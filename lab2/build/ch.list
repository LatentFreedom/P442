
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4825      	ldr	r0, [pc, #148]	; (8000298 <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	4824      	ldr	r0, [pc, #144]	; (800029c <endfiniloop+0x8>)
 800020a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800020e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000212:	6008      	str	r0, [r1, #0]
 8000214:	2002      	movs	r0, #2
 8000216:	f380 8814 	msr	CONTROL, r0
 800021a:	f3bf 8f6f 	isb	sy
 800021e:	f006 faef 	bl	8006800 <__core_init>
 8000222:	f003 ff9d 	bl	8004160 <__early_init>
 8000226:	481e      	ldr	r0, [pc, #120]	; (80002a0 <endfiniloop+0xc>)
 8000228:	491e      	ldr	r1, [pc, #120]	; (80002a4 <endfiniloop+0x10>)
 800022a:	4a1f      	ldr	r2, [pc, #124]	; (80002a8 <endfiniloop+0x14>)

0800022c <msloop>:
 800022c:	4291      	cmp	r1, r2
 800022e:	bf3c      	itt	cc
 8000230:	f841 0b04 	strcc.w	r0, [r1], #4
 8000234:	e7fa      	bcc.n	800022c <msloop>
 8000236:	491d      	ldr	r1, [pc, #116]	; (80002ac <endfiniloop+0x18>)
 8000238:	4a17      	ldr	r2, [pc, #92]	; (8000298 <endfiniloop+0x4>)

0800023a <psloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <psloop>
 8000244:	491a      	ldr	r1, [pc, #104]	; (80002b0 <endfiniloop+0x1c>)
 8000246:	4a1b      	ldr	r2, [pc, #108]	; (80002b4 <endfiniloop+0x20>)
 8000248:	4b1b      	ldr	r3, [pc, #108]	; (80002b8 <endfiniloop+0x24>)

0800024a <dloop>:
 800024a:	429a      	cmp	r2, r3
 800024c:	bf3e      	ittt	cc
 800024e:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000252:	f842 0b04 	strcc.w	r0, [r2], #4
 8000256:	e7f8      	bcc.n	800024a <dloop>
 8000258:	2000      	movs	r0, #0
 800025a:	4918      	ldr	r1, [pc, #96]	; (80002bc <endfiniloop+0x28>)
 800025c:	4a18      	ldr	r2, [pc, #96]	; (80002c0 <endfiniloop+0x2c>)

0800025e <bloop>:
 800025e:	4291      	cmp	r1, r2
 8000260:	bf3c      	itt	cc
 8000262:	f841 0b04 	strcc.w	r0, [r1], #4
 8000266:	e7fa      	bcc.n	800025e <bloop>
 8000268:	f006 fa92 	bl	8006790 <__init_ram_areas>
 800026c:	f006 fac0 	bl	80067f0 <__late_init>
 8000270:	4c14      	ldr	r4, [pc, #80]	; (80002c4 <endfiniloop+0x30>)
 8000272:	4d15      	ldr	r5, [pc, #84]	; (80002c8 <endfiniloop+0x34>)

08000274 <initloop>:
 8000274:	42ac      	cmp	r4, r5
 8000276:	da03      	bge.n	8000280 <endinitloop>
 8000278:	f854 1b04 	ldr.w	r1, [r4], #4
 800027c:	4788      	blx	r1
 800027e:	e7f9      	b.n	8000274 <initloop>

08000280 <endinitloop>:
 8000280:	f006 fcf6 	bl	8006c70 <main>
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x38>)
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x3c>)

08000288 <finiloop>:
 8000288:	42ac      	cmp	r4, r5
 800028a:	da03      	bge.n	8000294 <endfiniloop>
 800028c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000290:	4788      	blx	r1
 8000292:	e7f9      	b.n	8000288 <finiloop>

08000294 <endfiniloop>:
 8000294:	f006 baa4 	b.w	80067e0 <__default_exit>
 8000298:	20000800 	.word	0x20000800
 800029c:	08000000 	.word	0x08000000
 80002a0:	55555555 	.word	0x55555555
 80002a4:	20000000 	.word	0x20000000
 80002a8:	20000400 	.word	0x20000400
 80002ac:	20000400 	.word	0x20000400
 80002b0:	080090c4 	.word	0x080090c4
 80002b4:	20000800 	.word	0x20000800
 80002b8:	200008b0 	.word	0x200008b0
 80002bc:	200008b0 	.word	0x200008b0
 80002c0:	20001360 	.word	0x20001360
 80002c4:	08000200 	.word	0x08000200
 80002c8:	08000200 	.word	0x08000200
 80002cc:	08000200 	.word	0x08000200
 80002d0:	08000200 	.word	0x08000200

080002d4 <_port_switch>:
 80002d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002dc:	68c3      	ldr	r3, [r0, #12]
 80002de:	469d      	mov	sp, r3
 80002e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e4 <_port_thread_start>:
 80002e4:	2300      	movs	r3, #0
 80002e6:	f383 8811 	msr	BASEPRI, r3
 80002ea:	4628      	mov	r0, r5
 80002ec:	47a0      	blx	r4
 80002ee:	2000      	movs	r0, #0
 80002f0:	f006 f8d6 	bl	80064a0 <chThdExit>

080002f4 <_port_switch_from_isr>:
 80002f4:	f005 fe74 	bl	8005fe0 <chSchDoReschedule>

080002f8 <_port_exit_from_isr>:
 80002f8:	df00      	svc	0
 80002fa:	e7fe      	b.n	80002fa <_port_exit_from_isr+0x2>

080002fc <__aeabi_drsub>:
 80002fc:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 8000300:	e002      	b.n	8000308 <__adddf3>
 8000302:	bf00      	nop

08000304 <__aeabi_dsub>:
 8000304:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

08000308 <__adddf3>:
 8000308:	b530      	push	{r4, r5, lr}
 800030a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 800030e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 8000312:	ea94 0f05 	teq	r4, r5
 8000316:	bf08      	it	eq
 8000318:	ea90 0f02 	teqeq	r0, r2
 800031c:	bf1f      	itttt	ne
 800031e:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000322:	ea55 0c02 	orrsne.w	ip, r5, r2
 8000326:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800032a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 800032e:	f000 80e2 	beq.w	80004f6 <__adddf3+0x1ee>
 8000332:	ea4f 5454 	mov.w	r4, r4, lsr #21
 8000336:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800033a:	bfb8      	it	lt
 800033c:	426d      	neglt	r5, r5
 800033e:	dd0c      	ble.n	800035a <__adddf3+0x52>
 8000340:	442c      	add	r4, r5
 8000342:	ea80 0202 	eor.w	r2, r0, r2
 8000346:	ea81 0303 	eor.w	r3, r1, r3
 800034a:	ea82 0000 	eor.w	r0, r2, r0
 800034e:	ea83 0101 	eor.w	r1, r3, r1
 8000352:	ea80 0202 	eor.w	r2, r0, r2
 8000356:	ea81 0303 	eor.w	r3, r1, r3
 800035a:	2d36      	cmp	r5, #54	; 0x36
 800035c:	bf88      	it	hi
 800035e:	bd30      	pophi	{r4, r5, pc}
 8000360:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000364:	ea4f 3101 	mov.w	r1, r1, lsl #12
 8000368:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 800036c:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000370:	d002      	beq.n	8000378 <__adddf3+0x70>
 8000372:	4240      	negs	r0, r0
 8000374:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000378:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 800037c:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000380:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000384:	d002      	beq.n	800038c <__adddf3+0x84>
 8000386:	4252      	negs	r2, r2
 8000388:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 800038c:	ea94 0f05 	teq	r4, r5
 8000390:	f000 80a7 	beq.w	80004e2 <__adddf3+0x1da>
 8000394:	f1a4 0401 	sub.w	r4, r4, #1
 8000398:	f1d5 0e20 	rsbs	lr, r5, #32
 800039c:	db0d      	blt.n	80003ba <__adddf3+0xb2>
 800039e:	fa02 fc0e 	lsl.w	ip, r2, lr
 80003a2:	fa22 f205 	lsr.w	r2, r2, r5
 80003a6:	1880      	adds	r0, r0, r2
 80003a8:	f141 0100 	adc.w	r1, r1, #0
 80003ac:	fa03 f20e 	lsl.w	r2, r3, lr
 80003b0:	1880      	adds	r0, r0, r2
 80003b2:	fa43 f305 	asr.w	r3, r3, r5
 80003b6:	4159      	adcs	r1, r3
 80003b8:	e00e      	b.n	80003d8 <__adddf3+0xd0>
 80003ba:	f1a5 0520 	sub.w	r5, r5, #32
 80003be:	f10e 0e20 	add.w	lr, lr, #32
 80003c2:	2a01      	cmp	r2, #1
 80003c4:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003c8:	bf28      	it	cs
 80003ca:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003ce:	fa43 f305 	asr.w	r3, r3, r5
 80003d2:	18c0      	adds	r0, r0, r3
 80003d4:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003dc:	d507      	bpl.n	80003ee <__adddf3+0xe6>
 80003de:	f04f 0e00 	mov.w	lr, #0
 80003e2:	f1dc 0c00 	rsbs	ip, ip, #0
 80003e6:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003ea:	eb6e 0101 	sbc.w	r1, lr, r1
 80003ee:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003f2:	d31b      	bcc.n	800042c <__adddf3+0x124>
 80003f4:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003f8:	d30c      	bcc.n	8000414 <__adddf3+0x10c>
 80003fa:	0849      	lsrs	r1, r1, #1
 80003fc:	ea5f 0030 	movs.w	r0, r0, rrx
 8000400:	ea4f 0c3c 	mov.w	ip, ip, rrx
 8000404:	f104 0401 	add.w	r4, r4, #1
 8000408:	ea4f 5244 	mov.w	r2, r4, lsl #21
 800040c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 8000410:	f080 809a 	bcs.w	8000548 <__adddf3+0x240>
 8000414:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 8000418:	bf08      	it	eq
 800041a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 800041e:	f150 0000 	adcs.w	r0, r0, #0
 8000422:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000426:	ea41 0105 	orr.w	r1, r1, r5
 800042a:	bd30      	pop	{r4, r5, pc}
 800042c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000430:	4140      	adcs	r0, r0
 8000432:	eb41 0101 	adc.w	r1, r1, r1
 8000436:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800043a:	f1a4 0401 	sub.w	r4, r4, #1
 800043e:	d1e9      	bne.n	8000414 <__adddf3+0x10c>
 8000440:	f091 0f00 	teq	r1, #0
 8000444:	bf04      	itt	eq
 8000446:	4601      	moveq	r1, r0
 8000448:	2000      	moveq	r0, #0
 800044a:	fab1 f381 	clz	r3, r1
 800044e:	bf08      	it	eq
 8000450:	3320      	addeq	r3, #32
 8000452:	f1a3 030b 	sub.w	r3, r3, #11
 8000456:	f1b3 0220 	subs.w	r2, r3, #32
 800045a:	da0c      	bge.n	8000476 <__adddf3+0x16e>
 800045c:	320c      	adds	r2, #12
 800045e:	dd08      	ble.n	8000472 <__adddf3+0x16a>
 8000460:	f102 0c14 	add.w	ip, r2, #20
 8000464:	f1c2 020c 	rsb	r2, r2, #12
 8000468:	fa01 f00c 	lsl.w	r0, r1, ip
 800046c:	fa21 f102 	lsr.w	r1, r1, r2
 8000470:	e00c      	b.n	800048c <__adddf3+0x184>
 8000472:	f102 0214 	add.w	r2, r2, #20
 8000476:	bfd8      	it	le
 8000478:	f1c2 0c20 	rsble	ip, r2, #32
 800047c:	fa01 f102 	lsl.w	r1, r1, r2
 8000480:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000484:	bfdc      	itt	le
 8000486:	ea41 010c 	orrle.w	r1, r1, ip
 800048a:	4090      	lslle	r0, r2
 800048c:	1ae4      	subs	r4, r4, r3
 800048e:	bfa2      	ittt	ge
 8000490:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000494:	4329      	orrge	r1, r5
 8000496:	bd30      	popge	{r4, r5, pc}
 8000498:	ea6f 0404 	mvn.w	r4, r4
 800049c:	3c1f      	subs	r4, #31
 800049e:	da1c      	bge.n	80004da <__adddf3+0x1d2>
 80004a0:	340c      	adds	r4, #12
 80004a2:	dc0e      	bgt.n	80004c2 <__adddf3+0x1ba>
 80004a4:	f104 0414 	add.w	r4, r4, #20
 80004a8:	f1c4 0220 	rsb	r2, r4, #32
 80004ac:	fa20 f004 	lsr.w	r0, r0, r4
 80004b0:	fa01 f302 	lsl.w	r3, r1, r2
 80004b4:	ea40 0003 	orr.w	r0, r0, r3
 80004b8:	fa21 f304 	lsr.w	r3, r1, r4
 80004bc:	ea45 0103 	orr.w	r1, r5, r3
 80004c0:	bd30      	pop	{r4, r5, pc}
 80004c2:	f1c4 040c 	rsb	r4, r4, #12
 80004c6:	f1c4 0220 	rsb	r2, r4, #32
 80004ca:	fa20 f002 	lsr.w	r0, r0, r2
 80004ce:	fa01 f304 	lsl.w	r3, r1, r4
 80004d2:	ea40 0003 	orr.w	r0, r0, r3
 80004d6:	4629      	mov	r1, r5
 80004d8:	bd30      	pop	{r4, r5, pc}
 80004da:	fa21 f004 	lsr.w	r0, r1, r4
 80004de:	4629      	mov	r1, r5
 80004e0:	bd30      	pop	{r4, r5, pc}
 80004e2:	f094 0f00 	teq	r4, #0
 80004e6:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004ea:	bf06      	itte	eq
 80004ec:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004f0:	3401      	addeq	r4, #1
 80004f2:	3d01      	subne	r5, #1
 80004f4:	e74e      	b.n	8000394 <__adddf3+0x8c>
 80004f6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004fa:	bf18      	it	ne
 80004fc:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000500:	d029      	beq.n	8000556 <__adddf3+0x24e>
 8000502:	ea94 0f05 	teq	r4, r5
 8000506:	bf08      	it	eq
 8000508:	ea90 0f02 	teqeq	r0, r2
 800050c:	d005      	beq.n	800051a <__adddf3+0x212>
 800050e:	ea54 0c00 	orrs.w	ip, r4, r0
 8000512:	bf04      	itt	eq
 8000514:	4619      	moveq	r1, r3
 8000516:	4610      	moveq	r0, r2
 8000518:	bd30      	pop	{r4, r5, pc}
 800051a:	ea91 0f03 	teq	r1, r3
 800051e:	bf1e      	ittt	ne
 8000520:	2100      	movne	r1, #0
 8000522:	2000      	movne	r0, #0
 8000524:	bd30      	popne	{r4, r5, pc}
 8000526:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800052a:	d105      	bne.n	8000538 <__adddf3+0x230>
 800052c:	0040      	lsls	r0, r0, #1
 800052e:	4149      	adcs	r1, r1
 8000530:	bf28      	it	cs
 8000532:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 8000536:	bd30      	pop	{r4, r5, pc}
 8000538:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 800053c:	bf3c      	itt	cc
 800053e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000542:	bd30      	popcc	{r4, r5, pc}
 8000544:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 8000548:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 800054c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000550:	f04f 0000 	mov.w	r0, #0
 8000554:	bd30      	pop	{r4, r5, pc}
 8000556:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800055a:	bf1a      	itte	ne
 800055c:	4619      	movne	r1, r3
 800055e:	4610      	movne	r0, r2
 8000560:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000564:	bf1c      	itt	ne
 8000566:	460b      	movne	r3, r1
 8000568:	4602      	movne	r2, r0
 800056a:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 800056e:	bf06      	itte	eq
 8000570:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000574:	ea91 0f03 	teqeq	r1, r3
 8000578:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 800057c:	bd30      	pop	{r4, r5, pc}
 800057e:	bf00      	nop

08000580 <__aeabi_ui2d>:
 8000580:	f090 0f00 	teq	r0, #0
 8000584:	bf04      	itt	eq
 8000586:	2100      	moveq	r1, #0
 8000588:	4770      	bxeq	lr
 800058a:	b530      	push	{r4, r5, lr}
 800058c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000590:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000594:	f04f 0500 	mov.w	r5, #0
 8000598:	f04f 0100 	mov.w	r1, #0
 800059c:	e750      	b.n	8000440 <__adddf3+0x138>
 800059e:	bf00      	nop

080005a0 <__aeabi_i2d>:
 80005a0:	f090 0f00 	teq	r0, #0
 80005a4:	bf04      	itt	eq
 80005a6:	2100      	moveq	r1, #0
 80005a8:	4770      	bxeq	lr
 80005aa:	b530      	push	{r4, r5, lr}
 80005ac:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80005b0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80005b4:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80005b8:	bf48      	it	mi
 80005ba:	4240      	negmi	r0, r0
 80005bc:	f04f 0100 	mov.w	r1, #0
 80005c0:	e73e      	b.n	8000440 <__adddf3+0x138>
 80005c2:	bf00      	nop

080005c4 <__aeabi_f2d>:
 80005c4:	0042      	lsls	r2, r0, #1
 80005c6:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005ca:	ea4f 0131 	mov.w	r1, r1, rrx
 80005ce:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005d2:	bf1f      	itttt	ne
 80005d4:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005d8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005dc:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005e0:	4770      	bxne	lr
 80005e2:	f092 0f00 	teq	r2, #0
 80005e6:	bf14      	ite	ne
 80005e8:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005ec:	4770      	bxeq	lr
 80005ee:	b530      	push	{r4, r5, lr}
 80005f0:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005f4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005f8:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005fc:	e720      	b.n	8000440 <__adddf3+0x138>
 80005fe:	bf00      	nop

08000600 <__aeabi_ul2d>:
 8000600:	ea50 0201 	orrs.w	r2, r0, r1
 8000604:	bf08      	it	eq
 8000606:	4770      	bxeq	lr
 8000608:	b530      	push	{r4, r5, lr}
 800060a:	f04f 0500 	mov.w	r5, #0
 800060e:	e00a      	b.n	8000626 <__aeabi_l2d+0x16>

08000610 <__aeabi_l2d>:
 8000610:	ea50 0201 	orrs.w	r2, r0, r1
 8000614:	bf08      	it	eq
 8000616:	4770      	bxeq	lr
 8000618:	b530      	push	{r4, r5, lr}
 800061a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 800061e:	d502      	bpl.n	8000626 <__aeabi_l2d+0x16>
 8000620:	4240      	negs	r0, r0
 8000622:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 8000626:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800062a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 800062e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000632:	f43f aedc 	beq.w	80003ee <__adddf3+0xe6>
 8000636:	f04f 0203 	mov.w	r2, #3
 800063a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800063e:	bf18      	it	ne
 8000640:	3203      	addne	r2, #3
 8000642:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000646:	bf18      	it	ne
 8000648:	3203      	addne	r2, #3
 800064a:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 800064e:	f1c2 0320 	rsb	r3, r2, #32
 8000652:	fa00 fc03 	lsl.w	ip, r0, r3
 8000656:	fa20 f002 	lsr.w	r0, r0, r2
 800065a:	fa01 fe03 	lsl.w	lr, r1, r3
 800065e:	ea40 000e 	orr.w	r0, r0, lr
 8000662:	fa21 f102 	lsr.w	r1, r1, r2
 8000666:	4414      	add	r4, r2
 8000668:	e6c1      	b.n	80003ee <__adddf3+0xe6>
 800066a:	bf00      	nop

0800066c <__aeabi_dmul>:
 800066c:	b570      	push	{r4, r5, r6, lr}
 800066e:	f04f 0cff 	mov.w	ip, #255	; 0xff
 8000672:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 8000676:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 800067a:	bf1d      	ittte	ne
 800067c:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 8000680:	ea94 0f0c 	teqne	r4, ip
 8000684:	ea95 0f0c 	teqne	r5, ip
 8000688:	f000 f8de 	bleq	8000848 <__aeabi_dmul+0x1dc>
 800068c:	442c      	add	r4, r5
 800068e:	ea81 0603 	eor.w	r6, r1, r3
 8000692:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 8000696:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 800069a:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 800069e:	bf18      	it	ne
 80006a0:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80006a4:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80006a8:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80006ac:	d038      	beq.n	8000720 <__aeabi_dmul+0xb4>
 80006ae:	fba0 ce02 	umull	ip, lr, r0, r2
 80006b2:	f04f 0500 	mov.w	r5, #0
 80006b6:	fbe1 e502 	umlal	lr, r5, r1, r2
 80006ba:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80006be:	fbe0 e503 	umlal	lr, r5, r0, r3
 80006c2:	f04f 0600 	mov.w	r6, #0
 80006c6:	fbe1 5603 	umlal	r5, r6, r1, r3
 80006ca:	f09c 0f00 	teq	ip, #0
 80006ce:	bf18      	it	ne
 80006d0:	f04e 0e01 	orrne.w	lr, lr, #1
 80006d4:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80006d8:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80006dc:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80006e0:	d204      	bcs.n	80006ec <__aeabi_dmul+0x80>
 80006e2:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80006e6:	416d      	adcs	r5, r5
 80006e8:	eb46 0606 	adc.w	r6, r6, r6
 80006ec:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80006f0:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80006f4:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80006f8:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80006fc:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 8000700:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 8000704:	bf88      	it	hi
 8000706:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 800070a:	d81e      	bhi.n	800074a <__aeabi_dmul+0xde>
 800070c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 8000710:	bf08      	it	eq
 8000712:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 8000716:	f150 0000 	adcs.w	r0, r0, #0
 800071a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800071e:	bd70      	pop	{r4, r5, r6, pc}
 8000720:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 8000724:	ea46 0101 	orr.w	r1, r6, r1
 8000728:	ea40 0002 	orr.w	r0, r0, r2
 800072c:	ea81 0103 	eor.w	r1, r1, r3
 8000730:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 8000734:	bfc2      	ittt	gt
 8000736:	ebd4 050c 	rsbsgt	r5, r4, ip
 800073a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 800073e:	bd70      	popgt	{r4, r5, r6, pc}
 8000740:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000744:	f04f 0e00 	mov.w	lr, #0
 8000748:	3c01      	subs	r4, #1
 800074a:	f300 80ab 	bgt.w	80008a4 <__aeabi_dmul+0x238>
 800074e:	f114 0f36 	cmn.w	r4, #54	; 0x36
 8000752:	bfde      	ittt	le
 8000754:	2000      	movle	r0, #0
 8000756:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 800075a:	bd70      	pople	{r4, r5, r6, pc}
 800075c:	f1c4 0400 	rsb	r4, r4, #0
 8000760:	3c20      	subs	r4, #32
 8000762:	da35      	bge.n	80007d0 <__aeabi_dmul+0x164>
 8000764:	340c      	adds	r4, #12
 8000766:	dc1b      	bgt.n	80007a0 <__aeabi_dmul+0x134>
 8000768:	f104 0414 	add.w	r4, r4, #20
 800076c:	f1c4 0520 	rsb	r5, r4, #32
 8000770:	fa00 f305 	lsl.w	r3, r0, r5
 8000774:	fa20 f004 	lsr.w	r0, r0, r4
 8000778:	fa01 f205 	lsl.w	r2, r1, r5
 800077c:	ea40 0002 	orr.w	r0, r0, r2
 8000780:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 8000784:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 8000788:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 800078c:	fa21 f604 	lsr.w	r6, r1, r4
 8000790:	eb42 0106 	adc.w	r1, r2, r6
 8000794:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000798:	bf08      	it	eq
 800079a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 800079e:	bd70      	pop	{r4, r5, r6, pc}
 80007a0:	f1c4 040c 	rsb	r4, r4, #12
 80007a4:	f1c4 0520 	rsb	r5, r4, #32
 80007a8:	fa00 f304 	lsl.w	r3, r0, r4
 80007ac:	fa20 f005 	lsr.w	r0, r0, r5
 80007b0:	fa01 f204 	lsl.w	r2, r1, r4
 80007b4:	ea40 0002 	orr.w	r0, r0, r2
 80007b8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007bc:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80007c0:	f141 0100 	adc.w	r1, r1, #0
 80007c4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80007c8:	bf08      	it	eq
 80007ca:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80007ce:	bd70      	pop	{r4, r5, r6, pc}
 80007d0:	f1c4 0520 	rsb	r5, r4, #32
 80007d4:	fa00 f205 	lsl.w	r2, r0, r5
 80007d8:	ea4e 0e02 	orr.w	lr, lr, r2
 80007dc:	fa20 f304 	lsr.w	r3, r0, r4
 80007e0:	fa01 f205 	lsl.w	r2, r1, r5
 80007e4:	ea43 0302 	orr.w	r3, r3, r2
 80007e8:	fa21 f004 	lsr.w	r0, r1, r4
 80007ec:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80007f0:	fa21 f204 	lsr.w	r2, r1, r4
 80007f4:	ea20 0002 	bic.w	r0, r0, r2
 80007f8:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80007fc:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 8000800:	bf08      	it	eq
 8000802:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 8000806:	bd70      	pop	{r4, r5, r6, pc}
 8000808:	f094 0f00 	teq	r4, #0
 800080c:	d10f      	bne.n	800082e <__aeabi_dmul+0x1c2>
 800080e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 8000812:	0040      	lsls	r0, r0, #1
 8000814:	eb41 0101 	adc.w	r1, r1, r1
 8000818:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800081c:	bf08      	it	eq
 800081e:	3c01      	subeq	r4, #1
 8000820:	d0f7      	beq.n	8000812 <__aeabi_dmul+0x1a6>
 8000822:	ea41 0106 	orr.w	r1, r1, r6
 8000826:	f095 0f00 	teq	r5, #0
 800082a:	bf18      	it	ne
 800082c:	4770      	bxne	lr
 800082e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 8000832:	0052      	lsls	r2, r2, #1
 8000834:	eb43 0303 	adc.w	r3, r3, r3
 8000838:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 800083c:	bf08      	it	eq
 800083e:	3d01      	subeq	r5, #1
 8000840:	d0f7      	beq.n	8000832 <__aeabi_dmul+0x1c6>
 8000842:	ea43 0306 	orr.w	r3, r3, r6
 8000846:	4770      	bx	lr
 8000848:	ea94 0f0c 	teq	r4, ip
 800084c:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000850:	bf18      	it	ne
 8000852:	ea95 0f0c 	teqne	r5, ip
 8000856:	d00c      	beq.n	8000872 <__aeabi_dmul+0x206>
 8000858:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 800085c:	bf18      	it	ne
 800085e:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000862:	d1d1      	bne.n	8000808 <__aeabi_dmul+0x19c>
 8000864:	ea81 0103 	eor.w	r1, r1, r3
 8000868:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 800086c:	f04f 0000 	mov.w	r0, #0
 8000870:	bd70      	pop	{r4, r5, r6, pc}
 8000872:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000876:	bf06      	itte	eq
 8000878:	4610      	moveq	r0, r2
 800087a:	4619      	moveq	r1, r3
 800087c:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000880:	d019      	beq.n	80008b6 <__aeabi_dmul+0x24a>
 8000882:	ea94 0f0c 	teq	r4, ip
 8000886:	d102      	bne.n	800088e <__aeabi_dmul+0x222>
 8000888:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 800088c:	d113      	bne.n	80008b6 <__aeabi_dmul+0x24a>
 800088e:	ea95 0f0c 	teq	r5, ip
 8000892:	d105      	bne.n	80008a0 <__aeabi_dmul+0x234>
 8000894:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 8000898:	bf1c      	itt	ne
 800089a:	4610      	movne	r0, r2
 800089c:	4619      	movne	r1, r3
 800089e:	d10a      	bne.n	80008b6 <__aeabi_dmul+0x24a>
 80008a0:	ea81 0103 	eor.w	r1, r1, r3
 80008a4:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80008a8:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008ac:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80008b0:	f04f 0000 	mov.w	r0, #0
 80008b4:	bd70      	pop	{r4, r5, r6, pc}
 80008b6:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80008ba:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80008be:	bd70      	pop	{r4, r5, r6, pc}

080008c0 <__aeabi_ddiv>:
 80008c0:	b570      	push	{r4, r5, r6, lr}
 80008c2:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80008c6:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80008ca:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80008ce:	bf1d      	ittte	ne
 80008d0:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80008d4:	ea94 0f0c 	teqne	r4, ip
 80008d8:	ea95 0f0c 	teqne	r5, ip
 80008dc:	f000 f8a7 	bleq	8000a2e <__aeabi_ddiv+0x16e>
 80008e0:	eba4 0405 	sub.w	r4, r4, r5
 80008e4:	ea81 0e03 	eor.w	lr, r1, r3
 80008e8:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80008ec:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80008f0:	f000 8088 	beq.w	8000a04 <__aeabi_ddiv+0x144>
 80008f4:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80008f8:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80008fc:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 8000900:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 8000904:	ea4f 2202 	mov.w	r2, r2, lsl #8
 8000908:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 800090c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 8000910:	ea4f 2600 	mov.w	r6, r0, lsl #8
 8000914:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 8000918:	429d      	cmp	r5, r3
 800091a:	bf08      	it	eq
 800091c:	4296      	cmpeq	r6, r2
 800091e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 8000922:	f504 7440 	add.w	r4, r4, #768	; 0x300
 8000926:	d202      	bcs.n	800092e <__aeabi_ddiv+0x6e>
 8000928:	085b      	lsrs	r3, r3, #1
 800092a:	ea4f 0232 	mov.w	r2, r2, rrx
 800092e:	1ab6      	subs	r6, r6, r2
 8000930:	eb65 0503 	sbc.w	r5, r5, r3
 8000934:	085b      	lsrs	r3, r3, #1
 8000936:	ea4f 0232 	mov.w	r2, r2, rrx
 800093a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 800093e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 8000942:	ebb6 0e02 	subs.w	lr, r6, r2
 8000946:	eb75 0e03 	sbcs.w	lr, r5, r3
 800094a:	bf22      	ittt	cs
 800094c:	1ab6      	subcs	r6, r6, r2
 800094e:	4675      	movcs	r5, lr
 8000950:	ea40 000c 	orrcs.w	r0, r0, ip
 8000954:	085b      	lsrs	r3, r3, #1
 8000956:	ea4f 0232 	mov.w	r2, r2, rrx
 800095a:	ebb6 0e02 	subs.w	lr, r6, r2
 800095e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000962:	bf22      	ittt	cs
 8000964:	1ab6      	subcs	r6, r6, r2
 8000966:	4675      	movcs	r5, lr
 8000968:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 800096c:	085b      	lsrs	r3, r3, #1
 800096e:	ea4f 0232 	mov.w	r2, r2, rrx
 8000972:	ebb6 0e02 	subs.w	lr, r6, r2
 8000976:	eb75 0e03 	sbcs.w	lr, r5, r3
 800097a:	bf22      	ittt	cs
 800097c:	1ab6      	subcs	r6, r6, r2
 800097e:	4675      	movcs	r5, lr
 8000980:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 8000984:	085b      	lsrs	r3, r3, #1
 8000986:	ea4f 0232 	mov.w	r2, r2, rrx
 800098a:	ebb6 0e02 	subs.w	lr, r6, r2
 800098e:	eb75 0e03 	sbcs.w	lr, r5, r3
 8000992:	bf22      	ittt	cs
 8000994:	1ab6      	subcs	r6, r6, r2
 8000996:	4675      	movcs	r5, lr
 8000998:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 800099c:	ea55 0e06 	orrs.w	lr, r5, r6
 80009a0:	d018      	beq.n	80009d4 <__aeabi_ddiv+0x114>
 80009a2:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80009a6:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80009aa:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80009ae:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80009b2:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80009b6:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80009ba:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80009be:	d1c0      	bne.n	8000942 <__aeabi_ddiv+0x82>
 80009c0:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009c4:	d10b      	bne.n	80009de <__aeabi_ddiv+0x11e>
 80009c6:	ea41 0100 	orr.w	r1, r1, r0
 80009ca:	f04f 0000 	mov.w	r0, #0
 80009ce:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80009d2:	e7b6      	b.n	8000942 <__aeabi_ddiv+0x82>
 80009d4:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80009d8:	bf04      	itt	eq
 80009da:	4301      	orreq	r1, r0
 80009dc:	2000      	moveq	r0, #0
 80009de:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80009e2:	bf88      	it	hi
 80009e4:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80009e8:	f63f aeaf 	bhi.w	800074a <__aeabi_dmul+0xde>
 80009ec:	ebb5 0c03 	subs.w	ip, r5, r3
 80009f0:	bf04      	itt	eq
 80009f2:	ebb6 0c02 	subseq.w	ip, r6, r2
 80009f6:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80009fa:	f150 0000 	adcs.w	r0, r0, #0
 80009fe:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 8000a02:	bd70      	pop	{r4, r5, r6, pc}
 8000a04:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 8000a08:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 8000a0c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 8000a10:	bfc2      	ittt	gt
 8000a12:	ebd4 050c 	rsbsgt	r5, r4, ip
 8000a16:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 8000a1a:	bd70      	popgt	{r4, r5, r6, pc}
 8000a1c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000a20:	f04f 0e00 	mov.w	lr, #0
 8000a24:	3c01      	subs	r4, #1
 8000a26:	e690      	b.n	800074a <__aeabi_dmul+0xde>
 8000a28:	ea45 0e06 	orr.w	lr, r5, r6
 8000a2c:	e68d      	b.n	800074a <__aeabi_dmul+0xde>
 8000a2e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 8000a32:	ea94 0f0c 	teq	r4, ip
 8000a36:	bf08      	it	eq
 8000a38:	ea95 0f0c 	teqeq	r5, ip
 8000a3c:	f43f af3b 	beq.w	80008b6 <__aeabi_dmul+0x24a>
 8000a40:	ea94 0f0c 	teq	r4, ip
 8000a44:	d10a      	bne.n	8000a5c <__aeabi_ddiv+0x19c>
 8000a46:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000a4a:	f47f af34 	bne.w	80008b6 <__aeabi_dmul+0x24a>
 8000a4e:	ea95 0f0c 	teq	r5, ip
 8000a52:	f47f af25 	bne.w	80008a0 <__aeabi_dmul+0x234>
 8000a56:	4610      	mov	r0, r2
 8000a58:	4619      	mov	r1, r3
 8000a5a:	e72c      	b.n	80008b6 <__aeabi_dmul+0x24a>
 8000a5c:	ea95 0f0c 	teq	r5, ip
 8000a60:	d106      	bne.n	8000a70 <__aeabi_ddiv+0x1b0>
 8000a62:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 8000a66:	f43f aefd 	beq.w	8000864 <__aeabi_dmul+0x1f8>
 8000a6a:	4610      	mov	r0, r2
 8000a6c:	4619      	mov	r1, r3
 8000a6e:	e722      	b.n	80008b6 <__aeabi_dmul+0x24a>
 8000a70:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 8000a74:	bf18      	it	ne
 8000a76:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 8000a7a:	f47f aec5 	bne.w	8000808 <__aeabi_dmul+0x19c>
 8000a7e:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 8000a82:	f47f af0d 	bne.w	80008a0 <__aeabi_dmul+0x234>
 8000a86:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 8000a8a:	f47f aeeb 	bne.w	8000864 <__aeabi_dmul+0x1f8>
 8000a8e:	e712      	b.n	80008b6 <__aeabi_dmul+0x24a>

08000a90 <__aeabi_d2iz>:
 8000a90:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000a94:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 8000a98:	d215      	bcs.n	8000ac6 <__aeabi_d2iz+0x36>
 8000a9a:	d511      	bpl.n	8000ac0 <__aeabi_d2iz+0x30>
 8000a9c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 8000aa0:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 8000aa4:	d912      	bls.n	8000acc <__aeabi_d2iz+0x3c>
 8000aa6:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000aaa:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000aae:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 8000ab2:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000ab6:	fa23 f002 	lsr.w	r0, r3, r2
 8000aba:	bf18      	it	ne
 8000abc:	4240      	negne	r0, r0
 8000abe:	4770      	bx	lr
 8000ac0:	f04f 0000 	mov.w	r0, #0
 8000ac4:	4770      	bx	lr
 8000ac6:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 8000aca:	d105      	bne.n	8000ad8 <__aeabi_d2iz+0x48>
 8000acc:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 8000ad0:	bf08      	it	eq
 8000ad2:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000ad6:	4770      	bx	lr
 8000ad8:	f04f 0000 	mov.w	r0, #0
 8000adc:	4770      	bx	lr
 8000ade:	bf00      	nop

08000ae0 <__aeabi_d2f>:
 8000ae0:	ea4f 0241 	mov.w	r2, r1, lsl #1
 8000ae4:	f1b2 43e0 	subs.w	r3, r2, #1879048192	; 0x70000000
 8000ae8:	bf24      	itt	cs
 8000aea:	f5b3 1c00 	subscs.w	ip, r3, #2097152	; 0x200000
 8000aee:	f1dc 5cfe 	rsbscs	ip, ip, #532676608	; 0x1fc00000
 8000af2:	d90d      	bls.n	8000b10 <__aeabi_d2f+0x30>
 8000af4:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 8000af8:	ea4f 02c0 	mov.w	r2, r0, lsl #3
 8000afc:	ea4c 7050 	orr.w	r0, ip, r0, lsr #29
 8000b00:	f1b2 4f00 	cmp.w	r2, #2147483648	; 0x80000000
 8000b04:	eb40 0083 	adc.w	r0, r0, r3, lsl #2
 8000b08:	bf08      	it	eq
 8000b0a:	f020 0001 	biceq.w	r0, r0, #1
 8000b0e:	4770      	bx	lr
 8000b10:	f011 4f80 	tst.w	r1, #1073741824	; 0x40000000
 8000b14:	d121      	bne.n	8000b5a <__aeabi_d2f+0x7a>
 8000b16:	f113 7238 	adds.w	r2, r3, #48234496	; 0x2e00000
 8000b1a:	bfbc      	itt	lt
 8000b1c:	f001 4000 	andlt.w	r0, r1, #2147483648	; 0x80000000
 8000b20:	4770      	bxlt	lr
 8000b22:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 8000b26:	ea4f 5252 	mov.w	r2, r2, lsr #21
 8000b2a:	f1c2 0218 	rsb	r2, r2, #24
 8000b2e:	f1c2 0c20 	rsb	ip, r2, #32
 8000b32:	fa10 f30c 	lsls.w	r3, r0, ip
 8000b36:	fa20 f002 	lsr.w	r0, r0, r2
 8000b3a:	bf18      	it	ne
 8000b3c:	f040 0001 	orrne.w	r0, r0, #1
 8000b40:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 8000b44:	ea4f 23d3 	mov.w	r3, r3, lsr #11
 8000b48:	fa03 fc0c 	lsl.w	ip, r3, ip
 8000b4c:	ea40 000c 	orr.w	r0, r0, ip
 8000b50:	fa23 f302 	lsr.w	r3, r3, r2
 8000b54:	ea4f 0343 	mov.w	r3, r3, lsl #1
 8000b58:	e7cc      	b.n	8000af4 <__aeabi_d2f+0x14>
 8000b5a:	ea7f 5362 	mvns.w	r3, r2, asr #21
 8000b5e:	d107      	bne.n	8000b70 <__aeabi_d2f+0x90>
 8000b60:	ea50 3301 	orrs.w	r3, r0, r1, lsl #12
 8000b64:	bf1e      	ittt	ne
 8000b66:	f04f 40fe 	movne.w	r0, #2130706432	; 0x7f000000
 8000b6a:	f440 0040 	orrne.w	r0, r0, #12582912	; 0xc00000
 8000b6e:	4770      	bxne	lr
 8000b70:	f001 4000 	and.w	r0, r1, #2147483648	; 0x80000000
 8000b74:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 8000b78:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 8000b7c:	4770      	bx	lr
 8000b7e:	bf00      	nop

08000b80 <__gesf2>:
 8000b80:	f04f 3cff 	mov.w	ip, #4294967295
 8000b84:	e006      	b.n	8000b94 <__cmpsf2+0x4>
 8000b86:	bf00      	nop

08000b88 <__lesf2>:
 8000b88:	f04f 0c01 	mov.w	ip, #1
 8000b8c:	e002      	b.n	8000b94 <__cmpsf2+0x4>
 8000b8e:	bf00      	nop

08000b90 <__cmpsf2>:
 8000b90:	f04f 0c01 	mov.w	ip, #1
 8000b94:	f84d cd04 	str.w	ip, [sp, #-4]!
 8000b98:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000b9c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 8000ba0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000ba4:	bf18      	it	ne
 8000ba6:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 8000baa:	d011      	beq.n	8000bd0 <__cmpsf2+0x40>
 8000bac:	b001      	add	sp, #4
 8000bae:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 8000bb2:	bf18      	it	ne
 8000bb4:	ea90 0f01 	teqne	r0, r1
 8000bb8:	bf58      	it	pl
 8000bba:	ebb2 0003 	subspl.w	r0, r2, r3
 8000bbe:	bf88      	it	hi
 8000bc0:	17c8      	asrhi	r0, r1, #31
 8000bc2:	bf38      	it	cc
 8000bc4:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 8000bc8:	bf18      	it	ne
 8000bca:	f040 0001 	orrne.w	r0, r0, #1
 8000bce:	4770      	bx	lr
 8000bd0:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 8000bd4:	d102      	bne.n	8000bdc <__cmpsf2+0x4c>
 8000bd6:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 8000bda:	d105      	bne.n	8000be8 <__cmpsf2+0x58>
 8000bdc:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 8000be0:	d1e4      	bne.n	8000bac <__cmpsf2+0x1c>
 8000be2:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 8000be6:	d0e1      	beq.n	8000bac <__cmpsf2+0x1c>
 8000be8:	f85d 0b04 	ldr.w	r0, [sp], #4
 8000bec:	4770      	bx	lr
 8000bee:	bf00      	nop

08000bf0 <__aeabi_cfrcmple>:
 8000bf0:	4684      	mov	ip, r0
 8000bf2:	4608      	mov	r0, r1
 8000bf4:	4661      	mov	r1, ip
 8000bf6:	e7ff      	b.n	8000bf8 <__aeabi_cfcmpeq>

08000bf8 <__aeabi_cfcmpeq>:
 8000bf8:	b50f      	push	{r0, r1, r2, r3, lr}
 8000bfa:	f7ff ffc9 	bl	8000b90 <__cmpsf2>
 8000bfe:	2800      	cmp	r0, #0
 8000c00:	bf48      	it	mi
 8000c02:	f110 0f00 	cmnmi.w	r0, #0
 8000c06:	bd0f      	pop	{r0, r1, r2, r3, pc}

08000c08 <__aeabi_fcmpeq>:
 8000c08:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c0c:	f7ff fff4 	bl	8000bf8 <__aeabi_cfcmpeq>
 8000c10:	bf0c      	ite	eq
 8000c12:	2001      	moveq	r0, #1
 8000c14:	2000      	movne	r0, #0
 8000c16:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c1a:	bf00      	nop

08000c1c <__aeabi_fcmplt>:
 8000c1c:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c20:	f7ff ffea 	bl	8000bf8 <__aeabi_cfcmpeq>
 8000c24:	bf34      	ite	cc
 8000c26:	2001      	movcc	r0, #1
 8000c28:	2000      	movcs	r0, #0
 8000c2a:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c2e:	bf00      	nop

08000c30 <__aeabi_fcmple>:
 8000c30:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c34:	f7ff ffe0 	bl	8000bf8 <__aeabi_cfcmpeq>
 8000c38:	bf94      	ite	ls
 8000c3a:	2001      	movls	r0, #1
 8000c3c:	2000      	movhi	r0, #0
 8000c3e:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c42:	bf00      	nop

08000c44 <__aeabi_fcmpge>:
 8000c44:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c48:	f7ff ffd2 	bl	8000bf0 <__aeabi_cfrcmple>
 8000c4c:	bf94      	ite	ls
 8000c4e:	2001      	movls	r0, #1
 8000c50:	2000      	movhi	r0, #0
 8000c52:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c56:	bf00      	nop

08000c58 <__aeabi_fcmpgt>:
 8000c58:	f84d ed08 	str.w	lr, [sp, #-8]!
 8000c5c:	f7ff ffc8 	bl	8000bf0 <__aeabi_cfrcmple>
 8000c60:	bf34      	ite	cc
 8000c62:	2001      	movcc	r0, #1
 8000c64:	2000      	movcs	r0, #0
 8000c66:	f85d fb08 	ldr.w	pc, [sp], #8
 8000c6a:	bf00      	nop

08000c6c <__aeabi_f2iz>:
 8000c6c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 8000c70:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 8000c74:	d30f      	bcc.n	8000c96 <__aeabi_f2iz+0x2a>
 8000c76:	f04f 039e 	mov.w	r3, #158	; 0x9e
 8000c7a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 8000c7e:	d90d      	bls.n	8000c9c <__aeabi_f2iz+0x30>
 8000c80:	ea4f 2300 	mov.w	r3, r0, lsl #8
 8000c84:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8000c88:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 8000c8c:	fa23 f002 	lsr.w	r0, r3, r2
 8000c90:	bf18      	it	ne
 8000c92:	4240      	negne	r0, r0
 8000c94:	4770      	bx	lr
 8000c96:	f04f 0000 	mov.w	r0, #0
 8000c9a:	4770      	bx	lr
 8000c9c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 8000ca0:	d101      	bne.n	8000ca6 <__aeabi_f2iz+0x3a>
 8000ca2:	0242      	lsls	r2, r0, #9
 8000ca4:	d105      	bne.n	8000cb2 <__aeabi_f2iz+0x46>
 8000ca6:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 8000caa:	bf08      	it	eq
 8000cac:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8000cb0:	4770      	bx	lr
 8000cb2:	f04f 0000 	mov.w	r0, #0
 8000cb6:	4770      	bx	lr
	...
 8000cc0:	eba2 0003 	sub.w	r0, r2, r3
 8000cc4:	4770      	bx	lr
 8000cc6:	bf00      	nop

08000cc8 <strcmp>:
 8000cc8:	7802      	ldrb	r2, [r0, #0]
 8000cca:	780b      	ldrb	r3, [r1, #0]
 8000ccc:	2a01      	cmp	r2, #1
 8000cce:	bf28      	it	cs
 8000cd0:	429a      	cmpcs	r2, r3
 8000cd2:	d1f5      	bne.n	8000cc0 <__aeabi_f2iz+0x54>
 8000cd4:	e96d 4504 	strd	r4, r5, [sp, #-16]!
 8000cd8:	ea40 0401 	orr.w	r4, r0, r1
 8000cdc:	e9cd 6702 	strd	r6, r7, [sp, #8]
 8000ce0:	f06f 0c00 	mvn.w	ip, #0
 8000ce4:	ea4f 7244 	mov.w	r2, r4, lsl #29
 8000ce8:	b312      	cbz	r2, 8000d30 <strcmp+0x68>
 8000cea:	ea80 0401 	eor.w	r4, r0, r1
 8000cee:	f014 0f07 	tst.w	r4, #7
 8000cf2:	d16a      	bne.n	8000dca <strcmp+0x102>
 8000cf4:	f000 0407 	and.w	r4, r0, #7
 8000cf8:	f020 0007 	bic.w	r0, r0, #7
 8000cfc:	f004 0503 	and.w	r5, r4, #3
 8000d00:	f021 0107 	bic.w	r1, r1, #7
 8000d04:	ea4f 05c5 	mov.w	r5, r5, lsl #3
 8000d08:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000d0c:	f014 0f04 	tst.w	r4, #4
 8000d10:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000d14:	fa0c f405 	lsl.w	r4, ip, r5
 8000d18:	ea62 0204 	orn	r2, r2, r4
 8000d1c:	ea66 0604 	orn	r6, r6, r4
 8000d20:	d00a      	beq.n	8000d38 <strcmp+0x70>
 8000d22:	ea63 0304 	orn	r3, r3, r4
 8000d26:	4662      	mov	r2, ip
 8000d28:	ea67 0704 	orn	r7, r7, r4
 8000d2c:	4666      	mov	r6, ip
 8000d2e:	e003      	b.n	8000d38 <strcmp+0x70>
 8000d30:	e8f0 2304 	ldrd	r2, r3, [r0], #16
 8000d34:	e8f1 6704 	ldrd	r6, r7, [r1], #16
 8000d38:	fa82 f54c 	uadd8	r5, r2, ip
 8000d3c:	ea82 0406 	eor.w	r4, r2, r6
 8000d40:	faa4 f48c 	sel	r4, r4, ip
 8000d44:	bb6c      	cbnz	r4, 8000da2 <strcmp+0xda>
 8000d46:	fa83 f54c 	uadd8	r5, r3, ip
 8000d4a:	ea83 0507 	eor.w	r5, r3, r7
 8000d4e:	faa5 f58c 	sel	r5, r5, ip
 8000d52:	b995      	cbnz	r5, 8000d7a <strcmp+0xb2>
 8000d54:	e950 2302 	ldrd	r2, r3, [r0, #-8]
 8000d58:	e951 6702 	ldrd	r6, r7, [r1, #-8]
 8000d5c:	fa82 f54c 	uadd8	r5, r2, ip
 8000d60:	ea82 0406 	eor.w	r4, r2, r6
 8000d64:	faa4 f48c 	sel	r4, r4, ip
 8000d68:	fa83 f54c 	uadd8	r5, r3, ip
 8000d6c:	ea83 0507 	eor.w	r5, r3, r7
 8000d70:	faa5 f58c 	sel	r5, r5, ip
 8000d74:	4325      	orrs	r5, r4
 8000d76:	d0db      	beq.n	8000d30 <strcmp+0x68>
 8000d78:	b99c      	cbnz	r4, 8000da2 <strcmp+0xda>
 8000d7a:	ba2d      	rev	r5, r5
 8000d7c:	fab5 f485 	clz	r4, r5
 8000d80:	f024 0407 	bic.w	r4, r4, #7
 8000d84:	fa27 f104 	lsr.w	r1, r7, r4
 8000d88:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000d8c:	fa23 f304 	lsr.w	r3, r3, r4
 8000d90:	f003 00ff 	and.w	r0, r3, #255	; 0xff
 8000d94:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000d98:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000d9c:	eba0 0001 	sub.w	r0, r0, r1
 8000da0:	4770      	bx	lr
 8000da2:	ba24      	rev	r4, r4
 8000da4:	fab4 f484 	clz	r4, r4
 8000da8:	f024 0407 	bic.w	r4, r4, #7
 8000dac:	fa26 f104 	lsr.w	r1, r6, r4
 8000db0:	e9dd 6702 	ldrd	r6, r7, [sp, #8]
 8000db4:	fa22 f204 	lsr.w	r2, r2, r4
 8000db8:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8000dbc:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000dc0:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000dc4:	eba0 0001 	sub.w	r0, r0, r1
 8000dc8:	4770      	bx	lr
 8000dca:	f014 0f03 	tst.w	r4, #3
 8000dce:	d13c      	bne.n	8000e4a <strcmp+0x182>
 8000dd0:	f010 0403 	ands.w	r4, r0, #3
 8000dd4:	d128      	bne.n	8000e28 <strcmp+0x160>
 8000dd6:	f850 2b08 	ldr.w	r2, [r0], #8
 8000dda:	f851 3b08 	ldr.w	r3, [r1], #8
 8000dde:	fa82 f54c 	uadd8	r5, r2, ip
 8000de2:	ea82 0503 	eor.w	r5, r2, r3
 8000de6:	faa5 f58c 	sel	r5, r5, ip
 8000dea:	b95d      	cbnz	r5, 8000e04 <strcmp+0x13c>
 8000dec:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8000df0:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8000df4:	fa82 f54c 	uadd8	r5, r2, ip
 8000df8:	ea82 0503 	eor.w	r5, r2, r3
 8000dfc:	faa5 f58c 	sel	r5, r5, ip
 8000e00:	2d00      	cmp	r5, #0
 8000e02:	d0e8      	beq.n	8000dd6 <strcmp+0x10e>
 8000e04:	ba2d      	rev	r5, r5
 8000e06:	fab5 f485 	clz	r4, r5
 8000e0a:	f024 0407 	bic.w	r4, r4, #7
 8000e0e:	fa23 f104 	lsr.w	r1, r3, r4
 8000e12:	fa22 f204 	lsr.w	r2, r2, r4
 8000e16:	f002 00ff 	and.w	r0, r2, #255	; 0xff
 8000e1a:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000e1e:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000e22:	eba0 0001 	sub.w	r0, r0, r1
 8000e26:	4770      	bx	lr
 8000e28:	ea4f 04c4 	mov.w	r4, r4, lsl #3
 8000e2c:	f020 0003 	bic.w	r0, r0, #3
 8000e30:	f850 2b08 	ldr.w	r2, [r0], #8
 8000e34:	f021 0103 	bic.w	r1, r1, #3
 8000e38:	f851 3b08 	ldr.w	r3, [r1], #8
 8000e3c:	fa0c f404 	lsl.w	r4, ip, r4
 8000e40:	ea62 0204 	orn	r2, r2, r4
 8000e44:	ea63 0304 	orn	r3, r3, r4
 8000e48:	e7c9      	b.n	8000dde <strcmp+0x116>
 8000e4a:	f010 0403 	ands.w	r4, r0, #3
 8000e4e:	d01a      	beq.n	8000e86 <strcmp+0x1be>
 8000e50:	eba1 0104 	sub.w	r1, r1, r4
 8000e54:	f020 0003 	bic.w	r0, r0, #3
 8000e58:	07e4      	lsls	r4, r4, #31
 8000e5a:	f850 2b04 	ldr.w	r2, [r0], #4
 8000e5e:	d006      	beq.n	8000e6e <strcmp+0x1a6>
 8000e60:	d20f      	bcs.n	8000e82 <strcmp+0x1ba>
 8000e62:	788b      	ldrb	r3, [r1, #2]
 8000e64:	fa5f f4a2 	uxtb.w	r4, r2, ror #16
 8000e68:	1ae4      	subs	r4, r4, r3
 8000e6a:	d106      	bne.n	8000e7a <strcmp+0x1b2>
 8000e6c:	b12b      	cbz	r3, 8000e7a <strcmp+0x1b2>
 8000e6e:	78cb      	ldrb	r3, [r1, #3]
 8000e70:	fa5f f4b2 	uxtb.w	r4, r2, ror #24
 8000e74:	1ae4      	subs	r4, r4, r3
 8000e76:	d100      	bne.n	8000e7a <strcmp+0x1b2>
 8000e78:	b91b      	cbnz	r3, 8000e82 <strcmp+0x1ba>
 8000e7a:	4620      	mov	r0, r4
 8000e7c:	f85d 4b10 	ldr.w	r4, [sp], #16
 8000e80:	4770      	bx	lr
 8000e82:	f101 0104 	add.w	r1, r1, #4
 8000e86:	f850 2b04 	ldr.w	r2, [r0], #4
 8000e8a:	07cc      	lsls	r4, r1, #31
 8000e8c:	f021 0103 	bic.w	r1, r1, #3
 8000e90:	f851 3b04 	ldr.w	r3, [r1], #4
 8000e94:	d848      	bhi.n	8000f28 <strcmp+0x260>
 8000e96:	d224      	bcs.n	8000ee2 <strcmp+0x21a>
 8000e98:	f022 447f 	bic.w	r4, r2, #4278190080	; 0xff000000
 8000e9c:	fa82 f54c 	uadd8	r5, r2, ip
 8000ea0:	ea94 2513 	eors.w	r5, r4, r3, lsr #8
 8000ea4:	faa5 f58c 	sel	r5, r5, ip
 8000ea8:	d10a      	bne.n	8000ec0 <strcmp+0x1f8>
 8000eaa:	b965      	cbnz	r5, 8000ec6 <strcmp+0x1fe>
 8000eac:	f851 3b04 	ldr.w	r3, [r1], #4
 8000eb0:	ea84 0402 	eor.w	r4, r4, r2
 8000eb4:	ebb4 6f03 	cmp.w	r4, r3, lsl #24
 8000eb8:	d10e      	bne.n	8000ed8 <strcmp+0x210>
 8000eba:	f850 2b04 	ldr.w	r2, [r0], #4
 8000ebe:	e7eb      	b.n	8000e98 <strcmp+0x1d0>
 8000ec0:	ea4f 2313 	mov.w	r3, r3, lsr #8
 8000ec4:	e055      	b.n	8000f72 <strcmp+0x2aa>
 8000ec6:	f035 457f 	bics.w	r5, r5, #4278190080	; 0xff000000
 8000eca:	d14d      	bne.n	8000f68 <strcmp+0x2a0>
 8000ecc:	7808      	ldrb	r0, [r1, #0]
 8000ece:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000ed2:	f1c0 0000 	rsb	r0, r0, #0
 8000ed6:	4770      	bx	lr
 8000ed8:	ea4f 6212 	mov.w	r2, r2, lsr #24
 8000edc:	f003 03ff 	and.w	r3, r3, #255	; 0xff
 8000ee0:	e047      	b.n	8000f72 <strcmp+0x2aa>
 8000ee2:	ea02 441c 	and.w	r4, r2, ip, lsr #16
 8000ee6:	fa82 f54c 	uadd8	r5, r2, ip
 8000eea:	ea94 4513 	eors.w	r5, r4, r3, lsr #16
 8000eee:	faa5 f58c 	sel	r5, r5, ip
 8000ef2:	d10a      	bne.n	8000f0a <strcmp+0x242>
 8000ef4:	b965      	cbnz	r5, 8000f10 <strcmp+0x248>
 8000ef6:	f851 3b04 	ldr.w	r3, [r1], #4
 8000efa:	ea84 0402 	eor.w	r4, r4, r2
 8000efe:	ebb4 4f03 	cmp.w	r4, r3, lsl #16
 8000f02:	d10c      	bne.n	8000f1e <strcmp+0x256>
 8000f04:	f850 2b04 	ldr.w	r2, [r0], #4
 8000f08:	e7eb      	b.n	8000ee2 <strcmp+0x21a>
 8000f0a:	ea4f 4313 	mov.w	r3, r3, lsr #16
 8000f0e:	e030      	b.n	8000f72 <strcmp+0x2aa>
 8000f10:	ea15 451c 	ands.w	r5, r5, ip, lsr #16
 8000f14:	d128      	bne.n	8000f68 <strcmp+0x2a0>
 8000f16:	880b      	ldrh	r3, [r1, #0]
 8000f18:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000f1c:	e029      	b.n	8000f72 <strcmp+0x2aa>
 8000f1e:	ea4f 4212 	mov.w	r2, r2, lsr #16
 8000f22:	ea03 431c 	and.w	r3, r3, ip, lsr #16
 8000f26:	e024      	b.n	8000f72 <strcmp+0x2aa>
 8000f28:	f002 04ff 	and.w	r4, r2, #255	; 0xff
 8000f2c:	fa82 f54c 	uadd8	r5, r2, ip
 8000f30:	ea94 6513 	eors.w	r5, r4, r3, lsr #24
 8000f34:	faa5 f58c 	sel	r5, r5, ip
 8000f38:	d10a      	bne.n	8000f50 <strcmp+0x288>
 8000f3a:	b965      	cbnz	r5, 8000f56 <strcmp+0x28e>
 8000f3c:	f851 3b04 	ldr.w	r3, [r1], #4
 8000f40:	ea84 0402 	eor.w	r4, r4, r2
 8000f44:	ebb4 2f03 	cmp.w	r4, r3, lsl #8
 8000f48:	d109      	bne.n	8000f5e <strcmp+0x296>
 8000f4a:	f850 2b04 	ldr.w	r2, [r0], #4
 8000f4e:	e7eb      	b.n	8000f28 <strcmp+0x260>
 8000f50:	ea4f 6313 	mov.w	r3, r3, lsr #24
 8000f54:	e00d      	b.n	8000f72 <strcmp+0x2aa>
 8000f56:	f015 0fff 	tst.w	r5, #255	; 0xff
 8000f5a:	d105      	bne.n	8000f68 <strcmp+0x2a0>
 8000f5c:	680b      	ldr	r3, [r1, #0]
 8000f5e:	ea4f 2212 	mov.w	r2, r2, lsr #8
 8000f62:	f023 437f 	bic.w	r3, r3, #4278190080	; 0xff000000
 8000f66:	e004      	b.n	8000f72 <strcmp+0x2aa>
 8000f68:	f04f 0000 	mov.w	r0, #0
 8000f6c:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000f70:	4770      	bx	lr
 8000f72:	ba12      	rev	r2, r2
 8000f74:	ba1b      	rev	r3, r3
 8000f76:	fa82 f44c 	uadd8	r4, r2, ip
 8000f7a:	ea82 0403 	eor.w	r4, r2, r3
 8000f7e:	faa4 f58c 	sel	r5, r4, ip
 8000f82:	fab5 f485 	clz	r4, r5
 8000f86:	fa02 f204 	lsl.w	r2, r2, r4
 8000f8a:	fa03 f304 	lsl.w	r3, r3, r4
 8000f8e:	ea4f 6012 	mov.w	r0, r2, lsr #24
 8000f92:	e8fd 4504 	ldrd	r4, r5, [sp], #16
 8000f96:	eba0 6013 	sub.w	r0, r0, r3, lsr #24
 8000f9a:	4770      	bx	lr
 8000f9c:	f3af 8000 	nop.w

08000fa0 <test_008_002_setup.lto_priv.169>:
 * - [8.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_008_002_setup(void) {
 8000fa0:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8000fa2:	4b0b      	ldr	r3, [pc, #44]	; (8000fd0 <test_008_002_setup.lto_priv.169+0x30>)
 8000fa4:	4a0b      	ldr	r2, [pc, #44]	; (8000fd4 <test_008_002_setup.lto_priv.169+0x34>)
 8000fa6:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8000fa8:	f102 0610 	add.w	r6, r2, #16
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8000fac:	2504      	movs	r5, #4
 8000fae:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000fb0:	f103 001c 	add.w	r0, r3, #28
 8000fb4:	f103 0110 	add.w	r1, r3, #16
 8000fb8:	605e      	str	r6, [r3, #4]
 8000fba:	625d      	str	r5, [r3, #36]	; 0x24
 8000fbc:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 8000fbe:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8000fc0:	609a      	str	r2, [r3, #8]
 8000fc2:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8000fc4:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000fc6:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8000fc8:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8000fca:	bc70      	pop	{r4, r5, r6}
 8000fcc:	4770      	bx	lr
 8000fce:	bf00      	nop
 8000fd0:	20000868 	.word	0x20000868
 8000fd4:	20001290 	.word	0x20001290
 8000fd8:	f3af 8000 	nop.w
 8000fdc:	f3af 8000 	nop.w

08000fe0 <test_008_001_setup.lto_priv.166>:
 * - [8.1.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_008_001_setup(void) {
 8000fe0:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8000fe2:	4b0b      	ldr	r3, [pc, #44]	; (8001010 <test_008_001_setup.lto_priv.166+0x30>)
 8000fe4:	4a0b      	ldr	r2, [pc, #44]	; (8001014 <test_008_001_setup.lto_priv.166+0x34>)
 8000fe6:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8000fe8:	f102 0610 	add.w	r6, r2, #16
 8000fec:	2504      	movs	r5, #4
 8000fee:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000ff0:	f103 001c 	add.w	r0, r3, #28
 8000ff4:	f103 0110 	add.w	r1, r3, #16
 8000ff8:	605e      	str	r6, [r3, #4]
 8000ffa:	625d      	str	r5, [r3, #36]	; 0x24
 8000ffc:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 8000ffe:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8001000:	609a      	str	r2, [r3, #8]
 8001002:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8001004:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001006:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001008:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 800100a:	bc70      	pop	{r4, r5, r6}
 800100c:	4770      	bx	lr
 800100e:	bf00      	nop
 8001010:	20000868 	.word	0x20000868
 8001014:	20001290 	.word	0x20001290
 8001018:	f3af 8000 	nop.w
 800101c:	f3af 8000 	nop.w

08001020 <test_007_002_execute.lto_priv.155>:

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_002_execute(void) {
 8001020:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8001022:	4b0f      	ldr	r3, [pc, #60]	; (8001060 <test_007_002_execute.lto_priv.155+0x40>)
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8001024:	4f0f      	ldr	r7, [pc, #60]	; (8001064 <test_007_002_execute.lto_priv.155+0x44>)
 8001026:	2601      	movs	r6, #1
 8001028:	601e      	str	r6, [r3, #0]
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 800102a:	2400      	movs	r4, #0
 800102c:	2507      	movs	r5, #7
 800102e:	e001      	b.n	8001034 <test_007_002_execute.lto_priv.155+0x14>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 8001030:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8001032:	b175      	cbz	r5, 8001052 <test_007_002_execute.lto_priv.155+0x32>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8001034:	fa25 f304 	lsr.w	r3, r5, r4
 8001038:	07db      	lsls	r3, r3, #31
 800103a:	d5f9      	bpl.n	8001030 <test_007_002_execute.lto_priv.155+0x10>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800103c:	fa06 f304 	lsl.w	r3, r6, r4
      handlers[eid](eid);
 8001040:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
 8001044:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8001046:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
    }
    eid++;
 800104a:	3401      	adds	r4, #1
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 800104c:	4790      	blx	r2
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 800104e:	2d00      	cmp	r5, #0
 8001050:	d1f0      	bne.n	8001034 <test_007_002_execute.lto_priv.155+0x14>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8001052:	4805      	ldr	r0, [pc, #20]	; (8001068 <test_007_002_execute.lto_priv.155+0x48>)
 8001054:	4905      	ldr	r1, [pc, #20]	; (800106c <test_007_002_execute.lto_priv.155+0x4c>)
  }
}
 8001056:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 800105a:	f003 b841 	b.w	80040e0 <_test_assert_sequence>
 800105e:	bf00      	nop
 8001060:	20000f5c 	.word	0x20000f5c
 8001064:	08007a94 	.word	0x08007a94
 8001068:	08007928 	.word	0x08007928
 800106c:	0800792c 	.word	0x0800792c

08001070 <test_008_002_execute.lto_priv.171>:

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8001070:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 8001074:	4fb8      	ldr	r7, [pc, #736]	; (8001358 <test_008_002_execute.lto_priv.171+0x2e8>)
 8001076:	2301      	movs	r3, #1

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8001078:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 800107a:	603b      	str	r3, [r7, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800107c:	2520      	movs	r5, #32
 800107e:	f385 8811 	msr	BASEPRI, r5
 8001082:	4eb6      	ldr	r6, [pc, #728]	; (800135c <test_008_002_execute.lto_priv.171+0x2ec>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8001084:	49b6      	ldr	r1, [pc, #728]	; (8001360 <test_008_002_execute.lto_priv.171+0x2f0>)
 8001086:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8001088:	f1a0 0004 	sub.w	r0, r0, #4
 800108c:	fab0 f080 	clz	r0, r0
 8001090:	0940      	lsrs	r0, r0, #5
 8001092:	f003 f84d 	bl	8004130 <_test_assert>
 8001096:	4604      	mov	r4, r0
 8001098:	b128      	cbz	r0, 80010a6 <test_008_002_execute.lto_priv.171+0x36>
 800109a:	2300      	movs	r3, #0
 800109c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80010a0:	b003      	add	sp, #12
 80010a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80010a6:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.2.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 80010aa:	2302      	movs	r3, #2
 80010ac:	603b      	str	r3, [r7, #0]
 80010ae:	f385 8811 	msr	BASEPRI, r5
  {
    chSysLock();
    chMBResetI(&mb1);
 80010b2:	f006 fa4d 	bl	8007550 <chMBResetI.constprop.31>
 80010b6:	f384 8811 	msr	BASEPRI, r4
 80010ba:	f385 8811 	msr	BASEPRI, r5
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80010be:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80010c0:	49a8      	ldr	r1, [pc, #672]	; (8001364 <test_008_002_execute.lto_priv.171+0x2f4>)
 80010c2:	f1a0 0004 	sub.w	r0, r0, #4
 80010c6:	fab0 f080 	clz	r0, r0
 80010ca:	0940      	lsrs	r0, r0, #5
 80010cc:	f003 f830 	bl	8004130 <_test_assert>
 80010d0:	4680      	mov	r8, r0
 80010d2:	b120      	cbz	r0, 80010de <test_008_002_execute.lto_priv.171+0x6e>
 80010d4:	f384 8811 	msr	BASEPRI, r4
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80010d8:	b003      	add	sp, #12
 80010da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80010de:	f380 8811 	msr	BASEPRI, r0
 80010e2:	f385 8811 	msr	BASEPRI, r5
  {
    chSysLock();
    chMBResetI(&mb1);
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80010e6:	49a0      	ldr	r1, [pc, #640]	; (8001368 <test_008_002_execute.lto_priv.171+0x2f8>)
 80010e8:	69b0      	ldr	r0, [r6, #24]
 80010ea:	fab0 f080 	clz	r0, r0
 80010ee:	0940      	lsrs	r0, r0, #5
 80010f0:	f003 f81e 	bl	8004130 <_test_assert>
 80010f4:	4604      	mov	r4, r0
 80010f6:	b110      	cbz	r0, 80010fe <test_008_002_execute.lto_priv.171+0x8e>
 80010f8:	f388 8811 	msr	BASEPRI, r8
 80010fc:	e7d0      	b.n	80010a0 <test_008_002_execute.lto_priv.171+0x30>
 80010fe:	f380 8811 	msr	BASEPRI, r0
 8001102:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8001106:	6830      	ldr	r0, [r6, #0]
 8001108:	68b3      	ldr	r3, [r6, #8]
 800110a:	4998      	ldr	r1, [pc, #608]	; (800136c <test_008_002_execute.lto_priv.171+0x2fc>)
 800110c:	1ac0      	subs	r0, r0, r3
 800110e:	fab0 f080 	clz	r0, r0
 8001112:	0940      	lsrs	r0, r0, #5
 8001114:	f003 f80c 	bl	8004130 <_test_assert>
 8001118:	4680      	mov	r8, r0
 800111a:	2800      	cmp	r0, #0
 800111c:	d1da      	bne.n	80010d4 <test_008_002_execute.lto_priv.171+0x64>
 800111e:	f380 8811 	msr	BASEPRI, r0
 8001122:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8001126:	6830      	ldr	r0, [r6, #0]
 8001128:	68f3      	ldr	r3, [r6, #12]
 800112a:	4991      	ldr	r1, [pc, #580]	; (8001370 <test_008_002_execute.lto_priv.171+0x300>)
 800112c:	1ac0      	subs	r0, r0, r3
 800112e:	fab0 f080 	clz	r0, r0
 8001132:	0940      	lsrs	r0, r0, #5
 8001134:	f002 fffc 	bl	8004130 <_test_assert>
 8001138:	2800      	cmp	r0, #0
 800113a:	d1dd      	bne.n	80010f8 <test_008_002_execute.lto_priv.171+0x88>
 800113c:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 8001140:	2303      	movs	r3, #3
 8001142:	603b      	str	r3, [r7, #0]
 8001144:	4634      	mov	r4, r6
 8001146:	2542      	movs	r5, #66	; 0x42
 8001148:	2320      	movs	r3, #32
 800114a:	f383 8811 	msr	BASEPRI, r3
 800114e:	6a73      	ldr	r3, [r6, #36]	; 0x24
  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
  }
  chSemSignalI(&mbp->fullsem);
 8001150:	4888      	ldr	r0, [pc, #544]	; (8001374 <test_008_002_execute.lto_priv.171+0x304>)
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8001152:	2b00      	cmp	r3, #0
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt--;
 8001154:	f103 3eff 	add.w	lr, r3, #4294967295
 8001158:	dd60      	ble.n	800121c <test_008_002_execute.lto_priv.171+0x1ac>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 800115a:	68a2      	ldr	r2, [r4, #8]
  if (mbp->wrptr >= mbp->top) {
 800115c:	6861      	ldr	r1, [r4, #4]
 800115e:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001162:	1d13      	adds	r3, r2, #4
  if (mbp->wrptr >= mbp->top) {
 8001164:	428b      	cmp	r3, r1
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001166:	60a3      	str	r3, [r4, #8]
 8001168:	6015      	str	r5, [r2, #0]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 800116a:	bf24      	itt	cs
 800116c:	6823      	ldrcs	r3, [r4, #0]
 800116e:	60a3      	strcs	r3, [r4, #8]
  }
  chSemSignalI(&mbp->fullsem);
 8001170:	f005 f936 	bl	80063e0 <chSemSignalI>
 8001174:	2001      	movs	r0, #1
 8001176:	2300      	movs	r3, #0
 8001178:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800117c:	497e      	ldr	r1, [pc, #504]	; (8001378 <test_008_002_execute.lto_priv.171+0x308>)
 800117e:	f002 ffd7 	bl	8004130 <_test_assert>
 8001182:	3501      	adds	r5, #1
 8001184:	2800      	cmp	r0, #0
 8001186:	d18b      	bne.n	80010a0 <test_008_002_execute.lto_priv.171+0x30>

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8001188:	2d45      	cmp	r5, #69	; 0x45
 800118a:	d1dd      	bne.n	8001148 <test_008_002_execute.lto_priv.171+0xd8>
 800118c:	2320      	movs	r3, #32
 800118e:	f383 8811 	msr	BASEPRI, r3
 8001192:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8001194:	4a71      	ldr	r2, [pc, #452]	; (800135c <test_008_002_execute.lto_priv.171+0x2ec>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8001196:	2900      	cmp	r1, #0
 8001198:	dd10      	ble.n	80011bc <test_008_002_execute.lto_priv.171+0x14c>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 800119a:	68d3      	ldr	r3, [r2, #12]
 800119c:	6810      	ldr	r0, [r2, #0]
 800119e:	3b04      	subs	r3, #4
 80011a0:	3901      	subs	r1, #1
 80011a2:	4283      	cmp	r3, r0
 80011a4:	6251      	str	r1, [r2, #36]	; 0x24
 80011a6:	60d3      	str	r3, [r2, #12]
 80011a8:	d202      	bcs.n	80011b0 <test_008_002_execute.lto_priv.171+0x140>
    mbp->rdptr = mbp->top - 1;
 80011aa:	6853      	ldr	r3, [r2, #4]
 80011ac:	3b04      	subs	r3, #4
 80011ae:	60d3      	str	r3, [r2, #12]
  }
  *mbp->rdptr = msg;
 80011b0:	2241      	movs	r2, #65	; 0x41
  chSemSignalI(&mbp->fullsem);
 80011b2:	4870      	ldr	r0, [pc, #448]	; (8001374 <test_008_002_execute.lto_priv.171+0x304>)
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
    mbp->rdptr = mbp->top - 1;
  }
  *mbp->rdptr = msg;
 80011b4:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 80011b6:	f005 f913 	bl	80063e0 <chSemSignalI>
 80011ba:	2001      	movs	r0, #1
 80011bc:	2300      	movs	r3, #0
 80011be:	f383 8811 	msr	BASEPRI, r3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'A');
    chSysUnlock();
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80011c2:	496d      	ldr	r1, [pc, #436]	; (8001378 <test_008_002_execute.lto_priv.171+0x308>)
 80011c4:	f002 ffb4 	bl	8004130 <_test_assert>
 80011c8:	4680      	mov	r8, r0
 80011ca:	2800      	cmp	r0, #0
 80011cc:	f47f af68 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
  }

  /* [8.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 80011d0:	2504      	movs	r5, #4
 80011d2:	603d      	str	r5, [r7, #0]
 80011d4:	f8df 9180 	ldr.w	r9, [pc, #384]	; 8001358 <test_008_002_execute.lto_priv.171+0x2e8>
 80011d8:	f04f 0a20 	mov.w	sl, #32
 80011dc:	f38a 8811 	msr	BASEPRI, sl
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80011e0:	4966      	ldr	r1, [pc, #408]	; (800137c <test_008_002_execute.lto_priv.171+0x30c>)
 80011e2:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80011e4:	fab0 f080 	clz	r0, r0
 80011e8:	0940      	lsrs	r0, r0, #5
 80011ea:	f002 ffa1 	bl	8004130 <_test_assert>
 80011ee:	4c5b      	ldr	r4, [pc, #364]	; (800135c <test_008_002_execute.lto_priv.171+0x2ec>)
 80011f0:	4683      	mov	fp, r0
 80011f2:	2800      	cmp	r0, #0
 80011f4:	d180      	bne.n	80010f8 <test_008_002_execute.lto_priv.171+0x88>
 80011f6:	f380 8811 	msr	BASEPRI, r0
 80011fa:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80011fe:	69a0      	ldr	r0, [r4, #24]
 8001200:	495f      	ldr	r1, [pc, #380]	; (8001380 <test_008_002_execute.lto_priv.171+0x310>)
 8001202:	f1a0 0c04 	sub.w	ip, r0, #4
 8001206:	f1dc 0000 	rsbs	r0, ip, #0
 800120a:	eb40 000c 	adc.w	r0, r0, ip
 800120e:	f002 ff8f 	bl	8004130 <_test_assert>
 8001212:	4680      	mov	r8, r0
 8001214:	b120      	cbz	r0, 8001220 <test_008_002_execute.lto_priv.171+0x1b0>
 8001216:	f38b 8811 	msr	BASEPRI, fp
 800121a:	e741      	b.n	80010a0 <test_008_002_execute.lto_priv.171+0x30>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 800121c:	2000      	movs	r0, #0
 800121e:	e7aa      	b.n	8001176 <test_008_002_execute.lto_priv.171+0x106>
 8001220:	f380 8811 	msr	BASEPRI, r0
 8001224:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8001228:	68e0      	ldr	r0, [r4, #12]
 800122a:	68a3      	ldr	r3, [r4, #8]
 800122c:	4955      	ldr	r1, [pc, #340]	; (8001384 <test_008_002_execute.lto_priv.171+0x314>)
 800122e:	ebc3 0e00 	rsb	lr, r3, r0
 8001232:	f1de 0000 	rsbs	r0, lr, #0
 8001236:	eb40 000e 	adc.w	r0, r0, lr
 800123a:	f002 ff79 	bl	8004130 <_test_assert>
 800123e:	2800      	cmp	r0, #0
 8001240:	f47f af5a 	bne.w	80010f8 <test_008_002_execute.lto_priv.171+0x88>
 8001244:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 8001248:	2305      	movs	r3, #5
 800124a:	f8c9 3000 	str.w	r3, [r9]
 800124e:	e01d      	b.n	800128c <test_008_002_execute.lto_priv.171+0x21c>

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8001250:	68e3      	ldr	r3, [r4, #12]
 8001252:	61a2      	str	r2, [r4, #24]
  if (mbp->rdptr >= mbp->top) {
 8001254:	6862      	ldr	r2, [r4, #4]

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8001256:	6819      	ldr	r1, [r3, #0]
 8001258:	9101      	str	r1, [sp, #4]
 800125a:	3304      	adds	r3, #4
  if (mbp->rdptr >= mbp->top) {
 800125c:	4293      	cmp	r3, r2

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 800125e:	60e3      	str	r3, [r4, #12]
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
 8001260:	bf24      	itt	cs
 8001262:	6823      	ldrcs	r3, [r4, #0]
 8001264:	60e3      	strcs	r3, [r4, #12]
  }
  chSemSignalI(&mbp->emptysem);
 8001266:	f005 f8bb 	bl	80063e0 <chSemSignalI>

  return MSG_OK;
 800126a:	2000      	movs	r0, #0
 800126c:	2300      	movs	r3, #0
 800126e:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE; i++) {
      chSysLock();
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8001272:	4941      	ldr	r1, [pc, #260]	; (8001378 <test_008_002_execute.lto_priv.171+0x308>)
 8001274:	3001      	adds	r0, #1
 8001276:	f002 ff5b 	bl	8004130 <_test_assert>
 800127a:	2800      	cmp	r0, #0
 800127c:	f47f af10 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
      test_emit_token(msg2);
 8001280:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8001284:	f002 fd64 	bl	8003d50 <test_emit_token>

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8001288:	3d01      	subs	r5, #1
 800128a:	d00b      	beq.n	80012a4 <test_008_002_execute.lto_priv.171+0x234>
 800128c:	2320      	movs	r3, #32
 800128e:	f383 8811 	msr	BASEPRI, r3
 8001292:	69b3      	ldr	r3, [r6, #24]
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
  }
  chSemSignalI(&mbp->emptysem);
 8001294:	483c      	ldr	r0, [pc, #240]	; (8001388 <test_008_002_execute.lto_priv.171+0x318>)
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8001296:	2b00      	cmp	r3, #0
 8001298:	f103 32ff 	add.w	r2, r3, #4294967295
 800129c:	dcd8      	bgt.n	8001250 <test_008_002_execute.lto_priv.171+0x1e0>
    return MSG_TIMEOUT;
 800129e:	f04f 30ff 	mov.w	r0, #4294967295
 80012a2:	e7e3      	b.n	800126c <test_008_002_execute.lto_priv.171+0x1fc>
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 80012a4:	4839      	ldr	r0, [pc, #228]	; (800138c <test_008_002_execute.lto_priv.171+0x31c>)
 80012a6:	493a      	ldr	r1, [pc, #232]	; (8001390 <test_008_002_execute.lto_priv.171+0x320>)
 80012a8:	f002 ff1a 	bl	80040e0 <_test_assert_sequence>
 80012ac:	2800      	cmp	r0, #0
 80012ae:	f47f aef7 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80012b2:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80012b4:	f04f 31ff 	mov.w	r1, #4294967295
 80012b8:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80012ba:	603b      	str	r3, [r7, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80012bc:	f006 f970 	bl	80075a0 <chMBPost.constprop.29>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80012c0:	492d      	ldr	r1, [pc, #180]	; (8001378 <test_008_002_execute.lto_priv.171+0x308>)
 80012c2:	fab0 f080 	clz	r0, r0
 80012c6:	0940      	lsrs	r0, r0, #5
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80012c8:	4c23      	ldr	r4, [pc, #140]	; (8001358 <test_008_002_execute.lto_priv.171+0x2e8>)
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80012ca:	f002 ff31 	bl	8004130 <_test_assert>
 80012ce:	2800      	cmp	r0, #0
 80012d0:	f47f aee6 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80012d4:	f04f 31ff 	mov.w	r1, #4294967295
 80012d8:	a801      	add	r0, sp, #4
 80012da:	f006 f9b1 	bl	8007640 <chMBFetch.constprop.25>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80012de:	4926      	ldr	r1, [pc, #152]	; (8001378 <test_008_002_execute.lto_priv.171+0x308>)
 80012e0:	fab0 f080 	clz	r0, r0
 80012e4:	0940      	lsrs	r0, r0, #5
 80012e6:	f002 ff23 	bl	8004130 <_test_assert>
 80012ea:	2800      	cmp	r0, #0
 80012ec:	f47f aed8 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
  }

  /* [8.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 80012f0:	2307      	movs	r3, #7
 80012f2:	6023      	str	r3, [r4, #0]
 80012f4:	2720      	movs	r7, #32
 80012f6:	f387 8811 	msr	BASEPRI, r7
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80012fa:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80012fc:	4919      	ldr	r1, [pc, #100]	; (8001364 <test_008_002_execute.lto_priv.171+0x2f4>)
 80012fe:	4c17      	ldr	r4, [pc, #92]	; (800135c <test_008_002_execute.lto_priv.171+0x2ec>)
 8001300:	1f06      	subs	r6, r0, #4
 8001302:	4270      	negs	r0, r6
 8001304:	4170      	adcs	r0, r6
 8001306:	f002 ff13 	bl	8004130 <_test_assert>
 800130a:	b110      	cbz	r0, 8001312 <test_008_002_execute.lto_priv.171+0x2a2>
 800130c:	f385 8811 	msr	BASEPRI, r5
 8001310:	e6c6      	b.n	80010a0 <test_008_002_execute.lto_priv.171+0x30>
 8001312:	f385 8811 	msr	BASEPRI, r5
 8001316:	f387 8811 	msr	BASEPRI, r7
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800131a:	4913      	ldr	r1, [pc, #76]	; (8001368 <test_008_002_execute.lto_priv.171+0x2f8>)
 800131c:	69a0      	ldr	r0, [r4, #24]
 800131e:	fab0 f080 	clz	r0, r0
 8001322:	0940      	lsrs	r0, r0, #5
 8001324:	f002 ff04 	bl	8004130 <_test_assert>
 8001328:	2800      	cmp	r0, #0
 800132a:	d1ef      	bne.n	800130c <test_008_002_execute.lto_priv.171+0x29c>
 800132c:	f385 8811 	msr	BASEPRI, r5
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8001330:	6820      	ldr	r0, [r4, #0]
 8001332:	68a3      	ldr	r3, [r4, #8]
 8001334:	490d      	ldr	r1, [pc, #52]	; (800136c <test_008_002_execute.lto_priv.171+0x2fc>)
 8001336:	1ac2      	subs	r2, r0, r3
 8001338:	4250      	negs	r0, r2
 800133a:	4150      	adcs	r0, r2
 800133c:	f002 fef8 	bl	8004130 <_test_assert>
 8001340:	2800      	cmp	r0, #0
 8001342:	f47f aead 	bne.w	80010a0 <test_008_002_execute.lto_priv.171+0x30>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8001346:	6820      	ldr	r0, [r4, #0]
 8001348:	68e3      	ldr	r3, [r4, #12]
 800134a:	4909      	ldr	r1, [pc, #36]	; (8001370 <test_008_002_execute.lto_priv.171+0x300>)
 800134c:	1ac3      	subs	r3, r0, r3
 800134e:	4258      	negs	r0, r3
 8001350:	4158      	adcs	r0, r3
 8001352:	f002 feed 	bl	8004130 <_test_assert>
 8001356:	e6a3      	b.n	80010a0 <test_008_002_execute.lto_priv.171+0x30>
 8001358:	20000f5c 	.word	0x20000f5c
 800135c:	20000868 	.word	0x20000868
 8001360:	08007940 	.word	0x08007940
 8001364:	0800794c 	.word	0x0800794c
 8001368:	08007958 	.word	0x08007958
 800136c:	08007964 	.word	0x08007964
 8001370:	08007988 	.word	0x08007988
 8001374:	20000878 	.word	0x20000878
 8001378:	080079ac 	.word	0x080079ac
 800137c:	080079c4 	.word	0x080079c4
 8001380:	080079d0 	.word	0x080079d0
 8001384:	080079dc 	.word	0x080079dc
 8001388:	20000884 	.word	0x20000884
 800138c:	080079f4 	.word	0x080079f4
 8001390:	080079fc 	.word	0x080079fc
 8001394:	f3af 8000 	nop.w
 8001398:	f3af 8000 	nop.w
 800139c:	f3af 8000 	nop.w

080013a0 <test_008_002_teardown.lto_priv.170>:
static void test_008_002_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
 80013a0:	f006 b8ee 	b.w	8007580 <chMBReset.constprop.30>
 80013a4:	f3af 8000 	nop.w
 80013a8:	f3af 8000 	nop.w
 80013ac:	f3af 8000 	nop.w

080013b0 <test_008_001_teardown.lto_priv.167>:
static void test_008_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
 80013b0:	f006 b8e6 	b.w	8007580 <chMBReset.constprop.30>
 80013b4:	f3af 8000 	nop.w
 80013b8:	f3af 8000 	nop.w
 80013bc:	f3af 8000 	nop.w

080013c0 <test_008_001_execute.lto_priv.168>:
}

static void test_008_001_execute(void) {
 80013c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80013c4:	4f99      	ldr	r7, [pc, #612]	; (800162c <test_008_001_execute.lto_priv.168+0x26c>)
 80013c6:	2301      	movs	r3, #1

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 80013c8:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80013ca:	603b      	str	r3, [r7, #0]
 80013cc:	2620      	movs	r6, #32
 80013ce:	f386 8811 	msr	BASEPRI, r6
 80013d2:	4d97      	ldr	r5, [pc, #604]	; (8001630 <test_008_001_execute.lto_priv.168+0x270>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80013d4:	4997      	ldr	r1, [pc, #604]	; (8001634 <test_008_001_execute.lto_priv.168+0x274>)
 80013d6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80013d8:	f1a0 0004 	sub.w	r0, r0, #4
 80013dc:	fab0 f080 	clz	r0, r0
 80013e0:	0940      	lsrs	r0, r0, #5
 80013e2:	f002 fea5 	bl	8004130 <_test_assert>
 80013e6:	4604      	mov	r4, r0
 80013e8:	b128      	cbz	r0, 80013f6 <test_008_001_execute.lto_priv.168+0x36>
 80013ea:	2300      	movs	r3, #0
 80013ec:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80013f0:	b003      	add	sp, #12
 80013f2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80013f6:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 80013fa:	2302      	movs	r3, #2
 80013fc:	603b      	str	r3, [r7, #0]
  {
    chMBReset(&mb1);
 80013fe:	f006 f8bf 	bl	8007580 <chMBReset.constprop.30>
 8001402:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8001406:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8001408:	498b      	ldr	r1, [pc, #556]	; (8001638 <test_008_001_execute.lto_priv.168+0x278>)
 800140a:	f1a0 0004 	sub.w	r0, r0, #4
 800140e:	fab0 f080 	clz	r0, r0
 8001412:	0940      	lsrs	r0, r0, #5
 8001414:	f002 fe8c 	bl	8004130 <_test_assert>
 8001418:	4680      	mov	r8, r0
 800141a:	b120      	cbz	r0, 8001426 <test_008_001_execute.lto_priv.168+0x66>
 800141c:	f384 8811 	msr	BASEPRI, r4
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 8001420:	b003      	add	sp, #12
 8001422:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001426:	f380 8811 	msr	BASEPRI, r0
 800142a:	f386 8811 	msr	BASEPRI, r6
     expected.*/
  test_set_step(2);
  {
    chMBReset(&mb1);
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800142e:	4983      	ldr	r1, [pc, #524]	; (800163c <test_008_001_execute.lto_priv.168+0x27c>)
 8001430:	69a8      	ldr	r0, [r5, #24]
 8001432:	fab0 f080 	clz	r0, r0
 8001436:	0940      	lsrs	r0, r0, #5
 8001438:	f002 fe7a 	bl	8004130 <_test_assert>
 800143c:	4604      	mov	r4, r0
 800143e:	b110      	cbz	r0, 8001446 <test_008_001_execute.lto_priv.168+0x86>
 8001440:	f388 8811 	msr	BASEPRI, r8
 8001444:	e7d4      	b.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>
 8001446:	f380 8811 	msr	BASEPRI, r0
 800144a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800144e:	6828      	ldr	r0, [r5, #0]
 8001450:	68ab      	ldr	r3, [r5, #8]
 8001452:	497b      	ldr	r1, [pc, #492]	; (8001640 <test_008_001_execute.lto_priv.168+0x280>)
 8001454:	1ac0      	subs	r0, r0, r3
 8001456:	fab0 f080 	clz	r0, r0
 800145a:	0940      	lsrs	r0, r0, #5
 800145c:	f002 fe68 	bl	8004130 <_test_assert>
 8001460:	4680      	mov	r8, r0
 8001462:	2800      	cmp	r0, #0
 8001464:	d1da      	bne.n	800141c <test_008_001_execute.lto_priv.168+0x5c>
 8001466:	f380 8811 	msr	BASEPRI, r0
 800146a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800146e:	6828      	ldr	r0, [r5, #0]
 8001470:	68eb      	ldr	r3, [r5, #12]
 8001472:	4974      	ldr	r1, [pc, #464]	; (8001644 <test_008_001_execute.lto_priv.168+0x284>)
 8001474:	1ac0      	subs	r0, r0, r3
 8001476:	fab0 f080 	clz	r0, r0
 800147a:	0940      	lsrs	r0, r0, #5
 800147c:	f002 fe58 	bl	8004130 <_test_assert>
 8001480:	2800      	cmp	r0, #0
 8001482:	d1dd      	bne.n	8001440 <test_008_001_execute.lto_priv.168+0x80>
 8001484:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
 8001488:	2303      	movs	r3, #3
 800148a:	603b      	str	r3, [r7, #0]
 800148c:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800148e:	4620      	mov	r0, r4
 8001490:	f04f 31ff 	mov.w	r1, #4294967295
 8001494:	f006 f884 	bl	80075a0 <chMBPost.constprop.29>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8001498:	496b      	ldr	r1, [pc, #428]	; (8001648 <test_008_001_execute.lto_priv.168+0x288>)
 800149a:	fab0 f080 	clz	r0, r0
 800149e:	0940      	lsrs	r0, r0, #5
 80014a0:	f002 fe46 	bl	8004130 <_test_assert>
 80014a4:	3401      	adds	r4, #1
 80014a6:	2800      	cmp	r0, #0
 80014a8:	d1a2      	bne.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 80014aa:	2c45      	cmp	r4, #69	; 0x45
 80014ac:	d1ef      	bne.n	800148e <test_008_001_execute.lto_priv.168+0xce>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80014ae:	f04f 31ff 	mov.w	r1, #4294967295
 80014b2:	2041      	movs	r0, #65	; 0x41
 80014b4:	f006 f89c 	bl	80075f0 <chMBPostAhead.constprop.27>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80014b8:	4963      	ldr	r1, [pc, #396]	; (8001648 <test_008_001_execute.lto_priv.168+0x288>)
 80014ba:	fab0 f080 	clz	r0, r0
 80014be:	0940      	lsrs	r0, r0, #5
 80014c0:	f002 fe36 	bl	8004130 <_test_assert>
 80014c4:	4606      	mov	r6, r0
 80014c6:	2800      	cmp	r0, #0
 80014c8:	d192      	bne.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>
  }

  /* [8.1.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 80014ca:	2404      	movs	r4, #4
 80014cc:	603c      	str	r4, [r7, #0]
 80014ce:	f8df 915c 	ldr.w	r9, [pc, #348]	; 800162c <test_008_001_execute.lto_priv.168+0x26c>
 80014d2:	f04f 0a20 	mov.w	sl, #32
 80014d6:	f38a 8811 	msr	BASEPRI, sl
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80014da:	495c      	ldr	r1, [pc, #368]	; (800164c <test_008_001_execute.lto_priv.168+0x28c>)
 80014dc:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80014de:	fab0 f080 	clz	r0, r0
 80014e2:	0940      	lsrs	r0, r0, #5
 80014e4:	f002 fe24 	bl	8004130 <_test_assert>
 80014e8:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8001630 <test_008_001_execute.lto_priv.168+0x270>
 80014ec:	4683      	mov	fp, r0
 80014ee:	b110      	cbz	r0, 80014f6 <test_008_001_execute.lto_priv.168+0x136>
 80014f0:	f386 8811 	msr	BASEPRI, r6
 80014f4:	e77c      	b.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>
 80014f6:	f380 8811 	msr	BASEPRI, r0
 80014fa:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80014fe:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8001502:	4953      	ldr	r1, [pc, #332]	; (8001650 <test_008_001_execute.lto_priv.168+0x290>)
 8001504:	f1a0 0c04 	sub.w	ip, r0, #4
 8001508:	f1dc 0000 	rsbs	r0, ip, #0
 800150c:	eb40 000c 	adc.w	r0, r0, ip
 8001510:	f002 fe0e 	bl	8004130 <_test_assert>
 8001514:	4606      	mov	r6, r0
 8001516:	b110      	cbz	r0, 800151e <test_008_001_execute.lto_priv.168+0x15e>
 8001518:	f38b 8811 	msr	BASEPRI, fp
 800151c:	e768      	b.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>
 800151e:	f380 8811 	msr	BASEPRI, r0
 8001522:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8001526:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800152a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800152e:	4949      	ldr	r1, [pc, #292]	; (8001654 <test_008_001_execute.lto_priv.168+0x294>)
 8001530:	ebc3 0e00 	rsb	lr, r3, r0
 8001534:	f1de 0000 	rsbs	r0, lr, #0
 8001538:	eb40 000e 	adc.w	r0, r0, lr
 800153c:	f002 fdf8 	bl	8004130 <_test_assert>
 8001540:	2800      	cmp	r0, #0
 8001542:	d1d5      	bne.n	80014f0 <test_008_001_execute.lto_priv.168+0x130>
 8001544:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
 8001548:	2305      	movs	r3, #5
 800154a:	f8c9 3000 	str.w	r3, [r9]
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800154e:	f04f 31ff 	mov.w	r1, #4294967295
 8001552:	a801      	add	r0, sp, #4
 8001554:	f006 f874 	bl	8007640 <chMBFetch.constprop.25>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8001558:	493b      	ldr	r1, [pc, #236]	; (8001648 <test_008_001_execute.lto_priv.168+0x288>)
 800155a:	fab0 f080 	clz	r0, r0
 800155e:	0940      	lsrs	r0, r0, #5
 8001560:	f002 fde6 	bl	8004130 <_test_assert>
 8001564:	2800      	cmp	r0, #0
 8001566:	f47f af43 	bne.w	80013f0 <test_008_001_execute.lto_priv.168+0x30>
      test_emit_token(msg2);
 800156a:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800156e:	f002 fbef 	bl	8003d50 <test_emit_token>

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8001572:	3c01      	subs	r4, #1
 8001574:	d1eb      	bne.n	800154e <test_008_001_execute.lto_priv.168+0x18e>
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8001576:	4838      	ldr	r0, [pc, #224]	; (8001658 <test_008_001_execute.lto_priv.168+0x298>)
 8001578:	4938      	ldr	r1, [pc, #224]	; (800165c <test_008_001_execute.lto_priv.168+0x29c>)
 800157a:	f002 fdb1 	bl	80040e0 <_test_assert_sequence>
 800157e:	2800      	cmp	r0, #0
 8001580:	f47f af36 	bne.w	80013f0 <test_008_001_execute.lto_priv.168+0x30>
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8001584:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8001586:	f04f 31ff 	mov.w	r1, #4294967295
 800158a:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800158c:	603b      	str	r3, [r7, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800158e:	f006 f807 	bl	80075a0 <chMBPost.constprop.29>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8001592:	492d      	ldr	r1, [pc, #180]	; (8001648 <test_008_001_execute.lto_priv.168+0x288>)
 8001594:	fab0 f080 	clz	r0, r0
 8001598:	0940      	lsrs	r0, r0, #5
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800159a:	4e24      	ldr	r6, [pc, #144]	; (800162c <test_008_001_execute.lto_priv.168+0x26c>)
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800159c:	f002 fdc8 	bl	8004130 <_test_assert>
 80015a0:	2800      	cmp	r0, #0
 80015a2:	f47f af25 	bne.w	80013f0 <test_008_001_execute.lto_priv.168+0x30>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80015a6:	f04f 31ff 	mov.w	r1, #4294967295
 80015aa:	a801      	add	r0, sp, #4
 80015ac:	f006 f848 	bl	8007640 <chMBFetch.constprop.25>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80015b0:	4925      	ldr	r1, [pc, #148]	; (8001648 <test_008_001_execute.lto_priv.168+0x288>)
 80015b2:	fab0 f080 	clz	r0, r0
 80015b6:	0940      	lsrs	r0, r0, #5
 80015b8:	f002 fdba 	bl	8004130 <_test_assert>
 80015bc:	2800      	cmp	r0, #0
 80015be:	f47f af17 	bne.w	80013f0 <test_008_001_execute.lto_priv.168+0x30>
  }

  /* [8.1.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 80015c2:	2307      	movs	r3, #7
 80015c4:	6033      	str	r3, [r6, #0]
 80015c6:	2620      	movs	r6, #32
 80015c8:	f386 8811 	msr	BASEPRI, r6
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80015cc:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80015ce:	491a      	ldr	r1, [pc, #104]	; (8001638 <test_008_001_execute.lto_priv.168+0x278>)
 80015d0:	4d17      	ldr	r5, [pc, #92]	; (8001630 <test_008_001_execute.lto_priv.168+0x270>)
 80015d2:	1f07      	subs	r7, r0, #4
 80015d4:	4278      	negs	r0, r7
 80015d6:	4178      	adcs	r0, r7
 80015d8:	f002 fdaa 	bl	8004130 <_test_assert>
 80015dc:	2800      	cmp	r0, #0
 80015de:	f47f af1d 	bne.w	800141c <test_008_001_execute.lto_priv.168+0x5c>
 80015e2:	f384 8811 	msr	BASEPRI, r4
 80015e6:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80015ea:	4914      	ldr	r1, [pc, #80]	; (800163c <test_008_001_execute.lto_priv.168+0x27c>)
 80015ec:	69a8      	ldr	r0, [r5, #24]
 80015ee:	fab0 f080 	clz	r0, r0
 80015f2:	0940      	lsrs	r0, r0, #5
 80015f4:	f002 fd9c 	bl	8004130 <_test_assert>
 80015f8:	2800      	cmp	r0, #0
 80015fa:	f47f af0f 	bne.w	800141c <test_008_001_execute.lto_priv.168+0x5c>
 80015fe:	f384 8811 	msr	BASEPRI, r4
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8001602:	6828      	ldr	r0, [r5, #0]
 8001604:	68ab      	ldr	r3, [r5, #8]
 8001606:	490e      	ldr	r1, [pc, #56]	; (8001640 <test_008_001_execute.lto_priv.168+0x280>)
 8001608:	1ac2      	subs	r2, r0, r3
 800160a:	4250      	negs	r0, r2
 800160c:	4150      	adcs	r0, r2
 800160e:	f002 fd8f 	bl	8004130 <_test_assert>
 8001612:	2800      	cmp	r0, #0
 8001614:	f47f aeec 	bne.w	80013f0 <test_008_001_execute.lto_priv.168+0x30>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8001618:	6828      	ldr	r0, [r5, #0]
 800161a:	68eb      	ldr	r3, [r5, #12]
 800161c:	4909      	ldr	r1, [pc, #36]	; (8001644 <test_008_001_execute.lto_priv.168+0x284>)
 800161e:	1ac3      	subs	r3, r0, r3
 8001620:	4258      	negs	r0, r3
 8001622:	4158      	adcs	r0, r3
 8001624:	f002 fd84 	bl	8004130 <_test_assert>
 8001628:	e6e2      	b.n	80013f0 <test_008_001_execute.lto_priv.168+0x30>
 800162a:	bf00      	nop
 800162c:	20000f5c 	.word	0x20000f5c
 8001630:	20000868 	.word	0x20000868
 8001634:	08007940 	.word	0x08007940
 8001638:	0800794c 	.word	0x0800794c
 800163c:	08007958 	.word	0x08007958
 8001640:	08007964 	.word	0x08007964
 8001644:	08007988 	.word	0x08007988
 8001648:	080079ac 	.word	0x080079ac
 800164c:	080079c4 	.word	0x080079c4
 8001650:	080079d0 	.word	0x080079d0
 8001654:	080079dc 	.word	0x080079dc
 8001658:	080079f4 	.word	0x080079f4
 800165c:	080079fc 	.word	0x080079fc

08001660 <test_007_007_setup.lto_priv.164>:
 *   has been emptied.
 * - [7.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_007_007_setup(void) {
 8001660:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 8001662:	f005 fe5d 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8001666:	4a02      	ldr	r2, [pc, #8]	; (8001670 <test_007_007_setup.lto_priv.164+0x10>)
 8001668:	4b02      	ldr	r3, [pc, #8]	; (8001674 <test_007_007_setup.lto_priv.164+0x14>)
 800166a:	6012      	str	r2, [r2, #0]
 800166c:	601b      	str	r3, [r3, #0]
 800166e:	bd08      	pop	{r3, pc}
 8001670:	20000804 	.word	0x20000804
 8001674:	20000800 	.word	0x20000800
 8001678:	f3af 8000 	nop.w
 800167c:	f3af 8000 	nop.w

08001680 <test_007_006_setup.lto_priv.162>:
 *   timeout condition is tested.
 * .
 */

static void test_007_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8001680:	f005 be4e 	b.w	8007320 <chEvtGetAndClearEvents.constprop.50>
 8001684:	f3af 8000 	nop.w
 8001688:	f3af 8000 	nop.w
 800168c:	f3af 8000 	nop.w

08001690 <test_007_005_setup.lto_priv.160>:
 *   has been emptied.
 * .
 */

static void test_007_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8001690:	f005 be46 	b.w	8007320 <chEvtGetAndClearEvents.constprop.50>
 8001694:	f3af 8000 	nop.w
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <test_007_004_setup.lto_priv.158>:
 *   emptied.
 * .
 */

static void test_007_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 80016a0:	f005 be3e 	b.w	8007320 <chEvtGetAndClearEvents.constprop.50>
 80016a4:	f3af 8000 	nop.w
 80016a8:	f3af 8000 	nop.w
 80016ac:	f3af 8000 	nop.w

080016b0 <test_007_003_setup.lto_priv.156>:
 *   emptied.
 * .
 */

static void test_007_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 80016b0:	f005 be36 	b.w	8007320 <chEvtGetAndClearEvents.constprop.50>
 80016b4:	f3af 8000 	nop.w
 80016b8:	f3af 8000 	nop.w
 80016bc:	f3af 8000 	nop.w

080016c0 <test_007_002_setup.lto_priv.154>:
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 80016c0:	f005 be2e 	b.w	8007320 <chEvtGetAndClearEvents.constprop.50>
 80016c4:	f3af 8000 	nop.w
 80016c8:	f3af 8000 	nop.w
 80016cc:	f3af 8000 	nop.w

080016d0 <test_007_007_execute.lto_priv.165>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 80016d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80016d4:	4d3c      	ldr	r5, [pc, #240]	; (80017c8 <test_007_007_execute.lto_priv.165+0xf8>)
 80016d6:	2301      	movs	r3, #1
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 80016d8:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80016da:	602b      	str	r3, [r5, #0]
 80016dc:	2220      	movs	r2, #32
 80016de:	f382 8811 	msr	BASEPRI, r2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80016e2:	f8df 8104 	ldr.w	r8, [pc, #260]	; 80017e8 <test_007_007_execute.lto_priv.165+0x118>
  esp->next     = elp;
  elp->listener = currp;
 80016e6:	4f39      	ldr	r7, [pc, #228]	; (80017cc <test_007_007_execute.lto_priv.165+0xfc>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80016e8:	f8d8 0000 	ldr.w	r0, [r8]
  esp->next     = elp;
  elp->listener = currp;
 80016ec:	69b9      	ldr	r1, [r7, #24]
  elp->events   = events;
 80016ee:	9302      	str	r3, [sp, #8]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80016f0:	ae0a      	add	r6, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 80016f2:	2300      	movs	r3, #0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80016f4:	f846 0d28 	str.w	r0, [r6, #-40]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 80016f8:	f04f 30ff 	mov.w	r0, #4294967295
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 80016fc:	9101      	str	r1, [sp, #4]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 80016fe:	f8c8 6000 	str.w	r6, [r8]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8001702:	9303      	str	r3, [sp, #12]
  elp->wflags   = wflags;
 8001704:	9004      	str	r0, [sp, #16]
 8001706:	f383 8811 	msr	BASEPRI, r3
 800170a:	f382 8811 	msr	BASEPRI, r2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800170e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 80017ec <test_007_007_execute.lto_priv.165+0x11c>
  esp->next     = elp;
  elp->listener = currp;
 8001712:	69ba      	ldr	r2, [r7, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8001714:	f8d9 1000 	ldr.w	r1, [r9]
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8001718:	9308      	str	r3, [sp, #32]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800171a:	ac0a      	add	r4, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 800171c:	f04f 0a04 	mov.w	sl, #4
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8001720:	f844 1d14 	str.w	r1, [r4, #-20]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8001724:	9009      	str	r0, [sp, #36]	; 0x24
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8001726:	9206      	str	r2, [sp, #24]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8001728:	f8c9 4000 	str.w	r4, [r9]
  elp->listener = currp;
  elp->events   = events;
 800172c:	f8cd a01c 	str.w	sl, [sp, #28]
 8001730:	f383 8811 	msr	BASEPRI, r3
  }

  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8001734:	2302      	movs	r3, #2
 8001736:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001738:	f001 fcf2 	bl	8003120 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800173c:	69bb      	ldr	r3, [r7, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800173e:	4a24      	ldr	r2, [pc, #144]	; (80017d0 <test_007_007_execute.lto_priv.165+0x100>)
 8001740:	6899      	ldr	r1, [r3, #8]
 8001742:	4b24      	ldr	r3, [pc, #144]	; (80017d4 <test_007_007_execute.lto_priv.165+0x104>)
  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001744:	4683      	mov	fp, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001746:	3901      	subs	r1, #1
 8001748:	4823      	ldr	r0, [pc, #140]	; (80017d8 <test_007_007_execute.lto_priv.165+0x108>)
 800174a:	f005 fd11 	bl	8007170 <chThdCreateStatic.constprop.69>
 800174e:	4a23      	ldr	r2, [pc, #140]	; (80017dc <test_007_007_execute.lto_priv.165+0x10c>)
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8001750:	2303      	movs	r3, #3
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001752:	6010      	str	r0, [r2, #0]
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8001754:	602b      	str	r3, [r5, #0]
  {
    m = chEvtWaitAll(5);
 8001756:	f005 fe2b 	bl	80073b0 <chEvtWaitAll.constprop.44>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800175a:	f50b 70fa 	add.w	r0, fp, #500	; 0x1f4
 800175e:	f50b 7102 	add.w	r1, fp, #520	; 0x208
 8001762:	f006 f81d 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8001766:	b110      	cbz	r0, 800176e <test_007_007_execute.lto_priv.165+0x9e>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 8001768:	b00b      	add	sp, #44	; 0x2c
 800176a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800176e:	f005 fdd7 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8001772:	491b      	ldr	r1, [pc, #108]	; (80017e0 <test_007_007_execute.lto_priv.165+0x110>)
 8001774:	fab0 f080 	clz	r0, r0
 8001778:	0940      	lsrs	r0, r0, #5
 800177a:	f002 fcd9 	bl	8004130 <_test_assert>
 800177e:	2800      	cmp	r0, #0
 8001780:	d1f2      	bne.n	8001768 <test_007_007_execute.lto_priv.165+0x98>
    test_wait_threads();
 8001782:	f001 fcdd 	bl	8003140 <test_wait_threads>
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el1);
 8001786:	4631      	mov	r1, r6
 8001788:	4640      	mov	r0, r8
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 800178a:	f8c5 a000 	str.w	sl, [r5]
  {
    chEvtUnregister(&es1, &el1);
 800178e:	f004 fb37 	bl	8005e00 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 8001792:	4648      	mov	r0, r9
 8001794:	4621      	mov	r1, r4
 8001796:	f004 fb33 	bl	8005e00 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 800179a:	f8d8 0000 	ldr.w	r0, [r8]
 800179e:	4911      	ldr	r1, [pc, #68]	; (80017e4 <test_007_007_execute.lto_priv.165+0x114>)
 80017a0:	ebc8 0000 	rsb	r0, r8, r0
 80017a4:	fab0 f080 	clz	r0, r0
 80017a8:	0940      	lsrs	r0, r0, #5
 80017aa:	f002 fcc1 	bl	8004130 <_test_assert>
 80017ae:	2800      	cmp	r0, #0
 80017b0:	d1da      	bne.n	8001768 <test_007_007_execute.lto_priv.165+0x98>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 80017b2:	f8d9 0000 	ldr.w	r0, [r9]
 80017b6:	490b      	ldr	r1, [pc, #44]	; (80017e4 <test_007_007_execute.lto_priv.165+0x114>)
 80017b8:	ebc9 0000 	rsb	r0, r9, r0
 80017bc:	fab0 f080 	clz	r0, r0
 80017c0:	0940      	lsrs	r0, r0, #5
 80017c2:	f002 fcb5 	bl	8004130 <_test_assert>
 80017c6:	e7cf      	b.n	8001768 <test_007_007_execute.lto_priv.165+0x98>
 80017c8:	20000f5c 	.word	0x20000f5c
 80017cc:	200012a0 	.word	0x200012a0
 80017d0:	08004611 	.word	0x08004611
 80017d4:	08007a10 	.word	0x08007a10
 80017d8:	200008b0 	.word	0x200008b0
 80017dc:	20000f60 	.word	0x20000f60
 80017e0:	08007a14 	.word	0x08007a14
 80017e4:	08007a20 	.word	0x08007a20
 80017e8:	20000804 	.word	0x20000804
 80017ec:	20000800 	.word	0x20000800

080017f0 <test_007_006_execute.lto_priv.163>:

static void test_007_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_006_execute(void) {
 80017f0:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;

  /* [7.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 80017f2:	4d57      	ldr	r5, [pc, #348]	; (8001950 <test_007_006_execute.lto_priv.163+0x160>)
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80017f4:	4c57      	ldr	r4, [pc, #348]	; (8001954 <test_007_006_execute.lto_priv.163+0x164>)
 80017f6:	2001      	movs	r0, #1
 80017f8:	6028      	str	r0, [r5, #0]
 80017fa:	69a2      	ldr	r2, [r4, #24]
 80017fc:	2320      	movs	r3, #32
 80017fe:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8001802:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8001804:	b933      	cbnz	r3, 8001814 <test_007_006_execute.lto_priv.163+0x24>
 8001806:	f383 8811 	msr	BASEPRI, r3
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 800180a:	4953      	ldr	r1, [pc, #332]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 800180c:	f002 fc90 	bl	8004130 <_test_assert>
 8001810:	b180      	cbz	r0, 8001834 <test_007_006_execute.lto_priv.163+0x44>
 8001812:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8001814:	4258      	negs	r0, r3
 8001816:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8001818:	ea23 0300 	bic.w	r3, r3, r0
 800181c:	6353      	str	r3, [r2, #52]	; 0x34
 800181e:	2300      	movs	r3, #0
 8001820:	f383 8811 	msr	BASEPRI, r3
 8001824:	494c      	ldr	r1, [pc, #304]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 8001826:	fab0 f080 	clz	r0, r0
 800182a:	0940      	lsrs	r0, r0, #5
 800182c:	f002 fc80 	bl	8004130 <_test_assert>
 8001830:	2800      	cmp	r0, #0
 8001832:	d1ee      	bne.n	8001812 <test_007_006_execute.lto_priv.163+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8001834:	69a3      	ldr	r3, [r4, #24]
 8001836:	2220      	movs	r2, #32
 8001838:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 800183c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800183e:	2a00      	cmp	r2, #0
 8001840:	d072      	beq.n	8001928 <test_007_006_execute.lto_priv.163+0x138>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8001842:	6358      	str	r0, [r3, #52]	; 0x34
 8001844:	f380 8811 	msr	BASEPRI, r0
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8001848:	4943      	ldr	r1, [pc, #268]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 800184a:	f002 fc71 	bl	8004130 <_test_assert>
 800184e:	2800      	cmp	r0, #0
 8001850:	d1df      	bne.n	8001812 <test_007_006_execute.lto_priv.163+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8001852:	69a3      	ldr	r3, [r4, #24]
 8001854:	2220      	movs	r2, #32
 8001856:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  if ((ctp->epending & events) != events) {
 800185a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800185c:	3201      	adds	r2, #1
 800185e:	d067      	beq.n	8001930 <test_007_006_execute.lto_priv.163+0x140>
 8001860:	f380 8811 	msr	BASEPRI, r0
 8001864:	2001      	movs	r0, #1
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8001866:	493c      	ldr	r1, [pc, #240]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 8001868:	f002 fc62 	bl	8004130 <_test_assert>
 800186c:	2800      	cmp	r0, #0
 800186e:	d1d0      	bne.n	8001812 <test_007_006_execute.lto_priv.163+0x22>
  }

  /* [7.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8001870:	2302      	movs	r3, #2
 8001872:	602b      	str	r3, [r5, #0]
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8001874:	69a6      	ldr	r6, [r4, #24]
 8001876:	2320      	movs	r3, #32
 8001878:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800187c:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800187e:	b955      	cbnz	r5, 8001896 <test_007_006_execute.lto_priv.163+0xa6>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8001880:	f04f 33ff 	mov.w	r3, #4294967295
 8001884:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8001886:	200a      	movs	r0, #10
 8001888:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800188c:	f004 fe88 	bl	80065a0 <chSchGoSleepTimeoutS>
 8001890:	2800      	cmp	r0, #0
 8001892:	db51      	blt.n	8001938 <test_007_006_execute.lto_priv.163+0x148>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 8001894:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8001896:	4268      	negs	r0, r5
 8001898:	4028      	ands	r0, r5
  ctp->epending &= ~m;
 800189a:	ea25 0500 	bic.w	r5, r5, r0
 800189e:	6375      	str	r5, [r6, #52]	; 0x34
 80018a0:	2300      	movs	r3, #0
 80018a2:	f383 8811 	msr	BASEPRI, r3
 80018a6:	fab0 f080 	clz	r0, r0
 80018aa:	0940      	lsrs	r0, r0, #5
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80018ac:	492a      	ldr	r1, [pc, #168]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 80018ae:	f002 fc3f 	bl	8004130 <_test_assert>
 80018b2:	2800      	cmp	r0, #0
 80018b4:	d1ad      	bne.n	8001812 <test_007_006_execute.lto_priv.163+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80018b6:	69a6      	ldr	r6, [r4, #24]
 80018b8:	2320      	movs	r3, #32
 80018ba:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80018be:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80018c0:	b955      	cbnz	r5, 80018d8 <test_007_006_execute.lto_priv.163+0xe8>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 80018c2:	f04f 33ff 	mov.w	r3, #4294967295
 80018c6:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80018c8:	200a      	movs	r0, #10
 80018ca:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80018ce:	f004 fe67 	bl	80065a0 <chSchGoSleepTimeoutS>
 80018d2:	2800      	cmp	r0, #0
 80018d4:	db34      	blt.n	8001940 <test_007_006_execute.lto_priv.163+0x150>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 80018d6:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  ctp->epending &= ~m;
 80018d8:	2300      	movs	r3, #0
 80018da:	6373      	str	r3, [r6, #52]	; 0x34
 80018dc:	f383 8811 	msr	BASEPRI, r3
 80018e0:	fab5 f085 	clz	r0, r5
 80018e4:	0940      	lsrs	r0, r0, #5
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80018e6:	491c      	ldr	r1, [pc, #112]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
 80018e8:	f002 fc22 	bl	8004130 <_test_assert>
 80018ec:	4605      	mov	r5, r0
 80018ee:	2800      	cmp	r0, #0
 80018f0:	d18f      	bne.n	8001812 <test_007_006_execute.lto_priv.163+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80018f2:	69a4      	ldr	r4, [r4, #24]
 80018f4:	2320      	movs	r3, #32
 80018f6:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 80018fa:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80018fc:	3301      	adds	r3, #1
 80018fe:	d009      	beq.n	8001914 <test_007_006_execute.lto_priv.163+0x124>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8001900:	f04f 33ff 	mov.w	r3, #4294967295
 8001904:	6263      	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8001906:	200b      	movs	r0, #11
 8001908:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800190c:	f004 fe48 	bl	80065a0 <chSchGoSleepTimeoutS>
 8001910:	2800      	cmp	r0, #0
 8001912:	db19      	blt.n	8001948 <test_007_006_execute.lto_priv.163+0x158>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8001914:	2300      	movs	r3, #0
 8001916:	6363      	str	r3, [r4, #52]	; 0x34
 8001918:	f383 8811 	msr	BASEPRI, r3
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 800191c:	4628      	mov	r0, r5
 800191e:	490e      	ldr	r1, [pc, #56]	; (8001958 <test_007_006_execute.lto_priv.163+0x168>)
  }
}
 8001920:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8001924:	f002 bc04 	b.w	8004130 <_test_assert>
 8001928:	f380 8811 	msr	BASEPRI, r0
 800192c:	2001      	movs	r0, #1
 800192e:	e78b      	b.n	8001848 <test_007_006_execute.lto_priv.163+0x58>
 8001930:	6358      	str	r0, [r3, #52]	; 0x34
 8001932:	f380 8811 	msr	BASEPRI, r0
 8001936:	e796      	b.n	8001866 <test_007_006_execute.lto_priv.163+0x76>
 8001938:	f385 8811 	msr	BASEPRI, r5
 800193c:	2001      	movs	r0, #1
 800193e:	e7b5      	b.n	80018ac <test_007_006_execute.lto_priv.163+0xbc>
 8001940:	f385 8811 	msr	BASEPRI, r5
 8001944:	2001      	movs	r0, #1
 8001946:	e7ce      	b.n	80018e6 <test_007_006_execute.lto_priv.163+0xf6>
 8001948:	f385 8811 	msr	BASEPRI, r5
 800194c:	2501      	movs	r5, #1
 800194e:	e7e5      	b.n	800191c <test_007_006_execute.lto_priv.163+0x12c>
 8001950:	20000f5c 	.word	0x20000f5c
 8001954:	200012a0 	.word	0x200012a0
 8001958:	08007a30 	.word	0x08007a30
 800195c:	f3af 8000 	nop.w

08001960 <test_007_005_execute.lto_priv.161>:

static void test_007_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_005_execute(void) {
 8001960:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001962:	4c2b      	ldr	r4, [pc, #172]	; (8001a10 <test_007_005_execute.lto_priv.161+0xb0>)
 8001964:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8001966:	2005      	movs	r0, #5
static void test_007_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001968:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 800196a:	f004 fa39 	bl	8005de0 <chEvtAddEvents>
  }

  /* [7.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800196e:	2302      	movs	r3, #2
 8001970:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8001972:	f005 fd1d 	bl	80073b0 <chEvtWaitAll.constprop.44>
    test_assert(m == 5, "unexpected pending bit");
 8001976:	4927      	ldr	r1, [pc, #156]	; (8001a14 <test_007_005_execute.lto_priv.161+0xb4>)
 8001978:	f1a0 0005 	sub.w	r0, r0, #5
 800197c:	fab0 f080 	clz	r0, r0
 8001980:	0940      	lsrs	r0, r0, #5
 8001982:	f002 fbd5 	bl	8004130 <_test_assert>
 8001986:	b100      	cbz	r0, 800198a <test_007_005_execute.lto_priv.161+0x2a>
 8001988:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800198a:	f005 fcc9 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 800198e:	4922      	ldr	r1, [pc, #136]	; (8001a18 <test_007_005_execute.lto_priv.161+0xb8>)
 8001990:	fab0 f080 	clz	r0, r0
 8001994:	0940      	lsrs	r0, r0, #5
 8001996:	f002 fbcb 	bl	8004130 <_test_assert>
 800199a:	2800      	cmp	r0, #0
 800199c:	d1f4      	bne.n	8001988 <test_007_005_execute.lto_priv.161+0x28>
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 800199e:	2303      	movs	r3, #3
  {
    chEvtAddEvents(4);
 80019a0:	2004      	movs	r0, #4
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 80019a2:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(4);
 80019a4:	f004 fa1c 	bl	8005de0 <chEvtAddEvents>
  }

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 80019a8:	2304      	movs	r3, #4
 80019aa:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 80019ac:	f001 fbb8 	bl	8003120 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80019b0:	4b1a      	ldr	r3, [pc, #104]	; (8001a1c <test_007_005_execute.lto_priv.161+0xbc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80019b2:	4a1b      	ldr	r2, [pc, #108]	; (8001a20 <test_007_005_execute.lto_priv.161+0xc0>)
 80019b4:	699b      	ldr	r3, [r3, #24]
 80019b6:	6899      	ldr	r1, [r3, #8]

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
 80019b8:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80019ba:	3901      	subs	r1, #1
 80019bc:	4819      	ldr	r0, [pc, #100]	; (8001a24 <test_007_005_execute.lto_priv.161+0xc4>)
 80019be:	f005 fbd7 	bl	8007170 <chThdCreateStatic.constprop.69>
 80019c2:	4a19      	ldr	r2, [pc, #100]	; (8001a28 <test_007_005_execute.lto_priv.161+0xc8>)
  }

  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 80019c4:	2305      	movs	r3, #5
 80019c6:	6023      	str	r3, [r4, #0]
  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80019c8:	6010      	str	r0, [r2, #0]
  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 80019ca:	f005 fcf1 	bl	80073b0 <chEvtWaitAll.constprop.44>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80019ce:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 80019d2:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80019d4:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 80019d8:	f005 fee2 	bl	80077a0 <_test_assert_time_window.constprop.3>
 80019dc:	2800      	cmp	r0, #0
 80019de:	d1d3      	bne.n	8001988 <test_007_005_execute.lto_priv.161+0x28>
                            "out of time window");
    test_assert(m == 5, "event flags error");
 80019e0:	f1a4 0005 	sub.w	r0, r4, #5
 80019e4:	4911      	ldr	r1, [pc, #68]	; (8001a2c <test_007_005_execute.lto_priv.161+0xcc>)
 80019e6:	fab0 f080 	clz	r0, r0
 80019ea:	0940      	lsrs	r0, r0, #5
 80019ec:	f002 fba0 	bl	8004130 <_test_assert>
 80019f0:	2800      	cmp	r0, #0
 80019f2:	d1c9      	bne.n	8001988 <test_007_005_execute.lto_priv.161+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 80019f4:	f005 fc94 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 80019f8:	4907      	ldr	r1, [pc, #28]	; (8001a18 <test_007_005_execute.lto_priv.161+0xb8>)
 80019fa:	fab0 f080 	clz	r0, r0
 80019fe:	0940      	lsrs	r0, r0, #5
 8001a00:	f002 fb96 	bl	8004130 <_test_assert>
 8001a04:	2800      	cmp	r0, #0
 8001a06:	d1bf      	bne.n	8001988 <test_007_005_execute.lto_priv.161+0x28>
    test_wait_threads();
  }
}
 8001a08:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 5, "event flags error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8001a0c:	f001 bb98 	b.w	8003140 <test_wait_threads>
 8001a10:	20000f5c 	.word	0x20000f5c
 8001a14:	08007a40 	.word	0x08007a40
 8001a18:	08007a14 	.word	0x08007a14
 8001a1c:	200012a0 	.word	0x200012a0
 8001a20:	08004651 	.word	0x08004651
 8001a24:	200008b0 	.word	0x200008b0
 8001a28:	20000f60 	.word	0x20000f60
 8001a2c:	08007a58 	.word	0x08007a58

08001a30 <test_007_004_execute.lto_priv.159>:

static void test_007_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_004_execute(void) {
 8001a30:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001a32:	4c29      	ldr	r4, [pc, #164]	; (8001ad8 <test_007_004_execute.lto_priv.159+0xa8>)
 8001a34:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8001a36:	2005      	movs	r0, #5
static void test_007_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8001a38:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8001a3a:	f004 f9d1 	bl	8005de0 <chEvtAddEvents>
  }

  /* [7.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8001a3e:	2302      	movs	r3, #2
 8001a40:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001a42:	f005 fc9d 	bl	8007380 <chEvtWaitAny.constprop.45>
    test_assert(m == 5, "unexpected pending bit");
 8001a46:	4925      	ldr	r1, [pc, #148]	; (8001adc <test_007_004_execute.lto_priv.159+0xac>)
 8001a48:	f1a0 0005 	sub.w	r0, r0, #5
 8001a4c:	fab0 f080 	clz	r0, r0
 8001a50:	0940      	lsrs	r0, r0, #5
 8001a52:	f002 fb6d 	bl	8004130 <_test_assert>
 8001a56:	b100      	cbz	r0, 8001a5a <test_007_004_execute.lto_priv.159+0x2a>
 8001a58:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001a5a:	f005 fc61 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8001a5e:	4920      	ldr	r1, [pc, #128]	; (8001ae0 <test_007_004_execute.lto_priv.159+0xb0>)
 8001a60:	fab0 f080 	clz	r0, r0
 8001a64:	0940      	lsrs	r0, r0, #5
 8001a66:	f002 fb63 	bl	8004130 <_test_assert>
 8001a6a:	2800      	cmp	r0, #0
 8001a6c:	d1f4      	bne.n	8001a58 <test_007_004_execute.lto_priv.159+0x28>
  }

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8001a6e:	2303      	movs	r3, #3
 8001a70:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001a72:	f001 fb55 	bl	8003120 <test_wait_tick>
 8001a76:	4b1b      	ldr	r3, [pc, #108]	; (8001ae4 <test_007_004_execute.lto_priv.159+0xb4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001a78:	4a1b      	ldr	r2, [pc, #108]	; (8001ae8 <test_007_004_execute.lto_priv.159+0xb8>)
 8001a7a:	699b      	ldr	r3, [r3, #24]
 8001a7c:	6899      	ldr	r1, [r3, #8]

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001a7e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001a80:	3901      	subs	r1, #1
 8001a82:	481a      	ldr	r0, [pc, #104]	; (8001aec <test_007_004_execute.lto_priv.159+0xbc>)
 8001a84:	f005 fb74 	bl	8007170 <chThdCreateStatic.constprop.69>
 8001a88:	4a19      	ldr	r2, [pc, #100]	; (8001af0 <test_007_004_execute.lto_priv.159+0xc0>)
  }

  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8001a8a:	2304      	movs	r3, #4
 8001a8c:	6023      	str	r3, [r4, #0]
  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001a8e:	6010      	str	r0, [r2, #0]
  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001a90:	f005 fc76 	bl	8007380 <chEvtWaitAny.constprop.45>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001a94:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8001a98:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001a9a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8001a9e:	f005 fe7f 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8001aa2:	2800      	cmp	r0, #0
 8001aa4:	d1d8      	bne.n	8001a58 <test_007_004_execute.lto_priv.159+0x28>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8001aa6:	f1a4 0001 	sub.w	r0, r4, #1
 8001aaa:	4912      	ldr	r1, [pc, #72]	; (8001af4 <test_007_004_execute.lto_priv.159+0xc4>)
 8001aac:	fab0 f080 	clz	r0, r0
 8001ab0:	0940      	lsrs	r0, r0, #5
 8001ab2:	f002 fb3d 	bl	8004130 <_test_assert>
 8001ab6:	2800      	cmp	r0, #0
 8001ab8:	d1ce      	bne.n	8001a58 <test_007_004_execute.lto_priv.159+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001aba:	f005 fc31 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8001abe:	4908      	ldr	r1, [pc, #32]	; (8001ae0 <test_007_004_execute.lto_priv.159+0xb0>)
 8001ac0:	fab0 f080 	clz	r0, r0
 8001ac4:	0940      	lsrs	r0, r0, #5
 8001ac6:	f002 fb33 	bl	8004130 <_test_assert>
 8001aca:	2800      	cmp	r0, #0
 8001acc:	d1c4      	bne.n	8001a58 <test_007_004_execute.lto_priv.159+0x28>
    test_wait_threads();
  }
}
 8001ace:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8001ad2:	f001 bb35 	b.w	8003140 <test_wait_threads>
 8001ad6:	bf00      	nop
 8001ad8:	20000f5c 	.word	0x20000f5c
 8001adc:	08007a40 	.word	0x08007a40
 8001ae0:	08007a14 	.word	0x08007a14
 8001ae4:	200012a0 	.word	0x200012a0
 8001ae8:	08004651 	.word	0x08004651
 8001aec:	200008b0 	.word	0x200008b0
 8001af0:	20000f60 	.word	0x20000f60
 8001af4:	08007a6c 	.word	0x08007a6c
 8001af8:	f3af 8000 	nop.w
 8001afc:	f3af 8000 	nop.w

08001b00 <test_007_003_execute.lto_priv.157>:

static void test_007_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_003_execute(void) {
 8001b00:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8001b02:	4c35      	ldr	r4, [pc, #212]	; (8001bd8 <test_007_003_execute.lto_priv.157+0xd8>)
 8001b04:	2301      	movs	r3, #1
  {
    chEvtAddEvents(7);
 8001b06:	2007      	movs	r0, #7
static void test_007_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8001b08:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(7);
 8001b0a:	f004 f969 	bl	8005de0 <chEvtAddEvents>
  }

  /* [7.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 8001b0e:	2302      	movs	r3, #2
 8001b10:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001b12:	f005 fc15 	bl	8007340 <chEvtWaitOne.constprop.46>
    test_assert(m == 1, "single event error");
 8001b16:	4931      	ldr	r1, [pc, #196]	; (8001bdc <test_007_003_execute.lto_priv.157+0xdc>)
 8001b18:	f1a0 0001 	sub.w	r0, r0, #1
 8001b1c:	fab0 f080 	clz	r0, r0
 8001b20:	0940      	lsrs	r0, r0, #5
 8001b22:	f002 fb05 	bl	8004130 <_test_assert>
 8001b26:	b100      	cbz	r0, 8001b2a <test_007_003_execute.lto_priv.157+0x2a>
 8001b28:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 8001b2a:	f005 fc09 	bl	8007340 <chEvtWaitOne.constprop.46>
    test_assert(m == 2, "single event error");
 8001b2e:	492b      	ldr	r1, [pc, #172]	; (8001bdc <test_007_003_execute.lto_priv.157+0xdc>)
 8001b30:	f1a0 0002 	sub.w	r0, r0, #2
 8001b34:	fab0 f080 	clz	r0, r0
 8001b38:	0940      	lsrs	r0, r0, #5
 8001b3a:	f002 faf9 	bl	8004130 <_test_assert>
 8001b3e:	2800      	cmp	r0, #0
 8001b40:	d1f2      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
    m = chEvtWaitOne(ALL_EVENTS);
 8001b42:	f005 fbfd 	bl	8007340 <chEvtWaitOne.constprop.46>
    test_assert(m == 4, "single event error");
 8001b46:	4925      	ldr	r1, [pc, #148]	; (8001bdc <test_007_003_execute.lto_priv.157+0xdc>)
 8001b48:	f1a0 0004 	sub.w	r0, r0, #4
 8001b4c:	fab0 f080 	clz	r0, r0
 8001b50:	0940      	lsrs	r0, r0, #5
 8001b52:	f002 faed 	bl	8004130 <_test_assert>
 8001b56:	2800      	cmp	r0, #0
 8001b58:	d1e6      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001b5a:	f005 fbe1 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8001b5e:	4920      	ldr	r1, [pc, #128]	; (8001be0 <test_007_003_execute.lto_priv.157+0xe0>)
 8001b60:	fab0 f080 	clz	r0, r0
 8001b64:	0940      	lsrs	r0, r0, #5
 8001b66:	f002 fae3 	bl	8004130 <_test_assert>
 8001b6a:	2800      	cmp	r0, #0
 8001b6c:	d1dc      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
  }

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8001b6e:	2303      	movs	r3, #3
 8001b70:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001b72:	f001 fad5 	bl	8003120 <test_wait_tick>
 8001b76:	4b1b      	ldr	r3, [pc, #108]	; (8001be4 <test_007_003_execute.lto_priv.157+0xe4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001b78:	4a1b      	ldr	r2, [pc, #108]	; (8001be8 <test_007_003_execute.lto_priv.157+0xe8>)
 8001b7a:	699b      	ldr	r3, [r3, #24]
 8001b7c:	6899      	ldr	r1, [r3, #8]

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8001b7e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001b80:	3901      	subs	r1, #1
 8001b82:	481a      	ldr	r0, [pc, #104]	; (8001bec <test_007_003_execute.lto_priv.157+0xec>)
 8001b84:	f005 faf4 	bl	8007170 <chThdCreateStatic.constprop.69>
 8001b88:	4a19      	ldr	r2, [pc, #100]	; (8001bf0 <test_007_003_execute.lto_priv.157+0xf0>)
  }

  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8001b8a:	2304      	movs	r3, #4
 8001b8c:	6023      	str	r3, [r4, #0]
  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001b8e:	6010      	str	r0, [r2, #0]
  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001b90:	f005 fbd6 	bl	8007340 <chEvtWaitOne.constprop.46>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001b94:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8001b98:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001b9a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8001b9e:	f005 fdff 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8001ba2:	2800      	cmp	r0, #0
 8001ba4:	d1c0      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8001ba6:	f1a4 0001 	sub.w	r0, r4, #1
 8001baa:	4912      	ldr	r1, [pc, #72]	; (8001bf4 <test_007_003_execute.lto_priv.157+0xf4>)
 8001bac:	fab0 f080 	clz	r0, r0
 8001bb0:	0940      	lsrs	r0, r0, #5
 8001bb2:	f002 fabd 	bl	8004130 <_test_assert>
 8001bb6:	2800      	cmp	r0, #0
 8001bb8:	d1b6      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8001bba:	f005 fbb1 	bl	8007320 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8001bbe:	4908      	ldr	r1, [pc, #32]	; (8001be0 <test_007_003_execute.lto_priv.157+0xe0>)
 8001bc0:	fab0 f080 	clz	r0, r0
 8001bc4:	0940      	lsrs	r0, r0, #5
 8001bc6:	f002 fab3 	bl	8004130 <_test_assert>
 8001bca:	2800      	cmp	r0, #0
 8001bcc:	d1ac      	bne.n	8001b28 <test_007_003_execute.lto_priv.157+0x28>
    test_wait_threads();
  }
}
 8001bce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8001bd2:	f001 bab5 	b.w	8003140 <test_wait_threads>
 8001bd6:	bf00      	nop
 8001bd8:	20000f5c 	.word	0x20000f5c
 8001bdc:	08007a80 	.word	0x08007a80
 8001be0:	08007a14 	.word	0x08007a14
 8001be4:	200012a0 	.word	0x200012a0
 8001be8:	08004651 	.word	0x08004651
 8001bec:	200008b0 	.word	0x200008b0
 8001bf0:	20000f60 	.word	0x20000f60
 8001bf4:	08007a6c 	.word	0x08007a6c
 8001bf8:	f3af 8000 	nop.w
 8001bfc:	f3af 8000 	nop.w

08001c00 <test_012_011_setup.lto_priv.200>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001c00:	4b02      	ldr	r3, [pc, #8]	; (8001c0c <test_012_011_setup.lto_priv.200+0xc>)
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8001c02:	2200      	movs	r2, #0
 8001c04:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001c06:	605b      	str	r3, [r3, #4]
 8001c08:	609a      	str	r2, [r3, #8]
 8001c0a:	4770      	bx	lr
 8001c0c:	20000f2c 	.word	0x20000f2c

08001c10 <test_012_010_setup.lto_priv.198>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001c10:	4b02      	ldr	r3, [pc, #8]	; (8001c1c <test_012_010_setup.lto_priv.198+0xc>)
 8001c12:	2201      	movs	r2, #1
 8001c14:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001c16:	605b      	str	r3, [r3, #4]
 8001c18:	609a      	str	r2, [r3, #8]
 8001c1a:	4770      	bx	lr
 8001c1c:	20000f3c 	.word	0x20000f3c

08001c20 <test_012_007_setup.lto_priv.194>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001c20:	4b02      	ldr	r3, [pc, #8]	; (8001c2c <test_012_007_setup.lto_priv.194+0xc>)
 8001c22:	2200      	movs	r2, #0
 8001c24:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001c26:	605b      	str	r3, [r3, #4]
 8001c28:	609a      	str	r2, [r3, #8]
 8001c2a:	4770      	bx	lr
 8001c2c:	20000f3c 	.word	0x20000f3c

08001c30 <cmd_systime>:

#if (SHELL_CMD_SYSTIME_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8001c30:	2900      	cmp	r1, #0
 8001c32:	dd03      	ble.n	8001c3c <cmd_systime+0xc>
    shellUsage(chp, "systime");
 8001c34:	4907      	ldr	r1, [pc, #28]	; (8001c54 <cmd_systime+0x24>)
 8001c36:	4a08      	ldr	r2, [pc, #32]	; (8001c58 <cmd_systime+0x28>)
 8001c38:	f004 be02 	b.w	8006840 <chprintf>
 8001c3c:	2320      	movs	r3, #32
 8001c3e:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8001c42:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001c46:	2300      	movs	r3, #0
 8001c48:	6a52      	ldr	r2, [r2, #36]	; 0x24
 8001c4a:	f383 8811 	msr	BASEPRI, r3
    return;
  }
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
 8001c4e:	4903      	ldr	r1, [pc, #12]	; (8001c5c <cmd_systime+0x2c>)
 8001c50:	f004 bdf6 	b.w	8006840 <chprintf>
 8001c54:	08007ab4 	.word	0x08007ab4
 8001c58:	08007ac0 	.word	0x08007ac0
 8001c5c:	08007ac8 	.word	0x08007ac8

08001c60 <cmd_echo>:

#if (SHELL_CMD_ECHO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_echo(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc != 1) {
 8001c60:	2901      	cmp	r1, #1
 8001c62:	d003      	beq.n	8001c6c <cmd_echo+0xc>
    shellUsage(chp, "echo \"message\"");
 8001c64:	4903      	ldr	r1, [pc, #12]	; (8001c74 <cmd_echo+0x14>)
 8001c66:	4a04      	ldr	r2, [pc, #16]	; (8001c78 <cmd_echo+0x18>)
 8001c68:	f004 bdea 	b.w	8006840 <chprintf>
    return;
  }
  chprintf(chp, "%s"SHELL_NEWLINE_STR, argv[0]);
 8001c6c:	6812      	ldr	r2, [r2, #0]
 8001c6e:	4903      	ldr	r1, [pc, #12]	; (8001c7c <cmd_echo+0x1c>)
 8001c70:	f004 bde6 	b.w	8006840 <chprintf>
 8001c74:	08007ab4 	.word	0x08007ab4
 8001c78:	08007ad0 	.word	0x08007ad0
 8001c7c:	08007ae0 	.word	0x08007ae0

08001c80 <cmd_info>:

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8001c80:	2900      	cmp	r1, #0
 8001c82:	dd03      	ble.n	8001c8c <cmd_info+0xc>
    shellUsage(chp, "info");
 8001c84:	4919      	ldr	r1, [pc, #100]	; (8001cec <cmd_info+0x6c>)
 8001c86:	4a1a      	ldr	r2, [pc, #104]	; (8001cf0 <cmd_info+0x70>)
 8001c88:	f004 bdda 	b.w	8006840 <chprintf>
  shellExit(MSG_OK);
}
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001c8c:	b510      	push	{r4, lr}
  if (argc > 0) {
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8001c8e:	4919      	ldr	r1, [pc, #100]	; (8001cf4 <cmd_info+0x74>)
 8001c90:	4a19      	ldr	r2, [pc, #100]	; (8001cf8 <cmd_info+0x78>)
  shellExit(MSG_OK);
}
#endif

#if (SHELL_CMD_INFO_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001c92:	b082      	sub	sp, #8
 8001c94:	4604      	mov	r4, r0
  if (argc > 0) {
    shellUsage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s"SHELL_NEWLINE_STR, CH_KERNEL_VERSION);
 8001c96:	f004 fdd3 	bl	8006840 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s"SHELL_NEWLINE_STR, PORT_COMPILER_NAME);
 8001c9a:	4620      	mov	r0, r4
 8001c9c:	4917      	ldr	r1, [pc, #92]	; (8001cfc <cmd_info+0x7c>)
 8001c9e:	4a18      	ldr	r2, [pc, #96]	; (8001d00 <cmd_info+0x80>)
 8001ca0:	f004 fdce 	bl	8006840 <chprintf>
#endif
  chprintf(chp, "Architecture: %s"SHELL_NEWLINE_STR, PORT_ARCHITECTURE_NAME);
 8001ca4:	4620      	mov	r0, r4
 8001ca6:	4917      	ldr	r1, [pc, #92]	; (8001d04 <cmd_info+0x84>)
 8001ca8:	4a17      	ldr	r2, [pc, #92]	; (8001d08 <cmd_info+0x88>)
 8001caa:	f004 fdc9 	bl	8006840 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s"SHELL_NEWLINE_STR, PORT_CORE_VARIANT_NAME);
 8001cae:	4620      	mov	r0, r4
 8001cb0:	4916      	ldr	r1, [pc, #88]	; (8001d0c <cmd_info+0x8c>)
 8001cb2:	4a17      	ldr	r2, [pc, #92]	; (8001d10 <cmd_info+0x90>)
 8001cb4:	f004 fdc4 	bl	8006840 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s"SHELL_NEWLINE_STR, PORT_INFO);
 8001cb8:	4620      	mov	r0, r4
 8001cba:	4916      	ldr	r1, [pc, #88]	; (8001d14 <cmd_info+0x94>)
 8001cbc:	4a16      	ldr	r2, [pc, #88]	; (8001d18 <cmd_info+0x98>)
 8001cbe:	f004 fdbf 	bl	8006840 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s"SHELL_NEWLINE_STR, PLATFORM_NAME);
 8001cc2:	4620      	mov	r0, r4
 8001cc4:	4915      	ldr	r1, [pc, #84]	; (8001d1c <cmd_info+0x9c>)
 8001cc6:	4a16      	ldr	r2, [pc, #88]	; (8001d20 <cmd_info+0xa0>)
 8001cc8:	f004 fdba 	bl	8006840 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s"SHELL_NEWLINE_STR, BOARD_NAME);
 8001ccc:	4620      	mov	r0, r4
 8001cce:	4915      	ldr	r1, [pc, #84]	; (8001d24 <cmd_info+0xa4>)
 8001cd0:	4a15      	ldr	r2, [pc, #84]	; (8001d28 <cmd_info+0xa8>)
 8001cd2:	f004 fdb5 	bl	8006840 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s"SHELL_NEWLINE_STR, __DATE__, " - ", __TIME__);
 8001cd6:	4b15      	ldr	r3, [pc, #84]	; (8001d2c <cmd_info+0xac>)
 8001cd8:	9300      	str	r3, [sp, #0]
 8001cda:	4620      	mov	r0, r4
 8001cdc:	4914      	ldr	r1, [pc, #80]	; (8001d30 <cmd_info+0xb0>)
 8001cde:	4a15      	ldr	r2, [pc, #84]	; (8001d34 <cmd_info+0xb4>)
 8001ce0:	4b15      	ldr	r3, [pc, #84]	; (8001d38 <cmd_info+0xb8>)
 8001ce2:	f004 fdad 	bl	8006840 <chprintf>
#endif
#endif
}
 8001ce6:	b002      	add	sp, #8
 8001ce8:	bd10      	pop	{r4, pc}
 8001cea:	bf00      	nop
 8001cec:	08007ab4 	.word	0x08007ab4
 8001cf0:	08007ae8 	.word	0x08007ae8
 8001cf4:	08007af0 	.word	0x08007af0
 8001cf8:	08007b04 	.word	0x08007b04
 8001cfc:	08007b0c 	.word	0x08007b0c
 8001d00:	08007b20 	.word	0x08007b20
 8001d04:	08007b68 	.word	0x08007b68
 8001d08:	08007b7c 	.word	0x08007b7c
 8001d0c:	08007b88 	.word	0x08007b88
 8001d10:	08007b9c 	.word	0x08007b9c
 8001d14:	08007ba8 	.word	0x08007ba8
 8001d18:	08007bbc 	.word	0x08007bbc
 8001d1c:	08007bd4 	.word	0x08007bd4
 8001d20:	08007be8 	.word	0x08007be8
 8001d24:	08007c04 	.word	0x08007c04
 8001d28:	08007c18 	.word	0x08007c18
 8001d2c:	08007c68 	.word	0x08007c68
 8001d30:	08007c40 	.word	0x08007c40
 8001d34:	08007c58 	.word	0x08007c58
 8001d38:	08007c64 	.word	0x08007c64
 8001d3c:	f3af 8000 	nop.w

08001d40 <cmd_test>:
#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8001d40:	2900      	cmp	r1, #0
 8001d42:	dd03      	ble.n	8001d4c <cmd_test+0xc>
    shellUsage(chp, "test");
 8001d44:	490f      	ldr	r1, [pc, #60]	; (8001d84 <cmd_test+0x44>)
 8001d46:	4a10      	ldr	r2, [pc, #64]	; (8001d88 <cmd_test+0x48>)
 8001d48:	f004 bd7a 	b.w	8006840 <chprintf>
  } while (tp != NULL);
}
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001d4c:	b510      	push	{r4, lr}
 8001d4e:	4b0f      	ldr	r3, [pc, #60]	; (8001d8c <cmd_test+0x4c>)
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "test");
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 8001d50:	490f      	ldr	r1, [pc, #60]	; (8001d90 <cmd_test+0x50>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001d52:	699b      	ldr	r3, [r3, #24]
 8001d54:	4a0c      	ldr	r2, [pc, #48]	; (8001d88 <cmd_test+0x48>)
 8001d56:	689b      	ldr	r3, [r3, #8]
  } while (tp != NULL);
}
#endif

#if (SHELL_CMD_TEST_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_test(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001d58:	b082      	sub	sp, #8
 8001d5a:	4604      	mov	r4, r0
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "test");
    return;
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
 8001d5c:	e88d 0012 	stmia.w	sp, {r1, r4}
 8001d60:	2000      	movs	r0, #0
 8001d62:	f44f 71e4 	mov.w	r1, #456	; 0x1c8
 8001d66:	f002 faf3 	bl	8004350 <chThdCreateFromHeap>
                           "test", chThdGetPriorityX(),
                           (tfunc_t)test_execute, chp);
  if (tp == NULL) {
 8001d6a:	b120      	cbz	r0, 8001d76 <cmd_test+0x36>
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
    return;
  }
  chThdWait(tp);
}
 8001d6c:	b002      	add	sp, #8
 8001d6e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
                           (tfunc_t)test_execute, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
    return;
  }
  chThdWait(tp);
 8001d72:	f004 ba25 	b.w	80061c0 <chThdWait>
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
                           "test", chThdGetPriorityX(),
                           (tfunc_t)test_execute, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
 8001d76:	4907      	ldr	r1, [pc, #28]	; (8001d94 <cmd_test+0x54>)
 8001d78:	4620      	mov	r0, r4
    return;
  }
  chThdWait(tp);
}
 8001d7a:	b002      	add	sp, #8
 8001d7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  }
  tp = chThdCreateFromHeap(NULL, SHELL_CMD_TEST_WA_SIZE,
                           "test", chThdGetPriorityX(),
                           (tfunc_t)test_execute, chp);
  if (tp == NULL) {
    chprintf(chp, "out of memory"SHELL_NEWLINE_STR);
 8001d80:	f004 bd5e 	b.w	8006840 <chprintf>
 8001d84:	08007ab4 	.word	0x08007ab4
 8001d88:	08008c5c 	.word	0x08008c5c
 8001d8c:	200012a0 	.word	0x200012a0
 8001d90:	08003e41 	.word	0x08003e41
 8001d94:	08007c74 	.word	0x08007c74
 8001d98:	f3af 8000 	nop.w
 8001d9c:	f3af 8000 	nop.w

08001da0 <cmd_threads>:
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8001da0:	2900      	cmp	r1, #0
 8001da2:	dd03      	ble.n	8001dac <cmd_threads+0xc>
    shellUsage(chp, "threads");
 8001da4:	4926      	ldr	r1, [pc, #152]	; (8001e40 <cmd_threads+0xa0>)
 8001da6:	4a27      	ldr	r2, [pc, #156]	; (8001e44 <cmd_threads+0xa4>)
 8001da8:	f004 bd4a 	b.w	8006840 <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001dac:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
 8001db0:	4925      	ldr	r1, [pc, #148]	; (8001e48 <cmd_threads+0xa8>)
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
#endif

#if (SHELL_CMD_THREADS_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001db2:	b087      	sub	sp, #28
 8001db4:	4606      	mov	r6, r0
 8001db6:	2720      	movs	r7, #32
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "threads");
    return;
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
 8001db8:	f004 fd42 	bl	8006840 <chprintf>
 8001dbc:	f387 8811 	msr	BASEPRI, r7
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.newer;
 8001dc0:	f8df 808c 	ldr.w	r8, [pc, #140]	; 8001e50 <cmd_threads+0xb0>
 8001dc4:	f8d8 4010 	ldr.w	r4, [r8, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->refs++;
 8001dc8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8001dcc:	3301      	adds	r3, #1
 8001dce:	f884 3022 	strb.w	r3, [r4, #34]	; 0x22
 8001dd2:	2300      	movs	r3, #0
 8001dd4:	f383 8811 	msr	BASEPRI, r3
 8001dd8:	f8df a078 	ldr.w	sl, [pc, #120]	; 8001e54 <cmd_threads+0xb4>
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8001ddc:	f8df 9078 	ldr.w	r9, [pc, #120]	; 8001e58 <cmd_threads+0xb8>
 8001de0:	46bb      	mov	fp, r7
 8001de2:	e000      	b.n	8001de6 <cmd_threads+0x46>
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
 8001de4:	462c      	mov	r4, r5
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
 8001de6:	f894 0022 	ldrb.w	r0, [r4, #34]	; 0x22
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8001dea:	f894 5020 	ldrb.w	r5, [r4, #32]
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
             tp->name == NULL ? "" : tp->name);
 8001dee:	69a1      	ldr	r1, [r4, #24]
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8001df0:	68a7      	ldr	r7, [r4, #8]
 8001df2:	f85a 5025 	ldr.w	r5, [sl, r5, lsl #2]
  }
  chprintf(chp, "stklimit    stack     addr refs prio     state         name\r\n"SHELL_NEWLINE_STR);
  tp = chRegFirstThread();
  do {
#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
    uint32_t stklimit = (uint32_t)tp->wabase;
 8001df6:	69e2      	ldr	r2, [r4, #28]
#else
    uint32_t stklimit = 0U;
#endif
    chprintf(chp, "%08lx %08lx %08lx %4lu %4lu %9s %12s"SHELL_NEWLINE_STR,
 8001df8:	68e3      	ldr	r3, [r4, #12]
 8001dfa:	9702      	str	r7, [sp, #8]
 8001dfc:	2900      	cmp	r1, #0
 8001dfe:	bf08      	it	eq
 8001e00:	4649      	moveq	r1, r9
 8001e02:	3801      	subs	r0, #1
 8001e04:	9001      	str	r0, [sp, #4]
 8001e06:	9104      	str	r1, [sp, #16]
 8001e08:	9503      	str	r5, [sp, #12]
 8001e0a:	9400      	str	r4, [sp, #0]
 8001e0c:	4630      	mov	r0, r6
 8001e0e:	490f      	ldr	r1, [pc, #60]	; (8001e4c <cmd_threads+0xac>)
 8001e10:	f004 fd16 	bl	8006840 <chprintf>
 8001e14:	f38b 8811 	msr	BASEPRI, fp
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->newer;
 8001e18:	6925      	ldr	r5, [r4, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001e1a:	4545      	cmp	r5, r8
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->refs < (trefs_t)255, "too many references");
    ntp->refs++;
 8001e1c:	bf1d      	ittte	ne
 8001e1e:	f895 3022 	ldrbne.w	r3, [r5, #34]	; 0x22
 8001e22:	3301      	addne	r3, #1
 8001e24:	f885 3022 	strbne.w	r3, [r5, #34]	; 0x22
  chSysLock();
  ntp = tp->newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 8001e28:	2500      	moveq	r5, #0
 8001e2a:	2300      	movs	r3, #0
 8001e2c:	f383 8811 	msr	BASEPRI, r3
    ntp->refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8001e30:	4620      	mov	r0, r4
 8001e32:	f004 f855 	bl	8005ee0 <chThdRelease>
             stklimit, (uint32_t)tp->ctx.sp, (uint32_t)tp,
             (uint32_t)tp->refs - 1, (uint32_t)tp->prio, states[tp->state],
             tp->name == NULL ? "" : tp->name);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
 8001e36:	2d00      	cmp	r5, #0
 8001e38:	d1d4      	bne.n	8001de4 <cmd_threads+0x44>
}
 8001e3a:	b007      	add	sp, #28
 8001e3c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001e40:	08007ab4 	.word	0x08007ab4
 8001e44:	08007c84 	.word	0x08007c84
 8001e48:	08007c8c 	.word	0x08007c8c
 8001e4c:	08007ccc 	.word	0x08007ccc
 8001e50:	200012a0 	.word	0x200012a0
 8001e54:	08007f84 	.word	0x08007f84
 8001e58:	08007dd8 	.word	0x08007dd8
 8001e5c:	f3af 8000 	nop.w

08001e60 <cmd_mem>:
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001e60:	b530      	push	{r4, r5, lr}
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
 8001e62:	2900      	cmp	r1, #0
  chprintf(chp, "%lu"SHELL_NEWLINE_STR, (unsigned long)chVTGetSystemTime());
}
#endif

#if (SHELL_CMD_MEM_ENABLED == TRUE) || defined(__DOXYGEN__)
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001e64:	b083      	sub	sp, #12
  size_t n, total, largest;

  (void)argv;
  if (argc > 0) {
 8001e66:	dd05      	ble.n	8001e74 <cmd_mem+0x14>
    shellUsage(chp, "mem");
 8001e68:	4913      	ldr	r1, [pc, #76]	; (8001eb8 <cmd_mem+0x58>)
 8001e6a:	4a14      	ldr	r2, [pc, #80]	; (8001ebc <cmd_mem+0x5c>)
 8001e6c:	f004 fce8 	bl	8006840 <chprintf>
  n = chHeapStatus(NULL, &total, &largest);
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
}
 8001e70:	b003      	add	sp, #12
 8001e72:	bd30      	pop	{r4, r5, pc}
 8001e74:	4604      	mov	r4, r0
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "mem");
    return;
  }
  n = chHeapStatus(NULL, &total, &largest);
 8001e76:	4669      	mov	r1, sp
 8001e78:	aa01      	add	r2, sp, #4
 8001e7a:	2000      	movs	r0, #0
 8001e7c:	f002 f9d8 	bl	8004230 <chHeapStatus>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 8001e80:	4a0f      	ldr	r2, [pc, #60]	; (8001ec0 <cmd_mem+0x60>)
 8001e82:	4b10      	ldr	r3, [pc, #64]	; (8001ec4 <cmd_mem+0x64>)
 8001e84:	6812      	ldr	r2, [r2, #0]
 8001e86:	681b      	ldr	r3, [r3, #0]
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 8001e88:	490f      	ldr	r1, [pc, #60]	; (8001ec8 <cmd_mem+0x68>)
 8001e8a:	1ad2      	subs	r2, r2, r3
  (void)argv;
  if (argc > 0) {
    shellUsage(chp, "mem");
    return;
  }
  n = chHeapStatus(NULL, &total, &largest);
 8001e8c:	4605      	mov	r5, r0
  chprintf(chp, "core free memory : %u bytes"SHELL_NEWLINE_STR, chCoreGetStatusX());
 8001e8e:	4620      	mov	r0, r4
 8001e90:	f004 fcd6 	bl	8006840 <chprintf>
  chprintf(chp, "heap fragments   : %u"SHELL_NEWLINE_STR, n);
 8001e94:	462a      	mov	r2, r5
 8001e96:	4620      	mov	r0, r4
 8001e98:	490c      	ldr	r1, [pc, #48]	; (8001ecc <cmd_mem+0x6c>)
 8001e9a:	f004 fcd1 	bl	8006840 <chprintf>
  chprintf(chp, "heap free total  : %u bytes"SHELL_NEWLINE_STR, total);
 8001e9e:	9a00      	ldr	r2, [sp, #0]
 8001ea0:	490b      	ldr	r1, [pc, #44]	; (8001ed0 <cmd_mem+0x70>)
 8001ea2:	4620      	mov	r0, r4
 8001ea4:	f004 fccc 	bl	8006840 <chprintf>
  chprintf(chp, "heap free largest: %u bytes"SHELL_NEWLINE_STR, largest);
 8001ea8:	4620      	mov	r0, r4
 8001eaa:	490a      	ldr	r1, [pc, #40]	; (8001ed4 <cmd_mem+0x74>)
 8001eac:	9a01      	ldr	r2, [sp, #4]
 8001eae:	f004 fcc7 	bl	8006840 <chprintf>
}
 8001eb2:	b003      	add	sp, #12
 8001eb4:	bd30      	pop	{r4, r5, pc}
 8001eb6:	bf00      	nop
 8001eb8:	08007ab4 	.word	0x08007ab4
 8001ebc:	08007cf4 	.word	0x08007cf4
 8001ec0:	20000fe0 	.word	0x20000fe0
 8001ec4:	20000fe4 	.word	0x20000fe4
 8001ec8:	08007cf8 	.word	0x08007cf8
 8001ecc:	08007d18 	.word	0x08007d18
 8001ed0:	08007d30 	.word	0x08007d30
 8001ed4:	08007d50 	.word	0x08007d50
 8001ed8:	f3af 8000 	nop.w
 8001edc:	f3af 8000 	nop.w

08001ee0 <cmd_exit>:
#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8001ee0:	2900      	cmp	r1, #0
 8001ee2:	dd03      	ble.n	8001eec <cmd_exit+0xc>
    shellUsage(chp, "exit");
 8001ee4:	4908      	ldr	r1, [pc, #32]	; (8001f08 <cmd_exit+0x28>)
 8001ee6:	4a09      	ldr	r2, [pc, #36]	; (8001f0c <cmd_exit+0x2c>)
 8001ee8:	f004 bcaa 	b.w	8006840 <chprintf>
/* Module local functions.                                                   */
/*===========================================================================*/

#if ((SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)) ||        \
    defined(__DOXYGEN__)
static void cmd_exit(BaseSequentialStream *chp, int argc, char *argv[]) {
 8001eec:	b508      	push	{r3, lr}
 8001eee:	2320      	movs	r3, #32
 8001ef0:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8001ef4:	4806      	ldr	r0, [pc, #24]	; (8001f10 <cmd_exit+0x30>)
 8001ef6:	2100      	movs	r1, #0
 8001ef8:	f003 ff5a 	bl	8005db0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8001efc:	2000      	movs	r0, #0
    shellUsage(chp, "exit");
    return;
  }

  shellExit(MSG_OK);
}
 8001efe:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
 8001f02:	f004 baa5 	b.w	8006450 <chThdExitS>
 8001f06:	bf00      	nop
 8001f08:	08007ab4 	.word	0x08007ab4
 8001f0c:	08007d70 	.word	0x08007d70
 8001f10:	20001190 	.word	0x20001190
 8001f14:	f3af 8000 	nop.w
 8001f18:	f3af 8000 	nop.w
 8001f1c:	f3af 8000 	nop.w

08001f20 <parse_arguments>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static char *parse_arguments(char *str, char **saveptr) {
 8001f20:	b570      	push	{r4, r5, r6, lr}
 8001f22:	460e      	mov	r6, r1
  char *p;

  if (str != NULL)
 8001f24:	4604      	mov	r4, r0
 8001f26:	b1b8      	cbz	r0, 8001f58 <parse_arguments+0x38>
    *saveptr = str;
 8001f28:	6030      	str	r0, [r6, #0]
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 8001f2a:	4911      	ldr	r1, [pc, #68]	; (8001f70 <parse_arguments+0x50>)
 8001f2c:	4620      	mov	r0, r4
 8001f2e:	f005 fce1 	bl	80078f4 <strspn>

  if (*p == '"') {
 8001f32:	5c21      	ldrb	r1, [r4, r0]
 8001f34:	2922      	cmp	r1, #34	; 0x22
  if (!p) {
    return NULL;
  }

  /* Skipping white space.*/
  p += strspn(p, " \t");
 8001f36:	eb04 0500 	add.w	r5, r4, r0

  if (*p == '"') {
 8001f3a:	d012      	beq.n	8001f62 <parse_arguments+0x42>
    p++;
    *saveptr = strpbrk(p, "\"");
  }
  else {
    /* The delimiter is white space.*/
    *saveptr = strpbrk(p, " \t");
 8001f3c:	4628      	mov	r0, r5
 8001f3e:	490c      	ldr	r1, [pc, #48]	; (8001f70 <parse_arguments+0x50>)
 8001f40:	f005 fcb4 	bl	80078ac <strpbrk>
 8001f44:	6030      	str	r0, [r6, #0]
  }

  /* Replacing the delimiter with a zero.*/
  if (*saveptr != NULL) {
 8001f46:	b118      	cbz	r0, 8001f50 <parse_arguments+0x30>
    *(*saveptr)++ = '\0';
 8001f48:	1c42      	adds	r2, r0, #1
 8001f4a:	2300      	movs	r3, #0
 8001f4c:	6032      	str	r2, [r6, #0]
 8001f4e:	7003      	strb	r3, [r0, #0]
  }

  return *p != '\0' ? p : NULL;
 8001f50:	782b      	ldrb	r3, [r5, #0]
 8001f52:	b123      	cbz	r3, 8001f5e <parse_arguments+0x3e>
 8001f54:	4628      	mov	r0, r5
}
 8001f56:	bd70      	pop	{r4, r5, r6, pc}
  char *p;

  if (str != NULL)
    *saveptr = str;

  p = *saveptr;
 8001f58:	680c      	ldr	r4, [r1, #0]
  if (!p) {
 8001f5a:	2c00      	cmp	r4, #0
 8001f5c:	d1e5      	bne.n	8001f2a <parse_arguments+0xa>
    return NULL;
 8001f5e:	2000      	movs	r0, #0
 8001f60:	bd70      	pop	{r4, r5, r6, pc}
  p += strspn(p, " \t");

  if (*p == '"') {
    /* If an argument starts with a double quote then its delimiter is another
       quote.*/
    p++;
 8001f62:	3501      	adds	r5, #1
    *saveptr = strpbrk(p, "\"");
 8001f64:	4628      	mov	r0, r5
 8001f66:	f005 fc3b 	bl	80077e0 <strchr>
 8001f6a:	6030      	str	r0, [r6, #0]
 8001f6c:	e7eb      	b.n	8001f46 <parse_arguments+0x26>
 8001f6e:	bf00      	nop
 8001f70:	08007d78 	.word	0x08007d78
 8001f74:	f3af 8000 	nop.w
 8001f78:	f3af 8000 	nop.w
 8001f7c:	f3af 8000 	nop.w

08001f80 <shellThread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8001f80:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  int n;
  ShellConfig *scfg = p;
  BaseSequentialStream *chp = scfg->sc_channel;
  const ShellCommand *scp = scfg->sc_commands;
 8001f84:	e890 0280 	ldmia.w	r0, {r7, r9}
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8001f88:	b098      	sub	sp, #96	; 0x60
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 8001f8a:	4971      	ldr	r1, [pc, #452]	; (8002150 <shellThread+0x1d0>)
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
THD_FUNCTION(shellThread, p) {
 8001f8c:	4680      	mov	r8, r0
  ShellHistory *shp = &hist;
#else
  ShellHistory *shp = NULL;
#endif

  chprintf(chp, SHELL_NEWLINE_STR);
 8001f8e:	4638      	mov	r0, r7
 8001f90:	f004 fc56 	bl	8006840 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
 8001f94:	4638      	mov	r0, r7
 8001f96:	496f      	ldr	r1, [pc, #444]	; (8002154 <shellThread+0x1d4>)
 8001f98:	f004 fc52 	bl	8006840 <chprintf>
 8001f9c:	ae08      	add	r6, sp, #32
  while (true) {
    chprintf(chp, SHELL_PROMPT_STR);
 8001f9e:	4638      	mov	r0, r7
 8001fa0:	496d      	ldr	r1, [pc, #436]	; (8002158 <shellThread+0x1d8>)
 8001fa2:	f004 fc4d 	bl	8006840 <chprintf>
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
  BaseSequentialStream *chp = scfg->sc_channel;
 8001fa6:	f8d8 4000 	ldr.w	r4, [r8]
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(ShellConfig *scfg, char *line, unsigned size, ShellHistory *shp) {
  char *p = line;
 8001faa:	4635      	mov	r5, r6
#endif

  while (true) {
    char c;

    if (streamRead(chp, (uint8_t *)&c, 1) == 0)
 8001fac:	6823      	ldr	r3, [r4, #0]
 8001fae:	4620      	mov	r0, r4
 8001fb0:	685b      	ldr	r3, [r3, #4]
 8001fb2:	f10d 0107 	add.w	r1, sp, #7
 8001fb6:	2201      	movs	r2, #1
 8001fb8:	4798      	blx	r3
 8001fba:	b380      	cbz	r0, 800201e <shellThread+0x9e>
      }
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
 8001fbc:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8001fc0:	2904      	cmp	r1, #4
 8001fc2:	d028      	beq.n	8002016 <shellThread+0x96>
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
 8001fc4:	2908      	cmp	r1, #8
 8001fc6:	d012      	beq.n	8001fee <shellThread+0x6e>
 8001fc8:	297f      	cmp	r1, #127	; 0x7f
 8001fca:	d010      	beq.n	8001fee <shellThread+0x6e>
        streamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8001fcc:	290d      	cmp	r1, #13
      continue;
    }
#endif
    if (c < 0x20)
      continue;
    if (p < line + size - 1) {
 8001fce:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
        streamPut(chp, 0x08);
        p--;
      }
      continue;
    }
    if (c == '\r') {
 8001fd2:	d039      	beq.n	8002048 <shellThread+0xc8>
        p = line + len;
      }
      continue;
    }
#endif
    if (c < 0x20)
 8001fd4:	291f      	cmp	r1, #31
 8001fd6:	d9e9      	bls.n	8001fac <shellThread+0x2c>
      continue;
    if (p < line + size - 1) {
 8001fd8:	429d      	cmp	r5, r3
 8001fda:	d2e7      	bcs.n	8001fac <shellThread+0x2c>
      streamPut(chp, c);
 8001fdc:	6823      	ldr	r3, [r4, #0]
 8001fde:	4620      	mov	r0, r4
 8001fe0:	689b      	ldr	r3, [r3, #8]
 8001fe2:	4798      	blx	r3
      *p++ = (char)c;
 8001fe4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8001fe8:	702b      	strb	r3, [r5, #0]
 8001fea:	3501      	adds	r5, #1
 8001fec:	e7de      	b.n	8001fac <shellThread+0x2c>
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8001fee:	42b5      	cmp	r5, r6
        streamPut(chp, 0x08);
 8001ff0:	f04f 0108 	mov.w	r1, #8
 8001ff4:	4620      	mov	r0, r4
      chprintf(chp, "^D");
      return true;
    }
#endif
    if ((c == 8) || (c == 127)) {
      if (p != line) {
 8001ff6:	d0d9      	beq.n	8001fac <shellThread+0x2c>
        streamPut(chp, 0x08);
 8001ff8:	6823      	ldr	r3, [r4, #0]
 8001ffa:	689b      	ldr	r3, [r3, #8]
 8001ffc:	4798      	blx	r3
        streamPut(chp, 0x20);
 8001ffe:	6823      	ldr	r3, [r4, #0]
 8002000:	4620      	mov	r0, r4
 8002002:	689b      	ldr	r3, [r3, #8]
 8002004:	2120      	movs	r1, #32
 8002006:	4798      	blx	r3
        streamPut(chp, 0x08);
 8002008:	6823      	ldr	r3, [r4, #0]
 800200a:	4620      	mov	r0, r4
 800200c:	689b      	ldr	r3, [r3, #8]
 800200e:	2108      	movs	r1, #8
        p--;
 8002010:	3d01      	subs	r5, #1
#endif
    if ((c == 8) || (c == 127)) {
      if (p != line) {
        streamPut(chp, 0x08);
        streamPut(chp, 0x20);
        streamPut(chp, 0x08);
 8002012:	4798      	blx	r3
 8002014:	e7ca      	b.n	8001fac <shellThread+0x2c>
      continue;
    }
#endif
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
    if (c == 4) {
      chprintf(chp, "^D");
 8002016:	4620      	mov	r0, r4
 8002018:	4950      	ldr	r1, [pc, #320]	; (800215c <shellThread+0x1dc>)
 800201a:	f004 fc11 	bl	8006840 <chprintf>
  chprintf(chp, "ChibiOS/RT Shell"SHELL_NEWLINE_STR);
  while (true) {
    chprintf(chp, SHELL_PROMPT_STR);
    if (shellGetLine(scfg, line, sizeof(line), shp)) {
#if (SHELL_CMD_EXIT_ENABLED == TRUE) && !defined(_CHIBIOS_NIL_)
      chprintf(chp, SHELL_NEWLINE_STR);
 800201e:	4638      	mov	r0, r7
 8002020:	494b      	ldr	r1, [pc, #300]	; (8002150 <shellThread+0x1d0>)
 8002022:	f004 fc0d 	bl	8006840 <chprintf>
      chprintf(chp, "logout");
 8002026:	4638      	mov	r0, r7
 8002028:	494d      	ldr	r1, [pc, #308]	; (8002160 <shellThread+0x1e0>)
 800202a:	f004 fc09 	bl	8006840 <chprintf>
 800202e:	2320      	movs	r3, #32
 8002030:	f383 8811 	msr	BASEPRI, r3
 8002034:	2100      	movs	r1, #0
 8002036:	484b      	ldr	r0, [pc, #300]	; (8002164 <shellThread+0x1e4>)
 8002038:	f003 feba 	bl	8005db0 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 800203c:	2000      	movs	r0, #0
 800203e:	f004 fa07 	bl	8006450 <chThdExitS>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
      }
    }
  }
  shellExit(MSG_OK);
}
 8002042:	b018      	add	sp, #96	; 0x60
 8002044:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
 8002048:	4620      	mov	r0, r4
 800204a:	4941      	ldr	r1, [pc, #260]	; (8002150 <shellThread+0x1d0>)
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
 800204c:	2400      	movs	r4, #0
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
 800204e:	f004 fbf7 	bl	8006840 <chprintf>
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
 8002052:	a902      	add	r1, sp, #8
    if (c == '\r') {
      chprintf(chp, SHELL_NEWLINE_STR);
#if SHELL_USE_HISTORY == TRUE
      save_history(shp, line, p - line);
#endif
      *p = 0;
 8002054:	702c      	strb	r4, [r5, #0]
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
 8002056:	4630      	mov	r0, r6
 8002058:	f7ff ff62 	bl	8001f20 <parse_arguments>
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 800205c:	a902      	add	r1, sp, #8
      /* Putting a delay in order to avoid an endless loop trying to read
         an unavailable stream.*/
      osalThreadSleepMilliseconds(100);
#endif
    }
    lp = parse_arguments(line, &tokp);
 800205e:	4682      	mov	sl, r0
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8002060:	2000      	movs	r0, #0
 8002062:	ad03      	add	r5, sp, #12
 8002064:	f7ff ff5c 	bl	8001f20 <parse_arguments>
 8002068:	b150      	cbz	r0, 8002080 <shellThread+0x100>
      if (n >= SHELL_MAX_ARGUMENTS) {
 800206a:	2c04      	cmp	r4, #4
 800206c:	d01c      	beq.n	80020a8 <shellThread+0x128>
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 800206e:	f845 0b04 	str.w	r0, [r5], #4
#endif
    }
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8002072:	a902      	add	r1, sp, #8
 8002074:	2000      	movs	r0, #0
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8002076:	3401      	adds	r4, #1
#endif
    }
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
 8002078:	f7ff ff52 	bl	8001f20 <parse_arguments>
 800207c:	2800      	cmp	r0, #0
 800207e:	d1f4      	bne.n	800206a <shellThread+0xea>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8002080:	ab18      	add	r3, sp, #96	; 0x60
 8002082:	eb03 0384 	add.w	r3, r3, r4, lsl #2
 8002086:	f843 0c54 	str.w	r0, [r3, #-84]
    if (cmd != NULL) {
 800208a:	f1ba 0f00 	cmp.w	sl, #0
 800208e:	d086      	beq.n	8001f9e <shellThread+0x1e>
      if (strcmp(cmd, "help") == 0) {
 8002090:	4650      	mov	r0, sl
 8002092:	4935      	ldr	r1, [pc, #212]	; (8002168 <shellThread+0x1e8>)
 8002094:	f7fe fe18 	bl	8000cc8 <strcmp>
 8002098:	b968      	cbnz	r0, 80020b6 <shellThread+0x136>
        if (n > 0) {
          shellUsage(chp, "help");
 800209a:	4638      	mov	r0, r7
      args[n++] = lp;
    }
    args[n] = NULL;
    if (cmd != NULL) {
      if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
 800209c:	b1e4      	cbz	r4, 80020d8 <shellThread+0x158>
          shellUsage(chp, "help");
 800209e:	4933      	ldr	r1, [pc, #204]	; (800216c <shellThread+0x1ec>)
 80020a0:	4a31      	ldr	r2, [pc, #196]	; (8002168 <shellThread+0x1e8>)
 80020a2:	f004 fbcd 	bl	8006840 <chprintf>
 80020a6:	e77a      	b.n	8001f9e <shellThread+0x1e>
    lp = parse_arguments(line, &tokp);
    cmd = lp;
    n = 0;
    while ((lp = parse_arguments(NULL, &tokp)) != NULL) {
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments"SHELL_NEWLINE_STR);
 80020a8:	4638      	mov	r0, r7
 80020aa:	4931      	ldr	r1, [pc, #196]	; (8002170 <shellThread+0x1f0>)
 80020ac:	f004 fbc8 	bl	8006840 <chprintf>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 80020b0:	2300      	movs	r3, #0
 80020b2:	9307      	str	r3, [sp, #28]
 80020b4:	e773      	b.n	8001f9e <shellThread+0x1e>
 80020b6:	4d2f      	ldr	r5, [pc, #188]	; (8002174 <shellThread+0x1f4>)
    if (cmd != NULL) {
      if (strcmp(cmd, "help") == 0) {
 80020b8:	482f      	ldr	r0, [pc, #188]	; (8002178 <shellThread+0x1f8>)
 80020ba:	e002      	b.n	80020c2 <shellThread+0x142>
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 80020bc:	f855 0f08 	ldr.w	r0, [r5, #8]!
 80020c0:	b358      	cbz	r0, 800211a <shellThread+0x19a>
    if (strcmp(scp->sc_name, name) == 0) {
 80020c2:	4651      	mov	r1, sl
 80020c4:	f7fe fe00 	bl	8000cc8 <strcmp>
 80020c8:	2800      	cmp	r0, #0
 80020ca:	d1f7      	bne.n	80020bc <shellThread+0x13c>
      scp->sc_function(chp, argc, argv);
 80020cc:	686b      	ldr	r3, [r5, #4]
 80020ce:	4621      	mov	r1, r4
 80020d0:	aa03      	add	r2, sp, #12
 80020d2:	4638      	mov	r0, r7
 80020d4:	4798      	blx	r3
 80020d6:	e762      	b.n	8001f9e <shellThread+0x1e>
      if (strcmp(cmd, "help") == 0) {
        if (n > 0) {
          shellUsage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help ");
 80020d8:	4928      	ldr	r1, [pc, #160]	; (800217c <shellThread+0x1fc>)
 80020da:	4c26      	ldr	r4, [pc, #152]	; (8002174 <shellThread+0x1f4>)
 80020dc:	f004 fbb0 	bl	8006840 <chprintf>
 80020e0:	4a25      	ldr	r2, [pc, #148]	; (8002178 <shellThread+0x1f8>)
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
    chprintf(chp, "%s ", scp->sc_name);
 80020e2:	4927      	ldr	r1, [pc, #156]	; (8002180 <shellThread+0x200>)
 80020e4:	4638      	mov	r0, r7
 80020e6:	f004 fbab 	bl	8006840 <chprintf>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80020ea:	f854 2f08 	ldr.w	r2, [r4, #8]!
 80020ee:	2a00      	cmp	r2, #0
 80020f0:	d1f7      	bne.n	80020e2 <shellThread+0x162>
          shellUsage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help ");
        list_commands(chp, shell_local_commands);
        if (scp != NULL)
 80020f2:	f1b9 0f00 	cmp.w	r9, #0
 80020f6:	d00b      	beq.n	8002110 <shellThread+0x190>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80020f8:	f8d9 2000 	ldr.w	r2, [r9]
 80020fc:	b142      	cbz	r2, 8002110 <shellThread+0x190>
 80020fe:	464c      	mov	r4, r9
    chprintf(chp, "%s ", scp->sc_name);
 8002100:	4638      	mov	r0, r7
 8002102:	491f      	ldr	r1, [pc, #124]	; (8002180 <shellThread+0x200>)
 8002104:	f004 fb9c 	bl	8006840 <chprintf>
  return *p != '\0' ? p : NULL;
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002108:	f854 2f08 	ldr.w	r2, [r4, #8]!
 800210c:	2a00      	cmp	r2, #0
 800210e:	d1f7      	bne.n	8002100 <shellThread+0x180>
        }
        chprintf(chp, "Commands: help ");
        list_commands(chp, shell_local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, SHELL_NEWLINE_STR);
 8002110:	4638      	mov	r0, r7
 8002112:	490f      	ldr	r1, [pc, #60]	; (8002150 <shellThread+0x1d0>)
 8002114:	f004 fb94 	bl	8006840 <chprintf>
 8002118:	e741      	b.n	8001f9e <shellThread+0x1e>
      }
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
 800211a:	f1b9 0f00 	cmp.w	r9, #0
 800211e:	d00d      	beq.n	800213c <shellThread+0x1bc>
}

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8002120:	f8d9 0000 	ldr.w	r0, [r9]
 8002124:	b150      	cbz	r0, 800213c <shellThread+0x1bc>
 8002126:	464d      	mov	r5, r9
 8002128:	e002      	b.n	8002130 <shellThread+0x1b0>
 800212a:	f855 0f08 	ldr.w	r0, [r5, #8]!
 800212e:	b128      	cbz	r0, 800213c <shellThread+0x1bc>
    if (strcmp(scp->sc_name, name) == 0) {
 8002130:	4651      	mov	r1, sl
 8002132:	f7fe fdc9 	bl	8000cc8 <strcmp>
 8002136:	2800      	cmp	r0, #0
 8002138:	d1f7      	bne.n	800212a <shellThread+0x1aa>
 800213a:	e7c7      	b.n	80020cc <shellThread+0x14c>
          list_commands(chp, scp);
        chprintf(chp, SHELL_NEWLINE_STR);
      }
      else if (cmdexec(shell_local_commands, chp, cmd, n, args) &&
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 800213c:	4652      	mov	r2, sl
 800213e:	4638      	mov	r0, r7
 8002140:	4910      	ldr	r1, [pc, #64]	; (8002184 <shellThread+0x204>)
 8002142:	f004 fb7d 	bl	8006840 <chprintf>
        chprintf(chp, " ?"SHELL_NEWLINE_STR);
 8002146:	4638      	mov	r0, r7
 8002148:	490f      	ldr	r1, [pc, #60]	; (8002188 <shellThread+0x208>)
 800214a:	f004 fb79 	bl	8006840 <chprintf>
 800214e:	e726      	b.n	8001f9e <shellThread+0x1e>
 8002150:	08007d8c 	.word	0x08007d8c
 8002154:	08007d7c 	.word	0x08007d7c
 8002158:	08007d90 	.word	0x08007d90
 800215c:	08007d98 	.word	0x08007d98
 8002160:	08007ddc 	.word	0x08007ddc
 8002164:	20001190 	.word	0x20001190
 8002168:	08007db4 	.word	0x08007db4
 800216c:	08007ab4 	.word	0x08007ab4
 8002170:	08007d9c 	.word	0x08007d9c
 8002174:	08007fc4 	.word	0x08007fc4
 8002178:	08007d70 	.word	0x08007d70
 800217c:	08007dbc 	.word	0x08007dbc
 8002180:	08007dcc 	.word	0x08007dcc
 8002184:	08007dd0 	.word	0x08007dd0
 8002188:	08007dd4 	.word	0x08007dd4
 800218c:	f3af 8000 	nop.w

08002190 <test_012_012_execute.lto_priv.202>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void test_012_012_execute(void) {
 8002190:	b570      	push	{r4, r5, r6, lr}

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8002192:	4d33      	ldr	r5, [pc, #204]	; (8002260 <test_012_012_execute.lto_priv.202+0xd0>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 8002194:	4c33      	ldr	r4, [pc, #204]	; (8002264 <test_012_012_execute.lto_priv.202+0xd4>)
static void test_012_012_execute(void) {

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
  {
    test_print("--- System: ");
 8002196:	4834      	ldr	r0, [pc, #208]	; (8002268 <test_012_012_execute.lto_priv.202+0xd8>)
 */

static void test_012_012_execute(void) {

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8002198:	2301      	movs	r3, #1
 800219a:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 800219c:	f001 fe10 	bl	8003dc0 <test_print>
    test_printn(sizeof(ch_system_t));
 80021a0:	2078      	movs	r0, #120	; 0x78
 80021a2:	f001 fe1d 	bl	8003de0 <test_printn>
    test_println(" bytes");
 80021a6:	4620      	mov	r0, r4
 80021a8:	f001 fdea 	bl	8003d80 <test_println>
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80021ac:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 80021ae:	482f      	ldr	r0, [pc, #188]	; (800226c <test_012_012_execute.lto_priv.202+0xdc>)
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 80021b0:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 80021b2:	f001 fe05 	bl	8003dc0 <test_print>
    test_printn(sizeof(thread_t));
 80021b6:	2044      	movs	r0, #68	; 0x44
 80021b8:	f001 fe12 	bl	8003de0 <test_printn>
    test_println(" bytes");
 80021bc:	4620      	mov	r0, r4
 80021be:	f001 fddf 	bl	8003d80 <test_println>
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 80021c2:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 80021c4:	482a      	ldr	r0, [pc, #168]	; (8002270 <test_012_012_execute.lto_priv.202+0xe0>)
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 80021c6:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 80021c8:	f001 fdfa 	bl	8003dc0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 80021cc:	2014      	movs	r0, #20
 80021ce:	f001 fe07 	bl	8003de0 <test_printn>
    test_println(" bytes");
 80021d2:	4620      	mov	r0, r4
 80021d4:	f001 fdd4 	bl	8003d80 <test_println>
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 80021d8:	2604      	movs	r6, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 80021da:	4826      	ldr	r0, [pc, #152]	; (8002274 <test_012_012_execute.lto_priv.202+0xe4>)
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 80021dc:	602e      	str	r6, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 80021de:	f001 fdef 	bl	8003dc0 <test_print>
    test_printn(sizeof(semaphore_t));
 80021e2:	200c      	movs	r0, #12
 80021e4:	f001 fdfc 	bl	8003de0 <test_printn>
    test_println(" bytes");
 80021e8:	4620      	mov	r0, r4
 80021ea:	f001 fdc9 	bl	8003d80 <test_println>
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 80021ee:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 80021f0:	4821      	ldr	r0, [pc, #132]	; (8002278 <test_012_012_execute.lto_priv.202+0xe8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 80021f2:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 80021f4:	f001 fde4 	bl	8003dc0 <test_print>
    test_printn(sizeof(mutex_t));
 80021f8:	2010      	movs	r0, #16
 80021fa:	f001 fdf1 	bl	8003de0 <test_printn>
    test_println(" bytes");
 80021fe:	4620      	mov	r0, r4
 8002200:	f001 fdbe 	bl	8003d80 <test_println>
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8002204:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8002206:	481d      	ldr	r0, [pc, #116]	; (800227c <test_012_012_execute.lto_priv.202+0xec>)
    test_println(" bytes");
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8002208:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 800220a:	f001 fdd9 	bl	8003dc0 <test_print>
    test_printn(sizeof(condition_variable_t));
 800220e:	2008      	movs	r0, #8
 8002210:	f001 fde6 	bl	8003de0 <test_printn>
    test_println(" bytes");
 8002214:	4620      	mov	r0, r4
 8002216:	f001 fdb3 	bl	8003d80 <test_println>
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800221a:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 800221c:	4818      	ldr	r0, [pc, #96]	; (8002280 <test_012_012_execute.lto_priv.202+0xf0>)
    test_println(" bytes");
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800221e:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8002220:	f001 fdce 	bl	8003dc0 <test_print>
    test_printn(sizeof(event_source_t));
 8002224:	4630      	mov	r0, r6
 8002226:	f001 fddb 	bl	8003de0 <test_printn>
    test_println(" bytes");
 800222a:	4620      	mov	r0, r4
 800222c:	f001 fda8 	bl	8003d80 <test_println>
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8002230:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8002232:	4814      	ldr	r0, [pc, #80]	; (8002284 <test_012_012_execute.lto_priv.202+0xf4>)
    test_println(" bytes");
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 8002234:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 8002236:	f001 fdc3 	bl	8003dc0 <test_print>
    test_printn(sizeof(event_listener_t));
 800223a:	2014      	movs	r0, #20
 800223c:	f001 fdd0 	bl	8003de0 <test_printn>
    test_println(" bytes");
 8002240:	4620      	mov	r0, r4
 8002242:	f001 fd9d 	bl	8003d80 <test_println>
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 8002246:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 8002248:	480f      	ldr	r0, [pc, #60]	; (8002288 <test_012_012_execute.lto_priv.202+0xf8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 800224a:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 800224c:	f001 fdb8 	bl	8003dc0 <test_print>
    test_printn(sizeof(mailbox_t));
 8002250:	2028      	movs	r0, #40	; 0x28
 8002252:	f001 fdc5 	bl	8003de0 <test_printn>
    test_println(" bytes");
 8002256:	4620      	mov	r0, r4
#endif
  }
}
 8002258:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_set_step(9);
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
 800225c:	f001 bd90 	b.w	8003d80 <test_println>
 8002260:	20000f5c 	.word	0x20000f5c
 8002264:	08007df4 	.word	0x08007df4
 8002268:	08007de4 	.word	0x08007de4
 800226c:	08007dfc 	.word	0x08007dfc
 8002270:	08007e0c 	.word	0x08007e0c
 8002274:	08007e1c 	.word	0x08007e1c
 8002278:	08007e2c 	.word	0x08007e2c
 800227c:	08007e3c 	.word	0x08007e3c
 8002280:	08007e4c 	.word	0x08007e4c
 8002284:	08007e5c 	.word	0x08007e5c
 8002288:	08007e6c 	.word	0x08007e6c
 800228c:	f3af 8000 	nop.w

08002290 <test_012_011_execute.lto_priv.201>:

static void test_012_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void test_012_011_execute(void) {
 8002290:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;

  /* [12.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002294:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8002314 <test_012_011_execute.lto_priv.201+0x84>
 8002298:	2301      	movs	r3, #1
 800229a:	f8c8 3000 	str.w	r3, [r8]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800229e:	f000 ff3f 	bl	8003120 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 80022a2:	2400      	movs	r4, #0
    start = test_wait_tick();
 80022a4:	4607      	mov	r7, r0
 80022a6:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
      chMtxUnlock(&mtx1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80022aa:	f242 750f 	movw	r5, #9999	; 0x270f

    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chMtxLock(&mtx1);
 80022ae:	4816      	ldr	r0, [pc, #88]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022b0:	f004 f886 	bl	80063c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 80022b4:	4814      	ldr	r0, [pc, #80]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022b6:	f003 ffe3 	bl	8006280 <chMtxUnlock>
      chMtxLock(&mtx1);
 80022ba:	4813      	ldr	r0, [pc, #76]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022bc:	f004 f880 	bl	80063c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 80022c0:	4811      	ldr	r0, [pc, #68]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022c2:	f003 ffdd 	bl	8006280 <chMtxUnlock>
      chMtxLock(&mtx1);
 80022c6:	4810      	ldr	r0, [pc, #64]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022c8:	f004 f87a 	bl	80063c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 80022cc:	480e      	ldr	r0, [pc, #56]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022ce:	f003 ffd7 	bl	8006280 <chMtxUnlock>
      chMtxLock(&mtx1);
 80022d2:	480d      	ldr	r0, [pc, #52]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022d4:	f004 f874 	bl	80063c0 <chMtxLock>
      chMtxUnlock(&mtx1);
 80022d8:	480b      	ldr	r0, [pc, #44]	; (8002308 <test_012_011_execute.lto_priv.201+0x78>)
 80022da:	f003 ffd1 	bl	8006280 <chMtxUnlock>
 80022de:	6a73      	ldr	r3, [r6, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 80022e0:	1bdb      	subs	r3, r3, r7
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80022e2:	42ab      	cmp	r3, r5
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      n++;
 80022e4:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80022e8:	d9e1      	bls.n	80022ae <test_012_011_execute.lto_priv.201+0x1e>
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 80022ea:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80022ec:	4807      	ldr	r0, [pc, #28]	; (800230c <test_012_011_execute.lto_priv.201+0x7c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 80022ee:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 80022f2:	f001 fd65 	bl	8003dc0 <test_print>
    test_printn(n * 4);
 80022f6:	00a0      	lsls	r0, r4, #2
 80022f8:	f001 fd72 	bl	8003de0 <test_printn>
    test_println(" lock+unlock/S");
 80022fc:	4804      	ldr	r0, [pc, #16]	; (8002310 <test_012_011_execute.lto_priv.201+0x80>)
  }
}
 80022fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [12.11.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" lock+unlock/S");
 8002302:	f001 bd3d 	b.w	8003d80 <test_println>
 8002306:	bf00      	nop
 8002308:	20000f2c 	.word	0x20000f2c
 800230c:	08007e7c 	.word	0x08007e7c
 8002310:	08007e8c 	.word	0x08007e8c
 8002314:	20000f5c 	.word	0x20000f5c
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <test_012_010_execute.lto_priv.199>:

static void test_012_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_012_010_execute(void) {
 8002320:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;

  /* [12.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8002324:	f8df 807c 	ldr.w	r8, [pc, #124]	; 80023a4 <test_012_010_execute.lto_priv.199+0x84>
 8002328:	2301      	movs	r3, #1
 800232a:	f8c8 3000 	str.w	r3, [r8]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800232e:	f000 fef7 	bl	8003120 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8002332:	2400      	movs	r4, #0
    start = test_wait_tick();
 8002334:	4607      	mov	r7, r0
 8002336:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
      chSemSignal(&sem1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800233a:	f242 750f 	movw	r5, #9999	; 0x270f

    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemWait(&sem1);
 800233e:	4816      	ldr	r0, [pc, #88]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 8002340:	f003 ff16 	bl	8006170 <chSemWait>
      chSemSignal(&sem1);
 8002344:	4814      	ldr	r0, [pc, #80]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 8002346:	f003 fedb 	bl	8006100 <chSemSignal>
      chSemWait(&sem1);
 800234a:	4813      	ldr	r0, [pc, #76]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 800234c:	f003 ff10 	bl	8006170 <chSemWait>
      chSemSignal(&sem1);
 8002350:	4811      	ldr	r0, [pc, #68]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 8002352:	f003 fed5 	bl	8006100 <chSemSignal>
      chSemWait(&sem1);
 8002356:	4810      	ldr	r0, [pc, #64]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 8002358:	f003 ff0a 	bl	8006170 <chSemWait>
      chSemSignal(&sem1);
 800235c:	480e      	ldr	r0, [pc, #56]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 800235e:	f003 fecf 	bl	8006100 <chSemSignal>
      chSemWait(&sem1);
 8002362:	480d      	ldr	r0, [pc, #52]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 8002364:	f003 ff04 	bl	8006170 <chSemWait>
      chSemSignal(&sem1);
 8002368:	480b      	ldr	r0, [pc, #44]	; (8002398 <test_012_010_execute.lto_priv.199+0x78>)
 800236a:	f003 fec9 	bl	8006100 <chSemSignal>
 800236e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 8002370:	1bdb      	subs	r3, r3, r7
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002372:	42ab      	cmp	r3, r5
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      n++;
 8002374:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002378:	d9e1      	bls.n	800233e <test_012_010_execute.lto_priv.199+0x1e>
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 800237a:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800237c:	4807      	ldr	r0, [pc, #28]	; (800239c <test_012_010_execute.lto_priv.199+0x7c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 800237e:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 8002382:	f001 fd1d 	bl	8003dc0 <test_print>
    test_printn(n * 4);
 8002386:	00a0      	lsls	r0, r4, #2
 8002388:	f001 fd2a 	bl	8003de0 <test_printn>
    test_println(" wait+signal/S");
 800238c:	4804      	ldr	r0, [pc, #16]	; (80023a0 <test_012_010_execute.lto_priv.199+0x80>)
  }
}
 800238e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [12.10.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" wait+signal/S");
 8002392:	f001 bcf5 	b.w	8003d80 <test_println>
 8002396:	bf00      	nop
 8002398:	20000f3c 	.word	0x20000f3c
 800239c:	08007e7c 	.word	0x08007e7c
 80023a0:	08007e9c 	.word	0x08007e9c
 80023a4:	20000f5c 	.word	0x20000f5c
 80023a8:	f3af 8000 	nop.w
 80023ac:	f3af 8000 	nop.w

080023b0 <bmk_thread7>:
  } while (msg == MSG_OK);
  chSysUnlock();
}

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 80023b0:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80023b2:	4c07      	ldr	r4, [pc, #28]	; (80023d0 <bmk_thread7+0x20>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 80023b4:	69a3      	ldr	r3, [r4, #24]
 80023b6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

  (void)p;
  while (!chThdShouldTerminateX())
 80023ba:	075a      	lsls	r2, r3, #29
 80023bc:	d407      	bmi.n	80023ce <bmk_thread7+0x1e>
    chSemWait(&sem1);
 80023be:	4805      	ldr	r0, [pc, #20]	; (80023d4 <bmk_thread7+0x24>)
 80023c0:	f003 fed6 	bl	8006170 <chSemWait>
 80023c4:	69a3      	ldr	r3, [r4, #24]
 80023c6:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 80023ca:	075b      	lsls	r3, r3, #29
 80023cc:	d5f7      	bpl.n	80023be <bmk_thread7+0xe>
 80023ce:	bd10      	pop	{r4, pc}
 80023d0:	200012a0 	.word	0x200012a0
 80023d4:	20000f3c 	.word	0x20000f3c
 80023d8:	f3af 8000 	nop.w
 80023dc:	f3af 8000 	nop.w

080023e0 <test_012_009_execute.lto_priv.197>:
 *   one-second time window.
 * - [12.9.2] The score is printed.
 * .
 */

static void test_012_009_execute(void) {
 80023e0:	b570      	push	{r4, r5, r6, lr}
  uint32_t n;

  /* [12.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 80023e2:	4e1b      	ldr	r6, [pc, #108]	; (8002450 <test_012_009_execute.lto_priv.197+0x70>)
 80023e4:	2301      	movs	r3, #1
 80023e6:	6033      	str	r3, [r6, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80023e8:	f000 fe9a 	bl	8003120 <test_wait_tick>
     one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 80023ec:	2400      	movs	r4, #0
    start = test_wait_tick();
 80023ee:	4605      	mov	r5, r0
 80023f0:	2320      	movs	r3, #32
 80023f2:	f383 8811 	msr	BASEPRI, r3
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 80023f6:	4817      	ldr	r0, [pc, #92]	; (8002454 <test_012_009_execute.lto_priv.197+0x74>)
 80023f8:	4a17      	ldr	r2, [pc, #92]	; (8002458 <test_012_009_execute.lto_priv.197+0x78>)
 80023fa:	2101      	movs	r1, #1
 80023fc:	2300      	movs	r3, #0
 80023fe:	f004 f88f 	bl	8006520 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8002402:	4a15      	ldr	r2, [pc, #84]	; (8002458 <test_012_009_execute.lto_priv.197+0x78>)
 8002404:	4815      	ldr	r0, [pc, #84]	; (800245c <test_012_009_execute.lto_priv.197+0x7c>)
 8002406:	f242 7110 	movw	r1, #10000	; 0x2710
 800240a:	2300      	movs	r3, #0
 800240c:	f004 f888 	bl	8006520 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8002410:	4810      	ldr	r0, [pc, #64]	; (8002454 <test_012_009_execute.lto_priv.197+0x74>)
 8002412:	f004 f84d 	bl	80064b0 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8002416:	4811      	ldr	r0, [pc, #68]	; (800245c <test_012_009_execute.lto_priv.197+0x7c>)
 8002418:	f004 f84a 	bl	80064b0 <chVTDoResetI>
 800241c:	2300      	movs	r3, #0
 800241e:	f383 8811 	msr	BASEPRI, r3
 8002422:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002426:	f242 720f 	movw	r2, #9999	; 0x270f
 800242a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800242c:	1b5b      	subs	r3, r3, r5
 800242e:	4293      	cmp	r3, r2
      chVTDoSetI(&vt1, 1, tmo, NULL);
      chVTDoSetI(&vt2, 10000, tmo, NULL);
      chVTDoResetI(&vt1);
      chVTDoResetI(&vt2);
      chSysUnlock();
      n++;
 8002430:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8002434:	d9dc      	bls.n	80023f0 <test_012_009_execute.lto_priv.197+0x10>
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 8002436:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8002438:	4809      	ldr	r0, [pc, #36]	; (8002460 <test_012_009_execute.lto_priv.197+0x80>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 800243a:	6033      	str	r3, [r6, #0]
  {
    test_print("--- Score : ");
 800243c:	f001 fcc0 	bl	8003dc0 <test_print>
    test_printn(n * 2);
 8002440:	0060      	lsls	r0, r4, #1
 8002442:	f001 fccd 	bl	8003de0 <test_printn>
    test_println(" timers/S");
 8002446:	4807      	ldr	r0, [pc, #28]	; (8002464 <test_012_009_execute.lto_priv.197+0x84>)
  }
}
 8002448:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* [12.9.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" timers/S");
 800244c:	f001 bc98 	b.w	8003d80 <test_println>
 8002450:	20000f5c 	.word	0x20000f5c
 8002454:	20000f48 	.word	0x20000f48
 8002458:	08005151 	.word	0x08005151
 800245c:	20000f18 	.word	0x20000f18
 8002460:	08007e7c 	.word	0x08007e7c
 8002464:	08007eac 	.word	0x08007eac
 8002468:	f3af 8000 	nop.w
 800246c:	f3af 8000 	nop.w

08002470 <test_012_008_execute.lto_priv.196>:
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void test_012_008_execute(void) {
 8002470:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8002474:	b083      	sub	sp, #12
  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
 8002476:	ac02      	add	r4, sp, #8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002478:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800254c <test_012_008_execute.lto_priv.196+0xdc>
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 800247c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8002550 <test_012_008_execute.lto_priv.196+0xe0>
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002480:	4f2d      	ldr	r7, [pc, #180]	; (8002538 <test_012_008_execute.lto_priv.196+0xc8>)
 8002482:	4e2e      	ldr	r6, [pc, #184]	; (800253c <test_012_008_execute.lto_priv.196+0xcc>)
 8002484:	4d2e      	ldr	r5, [pc, #184]	; (8002540 <test_012_008_execute.lto_priv.196+0xd0>)
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 8002486:	2201      	movs	r2, #1
  {
    n = 0;
 8002488:	2300      	movs	r3, #0
 800248a:	f844 3d04 	str.w	r3, [r4, #-4]!
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 800248e:	f8c9 2000 	str.w	r2, [r9]
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002492:	f000 fe45 	bl	8003120 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002496:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800249a:	6899      	ldr	r1, [r3, #8]
 800249c:	4632      	mov	r2, r6
 800249e:	4623      	mov	r3, r4
 80024a0:	3901      	subs	r1, #1
 80024a2:	4638      	mov	r0, r7
 80024a4:	f004 fe64 	bl	8007170 <chThdCreateStatic.constprop.69>
 80024a8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80024ac:	6028      	str	r0, [r5, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80024ae:	6899      	ldr	r1, [r3, #8]
 80024b0:	4632      	mov	r2, r6
 80024b2:	4623      	mov	r3, r4
 80024b4:	3901      	subs	r1, #1
 80024b6:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 80024ba:	f004 fe59 	bl	8007170 <chThdCreateStatic.constprop.69>
 80024be:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80024c2:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80024c4:	6899      	ldr	r1, [r3, #8]
 80024c6:	4632      	mov	r2, r6
 80024c8:	4623      	mov	r3, r4
 80024ca:	3901      	subs	r1, #1
 80024cc:	f507 7024 	add.w	r0, r7, #656	; 0x290
 80024d0:	f004 fe4e 	bl	8007170 <chThdCreateStatic.constprop.69>
 80024d4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80024d8:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80024da:	6899      	ldr	r1, [r3, #8]
 80024dc:	4632      	mov	r2, r6
 80024de:	4623      	mov	r3, r4
 80024e0:	3901      	subs	r1, #1
 80024e2:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 80024e6:	f004 fe43 	bl	8007170 <chThdCreateStatic.constprop.69>
 80024ea:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80024ee:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80024f0:	6899      	ldr	r1, [r3, #8]
 80024f2:	4632      	mov	r2, r6
 80024f4:	3901      	subs	r1, #1
 80024f6:	4623      	mov	r3, r4
 80024f8:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 80024fc:	f004 fe38 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8002500:	2302      	movs	r3, #2
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8002502:	6128      	str	r0, [r5, #16]
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  {
    chThdSleepSeconds(1);
 8002504:	f242 7010 	movw	r0, #10000	; 0x2710
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8002508:	f8c9 3000 	str.w	r3, [r9]
  {
    chThdSleepSeconds(1);
 800250c:	f004 f8a8 	bl	8006660 <chThdSleep>
    test_terminate_threads();
 8002510:	f001 f90e 	bl	8003730 <test_terminate_threads>
    test_wait_threads();
 8002514:	f000 fe14 	bl	8003140 <test_wait_threads>
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 8002518:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800251a:	480a      	ldr	r0, [pc, #40]	; (8002544 <test_012_008_execute.lto_priv.196+0xd4>)
    test_terminate_threads();
    test_wait_threads();
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 800251c:	f8c9 3000 	str.w	r3, [r9]
  {
    test_print("--- Score : ");
 8002520:	f001 fc4e 	bl	8003dc0 <test_print>
    test_printn(n);
 8002524:	9801      	ldr	r0, [sp, #4]
 8002526:	f001 fc5b 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 800252a:	4807      	ldr	r0, [pc, #28]	; (8002548 <test_012_008_execute.lto_priv.196+0xd8>)
 800252c:	f001 fc28 	bl	8003d80 <test_println>
  }
}
 8002530:	b003      	add	sp, #12
 8002532:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8002536:	bf00      	nop
 8002538:	200008b0 	.word	0x200008b0
 800253c:	08002641 	.word	0x08002641
 8002540:	20000f60 	.word	0x20000f60
 8002544:	08007e7c 	.word	0x08007e7c
 8002548:	08007eb8 	.word	0x08007eb8
 800254c:	200012a0 	.word	0x200012a0
 8002550:	20000f5c 	.word	0x20000f5c
 8002554:	f3af 8000 	nop.w
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <test_012_006_execute.lto_priv.193>:
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void test_012_006_execute(void) {
 8002560:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002562:	4b15      	ldr	r3, [pc, #84]	; (80025b8 <test_012_006_execute.lto_priv.193+0x58>)
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8002564:	4f15      	ldr	r7, [pc, #84]	; (80025bc <test_012_006_execute.lto_priv.193+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002566:	699b      	ldr	r3, [r3, #24]
 * .
 */

static void test_012_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 8002568:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800256a:	2301      	movs	r3, #1
 * .
 */

static void test_012_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 800256c:	441d      	add	r5, r3
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800256e:	603b      	str	r3, [r7, #0]
  {
    n = 0;
    start = test_wait_tick();
 8002570:	f000 fdd6 	bl	8003120 <test_wait_tick>
  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 8002574:	2400      	movs	r4, #0
    start = test_wait_tick();
 8002576:	4606      	mov	r6, r0
    end = start + MS2ST(1000);
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8002578:	4a11      	ldr	r2, [pc, #68]	; (80025c0 <test_012_006_execute.lto_priv.193+0x60>)
 800257a:	4812      	ldr	r0, [pc, #72]	; (80025c4 <test_012_006_execute.lto_priv.193+0x64>)
 800257c:	2300      	movs	r3, #0
 800257e:	4629      	mov	r1, r5
 8002580:	f004 fdf6 	bl	8007170 <chThdCreateStatic.constprop.69>
 8002584:	f003 fcac 	bl	8005ee0 <chThdRelease>
 8002588:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800258c:	f242 720f 	movw	r2, #9999	; 0x270f
 8002590:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002592:	1b9b      	subs	r3, r3, r6
 8002594:	4293      	cmp	r3, r2
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 8002596:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800259a:	d9ed      	bls.n	8002578 <test_012_006_execute.lto_priv.193+0x18>
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 800259c:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800259e:	480a      	ldr	r0, [pc, #40]	; (80025c8 <test_012_006_execute.lto_priv.193+0x68>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 80025a0:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 80025a2:	f001 fc0d 	bl	8003dc0 <test_print>
    test_printn(n);
 80025a6:	4620      	mov	r0, r4
 80025a8:	f001 fc1a 	bl	8003de0 <test_printn>
    test_println(" threads/S");
 80025ac:	4807      	ldr	r0, [pc, #28]	; (80025cc <test_012_006_execute.lto_priv.193+0x6c>)
  }
}
 80025ae:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [12.6.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 80025b2:	f001 bbe5 	b.w	8003d80 <test_println>
 80025b6:	bf00      	nop
 80025b8:	200012a0 	.word	0x200012a0
 80025bc:	20000f5c 	.word	0x20000f5c
 80025c0:	08002ab1 	.word	0x08002ab1
 80025c4:	200008b0 	.word	0x200008b0
 80025c8:	08007e7c 	.word	0x08007e7c
 80025cc:	08007ec4 	.word	0x08007ec4

080025d0 <test_012_005_execute.lto_priv.192>:
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void test_012_005_execute(void) {
 80025d0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80025d2:	4b15      	ldr	r3, [pc, #84]	; (8002628 <test_012_005_execute.lto_priv.192+0x58>)
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80025d4:	4f15      	ldr	r7, [pc, #84]	; (800262c <test_012_005_execute.lto_priv.192+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80025d6:	699b      	ldr	r3, [r3, #24]
 * .
 */

static void test_012_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 80025d8:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80025da:	2301      	movs	r3, #1
 80025dc:	603b      	str	r3, [r7, #0]
  {
    n = 0;
    start = test_wait_tick();
 80025de:	f000 fd9f 	bl	8003120 <test_wait_tick>
 * .
 */

static void test_012_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 80025e2:	3d01      	subs	r5, #1
  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 80025e4:	2400      	movs	r4, #0
    start = test_wait_tick();
 80025e6:	4606      	mov	r6, r0
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 80025e8:	4a11      	ldr	r2, [pc, #68]	; (8002630 <test_012_005_execute.lto_priv.192+0x60>)
 80025ea:	4812      	ldr	r0, [pc, #72]	; (8002634 <test_012_005_execute.lto_priv.192+0x64>)
 80025ec:	2300      	movs	r3, #0
 80025ee:	4629      	mov	r1, r5
 80025f0:	f004 fdbe 	bl	8007170 <chThdCreateStatic.constprop.69>
 80025f4:	f003 fde4 	bl	80061c0 <chThdWait>
 80025f8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80025fc:	f242 720f 	movw	r2, #9999	; 0x270f
 8002600:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8002602:	1b9b      	subs	r3, r3, r6
 8002604:	4293      	cmp	r3, r2
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
      n++;
 8002606:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800260a:	d9ed      	bls.n	80025e8 <test_012_005_execute.lto_priv.192+0x18>
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 800260c:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800260e:	480a      	ldr	r0, [pc, #40]	; (8002638 <test_012_005_execute.lto_priv.192+0x68>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 8002610:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8002612:	f001 fbd5 	bl	8003dc0 <test_print>
    test_printn(n);
 8002616:	4620      	mov	r0, r4
 8002618:	f001 fbe2 	bl	8003de0 <test_printn>
    test_println(" threads/S");
 800261c:	4807      	ldr	r0, [pc, #28]	; (800263c <test_012_005_execute.lto_priv.192+0x6c>)
  }
}
 800261e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [12.5.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 8002622:	f001 bbad 	b.w	8003d80 <test_println>
 8002626:	bf00      	nop
 8002628:	200012a0 	.word	0x200012a0
 800262c:	20000f5c 	.word	0x20000f5c
 8002630:	08002ab1 	.word	0x08002ab1
 8002634:	200008b0 	.word	0x200008b0
 8002638:	08007e7c 	.word	0x08007e7c
 800263c:	08007ec4 	.word	0x08007ec4

08002640 <bmk_thread8>:
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
}
#endif

static THD_FUNCTION(bmk_thread8, p) {
 8002640:	b538      	push	{r3, r4, r5, lr}
 8002642:	4d09      	ldr	r5, [pc, #36]	; (8002668 <bmk_thread8+0x28>)
 8002644:	4604      	mov	r4, r0

  do {
    chThdYield();
 8002646:	f003 fc1b 	bl	8005e80 <chThdYield>
    chThdYield();
 800264a:	f003 fc19 	bl	8005e80 <chThdYield>
    chThdYield();
 800264e:	f003 fc17 	bl	8005e80 <chThdYield>
    chThdYield();
 8002652:	f003 fc15 	bl	8005e80 <chThdYield>
    (*(uint32_t *)p) += 4;
 8002656:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8002658:	69aa      	ldr	r2, [r5, #24]
 800265a:	3304      	adds	r3, #4
 800265c:	6023      	str	r3, [r4, #0]
 800265e:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8002662:	075b      	lsls	r3, r3, #29
 8002664:	d5ef      	bpl.n	8002646 <bmk_thread8+0x6>
}
 8002666:	bd38      	pop	{r3, r4, r5, pc}
 8002668:	200012a0 	.word	0x200012a0
 800266c:	f3af 8000 	nop.w

08002670 <test_012_007_execute.lto_priv.195>:

static void test_012_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_012_007_execute(void) {
 8002670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002672:	4d32      	ldr	r5, [pc, #200]	; (800273c <test_012_007_execute.lto_priv.195+0xcc>)
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002674:	4f32      	ldr	r7, [pc, #200]	; (8002740 <test_012_007_execute.lto_priv.195+0xd0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002676:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8002678:	4a32      	ldr	r2, [pc, #200]	; (8002744 <test_012_007_execute.lto_priv.195+0xd4>)
 800267a:	6899      	ldr	r1, [r3, #8]
 800267c:	4832      	ldr	r0, [pc, #200]	; (8002748 <test_012_007_execute.lto_priv.195+0xd8>)
 800267e:	4c33      	ldr	r4, [pc, #204]	; (800274c <test_012_007_execute.lto_priv.195+0xdc>)
static void test_012_007_execute(void) {
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002680:	2601      	movs	r6, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8002682:	3105      	adds	r1, #5
 8002684:	2300      	movs	r3, #0
static void test_012_007_execute(void) {
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8002686:	603e      	str	r6, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8002688:	f004 fd72 	bl	8007170 <chThdCreateStatic.constprop.69>
 800268c:	69ab      	ldr	r3, [r5, #24]
 800268e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 8002690:	6899      	ldr	r1, [r3, #8]
 8002692:	4a2c      	ldr	r2, [pc, #176]	; (8002744 <test_012_007_execute.lto_priv.195+0xd4>)
 8002694:	482e      	ldr	r0, [pc, #184]	; (8002750 <test_012_007_execute.lto_priv.195+0xe0>)
 8002696:	3104      	adds	r1, #4
 8002698:	2300      	movs	r3, #0
 800269a:	f004 fd69 	bl	8007170 <chThdCreateStatic.constprop.69>
 800269e:	69ab      	ldr	r3, [r5, #24]
 80026a0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 80026a2:	6899      	ldr	r1, [r3, #8]
 80026a4:	4a27      	ldr	r2, [pc, #156]	; (8002744 <test_012_007_execute.lto_priv.195+0xd4>)
 80026a6:	482b      	ldr	r0, [pc, #172]	; (8002754 <test_012_007_execute.lto_priv.195+0xe4>)
 80026a8:	3103      	adds	r1, #3
 80026aa:	2300      	movs	r3, #0
 80026ac:	f004 fd60 	bl	8007170 <chThdCreateStatic.constprop.69>
 80026b0:	69ab      	ldr	r3, [r5, #24]
 80026b2:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 80026b4:	6899      	ldr	r1, [r3, #8]
 80026b6:	4a23      	ldr	r2, [pc, #140]	; (8002744 <test_012_007_execute.lto_priv.195+0xd4>)
 80026b8:	4827      	ldr	r0, [pc, #156]	; (8002758 <test_012_007_execute.lto_priv.195+0xe8>)
 80026ba:	3102      	adds	r1, #2
 80026bc:	2300      	movs	r3, #0
 80026be:	f004 fd57 	bl	8007170 <chThdCreateStatic.constprop.69>
 80026c2:	69ab      	ldr	r3, [r5, #24]
 80026c4:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80026c6:	6899      	ldr	r1, [r3, #8]
 80026c8:	4a1e      	ldr	r2, [pc, #120]	; (8002744 <test_012_007_execute.lto_priv.195+0xd4>)
 80026ca:	4824      	ldr	r0, [pc, #144]	; (800275c <test_012_007_execute.lto_priv.195+0xec>)
 80026cc:	4431      	add	r1, r6
 80026ce:	2300      	movs	r3, #0
 80026d0:	f004 fd4e 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 80026d4:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80026d6:	6120      	str	r0, [r4, #16]
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 80026d8:	603b      	str	r3, [r7, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80026da:	f000 fd21 	bl	8003120 <test_wait_tick>
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80026de:	2400      	movs	r4, #0
    start = test_wait_tick();
 80026e0:	4606      	mov	r6, r0
 80026e2:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
 80026e6:	481e      	ldr	r0, [pc, #120]	; (8002760 <test_012_007_execute.lto_priv.195+0xf0>)
 80026e8:	2100      	movs	r1, #0
 80026ea:	f003 fea1 	bl	8006430 <chSemReset>
 80026ee:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80026f0:	f242 720f 	movw	r2, #9999	; 0x270f
 80026f4:	1b9b      	subs	r3, r3, r6
 80026f6:	4293      	cmp	r3, r2
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
      n++;
 80026f8:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80026fc:	d9f3      	bls.n	80026e6 <test_012_007_execute.lto_priv.195+0x76>
  }

  /* [12.7.3] The five threads are terminated.*/
  test_set_step(3);
 80026fe:	2303      	movs	r3, #3
 8002700:	603b      	str	r3, [r7, #0]
  {
    test_terminate_threads();
 8002702:	f001 f815 	bl	8003730 <test_terminate_threads>
    chSemReset(&sem1, 0);
 8002706:	2100      	movs	r1, #0
 8002708:	4815      	ldr	r0, [pc, #84]	; (8002760 <test_012_007_execute.lto_priv.195+0xf0>)
 800270a:	f003 fe91 	bl	8006430 <chSemReset>
    test_wait_threads();
 800270e:	f000 fd17 	bl	8003140 <test_wait_threads>
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8002712:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8002714:	4813      	ldr	r0, [pc, #76]	; (8002764 <test_012_007_execute.lto_priv.195+0xf4>)
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8002716:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8002718:	f001 fb52 	bl	8003dc0 <test_print>
    test_printn(n);
 800271c:	4620      	mov	r0, r4
 800271e:	f001 fb5f 	bl	8003de0 <test_printn>
    test_print(" reschedules/S, ");
 8002722:	4811      	ldr	r0, [pc, #68]	; (8002768 <test_012_007_execute.lto_priv.195+0xf8>)
 8002724:	f001 fb4c 	bl	8003dc0 <test_print>
    test_printn(n * 6);
 8002728:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 800272c:	0040      	lsls	r0, r0, #1
 800272e:	f001 fb57 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 8002732:	480e      	ldr	r0, [pc, #56]	; (800276c <test_012_007_execute.lto_priv.195+0xfc>)
  }
}
 8002734:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" reschedules/S, ");
    test_printn(n * 6);
    test_println(" ctxswc/S");
 8002738:	f001 bb22 	b.w	8003d80 <test_println>
 800273c:	200012a0 	.word	0x200012a0
 8002740:	20000f5c 	.word	0x20000f5c
 8002744:	080023b1 	.word	0x080023b1
 8002748:	200008b0 	.word	0x200008b0
 800274c:	20000f60 	.word	0x20000f60
 8002750:	200009f8 	.word	0x200009f8
 8002754:	20000b40 	.word	0x20000b40
 8002758:	20000c88 	.word	0x20000c88
 800275c:	20000dd0 	.word	0x20000dd0
 8002760:	20000f3c 	.word	0x20000f3c
 8002764:	08007e7c 	.word	0x08007e7c
 8002768:	08007ed0 	.word	0x08007ed0
 800276c:	08007eb8 	.word	0x08007eb8

08002770 <test_012_004_execute.lto_priv.191>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002770:	4b2e      	ldr	r3, [pc, #184]	; (800282c <test_012_004_execute.lto_priv.191+0xbc>)
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002772:	4a2f      	ldr	r2, [pc, #188]	; (8002830 <test_012_004_execute.lto_priv.191+0xc0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002774:	699b      	ldr	r3, [r3, #24]
 8002776:	482f      	ldr	r0, [pc, #188]	; (8002834 <test_012_004_execute.lto_priv.191+0xc4>)
 8002778:	6899      	ldr	r1, [r3, #8]
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 800277a:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800277e:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 8002844 <test_012_004_execute.lto_priv.191+0xd4>
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 8002782:	b083      	sub	sp, #12
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002784:	3101      	adds	r1, #1
static void test_012_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 8002786:	2401      	movs	r4, #1
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002788:	2300      	movs	r3, #0
static void test_012_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 800278a:	f8cb 4000 	str.w	r4, [fp]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 800278e:	f004 fcef 	bl	8007170 <chThdCreateStatic.constprop.69>
 8002792:	4a29      	ldr	r2, [pc, #164]	; (8002838 <test_012_004_execute.lto_priv.191+0xc8>)
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 8002794:	2302      	movs	r3, #2
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8002796:	4604      	mov	r4, r0
 8002798:	6010      	str	r0, [r2, #0]
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 800279a:	f8cb 3000 	str.w	r3, [fp]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800279e:	f000 fcbf 	bl	8003120 <test_wait_tick>
     time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80027a2:	2500      	movs	r5, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 80027a4:	46aa      	mov	sl, r5
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80027a6:	4681      	mov	r9, r0
 80027a8:	f04f 0820 	mov.w	r8, #32
 80027ac:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80027b0:	2620      	movs	r6, #32
 80027b2:	f388 8811 	msr	BASEPRI, r8
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 80027b6:	2100      	movs	r1, #0
 80027b8:	4620      	mov	r0, r4
 80027ba:	f003 fc71 	bl	80060a0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80027be:	4620      	mov	r0, r4
 80027c0:	2100      	movs	r1, #0
 80027c2:	f003 fc6d 	bl	80060a0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80027c6:	4620      	mov	r0, r4
 80027c8:	2100      	movs	r1, #0
 80027ca:	f003 fc69 	bl	80060a0 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80027ce:	4620      	mov	r0, r4
 80027d0:	2100      	movs	r1, #0
 80027d2:	f003 fc65 	bl	80060a0 <chSchWakeupS>
 80027d6:	2200      	movs	r2, #0
 80027d8:	f38a 8811 	msr	BASEPRI, sl
 80027dc:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      chSysUnlock();
      n += 4;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80027de:	f242 710f 	movw	r1, #9999	; 0x270f
 80027e2:	ebc9 0303 	rsb	r3, r9, r3
 80027e6:	428b      	cmp	r3, r1
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSysUnlock();
      n += 4;
 80027e8:	f105 0504 	add.w	r5, r5, #4
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80027ec:	d9e0      	bls.n	80027b0 <test_012_004_execute.lto_priv.191+0x40>
  }

  /* [12.4.3] Stopping the target thread.*/
  test_set_step(3);
 80027ee:	2303      	movs	r3, #3
 80027f0:	9201      	str	r2, [sp, #4]
 80027f2:	f8cb 3000 	str.w	r3, [fp]
 80027f6:	f386 8811 	msr	BASEPRI, r6
  {
    chSysLock();
    chSchWakeupS(tp, MSG_TIMEOUT);
 80027fa:	f04f 31ff 	mov.w	r1, #4294967295
 80027fe:	4620      	mov	r0, r4
 8002800:	f003 fc4e 	bl	80060a0 <chSchWakeupS>
 8002804:	9a01      	ldr	r2, [sp, #4]
 8002806:	f382 8811 	msr	BASEPRI, r2
    chSysUnlock();
    test_wait_threads();
 800280a:	f000 fc99 	bl	8003140 <test_wait_threads>
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 800280e:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8002810:	480a      	ldr	r0, [pc, #40]	; (800283c <test_012_004_execute.lto_priv.191+0xcc>)
    chSysUnlock();
    test_wait_threads();
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 8002812:	f8cb 3000 	str.w	r3, [fp]
  {
    test_print("--- Score : ");
 8002816:	f001 fad3 	bl	8003dc0 <test_print>
    test_printn(n * 2);
 800281a:	0068      	lsls	r0, r5, #1
 800281c:	f001 fae0 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 8002820:	4807      	ldr	r0, [pc, #28]	; (8002840 <test_012_004_execute.lto_priv.191+0xd0>)
  }
}
 8002822:	b003      	add	sp, #12
 8002824:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* [12.4.4] Score is printed.*/
  test_set_step(4);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" ctxswc/S");
 8002828:	f001 baaa 	b.w	8003d80 <test_println>
 800282c:	200012a0 	.word	0x200012a0
 8002830:	08002851 	.word	0x08002851
 8002834:	200008b0 	.word	0x200008b0
 8002838:	20000f60 	.word	0x20000f60
 800283c:	08007e7c 	.word	0x08007e7c
 8002840:	08007eb8 	.word	0x08007eb8
 8002844:	20000f5c 	.word	0x20000f5c
 8002848:	f3af 8000 	nop.w
 800284c:	f3af 8000 	nop.w

08002850 <bmk_thread4>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002850:	4a07      	ldr	r2, [pc, #28]	; (8002870 <bmk_thread4+0x20>)
static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
}

static THD_FUNCTION(bmk_thread4, p) {
 8002852:	b510      	push	{r4, lr}
 8002854:	2320      	movs	r3, #32
 8002856:	6994      	ldr	r4, [r2, #24]
 8002858:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800285c:	2003      	movs	r0, #3
 800285e:	f003 fc6f 	bl	8006140 <chSchGoSleepS>
    msg = self->u.rdymsg;
  } while (msg == MSG_OK);
 8002862:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8002864:	2b00      	cmp	r3, #0
 8002866:	d0f9      	beq.n	800285c <bmk_thread4+0xc>
 8002868:	2300      	movs	r3, #0
 800286a:	f383 8811 	msr	BASEPRI, r3
 800286e:	bd10      	pop	{r4, pc}
 8002870:	200012a0 	.word	0x200012a0
 8002874:	f3af 8000 	nop.w
 8002878:	f3af 8000 	nop.w
 800287c:	f3af 8000 	nop.w

08002880 <test_012_003_execute.lto_priv.190>:
 *   second time window.
 * - [12.3.4] Score is printed.
 * .
 */

static void test_012_003_execute(void) {
 8002880:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002884:	4e2c      	ldr	r6, [pc, #176]	; (8002938 <test_012_003_execute.lto_priv.190+0xb8>)

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002886:	4d2d      	ldr	r5, [pc, #180]	; (800293c <test_012_003_execute.lto_priv.190+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002888:	69b3      	ldr	r3, [r6, #24]
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 800288a:	4f2d      	ldr	r7, [pc, #180]	; (8002940 <test_012_003_execute.lto_priv.190+0xc0>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800288c:	6899      	ldr	r1, [r3, #8]
 800288e:	4a2d      	ldr	r2, [pc, #180]	; (8002944 <test_012_003_execute.lto_priv.190+0xc4>)
 8002890:	4c2d      	ldr	r4, [pc, #180]	; (8002948 <test_012_003_execute.lto_priv.190+0xc8>)

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8002892:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 8002958 <test_012_003_execute.lto_priv.190+0xd8>
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8002896:	f04f 0e01 	mov.w	lr, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800289a:	3101      	adds	r1, #1
 800289c:	4628      	mov	r0, r5
 800289e:	2300      	movs	r3, #0
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80028a0:	f8c7 e000 	str.w	lr, [r7]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80028a4:	f004 fc64 	bl	8007170 <chThdCreateStatic.constprop.69>
 80028a8:	69b3      	ldr	r3, [r6, #24]
 80028aa:	6020      	str	r0, [r4, #0]

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80028ac:	6899      	ldr	r1, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 80028ae:	f04f 0e02 	mov.w	lr, #2
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80028b2:	4642      	mov	r2, r8
 80028b4:	3902      	subs	r1, #2
 80028b6:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 80028ba:	2300      	movs	r3, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 80028bc:	f8c7 e000 	str.w	lr, [r7]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 80028c0:	f004 fc56 	bl	8007170 <chThdCreateStatic.constprop.69>
 80028c4:	69b3      	ldr	r3, [r6, #24]
 80028c6:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 80028c8:	6899      	ldr	r1, [r3, #8]
 80028ca:	4642      	mov	r2, r8
 80028cc:	f505 7024 	add.w	r0, r5, #656	; 0x290
 80028d0:	3903      	subs	r1, #3
 80028d2:	2300      	movs	r3, #0
 80028d4:	f004 fc4c 	bl	8007170 <chThdCreateStatic.constprop.69>
 80028d8:	69b3      	ldr	r3, [r6, #24]
 80028da:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 80028dc:	6899      	ldr	r1, [r3, #8]
 80028de:	4642      	mov	r2, r8
 80028e0:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 80028e4:	3904      	subs	r1, #4
 80028e6:	2300      	movs	r3, #0
 80028e8:	f004 fc42 	bl	8007170 <chThdCreateStatic.constprop.69>
 80028ec:	69b3      	ldr	r3, [r6, #24]
 80028ee:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 80028f0:	6899      	ldr	r1, [r3, #8]
 80028f2:	4642      	mov	r2, r8
 80028f4:	3905      	subs	r1, #5
 80028f6:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 80028fa:	2300      	movs	r3, #0
 80028fc:	f004 fc38 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8002900:	2303      	movs	r3, #3
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8002902:	6120      	str	r0, [r4, #16]

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  {
    n = msg_loop_test(threads[0]);
 8002904:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8002906:	603b      	str	r3, [r7, #0]
  {
    n = msg_loop_test(threads[0]);
 8002908:	f003 f9ea 	bl	8005ce0 <msg_loop_test.lto_priv.90>
 800290c:	4604      	mov	r4, r0
    test_wait_threads();
 800290e:	f000 fc17 	bl	8003140 <test_wait_threads>
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8002912:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8002914:	480d      	ldr	r0, [pc, #52]	; (800294c <test_012_003_execute.lto_priv.190+0xcc>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8002916:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8002918:	f001 fa52 	bl	8003dc0 <test_print>
    test_printn(n);
 800291c:	4620      	mov	r0, r4
 800291e:	f001 fa5f 	bl	8003de0 <test_printn>
    test_print(" msgs/S, ");
 8002922:	480b      	ldr	r0, [pc, #44]	; (8002950 <test_012_003_execute.lto_priv.190+0xd0>)
 8002924:	f001 fa4c 	bl	8003dc0 <test_print>
    test_printn(n << 1);
 8002928:	0060      	lsls	r0, r4, #1
 800292a:	f001 fa59 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 800292e:	4809      	ldr	r0, [pc, #36]	; (8002954 <test_012_003_execute.lto_priv.190+0xd4>)
  }
}
 8002930:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 8002934:	f001 ba24 	b.w	8003d80 <test_println>
 8002938:	200012a0 	.word	0x200012a0
 800293c:	200008b0 	.word	0x200008b0
 8002940:	20000f5c 	.word	0x20000f5c
 8002944:	08005291 	.word	0x08005291
 8002948:	20000f60 	.word	0x20000f60
 800294c:	08007e7c 	.word	0x08007e7c
 8002950:	08007ee4 	.word	0x08007ee4
 8002954:	08007eb8 	.word	0x08007eb8
 8002958:	08002ab1 	.word	0x08002ab1
 800295c:	f3af 8000 	nop.w

08002960 <test_012_002_execute.lto_priv.189>:
 *   second time window.
 * - [12.2.3] Score is printed.
 * .
 */

static void test_012_002_execute(void) {
 8002960:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002962:	4b14      	ldr	r3, [pc, #80]	; (80029b4 <test_012_002_execute.lto_priv.189+0x54>)
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8002964:	4c14      	ldr	r4, [pc, #80]	; (80029b8 <test_012_002_execute.lto_priv.189+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002966:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002968:	4a14      	ldr	r2, [pc, #80]	; (80029bc <test_012_002_execute.lto_priv.189+0x5c>)
 800296a:	6899      	ldr	r1, [r3, #8]
 800296c:	4814      	ldr	r0, [pc, #80]	; (80029c0 <test_012_002_execute.lto_priv.189+0x60>)
 800296e:	3101      	adds	r1, #1
static void test_012_002_execute(void) {
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8002970:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002972:	2300      	movs	r3, #0
static void test_012_002_execute(void) {
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8002974:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8002976:	f004 fbfb 	bl	8007170 <chThdCreateStatic.constprop.69>
 800297a:	4a12      	ldr	r2, [pc, #72]	; (80029c4 <test_012_002_execute.lto_priv.189+0x64>)
  }

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800297c:	2302      	movs	r3, #2

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800297e:	6010      	str	r0, [r2, #0]
  }

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 8002980:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 8002982:	f003 f9ad 	bl	8005ce0 <msg_loop_test.lto_priv.90>
 8002986:	4605      	mov	r5, r0
    test_wait_threads();
 8002988:	f000 fbda 	bl	8003140 <test_wait_threads>
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 800298c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800298e:	480e      	ldr	r0, [pc, #56]	; (80029c8 <test_012_002_execute.lto_priv.189+0x68>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 8002990:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8002992:	f001 fa15 	bl	8003dc0 <test_print>
    test_printn(n);
 8002996:	4628      	mov	r0, r5
 8002998:	f001 fa22 	bl	8003de0 <test_printn>
    test_print(" msgs/S, ");
 800299c:	480b      	ldr	r0, [pc, #44]	; (80029cc <test_012_002_execute.lto_priv.189+0x6c>)
 800299e:	f001 fa0f 	bl	8003dc0 <test_print>
    test_printn(n << 1);
 80029a2:	0068      	lsls	r0, r5, #1
 80029a4:	f001 fa1c 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 80029a8:	4809      	ldr	r0, [pc, #36]	; (80029d0 <test_012_002_execute.lto_priv.189+0x70>)
  }
}
 80029aa:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 80029ae:	f001 b9e7 	b.w	8003d80 <test_println>
 80029b2:	bf00      	nop
 80029b4:	200012a0 	.word	0x200012a0
 80029b8:	20000f5c 	.word	0x20000f5c
 80029bc:	08005291 	.word	0x08005291
 80029c0:	200008b0 	.word	0x200008b0
 80029c4:	20000f60 	.word	0x20000f60
 80029c8:	08007e7c 	.word	0x08007e7c
 80029cc:	08007ee4 	.word	0x08007ee4
 80029d0:	08007eb8 	.word	0x08007eb8
 80029d4:	f3af 8000 	nop.w
 80029d8:	f3af 8000 	nop.w
 80029dc:	f3af 8000 	nop.w

080029e0 <test_012_001_execute.lto_priv.188>:
 *   second time window.
 * - [12.1.3] Score is printed.
 * .
 */

static void test_012_001_execute(void) {
 80029e0:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80029e2:	4b14      	ldr	r3, [pc, #80]	; (8002a34 <test_012_001_execute.lto_priv.188+0x54>)
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80029e4:	4c14      	ldr	r4, [pc, #80]	; (8002a38 <test_012_001_execute.lto_priv.188+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80029e6:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80029e8:	4a14      	ldr	r2, [pc, #80]	; (8002a3c <test_012_001_execute.lto_priv.188+0x5c>)
 80029ea:	6899      	ldr	r1, [r3, #8]
 80029ec:	4814      	ldr	r0, [pc, #80]	; (8002a40 <test_012_001_execute.lto_priv.188+0x60>)
 80029ee:	3901      	subs	r1, #1
static void test_012_001_execute(void) {
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80029f0:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80029f2:	2300      	movs	r3, #0
static void test_012_001_execute(void) {
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 80029f4:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80029f6:	f004 fbbb 	bl	8007170 <chThdCreateStatic.constprop.69>
 80029fa:	4a12      	ldr	r2, [pc, #72]	; (8002a44 <test_012_001_execute.lto_priv.188+0x64>)
  }

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80029fc:	2302      	movs	r3, #2

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 80029fe:	6010      	str	r0, [r2, #0]
  }

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 8002a00:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 8002a02:	f003 f96d 	bl	8005ce0 <msg_loop_test.lto_priv.90>
 8002a06:	4605      	mov	r5, r0
    test_wait_threads();
 8002a08:	f000 fb9a 	bl	8003140 <test_wait_threads>
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 8002a0c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 8002a0e:	480e      	ldr	r0, [pc, #56]	; (8002a48 <test_012_001_execute.lto_priv.188+0x68>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 8002a10:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8002a12:	f001 f9d5 	bl	8003dc0 <test_print>
    test_printn(n);
 8002a16:	4628      	mov	r0, r5
 8002a18:	f001 f9e2 	bl	8003de0 <test_printn>
    test_print(" msgs/S, ");
 8002a1c:	480b      	ldr	r0, [pc, #44]	; (8002a4c <test_012_001_execute.lto_priv.188+0x6c>)
 8002a1e:	f001 f9cf 	bl	8003dc0 <test_print>
    test_printn(n << 1);
 8002a22:	0068      	lsls	r0, r5, #1
 8002a24:	f001 f9dc 	bl	8003de0 <test_printn>
    test_println(" ctxswc/S");
 8002a28:	4809      	ldr	r0, [pc, #36]	; (8002a50 <test_012_001_execute.lto_priv.188+0x70>)
  }
}
 8002a2a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 8002a2e:	f001 b9a7 	b.w	8003d80 <test_println>
 8002a32:	bf00      	nop
 8002a34:	200012a0 	.word	0x200012a0
 8002a38:	20000f5c 	.word	0x20000f5c
 8002a3c:	08005291 	.word	0x08005291
 8002a40:	200008b0 	.word	0x200008b0
 8002a44:	20000f60 	.word	0x20000f60
 8002a48:	08007e7c 	.word	0x08007e7c
 8002a4c:	08007ee4 	.word	0x08007ee4
 8002a50:	08007eb8 	.word	0x08007eb8
 8002a54:	f3af 8000 	nop.w
 8002a58:	f3af 8000 	nop.w
 8002a5c:	f3af 8000 	nop.w

08002a60 <long_to_string_with_divisor.lto_priv.85>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 8002a60:	b4f0      	push	{r4, r5, r6, r7}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8002a62:	f100 070b 	add.w	r7, r0, #11
  int i;
  char *q;
  long l, ll;

  l = num;
  if (divisor == 0) {
 8002a66:	2b00      	cmp	r3, #0
 8002a68:	bf08      	it	eq
 8002a6a:	460b      	moveq	r3, r1
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8002a6c:	463d      	mov	r5, r7
  do {
    i = (int)(l % radix);
 8002a6e:	fbb1 f6f2 	udiv	r6, r1, r2
 8002a72:	fb02 1116 	mls	r1, r2, r6, r1
    i += '0';
 8002a76:	f101 0430 	add.w	r4, r1, #48	; 0x30
    if (i > '9')
 8002a7a:	2c39      	cmp	r4, #57	; 0x39
      i += 'A' - '0' - 10;
 8002a7c:	bfc8      	it	gt
 8002a7e:	f101 0437 	addgt.w	r4, r1, #55	; 0x37
    *--q = i;
 8002a82:	b2e4      	uxtb	r4, r4
 8002a84:	f805 4d01 	strb.w	r4, [r5, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 8002a88:	fbb3 f3f2 	udiv	r3, r3, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 8002a8c:	4631      	mov	r1, r6
  } while ((ll /= radix) != 0);
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	d1ed      	bne.n	8002a6e <long_to_string_with_divisor.lto_priv.85+0xe>

  i = (int)(p + MAX_FILLER - q);
 8002a92:	1b7b      	subs	r3, r7, r5
 8002a94:	4403      	add	r3, r0
 8002a96:	e001      	b.n	8002a9c <long_to_string_with_divisor.lto_priv.85+0x3c>
 8002a98:	f815 4f01 	ldrb.w	r4, [r5, #1]!
  do
    *p++ = *q++;
 8002a9c:	f800 4b01 	strb.w	r4, [r0], #1
  while (--i);
 8002aa0:	4298      	cmp	r0, r3
 8002aa2:	d1f9      	bne.n	8002a98 <long_to_string_with_divisor.lto_priv.85+0x38>

  return p;
}
 8002aa4:	bcf0      	pop	{r4, r5, r6, r7}
 8002aa6:	4770      	bx	lr
 8002aa8:	f3af 8000 	nop.w
 8002aac:	f3af 8000 	nop.w

08002ab0 <bmk_thread3>:
}
#endif

static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
 8002ab0:	f003 bcf6 	b.w	80064a0 <chThdExit>
 8002ab4:	f3af 8000 	nop.w
 8002ab8:	f3af 8000 	nop.w
 8002abc:	f3af 8000 	nop.w

08002ac0 <test_004_004_setup.lto_priv.132>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ac0:	4b02      	ldr	r3, [pc, #8]	; (8002acc <test_004_004_setup.lto_priv.132+0xc>)
 8002ac2:	2200      	movs	r2, #0
 8002ac4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ac6:	605b      	str	r3, [r3, #4]
 8002ac8:	609a      	str	r2, [r3, #8]
 8002aca:	4770      	bx	lr
 8002acc:	20001340 	.word	0x20001340

08002ad0 <test_004_003_setup.lto_priv.130>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ad0:	4b02      	ldr	r3, [pc, #8]	; (8002adc <test_004_003_setup.lto_priv.130+0xc>)
 8002ad2:	2200      	movs	r2, #0
 8002ad4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ad6:	605b      	str	r3, [r3, #4]
 8002ad8:	609a      	str	r2, [r3, #8]
 8002ada:	4770      	bx	lr
 8002adc:	20001340 	.word	0x20001340

08002ae0 <test_004_002_setup.lto_priv.128>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ae0:	4b02      	ldr	r3, [pc, #8]	; (8002aec <test_004_002_setup.lto_priv.128+0xc>)
 8002ae2:	2200      	movs	r2, #0
 8002ae4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ae6:	605b      	str	r3, [r3, #4]
 8002ae8:	609a      	str	r2, [r3, #8]
 8002aea:	4770      	bx	lr
 8002aec:	20001340 	.word	0x20001340

08002af0 <test_004_001_setup.lto_priv.125>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002af0:	4b02      	ldr	r3, [pc, #8]	; (8002afc <test_004_001_setup.lto_priv.125+0xc>)
 8002af2:	2201      	movs	r2, #1
 8002af4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002af6:	605b      	str	r3, [r3, #4]
 8002af8:	609a      	str	r2, [r3, #8]
 8002afa:	4770      	bx	lr
 8002afc:	20001340 	.word	0x20001340

08002b00 <test_003_001_setup.lto_priv.123>:
 *   the state of the reference are tested.
 * .
 */

static void test_003_001_setup(void) {
  tr1 = NULL;
 8002b00:	4b01      	ldr	r3, [pc, #4]	; (8002b08 <test_003_001_setup.lto_priv.123+0x8>)
 8002b02:	2200      	movs	r2, #0
 8002b04:	601a      	str	r2, [r3, #0]
 8002b06:	4770      	bx	lr
 8002b08:	20000f74 	.word	0x20000f74
 8002b0c:	f3af 8000 	nop.w

08002b10 <test_001_004_execute.lto_priv.118>:

static void test_001_004_execute(void) {

  /* [1.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 8002b10:	4b04      	ldr	r3, [pc, #16]	; (8002b24 <test_001_004_execute.lto_priv.118+0x14>)
 8002b12:	2101      	movs	r1, #1
 8002b14:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8002b18:	6019      	str	r1, [r3, #0]
 8002b1a:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8002b1c:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 8002b1e:	428b      	cmp	r3, r1
 8002b20:	d0fc      	beq.n	8002b1c <test_001_004_execute.lto_priv.118+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 8002b22:	4770      	bx	lr
 8002b24:	20000f5c 	.word	0x20000f5c
 8002b28:	f3af 8000 	nop.w
 8002b2c:	f3af 8000 	nop.w

08002b30 <test_001_003_execute.lto_priv.117>:

static void test_001_003_execute(void) {

  /* [1.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 8002b30:	4b07      	ldr	r3, [pc, #28]	; (8002b50 <test_001_003_execute.lto_priv.117+0x20>)
 8002b32:	2201      	movs	r2, #1
 8002b34:	601a      	str	r2, [r3, #0]
 8002b36:	2320      	movs	r3, #32
 8002b38:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b3c:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8002b3e:	b672      	cpsid	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002b40:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b44:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002b46:	2300      	movs	r3, #0
 8002b48:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002b4c:	b662      	cpsie	i
 8002b4e:	4770      	bx	lr
 8002b50:	20000f5c 	.word	0x20000f5c
 8002b54:	f3af 8000 	nop.w
 8002b58:	f3af 8000 	nop.w
 8002b5c:	f3af 8000 	nop.w

08002b60 <thread>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 8002b60:	7800      	ldrb	r0, [r0, #0]
 8002b62:	f001 b8f5 	b.w	8003d50 <test_emit_token>
 8002b66:	bf00      	nop
 8002b68:	f3af 8000 	nop.w
 8002b6c:	f3af 8000 	nop.w

08002b70 <thread1.lto_priv.110>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 8002b70:	b510      	push	{r4, lr}
 8002b72:	4604      	mov	r4, r0

  chSemWait(&sem1);
 8002b74:	4803      	ldr	r0, [pc, #12]	; (8002b84 <thread1.lto_priv.110+0x14>)
 8002b76:	f003 fafb 	bl	8006170 <chSemWait>
  test_emit_token(*(char *)p);
 8002b7a:	7820      	ldrb	r0, [r4, #0]
}
 8002b7c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 8002b80:	f001 b8e6 	b.w	8003d50 <test_emit_token>
 8002b84:	20001340 	.word	0x20001340
 8002b88:	f3af 8000 	nop.w
 8002b8c:	f3af 8000 	nop.w

08002b90 <thread1.lto_priv.109>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8002b90:	b510      	push	{r4, lr}
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002b92:	2320      	movs	r3, #32
 8002b94:	4604      	mov	r4, r0
 8002b96:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8002b9a:	4b09      	ldr	r3, [pc, #36]	; (8002bc0 <thread1.lto_priv.109+0x30>)
 8002b9c:	6818      	ldr	r0, [r3, #0]
 8002b9e:	b120      	cbz	r0, 8002baa <thread1.lto_priv.109+0x1a>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002ba0:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 8002ba2:	6242      	str	r2, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8002ba4:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8002ba6:	f003 fb2b 	bl	8006200 <chSchReadyI>

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
 8002baa:	f003 fa39 	bl	8006020 <chSchRescheduleS>
 8002bae:	2300      	movs	r3, #0
 8002bb0:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_emit_token(*(char *)p);
 8002bb4:	7820      	ldrb	r0, [r4, #0]
}
 8002bb6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
  chSysUnlock();
  test_emit_token(*(char *)p);
 8002bba:	f001 b8c9 	b.w	8003d50 <test_emit_token>
 8002bbe:	bf00      	nop
 8002bc0:	20000f74 	.word	0x20000f74
 8002bc4:	f3af 8000 	nop.w
 8002bc8:	f3af 8000 	nop.w
 8002bcc:	f3af 8000 	nop.w

08002bd0 <thread4.lto_priv.106>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {
 8002bd0:	b508      	push	{r3, lr}
 8002bd2:	2220      	movs	r2, #32
 8002bd4:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8002bd8:	6883      	ldr	r3, [r0, #8]
 8002bda:	2b00      	cmp	r3, #0
 8002bdc:	dd05      	ble.n	8002bea <thread4.lto_priv.106+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002bde:	f003 fa1f 	bl	8006020 <chSchRescheduleS>
 8002be2:	2300      	movs	r3, #0
 8002be4:	f383 8811 	msr	BASEPRI, r3
 8002be8:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 8002bea:	f003 fbf9 	bl	80063e0 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8002bee:	f003 fa17 	bl	8006020 <chSchRescheduleS>
 8002bf2:	2300      	movs	r3, #0
 8002bf4:	f383 8811 	msr	BASEPRI, r3
 8002bf8:	bd08      	pop	{r3, pc}
 8002bfa:	bf00      	nop
 8002bfc:	f3af 8000 	nop.w

08002c00 <thread2>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {
 8002c00:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8002c02:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002c06:	f003 fd2b 	bl	8006660 <chThdSleep>
 8002c0a:	2320      	movs	r3, #32
 8002c0c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8002c10:	4804      	ldr	r0, [pc, #16]	; (8002c24 <thread2+0x24>)
 8002c12:	f003 fbe5 	bl	80063e0 <chSemSignalI>
  chSchRescheduleS();
 8002c16:	f003 fa03 	bl	8006020 <chSchRescheduleS>
 8002c1a:	2300      	movs	r3, #0
 8002c1c:	f383 8811 	msr	BASEPRI, r3
 8002c20:	bd08      	pop	{r3, pc}
 8002c22:	bf00      	nop
 8002c24:	20001340 	.word	0x20001340
 8002c28:	f3af 8000 	nop.w
 8002c2c:	f3af 8000 	nop.w

08002c30 <test_002_001_execute.lto_priv.119>:
 * - [2.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void test_002_001_execute(void) {
 8002c30:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [2.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8002c32:	4e2b      	ldr	r6, [pc, #172]	; (8002ce0 <test_002_001_execute.lto_priv.119+0xb0>)
 8002c34:	2301      	movs	r3, #1
 8002c36:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8002c3a:	6033      	str	r3, [r6, #0]
 8002c3c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 8002c3e:	2064      	movs	r0, #100	; 0x64
 8002c40:	f003 fd0e 	bl	8006660 <chThdSleep>
    test_assert_time_window(time + 100,
 8002c44:	f104 0064 	add.w	r0, r4, #100	; 0x64
 8002c48:	f104 0167 	add.w	r1, r4, #103	; 0x67
 8002c4c:	f004 fda8 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8002c50:	b100      	cbz	r0, 8002c54 <test_002_001_execute.lto_priv.119+0x24>
 8002c52:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [2.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 8002c54:	2302      	movs	r3, #2
 8002c56:	6033      	str	r3, [r6, #0]
 8002c58:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 8002c5a:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002c5e:	f003 fcff 	bl	8006660 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 8002c62:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8002c66:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 8002c6a:	f004 fd99 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8002c6e:	2800      	cmp	r0, #0
 8002c70:	d1ef      	bne.n	8002c52 <test_002_001_execute.lto_priv.119+0x22>
  }

  /* [2.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 8002c72:	2303      	movs	r3, #3
 8002c74:	6033      	str	r3, [r6, #0]
 8002c76:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 8002c78:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8002c7c:	f003 fcf0 	bl	8006660 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 8002c80:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 8002c84:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 8002c88:	f004 fd8a 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8002c8c:	2800      	cmp	r0, #0
 8002c8e:	d1e0      	bne.n	8002c52 <test_002_001_execute.lto_priv.119+0x22>
                            "out of time window");
  }

  /* [2.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 8002c90:	2304      	movs	r3, #4
 8002c92:	6033      	str	r3, [r6, #0]
 8002c94:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 8002c96:	f242 7010 	movw	r0, #10000	; 0x2710
 8002c9a:	f003 fce1 	bl	8006660 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 8002c9e:	f504 501c 	add.w	r0, r4, #9984	; 0x2700
 8002ca2:	4601      	mov	r1, r0
 8002ca4:	3113      	adds	r1, #19
 8002ca6:	3010      	adds	r0, #16
 8002ca8:	f004 fd7a 	bl	80077a0 <_test_assert_time_window.constprop.3>
 8002cac:	2800      	cmp	r0, #0
 8002cae:	d1d0      	bne.n	8002c52 <test_002_001_execute.lto_priv.119+0x22>
                            "out of time window");
  }

  /* [2.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 8002cb0:	2305      	movs	r3, #5
 8002cb2:	6033      	str	r3, [r6, #0]
 8002cb4:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 8002cb6:	2320      	movs	r3, #32
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
 8002cb8:	f106 0464 	add.w	r4, r6, #100	; 0x64
 8002cbc:	f383 8811 	msr	BASEPRI, r3
 8002cc0:	6a69      	ldr	r1, [r5, #36]	; 0x24
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
  if (time > (systime_t)0) {
 8002cc2:	1a61      	subs	r1, r4, r1
 8002cc4:	d002      	beq.n	8002ccc <test_002_001_execute.lto_priv.119+0x9c>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8002cc6:	2008      	movs	r0, #8
 8002cc8:	f003 fc6a 	bl	80065a0 <chSchGoSleepTimeoutS>
 8002ccc:	2300      	movs	r3, #0
 8002cce:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(time + 100,
 8002cd2:	4620      	mov	r0, r4
 8002cd4:	f106 0167 	add.w	r1, r6, #103	; 0x67
                            time + 100 + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
  }
}
 8002cd8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     "now" + 100 ticks.*/
  test_set_step(5);
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
    test_assert_time_window(time + 100,
 8002cdc:	f004 bd60 	b.w	80077a0 <_test_assert_time_window.constprop.3>
 8002ce0:	20000f5c 	.word	0x20000f5c
 8002ce4:	f3af 8000 	nop.w
 8002ce8:	f3af 8000 	nop.w
 8002cec:	f3af 8000 	nop.w

08002cf0 <thread3.lto_priv.107>:
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {
 8002cf0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 8002cf2:	4c04      	ldr	r4, [pc, #16]	; (8002d04 <thread3.lto_priv.107+0x14>)
 8002cf4:	4620      	mov	r0, r4
 8002cf6:	f003 fa3b 	bl	8006170 <chSemWait>
  chSemSignal(&sem1);
 8002cfa:	4620      	mov	r0, r4
}
 8002cfc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 8002d00:	f003 b9fe 	b.w	8006100 <chSemSignal>
 8002d04:	20001340 	.word	0x20001340
 8002d08:	f3af 8000 	nop.w
 8002d0c:	f3af 8000 	nop.w

08002d10 <test_004_001_execute.lto_priv.127>:

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
}

static void test_004_001_execute(void) {
 8002d10:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     counter and the returned message are tested.*/
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8002d14:	4c2b      	ldr	r4, [pc, #172]	; (8002dc4 <test_004_001_execute.lto_priv.127+0xb4>)

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8002d16:	4e2c      	ldr	r6, [pc, #176]	; (8002dc8 <test_004_001_execute.lto_priv.127+0xb8>)
 8002d18:	2301      	movs	r3, #1
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8002d1a:	4620      	mov	r0, r4

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 8002d1c:	6033      	str	r3, [r6, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 8002d1e:	f003 fa27 	bl	8006170 <chSemWait>
 8002d22:	2520      	movs	r5, #32
 8002d24:	4607      	mov	r7, r0
 8002d26:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 8002d2a:	4928      	ldr	r1, [pc, #160]	; (8002dcc <test_004_001_execute.lto_priv.127+0xbc>)
 8002d2c:	68a0      	ldr	r0, [r4, #8]
 8002d2e:	fab0 f080 	clz	r0, r0
 8002d32:	0940      	lsrs	r0, r0, #5
 8002d34:	f001 f9fc 	bl	8004130 <_test_assert>
 8002d38:	b120      	cbz	r0, 8002d44 <test_004_001_execute.lto_priv.127+0x34>
 8002d3a:	2300      	movs	r3, #0
 8002d3c:	f383 8811 	msr	BASEPRI, r3
 8002d40:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002d44:	f380 8811 	msr	BASEPRI, r0
    test_assert(MSG_OK == msg, "wrong returned message");
 8002d48:	4921      	ldr	r1, [pc, #132]	; (8002dd0 <test_004_001_execute.lto_priv.127+0xc0>)
 8002d4a:	fab7 f087 	clz	r0, r7
 8002d4e:	0940      	lsrs	r0, r0, #5
 8002d50:	f001 f9ee 	bl	8004130 <_test_assert>
 8002d54:	4607      	mov	r7, r0
 8002d56:	b108      	cbz	r0, 8002d5c <test_004_001_execute.lto_priv.127+0x4c>
 8002d58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8002d5c:	f04f 0902 	mov.w	r9, #2
  {
    chSemSignal(&sem1);
 8002d60:	4620      	mov	r0, r4
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8002d62:	f8c6 9000 	str.w	r9, [r6]
  {
    chSemSignal(&sem1);
 8002d66:	f003 f9cb 	bl	8006100 <chSemSignal>
 8002d6a:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 8002d6e:	68a0      	ldr	r0, [r4, #8]
 8002d70:	4916      	ldr	r1, [pc, #88]	; (8002dcc <test_004_001_execute.lto_priv.127+0xbc>)
 8002d72:	f1a0 0001 	sub.w	r0, r0, #1
 8002d76:	fab0 f080 	clz	r0, r0
 8002d7a:	0940      	lsrs	r0, r0, #5
 8002d7c:	f001 f9d8 	bl	8004130 <_test_assert>
 8002d80:	4680      	mov	r8, r0
 8002d82:	b118      	cbz	r0, 8002d8c <test_004_001_execute.lto_priv.127+0x7c>
 8002d84:	f387 8811 	msr	BASEPRI, r7
 8002d88:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002d8c:	f380 8811 	msr	BASEPRI, r0
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8002d90:	2303      	movs	r3, #3
  {
    chSemReset(&sem1, 2);
 8002d92:	4649      	mov	r1, r9
 8002d94:	4620      	mov	r0, r4
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8002d96:	6033      	str	r3, [r6, #0]
  {
    chSemReset(&sem1, 2);
 8002d98:	f003 fb4a 	bl	8006430 <chSemReset>
 8002d9c:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8002da0:	68a0      	ldr	r0, [r4, #8]
 8002da2:	490a      	ldr	r1, [pc, #40]	; (8002dcc <test_004_001_execute.lto_priv.127+0xbc>)
 8002da4:	f1a0 0002 	sub.w	r0, r0, #2
 8002da8:	fab0 f080 	clz	r0, r0
 8002dac:	0940      	lsrs	r0, r0, #5
 8002dae:	f001 f9bf 	bl	8004130 <_test_assert>
 8002db2:	b910      	cbnz	r0, 8002dba <test_004_001_execute.lto_priv.127+0xaa>
 8002db4:	f380 8811 	msr	BASEPRI, r0
 8002db8:	e7ce      	b.n	8002d58 <test_004_001_execute.lto_priv.127+0x48>
 8002dba:	f388 8811 	msr	BASEPRI, r8
 8002dbe:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8002dc2:	bf00      	nop
 8002dc4:	20001340 	.word	0x20001340
 8002dc8:	20000f5c 	.word	0x20000f5c
 8002dcc:	08008004 	.word	0x08008004
 8002dd0:	08008018 	.word	0x08008018
 8002dd4:	f3af 8000 	nop.w
 8002dd8:	f3af 8000 	nop.w
 8002ddc:	f3af 8000 	nop.w

08002de0 <test_004_001_teardown.lto_priv.126>:
static void test_004_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
 8002de0:	4801      	ldr	r0, [pc, #4]	; (8002de8 <test_004_001_teardown.lto_priv.126+0x8>)
 8002de2:	2100      	movs	r1, #0
 8002de4:	f003 bb24 	b.w	8006430 <chSemReset>
 8002de8:	20001340 	.word	0x20001340
 8002dec:	f3af 8000 	nop.w

08002df0 <test_002_004_execute.lto_priv.122>:
 * - [2.4.3] Raising thread priority above the boosted level.
 * - [2.4.4] Restoring original conditions.
 * .
 */

static void test_002_004_execute(void) {
 8002df0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002df4:	4d2f      	ldr	r5, [pc, #188]	; (8002eb4 <test_002_004_execute.lto_priv.122+0xc4>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8002df6:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8002ec8 <test_002_004_execute.lto_priv.122+0xd8>
 8002dfa:	69ab      	ldr	r3, [r5, #24]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002dfc:	689c      	ldr	r4, [r3, #8]

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8002dfe:	1ca6      	adds	r6, r4, #2

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8002e00:	1c67      	adds	r7, r4, #1

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8002e02:	609e      	str	r6, [r3, #8]

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8002e04:	4638      	mov	r0, r7
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8002e06:	2302      	movs	r3, #2
 8002e08:	f8c8 3000 	str.w	r3, [r8]
  {
    p1 = chThdSetPriority(prio + 1);
 8002e0c:	f003 f930 	bl	8006070 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8002e10:	4929      	ldr	r1, [pc, #164]	; (8002eb8 <test_002_004_execute.lto_priv.122+0xc8>)
 8002e12:	1b00      	subs	r0, r0, r4
 8002e14:	fab0 f080 	clz	r0, r0
 8002e18:	0940      	lsrs	r0, r0, #5
 8002e1a:	f001 f989 	bl	8004130 <_test_assert>
 8002e1e:	b108      	cbz	r0, 8002e24 <test_002_004_execute.lto_priv.122+0x34>
 8002e20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8002e24:	69ab      	ldr	r3, [r5, #24]
 8002e26:	4925      	ldr	r1, [pc, #148]	; (8002ebc <test_002_004_execute.lto_priv.122+0xcc>)
 8002e28:	6898      	ldr	r0, [r3, #8]
 8002e2a:	1a30      	subs	r0, r6, r0
 8002e2c:	fab0 f080 	clz	r0, r0
 8002e30:	0940      	lsrs	r0, r0, #5
 8002e32:	f001 f97d 	bl	8004130 <_test_assert>
 8002e36:	2800      	cmp	r0, #0
 8002e38:	d1f2      	bne.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8002e3a:	69ab      	ldr	r3, [r5, #24]
 8002e3c:	4920      	ldr	r1, [pc, #128]	; (8002ec0 <test_002_004_execute.lto_priv.122+0xd0>)
 8002e3e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8002e40:	1a38      	subs	r0, r7, r0
 8002e42:	fab0 f080 	clz	r0, r0
 8002e46:	0940      	lsrs	r0, r0, #5
 8002e48:	f001 f972 	bl	8004130 <_test_assert>
 8002e4c:	2800      	cmp	r0, #0
 8002e4e:	d1e7      	bne.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
  {
    p1 = chThdSetPriority(prio + 3);
 8002e50:	1ce6      	adds	r6, r4, #3
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8002e52:	2303      	movs	r3, #3
  {
    p1 = chThdSetPriority(prio + 3);
 8002e54:	4630      	mov	r0, r6
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8002e56:	f8c8 3000 	str.w	r3, [r8]
  {
    p1 = chThdSetPriority(prio + 3);
 8002e5a:	f003 f909 	bl	8006070 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8002e5e:	4916      	ldr	r1, [pc, #88]	; (8002eb8 <test_002_004_execute.lto_priv.122+0xc8>)
 8002e60:	1a38      	subs	r0, r7, r0
 8002e62:	fab0 f080 	clz	r0, r0
 8002e66:	0940      	lsrs	r0, r0, #5
 8002e68:	f001 f962 	bl	8004130 <_test_assert>
 8002e6c:	2800      	cmp	r0, #0
 8002e6e:	d1d7      	bne.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8002e70:	69ab      	ldr	r3, [r5, #24]
 8002e72:	4912      	ldr	r1, [pc, #72]	; (8002ebc <test_002_004_execute.lto_priv.122+0xcc>)
 8002e74:	6898      	ldr	r0, [r3, #8]
 8002e76:	1a30      	subs	r0, r6, r0
 8002e78:	fab0 f080 	clz	r0, r0
 8002e7c:	0940      	lsrs	r0, r0, #5
 8002e7e:	f001 f957 	bl	8004130 <_test_assert>
 8002e82:	2800      	cmp	r0, #0
 8002e84:	d1cc      	bne.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8002e86:	69ab      	ldr	r3, [r5, #24]
 8002e88:	490e      	ldr	r1, [pc, #56]	; (8002ec4 <test_002_004_execute.lto_priv.122+0xd4>)
 8002e8a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8002e8c:	1a30      	subs	r0, r6, r0
 8002e8e:	fab0 f080 	clz	r0, r0
 8002e92:	0940      	lsrs	r0, r0, #5
 8002e94:	f001 f94c 	bl	8004130 <_test_assert>
 8002e98:	2800      	cmp	r0, #0
 8002e9a:	d1c1      	bne.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
  }

  /* [2.4.4] Restoring original conditions.*/
  test_set_step(4);
 8002e9c:	2304      	movs	r3, #4
 8002e9e:	f8c8 3000 	str.w	r3, [r8]
 8002ea2:	2320      	movs	r3, #32
 8002ea4:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8002ea8:	69ab      	ldr	r3, [r5, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8002eaa:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8002eac:	63dc      	str	r4, [r3, #60]	; 0x3c
 8002eae:	f380 8811 	msr	BASEPRI, r0
 8002eb2:	e7b5      	b.n	8002e20 <test_002_004_execute.lto_priv.122+0x30>
 8002eb4:	200012a0 	.word	0x200012a0
 8002eb8:	08008030 	.word	0x08008030
 8002ebc:	08008054 	.word	0x08008054
 8002ec0:	08008070 	.word	0x08008070
 8002ec4:	08008098 	.word	0x08008098
 8002ec8:	20000f5c 	.word	0x20000f5c
 8002ecc:	f3af 8000 	nop.w

08002ed0 <test_002_003_execute.lto_priv.121>:
 * - [2.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_002_003_execute(void) {
 8002ed0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002ed4:	4e1c      	ldr	r6, [pc, #112]	; (8002f48 <test_002_003_execute.lto_priv.121+0x78>)
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8002ed6:	4f1d      	ldr	r7, [pc, #116]	; (8002f4c <test_002_003_execute.lto_priv.121+0x7c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002ed8:	69b3      	ldr	r3, [r6, #24]
 8002eda:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8002edc:	1c65      	adds	r5, r4, #1
static void test_002_003_execute(void) {
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8002ede:	2301      	movs	r3, #1
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8002ee0:	4628      	mov	r0, r5
static void test_002_003_execute(void) {
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8002ee2:	603b      	str	r3, [r7, #0]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8002ee4:	f003 f8c4 	bl	8006070 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8002ee8:	4919      	ldr	r1, [pc, #100]	; (8002f50 <test_002_003_execute.lto_priv.121+0x80>)
  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8002eea:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 8002eec:	1b00      	subs	r0, r0, r4
 8002eee:	fab0 f080 	clz	r0, r0
 8002ef2:	0940      	lsrs	r0, r0, #5
 8002ef4:	f001 f91c 	bl	8004130 <_test_assert>
 8002ef8:	b108      	cbz	r0, 8002efe <test_002_003_execute.lto_priv.121+0x2e>
 8002efa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8002efe:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8002f00:	4914      	ldr	r1, [pc, #80]	; (8002f54 <test_002_003_execute.lto_priv.121+0x84>)
 8002f02:	6898      	ldr	r0, [r3, #8]
 8002f04:	1a28      	subs	r0, r5, r0
 8002f06:	fab0 f080 	clz	r0, r0
 8002f0a:	0940      	lsrs	r0, r0, #5
 8002f0c:	f001 f910 	bl	8004130 <_test_assert>
 8002f10:	2800      	cmp	r0, #0
 8002f12:	d1f2      	bne.n	8002efa <test_002_003_execute.lto_priv.121+0x2a>
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8002f14:	2302      	movs	r3, #2
  {
    p1 = chThdSetPriority(p1);
 8002f16:	4640      	mov	r0, r8
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8002f18:	603b      	str	r3, [r7, #0]
  {
    p1 = chThdSetPriority(p1);
 8002f1a:	f003 f8a9 	bl	8006070 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8002f1e:	490c      	ldr	r1, [pc, #48]	; (8002f50 <test_002_003_execute.lto_priv.121+0x80>)
 8002f20:	1a28      	subs	r0, r5, r0
 8002f22:	fab0 f080 	clz	r0, r0
 8002f26:	0940      	lsrs	r0, r0, #5
 8002f28:	f001 f902 	bl	8004130 <_test_assert>
 8002f2c:	2800      	cmp	r0, #0
 8002f2e:	d1e4      	bne.n	8002efa <test_002_003_execute.lto_priv.121+0x2a>
 8002f30:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8002f32:	4908      	ldr	r1, [pc, #32]	; (8002f54 <test_002_003_execute.lto_priv.121+0x84>)
 8002f34:	6898      	ldr	r0, [r3, #8]
 8002f36:	1a20      	subs	r0, r4, r0
  }
}
 8002f38:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
     check is performed.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(p1);
    test_assert(p1 == prio + 1, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8002f3c:	fab0 f080 	clz	r0, r0
 8002f40:	0940      	lsrs	r0, r0, #5
 8002f42:	f001 b8f5 	b.w	8004130 <_test_assert>
 8002f46:	bf00      	nop
 8002f48:	200012a0 	.word	0x200012a0
 8002f4c:	20000f5c 	.word	0x20000f5c
 8002f50:	08008030 	.word	0x08008030
 8002f54:	08008054 	.word	0x08008054
 8002f58:	f3af 8000 	nop.w
 8002f5c:	f3af 8000 	nop.w

08002f60 <test_001_002_execute.lto_priv.116>:
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 8002f60:	b510      	push	{r4, lr}
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8002f62:	4c31      	ldr	r4, [pc, #196]	; (8003028 <test_001_002_execute.lto_priv.116+0xc8>)
 8002f64:	2301      	movs	r3, #1
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 8002f66:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8002f68:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002f6a:	f3ef 8311 	mrs	r3, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8002f6e:	b91b      	cbnz	r3, 8002f78 <test_001_002_execute.lto_priv.116+0x18>
 8002f70:	f003 fb96 	bl	80066a0 <chSysGetStatusAndLockX.part.1.lto_priv.114>
 8002f74:	f003 fb84 	bl	8006680 <chSysRestoreStatusX.part.2.lto_priv.113>
    chSysRestoreStatusX(sts);
  }

  /* [1.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 8002f78:	2302      	movs	r3, #2
 8002f7a:	6023      	str	r3, [r4, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002f7c:	2320      	movs	r3, #32
 8002f7e:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002f82:	f3ef 8311 	mrs	r3, BASEPRI
 8002f86:	b91b      	cbnz	r3, 8002f90 <test_001_002_execute.lto_priv.116+0x30>
 8002f88:	f003 fb8a 	bl	80066a0 <chSysGetStatusAndLockX.part.1.lto_priv.114>
 8002f8c:	f003 fb78 	bl	8006680 <chSysRestoreStatusX.part.2.lto_priv.113>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002f90:	2300      	movs	r3, #0
 8002f92:	f383 8811 	msr	BASEPRI, r3
    chSysRestoreStatusX(sts);
    chSysUnlock();
  }

  /* [1.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 8002f96:	2303      	movs	r3, #3
 8002f98:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002f9a:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8002f9e:	b913      	cbnz	r3, 8002fa6 <test_001_002_execute.lto_priv.116+0x46>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002fa0:	2320      	movs	r3, #32
 8002fa2:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002fa6:	f3ef 8311 	mrs	r3, BASEPRI
 8002faa:	b913      	cbnz	r3, 8002fb2 <test_001_002_execute.lto_priv.116+0x52>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002fac:	2320      	movs	r3, #32
 8002fae:	f383 8811 	msr	BASEPRI, r3
 8002fb2:	2300      	movs	r3, #0
 8002fb4:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalLock();
    chSysUnlock();
  }

  /* [1.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8002fb8:	2204      	movs	r2, #4
 8002fba:	6022      	str	r2, [r4, #0]
 8002fbc:	2220      	movs	r2, #32
 8002fbe:	f382 8811 	msr	BASEPRI, r2
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002fc2:	f3ef 8211 	mrs	r2, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8002fc6:	b10a      	cbz	r2, 8002fcc <test_001_002_execute.lto_priv.116+0x6c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002fc8:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8002fcc:	f3ef 8311 	mrs	r3, BASEPRI
 8002fd0:	b113      	cbz	r3, 8002fd8 <test_001_002_execute.lto_priv.116+0x78>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8002fd2:	2300      	movs	r3, #0
 8002fd4:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalUnlock();
    chSysUnconditionalUnlock();
  }

  /* [1.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8002fd8:	2205      	movs	r2, #5
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8002fda:	2300      	movs	r3, #0
 8002fdc:	9304      	str	r3, [sp, #16]
 8002fde:	6022      	str	r2, [r4, #0]
 8002fe0:	2320      	movs	r3, #32
 8002fe2:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8002fe6:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8002fe8:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8002fea:	b113      	cbz	r3, 8002ff2 <test_001_002_execute.lto_priv.116+0x92>
    chVTDoResetI(vtp);
 8002fec:	4620      	mov	r0, r4
 8002fee:	f003 fa5f 	bl	80064b0 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8002ff2:	4620      	mov	r0, r4
 8002ff4:	2101      	movs	r1, #1
 8002ff6:	4a0d      	ldr	r2, [pc, #52]	; (800302c <test_001_002_execute.lto_priv.116+0xcc>)
 8002ff8:	2300      	movs	r3, #0
 8002ffa:	f003 fa91 	bl	8006520 <chVTDoSetI>
 8002ffe:	2400      	movs	r4, #0
 8003000:	f384 8811 	msr	BASEPRI, r4
  {
    chVTObjectInit(&vt);
    chVTSet(&vt, 1, vtcb, NULL);
    chThdSleep(10);
 8003004:	200a      	movs	r0, #10
 8003006:	f003 fb2b 	bl	8006660 <chThdSleep>
 800300a:	2320      	movs	r3, #32
 800300c:	f383 8811 	msr	BASEPRI, r3
 8003010:	9804      	ldr	r0, [sp, #16]
 8003012:	f384 8811 	msr	BASEPRI, r4

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8003016:	4906      	ldr	r1, [pc, #24]	; (8003030 <test_001_002_execute.lto_priv.116+0xd0>)
 8003018:	fab0 f080 	clz	r0, r0
 800301c:	0940      	lsrs	r0, r0, #5
 800301e:	f001 f887 	bl	8004130 <_test_assert>
  }
}
 8003022:	b006      	add	sp, #24
 8003024:	bd10      	pop	{r4, pc}
 8003026:	bf00      	nop
 8003028:	20000f5c 	.word	0x20000f5c
 800302c:	08003041 	.word	0x08003041
 8003030:	080080b8 	.word	0x080080b8
 8003034:	f3af 8000 	nop.w
 8003038:	f3af 8000 	nop.w
 800303c:	f3af 8000 	nop.w

08003040 <vtcb>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 8003040:	b508      	push	{r3, lr}
 8003042:	2320      	movs	r3, #32
 8003044:	f383 8811 	msr	BASEPRI, r3
 8003048:	2200      	movs	r2, #0
 800304a:	f382 8811 	msr	BASEPRI, r2
 800304e:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003052:	f3ef 8311 	mrs	r3, BASEPRI
 8003056:	b91b      	cbnz	r3, 8003060 <vtcb+0x20>
 8003058:	f003 fb22 	bl	80066a0 <chSysGetStatusAndLockX.part.1.lto_priv.114>
 800305c:	f003 fb10 	bl	8006680 <chSysRestoreStatusX.part.2.lto_priv.113>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003060:	2300      	movs	r3, #0
 8003062:	f383 8811 	msr	BASEPRI, r3
 8003066:	bd08      	pop	{r3, pc}
 8003068:	f3af 8000 	nop.w
 800306c:	f3af 8000 	nop.w

08003070 <test_001_001_execute.lto_priv.115>:
 * - [1.1.3] Testing Registry List integrity.
 * - [1.1.4] Testing Port-defined integrity.
 * .
 */

static void test_001_001_execute(void) {
 8003070:	b570      	push	{r4, r5, r6, lr}
  bool result;

  /* [1.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 8003072:	4d24      	ldr	r5, [pc, #144]	; (8003104 <test_001_001_execute.lto_priv.115+0x94>)
 8003074:	2001      	movs	r0, #1
 8003076:	6028      	str	r0, [r5, #0]
 8003078:	2420      	movs	r4, #32
 800307a:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 800307e:	f003 fb1f 	bl	80066c0 <chSysIntegrityCheckI>
 8003082:	2300      	movs	r3, #0
 8003084:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
 8003088:	f080 0001 	eor.w	r0, r0, #1
 800308c:	b2c0      	uxtb	r0, r0
 800308e:	491e      	ldr	r1, [pc, #120]	; (8003108 <test_001_001_execute.lto_priv.115+0x98>)
 8003090:	f001 f84e 	bl	8004130 <_test_assert>
 8003094:	4606      	mov	r6, r0
 8003096:	b100      	cbz	r0, 800309a <test_001_001_execute.lto_priv.115+0x2a>
 8003098:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [1.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 800309a:	2002      	movs	r0, #2
 800309c:	6028      	str	r0, [r5, #0]
 800309e:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80030a2:	f003 fb0d 	bl	80066c0 <chSysIntegrityCheckI>
 80030a6:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "virtual timers list check failed");
 80030aa:	f080 0001 	eor.w	r0, r0, #1
 80030ae:	b2c0      	uxtb	r0, r0
 80030b0:	4916      	ldr	r1, [pc, #88]	; (800310c <test_001_001_execute.lto_priv.115+0x9c>)
 80030b2:	f001 f83d 	bl	8004130 <_test_assert>
 80030b6:	4606      	mov	r6, r0
 80030b8:	2800      	cmp	r0, #0
 80030ba:	d1ed      	bne.n	8003098 <test_001_001_execute.lto_priv.115+0x28>
  }

  /* [1.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 80030bc:	2303      	movs	r3, #3
 80030be:	602b      	str	r3, [r5, #0]
 80030c0:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 80030c4:	2004      	movs	r0, #4
 80030c6:	f003 fafb 	bl	80066c0 <chSysIntegrityCheckI>
 80030ca:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "registry list check failed");
 80030ce:	f080 0001 	eor.w	r0, r0, #1
 80030d2:	b2c0      	uxtb	r0, r0
 80030d4:	490e      	ldr	r1, [pc, #56]	; (8003110 <test_001_001_execute.lto_priv.115+0xa0>)
 80030d6:	f001 f82b 	bl	8004130 <_test_assert>
 80030da:	4606      	mov	r6, r0
 80030dc:	2800      	cmp	r0, #0
 80030de:	d1db      	bne.n	8003098 <test_001_001_execute.lto_priv.115+0x28>
  }

  /* [1.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 80030e0:	2304      	movs	r3, #4
 80030e2:	602b      	str	r3, [r5, #0]
 80030e4:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 80030e8:	2008      	movs	r0, #8
 80030ea:	f003 fae9 	bl	80066c0 <chSysIntegrityCheckI>
 80030ee:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 80030f2:	f080 0001 	eor.w	r0, r0, #1
 80030f6:	b2c0      	uxtb	r0, r0
 80030f8:	4906      	ldr	r1, [pc, #24]	; (8003114 <test_001_001_execute.lto_priv.115+0xa4>)
  }
}
 80030fa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_set_step(4);
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 80030fe:	f001 b817 	b.w	8004130 <_test_assert>
 8003102:	bf00      	nop
 8003104:	20000f5c 	.word	0x20000f5c
 8003108:	080080cc 	.word	0x080080cc
 800310c:	080080e4 	.word	0x080080e4
 8003110:	08008108 	.word	0x08008108
 8003114:	08008124 	.word	0x08008124
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8003120:	b508      	push	{r3, lr}

  chThdSleep(1);
 8003122:	2001      	movs	r0, #1
 8003124:	f003 fa9c 	bl	8006660 <chThdSleep>
 8003128:	2320      	movs	r3, #32
 800312a:	f383 8811 	msr	BASEPRI, r3
 800312e:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003132:	2300      	movs	r3, #0
 8003134:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8003136:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 800313a:	bd08      	pop	{r3, pc}
 800313c:	f3af 8000 	nop.w

08003140 <test_wait_threads>:
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8003140:	b570      	push	{r4, r5, r6, lr}
 8003142:	4c07      	ldr	r4, [pc, #28]	; (8003160 <test_wait_threads+0x20>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8003144:	2600      	movs	r6, #0
 8003146:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 800314a:	f854 0b04 	ldr.w	r0, [r4], #4
 800314e:	b118      	cbz	r0, 8003158 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8003150:	f003 f836 	bl	80061c0 <chThdWait>
      threads[i] = NULL;
 8003154:	f844 6c04 	str.w	r6, [r4, #-4]
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8003158:	42ac      	cmp	r4, r5
 800315a:	d1f6      	bne.n	800314a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800315c:	bd70      	pop	{r4, r5, r6, pc}
 800315e:	bf00      	nop
 8003160:	20000f60 	.word	0x20000f60
 8003164:	f3af 8000 	nop.w
 8003168:	f3af 8000 	nop.w
 800316c:	f3af 8000 	nop.w

08003170 <test_004_004_execute.lto_priv.133>:

static void test_004_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_004_execute(void) {
 8003170:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003172:	4b23      	ldr	r3, [pc, #140]	; (8003200 <test_004_004_execute.lto_priv.133+0x90>)

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8003174:	4c23      	ldr	r4, [pc, #140]	; (8003204 <test_004_004_execute.lto_priv.133+0x94>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003176:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8003178:	4a23      	ldr	r2, [pc, #140]	; (8003208 <test_004_004_execute.lto_priv.133+0x98>)
 800317a:	6899      	ldr	r1, [r3, #8]
 800317c:	4823      	ldr	r0, [pc, #140]	; (800320c <test_004_004_execute.lto_priv.133+0x9c>)
 800317e:	4b24      	ldr	r3, [pc, #144]	; (8003210 <test_004_004_execute.lto_priv.133+0xa0>)
 8003180:	3101      	adds	r1, #1
}

static void test_004_004_execute(void) {

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8003182:	2501      	movs	r5, #1
 8003184:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8003186:	f003 fff3 	bl	8007170 <chThdCreateStatic.constprop.69>
 800318a:	4b22      	ldr	r3, [pc, #136]	; (8003214 <test_004_004_execute.lto_priv.133+0xa4>)
  }

  /* [4.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 800318c:	2502      	movs	r5, #2
static void test_004_004_execute(void) {

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800318e:	6018      	str	r0, [r3, #0]
  }

  /* [4.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 8003190:	6025      	str	r5, [r4, #0]
 8003192:	2320      	movs	r3, #32
 8003194:	f383 8811 	msr	BASEPRI, r3
 8003198:	4c1f      	ldr	r4, [pc, #124]	; (8003218 <test_004_004_execute.lto_priv.133+0xa8>)
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 800319a:	2700      	movs	r7, #0
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
 800319c:	4626      	mov	r6, r4
 800319e:	e002      	b.n	80031a6 <test_004_004_execute.lto_priv.133+0x36>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80031a0:	2d01      	cmp	r5, #1
 80031a2:	d00e      	beq.n	80031c2 <test_004_004_execute.lto_priv.133+0x52>
 80031a4:	2501      	movs	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
 80031a6:	68a3      	ldr	r3, [r4, #8]
 80031a8:	3301      	adds	r3, #1
 80031aa:	2b00      	cmp	r3, #0
 80031ac:	60a3      	str	r3, [r4, #8]
 80031ae:	dcf7      	bgt.n	80031a0 <test_004_004_execute.lto_priv.133+0x30>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80031b0:	6830      	ldr	r0, [r6, #0]

  tqp->next             = tp->queue.next;
 80031b2:	6803      	ldr	r3, [r0, #0]
 80031b4:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80031b6:	605e      	str	r6, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 80031b8:	f003 f822 	bl	8006200 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80031bc:	2d01      	cmp	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 80031be:	6247      	str	r7, [r0, #36]	; 0x24
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80031c0:	d1f0      	bne.n	80031a4 <test_004_004_execute.lto_priv.133+0x34>
  {
    chSysLock();
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
 80031c2:	f002 ff2d 	bl	8006020 <chSchRescheduleS>
 80031c6:	2500      	movs	r5, #0
 80031c8:	f385 8811 	msr	BASEPRI, r5
    chSysUnlock();
    test_wait_threads();
 80031cc:	f7ff ffb8 	bl	8003140 <test_wait_threads>
 80031d0:	2320      	movs	r3, #32
 80031d2:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 80031d6:	68a0      	ldr	r0, [r4, #8]
 80031d8:	4910      	ldr	r1, [pc, #64]	; (800321c <test_004_004_execute.lto_priv.133+0xac>)
 80031da:	f1a0 0001 	sub.w	r0, r0, #1
 80031de:	fab0 f080 	clz	r0, r0
 80031e2:	0940      	lsrs	r0, r0, #5
 80031e4:	f000 ffa4 	bl	8004130 <_test_assert>
 80031e8:	b110      	cbz	r0, 80031f0 <test_004_004_execute.lto_priv.133+0x80>
 80031ea:	f385 8811 	msr	BASEPRI, r5
 80031ee:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80031f0:	f380 8811 	msr	BASEPRI, r0
    test_assert_sequence("A", "invalid sequence");
 80031f4:	4806      	ldr	r0, [pc, #24]	; (8003210 <test_004_004_execute.lto_priv.133+0xa0>)
 80031f6:	490a      	ldr	r1, [pc, #40]	; (8003220 <test_004_004_execute.lto_priv.133+0xb0>)
  }
}
 80031f8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
    test_assert_sequence("A", "invalid sequence");
 80031fc:	f000 bf70 	b.w	80040e0 <_test_assert_sequence>
 8003200:	200012a0 	.word	0x200012a0
 8003204:	20000f5c 	.word	0x20000f5c
 8003208:	08002b71 	.word	0x08002b71
 800320c:	200008b0 	.word	0x200008b0
 8003210:	08007a10 	.word	0x08007a10
 8003214:	20000f60 	.word	0x20000f60
 8003218:	20001340 	.word	0x20001340
 800321c:	0800813c 	.word	0x0800813c
 8003220:	0800792c 	.word	0x0800792c
 8003224:	f3af 8000 	nop.w
 8003228:	f3af 8000 	nop.w
 800322c:	f3af 8000 	nop.w

08003230 <test_004_003_execute.lto_priv.131>:

static void test_004_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_003_execute(void) {
 8003230:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [4.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8003232:	4d53      	ldr	r5, [pc, #332]	; (8003380 <test_004_003_execute.lto_priv.131+0x150>)
 8003234:	2301      	movs	r3, #1
 8003236:	602b      	str	r3, [r5, #0]
 8003238:	2620      	movs	r6, #32
 800323a:	f386 8811 	msr	BASEPRI, r6
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 800323e:	4c51      	ldr	r4, [pc, #324]	; (8003384 <test_004_003_execute.lto_priv.131+0x154>)
 8003240:	2100      	movs	r1, #0
 8003242:	4620      	mov	r0, r4
 8003244:	f003 f9d4 	bl	80065f0 <chSemWaitTimeoutS>
 8003248:	2300      	movs	r3, #0
 800324a:	f383 8811 	msr	BASEPRI, r3
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800324e:	494e      	ldr	r1, [pc, #312]	; (8003388 <test_004_003_execute.lto_priv.131+0x158>)
 8003250:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8003254:	fab0 f080 	clz	r0, r0
 8003258:	0940      	lsrs	r0, r0, #5
 800325a:	f000 ff69 	bl	8004130 <_test_assert>
 800325e:	b100      	cbz	r0, 8003262 <test_004_003_execute.lto_priv.131+0x32>
 8003260:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8003262:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003264:	4949      	ldr	r1, [pc, #292]	; (800338c <test_004_003_execute.lto_priv.131+0x15c>)
 8003266:	1b00      	subs	r0, r0, r4
 8003268:	fab0 f080 	clz	r0, r0
 800326c:	0940      	lsrs	r0, r0, #5
 800326e:	f000 ff5f 	bl	8004130 <_test_assert>
 8003272:	2800      	cmp	r0, #0
 8003274:	d1f4      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 8003276:	68a0      	ldr	r0, [r4, #8]
 8003278:	4945      	ldr	r1, [pc, #276]	; (8003390 <test_004_003_execute.lto_priv.131+0x160>)
 800327a:	fab0 f080 	clz	r0, r0
 800327e:	0940      	lsrs	r0, r0, #5
 8003280:	f000 ff56 	bl	8004130 <_test_assert>
 8003284:	4607      	mov	r7, r0
 8003286:	2800      	cmp	r0, #0
 8003288:	d1ea      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800328a:	4b42      	ldr	r3, [pc, #264]	; (8003394 <test_004_003_execute.lto_priv.131+0x164>)
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800328c:	4a42      	ldr	r2, [pc, #264]	; (8003398 <test_004_003_execute.lto_priv.131+0x168>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800328e:	699b      	ldr	r3, [r3, #24]
 8003290:	4842      	ldr	r0, [pc, #264]	; (800339c <test_004_003_execute.lto_priv.131+0x16c>)
 8003292:	6899      	ldr	r1, [r3, #8]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8003294:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8003298:	463b      	mov	r3, r7
 800329a:	3901      	subs	r1, #1
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 800329c:	f8c5 e000 	str.w	lr, [r5]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80032a0:	f003 ff66 	bl	8007170 <chThdCreateStatic.constprop.69>
 80032a4:	4b3e      	ldr	r3, [pc, #248]	; (80033a0 <test_004_003_execute.lto_priv.131+0x170>)
 80032a6:	6018      	str	r0, [r3, #0]
 80032a8:	f386 8811 	msr	BASEPRI, r6
 80032ac:	f241 3188 	movw	r1, #5000	; 0x1388
 80032b0:	4620      	mov	r0, r4
 80032b2:	f003 f99d 	bl	80065f0 <chSemWaitTimeoutS>
 80032b6:	4606      	mov	r6, r0
 80032b8:	f387 8811 	msr	BASEPRI, r7
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_wait_threads();
 80032bc:	f7ff ff40 	bl	8003140 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 80032c0:	fab6 f086 	clz	r0, r6
 80032c4:	4930      	ldr	r1, [pc, #192]	; (8003388 <test_004_003_execute.lto_priv.131+0x158>)
 80032c6:	0940      	lsrs	r0, r0, #5
 80032c8:	f000 ff32 	bl	8004130 <_test_assert>
 80032cc:	2800      	cmp	r0, #0
 80032ce:	d1c7      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
 80032d0:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80032d2:	492e      	ldr	r1, [pc, #184]	; (800338c <test_004_003_execute.lto_priv.131+0x15c>)
 80032d4:	1b00      	subs	r0, r0, r4
 80032d6:	fab0 f080 	clz	r0, r0
 80032da:	0940      	lsrs	r0, r0, #5
 80032dc:	f000 ff28 	bl	8004130 <_test_assert>
 80032e0:	2800      	cmp	r0, #0
 80032e2:	d1bd      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 80032e4:	68a0      	ldr	r0, [r4, #8]
 80032e6:	492a      	ldr	r1, [pc, #168]	; (8003390 <test_004_003_execute.lto_priv.131+0x160>)
 80032e8:	fab0 f080 	clz	r0, r0
 80032ec:	0940      	lsrs	r0, r0, #5
 80032ee:	f000 ff1f 	bl	8004130 <_test_assert>
 80032f2:	2800      	cmp	r0, #0
 80032f4:	d1b4      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
  }

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
 80032f6:	2303      	movs	r3, #3
 80032f8:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 80032fa:	f7ff ff11 	bl	8003120 <test_wait_tick>
 80032fe:	2541      	movs	r5, #65	; 0x41
 8003300:	4606      	mov	r6, r0
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
 8003302:	4628      	mov	r0, r5
 8003304:	f000 fd24 	bl	8003d50 <test_emit_token>
 8003308:	2320      	movs	r3, #32
 800330a:	f383 8811 	msr	BASEPRI, r3
 800330e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8003312:	481c      	ldr	r0, [pc, #112]	; (8003384 <test_004_003_execute.lto_priv.131+0x154>)
 8003314:	f003 f96c 	bl	80065f0 <chSemWaitTimeoutS>
 8003318:	2300      	movs	r3, #0
 800331a:	f383 8811 	msr	BASEPRI, r3
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 800331e:	491a      	ldr	r1, [pc, #104]	; (8003388 <test_004_003_execute.lto_priv.131+0x158>)
 8003320:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8003324:	fab0 f080 	clz	r0, r0
 8003328:	0940      	lsrs	r0, r0, #5
 800332a:	f000 ff01 	bl	8004130 <_test_assert>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800332e:	4917      	ldr	r1, [pc, #92]	; (800338c <test_004_003_execute.lto_priv.131+0x15c>)
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8003330:	2800      	cmp	r0, #0
 8003332:	d195      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
 8003334:	6820      	ldr	r0, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003336:	1b00      	subs	r0, r0, r4
 8003338:	fab0 f080 	clz	r0, r0
 800333c:	0940      	lsrs	r0, r0, #5
 800333e:	f000 fef7 	bl	8004130 <_test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
 8003342:	4913      	ldr	r1, [pc, #76]	; (8003390 <test_004_003_execute.lto_priv.131+0x160>)
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8003344:	2800      	cmp	r0, #0
 8003346:	d18b      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>
      test_assert(sem1.cnt == 0, "counter not zero");
 8003348:	68a0      	ldr	r0, [r4, #8]
 800334a:	fab0 f080 	clz	r0, r0
 800334e:	0940      	lsrs	r0, r0, #5
 8003350:	f000 feee 	bl	8004130 <_test_assert>
 8003354:	3501      	adds	r5, #1
 8003356:	b2ed      	uxtb	r5, r5
 8003358:	2800      	cmp	r0, #0
 800335a:	d181      	bne.n	8003260 <test_004_003_execute.lto_priv.131+0x30>

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
 800335c:	2d46      	cmp	r5, #70	; 0x46
 800335e:	d1d0      	bne.n	8003302 <test_004_003_execute.lto_priv.131+0xd2>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8003360:	4810      	ldr	r0, [pc, #64]	; (80033a4 <test_004_003_execute.lto_priv.131+0x174>)
 8003362:	4911      	ldr	r1, [pc, #68]	; (80033a8 <test_004_003_execute.lto_priv.131+0x178>)
 8003364:	f000 febc 	bl	80040e0 <_test_assert_sequence>
 8003368:	2800      	cmp	r0, #0
 800336a:	f47f af79 	bne.w	8003260 <test_004_003_execute.lto_priv.131+0x30>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800336e:	f606 10c4 	addw	r0, r6, #2500	; 0x9c4
 8003372:	f606 11d8 	addw	r1, r6, #2520	; 0x9d8
                            "out of time window");
  }
}
 8003376:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800337a:	f004 ba11 	b.w	80077a0 <_test_assert_time_window.constprop.3>
 800337e:	bf00      	nop
 8003380:	20000f5c 	.word	0x20000f5c
 8003384:	20001340 	.word	0x20001340
 8003388:	080079ac 	.word	0x080079ac
 800338c:	0800814c 	.word	0x0800814c
 8003390:	0800815c 	.word	0x0800815c
 8003394:	200012a0 	.word	0x200012a0
 8003398:	08002c01 	.word	0x08002c01
 800339c:	200008b0 	.word	0x200008b0
 80033a0:	20000f60 	.word	0x20000f60
 80033a4:	08008170 	.word	0x08008170
 80033a8:	0800792c 	.word	0x0800792c
 80033ac:	f3af 8000 	nop.w

080033b0 <test_004_002_execute.lto_priv.129>:

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_002_execute(void) {
 80033b0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80033b4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 8003498 <test_004_002_execute.lto_priv.129+0xe8>
  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033b8:	4f2c      	ldr	r7, [pc, #176]	; (800346c <test_004_002_execute.lto_priv.129+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80033ba:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80033be:	4e2c      	ldr	r6, [pc, #176]	; (8003470 <test_004_002_execute.lto_priv.129+0xc0>)
 80033c0:	6899      	ldr	r1, [r3, #8]
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80033c2:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 800349c <test_004_002_execute.lto_priv.129+0xec>
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033c6:	4b2b      	ldr	r3, [pc, #172]	; (8003474 <test_004_002_execute.lto_priv.129+0xc4>)
 80033c8:	4d2b      	ldr	r5, [pc, #172]	; (8003478 <test_004_002_execute.lto_priv.129+0xc8>)

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 80033ca:	4c2c      	ldr	r4, [pc, #176]	; (800347c <test_004_002_execute.lto_priv.129+0xcc>)
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80033cc:	f04f 0e01 	mov.w	lr, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033d0:	4632      	mov	r2, r6
 80033d2:	3105      	adds	r1, #5
 80033d4:	4638      	mov	r0, r7
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80033d6:	f8c9 e000 	str.w	lr, [r9]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80033da:	f003 fec9 	bl	8007170 <chThdCreateStatic.constprop.69>
 80033de:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80033e2:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 80033e4:	6899      	ldr	r1, [r3, #8]
 80033e6:	4b26      	ldr	r3, [pc, #152]	; (8003480 <test_004_002_execute.lto_priv.129+0xd0>)
 80033e8:	4632      	mov	r2, r6
 80033ea:	3101      	adds	r1, #1
 80033ec:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 80033f0:	f003 febe 	bl	8007170 <chThdCreateStatic.constprop.69>
 80033f4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80033f8:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 80033fa:	6899      	ldr	r1, [r3, #8]
 80033fc:	4b21      	ldr	r3, [pc, #132]	; (8003484 <test_004_002_execute.lto_priv.129+0xd4>)
 80033fe:	4632      	mov	r2, r6
 8003400:	3103      	adds	r1, #3
 8003402:	f507 7024 	add.w	r0, r7, #656	; 0x290
 8003406:	f003 feb3 	bl	8007170 <chThdCreateStatic.constprop.69>
 800340a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800340e:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8003410:	6899      	ldr	r1, [r3, #8]
 8003412:	4b1d      	ldr	r3, [pc, #116]	; (8003488 <test_004_002_execute.lto_priv.129+0xd8>)
 8003414:	4632      	mov	r2, r6
 8003416:	3104      	adds	r1, #4
 8003418:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 800341c:	f003 fea8 	bl	8007170 <chThdCreateStatic.constprop.69>
 8003420:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8003424:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8003426:	6899      	ldr	r1, [r3, #8]
 8003428:	4b18      	ldr	r3, [pc, #96]	; (800348c <test_004_002_execute.lto_priv.129+0xdc>)
 800342a:	3102      	adds	r1, #2
 800342c:	4632      	mov	r2, r6
 800342e:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 8003432:	f003 fe9d 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8003436:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8003438:	6128      	str	r0, [r5, #16]

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 800343a:	4620      	mov	r0, r4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 800343c:	f8c9 3000 	str.w	r3, [r9]
  {
    chSemSignal(&sem1);
 8003440:	f002 fe5e 	bl	8006100 <chSemSignal>
    chSemSignal(&sem1);
 8003444:	4620      	mov	r0, r4
 8003446:	f002 fe5b 	bl	8006100 <chSemSignal>
    chSemSignal(&sem1);
 800344a:	4620      	mov	r0, r4
 800344c:	f002 fe58 	bl	8006100 <chSemSignal>
    chSemSignal(&sem1);
 8003450:	4620      	mov	r0, r4
 8003452:	f002 fe55 	bl	8006100 <chSemSignal>
    chSemSignal(&sem1);
 8003456:	4620      	mov	r0, r4
 8003458:	f002 fe52 	bl	8006100 <chSemSignal>
    test_wait_threads();
 800345c:	f7ff fe70 	bl	8003140 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 8003460:	480b      	ldr	r0, [pc, #44]	; (8003490 <test_004_002_execute.lto_priv.129+0xe0>)
 8003462:	490c      	ldr	r1, [pc, #48]	; (8003494 <test_004_002_execute.lto_priv.129+0xe4>)
#endif
  }
}
 8003464:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    chSemSignal(&sem1);
    test_wait_threads();
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 8003468:	f000 be3a 	b.w	80040e0 <_test_assert_sequence>
 800346c:	200008b0 	.word	0x200008b0
 8003470:	08002b71 	.word	0x08002b71
 8003474:	08007a10 	.word	0x08007a10
 8003478:	20000f60 	.word	0x20000f60
 800347c:	20001340 	.word	0x20001340
 8003480:	08008178 	.word	0x08008178
 8003484:	0800817c 	.word	0x0800817c
 8003488:	08007f18 	.word	0x08007f18
 800348c:	08008174 	.word	0x08008174
 8003490:	08008170 	.word	0x08008170
 8003494:	0800792c 	.word	0x0800792c
 8003498:	200012a0 	.word	0x200012a0
 800349c:	20000f5c 	.word	0x20000f5c

080034a0 <test_003_001_execute.lto_priv.124>:

static void test_003_001_setup(void) {
  tr1 = NULL;
}

static void test_003_001_execute(void) {
 80034a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80034a4:	4d30      	ldr	r5, [pc, #192]	; (8003568 <test_003_001_execute.lto_priv.124+0xc8>)
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80034a6:	4f31      	ldr	r7, [pc, #196]	; (800356c <test_003_001_execute.lto_priv.124+0xcc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80034a8:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80034aa:	4a31      	ldr	r2, [pc, #196]	; (8003570 <test_003_001_execute.lto_priv.124+0xd0>)
 80034ac:	6899      	ldr	r1, [r3, #8]
 80034ae:	4831      	ldr	r0, [pc, #196]	; (8003574 <test_003_001_execute.lto_priv.124+0xd4>)
 80034b0:	4b31      	ldr	r3, [pc, #196]	; (8003578 <test_003_001_execute.lto_priv.124+0xd8>)
 80034b2:	3901      	subs	r1, #1
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 80034b4:	2401      	movs	r4, #1
 80034b6:	603c      	str	r4, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 80034b8:	f003 fe5a 	bl	8007170 <chThdCreateStatic.constprop.69>
 80034bc:	4b2f      	ldr	r3, [pc, #188]	; (800357c <test_003_001_execute.lto_priv.124+0xdc>)
 80034be:	2620      	movs	r6, #32
 80034c0:	6018      	str	r0, [r3, #0]
 80034c2:	f386 8811 	msr	BASEPRI, r6
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80034c6:	69ab      	ldr	r3, [r5, #24]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80034c8:	4c2d      	ldr	r4, [pc, #180]	; (8003580 <test_003_001_execute.lto_priv.124+0xe0>)
  tp->u.wttrp = trp;
 80034ca:	625c      	str	r4, [r3, #36]	; 0x24
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80034cc:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80034ce:	6023      	str	r3, [r4, #0]
 80034d0:	f002 fe36 	bl	8006140 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 80034d4:	69aa      	ldr	r2, [r5, #24]
 80034d6:	2300      	movs	r3, #0
 80034d8:	f8d2 8024 	ldr.w	r8, [r2, #36]	; 0x24
 80034dc:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 80034e0:	4928      	ldr	r1, [pc, #160]	; (8003584 <test_003_001_execute.lto_priv.124+0xe4>)
 80034e2:	6820      	ldr	r0, [r4, #0]
 80034e4:	fab0 f080 	clz	r0, r0
 80034e8:	0940      	lsrs	r0, r0, #5
 80034ea:	f000 fe21 	bl	8004130 <_test_assert>
 80034ee:	b108      	cbz	r0, 80034f4 <test_003_001_execute.lto_priv.124+0x54>
 80034f0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
 80034f4:	fab8 f088 	clz	r0, r8
 80034f8:	4923      	ldr	r1, [pc, #140]	; (8003588 <test_003_001_execute.lto_priv.124+0xe8>)
 80034fa:	0940      	lsrs	r0, r0, #5
 80034fc:	f000 fe18 	bl	8004130 <_test_assert>
 8003500:	4680      	mov	r8, r0
 8003502:	2800      	cmp	r0, #0
 8003504:	d1f4      	bne.n	80034f0 <test_003_001_execute.lto_priv.124+0x50>
    test_wait_threads();
 8003506:	f7ff fe1b 	bl	8003140 <test_wait_threads>
  }

  /* [3.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 800350a:	2302      	movs	r3, #2
 800350c:	603b      	str	r3, [r7, #0]
 800350e:	f386 8811 	msr	BASEPRI, r6
 8003512:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003516:	69ab      	ldr	r3, [r5, #24]
 8003518:	6a55      	ldr	r5, [r2, #36]	; 0x24
  tp->u.wttrp = trp;
 800351a:	625c      	str	r4, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800351c:	f242 7110 	movw	r1, #10000	; 0x2710
 8003520:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003522:	6023      	str	r3, [r4, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8003524:	f003 f83c 	bl	80065a0 <chSchGoSleepTimeoutS>
 8003528:	4606      	mov	r6, r0
 800352a:	f388 8811 	msr	BASEPRI, r8
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
 800352e:	f505 501c 	add.w	r0, r5, #9984	; 0x2700
 8003532:	4601      	mov	r1, r0
 8003534:	3113      	adds	r1, #19
 8003536:	3010      	adds	r0, #16
 8003538:	f004 f932 	bl	80077a0 <_test_assert_time_window.constprop.3>
 800353c:	2800      	cmp	r0, #0
 800353e:	d1d7      	bne.n	80034f0 <test_003_001_execute.lto_priv.124+0x50>
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8003540:	6820      	ldr	r0, [r4, #0]
 8003542:	4910      	ldr	r1, [pc, #64]	; (8003584 <test_003_001_execute.lto_priv.124+0xe4>)
 8003544:	fab0 f080 	clz	r0, r0
 8003548:	0940      	lsrs	r0, r0, #5
 800354a:	f000 fdf1 	bl	8004130 <_test_assert>
 800354e:	2800      	cmp	r0, #0
 8003550:	d1ce      	bne.n	80034f0 <test_003_001_execute.lto_priv.124+0x50>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8003552:	f1a6 30ff 	sub.w	r0, r6, #4294967295
 8003556:	490c      	ldr	r1, [pc, #48]	; (8003588 <test_003_001_execute.lto_priv.124+0xe8>)
 8003558:	fab0 f080 	clz	r0, r0
  }
}
 800355c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8003560:	0940      	lsrs	r0, r0, #5
 8003562:	f000 bde5 	b.w	8004130 <_test_assert>
 8003566:	bf00      	nop
 8003568:	200012a0 	.word	0x200012a0
 800356c:	20000f5c 	.word	0x20000f5c
 8003570:	08002b91 	.word	0x08002b91
 8003574:	200008b0 	.word	0x200008b0
 8003578:	08007a10 	.word	0x08007a10
 800357c:	20000f60 	.word	0x20000f60
 8003580:	20000f74 	.word	0x20000f74
 8003584:	08008180 	.word	0x08008180
 8003588:	08008018 	.word	0x08008018
 800358c:	f3af 8000 	nop.w

08003590 <test_002_002_execute.lto_priv.120>:
 * - [2.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void test_002_002_execute(void) {
 8003590:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003592:	4d54      	ldr	r5, [pc, #336]	; (80036e4 <test_002_002_execute.lto_priv.120+0x154>)

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 8003594:	4e54      	ldr	r6, [pc, #336]	; (80036e8 <test_002_002_execute.lto_priv.120+0x158>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003596:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003598:	4a54      	ldr	r2, [pc, #336]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 800359a:	6899      	ldr	r1, [r3, #8]
 800359c:	4854      	ldr	r0, [pc, #336]	; (80036f0 <test_002_002_execute.lto_priv.120+0x160>)
 800359e:	4b55      	ldr	r3, [pc, #340]	; (80036f4 <test_002_002_execute.lto_priv.120+0x164>)
 80035a0:	4c55      	ldr	r4, [pc, #340]	; (80036f8 <test_002_002_execute.lto_priv.120+0x168>)
 80035a2:	3905      	subs	r1, #5

static void test_002_002_execute(void) {

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80035a4:	2701      	movs	r7, #1
 80035a6:	6037      	str	r7, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80035a8:	f003 fde2 	bl	8007170 <chThdCreateStatic.constprop.69>
 80035ac:	69ab      	ldr	r3, [r5, #24]
 80035ae:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80035b0:	6899      	ldr	r1, [r3, #8]
 80035b2:	4a4e      	ldr	r2, [pc, #312]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80035b4:	4b51      	ldr	r3, [pc, #324]	; (80036fc <test_002_002_execute.lto_priv.120+0x16c>)
 80035b6:	4852      	ldr	r0, [pc, #328]	; (8003700 <test_002_002_execute.lto_priv.120+0x170>)
 80035b8:	3904      	subs	r1, #4
 80035ba:	f003 fdd9 	bl	8007170 <chThdCreateStatic.constprop.69>
 80035be:	69ab      	ldr	r3, [r5, #24]
 80035c0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80035c2:	6899      	ldr	r1, [r3, #8]
 80035c4:	4a49      	ldr	r2, [pc, #292]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80035c6:	4b4f      	ldr	r3, [pc, #316]	; (8003704 <test_002_002_execute.lto_priv.120+0x174>)
 80035c8:	484f      	ldr	r0, [pc, #316]	; (8003708 <test_002_002_execute.lto_priv.120+0x178>)
 80035ca:	3903      	subs	r1, #3
 80035cc:	f003 fdd0 	bl	8007170 <chThdCreateStatic.constprop.69>
 80035d0:	69ab      	ldr	r3, [r5, #24]
 80035d2:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80035d4:	6899      	ldr	r1, [r3, #8]
 80035d6:	4a45      	ldr	r2, [pc, #276]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80035d8:	4b4c      	ldr	r3, [pc, #304]	; (800370c <test_002_002_execute.lto_priv.120+0x17c>)
 80035da:	484d      	ldr	r0, [pc, #308]	; (8003710 <test_002_002_execute.lto_priv.120+0x180>)
 80035dc:	3902      	subs	r1, #2
 80035de:	f003 fdc7 	bl	8007170 <chThdCreateStatic.constprop.69>
 80035e2:	69ab      	ldr	r3, [r5, #24]
 80035e4:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80035e6:	6899      	ldr	r1, [r3, #8]
 80035e8:	4a40      	ldr	r2, [pc, #256]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80035ea:	4b4a      	ldr	r3, [pc, #296]	; (8003714 <test_002_002_execute.lto_priv.120+0x184>)
 80035ec:	484a      	ldr	r0, [pc, #296]	; (8003718 <test_002_002_execute.lto_priv.120+0x188>)
 80035ee:	3901      	subs	r1, #1
 80035f0:	f003 fdbe 	bl	8007170 <chThdCreateStatic.constprop.69>
 80035f4:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 80035f6:	f7ff fda3 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80035fa:	4848      	ldr	r0, [pc, #288]	; (800371c <test_002_002_execute.lto_priv.120+0x18c>)
 80035fc:	4948      	ldr	r1, [pc, #288]	; (8003720 <test_002_002_execute.lto_priv.120+0x190>)
 80035fe:	f000 fd6f 	bl	80040e0 <_test_assert_sequence>
 8003602:	b100      	cbz	r0, 8003606 <test_002_002_execute.lto_priv.120+0x76>
 8003604:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003606:	69ab      	ldr	r3, [r5, #24]

  /* [2.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8003608:	4a38      	ldr	r2, [pc, #224]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 800360a:	6899      	ldr	r1, [r3, #8]
 800360c:	4842      	ldr	r0, [pc, #264]	; (8003718 <test_002_002_execute.lto_priv.120+0x188>)
 800360e:	4b41      	ldr	r3, [pc, #260]	; (8003714 <test_002_002_execute.lto_priv.120+0x184>)
 8003610:	3901      	subs	r1, #1
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [2.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8003612:	2702      	movs	r7, #2
 8003614:	6037      	str	r7, [r6, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8003616:	f003 fdab 	bl	8007170 <chThdCreateStatic.constprop.69>
 800361a:	69ab      	ldr	r3, [r5, #24]
 800361c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800361e:	6899      	ldr	r1, [r3, #8]
 8003620:	4a32      	ldr	r2, [pc, #200]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003622:	4b3a      	ldr	r3, [pc, #232]	; (800370c <test_002_002_execute.lto_priv.120+0x17c>)
 8003624:	483a      	ldr	r0, [pc, #232]	; (8003710 <test_002_002_execute.lto_priv.120+0x180>)
 8003626:	3902      	subs	r1, #2
 8003628:	f003 fda2 	bl	8007170 <chThdCreateStatic.constprop.69>
 800362c:	69ab      	ldr	r3, [r5, #24]
 800362e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8003630:	6899      	ldr	r1, [r3, #8]
 8003632:	4a2e      	ldr	r2, [pc, #184]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003634:	4b33      	ldr	r3, [pc, #204]	; (8003704 <test_002_002_execute.lto_priv.120+0x174>)
 8003636:	4834      	ldr	r0, [pc, #208]	; (8003708 <test_002_002_execute.lto_priv.120+0x178>)
 8003638:	3903      	subs	r1, #3
 800363a:	f003 fd99 	bl	8007170 <chThdCreateStatic.constprop.69>
 800363e:	69ab      	ldr	r3, [r5, #24]
 8003640:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8003642:	6899      	ldr	r1, [r3, #8]
 8003644:	4a29      	ldr	r2, [pc, #164]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003646:	4b2d      	ldr	r3, [pc, #180]	; (80036fc <test_002_002_execute.lto_priv.120+0x16c>)
 8003648:	482d      	ldr	r0, [pc, #180]	; (8003700 <test_002_002_execute.lto_priv.120+0x170>)
 800364a:	3904      	subs	r1, #4
 800364c:	f003 fd90 	bl	8007170 <chThdCreateStatic.constprop.69>
 8003650:	69ab      	ldr	r3, [r5, #24]
 8003652:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8003654:	6899      	ldr	r1, [r3, #8]
 8003656:	4a25      	ldr	r2, [pc, #148]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003658:	4b26      	ldr	r3, [pc, #152]	; (80036f4 <test_002_002_execute.lto_priv.120+0x164>)
 800365a:	4825      	ldr	r0, [pc, #148]	; (80036f0 <test_002_002_execute.lto_priv.120+0x160>)
 800365c:	3905      	subs	r1, #5
 800365e:	f003 fd87 	bl	8007170 <chThdCreateStatic.constprop.69>
 8003662:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 8003664:	f7ff fd6c 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8003668:	482c      	ldr	r0, [pc, #176]	; (800371c <test_002_002_execute.lto_priv.120+0x18c>)
 800366a:	492d      	ldr	r1, [pc, #180]	; (8003720 <test_002_002_execute.lto_priv.120+0x190>)
 800366c:	f000 fd38 	bl	80040e0 <_test_assert_sequence>
 8003670:	2800      	cmp	r0, #0
 8003672:	d1c7      	bne.n	8003604 <test_002_002_execute.lto_priv.120+0x74>
 8003674:	69ab      	ldr	r3, [r5, #24]

  /* [2.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8003676:	4a1d      	ldr	r2, [pc, #116]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003678:	6899      	ldr	r1, [r3, #8]
 800367a:	4821      	ldr	r0, [pc, #132]	; (8003700 <test_002_002_execute.lto_priv.120+0x170>)
 800367c:	4b1f      	ldr	r3, [pc, #124]	; (80036fc <test_002_002_execute.lto_priv.120+0x16c>)
 800367e:	3904      	subs	r1, #4
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [2.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 8003680:	2703      	movs	r7, #3
 8003682:	6037      	str	r7, [r6, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8003684:	f003 fd74 	bl	8007170 <chThdCreateStatic.constprop.69>
 8003688:	69ab      	ldr	r3, [r5, #24]
 800368a:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800368c:	6899      	ldr	r1, [r3, #8]
 800368e:	4a17      	ldr	r2, [pc, #92]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 8003690:	4b18      	ldr	r3, [pc, #96]	; (80036f4 <test_002_002_execute.lto_priv.120+0x164>)
 8003692:	4817      	ldr	r0, [pc, #92]	; (80036f0 <test_002_002_execute.lto_priv.120+0x160>)
 8003694:	3905      	subs	r1, #5
 8003696:	f003 fd6b 	bl	8007170 <chThdCreateStatic.constprop.69>
 800369a:	69ab      	ldr	r3, [r5, #24]
 800369c:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800369e:	6899      	ldr	r1, [r3, #8]
 80036a0:	4a12      	ldr	r2, [pc, #72]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80036a2:	4b1c      	ldr	r3, [pc, #112]	; (8003714 <test_002_002_execute.lto_priv.120+0x184>)
 80036a4:	481c      	ldr	r0, [pc, #112]	; (8003718 <test_002_002_execute.lto_priv.120+0x188>)
 80036a6:	3901      	subs	r1, #1
 80036a8:	f003 fd62 	bl	8007170 <chThdCreateStatic.constprop.69>
 80036ac:	69ab      	ldr	r3, [r5, #24]
 80036ae:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80036b0:	6899      	ldr	r1, [r3, #8]
 80036b2:	4a0e      	ldr	r2, [pc, #56]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80036b4:	4b15      	ldr	r3, [pc, #84]	; (800370c <test_002_002_execute.lto_priv.120+0x17c>)
 80036b6:	4816      	ldr	r0, [pc, #88]	; (8003710 <test_002_002_execute.lto_priv.120+0x180>)
 80036b8:	3902      	subs	r1, #2
 80036ba:	f003 fd59 	bl	8007170 <chThdCreateStatic.constprop.69>
 80036be:	69ab      	ldr	r3, [r5, #24]
 80036c0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80036c2:	6899      	ldr	r1, [r3, #8]
 80036c4:	4a09      	ldr	r2, [pc, #36]	; (80036ec <test_002_002_execute.lto_priv.120+0x15c>)
 80036c6:	4b0f      	ldr	r3, [pc, #60]	; (8003704 <test_002_002_execute.lto_priv.120+0x174>)
 80036c8:	480f      	ldr	r0, [pc, #60]	; (8003708 <test_002_002_execute.lto_priv.120+0x178>)
 80036ca:	3903      	subs	r1, #3
 80036cc:	f003 fd50 	bl	8007170 <chThdCreateStatic.constprop.69>
 80036d0:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 80036d2:	f7ff fd35 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 80036d6:	4811      	ldr	r0, [pc, #68]	; (800371c <test_002_002_execute.lto_priv.120+0x18c>)
 80036d8:	4911      	ldr	r1, [pc, #68]	; (8003720 <test_002_002_execute.lto_priv.120+0x190>)
  }
}
 80036da:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 80036de:	f000 bcff 	b.w	80040e0 <_test_assert_sequence>
 80036e2:	bf00      	nop
 80036e4:	200012a0 	.word	0x200012a0
 80036e8:	20000f5c 	.word	0x20000f5c
 80036ec:	08002b61 	.word	0x08002b61
 80036f0:	200008b0 	.word	0x200008b0
 80036f4:	08008174 	.word	0x08008174
 80036f8:	20000f60 	.word	0x20000f60
 80036fc:	08007f18 	.word	0x08007f18
 8003700:	200009f8 	.word	0x200009f8
 8003704:	0800817c 	.word	0x0800817c
 8003708:	20000b40 	.word	0x20000b40
 800370c:	08008178 	.word	0x08008178
 8003710:	20000c88 	.word	0x20000c88
 8003714:	08007a10 	.word	0x08007a10
 8003718:	20000dd0 	.word	0x20000dd0
 800371c:	08008170 	.word	0x08008170
 8003720:	0800792c 	.word	0x0800792c
 8003724:	f3af 8000 	nop.w
 8003728:	f3af 8000 	nop.w
 800372c:	f3af 8000 	nop.w

08003730 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8003730:	4b0b      	ldr	r3, [pc, #44]	; (8003760 <test_terminate_threads+0x30>)
 8003732:	b430      	push	{r4, r5}
 8003734:	f103 0014 	add.w	r0, r3, #20
 8003738:	2520      	movs	r5, #32
 800373a:	2400      	movs	r4, #0
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 800373c:	f853 2b04 	ldr.w	r2, [r3], #4
 8003740:	b14a      	cbz	r2, 8003756 <test_terminate_threads+0x26>
 8003742:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8003746:	f892 1021 	ldrb.w	r1, [r2, #33]	; 0x21
 800374a:	f041 0104 	orr.w	r1, r1, #4
 800374e:	f882 1021 	strb.w	r1, [r2, #33]	; 0x21
 8003752:	f384 8811 	msr	BASEPRI, r4
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8003756:	4283      	cmp	r3, r0
 8003758:	d1f0      	bne.n	800373c <test_terminate_threads+0xc>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800375a:	bc30      	pop	{r4, r5}
 800375c:	4770      	bx	lr
 800375e:	bf00      	nop
 8003760:	20000f60 	.word	0x20000f60
 8003764:	f3af 8000 	nop.w
 8003768:	f3af 8000 	nop.w
 800376c:	f3af 8000 	nop.w

08003770 <print_line>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
 8003770:	b570      	push	{r4, r5, r6, lr}
 8003772:	4e09      	ldr	r6, [pc, #36]	; (8003798 <print_line+0x28>)
 8003774:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
 8003776:	6830      	ldr	r0, [r6, #0]
 8003778:	4d07      	ldr	r5, [pc, #28]	; (8003798 <print_line+0x28>)
 800377a:	6803      	ldr	r3, [r0, #0]
 800377c:	212d      	movs	r1, #45	; 0x2d
 800377e:	689b      	ldr	r3, [r3, #8]
 8003780:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8003782:	3c01      	subs	r4, #1
 8003784:	d1f7      	bne.n	8003776 <print_line+0x6>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003786:	6828      	ldr	r0, [r5, #0]
 8003788:	4904      	ldr	r1, [pc, #16]	; (800379c <print_line+0x2c>)
 800378a:	6803      	ldr	r3, [r0, #0]
 800378c:	2202      	movs	r2, #2
 800378e:	681b      	ldr	r3, [r3, #0]
}
 8003790:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003794:	4718      	bx	r3
 8003796:	bf00      	nop
 8003798:	20000f8c 	.word	0x20000f8c
 800379c:	08007d8c 	.word	0x08007d8c

080037a0 <notify1.lto_priv.75>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 80037a0:	4a02      	ldr	r2, [pc, #8]	; (80037ac <notify1.lto_priv.75+0xc>)
 80037a2:	6813      	ldr	r3, [r2, #0]
 80037a4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 80037a8:	6013      	str	r3, [r2, #0]
 80037aa:	4770      	bx	lr
 80037ac:	40013800 	.word	0x40013800

080037b0 <_port_irq_epilogue>:
 80037b0:	2320      	movs	r3, #32
 80037b2:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 80037b6:	4b0f      	ldr	r3, [pc, #60]	; (80037f4 <_port_irq_epilogue+0x44>)
 80037b8:	685b      	ldr	r3, [r3, #4]
 80037ba:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 80037be:	d102      	bne.n	80037c6 <_port_irq_epilogue+0x16>
 80037c0:	f383 8811 	msr	BASEPRI, r3
 80037c4:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80037c6:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 80037ca:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 80037ce:	f843 2c04 	str.w	r2, [r3, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 80037d2:	f1a3 0220 	sub.w	r2, r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80037d6:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 80037da:	4a07      	ldr	r2, [pc, #28]	; (80037f8 <_port_irq_epilogue+0x48>)
 80037dc:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 80037de:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80037e0:	6889      	ldr	r1, [r1, #8]
 80037e2:	6892      	ldr	r2, [r2, #8]
 80037e4:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80037e6:	bf8c      	ite	hi
 80037e8:	4a04      	ldrhi	r2, [pc, #16]	; (80037fc <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80037ea:	4a05      	ldrls	r2, [pc, #20]	; (8003800 <_port_irq_epilogue+0x50>)
 80037ec:	f843 2c08 	str.w	r2, [r3, #-8]
 80037f0:	4770      	bx	lr
 80037f2:	bf00      	nop
 80037f4:	e000ed00 	.word	0xe000ed00
 80037f8:	200012a0 	.word	0x200012a0
 80037fc:	080002f5 	.word	0x080002f5
 8003800:	080002f8 	.word	0x080002f8
 8003804:	f3af 8000 	nop.w
 8003808:	f3af 8000 	nop.w
 800380c:	f3af 8000 	nop.w

08003810 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003810:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8003814:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8003818:	692b      	ldr	r3, [r5, #16]
 800381a:	079b      	lsls	r3, r3, #30
 800381c:	d403      	bmi.n	8003826 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800381e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003822:	f7ff bfc5 	b.w	80037b0 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8003826:	2700      	movs	r7, #0
 8003828:	612f      	str	r7, [r5, #16]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800382a:	2620      	movs	r6, #32
 800382c:	f386 8811 	msr	BASEPRI, r6
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 8003830:	f8df 9078 	ldr.w	r9, [pc, #120]	; 80038ac <VectorB0+0x9c>
 8003834:	6a69      	ldr	r1, [r5, #36]	; 0x24
 8003836:	f8d9 301c 	ldr.w	r3, [r9, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 800383a:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 800383e:	689a      	ldr	r2, [r3, #8]
 8003840:	ebce 0001 	rsb	r0, lr, r1
 8003844:	4290      	cmp	r0, r2
 8003846:	f109 081c 	add.w	r8, r9, #28
 800384a:	d31c      	bcc.n	8003886 <VectorB0+0x76>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 800384c:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 800384e:	68dc      	ldr	r4, [r3, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8003850:	4472      	add	r2, lr
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003852:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 8003854:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 8003858:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.next = vtp->next;
 800385c:	f8c9 101c 	str.w	r1, [r9, #28]
    fn = vtp->func;
    vtp->func = NULL;
 8003860:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003862:	bf08      	it	eq
 8003864:	60ef      	streq	r7, [r5, #12]
 8003866:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 800386a:	6918      	ldr	r0, [r3, #16]
 800386c:	47a0      	blx	r4
 800386e:	f386 8811 	msr	BASEPRI, r6
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 8003872:	f8d9 301c 	ldr.w	r3, [r9, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003876:	6a69      	ldr	r1, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 8003878:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 800387c:	689a      	ldr	r2, [r3, #8]
 800387e:	ebce 0001 	rsb	r0, lr, r1
 8003882:	4282      	cmp	r2, r0
 8003884:	d9e2      	bls.n	800384c <VectorB0+0x3c>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 8003886:	4543      	cmp	r3, r8
 8003888:	d008      	beq.n	800389c <VectorB0+0x8c>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 800388a:	4472      	add	r2, lr
 800388c:	1a52      	subs	r2, r2, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 800388e:	2a01      	cmp	r2, #1
 8003890:	bf98      	it	ls
 8003892:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003894:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 8003898:	440a      	add	r2, r1
 800389a:	635a      	str	r2, [r3, #52]	; 0x34
 800389c:	2300      	movs	r3, #0
 800389e:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 80038a2:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 80038a6:	f7ff bf83 	b.w	80037b0 <_port_irq_epilogue>
 80038aa:	bf00      	nop
 80038ac:	200012a0 	.word	0x200012a0

080038b0 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 80038b0:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 80038b4:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 80038b6:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80038ba:	2300      	movs	r3, #0
 80038bc:	f383 8811 	msr	BASEPRI, r3
 80038c0:	4770      	bx	lr
 80038c2:	bf00      	nop
 80038c4:	f3af 8000 	nop.w
 80038c8:	f3af 8000 	nop.w
 80038cc:	f3af 8000 	nop.w

080038d0 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 80038d0:	b430      	push	{r4, r5}
 80038d2:	2320      	movs	r3, #32
 80038d4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80038d8:	4d0b      	ldr	r5, [pc, #44]	; (8003908 <chCoreAllocAligned+0x38>)

  if (((size_t)endmem - (size_t)p) < size) {
 80038da:	4a0c      	ldr	r2, [pc, #48]	; (800390c <chCoreAllocAligned+0x3c>)
 80038dc:	682b      	ldr	r3, [r5, #0]
 80038de:	6812      	ldr	r2, [r2, #0]
 80038e0:	3b01      	subs	r3, #1

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80038e2:	440b      	add	r3, r1
 80038e4:	1e4c      	subs	r4, r1, #1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80038e6:	4249      	negs	r1, r1
 80038e8:	4404      	add	r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 80038ea:	ea03 0001 	and.w	r0, r3, r1

  if (((size_t)endmem - (size_t)p) < size) {
 80038ee:	1a13      	subs	r3, r2, r0
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 80038f0:	4021      	ands	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 80038f2:	4299      	cmp	r1, r3
    return NULL;
  }
  nextmem = p + size;
 80038f4:	bf9a      	itte	ls
 80038f6:	1809      	addls	r1, r1, r0
 80038f8:	6029      	strls	r1, [r5, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 80038fa:	2000      	movhi	r0, #0
 80038fc:	2300      	movs	r3, #0
 80038fe:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8003902:	bc30      	pop	{r4, r5}
 8003904:	4770      	bx	lr
 8003906:	bf00      	nop
 8003908:	20000fe4 	.word	0x20000fe4
 800390c:	20000fe0 	.word	0x20000fe0

08003910 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8003910:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 8003914:	4d64      	ldr	r5, [pc, #400]	; (8003aa8 <VectorD4+0x198>)
 8003916:	6d6e      	ldr	r6, [r5, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 8003918:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800391a:	69f4      	ldr	r4, [r6, #28]
  u->ICR = isr;
 800391c:	6234      	str	r4, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800391e:	0722      	lsls	r2, r4, #28
 8003920:	d156      	bne.n	80039d0 <VectorD4+0xc0>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 8003922:	05e3      	lsls	r3, r4, #23
 8003924:	d448      	bmi.n	80039b8 <VectorD4+0xa8>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8003926:	06a0      	lsls	r0, r4, #26
 8003928:	d418      	bmi.n	800395c <VectorD4+0x4c>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800392a:	0639      	lsls	r1, r7, #24
 800392c:	d501      	bpl.n	8003932 <VectorD4+0x22>
 800392e:	0622      	lsls	r2, r4, #24
 8003930:	d469      	bmi.n	8003a06 <VectorD4+0xf6>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 8003932:	0663      	lsls	r3, r4, #25
 8003934:	d50e      	bpl.n	8003954 <VectorD4+0x44>
 8003936:	2320      	movs	r3, #32
 8003938:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 800393c:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 800393e:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003940:	4859      	ldr	r0, [pc, #356]	; (8003aa8 <VectorD4+0x198>)
 8003942:	429a      	cmp	r2, r3
 8003944:	f000 808c 	beq.w	8003a60 <VectorD4+0x150>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 8003948:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 800394c:	6037      	str	r7, [r6, #0]
 800394e:	2300      	movs	r3, #0
 8003950:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 8003954:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8003958:	f7ff bf2a 	b.w	80037b0 <_port_irq_epilogue>
 800395c:	2320      	movs	r3, #32
 800395e:	f383 8811 	msr	BASEPRI, r3
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8003962:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 8003964:	f895 805c 	ldrb.w	r8, [r5, #92]	; 0x5c
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8003968:	696b      	ldr	r3, [r5, #20]
 800396a:	ea08 0802 	and.w	r8, r8, r2
 800396e:	2b00      	cmp	r3, #0
 8003970:	d07f      	beq.n	8003a72 <VectorD4+0x162>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8003972:	6a2b      	ldr	r3, [r5, #32]
 8003974:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003976:	484c      	ldr	r0, [pc, #304]	; (8003aa8 <VectorD4+0x198>)
 8003978:	4293      	cmp	r3, r2
 800397a:	d07f      	beq.n	8003a7c <VectorD4+0x16c>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800397c:	696a      	ldr	r2, [r5, #20]
 800397e:	494a      	ldr	r1, [pc, #296]	; (8003aa8 <VectorD4+0x198>)
 8003980:	3201      	adds	r2, #1
  *iqp->q_wrptr++ = b;
 8003982:	1c58      	adds	r0, r3, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8003984:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8003986:	6228      	str	r0, [r5, #32]
 8003988:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 800398c:	6a2a      	ldr	r2, [r5, #32]
 800398e:	69eb      	ldr	r3, [r5, #28]
 8003990:	429a      	cmp	r2, r3
 8003992:	d262      	bcs.n	8003a5a <VectorD4+0x14a>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003994:	4944      	ldr	r1, [pc, #272]	; (8003aa8 <VectorD4+0x198>)
 8003996:	68eb      	ldr	r3, [r5, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8003998:	f101 020c 	add.w	r2, r1, #12
 800399c:	4293      	cmp	r3, r2
 800399e:	d007      	beq.n	80039b0 <VectorD4+0xa0>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80039a0:	6818      	ldr	r0, [r3, #0]
 80039a2:	60c8      	str	r0, [r1, #12]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80039a4:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80039a6:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 80039a8:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80039aa:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80039ac:	f002 fc28 	bl	8006200 <chSchReadyI>
 80039b0:	2300      	movs	r3, #0
 80039b2:	f383 8811 	msr	BASEPRI, r3
 80039b6:	e7b8      	b.n	800392a <VectorD4+0x1a>
 80039b8:	2320      	movs	r3, #32
 80039ba:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80039be:	483b      	ldr	r0, [pc, #236]	; (8003aac <VectorD4+0x19c>)
 80039c0:	f44f 7100 	mov.w	r1, #512	; 0x200
 80039c4:	f002 f9f4 	bl	8005db0 <chEvtBroadcastFlagsI>
 80039c8:	2300      	movs	r3, #0
 80039ca:	f383 8811 	msr	BASEPRI, r3
 80039ce:	e7aa      	b.n	8003926 <VectorD4+0x16>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 80039d0:	f014 0f08 	tst.w	r4, #8
 80039d4:	bf0c      	ite	eq
 80039d6:	2100      	moveq	r1, #0
 80039d8:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
 80039da:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 80039dc:	bf48      	it	mi
 80039de:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 80039e2:	07a0      	lsls	r0, r4, #30
    sts |= SD_FRAMING_ERROR;
 80039e4:	bf48      	it	mi
 80039e6:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 80039ea:	0762      	lsls	r2, r4, #29
    sts |= SD_NOISE_ERROR;
 80039ec:	bf48      	it	mi
 80039ee:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 80039f2:	2320      	movs	r3, #32
 80039f4:	f383 8811 	msr	BASEPRI, r3
 80039f8:	482c      	ldr	r0, [pc, #176]	; (8003aac <VectorD4+0x19c>)
 80039fa:	f002 f9d9 	bl	8005db0 <chEvtBroadcastFlagsI>
 80039fe:	2300      	movs	r3, #0
 8003a00:	f383 8811 	msr	BASEPRI, r3
 8003a04:	e78d      	b.n	8003922 <VectorD4+0x12>
 8003a06:	2320      	movs	r3, #32
 8003a08:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8003a0c:	6cab      	ldr	r3, [r5, #72]	; 0x48
 8003a0e:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 8003a10:	4825      	ldr	r0, [pc, #148]	; (8003aa8 <VectorD4+0x198>)
 8003a12:	429a      	cmp	r2, r3
 8003a14:	d03b      	beq.n	8003a8e <VectorD4+0x17e>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8003a16:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8003a18:	4923      	ldr	r1, [pc, #140]	; (8003aa8 <VectorD4+0x198>)
  b = *oqp->q_rdptr++;
 8003a1a:	1c58      	adds	r0, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 8003a1c:	3201      	adds	r2, #1
 8003a1e:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8003a20:	64a8      	str	r0, [r5, #72]	; 0x48
 8003a22:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003a26:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 8003a28:	4298      	cmp	r0, r3
 8003a2a:	d301      	bcc.n	8003a30 <VectorD4+0x120>
    oqp->q_rdptr = oqp->q_buffer;
 8003a2c:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 8003a2e:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003a30:	491d      	ldr	r1, [pc, #116]	; (8003aa8 <VectorD4+0x198>)
 8003a32:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 8003a34:	f101 0230 	add.w	r2, r1, #48	; 0x30
 8003a38:	4293      	cmp	r3, r2
 8003a3a:	d007      	beq.n	8003a4c <VectorD4+0x13c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003a3c:	6818      	ldr	r0, [r3, #0]
 8003a3e:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003a40:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8003a42:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 8003a44:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003a46:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 8003a48:	f002 fbda 	bl	8006200 <chSchReadyI>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 8003a4c:	fa1f f388 	uxth.w	r3, r8
 8003a50:	8533      	strh	r3, [r6, #40]	; 0x28
 8003a52:	2300      	movs	r3, #0
 8003a54:	f383 8811 	msr	BASEPRI, r3
 8003a58:	e76b      	b.n	8003932 <VectorD4+0x22>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 8003a5a:	698b      	ldr	r3, [r1, #24]
 8003a5c:	620b      	str	r3, [r1, #32]
 8003a5e:	e799      	b.n	8003994 <VectorD4+0x84>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8003a60:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	f43f af70 	beq.w	8003948 <VectorD4+0x38>
 8003a68:	3004      	adds	r0, #4
 8003a6a:	2110      	movs	r1, #16
 8003a6c:	f002 f9a0 	bl	8005db0 <chEvtBroadcastFlagsI>
 8003a70:	e76a      	b.n	8003948 <VectorD4+0x38>
 8003a72:	480e      	ldr	r0, [pc, #56]	; (8003aac <VectorD4+0x19c>)
 8003a74:	2104      	movs	r1, #4
 8003a76:	f002 f99b 	bl	8005db0 <chEvtBroadcastFlagsI>
 8003a7a:	e77a      	b.n	8003972 <VectorD4+0x62>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8003a7c:	6942      	ldr	r2, [r0, #20]
 8003a7e:	2a00      	cmp	r2, #0
 8003a80:	f43f af7c 	beq.w	800397c <VectorD4+0x6c>
 8003a84:	3004      	adds	r0, #4
 8003a86:	2180      	movs	r1, #128	; 0x80
 8003a88:	f002 f992 	bl	8005db0 <chEvtBroadcastFlagsI>
 8003a8c:	e790      	b.n	80039b0 <VectorD4+0xa0>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8003a8e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8003a90:	2a00      	cmp	r2, #0
 8003a92:	d0c0      	beq.n	8003a16 <VectorD4+0x106>
 8003a94:	3004      	adds	r0, #4
 8003a96:	2108      	movs	r1, #8
 8003a98:	f002 f98a 	bl	8005db0 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8003a9c:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 8003aa0:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003aa4:	6033      	str	r3, [r6, #0]
 8003aa6:	e7d4      	b.n	8003a52 <VectorD4+0x142>
 8003aa8:	20000fe8 	.word	0x20000fe8
 8003aac:	20000fec 	.word	0x20000fec

08003ab0 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8003ab0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ab4:	4604      	mov	r4, r0
 8003ab6:	b083      	sub	sp, #12
 8003ab8:	468a      	mov	sl, r1
 8003aba:	4615      	mov	r5, r2
 8003abc:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8003abe:	69c7      	ldr	r7, [r0, #28]
 8003ac0:	f04f 0820 	mov.w	r8, #32
 8003ac4:	f388 8811 	msr	BASEPRI, r8
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003ac8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  size_t w = 0;
 8003acc:	2600      	movs	r6, #0
 8003ace:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003ad0:	444b      	add	r3, r9
 8003ad2:	9301      	str	r3, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003ad4:	f109 3bff 	add.w	fp, r9, #4294967295
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8003ad8:	68a3      	ldr	r3, [r4, #8]
 8003ada:	b1fb      	cbz	r3, 8003b1c <oqWriteTimeout+0x6c>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003adc:	6962      	ldr	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003ade:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003ae0:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003ae2:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8003ae4:	6161      	str	r1, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003ae6:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003ae8:	f89a 3000 	ldrb.w	r3, [sl]
 8003aec:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8003aee:	6923      	ldr	r3, [r4, #16]
 8003af0:	6962      	ldr	r2, [r4, #20]
 8003af2:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8003af4:	bf24      	itt	cs
 8003af6:	68e3      	ldrcs	r3, [r4, #12]
 8003af8:	6163      	strcs	r3, [r4, #20]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003afa:	f10a 0a01 	add.w	sl, sl, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8003afe:	b10f      	cbz	r7, 8003b04 <oqWriteTimeout+0x54>
      nfy(oqp);
 8003b00:	4620      	mov	r0, r4
 8003b02:	47b8      	blx	r7
 8003b04:	2300      	movs	r3, #0
 8003b06:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 8003b0a:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 8003b0c:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8003b10:	d016      	beq.n	8003b40 <oqWriteTimeout+0x90>
 8003b12:	f388 8811 	msr	BASEPRI, r8
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8003b16:	68a3      	ldr	r3, [r4, #8]
 8003b18:	2b00      	cmp	r3, #0
 8003b1a:	d1df      	bne.n	8003adc <oqWriteTimeout+0x2c>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003b1c:	f11b 0f03 	cmn.w	fp, #3
 8003b20:	d812      	bhi.n	8003b48 <oqWriteTimeout+0x98>
 8003b22:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003b26:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003b28:	9a01      	ldr	r2, [sp, #4]
 8003b2a:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003b2c:	4589      	cmp	r9, r1
 8003b2e:	d305      	bcc.n	8003b3c <oqWriteTimeout+0x8c>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8003b30:	4620      	mov	r0, r4
 8003b32:	f002 fd7d 	bl	8006630 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003b36:	2800      	cmp	r0, #0
 8003b38:	d0ce      	beq.n	8003ad8 <oqWriteTimeout+0x28>
 8003b3a:	2300      	movs	r3, #0
 8003b3c:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 8003b40:	4630      	mov	r0, r6
 8003b42:	b003      	add	sp, #12
 8003b44:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003b48:	4620      	mov	r0, r4
 8003b4a:	4649      	mov	r1, r9
 8003b4c:	f002 fd70 	bl	8006630 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003b50:	2800      	cmp	r0, #0
 8003b52:	d0c1      	beq.n	8003ad8 <oqWriteTimeout+0x28>
 8003b54:	e7f1      	b.n	8003b3a <oqWriteTimeout+0x8a>
 8003b56:	bf00      	nop
 8003b58:	f3af 8000 	nop.w
 8003b5c:	f3af 8000 	nop.w

08003b60 <writet.lto_priv.83>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003b60:	3030      	adds	r0, #48	; 0x30
 8003b62:	f7ff bfa5 	b.w	8003ab0 <oqWriteTimeout>
 8003b66:	bf00      	nop
 8003b68:	f3af 8000 	nop.w
 8003b6c:	f3af 8000 	nop.w

08003b70 <write.lto_priv.77>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003b70:	3030      	adds	r0, #48	; 0x30
 8003b72:	f04f 33ff 	mov.w	r3, #4294967295
 8003b76:	f7ff bf9b 	b.w	8003ab0 <oqWriteTimeout>
 8003b7a:	bf00      	nop
 8003b7c:	f3af 8000 	nop.w

08003b80 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003b80:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003b82:	4604      	mov	r4, r0
 8003b84:	460f      	mov	r7, r1
 8003b86:	4616      	mov	r6, r2
 8003b88:	2320      	movs	r3, #32
 8003b8a:	f383 8811 	msr	BASEPRI, r3
 8003b8e:	e003      	b.n	8003b98 <oqPutTimeout+0x18>
 8003b90:	f002 fd4e 	bl	8006630 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8003b94:	2800      	cmp	r0, #0
 8003b96:	db19      	blt.n	8003bcc <oqPutTimeout+0x4c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8003b98:	68a5      	ldr	r5, [r4, #8]
 8003b9a:	4620      	mov	r0, r4
 8003b9c:	4631      	mov	r1, r6
 8003b9e:	2d00      	cmp	r5, #0
 8003ba0:	d0f6      	beq.n	8003b90 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8003ba2:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003ba4:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003ba6:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003ba8:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8003baa:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003bac:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003bae:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003bb0:	6923      	ldr	r3, [r4, #16]
 8003bb2:	6962      	ldr	r2, [r4, #20]
 8003bb4:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8003bb6:	bf24      	itt	cs
 8003bb8:	68e3      	ldrcs	r3, [r4, #12]
 8003bba:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8003bbc:	69e3      	ldr	r3, [r4, #28]
 8003bbe:	b10b      	cbz	r3, 8003bc4 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8003bc0:	4620      	mov	r0, r4
 8003bc2:	4798      	blx	r3
 8003bc4:	2000      	movs	r0, #0
 8003bc6:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8003bca:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003bcc:	f385 8811 	msr	BASEPRI, r5
 8003bd0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003bd2:	bf00      	nop
 8003bd4:	f3af 8000 	nop.w
 8003bd8:	f3af 8000 	nop.w
 8003bdc:	f3af 8000 	nop.w

08003be0 <putt.lto_priv.81>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003be0:	3030      	adds	r0, #48	; 0x30
 8003be2:	f7ff bfcd 	b.w	8003b80 <oqPutTimeout>
 8003be6:	bf00      	nop
 8003be8:	f3af 8000 	nop.w
 8003bec:	f3af 8000 	nop.w

08003bf0 <put.lto_priv.79>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003bf0:	3030      	adds	r0, #48	; 0x30
 8003bf2:	f04f 32ff 	mov.w	r2, #4294967295
 8003bf6:	f7ff bfc3 	b.w	8003b80 <oqPutTimeout>
 8003bfa:	bf00      	nop
 8003bfc:	f3af 8000 	nop.w

08003c00 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8003c00:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003c04:	4604      	mov	r4, r0
 8003c06:	b083      	sub	sp, #12
 8003c08:	468a      	mov	sl, r1
 8003c0a:	4615      	mov	r5, r2
 8003c0c:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8003c0e:	69c7      	ldr	r7, [r0, #28]
 8003c10:	f04f 0820 	mov.w	r8, #32
 8003c14:	f388 8811 	msr	BASEPRI, r8
 8003c18:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  size_t r = 0;
 8003c1c:	2600      	movs	r6, #0
 8003c1e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003c20:	444b      	add	r3, r9
 8003c22:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003c24:	f109 3bff 	add.w	fp, r9, #4294967295
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8003c28:	68a3      	ldr	r3, [r4, #8]
 8003c2a:	b1fb      	cbz	r3, 8003c6c <iqReadTimeout+0x6c>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8003c2c:	69a2      	ldr	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003c2e:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003c30:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003c32:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8003c34:	61a1      	str	r1, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003c36:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003c38:	7813      	ldrb	r3, [r2, #0]
 8003c3a:	f88a 3000 	strb.w	r3, [sl]
    if (iqp->q_rdptr >= iqp->q_top) {
 8003c3e:	6923      	ldr	r3, [r4, #16]
 8003c40:	69a2      	ldr	r2, [r4, #24]
 8003c42:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8003c44:	bf24      	itt	cs
 8003c46:	68e3      	ldrcs	r3, [r4, #12]
 8003c48:	61a3      	strcs	r3, [r4, #24]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8003c4a:	f10a 0a01 	add.w	sl, sl, #1
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8003c4e:	b10f      	cbz	r7, 8003c54 <iqReadTimeout+0x54>
      nfy(iqp);
 8003c50:	4620      	mov	r0, r4
 8003c52:	47b8      	blx	r7
 8003c54:	2300      	movs	r3, #0
 8003c56:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 8003c5a:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8003c5c:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8003c60:	d016      	beq.n	8003c90 <iqReadTimeout+0x90>
 8003c62:	f388 8811 	msr	BASEPRI, r8
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8003c66:	68a3      	ldr	r3, [r4, #8]
 8003c68:	2b00      	cmp	r3, #0
 8003c6a:	d1df      	bne.n	8003c2c <iqReadTimeout+0x2c>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003c6c:	f11b 0f03 	cmn.w	fp, #3
 8003c70:	d812      	bhi.n	8003c98 <iqReadTimeout+0x98>
 8003c72:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003c76:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003c78:	9a01      	ldr	r2, [sp, #4]
 8003c7a:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003c7c:	4589      	cmp	r9, r1
 8003c7e:	d305      	bcc.n	8003c8c <iqReadTimeout+0x8c>
 8003c80:	4620      	mov	r0, r4
 8003c82:	f002 fcd5 	bl	8006630 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003c86:	2800      	cmp	r0, #0
 8003c88:	d0ce      	beq.n	8003c28 <iqReadTimeout+0x28>
 8003c8a:	2300      	movs	r3, #0
 8003c8c:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 8003c90:	4630      	mov	r0, r6
 8003c92:	b003      	add	sp, #12
 8003c94:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003c98:	4620      	mov	r0, r4
 8003c9a:	4649      	mov	r1, r9
 8003c9c:	f002 fcc8 	bl	8006630 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003ca0:	2800      	cmp	r0, #0
 8003ca2:	d0c1      	beq.n	8003c28 <iqReadTimeout+0x28>
 8003ca4:	e7f1      	b.n	8003c8a <iqReadTimeout+0x8a>
 8003ca6:	bf00      	nop
 8003ca8:	f3af 8000 	nop.w
 8003cac:	f3af 8000 	nop.w

08003cb0 <readt.lto_priv.84>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003cb0:	300c      	adds	r0, #12
 8003cb2:	f7ff bfa5 	b.w	8003c00 <iqReadTimeout>
 8003cb6:	bf00      	nop
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <read.lto_priv.78>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003cc0:	300c      	adds	r0, #12
 8003cc2:	f04f 33ff 	mov.w	r3, #4294967295
 8003cc6:	f7ff bf9b 	b.w	8003c00 <iqReadTimeout>
 8003cca:	bf00      	nop
 8003ccc:	f3af 8000 	nop.w

08003cd0 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003cd0:	b570      	push	{r4, r5, r6, lr}
 8003cd2:	2320      	movs	r3, #32
 8003cd4:	4604      	mov	r4, r0
 8003cd6:	460e      	mov	r6, r1
 8003cd8:	f383 8811 	msr	BASEPRI, r3
 8003cdc:	e003      	b.n	8003ce6 <iqGetTimeout+0x16>
 8003cde:	f002 fca7 	bl	8006630 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8003ce2:	2800      	cmp	r0, #0
 8003ce4:	db1a      	blt.n	8003d1c <iqGetTimeout+0x4c>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8003ce6:	68a5      	ldr	r5, [r4, #8]
 8003ce8:	4620      	mov	r0, r4
 8003cea:	4631      	mov	r1, r6
 8003cec:	2d00      	cmp	r5, #0
 8003cee:	d0f6      	beq.n	8003cde <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003cf0:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003cf2:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8003cf4:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003cf6:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003cf8:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8003cfa:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003cfc:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8003cfe:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003d00:	bf28      	it	cs
 8003d02:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003d04:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003d06:	bf28      	it	cs
 8003d08:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8003d0a:	69e3      	ldr	r3, [r4, #28]
 8003d0c:	b10b      	cbz	r3, 8003d12 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8003d0e:	4620      	mov	r0, r4
 8003d10:	4798      	blx	r3
 8003d12:	2300      	movs	r3, #0
 8003d14:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8003d18:	4628      	mov	r0, r5
}
 8003d1a:	bd70      	pop	{r4, r5, r6, pc}
 8003d1c:	f385 8811 	msr	BASEPRI, r5
 8003d20:	bd70      	pop	{r4, r5, r6, pc}
 8003d22:	bf00      	nop
 8003d24:	f3af 8000 	nop.w
 8003d28:	f3af 8000 	nop.w
 8003d2c:	f3af 8000 	nop.w

08003d30 <gett.lto_priv.82>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003d30:	300c      	adds	r0, #12
 8003d32:	f7ff bfcd 	b.w	8003cd0 <iqGetTimeout>
 8003d36:	bf00      	nop
 8003d38:	f3af 8000 	nop.w
 8003d3c:	f3af 8000 	nop.w

08003d40 <get.lto_priv.80>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003d40:	300c      	adds	r0, #12
 8003d42:	f04f 31ff 	mov.w	r1, #4294967295
 8003d46:	f7ff bfc3 	b.w	8003cd0 <iqGetTimeout>
 8003d4a:	bf00      	nop
 8003d4c:	f3af 8000 	nop.w

08003d50 <test_emit_token>:
 8003d50:	2320      	movs	r3, #32
 8003d52:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 8003d56:	4a06      	ldr	r2, [pc, #24]	; (8003d70 <test_emit_token+0x20>)
 8003d58:	4906      	ldr	r1, [pc, #24]	; (8003d74 <test_emit_token+0x24>)
 8003d5a:	6813      	ldr	r3, [r2, #0]
 8003d5c:	428b      	cmp	r3, r1
 8003d5e:	d202      	bcs.n	8003d66 <test_emit_token+0x16>
    *test_tokp++ = token;
 8003d60:	1c59      	adds	r1, r3, #1
 8003d62:	7018      	strb	r0, [r3, #0]
 8003d64:	6011      	str	r1, [r2, #0]
 8003d66:	2300      	movs	r3, #0
 8003d68:	f383 8811 	msr	BASEPRI, r3
 8003d6c:	4770      	bx	lr
 8003d6e:	bf00      	nop
 8003d70:	20000f78 	.word	0x20000f78
 8003d74:	20000f8c 	.word	0x20000f8c
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003d80:	b570      	push	{r4, r5, r6, lr}
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003d82:	7801      	ldrb	r1, [r0, #0]
 8003d84:	4d09      	ldr	r5, [pc, #36]	; (8003dac <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003d86:	4604      	mov	r4, r0
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003d88:	b139      	cbz	r1, 8003d9a <test_println+0x1a>
    streamPut(test_chp, *msgp++);
 8003d8a:	6828      	ldr	r0, [r5, #0]
 8003d8c:	6803      	ldr	r3, [r0, #0]
 8003d8e:	689b      	ldr	r3, [r3, #8]
 8003d90:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003d92:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8003d96:	2900      	cmp	r1, #0
 8003d98:	d1f7      	bne.n	8003d8a <test_println+0xa>
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003d9a:	6828      	ldr	r0, [r5, #0]
 8003d9c:	4904      	ldr	r1, [pc, #16]	; (8003db0 <test_println+0x30>)
 8003d9e:	6803      	ldr	r3, [r0, #0]
 8003da0:	2202      	movs	r2, #2
 8003da2:	681b      	ldr	r3, [r3, #0]
}
 8003da4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003da8:	4718      	bx	r3
 8003daa:	bf00      	nop
 8003dac:	20000f8c 	.word	0x20000f8c
 8003db0:	08007d8c 	.word	0x08007d8c
 8003db4:	f3af 8000 	nop.w
 8003db8:	f3af 8000 	nop.w
 8003dbc:	f3af 8000 	nop.w

08003dc0 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8003dc0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8003dc2:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8003dc4:	4604      	mov	r4, r0

  while (*msgp)
 8003dc6:	b141      	cbz	r1, 8003dda <test_print+0x1a>
 8003dc8:	4d04      	ldr	r5, [pc, #16]	; (8003ddc <test_print+0x1c>)
    streamPut(test_chp, *msgp++);
 8003dca:	6828      	ldr	r0, [r5, #0]
 8003dcc:	6803      	ldr	r3, [r0, #0]
 8003dce:	689b      	ldr	r3, [r3, #8]
 8003dd0:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003dd2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8003dd6:	2900      	cmp	r1, #0
 8003dd8:	d1f7      	bne.n	8003dca <test_print+0xa>
 8003dda:	bd38      	pop	{r3, r4, r5, pc}
 8003ddc:	20000f8c 	.word	0x20000f8c

08003de0 <test_printn>:
 * @api
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8003de0:	b310      	cbz	r0, 8003e28 <test_printn+0x48>
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8003de2:	b570      	push	{r4, r5, r6, lr}
  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8003de4:	4a13      	ldr	r2, [pc, #76]	; (8003e34 <test_printn+0x54>)
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8003de6:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8003de8:	466d      	mov	r5, sp
 8003dea:	466c      	mov	r4, sp
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8003dec:	fba2 1300 	umull	r1, r3, r2, r0
 8003df0:	08db      	lsrs	r3, r3, #3
 8003df2:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8003df6:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8003dfa:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8003dfe:	b2c9      	uxtb	r1, r1
 8003e00:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8003e04:	4618      	mov	r0, r3
 8003e06:	2b00      	cmp	r3, #0
 8003e08:	d1f0      	bne.n	8003dec <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8003e0a:	42ac      	cmp	r4, r5
 8003e0c:	d90a      	bls.n	8003e24 <test_printn+0x44>
 8003e0e:	4e0a      	ldr	r6, [pc, #40]	; (8003e38 <test_printn+0x58>)
 8003e10:	3c01      	subs	r4, #1
 8003e12:	e001      	b.n	8003e18 <test_printn+0x38>
 8003e14:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
 8003e18:	6830      	ldr	r0, [r6, #0]
 8003e1a:	6803      	ldr	r3, [r0, #0]
 8003e1c:	689b      	ldr	r3, [r3, #8]
 8003e1e:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8003e20:	42ac      	cmp	r4, r5
 8003e22:	d1f7      	bne.n	8003e14 <test_printn+0x34>
      streamPut(test_chp, *--p);
  }
}
 8003e24:	b004      	add	sp, #16
 8003e26:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
 8003e28:	4b03      	ldr	r3, [pc, #12]	; (8003e38 <test_printn+0x58>)
 8003e2a:	6818      	ldr	r0, [r3, #0]
 8003e2c:	6803      	ldr	r3, [r0, #0]
 8003e2e:	2130      	movs	r1, #48	; 0x30
 8003e30:	689b      	ldr	r3, [r3, #8]
 8003e32:	4718      	bx	r3
 8003e34:	cccccccd 	.word	0xcccccccd
 8003e38:	20000f8c 	.word	0x20000f8c
 8003e3c:	f3af 8000 	nop.w

08003e40 <test_execute>:
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
 8003e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  int i, j;

  test_chp = stream;
 8003e44:	4c89      	ldr	r4, [pc, #548]	; (800406c <test_execute+0x22c>)
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8003e46:	4d8a      	ldr	r5, [pc, #552]	; (8004070 <test_execute+0x230>)
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 8003e48:	6020      	str	r0, [r4, #0]
 * @retval false        if no errors occurred.
 * @retval true         if one or more tests failed.
 *
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
 8003e4a:	b083      	sub	sp, #12
  int i, j;

  test_chp = stream;
  test_println("");
 8003e4c:	4889      	ldr	r0, [pc, #548]	; (8004074 <test_execute+0x234>)
 8003e4e:	f7ff ff97 	bl	8003d80 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 8003e52:	4889      	ldr	r0, [pc, #548]	; (8004078 <test_execute+0x238>)
 8003e54:	f7ff ff94 	bl	8003d80 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8003e58:	4888      	ldr	r0, [pc, #544]	; (800407c <test_execute+0x23c>)
 8003e5a:	f7ff ff91 	bl	8003d80 <test_println>
 8003e5e:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003e60:	6820      	ldr	r0, [r4, #0]
 8003e62:	6803      	ldr	r3, [r0, #0]
 8003e64:	689b      	ldr	r3, [r3, #8]
 8003e66:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003e68:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003e6c:	2900      	cmp	r1, #0
 8003e6e:	d1f7      	bne.n	8003e60 <test_execute+0x20>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8003e70:	4883      	ldr	r0, [pc, #524]	; (8004080 <test_execute+0x240>)
 8003e72:	4d84      	ldr	r5, [pc, #528]	; (8004084 <test_execute+0x244>)
 8003e74:	f7ff ff84 	bl	8003d80 <test_println>
 8003e78:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003e7a:	6820      	ldr	r0, [r4, #0]
 8003e7c:	6803      	ldr	r3, [r0, #0]
 8003e7e:	689b      	ldr	r3, [r3, #8]
 8003e80:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003e82:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003e86:	2900      	cmp	r1, #0
 8003e88:	d1f7      	bne.n	8003e7a <test_execute+0x3a>
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8003e8a:	487f      	ldr	r0, [pc, #508]	; (8004088 <test_execute+0x248>)
 8003e8c:	4d7f      	ldr	r5, [pc, #508]	; (800408c <test_execute+0x24c>)
 8003e8e:	f7ff ff77 	bl	8003d80 <test_println>
 8003e92:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003e94:	6820      	ldr	r0, [r4, #0]
 8003e96:	6803      	ldr	r3, [r0, #0]
 8003e98:	689b      	ldr	r3, [r3, #8]
 8003e9a:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003e9c:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003ea0:	2900      	cmp	r1, #0
 8003ea2:	d1f7      	bne.n	8003e94 <test_execute+0x54>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8003ea4:	487a      	ldr	r0, [pc, #488]	; (8004090 <test_execute+0x250>)
 8003ea6:	9101      	str	r1, [sp, #4]
 8003ea8:	f7ff ff6a 	bl	8003d80 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8003eac:	4871      	ldr	r0, [pc, #452]	; (8004074 <test_execute+0x234>)

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8003eae:	4f79      	ldr	r7, [pc, #484]	; (8004094 <test_execute+0x254>)
  test_println(BOARD_NAME);
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8003eb0:	f7ff ff66 	bl	8003d80 <test_println>

  test_global_fail = false;
 8003eb4:	4b78      	ldr	r3, [pc, #480]	; (8004098 <test_execute+0x258>)
 8003eb6:	9901      	ldr	r1, [sp, #4]
 8003eb8:	7019      	strb	r1, [r3, #0]
  i = 0;
  while (test_suite[i]) {
 8003eba:	683b      	ldr	r3, [r7, #0]
 8003ebc:	2b00      	cmp	r3, #0
 8003ebe:	f000 80af 	beq.w	8004020 <test_execute+0x1e0>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003ec2:	f8df b1a8 	ldr.w	fp, [pc, #424]	; 800406c <test_execute+0x22c>
 8003ec6:	9a01      	ldr	r2, [sp, #4]
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8003ec8:	2600      	movs	r6, #0
 8003eca:	3201      	adds	r2, #1

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8003ecc:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 8003ed0:	9201      	str	r2, [sp, #4]
 8003ed2:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8003ed6:	2b00      	cmp	r3, #0
 8003ed8:	f000 809d 	beq.w	8004016 <test_execute+0x1d6>
      print_line();
 8003edc:	4d6f      	ldr	r5, [pc, #444]	; (800409c <test_execute+0x25c>)
 8003ede:	f7ff fc47 	bl	8003770 <print_line>
 8003ee2:	212d      	movs	r1, #45	; 0x2d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003ee4:	6820      	ldr	r0, [r4, #0]
 8003ee6:	6803      	ldr	r3, [r0, #0]
 8003ee8:	689b      	ldr	r3, [r3, #8]
 8003eea:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003eec:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003ef0:	2900      	cmp	r1, #0
 8003ef2:	d1f7      	bne.n	8003ee4 <test_execute+0xa4>
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8003ef4:	9801      	ldr	r0, [sp, #4]
      test_print(".");
      test_printn(j + 1);
 8003ef6:	4d6a      	ldr	r5, [pc, #424]	; (80040a0 <test_execute+0x260>)
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8003ef8:	f7ff ff72 	bl	8003de0 <test_printn>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003efc:	f8db 0000 	ldr.w	r0, [fp]
 8003f00:	6803      	ldr	r3, [r0, #0]
 8003f02:	212e      	movs	r1, #46	; 0x2e
 8003f04:	689b      	ldr	r3, [r3, #8]
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8003f06:	3601      	adds	r6, #1
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003f08:	4798      	blx	r3
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8003f0a:	4630      	mov	r0, r6
 8003f0c:	f7ff ff68 	bl	8003de0 <test_printn>
 8003f10:	2120      	movs	r1, #32
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003f12:	6820      	ldr	r0, [r4, #0]
 8003f14:	6803      	ldr	r3, [r0, #0]
 8003f16:	689b      	ldr	r3, [r3, #8]
 8003f18:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003f1a:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003f1e:	2900      	cmp	r1, #0
 8003f20:	d1f7      	bne.n	8003f12 <test_execute+0xd2>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
 8003f22:	683b      	ldr	r3, [r7, #0]
 8003f24:	f853 3008 	ldr.w	r3, [r3, r8]
 8003f28:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003f2a:	7829      	ldrb	r1, [r5, #0]
 8003f2c:	b139      	cbz	r1, 8003f3e <test_execute+0xfe>
    streamPut(test_chp, *msgp++);
 8003f2e:	6820      	ldr	r0, [r4, #0]
 8003f30:	6803      	ldr	r3, [r0, #0]
 8003f32:	689b      	ldr	r3, [r3, #8]
 8003f34:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003f36:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003f3a:	2900      	cmp	r1, #0
 8003f3c:	d1f7      	bne.n	8003f2e <test_execute+0xee>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
      test_println(")");
 8003f3e:	4859      	ldr	r0, [pc, #356]	; (80040a4 <test_execute+0x264>)
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8003f40:	4d59      	ldr	r5, [pc, #356]	; (80040a8 <test_execute+0x268>)

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8003f42:	f8df 9188 	ldr.w	r9, [pc, #392]	; 80040cc <test_execute+0x28c>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8003f46:	f8df a188 	ldr.w	sl, [pc, #392]	; 80040d0 <test_execute+0x290>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
      test_println(")");
 8003f4a:	f7ff ff19 	bl	8003d80 <test_println>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 8003f4e:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8003f52:	f002 fb85 	bl	8006660 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 8003f56:	683b      	ldr	r3, [r7, #0]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8003f58:	f8c5 a000 	str.w	sl, [r5]
      test_print(test_suite[i][j]->name);
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 8003f5c:	f853 8008 	ldr.w	r8, [r3, r8]

  /* Initialization */
  clear_tokens();
  test_local_fail = false;

  if (tcp->setup != NULL)
 8003f60:	f8d8 3004 	ldr.w	r3, [r8, #4]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8003f64:	2200      	movs	r2, #0
 8003f66:	f889 2000 	strb.w	r2, [r9]

  if (tcp->setup != NULL)
 8003f6a:	b103      	cbz	r3, 8003f6e <test_execute+0x12e>
    tcp->setup();
 8003f6c:	4798      	blx	r3
  tcp->execute();
 8003f6e:	f8d8 300c 	ldr.w	r3, [r8, #12]
 8003f72:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8003f74:	f8d8 3008 	ldr.w	r3, [r8, #8]
 8003f78:	b103      	cbz	r3, 8003f7c <test_execute+0x13c>
    tcp->teardown();
 8003f7a:	4798      	blx	r3
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
 8003f7c:	f899 3000 	ldrb.w	r3, [r9]
 8003f80:	2b00      	cmp	r3, #0
 8003f82:	d067      	beq.n	8004054 <test_execute+0x214>
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8003f84:	f8df 814c 	ldr.w	r8, [pc, #332]	; 80040d4 <test_execute+0x294>
 8003f88:	212d      	movs	r1, #45	; 0x2d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003f8a:	6820      	ldr	r0, [r4, #0]
 8003f8c:	6803      	ldr	r3, [r0, #0]
 8003f8e:	689b      	ldr	r3, [r3, #8]
 8003f90:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003f92:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8003f96:	2900      	cmp	r1, #0
 8003f98:	d1f7      	bne.n	8003f8a <test_execute+0x14a>
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8003f9a:	4b44      	ldr	r3, [pc, #272]	; (80040ac <test_execute+0x26c>)
 8003f9c:	f8df 8138 	ldr.w	r8, [pc, #312]	; 80040d8 <test_execute+0x298>
 8003fa0:	6818      	ldr	r0, [r3, #0]
 8003fa2:	f7ff ff1d 	bl	8003de0 <test_printn>
 8003fa6:	2120      	movs	r1, #32
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003fa8:	6820      	ldr	r0, [r4, #0]
 8003faa:	6803      	ldr	r3, [r0, #0]
 8003fac:	689b      	ldr	r3, [r3, #8]
 8003fae:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003fb0:	f818 1f01 	ldrb.w	r1, [r8, #1]!
 8003fb4:	2900      	cmp	r1, #0
 8003fb6:	d1f7      	bne.n	8003fa8 <test_execute+0x168>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8003fb8:	682b      	ldr	r3, [r5, #0]
 8003fba:	4553      	cmp	r3, sl
 8003fbc:	d90a      	bls.n	8003fd4 <test_execute+0x194>
 8003fbe:	f8df 8110 	ldr.w	r8, [pc, #272]	; 80040d0 <test_execute+0x290>
    streamPut(test_chp, *cp++);
 8003fc2:	6820      	ldr	r0, [r4, #0]
 8003fc4:	f818 1b01 	ldrb.w	r1, [r8], #1
 8003fc8:	6803      	ldr	r3, [r0, #0]
 8003fca:	689b      	ldr	r3, [r3, #8]
 8003fcc:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8003fce:	682b      	ldr	r3, [r5, #0]
 8003fd0:	4598      	cmp	r8, r3
 8003fd2:	d3f6      	bcc.n	8003fc2 <test_execute+0x182>
 8003fd4:	4d36      	ldr	r5, [pc, #216]	; (80040b0 <test_execute+0x270>)
 8003fd6:	215d      	movs	r1, #93	; 0x5d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8003fd8:	6820      	ldr	r0, [r4, #0]
 8003fda:	6803      	ldr	r3, [r0, #0]
 8003fdc:	689b      	ldr	r3, [r3, #8]
 8003fde:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003fe0:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003fe4:	2900      	cmp	r1, #0
 8003fe6:	d1f7      	bne.n	8003fd8 <test_execute+0x198>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 8003fe8:	4b32      	ldr	r3, [pc, #200]	; (80040b4 <test_execute+0x274>)
 8003fea:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003fec:	7829      	ldrb	r1, [r5, #0]
 8003fee:	b139      	cbz	r1, 8004000 <test_execute+0x1c0>
    streamPut(test_chp, *msgp++);
 8003ff0:	6820      	ldr	r0, [r4, #0]
 8003ff2:	6803      	ldr	r3, [r0, #0]
 8003ff4:	689b      	ldr	r3, [r3, #8]
 8003ff6:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003ff8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8003ffc:	2900      	cmp	r1, #0
 8003ffe:	d1f7      	bne.n	8003ff0 <test_execute+0x1b0>
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
 8004000:	482d      	ldr	r0, [pc, #180]	; (80040b8 <test_execute+0x278>)
 8004002:	f7ff febd 	bl	8003d80 <test_println>
 8004006:	683b      	ldr	r3, [r7, #0]

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8004008:	f853 3026 	ldr.w	r3, [r3, r6, lsl #2]
 800400c:	ea4f 0886 	mov.w	r8, r6, lsl #2
 8004010:	2b00      	cmp	r3, #0
 8004012:	f47f af63 	bne.w	8003edc <test_execute+0x9c>
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8004016:	f857 3f04 	ldr.w	r3, [r7, #4]!
 800401a:	2b00      	cmp	r3, #0
 800401c:	f47f af53 	bne.w	8003ec6 <test_execute+0x86>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 8004020:	f7ff fba6 	bl	8003770 <print_line>
  test_println("");
 8004024:	4d25      	ldr	r5, [pc, #148]	; (80040bc <test_execute+0x27c>)
 8004026:	4813      	ldr	r0, [pc, #76]	; (8004074 <test_execute+0x234>)
 8004028:	f7ff feaa 	bl	8003d80 <test_println>
 800402c:	2146      	movs	r1, #70	; 0x46
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 800402e:	6820      	ldr	r0, [r4, #0]
 8004030:	6803      	ldr	r3, [r0, #0]
 8004032:	689b      	ldr	r3, [r3, #8]
 8004034:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8004036:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800403a:	2900      	cmp	r1, #0
 800403c:	d1f7      	bne.n	800402e <test_execute+0x1ee>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 800403e:	4b16      	ldr	r3, [pc, #88]	; (8004098 <test_execute+0x258>)
 8004040:	781b      	ldrb	r3, [r3, #0]
 8004042:	b95b      	cbnz	r3, 800405c <test_execute+0x21c>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 8004044:	481e      	ldr	r0, [pc, #120]	; (80040c0 <test_execute+0x280>)
 8004046:	f7ff fe9b 	bl	8003d80 <test_println>

#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
 800404a:	4b13      	ldr	r3, [pc, #76]	; (8004098 <test_execute+0x258>)
 800404c:	7818      	ldrb	r0, [r3, #0]
}
 800404e:	b003      	add	sp, #12
 8004050:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else
        test_println("--- Result: SUCCESS");
 8004054:	481b      	ldr	r0, [pc, #108]	; (80040c4 <test_execute+0x284>)
 8004056:	f7ff fe93 	bl	8003d80 <test_println>
 800405a:	e7d4      	b.n	8004006 <test_execute+0x1c6>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 800405c:	481a      	ldr	r0, [pc, #104]	; (80040c8 <test_execute+0x288>)
 800405e:	f7ff fe8f 	bl	8003d80 <test_println>

#if defined(TEST_REPORT_HOOK_END)
  TEST_REPORT_HOOK_END
#endif

  return (msg_t)test_global_fail;
 8004062:	4b0d      	ldr	r3, [pc, #52]	; (8004098 <test_execute+0x258>)
 8004064:	7818      	ldrb	r0, [r3, #0]
}
 8004066:	b003      	add	sp, #12
 8004068:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 800406c:	20000f8c 	.word	0x20000f8c
 8004070:	080085b8 	.word	0x080085b8
 8004074:	08007dd8 	.word	0x08007dd8
 8004078:	08008638 	.word	0x08008638
 800407c:	08008654 	.word	0x08008654
 8004080:	0800867c 	.word	0x0800867c
 8004084:	080085cc 	.word	0x080085cc
 8004088:	08007be8 	.word	0x08007be8
 800408c:	080085e0 	.word	0x080085e0
 8004090:	08007c18 	.word	0x08007c18
 8004094:	20000808 	.word	0x20000808
 8004098:	2000135c 	.word	0x2000135c
 800409c:	080085f4 	.word	0x080085f4
 80040a0:	08008604 	.word	0x08008604
 80040a4:	08008658 	.word	0x08008658
 80040a8:	20000f78 	.word	0x20000f78
 80040ac:	20000f5c 	.word	0x20000f5c
 80040b0:	08008624 	.word	0x08008624
 80040b4:	2000134c 	.word	0x2000134c
 80040b8:	0800865c 	.word	0x0800865c
 80040bc:	08008628 	.word	0x08008628
 80040c0:	0800866c 	.word	0x0800866c
 80040c4:	08008660 	.word	0x08008660
 80040c8:	08008674 	.word	0x08008674
 80040cc:	20001318 	.word	0x20001318
 80040d0:	20000f7c 	.word	0x20000f7c
 80040d4:	08008608 	.word	0x08008608
 80040d8:	08008620 	.word	0x08008620
 80040dc:	f3af 8000 	nop.w

080040e0 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(msg);
  return false;
}

bool _test_assert_sequence(char *expected, const char *msg) {
 80040e0:	b4f0      	push	{r4, r5, r6, r7}
 80040e2:	4e0d      	ldr	r6, [pc, #52]	; (8004118 <_test_assert_sequence+0x38>)
  char *cp = test_tokens_buffer;
 80040e4:	4f0d      	ldr	r7, [pc, #52]	; (800411c <_test_assert_sequence+0x3c>)
 80040e6:	6835      	ldr	r5, [r6, #0]
 80040e8:	463b      	mov	r3, r7
 80040ea:	e005      	b.n	80040f8 <_test_assert_sequence+0x18>

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
 80040ec:	f813 4b01 	ldrb.w	r4, [r3], #1
 80040f0:	f810 2b01 	ldrb.w	r2, [r0], #1
 80040f4:	4294      	cmp	r4, r2
 80040f6:	d106      	bne.n	8004106 <_test_assert_sequence+0x26>
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 80040f8:	42ab      	cmp	r3, r5
 80040fa:	d3f7      	bcc.n	80040ec <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 80040fc:	7800      	ldrb	r0, [r0, #0]
 80040fe:	b910      	cbnz	r0, 8004106 <_test_assert_sequence+0x26>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8004100:	6037      	str	r7, [r6, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 8004102:	bcf0      	pop	{r4, r5, r6, r7}
 8004104:	4770      	bx	lr
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8004106:	4c06      	ldr	r4, [pc, #24]	; (8004120 <_test_assert_sequence+0x40>)
  test_global_fail     = true;
 8004108:	4a06      	ldr	r2, [pc, #24]	; (8004124 <_test_assert_sequence+0x44>)
  test_failure_message = msg;
 800410a:	4b07      	ldr	r3, [pc, #28]	; (8004128 <_test_assert_sequence+0x48>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 800410c:	2001      	movs	r0, #1
 800410e:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8004110:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8004112:	6019      	str	r1, [r3, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 8004114:	bcf0      	pop	{r4, r5, r6, r7}
 8004116:	4770      	bx	lr
 8004118:	20000f78 	.word	0x20000f78
 800411c:	20000f7c 	.word	0x20000f7c
 8004120:	20001318 	.word	0x20001318
 8004124:	2000135c 	.word	0x2000135c
 8004128:	2000134c 	.word	0x2000134c
 800412c:	f3af 8000 	nop.w

08004130 <_test_assert>:
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8004130:	b950      	cbnz	r0, 8004148 <_test_assert+0x18>
  test_global_fail     = true;
  test_failure_message = msg;
  return true;
}

bool _test_assert(bool condition, const char *msg) {
 8004132:	b410      	push	{r4}
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
 8004134:	4a05      	ldr	r2, [pc, #20]	; (800414c <_test_assert+0x1c>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8004136:	4c06      	ldr	r4, [pc, #24]	; (8004150 <_test_assert+0x20>)
  test_global_fail     = true;
  test_failure_message = msg;
 8004138:	4b06      	ldr	r3, [pc, #24]	; (8004154 <_test_assert+0x24>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 800413a:	2001      	movs	r0, #1
 800413c:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 800413e:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8004140:	6019      	str	r1, [r3, #0]
bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
}
 8004142:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004146:	4770      	bx	lr

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 8004148:	2000      	movs	r0, #0
 800414a:	4770      	bx	lr
 800414c:	2000135c 	.word	0x2000135c
 8004150:	20001318 	.word	0x20001318
 8004154:	2000134c 	.word	0x2000134c
 8004158:	f3af 8000 	nop.w
 800415c:	f3af 8000 	nop.w

08004160 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8004160:	4924      	ldr	r1, [pc, #144]	; (80041f4 <__early_init+0x94>)
 8004162:	680b      	ldr	r3, [r1, #0]
 8004164:	f043 0301 	orr.w	r3, r3, #1
 8004168:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 800416a:	680a      	ldr	r2, [r1, #0]
 800416c:	4b21      	ldr	r3, [pc, #132]	; (80041f4 <__early_init+0x94>)
 800416e:	0790      	lsls	r0, r2, #30
 8004170:	d5fb      	bpl.n	800416a <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8004172:	685a      	ldr	r2, [r3, #4]
 8004174:	f022 0203 	bic.w	r2, r2, #3
 8004178:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 800417a:	685a      	ldr	r2, [r3, #4]
 800417c:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 800417e:	4619      	mov	r1, r3
 8004180:	684b      	ldr	r3, [r1, #4]
 8004182:	4a1c      	ldr	r2, [pc, #112]	; (80041f4 <__early_init+0x94>)
 8004184:	f013 030c 	ands.w	r3, r3, #12
 8004188:	d1fa      	bne.n	8004180 <__early_init+0x20>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 800418a:	6811      	ldr	r1, [r2, #0]
 800418c:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 8004190:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8004192:	6053      	str	r3, [r2, #4]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 8004194:	6813      	ldr	r3, [r2, #0]
 8004196:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 800419a:	6013      	str	r3, [r2, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 800419c:	6811      	ldr	r1, [r2, #0]
 800419e:	4b15      	ldr	r3, [pc, #84]	; (80041f4 <__early_init+0x94>)
 80041a0:	0389      	lsls	r1, r1, #14
 80041a2:	d5fb      	bpl.n	800419c <__early_init+0x3c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80041a4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80041a6:	f042 0201 	orr.w	r2, r2, #1
 80041aa:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80041ac:	461a      	mov	r2, r3
 80041ae:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80041b0:	4b10      	ldr	r3, [pc, #64]	; (80041f4 <__early_init+0x94>)
 80041b2:	0788      	lsls	r0, r1, #30
 80041b4:	d5fb      	bpl.n	80041ae <__early_init+0x4e>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 80041b6:	4a10      	ldr	r2, [pc, #64]	; (80041f8 <__early_init+0x98>)
 80041b8:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 80041ba:	f44f 5104 	mov.w	r1, #8448	; 0x2100
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 80041be:	2230      	movs	r2, #48	; 0x30

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 80041c0:	62d9      	str	r1, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 80041c2:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 80041c4:	681a      	ldr	r2, [r3, #0]
 80041c6:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 80041ca:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 80041cc:	6819      	ldr	r1, [r3, #0]
 80041ce:	4a09      	ldr	r2, [pc, #36]	; (80041f4 <__early_init+0x94>)
 80041d0:	0189      	lsls	r1, r1, #6
 80041d2:	d5fb      	bpl.n	80041cc <__early_init+0x6c>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 80041d4:	4b09      	ldr	r3, [pc, #36]	; (80041fc <__early_init+0x9c>)
 80041d6:	2112      	movs	r1, #18
 80041d8:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 80041da:	6853      	ldr	r3, [r2, #4]
 80041dc:	f043 0302 	orr.w	r3, r3, #2
 80041e0:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80041e2:	6853      	ldr	r3, [r2, #4]
 80041e4:	4903      	ldr	r1, [pc, #12]	; (80041f4 <__early_init+0x94>)
 80041e6:	f003 030c 	and.w	r3, r3, #12
 80041ea:	2b08      	cmp	r3, #8
 80041ec:	d1f9      	bne.n	80041e2 <__early_init+0x82>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 80041ee:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 80041f0:	630b      	str	r3, [r1, #48]	; 0x30
 80041f2:	4770      	bx	lr
 80041f4:	40021000 	.word	0x40021000
 80041f8:	001d2400 	.word	0x001d2400
 80041fc:	40022000 	.word	0x40022000

08004200 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8004200:	b508      	push	{r3, lr}
 8004202:	2220      	movs	r2, #32
 8004204:	4603      	mov	r3, r0
 8004206:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 800420a:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 800420c:	b128      	cbz	r0, 800421a <chPoolAlloc+0x1a>
    mp->next = mp->next->next;
 800420e:	6802      	ldr	r2, [r0, #0]
 8004210:	601a      	str	r2, [r3, #0]
 8004212:	2300      	movs	r3, #0
 8004214:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8004218:	bd08      	pop	{r3, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 800421a:	689a      	ldr	r2, [r3, #8]
 800421c:	2a00      	cmp	r2, #0
 800421e:	d0f8      	beq.n	8004212 <chPoolAlloc+0x12>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8004220:	6858      	ldr	r0, [r3, #4]
 8004222:	2104      	movs	r1, #4
 8004224:	4790      	blx	r2
 8004226:	2300      	movs	r3, #0
 8004228:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 800422c:	bd08      	pop	{r3, pc}
 800422e:	bf00      	nop

08004230 <chHeapStatus>:
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8004230:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 8004234:	4b16      	ldr	r3, [pc, #88]	; (8004290 <chHeapStatus+0x60>)
 8004236:	2800      	cmp	r0, #0
 8004238:	bf14      	ite	ne
 800423a:	4604      	movne	r4, r0
 800423c:	461c      	moveq	r4, r3
  }

  H_LOCK(heapp);
 800423e:	f104 0710 	add.w	r7, r4, #16
  tpages = 0U;
  lpages = 0U;
 8004242:	2500      	movs	r5, #0

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8004244:	4638      	mov	r0, r7
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8004246:	4689      	mov	r9, r1
 8004248:	4690      	mov	r8, r2
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
 800424a:	462e      	mov	r6, r5

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 800424c:	f002 f8b8 	bl	80063c0 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
 8004250:	f104 0308 	add.w	r3, r4, #8
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
 8004254:	462c      	mov	r4, r5
 8004256:	e006      	b.n	8004266 <chHeapStatus+0x36>
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    size_t pages = H_PAGES(H_NEXT(qp));
 8004258:	6858      	ldr	r0, [r3, #4]
 800425a:	4285      	cmp	r5, r0

    /* Updating counters.*/
    n++;
 800425c:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 8004260:	4404      	add	r4, r0
 8004262:	bf38      	it	cc
 8004264:	4605      	movcc	r5, r0
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8004266:	681b      	ldr	r3, [r3, #0]
 8004268:	2b00      	cmp	r3, #0
 800426a:	d1f5      	bne.n	8004258 <chHeapStatus+0x28>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 800426c:	f1b9 0f00 	cmp.w	r9, #0
 8004270:	d002      	beq.n	8004278 <chHeapStatus+0x48>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 8004272:	00e4      	lsls	r4, r4, #3
 8004274:	f8c9 4000 	str.w	r4, [r9]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 8004278:	f1b8 0f00 	cmp.w	r8, #0
 800427c:	d002      	beq.n	8004284 <chHeapStatus+0x54>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 800427e:	00ed      	lsls	r5, r5, #3
 8004280:	f8c8 5000 	str.w	r5, [r8]
  }
  H_UNLOCK(heapp);
 8004284:	4638      	mov	r0, r7
 8004286:	f001 fffb 	bl	8006280 <chMtxUnlock>

  return n;
}
 800428a:	4630      	mov	r0, r6
 800428c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004290:	20001320 	.word	0x20001320
 8004294:	f3af 8000 	nop.w
 8004298:	f3af 8000 	nop.w
 800429c:	f3af 8000 	nop.w

080042a0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80042a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80042a2:	f850 3c04 	ldr.w	r3, [r0, #-4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80042a6:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80042aa:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80042ac:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80042ae:	f105 0710 	add.w	r7, r5, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80042b2:	f840 3c04 	str.w	r3, [r0, #-4]
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80042b6:	4606      	mov	r6, r0
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 80042b8:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80042bc:	3508      	adds	r5, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80042be:	4638      	mov	r0, r7
 80042c0:	f002 f87e 	bl	80063c0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 80042c4:	462b      	mov	r3, r5
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80042c6:	42ab      	cmp	r3, r5
 80042c8:	d004      	beq.n	80042d4 <chHeapFree+0x34>
 80042ca:	42a3      	cmp	r3, r4
 80042cc:	d302      	bcc.n	80042d4 <chHeapFree+0x34>
 80042ce:	681b      	ldr	r3, [r3, #0]
 80042d0:	42ab      	cmp	r3, r5
 80042d2:	d1fa      	bne.n	80042ca <chHeapFree+0x2a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80042d4:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 80042d6:	b11a      	cbz	r2, 80042e0 <chHeapFree+0x40>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 80042d8:	4294      	cmp	r4, r2
 80042da:	d301      	bcc.n	80042e0 <chHeapFree+0x40>
 80042dc:	4613      	mov	r3, r2
 80042de:	e7f2      	b.n	80042c6 <chHeapFree+0x26>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80042e0:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 80042e4:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 80042e8:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 80042ea:	1c4a      	adds	r2, r1, #1
 80042ec:	f856 5c08 	ldr.w	r5, [r6, #-8]
 80042f0:	eb04 00c2 	add.w	r0, r4, r2, lsl #3
 80042f4:	42a8      	cmp	r0, r5
 80042f6:	d00a      	beq.n	800430e <chHeapFree+0x6e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 80042f8:	6859      	ldr	r1, [r3, #4]
 80042fa:	1c4a      	adds	r2, r1, #1
 80042fc:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004300:	4294      	cmp	r4, r2
 8004302:	d013      	beq.n	800432c <chHeapFree+0x8c>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8004304:	4638      	mov	r0, r7

  return;
}
 8004306:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800430a:	f001 bfb9 	b.w	8006280 <chMtxUnlock>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800430e:	6840      	ldr	r0, [r0, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8004310:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 8004314:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8004318:	180a      	adds	r2, r1, r0
 800431a:	3201      	adds	r2, #1
 800431c:	f846 2c04 	str.w	r2, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8004320:	6859      	ldr	r1, [r3, #4]
 8004322:	1c4a      	adds	r2, r1, #1
 8004324:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004328:	4294      	cmp	r4, r2
 800432a:	d1eb      	bne.n	8004304 <chHeapFree+0x64>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
 800432c:	e916 0005 	ldmdb	r6, {r0, r2}
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004330:	440a      	add	r2, r1
 8004332:	3201      	adds	r2, #1
        H_NEXT(qp) = H_NEXT(hp);
 8004334:	6018      	str	r0, [r3, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004336:	605a      	str	r2, [r3, #4]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8004338:	4638      	mov	r0, r7

  return;
}
 800433a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800433e:	f001 bf9f 	b.w	8006280 <chMtxUnlock>
 8004342:	bf00      	nop
 8004344:	f3af 8000 	nop.w
 8004348:	f3af 8000 	nop.w
 800434c:	f3af 8000 	nop.w

08004350 <chThdCreateFromHeap>:
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
 8004350:	b570      	push	{r4, r5, r6, lr}
 8004352:	b086      	sub	sp, #24
 8004354:	4616      	mov	r6, r2
 8004356:	461d      	mov	r5, r3
 8004358:	460c      	mov	r4, r1
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 800435a:	f003 f849 	bl	80073f0 <chHeapAllocAligned.constprop.40>
  if (wsp == NULL) {
 800435e:	b1c8      	cbz	r0, 8004394 <chThdCreateFromHeap+0x44>
    return NULL;
  }

  thread_descriptor_t td = {
 8004360:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8004362:	9304      	str	r3, [sp, #16]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 8004364:	4404      	add	r4, r0
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8004366:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8004368:	9305      	str	r3, [sp, #20]
 800436a:	9402      	str	r4, [sp, #8]
 800436c:	9600      	str	r6, [sp, #0]
 800436e:	9001      	str	r0, [sp, #4]
 8004370:	9503      	str	r5, [sp, #12]
 8004372:	2320      	movs	r3, #32
 8004374:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8004378:	4668      	mov	r0, sp
 800437a:	f001 fde9 	bl	8005f50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 800437e:	2301      	movs	r3, #1
 8004380:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8004384:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8004386:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8004388:	f001 fe8a 	bl	80060a0 <chSchWakeupS>
 800438c:	2300      	movs	r3, #0
 800438e:	f383 8811 	msr	BASEPRI, r3
 8004392:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 8004394:	b006      	add	sp, #24
 8004396:	bd70      	pop	{r4, r5, r6, pc}
 8004398:	f3af 8000 	nop.w
 800439c:	f3af 8000 	nop.w

080043a0 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 80043a0:	b510      	push	{r4, lr}
 80043a2:	2320      	movs	r3, #32
 80043a4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 80043a8:	4c0c      	ldr	r4, [pc, #48]	; (80043dc <chMsgWait+0x3c>)
 80043aa:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 80043ac:	4613      	mov	r3, r2
 80043ae:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 80043b2:	4298      	cmp	r0, r3
 80043b4:	d009      	beq.n	80043ca <chMsgWait+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80043b6:	6801      	ldr	r1, [r0, #0]
 80043b8:	62d1      	str	r1, [r2, #44]	; 0x2c
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 80043ba:	220d      	movs	r2, #13
  tqp->next->queue.prev = (thread_t *)tqp;
 80043bc:	604b      	str	r3, [r1, #4]
 80043be:	2300      	movs	r3, #0
 80043c0:	f880 2020 	strb.w	r2, [r0, #32]
 80043c4:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 80043c8:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 80043ca:	200e      	movs	r0, #14
 80043cc:	f001 feb8 	bl	8006140 <chSchGoSleepS>
 80043d0:	69a2      	ldr	r2, [r4, #24]
 80043d2:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80043d4:	f102 032c 	add.w	r3, r2, #44	; 0x2c
 80043d8:	e7ed      	b.n	80043b6 <chMsgWait+0x16>
 80043da:	bf00      	nop
 80043dc:	200012a0 	.word	0x200012a0

080043e0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80043e0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80043e2:	4b0e      	ldr	r3, [pc, #56]	; (800441c <chMsgSend+0x3c>)
 80043e4:	2220      	movs	r2, #32
 80043e6:	699c      	ldr	r4, [r3, #24]
 80043e8:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
 80043ec:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
 80043ee:	f890 1020 	ldrb.w	r1, [r0, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80043f2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80043f4:	6062      	str	r2, [r4, #4]

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
 80043f6:	f100 052c 	add.w	r5, r0, #44	; 0x2c
  if (tp->state == CH_STATE_WTMSG) {
 80043fa:	290e      	cmp	r1, #14
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 80043fc:	6025      	str	r5, [r4, #0]
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 80043fe:	6014      	str	r4, [r2, #0]
  tqp->prev                  = tp;
 8004400:	6304      	str	r4, [r0, #48]	; 0x30
 8004402:	d007      	beq.n	8004414 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8004404:	200c      	movs	r0, #12
 8004406:	f001 fe9b 	bl	8006140 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 800440a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800440c:	2300      	movs	r3, #0
 800440e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8004412:	bd38      	pop	{r3, r4, r5, pc}

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8004414:	f001 fef4 	bl	8006200 <chSchReadyI>
 8004418:	e7f4      	b.n	8004404 <chMsgSend+0x24>
 800441a:	bf00      	nop
 800441c:	200012a0 	.word	0x200012a0

08004420 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004420:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004422:	f890 2020 	ldrb.w	r2, [r0, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004426:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004428:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 800442a:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800442c:	d00a      	beq.n	8004444 <chEvtSignalI+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800442e:	2a0b      	cmp	r2, #11
 8004430:	d000      	beq.n	8004434 <chEvtSignalI+0x14>
 8004432:	4770      	bx	lr
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004434:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004436:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004438:	428b      	cmp	r3, r1
 800443a:	d1fa      	bne.n	8004432 <chEvtSignalI+0x12>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800443c:	2300      	movs	r3, #0
 800443e:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004440:	f001 bede 	b.w	8006200 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004444:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004446:	4219      	tst	r1, r3
 8004448:	d1f8      	bne.n	800443c <chEvtSignalI+0x1c>
 800444a:	4770      	bx	lr
 800444c:	f3af 8000 	nop.w

08004450 <test_005_009_setup.lto_priv.150>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004450:	4a06      	ldr	r2, [pc, #24]	; (800446c <test_005_009_setup.lto_priv.150+0x1c>)
 8004452:	4b07      	ldr	r3, [pc, #28]	; (8004470 <test_005_009_setup.lto_priv.150+0x20>)
 8004454:	4907      	ldr	r1, [pc, #28]	; (8004474 <test_005_009_setup.lto_priv.150+0x24>)
 8004456:	6012      	str	r2, [r2, #0]
 8004458:	2000      	movs	r0, #0
 800445a:	6009      	str	r1, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 800445c:	6049      	str	r1, [r1, #4]
 800445e:	6052      	str	r2, [r2, #4]
 8004460:	6090      	str	r0, [r2, #8]
 8004462:	6098      	str	r0, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004464:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004466:	605b      	str	r3, [r3, #4]
 8004468:	4770      	bx	lr
 800446a:	bf00      	nop
 800446c:	20000858 	.word	0x20000858
 8004470:	2000083c 	.word	0x2000083c
 8004474:	200008a8 	.word	0x200008a8
 8004478:	f3af 8000 	nop.w
 800447c:	f3af 8000 	nop.w

08004480 <test_005_008_setup.lto_priv.148>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004480:	4b04      	ldr	r3, [pc, #16]	; (8004494 <test_005_008_setup.lto_priv.148+0x14>)
 8004482:	4a05      	ldr	r2, [pc, #20]	; (8004498 <test_005_008_setup.lto_priv.148+0x18>)
 8004484:	601b      	str	r3, [r3, #0]
 8004486:	2100      	movs	r1, #0
 8004488:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 800448a:	6052      	str	r2, [r2, #4]
 800448c:	605b      	str	r3, [r3, #4]
 800448e:	6099      	str	r1, [r3, #8]
 8004490:	4770      	bx	lr
 8004492:	bf00      	nop
 8004494:	20000858 	.word	0x20000858
 8004498:	200008a8 	.word	0x200008a8
 800449c:	f3af 8000 	nop.w

080044a0 <test_005_007_setup.lto_priv.146>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80044a0:	4b04      	ldr	r3, [pc, #16]	; (80044b4 <test_005_007_setup.lto_priv.146+0x14>)
 80044a2:	4a05      	ldr	r2, [pc, #20]	; (80044b8 <test_005_007_setup.lto_priv.146+0x18>)
 80044a4:	601b      	str	r3, [r3, #0]
 80044a6:	2100      	movs	r1, #0
 80044a8:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 80044aa:	6052      	str	r2, [r2, #4]
 80044ac:	605b      	str	r3, [r3, #4]
 80044ae:	6099      	str	r1, [r3, #8]
 80044b0:	4770      	bx	lr
 80044b2:	bf00      	nop
 80044b4:	20000858 	.word	0x20000858
 80044b8:	200008a8 	.word	0x200008a8
 80044bc:	f3af 8000 	nop.w

080044c0 <test_005_005_setup.lto_priv.144>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80044c0:	4b02      	ldr	r3, [pc, #8]	; (80044cc <test_005_005_setup.lto_priv.144+0xc>)
 80044c2:	2200      	movs	r2, #0
 80044c4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80044c6:	605b      	str	r3, [r3, #4]
 80044c8:	609a      	str	r2, [r3, #8]
 80044ca:	4770      	bx	lr
 80044cc:	20000858 	.word	0x20000858

080044d0 <test_005_004_setup.lto_priv.141>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80044d0:	4a04      	ldr	r2, [pc, #16]	; (80044e4 <test_005_004_setup.lto_priv.141+0x14>)
 80044d2:	4b05      	ldr	r3, [pc, #20]	; (80044e8 <test_005_004_setup.lto_priv.141+0x18>)
 80044d4:	6012      	str	r2, [r2, #0]
 80044d6:	2100      	movs	r1, #0
  tqp->prev = (thread_t *)tqp;
 80044d8:	6052      	str	r2, [r2, #4]
 80044da:	6091      	str	r1, [r2, #8]
 80044dc:	6099      	str	r1, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80044de:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80044e0:	605b      	str	r3, [r3, #4]
 80044e2:	4770      	bx	lr
 80044e4:	20000858 	.word	0x20000858
 80044e8:	2000083c 	.word	0x2000083c
 80044ec:	f3af 8000 	nop.w

080044f0 <test_005_001_setup.lto_priv.139>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80044f0:	4b02      	ldr	r3, [pc, #8]	; (80044fc <test_005_001_setup.lto_priv.139+0xc>)
 80044f2:	2200      	movs	r2, #0
 80044f4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80044f6:	605b      	str	r3, [r3, #4]
 80044f8:	609a      	str	r2, [r3, #8]
 80044fa:	4770      	bx	lr
 80044fc:	20000858 	.word	0x20000858

08004500 <test_004_005_setup.lto_priv.134>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004500:	4b02      	ldr	r3, [pc, #8]	; (800450c <test_004_005_setup.lto_priv.134+0xc>)
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8004502:	2200      	movs	r2, #0
 8004504:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004506:	605b      	str	r3, [r3, #4]
 8004508:	609a      	str	r2, [r3, #8]
 800450a:	4770      	bx	lr
 800450c:	20001340 	.word	0x20001340

08004510 <test_007_001_execute.lto_priv.153>:
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 8004510:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8004514:	4c36      	ldr	r4, [pc, #216]	; (80045f0 <test_007_001_execute.lto_priv.153+0xe0>)
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8004516:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 8004600 <test_007_001_execute.lto_priv.153+0xf0>
 800451a:	6024      	str	r4, [r4, #0]
 800451c:	2102      	movs	r1, #2
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 800451e:	b08a      	sub	sp, #40	; 0x28
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8004520:	f8c9 1000 	str.w	r1, [r9]
 8004524:	2620      	movs	r6, #32
 8004526:	f386 8811 	msr	BASEPRI, r6
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 800452a:	4832      	ldr	r0, [pc, #200]	; (80045f4 <test_007_001_execute.lto_priv.153+0xe4>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800452c:	6823      	ldr	r3, [r4, #0]
 800452e:	af0a      	add	r7, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8004530:	2201      	movs	r2, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004532:	f847 3d28 	str.w	r3, [r7, #-40]!
  esp->next     = elp;
  elp->listener = currp;
 8004536:	6983      	ldr	r3, [r0, #24]
 8004538:	9301      	str	r3, [sp, #4]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 800453a:	2500      	movs	r5, #0
  elp->wflags   = wflags;
 800453c:	f04f 33ff 	mov.w	r3, #4294967295

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8004540:	9202      	str	r2, [sp, #8]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8004542:	6027      	str	r7, [r4, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8004544:	9503      	str	r5, [sp, #12]
  elp->wflags   = wflags;
 8004546:	9304      	str	r3, [sp, #16]
 8004548:	f385 8811 	msr	BASEPRI, r5
 800454c:	f386 8811 	msr	BASEPRI, r6
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8004550:	f10d 0828 	add.w	r8, sp, #40	; 0x28
 8004554:	6822      	ldr	r2, [r4, #0]
 8004556:	f848 2d14 	str.w	r2, [r8, #-20]!
  esp->next     = elp;
  elp->listener = currp;
 800455a:	6982      	ldr	r2, [r0, #24]
 800455c:	9206      	str	r2, [sp, #24]
  elp->events   = events;
 800455e:	9107      	str	r1, [sp, #28]
  elp->flags    = (eventflags_t)0;
 8004560:	9508      	str	r5, [sp, #32]
  elp->wflags   = wflags;
 8004562:	9309      	str	r3, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8004564:	f8c4 8000 	str.w	r8, [r4]
 8004568:	f385 8811 	msr	BASEPRI, r5
 800456c:	f386 8811 	msr	BASEPRI, r6
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8004570:	6820      	ldr	r0, [r4, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
    chEvtRegisterMask(&es1, &el2, 2);
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8004572:	4921      	ldr	r1, [pc, #132]	; (80045f8 <test_007_001_execute.lto_priv.153+0xe8>)
 8004574:	1b00      	subs	r0, r0, r4
 8004576:	bf18      	it	ne
 8004578:	2001      	movne	r0, #1
 800457a:	f7ff fdd9 	bl	8004130 <_test_assert>
 800457e:	4682      	mov	sl, r0
 8004580:	b120      	cbz	r0, 800458c <test_007_001_execute.lto_priv.153+0x7c>
 8004582:	f385 8811 	msr	BASEPRI, r5
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 8004586:	b00a      	add	sp, #40	; 0x28
 8004588:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800458c:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8004590:	2303      	movs	r3, #3
  {
    chEvtUnregister(&es1, &el1);
 8004592:	4639      	mov	r1, r7
 8004594:	4620      	mov	r0, r4
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8004596:	f8c9 3000 	str.w	r3, [r9]
  {
    chEvtUnregister(&es1, &el1);
 800459a:	f001 fc31 	bl	8005e00 <chEvtUnregister>
 800459e:	f386 8811 	msr	BASEPRI, r6
 80045a2:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 80045a4:	4914      	ldr	r1, [pc, #80]	; (80045f8 <test_007_001_execute.lto_priv.153+0xe8>)
 80045a6:	1b00      	subs	r0, r0, r4
 80045a8:	bf18      	it	ne
 80045aa:	2001      	movne	r0, #1
 80045ac:	f7ff fdc0 	bl	8004130 <_test_assert>
 80045b0:	4605      	mov	r5, r0
 80045b2:	b120      	cbz	r0, 80045be <test_007_001_execute.lto_priv.153+0xae>
 80045b4:	f38a 8811 	msr	BASEPRI, sl
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 80045b8:	b00a      	add	sp, #40	; 0x28
 80045ba:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80045be:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 80045c2:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el2);
 80045c4:	4641      	mov	r1, r8
 80045c6:	4620      	mov	r0, r4
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 80045c8:	f8c9 3000 	str.w	r3, [r9]
  {
    chEvtUnregister(&es1, &el2);
 80045cc:	f001 fc18 	bl	8005e00 <chEvtUnregister>
 80045d0:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 80045d4:	6820      	ldr	r0, [r4, #0]
 80045d6:	4909      	ldr	r1, [pc, #36]	; (80045fc <test_007_001_execute.lto_priv.153+0xec>)
 80045d8:	1b00      	subs	r0, r0, r4
 80045da:	fab0 f080 	clz	r0, r0
 80045de:	0940      	lsrs	r0, r0, #5
 80045e0:	f7ff fda6 	bl	8004130 <_test_assert>
 80045e4:	2800      	cmp	r0, #0
 80045e6:	d1cc      	bne.n	8004582 <test_007_001_execute.lto_priv.153+0x72>
 80045e8:	f380 8811 	msr	BASEPRI, r0
 80045ec:	e7cb      	b.n	8004586 <test_007_001_execute.lto_priv.153+0x76>
 80045ee:	bf00      	nop
 80045f0:	20000804 	.word	0x20000804
 80045f4:	200012a0 	.word	0x200012a0
 80045f8:	08008d3c 	.word	0x08008d3c
 80045fc:	08007a20 	.word	0x08007a20
 8004600:	20000f5c 	.word	0x20000f5c
 8004604:	f3af 8000 	nop.w
 8004608:	f3af 8000 	nop.w
 800460c:	f3af 8000 	nop.w

08004610 <evt_thread7.lto_priv.96>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(evt_thread7, p) {
 8004610:	b538      	push	{r3, r4, r5, lr}
 8004612:	2520      	movs	r5, #32
 8004614:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8004618:	480b      	ldr	r0, [pc, #44]	; (8004648 <evt_thread7.lto_priv.96+0x38>)
 800461a:	2100      	movs	r1, #0
 800461c:	f001 fbc8 	bl	8005db0 <chEvtBroadcastFlagsI>
 8004620:	2400      	movs	r4, #0
  chSchRescheduleS();
 8004622:	f001 fcfd 	bl	8006020 <chSchRescheduleS>
 8004626:	f384 8811 	msr	BASEPRI, r4

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 800462a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 800462e:	f002 f817 	bl	8006660 <chThdSleep>
 8004632:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8004636:	4805      	ldr	r0, [pc, #20]	; (800464c <evt_thread7.lto_priv.96+0x3c>)
 8004638:	4621      	mov	r1, r4
 800463a:	f001 fbb9 	bl	8005db0 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 800463e:	f001 fcef 	bl	8006020 <chSchRescheduleS>
 8004642:	f384 8811 	msr	BASEPRI, r4
 8004646:	bd38      	pop	{r3, r4, r5, pc}
 8004648:	20000804 	.word	0x20000804
 800464c:	20000800 	.word	0x20000800

08004650 <evt_thread3.lto_priv.97>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 8004650:	b510      	push	{r4, lr}
 8004652:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8004654:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004658:	f002 f802 	bl	8006660 <chThdSleep>
 800465c:	2320      	movs	r3, #32
 800465e:	f383 8811 	msr	BASEPRI, r3
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8004662:	2101      	movs	r1, #1
 8004664:	4620      	mov	r0, r4
 8004666:	f7ff fedb 	bl	8004420 <chEvtSignalI>
  chSchRescheduleS();
 800466a:	f001 fcd9 	bl	8006020 <chSchRescheduleS>
 800466e:	2300      	movs	r3, #0
 8004670:	f383 8811 	msr	BASEPRI, r3
 8004674:	bd10      	pop	{r4, pc}
 8004676:	bf00      	nop
 8004678:	f3af 8000 	nop.w
 800467c:	f3af 8000 	nop.w

08004680 <h3.lto_priv.100>:
static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8004680:	2043      	movs	r0, #67	; 0x43
 8004682:	f7ff bb65 	b.w	8003d50 <test_emit_token>
 8004686:	bf00      	nop
 8004688:	f3af 8000 	nop.w
 800468c:	f3af 8000 	nop.w

08004690 <h2.lto_priv.99>:

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8004690:	2042      	movs	r0, #66	; 0x42
 8004692:	f7ff bb5d 	b.w	8003d50 <test_emit_token>
 8004696:	bf00      	nop
 8004698:	f3af 8000 	nop.w
 800469c:	f3af 8000 	nop.w

080046a0 <h1.lto_priv.98>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 80046a0:	2041      	movs	r0, #65	; 0x41
 80046a2:	f7ff bb55 	b.w	8003d50 <test_emit_token>
 80046a6:	bf00      	nop
 80046a8:	f3af 8000 	nop.w
 80046ac:	f3af 8000 	nop.w

080046b0 <test_005_004_teardown.lto_priv.142>:
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_004_teardown(void) {
  test_wait_threads();
 80046b0:	f7fe bd46 	b.w	8003140 <test_wait_threads>
 80046b4:	f3af 8000 	nop.w
 80046b8:	f3af 8000 	nop.w
 80046bc:	f3af 8000 	nop.w

080046c0 <test_004_006_teardown.lto_priv.137>:
 *   must not change from "not taken".
 * .
 */

static void test_004_006_teardown(void) {
  test_wait_threads();
 80046c0:	f7fe bd3e 	b.w	8003140 <test_wait_threads>
 80046c4:	f3af 8000 	nop.w
 80046c8:	f3af 8000 	nop.w
 80046cc:	f3af 8000 	nop.w

080046d0 <test_004_005_teardown.lto_priv.135>:
static void test_004_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_005_teardown(void) {
  test_wait_threads();
 80046d0:	f7fe bd36 	b.w	8003140 <test_wait_threads>
 80046d4:	f3af 8000 	nop.w
 80046d8:	f3af 8000 	nop.w
 80046dc:	f3af 8000 	nop.w

080046e0 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 80046e0:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 80046e2:	2141      	movs	r1, #65	; 0x41

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 80046e4:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 80046e6:	f7ff fe7b 	bl	80043e0 <chMsgSend>
  chMsgSend(p, 'B');
 80046ea:	4620      	mov	r0, r4
 80046ec:	2142      	movs	r1, #66	; 0x42
 80046ee:	f7ff fe77 	bl	80043e0 <chMsgSend>
  chMsgSend(p, 'C');
 80046f2:	4620      	mov	r0, r4
 80046f4:	2143      	movs	r1, #67	; 0x43
 80046f6:	f7ff fe73 	bl	80043e0 <chMsgSend>
  chMsgSend(p, 'D');
 80046fa:	4620      	mov	r0, r4
 80046fc:	2144      	movs	r1, #68	; 0x44
}
 80046fe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(msg_thread1, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  chMsgSend(p, 'D');
 8004702:	f7ff be6d 	b.w	80043e0 <chMsgSend>
 8004706:	bf00      	nop
 8004708:	f3af 8000 	nop.w
 800470c:	f3af 8000 	nop.w

08004710 <test_006_001_execute.lto_priv.152>:
 * - [6.1.1] Starting the messenger thread.
 * - [6.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_006_001_execute(void) {
 8004710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004712:	4b14      	ldr	r3, [pc, #80]	; (8004764 <test_006_001_execute.lto_priv.152+0x54>)
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004714:	4c14      	ldr	r4, [pc, #80]	; (8004768 <test_006_001_execute.lto_priv.152+0x58>)
 8004716:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004718:	4a14      	ldr	r2, [pc, #80]	; (800476c <test_006_001_execute.lto_priv.152+0x5c>)
 800471a:	6899      	ldr	r1, [r3, #8]
 800471c:	4814      	ldr	r0, [pc, #80]	; (8004770 <test_006_001_execute.lto_priv.152+0x60>)
 800471e:	3101      	adds	r1, #1
static void test_006_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8004720:	2501      	movs	r5, #1
 8004722:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8004724:	f002 fd24 	bl	8007170 <chThdCreateStatic.constprop.69>
 8004728:	4a12      	ldr	r2, [pc, #72]	; (8004774 <test_006_001_execute.lto_priv.152+0x64>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 800472a:	2302      	movs	r3, #2
 800472c:	6023      	str	r3, [r4, #0]
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800472e:	6010      	str	r0, [r2, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8004730:	2404      	movs	r4, #4
 8004732:	2720      	movs	r7, #32
 8004734:	2600      	movs	r6, #0
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8004736:	f7ff fe33 	bl	80043a0 <chMsgWait>
 800473a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 800473c:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8004740:	4629      	mov	r1, r5
 8004742:	f001 fcad 	bl	80060a0 <chSchWakeupS>
 8004746:	f386 8811 	msr	BASEPRI, r6
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 800474a:	b2e8      	uxtb	r0, r5
 800474c:	f7ff fb00 	bl	8003d50 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8004750:	3c01      	subs	r4, #1
 8004752:	d1f0      	bne.n	8004736 <test_006_001_execute.lto_priv.152+0x26>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 8004754:	f7fe fcf4 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8004758:	4807      	ldr	r0, [pc, #28]	; (8004778 <test_006_001_execute.lto_priv.152+0x68>)
 800475a:	4908      	ldr	r1, [pc, #32]	; (800477c <test_006_001_execute.lto_priv.152+0x6c>)
  }
}
 800475c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8004760:	f7ff bcbe 	b.w	80040e0 <_test_assert_sequence>
 8004764:	200012a0 	.word	0x200012a0
 8004768:	20000f5c 	.word	0x20000f5c
 800476c:	080046e1 	.word	0x080046e1
 8004770:	200008b0 	.word	0x200008b0
 8004774:	20000f60 	.word	0x20000f60
 8004778:	080079f4 	.word	0x080079f4
 800477c:	0800792c 	.word	0x0800792c

08004780 <test_005_009_execute.lto_priv.151>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_009_execute(void) {
 8004780:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004782:	4b1c      	ldr	r3, [pc, #112]	; (80047f4 <test_005_009_execute.lto_priv.151+0x74>)

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004784:	4e1c      	ldr	r6, [pc, #112]	; (80047f8 <test_005_009_execute.lto_priv.151+0x78>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004786:	699b      	ldr	r3, [r3, #24]
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8004788:	4c1c      	ldr	r4, [pc, #112]	; (80047fc <test_005_009_execute.lto_priv.151+0x7c>)
 800478a:	689f      	ldr	r7, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 800478c:	4a1c      	ldr	r2, [pc, #112]	; (8004800 <test_005_009_execute.lto_priv.151+0x80>)
 800478e:	4b1d      	ldr	r3, [pc, #116]	; (8004804 <test_005_009_execute.lto_priv.151+0x84>)
 8004790:	4d1d      	ldr	r5, [pc, #116]	; (8004808 <test_005_009_execute.lto_priv.151+0x88>)
 8004792:	1c79      	adds	r1, r7, #1
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8004794:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8004798:	4630      	mov	r0, r6
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 800479a:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 800479e:	f002 fce7 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 80047a2:	f04f 0e03 	mov.w	lr, #3

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 80047a6:	6028      	str	r0, [r5, #0]

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80047a8:	1cb9      	adds	r1, r7, #2
 80047aa:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 80047ae:	4a17      	ldr	r2, [pc, #92]	; (800480c <test_005_009_execute.lto_priv.151+0x8c>)
 80047b0:	4b17      	ldr	r3, [pc, #92]	; (8004810 <test_005_009_execute.lto_priv.151+0x90>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 80047b2:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80047b6:	f002 fcdb 	bl	8007170 <chThdCreateStatic.constprop.69>

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80047ba:	1cf9      	adds	r1, r7, #3
 80047bc:	4a15      	ldr	r2, [pc, #84]	; (8004814 <test_005_009_execute.lto_priv.151+0x94>)

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 80047be:	6068      	str	r0, [r5, #4]
  }

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 80047c0:	2704      	movs	r7, #4
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80047c2:	f506 7024 	add.w	r0, r6, #656	; 0x290
 80047c6:	4b14      	ldr	r3, [pc, #80]	; (8004818 <test_005_009_execute.lto_priv.151+0x98>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  }

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 80047c8:	6027      	str	r7, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80047ca:	f002 fcd1 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 80047ce:	2305      	movs	r3, #5

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 80047d0:	60a8      	str	r0, [r5, #8]
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 80047d2:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 80047d4:	f002 fd74 	bl	80072c0 <chCondSignal.constprop.59>
  }

  /* [5.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 80047d8:	2306      	movs	r3, #6
 80047da:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 80047dc:	f002 fd70 	bl	80072c0 <chCondSignal.constprop.59>
  }

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
 80047e0:	2307      	movs	r3, #7
 80047e2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 80047e4:	f7fe fcac 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 80047e8:	480c      	ldr	r0, [pc, #48]	; (800481c <test_005_009_execute.lto_priv.151+0x9c>)
 80047ea:	490d      	ldr	r1, [pc, #52]	; (8004820 <test_005_009_execute.lto_priv.151+0xa0>)
  }
}
 80047ec:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
  {
    test_wait_threads();
    test_assert_sequence("ABC", "invalid sequence");
 80047f0:	f7ff bc76 	b.w	80040e0 <_test_assert_sequence>
 80047f4:	200012a0 	.word	0x200012a0
 80047f8:	200008b0 	.word	0x200008b0
 80047fc:	20000f5c 	.word	0x20000f5c
 8004800:	08004e01 	.word	0x08004e01
 8004804:	08007a10 	.word	0x08007a10
 8004808:	20000f60 	.word	0x20000f60
 800480c:	08004e91 	.word	0x08004e91
 8004810:	0800817c 	.word	0x0800817c
 8004814:	08004831 	.word	0x08004831
 8004818:	08008178 	.word	0x08008178
 800481c:	08007928 	.word	0x08007928
 8004820:	0800792c 	.word	0x0800792c
 8004824:	f3af 8000 	nop.w
 8004828:	f3af 8000 	nop.w
 800482c:	f3af 8000 	nop.w

08004830 <thread9>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8004830:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 8004832:	4c06      	ldr	r4, [pc, #24]	; (800484c <thread9+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8004834:	4605      	mov	r5, r0

  chMtxLock(&m2);
 8004836:	4620      	mov	r0, r4
 8004838:	f001 fdc2 	bl	80063c0 <chMtxLock>
  test_emit_token(*(char *)p);
 800483c:	7828      	ldrb	r0, [r5, #0]
 800483e:	f7ff fa87 	bl	8003d50 <test_emit_token>
  chMtxUnlock(&m2);
 8004842:	4620      	mov	r0, r4
}
 8004844:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread9, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 8004848:	f001 bd1a 	b.w	8006280 <chMtxUnlock>
 800484c:	2000083c 	.word	0x2000083c

08004850 <test_005_004_execute.lto_priv.143>:

static void test_005_004_teardown(void) {
  test_wait_threads();
}

static void test_005_004_execute(void) {
 8004850:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004854:	4d40      	ldr	r5, [pc, #256]	; (8004958 <test_005_004_execute.lto_priv.143+0x108>)
    pa = p + 1;
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8004856:	4e41      	ldr	r6, [pc, #260]	; (800495c <test_005_004_execute.lto_priv.143+0x10c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004858:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800485a:	4a41      	ldr	r2, [pc, #260]	; (8004960 <test_005_004_execute.lto_priv.143+0x110>)
 800485c:	689c      	ldr	r4, [r3, #8]
 800485e:	4841      	ldr	r0, [pc, #260]	; (8004964 <test_005_004_execute.lto_priv.143+0x114>)
 8004860:	4b41      	ldr	r3, [pc, #260]	; (8004968 <test_005_004_execute.lto_priv.143+0x118>)
 8004862:	4f42      	ldr	r7, [pc, #264]	; (800496c <test_005_004_execute.lto_priv.143+0x11c>)
  /* [5.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
 8004864:	f104 0801 	add.w	r8, r4, #1
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8004868:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800486c:	4641      	mov	r1, r8
    pa = p + 1;
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 800486e:	f8c6 e000 	str.w	lr, [r6]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8004872:	f002 fc7d 	bl	8007170 <chThdCreateStatic.constprop.69>
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
    pb = p + 2;
 8004876:	f104 0902 	add.w	r9, r4, #2

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800487a:	4649      	mov	r1, r9
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800487c:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800487e:	4a3c      	ldr	r2, [pc, #240]	; (8004970 <test_005_004_execute.lto_priv.143+0x120>)
 8004880:	4b3c      	ldr	r3, [pc, #240]	; (8004974 <test_005_004_execute.lto_priv.143+0x124>)
 8004882:	483d      	ldr	r0, [pc, #244]	; (8004978 <test_005_004_execute.lto_priv.143+0x128>)
 8004884:	f002 fc74 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8004888:	2303      	movs	r3, #3

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800488a:	6078      	str	r0, [r7, #4]
  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
  {
    chMtxLock(&m1);
 800488c:	483b      	ldr	r0, [pc, #236]	; (800497c <test_005_004_execute.lto_priv.143+0x12c>)
  }

  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 800488e:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 8004890:	f001 fd96 	bl	80063c0 <chMtxLock>
 8004894:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8004896:	493a      	ldr	r1, [pc, #232]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 8004898:	6898      	ldr	r0, [r3, #8]
 800489a:	1a20      	subs	r0, r4, r0
 800489c:	fab0 f080 	clz	r0, r0
 80048a0:	0940      	lsrs	r0, r0, #5
 80048a2:	f7ff fc45 	bl	8004130 <_test_assert>
 80048a6:	b108      	cbz	r0, 80048ac <test_005_004_execute.lto_priv.143+0x5c>
 80048a8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80048ac:	2304      	movs	r3, #4
  {
    chThdSleepMilliseconds(100);
 80048ae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80048b2:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 80048b4:	f001 fed4 	bl	8006660 <chThdSleep>
 80048b8:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80048ba:	4931      	ldr	r1, [pc, #196]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 80048bc:	6898      	ldr	r0, [r3, #8]
 80048be:	ebc0 0008 	rsb	r0, r0, r8
 80048c2:	fab0 f080 	clz	r0, r0
 80048c6:	0940      	lsrs	r0, r0, #5
 80048c8:	f7ff fc32 	bl	8004130 <_test_assert>
 80048cc:	2800      	cmp	r0, #0
 80048ce:	d1eb      	bne.n	80048a8 <test_005_004_execute.lto_priv.143+0x58>
  }

  /* [5.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 80048d0:	2305      	movs	r3, #5
  {
    chMtxLock(&m2);
 80048d2:	482c      	ldr	r0, [pc, #176]	; (8004984 <test_005_004_execute.lto_priv.143+0x134>)
  }

  /* [5.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 80048d4:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m2);
 80048d6:	f001 fd73 	bl	80063c0 <chMtxLock>
 80048da:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80048dc:	4928      	ldr	r1, [pc, #160]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 80048de:	6898      	ldr	r0, [r3, #8]
 80048e0:	ebc0 0008 	rsb	r0, r0, r8
 80048e4:	fab0 f080 	clz	r0, r0
 80048e8:	0940      	lsrs	r0, r0, #5
 80048ea:	f7ff fc21 	bl	8004130 <_test_assert>
 80048ee:	2800      	cmp	r0, #0
 80048f0:	d1da      	bne.n	80048a8 <test_005_004_execute.lto_priv.143+0x58>
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 80048f2:	2306      	movs	r3, #6
  {
    chThdSleepMilliseconds(100);
 80048f4:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 80048f8:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 80048fa:	f001 feb1 	bl	8006660 <chThdSleep>
 80048fe:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8004900:	491f      	ldr	r1, [pc, #124]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 8004902:	6898      	ldr	r0, [r3, #8]
 8004904:	ebc0 0009 	rsb	r0, r0, r9
 8004908:	fab0 f080 	clz	r0, r0
 800490c:	0940      	lsrs	r0, r0, #5
 800490e:	f7ff fc0f 	bl	8004130 <_test_assert>
 8004912:	2800      	cmp	r0, #0
 8004914:	d1c8      	bne.n	80048a8 <test_005_004_execute.lto_priv.143+0x58>
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8004916:	2307      	movs	r3, #7
  {
    chMtxUnlock(&m2);
 8004918:	481a      	ldr	r0, [pc, #104]	; (8004984 <test_005_004_execute.lto_priv.143+0x134>)
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 800491a:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m2);
 800491c:	f001 fcb0 	bl	8006280 <chMtxUnlock>
 8004920:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8004922:	4917      	ldr	r1, [pc, #92]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 8004924:	6898      	ldr	r0, [r3, #8]
 8004926:	ebc0 0008 	rsb	r0, r0, r8
 800492a:	fab0 f080 	clz	r0, r0
 800492e:	0940      	lsrs	r0, r0, #5
 8004930:	f7ff fbfe 	bl	8004130 <_test_assert>
 8004934:	2800      	cmp	r0, #0
 8004936:	d1b7      	bne.n	80048a8 <test_005_004_execute.lto_priv.143+0x58>
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8004938:	2308      	movs	r3, #8
  {
    chMtxUnlock(&m1);
 800493a:	4810      	ldr	r0, [pc, #64]	; (800497c <test_005_004_execute.lto_priv.143+0x12c>)
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 800493c:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 800493e:	f001 fc9f 	bl	8006280 <chMtxUnlock>
 8004942:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8004944:	490e      	ldr	r1, [pc, #56]	; (8004980 <test_005_004_execute.lto_priv.143+0x130>)
 8004946:	6898      	ldr	r0, [r3, #8]
 8004948:	1a20      	subs	r0, r4, r0
  }
}
 800494a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
  {
    chMtxUnlock(&m1);
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 800494e:	fab0 f080 	clz	r0, r0
 8004952:	0940      	lsrs	r0, r0, #5
 8004954:	f7ff bbec 	b.w	8004130 <_test_assert>
 8004958:	200012a0 	.word	0x200012a0
 800495c:	20000f5c 	.word	0x20000f5c
 8004960:	08004991 	.word	0x08004991
 8004964:	200008b0 	.word	0x200008b0
 8004968:	08007a10 	.word	0x08007a10
 800496c:	20000f60 	.word	0x20000f60
 8004970:	08004dd1 	.word	0x08004dd1
 8004974:	08008178 	.word	0x08008178
 8004978:	200009f8 	.word	0x200009f8
 800497c:	20000858 	.word	0x20000858
 8004980:	08008d48 	.word	0x08008d48
 8004984:	2000083c 	.word	0x2000083c
 8004988:	f3af 8000 	nop.w
 800498c:	f3af 8000 	nop.w

08004990 <thread4A>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 8004990:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
 8004992:	4c06      	ldr	r4, [pc, #24]	; (80049ac <thread4A+0x1c>)
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 8004994:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8004998:	f001 fe62 	bl	8006660 <chThdSleep>
  chMtxLock(&m1);
 800499c:	4620      	mov	r0, r4
 800499e:	f001 fd0f 	bl	80063c0 <chMtxLock>
  chMtxUnlock(&m1);
 80049a2:	4620      	mov	r0, r4
}
 80049a4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 80049a8:	f001 bc6a 	b.w	8006280 <chMtxUnlock>
 80049ac:	20000858 	.word	0x20000858

080049b0 <test_005_001_execute.lto_priv.140>:

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 80049b0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80049b2:	4f24      	ldr	r7, [pc, #144]	; (8004a44 <test_005_001_execute.lto_priv.140+0x94>)
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80049b4:	4e24      	ldr	r6, [pc, #144]	; (8004a48 <test_005_001_execute.lto_priv.140+0x98>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80049b6:	69bb      	ldr	r3, [r7, #24]
  {
    chMtxLock(&m1);
 80049b8:	4824      	ldr	r0, [pc, #144]	; (8004a4c <test_005_001_execute.lto_priv.140+0x9c>)
 80049ba:	689c      	ldr	r4, [r3, #8]
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80049bc:	4d24      	ldr	r5, [pc, #144]	; (8004a50 <test_005_001_execute.lto_priv.140+0xa0>)
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80049be:	2302      	movs	r3, #2
 80049c0:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 80049c2:	f001 fcfd 	bl	80063c0 <chMtxLock>
  }

  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80049c6:	f04f 0e03 	mov.w	lr, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80049ca:	1c61      	adds	r1, r4, #1
 80049cc:	4a21      	ldr	r2, [pc, #132]	; (8004a54 <test_005_001_execute.lto_priv.140+0xa4>)
 80049ce:	4b22      	ldr	r3, [pc, #136]	; (8004a58 <test_005_001_execute.lto_priv.140+0xa8>)
 80049d0:	4822      	ldr	r0, [pc, #136]	; (8004a5c <test_005_001_execute.lto_priv.140+0xac>)
  }

  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80049d2:	f8c6 e000 	str.w	lr, [r6]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80049d6:	f002 fbcb 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80049da:	1ca1      	adds	r1, r4, #2
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80049dc:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80049de:	4a1d      	ldr	r2, [pc, #116]	; (8004a54 <test_005_001_execute.lto_priv.140+0xa4>)
 80049e0:	4b1f      	ldr	r3, [pc, #124]	; (8004a60 <test_005_001_execute.lto_priv.140+0xb0>)
 80049e2:	4820      	ldr	r0, [pc, #128]	; (8004a64 <test_005_001_execute.lto_priv.140+0xb4>)
 80049e4:	f002 fbc4 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80049e8:	1ce1      	adds	r1, r4, #3
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80049ea:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80049ec:	4a19      	ldr	r2, [pc, #100]	; (8004a54 <test_005_001_execute.lto_priv.140+0xa4>)
 80049ee:	4b1e      	ldr	r3, [pc, #120]	; (8004a68 <test_005_001_execute.lto_priv.140+0xb8>)
 80049f0:	481e      	ldr	r0, [pc, #120]	; (8004a6c <test_005_001_execute.lto_priv.140+0xbc>)
 80049f2:	f002 fbbd 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80049f6:	1d21      	adds	r1, r4, #4
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80049f8:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 80049fa:	4a16      	ldr	r2, [pc, #88]	; (8004a54 <test_005_001_execute.lto_priv.140+0xa4>)
 80049fc:	4b1c      	ldr	r3, [pc, #112]	; (8004a70 <test_005_001_execute.lto_priv.140+0xc0>)
 80049fe:	481d      	ldr	r0, [pc, #116]	; (8004a74 <test_005_001_execute.lto_priv.140+0xc4>)
 8004a00:	f002 fbb6 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8004a04:	1d61      	adds	r1, r4, #5
 8004a06:	4a13      	ldr	r2, [pc, #76]	; (8004a54 <test_005_001_execute.lto_priv.140+0xa4>)
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8004a08:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8004a0a:	4b1b      	ldr	r3, [pc, #108]	; (8004a78 <test_005_001_execute.lto_priv.140+0xc8>)
 8004a0c:	481b      	ldr	r0, [pc, #108]	; (8004a7c <test_005_001_execute.lto_priv.140+0xcc>)
 8004a0e:	f002 fbaf 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8004a12:	2304      	movs	r3, #4
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8004a14:	6128      	str	r0, [r5, #16]

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 8004a16:	480d      	ldr	r0, [pc, #52]	; (8004a4c <test_005_001_execute.lto_priv.140+0x9c>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8004a18:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 8004a1a:	f001 fc31 	bl	8006280 <chMtxUnlock>
    test_wait_threads();
 8004a1e:	f7fe fb8f 	bl	8003140 <test_wait_threads>
 8004a22:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8004a24:	4916      	ldr	r1, [pc, #88]	; (8004a80 <test_005_001_execute.lto_priv.140+0xd0>)
 8004a26:	6898      	ldr	r0, [r3, #8]
 8004a28:	1a20      	subs	r0, r4, r0
 8004a2a:	fab0 f080 	clz	r0, r0
 8004a2e:	0940      	lsrs	r0, r0, #5
 8004a30:	f7ff fb7e 	bl	8004130 <_test_assert>
 8004a34:	b100      	cbz	r0, 8004a38 <test_005_001_execute.lto_priv.140+0x88>
 8004a36:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 8004a38:	4812      	ldr	r0, [pc, #72]	; (8004a84 <test_005_001_execute.lto_priv.140+0xd4>)
 8004a3a:	4913      	ldr	r1, [pc, #76]	; (8004a88 <test_005_001_execute.lto_priv.140+0xd8>)
  }
}
 8004a3c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  test_set_step(4);
  {
    chMtxUnlock(&m1);
    test_wait_threads();
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
    test_assert_sequence("ABCDE", "invalid sequence");
 8004a40:	f7ff bb4e 	b.w	80040e0 <_test_assert_sequence>
 8004a44:	200012a0 	.word	0x200012a0
 8004a48:	20000f5c 	.word	0x20000f5c
 8004a4c:	20000858 	.word	0x20000858
 8004a50:	20000f60 	.word	0x20000f60
 8004a54:	08004a91 	.word	0x08004a91
 8004a58:	08008174 	.word	0x08008174
 8004a5c:	200008b0 	.word	0x200008b0
 8004a60:	08007f18 	.word	0x08007f18
 8004a64:	200009f8 	.word	0x200009f8
 8004a68:	0800817c 	.word	0x0800817c
 8004a6c:	20000b40 	.word	0x20000b40
 8004a70:	08008178 	.word	0x08008178
 8004a74:	20000c88 	.word	0x20000c88
 8004a78:	08007a10 	.word	0x08007a10
 8004a7c:	20000dd0 	.word	0x20000dd0
 8004a80:	08008d48 	.word	0x08008d48
 8004a84:	08008170 	.word	0x08008170
 8004a88:	0800792c 	.word	0x0800792c
 8004a8c:	f3af 8000 	nop.w

08004a90 <thread1>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8004a90:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 8004a92:	4c06      	ldr	r4, [pc, #24]	; (8004aac <thread1+0x1c>)
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 8004a94:	4605      	mov	r5, r0

  chMtxLock(&m1);
 8004a96:	4620      	mov	r0, r4
 8004a98:	f001 fc92 	bl	80063c0 <chMtxLock>
  test_emit_token(*(char *)p);
 8004a9c:	7828      	ldrb	r0, [r5, #0]
 8004a9e:	f7ff f957 	bl	8003d50 <test_emit_token>
  chMtxUnlock(&m1);
 8004aa2:	4620      	mov	r0, r4
}
 8004aa4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 8004aa8:	f001 bbea 	b.w	8006280 <chMtxUnlock>
 8004aac:	20000858 	.word	0x20000858

08004ab0 <test_005_008_execute.lto_priv.149>:
static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_008_execute(void) {
 8004ab0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004ab2:	4b26      	ldr	r3, [pc, #152]	; (8004b4c <test_005_008_execute.lto_priv.149+0x9c>)

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004ab4:	4e26      	ldr	r6, [pc, #152]	; (8004b50 <test_005_008_execute.lto_priv.149+0xa0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004ab6:	699b      	ldr	r3, [r3, #24]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004ab8:	4a26      	ldr	r2, [pc, #152]	; (8004b54 <test_005_008_execute.lto_priv.149+0xa4>)
 8004aba:	689d      	ldr	r5, [r3, #8]
 8004abc:	4826      	ldr	r0, [pc, #152]	; (8004b58 <test_005_008_execute.lto_priv.149+0xa8>)
 8004abe:	4b27      	ldr	r3, [pc, #156]	; (8004b5c <test_005_008_execute.lto_priv.149+0xac>)
 8004ac0:	4c27      	ldr	r4, [pc, #156]	; (8004b60 <test_005_008_execute.lto_priv.149+0xb0>)
 8004ac2:	1c69      	adds	r1, r5, #1

static void test_005_008_execute(void) {

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004ac4:	2701      	movs	r7, #1
 8004ac6:	6037      	str	r7, [r6, #0]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004ac8:	f002 fb52 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004acc:	1ca9      	adds	r1, r5, #2
  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004ace:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004ad0:	4a20      	ldr	r2, [pc, #128]	; (8004b54 <test_005_008_execute.lto_priv.149+0xa4>)
 8004ad2:	4b24      	ldr	r3, [pc, #144]	; (8004b64 <test_005_008_execute.lto_priv.149+0xb4>)
 8004ad4:	4824      	ldr	r0, [pc, #144]	; (8004b68 <test_005_008_execute.lto_priv.149+0xb8>)
 8004ad6:	f002 fb4b 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004ada:	1ce9      	adds	r1, r5, #3
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004adc:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004ade:	4a1d      	ldr	r2, [pc, #116]	; (8004b54 <test_005_008_execute.lto_priv.149+0xa4>)
 8004ae0:	4b22      	ldr	r3, [pc, #136]	; (8004b6c <test_005_008_execute.lto_priv.149+0xbc>)
 8004ae2:	4823      	ldr	r0, [pc, #140]	; (8004b70 <test_005_008_execute.lto_priv.149+0xc0>)
 8004ae4:	f002 fb44 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004ae8:	1d29      	adds	r1, r5, #4
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004aea:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004aec:	4a19      	ldr	r2, [pc, #100]	; (8004b54 <test_005_008_execute.lto_priv.149+0xa4>)
 8004aee:	4b21      	ldr	r3, [pc, #132]	; (8004b74 <test_005_008_execute.lto_priv.149+0xc4>)
 8004af0:	4821      	ldr	r0, [pc, #132]	; (8004b78 <test_005_008_execute.lto_priv.149+0xc8>)
 8004af2:	f002 fb3d 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004af6:	1d69      	adds	r1, r5, #5
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004af8:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004afa:	4a16      	ldr	r2, [pc, #88]	; (8004b54 <test_005_008_execute.lto_priv.149+0xa4>)
 8004afc:	4b1f      	ldr	r3, [pc, #124]	; (8004b7c <test_005_008_execute.lto_priv.149+0xcc>)
 8004afe:	4820      	ldr	r0, [pc, #128]	; (8004b80 <test_005_008_execute.lto_priv.149+0xd0>)
 8004b00:	f002 fb36 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8004b04:	2302      	movs	r3, #2
 8004b06:	6033      	str	r3, [r6, #0]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004b08:	6120      	str	r0, [r4, #16]
 8004b0a:	2320      	movs	r3, #32
 8004b0c:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004b10:	4c1c      	ldr	r4, [pc, #112]	; (8004b84 <test_005_008_execute.lto_priv.149+0xd4>)
 8004b12:	6823      	ldr	r3, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8004b14:	42a3      	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8004b16:	bf18      	it	ne
 8004b18:	f06f 0501 	mvnne.w	r5, #1
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8004b1c:	d009      	beq.n	8004b32 <test_005_008_execute.lto_priv.149+0x82>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004b1e:	681a      	ldr	r2, [r3, #0]
 8004b20:	6022      	str	r2, [r4, #0]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8004b22:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8004b24:	6054      	str	r4, [r2, #4]
 8004b26:	f001 fb6b 	bl	8006200 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004b2a:	6823      	ldr	r3, [r4, #0]
 8004b2c:	6245      	str	r5, [r0, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8004b2e:	42a3      	cmp	r3, r4
 8004b30:	d1f5      	bne.n	8004b1e <test_005_008_execute.lto_priv.149+0x6e>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8004b32:	f001 fa75 	bl	8006020 <chSchRescheduleS>
 8004b36:	2300      	movs	r3, #0
 8004b38:	f383 8811 	msr	BASEPRI, r3
  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
 8004b3c:	f7fe fb00 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8004b40:	4811      	ldr	r0, [pc, #68]	; (8004b88 <test_005_008_execute.lto_priv.149+0xd8>)
 8004b42:	4912      	ldr	r1, [pc, #72]	; (8004b8c <test_005_008_execute.lto_priv.149+0xdc>)
  }
}
 8004b44:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 8004b48:	f7ff baca 	b.w	80040e0 <_test_assert_sequence>
 8004b4c:	200012a0 	.word	0x200012a0
 8004b50:	20000f5c 	.word	0x20000f5c
 8004b54:	08004e91 	.word	0x08004e91
 8004b58:	200008b0 	.word	0x200008b0
 8004b5c:	08008174 	.word	0x08008174
 8004b60:	20000f60 	.word	0x20000f60
 8004b64:	08007f18 	.word	0x08007f18
 8004b68:	200009f8 	.word	0x200009f8
 8004b6c:	0800817c 	.word	0x0800817c
 8004b70:	20000b40 	.word	0x20000b40
 8004b74:	08008178 	.word	0x08008178
 8004b78:	20000c88 	.word	0x20000c88
 8004b7c:	08007a10 	.word	0x08007a10
 8004b80:	20000dd0 	.word	0x20000dd0
 8004b84:	200008a8 	.word	0x200008a8
 8004b88:	08008170 	.word	0x08008170
 8004b8c:	0800792c 	.word	0x0800792c

08004b90 <test_005_007_execute.lto_priv.147>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004b90:	4b28      	ldr	r3, [pc, #160]	; (8004c34 <test_005_007_execute.lto_priv.147+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004b92:	699b      	ldr	r3, [r3, #24]
static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_007_execute(void) {
 8004b94:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8004b98:	689f      	ldr	r7, [r3, #8]
  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004b9a:	4d27      	ldr	r5, [pc, #156]	; (8004c38 <test_005_007_execute.lto_priv.147+0xa8>)
 8004b9c:	4e27      	ldr	r6, [pc, #156]	; (8004c3c <test_005_007_execute.lto_priv.147+0xac>)

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004b9e:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8004c60 <test_005_007_execute.lto_priv.147+0xd0>
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004ba2:	4b27      	ldr	r3, [pc, #156]	; (8004c40 <test_005_007_execute.lto_priv.147+0xb0>)
 8004ba4:	4c27      	ldr	r4, [pc, #156]	; (8004c44 <test_005_007_execute.lto_priv.147+0xb4>)

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004ba6:	f04f 0e01 	mov.w	lr, #1
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004baa:	1c79      	adds	r1, r7, #1
 8004bac:	4632      	mov	r2, r6
 8004bae:	4628      	mov	r0, r5

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 8004bb0:	f8c8 e000 	str.w	lr, [r8]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004bb4:	f002 fadc 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004bb8:	1cb9      	adds	r1, r7, #2
  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 8004bba:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004bbc:	4632      	mov	r2, r6
 8004bbe:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 8004bc2:	4b21      	ldr	r3, [pc, #132]	; (8004c48 <test_005_007_execute.lto_priv.147+0xb8>)
 8004bc4:	f002 fad4 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004bc8:	1cf9      	adds	r1, r7, #3
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 8004bca:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004bcc:	4632      	mov	r2, r6
 8004bce:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8004bd2:	4b1e      	ldr	r3, [pc, #120]	; (8004c4c <test_005_007_execute.lto_priv.147+0xbc>)
 8004bd4:	f002 facc 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004bd8:	1d39      	adds	r1, r7, #4
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 8004bda:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004bdc:	4632      	mov	r2, r6
 8004bde:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 8004be2:	4b1b      	ldr	r3, [pc, #108]	; (8004c50 <test_005_007_execute.lto_priv.147+0xc0>)
 8004be4:	f002 fac4 	bl	8007170 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004be8:	1d79      	adds	r1, r7, #5
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8004bea:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004bec:	4632      	mov	r2, r6
 8004bee:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 8004bf2:	4b18      	ldr	r3, [pc, #96]	; (8004c54 <test_005_007_execute.lto_priv.147+0xc4>)
 8004bf4:	f002 fabc 	bl	8007170 <chThdCreateStatic.constprop.69>
  }

  /* [5.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8004bf8:	2302      	movs	r3, #2
 8004bfa:	f8c8 3000 	str.w	r3, [r8]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8004bfe:	6120      	str	r0, [r4, #16]
 8004c00:	2320      	movs	r3, #32
 8004c02:	f383 8811 	msr	BASEPRI, r3
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
  {
    chSysLock();
    chCondSignalI(&c1);
 8004c06:	f002 fb73 	bl	80072f0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8004c0a:	f002 fb71 	bl	80072f0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8004c0e:	f002 fb6f 	bl	80072f0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8004c12:	f002 fb6d 	bl	80072f0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8004c16:	f002 fb6b 	bl	80072f0 <chCondSignalI.constprop.58>
    chSchRescheduleS();
 8004c1a:	f001 fa01 	bl	8006020 <chSchRescheduleS>
 8004c1e:	2300      	movs	r3, #0
 8004c20:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_wait_threads();
 8004c24:	f7fe fa8c 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8004c28:	480b      	ldr	r0, [pc, #44]	; (8004c58 <test_005_007_execute.lto_priv.147+0xc8>)
 8004c2a:	490c      	ldr	r1, [pc, #48]	; (8004c5c <test_005_007_execute.lto_priv.147+0xcc>)
  }
}
 8004c2c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chCondSignalI(&c1);
    chCondSignalI(&c1);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 8004c30:	f7ff ba56 	b.w	80040e0 <_test_assert_sequence>
 8004c34:	200012a0 	.word	0x200012a0
 8004c38:	200008b0 	.word	0x200008b0
 8004c3c:	08004e91 	.word	0x08004e91
 8004c40:	08008174 	.word	0x08008174
 8004c44:	20000f60 	.word	0x20000f60
 8004c48:	08007f18 	.word	0x08007f18
 8004c4c:	0800817c 	.word	0x0800817c
 8004c50:	08008178 	.word	0x08008178
 8004c54:	08007a10 	.word	0x08007a10
 8004c58:	08008170 	.word	0x08008170
 8004c5c:	0800792c 	.word	0x0800792c
 8004c60:	20000f5c 	.word	0x20000f5c
 8004c64:	f3af 8000 	nop.w
 8004c68:	f3af 8000 	nop.w
 8004c6c:	f3af 8000 	nop.w

08004c70 <test_005_005_execute.lto_priv.145>:

static void test_005_005_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_005_execute(void) {
 8004c70:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004c74:	4d4e      	ldr	r5, [pc, #312]	; (8004db0 <test_005_005_execute.lto_priv.145+0x140>)
    prio = chThdGetPriorityX();
  }

  /* [5.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 8004c76:	4c4f      	ldr	r4, [pc, #316]	; (8004db4 <test_005_005_execute.lto_priv.145+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004c78:	69aa      	ldr	r2, [r5, #24]
 8004c7a:	2302      	movs	r3, #2
 8004c7c:	6896      	ldr	r6, [r2, #8]
 8004c7e:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004c80:	f002 fafe 	bl	8007280 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 8004c84:	494c      	ldr	r1, [pc, #304]	; (8004db8 <test_005_005_execute.lto_priv.145+0x148>)
 8004c86:	f7ff fa53 	bl	8004130 <_test_assert>
 8004c8a:	b108      	cbz	r0, 8004c90 <test_005_005_execute.lto_priv.145+0x20>
 8004c8c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [5.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 8004c90:	2303      	movs	r3, #3
 8004c92:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004c94:	f002 faf4 	bl	8007280 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 8004c98:	f080 0001 	eor.w	r0, r0, #1
 8004c9c:	b2c0      	uxtb	r0, r0
 8004c9e:	4947      	ldr	r1, [pc, #284]	; (8004dbc <test_005_005_execute.lto_priv.145+0x14c>)
 8004ca0:	f7ff fa46 	bl	8004130 <_test_assert>
 8004ca4:	2800      	cmp	r0, #0
 8004ca6:	d1f1      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 8004ca8:	4f45      	ldr	r7, [pc, #276]	; (8004dc0 <test_005_005_execute.lto_priv.145+0x150>)
    test_assert(!b, "not locked");
  }

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8004caa:	2304      	movs	r3, #4
  {
    chMtxUnlock(&m1);
 8004cac:	4638      	mov	r0, r7
    test_assert(!b, "not locked");
  }

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 8004cae:	6023      	str	r3, [r4, #0]
  {
    chMtxUnlock(&m1);
 8004cb0:	f001 fae6 	bl	8006280 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 8004cb4:	68b8      	ldr	r0, [r7, #8]
 8004cb6:	4943      	ldr	r1, [pc, #268]	; (8004dc4 <test_005_005_execute.lto_priv.145+0x154>)
 8004cb8:	fab0 f080 	clz	r0, r0
 8004cbc:	0940      	lsrs	r0, r0, #5
 8004cbe:	f7ff fa37 	bl	8004130 <_test_assert>
 8004cc2:	2800      	cmp	r0, #0
 8004cc4:	d1e2      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004cc6:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004cc8:	493f      	ldr	r1, [pc, #252]	; (8004dc8 <test_005_005_execute.lto_priv.145+0x158>)
 8004cca:	1bc0      	subs	r0, r0, r7
 8004ccc:	fab0 f080 	clz	r0, r0
 8004cd0:	0940      	lsrs	r0, r0, #5
 8004cd2:	f7ff fa2d 	bl	8004130 <_test_assert>
 8004cd6:	2800      	cmp	r0, #0
 8004cd8:	d1d8      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
 8004cda:	69ab      	ldr	r3, [r5, #24]
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004cdc:	493b      	ldr	r1, [pc, #236]	; (8004dcc <test_005_005_execute.lto_priv.145+0x15c>)
 8004cde:	6898      	ldr	r0, [r3, #8]
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8004ce0:	2305      	movs	r3, #5
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004ce2:	1a30      	subs	r0, r6, r0
 8004ce4:	fab0 f080 	clz	r0, r0
 8004ce8:	0940      	lsrs	r0, r0, #5
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 8004cea:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004cec:	f7ff fa20 	bl	8004130 <_test_assert>
 8004cf0:	2800      	cmp	r0, #0
 8004cf2:	d1cb      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
  }

  /* [5.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8004cf4:	2306      	movs	r3, #6
 8004cf6:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8004cf8:	f002 fac2 	bl	8007280 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 8004cfc:	492e      	ldr	r1, [pc, #184]	; (8004db8 <test_005_005_execute.lto_priv.145+0x148>)
 8004cfe:	f7ff fa17 	bl	8004130 <_test_assert>
 8004d02:	2800      	cmp	r0, #0
 8004d04:	d1c2      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
    b = chMtxTryLock(&m1);
 8004d06:	f002 fabb 	bl	8007280 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 8004d0a:	f080 0001 	eor.w	r0, r0, #1
 8004d0e:	b2c0      	uxtb	r0, r0
 8004d10:	492a      	ldr	r1, [pc, #168]	; (8004dbc <test_005_005_execute.lto_priv.145+0x14c>)
 8004d12:	f7ff fa0d 	bl	8004130 <_test_assert>
 8004d16:	2800      	cmp	r0, #0
 8004d18:	d1b8      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 8004d1a:	f8d5 8018 	ldr.w	r8, [r5, #24]
 8004d1e:	2320      	movs	r3, #32
 8004d20:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->mtxlist != NULL) {
 8004d24:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8004d28:	b1fb      	cbz	r3, 8004d6a <test_005_005_execute.lto_priv.145+0xfa>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004d2a:	4681      	mov	r9, r0
 8004d2c:	e00d      	b.n	8004d4a <test_005_005_execute.lto_priv.145+0xda>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8004d2e:	6811      	ldr	r1, [r2, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 8004d30:	f8d2 e038 	ldr.w	lr, [r2, #56]	; 0x38
 8004d34:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8004d36:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 8004d38:	609a      	str	r2, [r3, #8]
        mp->next = tp->mtxlist;
 8004d3a:	f8c3 e00c 	str.w	lr, [r3, #12]
        tp->mtxlist = mp;
 8004d3e:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 8004d40:	f001 fa5e 	bl	8006200 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 8004d44:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8004d48:	b14b      	cbz	r3, 8004d5e <test_005_005_execute.lto_priv.145+0xee>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8004d4a:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 8004d4c:	68d9      	ldr	r1, [r3, #12]
 8004d4e:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8004d52:	4293      	cmp	r3, r2
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
        tp->mtxlist = mp;
        (void) chSchReadyI(tp);
 8004d54:	4610      	mov	r0, r2
  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
      if (chMtxQueueNotEmptyS(mp)) {
 8004d56:	d1ea      	bne.n	8004d2e <test_005_005_execute.lto_priv.145+0xbe>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8004d58:	f8c3 9008 	str.w	r9, [r3, #8]
 8004d5c:	e7f2      	b.n	8004d44 <test_005_005_execute.lto_priv.145+0xd4>
      }
    } while (ctp->mtxlist != NULL);
    ctp->prio = ctp->realprio;
 8004d5e:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8004d62:	f8c8 3008 	str.w	r3, [r8, #8]
    chSchRescheduleS();
 8004d66:	f001 f95b 	bl	8006020 <chSchRescheduleS>
 8004d6a:	2300      	movs	r3, #0
 8004d6c:	f383 8811 	msr	BASEPRI, r3

    chMtxUnlockAll();
    test_assert(m1.owner == NULL, "still owned");
 8004d70:	4914      	ldr	r1, [pc, #80]	; (8004dc4 <test_005_005_execute.lto_priv.145+0x154>)
 8004d72:	68b8      	ldr	r0, [r7, #8]
 8004d74:	fab0 f080 	clz	r0, r0
 8004d78:	0940      	lsrs	r0, r0, #5
 8004d7a:	4f11      	ldr	r7, [pc, #68]	; (8004dc0 <test_005_005_execute.lto_priv.145+0x150>)
 8004d7c:	f7ff f9d8 	bl	8004130 <_test_assert>
 8004d80:	2800      	cmp	r0, #0
 8004d82:	d183      	bne.n	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8004d84:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8004d86:	4910      	ldr	r1, [pc, #64]	; (8004dc8 <test_005_005_execute.lto_priv.145+0x158>)
 8004d88:	1bc7      	subs	r7, r0, r7
 8004d8a:	4278      	negs	r0, r7
 8004d8c:	4178      	adcs	r0, r7
 8004d8e:	f7ff f9cf 	bl	8004130 <_test_assert>
 8004d92:	2800      	cmp	r0, #0
 8004d94:	f47f af7a 	bne.w	8004c8c <test_005_005_execute.lto_priv.145+0x1c>
 8004d98:	69ab      	ldr	r3, [r5, #24]
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004d9a:	490c      	ldr	r1, [pc, #48]	; (8004dcc <test_005_005_execute.lto_priv.145+0x15c>)
 8004d9c:	6898      	ldr	r0, [r3, #8]
 8004d9e:	1a32      	subs	r2, r6, r0
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8004da0:	2307      	movs	r3, #7
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004da2:	4250      	negs	r0, r2
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 8004da4:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004da6:	4150      	adcs	r0, r2
  }
}
 8004da8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 8004dac:	f7ff b9c0 	b.w	8004130 <_test_assert>
 8004db0:	200012a0 	.word	0x200012a0
 8004db4:	20000f5c 	.word	0x20000f5c
 8004db8:	08008d60 	.word	0x08008d60
 8004dbc:	08008d70 	.word	0x08008d70
 8004dc0:	20000858 	.word	0x20000858
 8004dc4:	08008d7c 	.word	0x08008d7c
 8004dc8:	0800814c 	.word	0x0800814c
 8004dcc:	08008d48 	.word	0x08008d48

08004dd0 <thread4B>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread4B, p) {
 8004dd0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 8004dd2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 8004dd6:	f001 fc43 	bl	8006660 <chThdSleep>
 8004dda:	2320      	movs	r3, #32
 8004ddc:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 8004de0:	4c06      	ldr	r4, [pc, #24]	; (8004dfc <thread4B+0x2c>)
 8004de2:	4620      	mov	r0, r4
 8004de4:	f001 fa84 	bl	80062f0 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 8004de8:	4620      	mov	r0, r4
 8004dea:	f001 fa21 	bl	8006230 <chMtxUnlockS>
  chSchRescheduleS();
 8004dee:	f001 f917 	bl	8006020 <chSchRescheduleS>
 8004df2:	2300      	movs	r3, #0
 8004df4:	f383 8811 	msr	BASEPRI, r3
 8004df8:	bd10      	pop	{r4, pc}
 8004dfa:	bf00      	nop
 8004dfc:	2000083c 	.word	0x2000083c

08004e00 <thread8>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8004e00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8004e02:	4607      	mov	r7, r0

  chMtxLock(&m2);
 8004e04:	481b      	ldr	r0, [pc, #108]	; (8004e74 <thread8+0x74>)
 8004e06:	f001 fadb 	bl	80063c0 <chMtxLock>
  chMtxLock(&m1);
 8004e0a:	481b      	ldr	r0, [pc, #108]	; (8004e78 <thread8+0x78>)
 8004e0c:	f001 fad8 	bl	80063c0 <chMtxLock>
 8004e10:	2320      	movs	r3, #32
 8004e12:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004e16:	4d19      	ldr	r5, [pc, #100]	; (8004e7c <thread8+0x7c>)
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->mtxlist;
 8004e18:	69ab      	ldr	r3, [r5, #24]
 8004e1a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8004e1c:	4630      	mov	r0, r6
 8004e1e:	f001 fa07 	bl	8006230 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8004e22:	4b17      	ldr	r3, [pc, #92]	; (8004e80 <thread8+0x80>)
 8004e24:	69ac      	ldr	r4, [r5, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004e26:	4618      	mov	r0, r3
 8004e28:	6263      	str	r3, [r4, #36]	; 0x24
 8004e2a:	e003      	b.n	8004e34 <thread8+0x34>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004e2c:	6899      	ldr	r1, [r3, #8]
 8004e2e:	68a2      	ldr	r2, [r4, #8]
 8004e30:	4291      	cmp	r1, r2
 8004e32:	d302      	bcc.n	8004e3a <thread8+0x3a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8004e34:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004e36:	4283      	cmp	r3, r0
 8004e38:	d1f8      	bne.n	8004e2c <thread8+0x2c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004e3a:	685a      	ldr	r2, [r3, #4]
 8004e3c:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8004e3e:	6023      	str	r3, [r4, #0]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8004e40:	2007      	movs	r0, #7
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8004e42:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004e44:	605c      	str	r4, [r3, #4]
 8004e46:	f001 f97b 	bl	8006140 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8004e4a:	69ab      	ldr	r3, [r5, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 8004e4c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004e4e:	3301      	adds	r3, #1
 8004e50:	d002      	beq.n	8004e58 <thread8+0x58>
    chMtxLockS(mp);
 8004e52:	4630      	mov	r0, r6
 8004e54:	f001 fa4c 	bl	80062f0 <chMtxLockS>
 8004e58:	2300      	movs	r3, #0
 8004e5a:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 8004e5e:	7838      	ldrb	r0, [r7, #0]
 8004e60:	f7fe ff76 	bl	8003d50 <test_emit_token>
  chMtxUnlock(&m1);
 8004e64:	4804      	ldr	r0, [pc, #16]	; (8004e78 <thread8+0x78>)
 8004e66:	f001 fa0b 	bl	8006280 <chMtxUnlock>
  chMtxUnlock(&m2);
 8004e6a:	4802      	ldr	r0, [pc, #8]	; (8004e74 <thread8+0x74>)
}
 8004e6c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 8004e70:	f001 ba06 	b.w	8006280 <chMtxUnlock>
 8004e74:	2000083c 	.word	0x2000083c
 8004e78:	20000858 	.word	0x20000858
 8004e7c:	200012a0 	.word	0x200012a0
 8004e80:	200008a8 	.word	0x200008a8
 8004e84:	f3af 8000 	nop.w
 8004e88:	f3af 8000 	nop.w
 8004e8c:	f3af 8000 	nop.w

08004e90 <thread6>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 8004e90:	b570      	push	{r4, r5, r6, lr}
 8004e92:	4606      	mov	r6, r0

  chMtxLock(&m1);
 8004e94:	4816      	ldr	r0, [pc, #88]	; (8004ef0 <thread6+0x60>)
 8004e96:	f001 fa93 	bl	80063c0 <chMtxLock>
 8004e9a:	2320      	movs	r3, #32
 8004e9c:	f383 8811 	msr	BASEPRI, r3
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 8004ea0:	4b14      	ldr	r3, [pc, #80]	; (8004ef4 <thread6+0x64>)
 8004ea2:	699c      	ldr	r4, [r3, #24]
 8004ea4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 8004ea6:	4628      	mov	r0, r5
 8004ea8:	f001 f9c2 	bl	8006230 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 8004eac:	4812      	ldr	r0, [pc, #72]	; (8004ef8 <thread6+0x68>)
 8004eae:	6260      	str	r0, [r4, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8004eb0:	4603      	mov	r3, r0
 8004eb2:	e003      	b.n	8004ebc <thread6+0x2c>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004eb4:	6899      	ldr	r1, [r3, #8]
 8004eb6:	68a2      	ldr	r2, [r4, #8]
 8004eb8:	4291      	cmp	r1, r2
 8004eba:	d302      	bcc.n	8004ec2 <thread6+0x32>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8004ebc:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8004ebe:	4283      	cmp	r3, r0
 8004ec0:	d1f8      	bne.n	8004eb4 <thread6+0x24>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004ec2:	685a      	ldr	r2, [r3, #4]
 8004ec4:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8004ec6:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 8004ec8:	2007      	movs	r0, #7
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8004eca:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8004ecc:	605c      	str	r4, [r3, #4]
 8004ece:	f001 f937 	bl	8006140 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 8004ed2:	4628      	mov	r0, r5
 8004ed4:	f001 fa0c 	bl	80062f0 <chMtxLockS>
 8004ed8:	2300      	movs	r3, #0
 8004eda:	f383 8811 	msr	BASEPRI, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 8004ede:	7830      	ldrb	r0, [r6, #0]
 8004ee0:	f7fe ff36 	bl	8003d50 <test_emit_token>
  chMtxUnlock(&m1);
 8004ee4:	4802      	ldr	r0, [pc, #8]	; (8004ef0 <thread6+0x60>)
}
 8004ee6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static THD_FUNCTION(thread6, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 8004eea:	f001 b9c9 	b.w	8006280 <chMtxUnlock>
 8004eee:	bf00      	nop
 8004ef0:	20000858 	.word	0x20000858
 8004ef4:	200012a0 	.word	0x200012a0
 8004ef8:	200008a8 	.word	0x200008a8
 8004efc:	f3af 8000 	nop.w

08004f00 <test_004_006_execute.lto_priv.138>:

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8004f00:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8004f04:	4f60      	ldr	r7, [pc, #384]	; (8005088 <test_004_006_execute.lto_priv.138+0x188>)

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8004f06:	b084      	sub	sp, #16
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004f08:	ac01      	add	r4, sp, #4
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8004f0a:	2301      	movs	r3, #1
 8004f0c:	2600      	movs	r6, #0
 8004f0e:	603b      	str	r3, [r7, #0]
 8004f10:	9401      	str	r4, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 8004f12:	9402      	str	r4, [sp, #8]
 8004f14:	9603      	str	r6, [sp, #12]
 8004f16:	f04f 0820 	mov.w	r8, #32
 8004f1a:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8004f1e:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8004f20:	495a      	ldr	r1, [pc, #360]	; (800508c <test_004_006_execute.lto_priv.138+0x18c>)
 8004f22:	42b0      	cmp	r0, r6
 8004f24:	bfcc      	ite	gt
 8004f26:	2000      	movgt	r0, #0
 8004f28:	2001      	movle	r0, #1
 8004f2a:	f7ff f901 	bl	8004130 <_test_assert>
 8004f2e:	4605      	mov	r5, r0
 8004f30:	b120      	cbz	r0, 8004f3c <test_004_006_execute.lto_priv.138+0x3c>
 8004f32:	f386 8811 	msr	BASEPRI, r6
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 8004f36:	b004      	add	sp, #16
 8004f38:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f3c:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 8004f40:	2302      	movs	r3, #2
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8004f42:	4620      	mov	r0, r4
 8004f44:	4629      	mov	r1, r5
 8004f46:	603b      	str	r3, [r7, #0]
 8004f48:	f001 fa72 	bl	8006430 <chSemReset>
 8004f4c:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8004f50:	9803      	ldr	r0, [sp, #12]
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8004f52:	494e      	ldr	r1, [pc, #312]	; (800508c <test_004_006_execute.lto_priv.138+0x18c>)
 8004f54:	2800      	cmp	r0, #0
 8004f56:	bfcc      	ite	gt
 8004f58:	2000      	movgt	r0, #0
 8004f5a:	2001      	movle	r0, #1
 8004f5c:	f7ff f8e8 	bl	8004130 <_test_assert>
 8004f60:	4606      	mov	r6, r0
 8004f62:	b120      	cbz	r0, 8004f6e <test_004_006_execute.lto_priv.138+0x6e>
 8004f64:	f385 8811 	msr	BASEPRI, r5
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 8004f68:	b004      	add	sp, #16
 8004f6a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8004f6e:	f380 8811 	msr	BASEPRI, r0
 8004f72:	4b47      	ldr	r3, [pc, #284]	; (8005090 <test_004_006_execute.lto_priv.138+0x190>)
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004f74:	4a47      	ldr	r2, [pc, #284]	; (8005094 <test_004_006_execute.lto_priv.138+0x194>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004f76:	699b      	ldr	r3, [r3, #24]
 8004f78:	4847      	ldr	r0, [pc, #284]	; (8005098 <test_004_006_execute.lto_priv.138+0x198>)
 8004f7a:	6899      	ldr	r1, [r3, #8]
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8004f7c:	2503      	movs	r5, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004f7e:	3901      	subs	r1, #1
 8004f80:	4623      	mov	r3, r4
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8004f82:	603d      	str	r5, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004f84:	f002 f8f4 	bl	8007170 <chThdCreateStatic.constprop.69>
 8004f88:	4a44      	ldr	r2, [pc, #272]	; (800509c <test_004_006_execute.lto_priv.138+0x19c>)
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [4.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 8004f8a:	2304      	movs	r3, #4
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8004f8c:	6010      	str	r0, [r2, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->sem);
 8004f8e:	4620      	mov	r0, r4
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [4.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 8004f90:	603b      	str	r3, [r7, #0]
 8004f92:	f001 f8ed 	bl	8006170 <chSemWait>
 8004f96:	4605      	mov	r5, r0
 8004f98:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8004f9c:	9803      	ldr	r0, [sp, #12]
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8004f9e:	493b      	ldr	r1, [pc, #236]	; (800508c <test_004_006_execute.lto_priv.138+0x18c>)
 8004fa0:	2800      	cmp	r0, #0
 8004fa2:	bfcc      	ite	gt
 8004fa4:	2000      	movgt	r0, #0
 8004fa6:	2001      	movle	r0, #1
 8004fa8:	f7ff f8c2 	bl	8004130 <_test_assert>
 8004fac:	2800      	cmp	r0, #0
 8004fae:	d1c0      	bne.n	8004f32 <test_004_006_execute.lto_priv.138+0x32>
 8004fb0:	f380 8811 	msr	BASEPRI, r0
    test_assert(msg == MSG_OK, "unexpected message");
 8004fb4:	fab5 f085 	clz	r0, r5
 8004fb8:	4939      	ldr	r1, [pc, #228]	; (80050a0 <test_004_006_execute.lto_priv.138+0x1a0>)
 8004fba:	0940      	lsrs	r0, r0, #5
 8004fbc:	f7ff f8b8 	bl	8004130 <_test_assert>
 8004fc0:	2800      	cmp	r0, #0
 8004fc2:	d1b8      	bne.n	8004f36 <test_004_006_execute.lto_priv.138+0x36>
  }

  /* [4.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 8004fc4:	2305      	movs	r3, #5
 8004fc6:	603b      	str	r3, [r7, #0]
 8004fc8:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 8004fcc:	9b03      	ldr	r3, [sp, #12]
 8004fce:	2b00      	cmp	r3, #0
 8004fd0:	dd23      	ble.n	800501a <test_004_006_execute.lto_priv.138+0x11a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8004fd2:	f001 f825 	bl	8006020 <chSchRescheduleS>
 8004fd6:	2500      	movs	r5, #0
 8004fd8:	f385 8811 	msr	BASEPRI, r5
 8004fdc:	2620      	movs	r6, #32
 8004fde:	f386 8811 	msr	BASEPRI, r6
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 8004fe2:	9803      	ldr	r0, [sp, #12]
 8004fe4:	492f      	ldr	r1, [pc, #188]	; (80050a4 <test_004_006_execute.lto_priv.138+0x1a4>)
 8004fe6:	42a8      	cmp	r0, r5
 8004fe8:	bfd4      	ite	le
 8004fea:	2000      	movle	r0, #0
 8004fec:	2001      	movgt	r0, #1
 8004fee:	f7ff f89f 	bl	8004130 <_test_assert>
 8004ff2:	4680      	mov	r8, r0
 8004ff4:	2800      	cmp	r0, #0
 8004ff6:	d1b5      	bne.n	8004f64 <test_004_006_execute.lto_priv.138+0x64>
 8004ff8:	f380 8811 	msr	BASEPRI, r0
 8004ffc:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8005000:	9803      	ldr	r0, [sp, #12]
 8005002:	4929      	ldr	r1, [pc, #164]	; (80050a8 <test_004_006_execute.lto_priv.138+0x1a8>)
 8005004:	f1a0 0001 	sub.w	r0, r0, #1
 8005008:	fab0 f080 	clz	r0, r0
 800500c:	0940      	lsrs	r0, r0, #5
 800500e:	f7ff f88f 	bl	8004130 <_test_assert>
 8005012:	b130      	cbz	r0, 8005022 <test_004_006_execute.lto_priv.138+0x122>
 8005014:	f388 8811 	msr	BASEPRI, r8
 8005018:	e78d      	b.n	8004f36 <test_004_006_execute.lto_priv.138+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 800501a:	4620      	mov	r0, r4
 800501c:	f001 f9e0 	bl	80063e0 <chSemSignalI>
 8005020:	e7d7      	b.n	8004fd2 <test_004_006_execute.lto_priv.138+0xd2>
 8005022:	f380 8811 	msr	BASEPRI, r0
  }

  /* [4.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8005026:	2306      	movs	r3, #6
 8005028:	603b      	str	r3, [r7, #0]
 800502a:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 800502e:	9b03      	ldr	r3, [sp, #12]
 8005030:	2b00      	cmp	r3, #0
 8005032:	dd22      	ble.n	800507a <test_004_006_execute.lto_priv.138+0x17a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8005034:	f000 fff4 	bl	8006020 <chSchRescheduleS>
 8005038:	2600      	movs	r6, #0
 800503a:	f386 8811 	msr	BASEPRI, r6
 800503e:	2520      	movs	r5, #32
 8005040:	f385 8811 	msr	BASEPRI, r5
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8005044:	9803      	ldr	r0, [sp, #12]
 8005046:	4919      	ldr	r1, [pc, #100]	; (80050ac <test_004_006_execute.lto_priv.138+0x1ac>)
 8005048:	42b0      	cmp	r0, r6
 800504a:	bfd4      	ite	le
 800504c:	2000      	movle	r0, #0
 800504e:	2001      	movgt	r0, #1
 8005050:	f7ff f86e 	bl	8004130 <_test_assert>
 8005054:	4604      	mov	r4, r0
 8005056:	2800      	cmp	r0, #0
 8005058:	f47f af6b 	bne.w	8004f32 <test_004_006_execute.lto_priv.138+0x32>
 800505c:	f380 8811 	msr	BASEPRI, r0
 8005060:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8005064:	9803      	ldr	r0, [sp, #12]
 8005066:	4910      	ldr	r1, [pc, #64]	; (80050a8 <test_004_006_execute.lto_priv.138+0x1a8>)
 8005068:	1e43      	subs	r3, r0, #1
 800506a:	4258      	negs	r0, r3
 800506c:	4158      	adcs	r0, r3
 800506e:	f7ff f85f 	bl	8004130 <_test_assert>
 8005072:	b130      	cbz	r0, 8005082 <test_004_006_execute.lto_priv.138+0x182>
 8005074:	f384 8811 	msr	BASEPRI, r4
 8005078:	e75d      	b.n	8004f36 <test_004_006_execute.lto_priv.138+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 800507a:	4620      	mov	r0, r4
 800507c:	f001 f9b0 	bl	80063e0 <chSemSignalI>
 8005080:	e7d8      	b.n	8005034 <test_004_006_execute.lto_priv.138+0x134>
 8005082:	f380 8811 	msr	BASEPRI, r0
 8005086:	e756      	b.n	8004f36 <test_004_006_execute.lto_priv.138+0x36>
 8005088:	20000f5c 	.word	0x20000f5c
 800508c:	08008d88 	.word	0x08008d88
 8005090:	200012a0 	.word	0x200012a0
 8005094:	08002bd1 	.word	0x08002bd1
 8005098:	200008b0 	.word	0x200008b0
 800509c:	20000f60 	.word	0x20000f60
 80050a0:	08008d94 	.word	0x08008d94
 80050a4:	08008da8 	.word	0x08008da8
 80050a8:	08008db4 	.word	0x08008db4
 80050ac:	08008d8c 	.word	0x08008d8c

080050b0 <test_004_005_execute.lto_priv.136>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80050b0:	4b1e      	ldr	r3, [pc, #120]	; (800512c <test_004_005_execute.lto_priv.136+0x7c>)

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050b2:	4a1f      	ldr	r2, [pc, #124]	; (8005130 <test_004_005_execute.lto_priv.136+0x80>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80050b4:	699b      	ldr	r3, [r3, #24]
 80050b6:	481f      	ldr	r0, [pc, #124]	; (8005134 <test_004_005_execute.lto_priv.136+0x84>)
 80050b8:	6899      	ldr	r1, [r3, #8]

static void test_004_005_teardown(void) {
  test_wait_threads();
}

static void test_004_005_execute(void) {
 80050ba:	b570      	push	{r4, r5, r6, lr}

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80050bc:	4d1e      	ldr	r5, [pc, #120]	; (8005138 <test_004_005_execute.lto_priv.136+0x88>)
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80050be:	4c1f      	ldr	r4, [pc, #124]	; (800513c <test_004_005_execute.lto_priv.136+0x8c>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050c0:	3101      	adds	r1, #1
 80050c2:	2300      	movs	r3, #0

static void test_004_005_execute(void) {

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 80050c4:	2601      	movs	r6, #1
 80050c6:	602e      	str	r6, [r5, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050c8:	f002 f852 	bl	8007170 <chThdCreateStatic.constprop.69>
 80050cc:	4a1c      	ldr	r2, [pc, #112]	; (8005140 <test_004_005_execute.lto_priv.136+0x90>)
  }

  /* [4.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80050ce:	2302      	movs	r3, #2

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 80050d0:	6010      	str	r0, [r2, #0]
  }

  /* [4.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 80050d2:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 80050d4:	f002 f89c 	bl	8007210 <chSemSignalWait.constprop.63>
 80050d8:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 80050da:	491a      	ldr	r1, [pc, #104]	; (8005144 <test_004_005_execute.lto_priv.136+0x94>)
 80050dc:	1b00      	subs	r0, r0, r4
 80050de:	fab0 f080 	clz	r0, r0
 80050e2:	0940      	lsrs	r0, r0, #5
 80050e4:	f7ff f824 	bl	8004130 <_test_assert>
 80050e8:	b100      	cbz	r0, 80050ec <test_004_005_execute.lto_priv.136+0x3c>
 80050ea:	bd70      	pop	{r4, r5, r6, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 80050ec:	68a0      	ldr	r0, [r4, #8]
 80050ee:	4916      	ldr	r1, [pc, #88]	; (8005148 <test_004_005_execute.lto_priv.136+0x98>)
 80050f0:	fab0 f080 	clz	r0, r0
 80050f4:	0940      	lsrs	r0, r0, #5
 80050f6:	f7ff f81b 	bl	8004130 <_test_assert>
 80050fa:	2800      	cmp	r0, #0
 80050fc:	d1f5      	bne.n	80050ea <test_004_005_execute.lto_priv.136+0x3a>
  }

  /* [4.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 80050fe:	2303      	movs	r3, #3
 8005100:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8005102:	f002 f885 	bl	8007210 <chSemSignalWait.constprop.63>
 8005106:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8005108:	490e      	ldr	r1, [pc, #56]	; (8005144 <test_004_005_execute.lto_priv.136+0x94>)
 800510a:	1b00      	subs	r0, r0, r4
 800510c:	fab0 f080 	clz	r0, r0
 8005110:	0940      	lsrs	r0, r0, #5
 8005112:	f7ff f80d 	bl	8004130 <_test_assert>
 8005116:	2800      	cmp	r0, #0
 8005118:	d1e7      	bne.n	80050ea <test_004_005_execute.lto_priv.136+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
 800511a:	68a0      	ldr	r0, [r4, #8]
 800511c:	490a      	ldr	r1, [pc, #40]	; (8005148 <test_004_005_execute.lto_priv.136+0x98>)
 800511e:	fab0 f080 	clz	r0, r0
  }
}
 8005122:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     counter value must be one on exit.*/
  test_set_step(3);
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
 8005126:	0940      	lsrs	r0, r0, #5
 8005128:	f7ff b802 	b.w	8004130 <_test_assert>
 800512c:	200012a0 	.word	0x200012a0
 8005130:	08002cf1 	.word	0x08002cf1
 8005134:	200008b0 	.word	0x200008b0
 8005138:	20000f5c 	.word	0x20000f5c
 800513c:	20001340 	.word	0x20001340
 8005140:	20000f60 	.word	0x20000f60
 8005144:	0800814c 	.word	0x0800814c
 8005148:	0800815c 	.word	0x0800815c
 800514c:	f3af 8000 	nop.w

08005150 <tmo.lto_priv.88>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 8005150:	4770      	bx	lr
 8005152:	bf00      	nop
 8005154:	f3af 8000 	nop.w
 8005158:	f3af 8000 	nop.w
 800515c:	f3af 8000 	nop.w

08005160 <test_011_002_setup.lto_priv.186>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8005160:	4b03      	ldr	r3, [pc, #12]	; (8005170 <test_011_002_setup.lto_priv.186+0x10>)
 8005162:	2200      	movs	r2, #0
  mp->object_size = size;
 8005164:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005168:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 800516a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 800516c:	609a      	str	r2, [r3, #8]
 800516e:	4770      	bx	lr
 8005170:	20001350 	.word	0x20001350
 8005174:	f3af 8000 	nop.w
 8005178:	f3af 8000 	nop.w
 800517c:	f3af 8000 	nop.w

08005180 <test_011_001_setup.lto_priv.184>:
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8005180:	4908      	ldr	r1, [pc, #32]	; (80051a4 <test_011_001_setup.lto_priv.184+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8005182:	4b09      	ldr	r3, [pc, #36]	; (80051a8 <test_011_001_setup.lto_priv.184+0x28>)
 *   freeing memory.
 * - [11.1.7] Getting heap info again for verification.
 * .
 */

static void test_011_001_setup(void) {
 8005184:	b410      	push	{r4}
 8005186:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8005188:	24cc      	movs	r4, #204	; 0xcc
 800518a:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800518e:	f103 0010 	add.w	r0, r3, #16
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8005192:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 8005194:	60da      	str	r2, [r3, #12]
 8005196:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8005198:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 800519a:	601a      	str	r2, [r3, #0]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 800519c:	619a      	str	r2, [r3, #24]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 800519e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80051a2:	4770      	bx	lr
 80051a4:	200008b0 	.word	0x200008b0
 80051a8:	20000fc0 	.word	0x20000fc0
 80051ac:	f3af 8000 	nop.w

080051b0 <test_010_001_setup.lto_priv.181>:
  H_NEXT(&heapp->header) = hp;
 80051b0:	4908      	ldr	r1, [pc, #32]	; (80051d4 <test_010_001_setup.lto_priv.181+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80051b2:	4b09      	ldr	r3, [pc, #36]	; (80051d8 <test_010_001_setup.lto_priv.181+0x28>)
 * - [10.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void test_010_001_setup(void) {
 80051b4:	b410      	push	{r4}
 80051b6:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80051b8:	24cc      	movs	r4, #204	; 0xcc
 80051ba:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80051be:	f103 0010 	add.w	r0, r3, #16
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 80051c2:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 80051c4:	60da      	str	r2, [r3, #12]
 80051c6:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 80051c8:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80051ca:	601a      	str	r2, [r3, #0]
 80051cc:	619a      	str	r2, [r3, #24]
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}
 80051ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 80051d2:	4770      	bx	lr
 80051d4:	200008b0 	.word	0x200008b0
 80051d8:	20000fa0 	.word	0x20000fa0
 80051dc:	f3af 8000 	nop.w

080051e0 <test_009_003_setup.lto_priv.179>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80051e0:	4b04      	ldr	r3, [pc, #16]	; (80051f4 <test_009_003_setup.lto_priv.179+0x14>)
 80051e2:	2200      	movs	r2, #0
  mp->object_size = size;
 80051e4:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80051e6:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80051e8:	605b      	str	r3, [r3, #4]
 80051ea:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80051ec:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 80051ee:	615a      	str	r2, [r3, #20]
 80051f0:	609a      	str	r2, [r3, #8]
 80051f2:	4770      	bx	lr
 80051f4:	20000890 	.word	0x20000890
 80051f8:	f3af 8000 	nop.w
 80051fc:	f3af 8000 	nop.w

08005200 <test_009_002_setup.lto_priv.177>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8005200:	4b04      	ldr	r3, [pc, #16]	; (8005214 <test_009_002_setup.lto_priv.177+0x14>)
 8005202:	2200      	movs	r2, #0
  mp->object_size = size;
 8005204:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005206:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8005208:	605b      	str	r3, [r3, #4]
 800520a:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 800520c:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 800520e:	615a      	str	r2, [r3, #20]
 8005210:	609a      	str	r2, [r3, #8]
 8005212:	4770      	bx	lr
 8005214:	20000890 	.word	0x20000890
 8005218:	f3af 8000 	nop.w
 800521c:	f3af 8000 	nop.w

08005220 <null_provider>:

  (void)size;
  (void)align;

  return NULL;
}
 8005220:	2000      	movs	r0, #0
 8005222:	4770      	bx	lr
 8005224:	f3af 8000 	nop.w
 8005228:	f3af 8000 	nop.w
 800522c:	f3af 8000 	nop.w

08005230 <test_009_001_setup.lto_priv.175>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8005230:	4b03      	ldr	r3, [pc, #12]	; (8005240 <test_009_001_setup.lto_priv.175+0x10>)
 8005232:	2200      	movs	r2, #0
  mp->object_size = size;
 8005234:	2104      	movs	r1, #4
 8005236:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8005238:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 800523a:	609a      	str	r2, [r3, #8]
 800523c:	4770      	bx	lr
 800523e:	bf00      	nop
 8005240:	2000084c 	.word	0x2000084c
 8005244:	f3af 8000 	nop.w
 8005248:	f3af 8000 	nop.w
 800524c:	f3af 8000 	nop.w

08005250 <test_008_003_setup.lto_priv.172>:
 * - [8.3.3] Resetting the mailbox.
 * - [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.
 * .
 */

static void test_008_003_setup(void) {
 8005250:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8005252:	4b0b      	ldr	r3, [pc, #44]	; (8005280 <test_008_003_setup.lto_priv.172+0x30>)
 8005254:	4a0b      	ldr	r2, [pc, #44]	; (8005284 <test_008_003_setup.lto_priv.172+0x34>)
 8005256:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8005258:	f102 0610 	add.w	r6, r2, #16
 800525c:	2504      	movs	r5, #4
 800525e:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005260:	f103 001c 	add.w	r0, r3, #28
 8005264:	f103 0110 	add.w	r1, r3, #16
 8005268:	605e      	str	r6, [r3, #4]
 800526a:	625d      	str	r5, [r3, #36]	; 0x24
 800526c:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 800526e:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8005270:	609a      	str	r2, [r3, #8]
 8005272:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8005274:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005276:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8005278:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 800527a:	bc70      	pop	{r4, r5, r6}
 800527c:	4770      	bx	lr
 800527e:	bf00      	nop
 8005280:	20000868 	.word	0x20000868
 8005284:	20001290 	.word	0x20001290
 8005288:	f3af 8000 	nop.w
 800528c:	f3af 8000 	nop.w

08005290 <bmk_thread1.lto_priv.89>:

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 8005290:	b570      	push	{r4, r5, r6, lr}
 8005292:	2620      	movs	r6, #32
 8005294:	2500      	movs	r5, #0
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8005296:	f7ff f883 	bl	80043a0 <chMsgWait>
 800529a:	6a44      	ldr	r4, [r0, #36]	; 0x24
 800529c:	f386 8811 	msr	BASEPRI, r6
 80052a0:	4621      	mov	r1, r4
 80052a2:	f000 fefd 	bl	80060a0 <chSchWakeupS>
 80052a6:	f385 8811 	msr	BASEPRI, r5
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 80052aa:	2c00      	cmp	r4, #0
 80052ac:	d1f3      	bne.n	8005296 <bmk_thread1.lto_priv.89+0x6>
}
 80052ae:	bd70      	pop	{r4, r5, r6, pc}

080052b0 <test_009_001_execute.lto_priv.176>:

static void test_009_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}

static void test_009_001_execute(void) {
 80052b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  unsigned i;

  /* [9.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 80052b4:	4e39      	ldr	r6, [pc, #228]	; (800539c <test_009_001_execute.lto_priv.176+0xec>)
 80052b6:	4b3a      	ldr	r3, [pc, #232]	; (80053a0 <test_009_001_execute.lto_priv.176+0xf0>)
 80052b8:	4c3a      	ldr	r4, [pc, #232]	; (80053a4 <test_009_001_execute.lto_priv.176+0xf4>)
 80052ba:	2201      	movs	r2, #1
 80052bc:	6032      	str	r2, [r6, #0]
 80052be:	2520      	movs	r5, #32
 80052c0:	2204      	movs	r2, #4
 80052c2:	2000      	movs	r0, #0
 80052c4:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 80052c8:	6821      	ldr	r1, [r4, #0]
 80052ca:	6019      	str	r1, [r3, #0]
  mp->next = php;
 80052cc:	6023      	str	r3, [r4, #0]
 80052ce:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80052d2:	6861      	ldr	r1, [r4, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 80052d4:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 80052d6:	440b      	add	r3, r1
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 80052d8:	d1f4      	bne.n	80052c4 <test_009_001_execute.lto_priv.176+0x14>
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 80052da:	2302      	movs	r3, #2
 80052dc:	6033      	str	r3, [r6, #0]
 80052de:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 80052e0:	4830      	ldr	r0, [pc, #192]	; (80053a4 <test_009_001_execute.lto_priv.176+0xf4>)
 80052e2:	f7fe ff8d 	bl	8004200 <chPoolAlloc>
 80052e6:	3000      	adds	r0, #0
 80052e8:	bf18      	it	ne
 80052ea:	2001      	movne	r0, #1
 80052ec:	492e      	ldr	r1, [pc, #184]	; (80053a8 <test_009_001_execute.lto_priv.176+0xf8>)
 80052ee:	f7fe ff1f 	bl	8004130 <_test_assert>
 80052f2:	2800      	cmp	r0, #0
 80052f4:	d13e      	bne.n	8005374 <test_009_001_execute.lto_priv.176+0xc4>
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 80052f6:	3d01      	subs	r5, #1
 80052f8:	d1f2      	bne.n	80052e0 <test_009_001_execute.lto_priv.176+0x30>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 80052fa:	2303      	movs	r3, #3
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80052fc:	4829      	ldr	r0, [pc, #164]	; (80053a4 <test_009_001_execute.lto_priv.176+0xf4>)
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 80052fe:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8005300:	f7fe ff7e 	bl	8004200 <chPoolAlloc>
 8005304:	4929      	ldr	r1, [pc, #164]	; (80053ac <test_009_001_execute.lto_priv.176+0xfc>)
 8005306:	fab0 f080 	clz	r0, r0
 800530a:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 800530c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 800539c <test_009_001_execute.lto_priv.176+0xec>
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8005310:	f7fe ff0e 	bl	8004130 <_test_assert>
 8005314:	bb70      	cbnz	r0, 8005374 <test_009_001_execute.lto_priv.176+0xc4>
 8005316:	4b22      	ldr	r3, [pc, #136]	; (80053a0 <test_009_001_execute.lto_priv.176+0xf0>)
  }

  /* [9.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 8005318:	2204      	movs	r2, #4
 800531a:	f103 0710 	add.w	r7, r3, #16
 800531e:	f8c8 2000 	str.w	r2, [r8]
 8005322:	2020      	movs	r0, #32
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      chPoolFree(&mp1, &objects[i]);
 8005324:	461a      	mov	r2, r3
 8005326:	f380 8811 	msr	BASEPRI, r0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800532a:	6821      	ldr	r1, [r4, #0]
 800532c:	f843 1b04 	str.w	r1, [r3], #4
  mp->next = php;
 8005330:	6022      	str	r2, [r4, #0]
 8005332:	f385 8811 	msr	BASEPRI, r5
  }

  /* [9.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005336:	42bb      	cmp	r3, r7
 8005338:	d1f4      	bne.n	8005324 <test_009_001_execute.lto_priv.176+0x74>
      chPoolFree(&mp1, &objects[i]);
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 800533a:	2305      	movs	r3, #5
 800533c:	6033      	str	r3, [r6, #0]
 800533e:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8005340:	4d18      	ldr	r5, [pc, #96]	; (80053a4 <test_009_001_execute.lto_priv.176+0xf4>)
 8005342:	4628      	mov	r0, r5
 8005344:	f7fe ff5c 	bl	8004200 <chPoolAlloc>
 8005348:	3000      	adds	r0, #0
 800534a:	bf18      	it	ne
 800534c:	2001      	movne	r0, #1
 800534e:	4916      	ldr	r1, [pc, #88]	; (80053a8 <test_009_001_execute.lto_priv.176+0xf8>)
 8005350:	f7fe feee 	bl	8004130 <_test_assert>
 8005354:	b970      	cbnz	r0, 8005374 <test_009_001_execute.lto_priv.176+0xc4>
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005356:	3c01      	subs	r4, #1
 8005358:	d1f2      	bne.n	8005340 <test_009_001_execute.lto_priv.176+0x90>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800535a:	2306      	movs	r3, #6
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800535c:	4628      	mov	r0, r5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800535e:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8005360:	f7fe ff4e 	bl	8004200 <chPoolAlloc>
 8005364:	4911      	ldr	r1, [pc, #68]	; (80053ac <test_009_001_execute.lto_priv.176+0xfc>)
 8005366:	fab0 f080 	clz	r0, r0
 800536a:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800536c:	4e0b      	ldr	r6, [pc, #44]	; (800539c <test_009_001_execute.lto_priv.176+0xec>)
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800536e:	f7fe fedf 	bl	8004130 <_test_assert>
 8005372:	b108      	cbz	r0, 8005378 <test_009_001_execute.lto_priv.176+0xc8>
 8005374:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }

  /* [9.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 8005378:	2107      	movs	r1, #7
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 800537a:	2204      	movs	r2, #4
  mp->provider = provider;
 800537c:	4b0c      	ldr	r3, [pc, #48]	; (80053b0 <test_009_001_execute.lto_priv.176+0x100>)
 800537e:	6031      	str	r1, [r6, #0]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005380:	4628      	mov	r0, r5
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8005382:	602c      	str	r4, [r5, #0]
  mp->object_size = size;
 8005384:	606a      	str	r2, [r5, #4]
  mp->provider = provider;
 8005386:	60ab      	str	r3, [r5, #8]
 8005388:	f7fe ff3a 	bl	8004200 <chPoolAlloc>
 800538c:	4909      	ldr	r1, [pc, #36]	; (80053b4 <test_009_001_execute.lto_priv.176+0x104>)
 800538e:	fab0 f080 	clz	r0, r0
  }
}
 8005392:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [9.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 8005396:	0940      	lsrs	r0, r0, #5
 8005398:	f7fe beca 	b.w	8004130 <_test_assert>
 800539c:	20000f5c 	.word	0x20000f5c
 80053a0:	20000f90 	.word	0x20000f90
 80053a4:	2000084c 	.word	0x2000084c
 80053a8:	08008dc8 	.word	0x08008dc8
 80053ac:	08008dd4 	.word	0x08008dd4
 80053b0:	08005221 	.word	0x08005221
 80053b4:	08008de4 	.word	0x08008de4
 80053b8:	f3af 8000 	nop.w
 80053bc:	f3af 8000 	nop.w

080053c0 <test_011_002_execute.lto_priv.187>:

static void test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void test_011_002_execute(void) {
 80053c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 80053c2:	4d3d      	ldr	r5, [pc, #244]	; (80054b8 <test_011_002_execute.lto_priv.187+0xf8>)
 80053c4:	4b3d      	ldr	r3, [pc, #244]	; (80054bc <test_011_002_execute.lto_priv.187+0xfc>)
 80053c6:	493e      	ldr	r1, [pc, #248]	; (80054c0 <test_011_002_execute.lto_priv.187+0x100>)
 80053c8:	2201      	movs	r2, #1
 80053ca:	602a      	str	r2, [r5, #0]
 80053cc:	f103 0710 	add.w	r7, r3, #16
 80053d0:	2620      	movs	r6, #32
 80053d2:	2400      	movs	r4, #0
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 80053d4:	f853 2b04 	ldr.w	r2, [r3], #4
 80053d8:	f386 8811 	msr	BASEPRI, r6
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 80053dc:	6808      	ldr	r0, [r1, #0]
 80053de:	6010      	str	r0, [r2, #0]
  mp->next = php;
 80053e0:	600a      	str	r2, [r1, #0]
 80053e2:	f384 8811 	msr	BASEPRI, r4
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 80053e6:	42bb      	cmp	r3, r7
 80053e8:	d1f4      	bne.n	80053d4 <test_011_002_execute.lto_priv.187+0x14>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80053ea:	4b36      	ldr	r3, [pc, #216]	; (80054c4 <test_011_002_execute.lto_priv.187+0x104>)
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80053ec:	4a36      	ldr	r2, [pc, #216]	; (80054c8 <test_011_002_execute.lto_priv.187+0x108>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80053ee:	699b      	ldr	r3, [r3, #24]
 80053f0:	4836      	ldr	r0, [pc, #216]	; (80054cc <test_011_002_execute.lto_priv.187+0x10c>)
 80053f2:	689e      	ldr	r6, [r3, #8]
 80053f4:	4c36      	ldr	r4, [pc, #216]	; (80054d0 <test_011_002_execute.lto_priv.187+0x110>)
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 80053f6:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80053f8:	1e71      	subs	r1, r6, #1
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 80053fa:	602b      	str	r3, [r5, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 80053fc:	f002 f878 	bl	80074f0 <chThdCreateFromMemoryPool.constprop.39>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8005400:	1eb1      	subs	r1, r6, #2
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8005402:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8005404:	4a33      	ldr	r2, [pc, #204]	; (80054d4 <test_011_002_execute.lto_priv.187+0x114>)
 8005406:	4834      	ldr	r0, [pc, #208]	; (80054d8 <test_011_002_execute.lto_priv.187+0x118>)
 8005408:	f002 f872 	bl	80074f0 <chThdCreateFromMemoryPool.constprop.39>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800540c:	1ef1      	subs	r1, r6, #3

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800540e:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8005410:	4a32      	ldr	r2, [pc, #200]	; (80054dc <test_011_002_execute.lto_priv.187+0x11c>)
 8005412:	4833      	ldr	r0, [pc, #204]	; (80054e0 <test_011_002_execute.lto_priv.187+0x120>)
 8005414:	f002 f86c 	bl	80074f0 <chThdCreateFromMemoryPool.constprop.39>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8005418:	1f31      	subs	r1, r6, #4
  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800541a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800541c:	4a31      	ldr	r2, [pc, #196]	; (80054e4 <test_011_002_execute.lto_priv.187+0x124>)
 800541e:	4832      	ldr	r0, [pc, #200]	; (80054e8 <test_011_002_execute.lto_priv.187+0x128>)
 8005420:	f002 f866 	bl	80074f0 <chThdCreateFromMemoryPool.constprop.39>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8005424:	4a31      	ldr	r2, [pc, #196]	; (80054ec <test_011_002_execute.lto_priv.187+0x12c>)
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8005426:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8005428:	1f71      	subs	r1, r6, #5
 800542a:	4831      	ldr	r0, [pc, #196]	; (80054f0 <test_011_002_execute.lto_priv.187+0x130>)
 800542c:	f002 f860 	bl	80074f0 <chThdCreateFromMemoryPool.constprop.39>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 8005430:	6823      	ldr	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8005432:	6120      	str	r0, [r4, #16]
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8005434:	2204      	movs	r2, #4
 8005436:	602a      	str	r2, [r5, #0]
  {
    test_assert((threads[0] != NULL) &&
 8005438:	2b00      	cmp	r3, #0
 800543a:	d03b      	beq.n	80054b4 <test_011_002_execute.lto_priv.187+0xf4>
 800543c:	6860      	ldr	r0, [r4, #4]
 800543e:	b128      	cbz	r0, 800544c <test_011_002_execute.lto_priv.187+0x8c>
 8005440:	68a0      	ldr	r0, [r4, #8]
 8005442:	b118      	cbz	r0, 800544c <test_011_002_execute.lto_priv.187+0x8c>
 8005444:	68e0      	ldr	r0, [r4, #12]
 8005446:	3000      	adds	r0, #0
 8005448:	bf18      	it	ne
 800544a:	2001      	movne	r0, #1
 800544c:	4929      	ldr	r1, [pc, #164]	; (80054f4 <test_011_002_execute.lto_priv.187+0x134>)
 800544e:	f7fe fe6f 	bl	8004130 <_test_assert>
 8005452:	b100      	cbz	r0, 8005456 <test_011_002_execute.lto_priv.187+0x96>
 8005454:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8005456:	6920      	ldr	r0, [r4, #16]
 8005458:	4927      	ldr	r1, [pc, #156]	; (80054f8 <test_011_002_execute.lto_priv.187+0x138>)
 800545a:	fab0 f080 	clz	r0, r0
 800545e:	0940      	lsrs	r0, r0, #5
 8005460:	f7fe fe66 	bl	8004130 <_test_assert>
 8005464:	2800      	cmp	r0, #0
 8005466:	d1f5      	bne.n	8005454 <test_011_002_execute.lto_priv.187+0x94>
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8005468:	2305      	movs	r3, #5
 800546a:	602b      	str	r3, [r5, #0]
  {
    test_wait_threads();
 800546c:	f7fd fe68 	bl	8003140 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8005470:	4822      	ldr	r0, [pc, #136]	; (80054fc <test_011_002_execute.lto_priv.187+0x13c>)
 8005472:	4923      	ldr	r1, [pc, #140]	; (8005500 <test_011_002_execute.lto_priv.187+0x140>)
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 8005474:	4c10      	ldr	r4, [pc, #64]	; (80054b8 <test_011_002_execute.lto_priv.187+0xf8>)
  {
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8005476:	f7fe fe33 	bl	80040e0 <_test_assert_sequence>
 800547a:	2800      	cmp	r0, #0
 800547c:	d1ea      	bne.n	8005454 <test_011_002_execute.lto_priv.187+0x94>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 800547e:	2306      	movs	r3, #6
 8005480:	6023      	str	r3, [r4, #0]
 8005482:	2404      	movs	r4, #4
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 8005484:	480e      	ldr	r0, [pc, #56]	; (80054c0 <test_011_002_execute.lto_priv.187+0x100>)
 8005486:	f7fe febb 	bl	8004200 <chPoolAlloc>
 800548a:	3000      	adds	r0, #0
 800548c:	bf18      	it	ne
 800548e:	2001      	movne	r0, #1
 8005490:	491c      	ldr	r1, [pc, #112]	; (8005504 <test_011_002_execute.lto_priv.187+0x144>)
 8005492:	f7fe fe4d 	bl	8004130 <_test_assert>
 8005496:	2800      	cmp	r0, #0
 8005498:	d1dc      	bne.n	8005454 <test_011_002_execute.lto_priv.187+0x94>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 800549a:	3c01      	subs	r4, #1
 800549c:	d1f2      	bne.n	8005484 <test_011_002_execute.lto_priv.187+0xc4>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800549e:	4808      	ldr	r0, [pc, #32]	; (80054c0 <test_011_002_execute.lto_priv.187+0x100>)
 80054a0:	f7fe feae 	bl	8004200 <chPoolAlloc>
 80054a4:	4918      	ldr	r1, [pc, #96]	; (8005508 <test_011_002_execute.lto_priv.187+0x148>)
 80054a6:	fab0 f080 	clz	r0, r0
  }
}
 80054aa:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80054ae:	0940      	lsrs	r0, r0, #5
 80054b0:	f7fe be3e 	b.w	8004130 <_test_assert>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 80054b4:	4618      	mov	r0, r3
 80054b6:	e7c9      	b.n	800544c <test_011_002_execute.lto_priv.187+0x8c>
 80054b8:	20000f5c 	.word	0x20000f5c
 80054bc:	08007aa0 	.word	0x08007aa0
 80054c0:	20001350 	.word	0x20001350
 80054c4:	200012a0 	.word	0x200012a0
 80054c8:	08007a10 	.word	0x08007a10
 80054cc:	08008e00 	.word	0x08008e00
 80054d0:	20000f60 	.word	0x20000f60
 80054d4:	08008178 	.word	0x08008178
 80054d8:	08008e08 	.word	0x08008e08
 80054dc:	0800817c 	.word	0x0800817c
 80054e0:	08008e10 	.word	0x08008e10
 80054e4:	08007f18 	.word	0x08007f18
 80054e8:	08008e18 	.word	0x08008e18
 80054ec:	08008174 	.word	0x08008174
 80054f0:	08008e20 	.word	0x08008e20
 80054f4:	08008e28 	.word	0x08008e28
 80054f8:	08008e40 	.word	0x08008e40
 80054fc:	080079f4 	.word	0x080079f4
 8005500:	0800792c 	.word	0x0800792c
 8005504:	08008e5c 	.word	0x08008e5c
 8005508:	08008e6c 	.word	0x08008e6c
 800550c:	f3af 8000 	nop.w

08005510 <dyn_thread1.lto_priv.73>:
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {

  test_emit_token(*(char *)p);
 8005510:	7800      	ldrb	r0, [r0, #0]
 8005512:	f7fe bc1d 	b.w	8003d50 <test_emit_token>
 8005516:	bf00      	nop
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <test_011_001_execute.lto_priv.185>:

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 8005520:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8005524:	4b45      	ldr	r3, [pc, #276]	; (800563c <test_011_001_execute.lto_priv.185+0x11c>)
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8005526:	4c46      	ldr	r4, [pc, #280]	; (8005640 <test_011_001_execute.lto_priv.185+0x120>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8005528:	699b      	ldr	r3, [r3, #24]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800552a:	4846      	ldr	r0, [pc, #280]	; (8005644 <test_011_001_execute.lto_priv.185+0x124>)
 800552c:	689e      	ldr	r6, [r3, #8]

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 800552e:	b086      	sub	sp, #24
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8005530:	2302      	movs	r3, #2
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8005532:	a902      	add	r1, sp, #8
 8005534:	aa03      	add	r2, sp, #12
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8005536:	6023      	str	r3, [r4, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8005538:	f7fe fe7a 	bl	8004230 <chHeapStatus>
    test_assert(n1 == 1, "heap fragmented");
 800553c:	4942      	ldr	r1, [pc, #264]	; (8005648 <test_011_001_execute.lto_priv.185+0x128>)
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800553e:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 8005540:	f1a0 0001 	sub.w	r0, r0, #1
 8005544:	fab0 f080 	clz	r0, r0
 8005548:	0940      	lsrs	r0, r0, #5
 800554a:	f7fe fdf1 	bl	8004130 <_test_assert>
 800554e:	b110      	cbz	r0, 8005556 <test_011_001_execute.lto_priv.185+0x36>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 8005550:	b006      	add	sp, #24
 8005552:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8005556:	4b3d      	ldr	r3, [pc, #244]	; (800564c <test_011_001_execute.lto_priv.185+0x12c>)
 8005558:	9301      	str	r3, [sp, #4]
 800555a:	f8df 812c 	ldr.w	r8, [pc, #300]	; 8005688 <test_011_001_execute.lto_priv.185+0x168>
 800555e:	f8cd 8000 	str.w	r8, [sp]
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8005562:	2303      	movs	r3, #3
 8005564:	6023      	str	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8005566:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800556a:	4836      	ldr	r0, [pc, #216]	; (8005644 <test_011_001_execute.lto_priv.185+0x124>)
 800556c:	4a38      	ldr	r2, [pc, #224]	; (8005650 <test_011_001_execute.lto_priv.185+0x130>)
 800556e:	4f39      	ldr	r7, [pc, #228]	; (8005654 <test_011_001_execute.lto_priv.185+0x134>)
 8005570:	1e73      	subs	r3, r6, #1
 8005572:	f7fe feed 	bl	8004350 <chThdCreateFromHeap>
 8005576:	6038      	str	r0, [r7, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 8005578:	3000      	adds	r0, #0
 800557a:	bf18      	it	ne
 800557c:	2001      	movne	r0, #1
 800557e:	4936      	ldr	r1, [pc, #216]	; (8005658 <test_011_001_execute.lto_priv.185+0x138>)
 8005580:	f7fe fdd6 	bl	8004130 <_test_assert>
 8005584:	2800      	cmp	r0, #0
 8005586:	d1e3      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8005588:	4b34      	ldr	r3, [pc, #208]	; (800565c <test_011_001_execute.lto_priv.185+0x13c>)
 800558a:	9301      	str	r3, [sp, #4]
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 800558c:	2304      	movs	r3, #4
 800558e:	6023      	str	r3, [r4, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 8005590:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8005594:	1eb3      	subs	r3, r6, #2
 8005596:	f8cd 8000 	str.w	r8, [sp]
 800559a:	482a      	ldr	r0, [pc, #168]	; (8005644 <test_011_001_execute.lto_priv.185+0x124>)
 800559c:	4a30      	ldr	r2, [pc, #192]	; (8005660 <test_011_001_execute.lto_priv.185+0x140>)
 800559e:	f7fe fed7 	bl	8004350 <chThdCreateFromHeap>
 80055a2:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80055a4:	3000      	adds	r0, #0
 80055a6:	bf18      	it	ne
 80055a8:	2001      	movne	r0, #1
 80055aa:	492b      	ldr	r1, [pc, #172]	; (8005658 <test_011_001_execute.lto_priv.185+0x138>)
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80055ac:	607b      	str	r3, [r7, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80055ae:	f7fe fdbf 	bl	8004130 <_test_assert>
 80055b2:	2800      	cmp	r0, #0
 80055b4:	d1cc      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80055b6:	4a2b      	ldr	r2, [pc, #172]	; (8005664 <test_011_001_execute.lto_priv.185+0x144>)
 80055b8:	9201      	str	r2, [sp, #4]
 80055ba:	1ef3      	subs	r3, r6, #3
 80055bc:	492a      	ldr	r1, [pc, #168]	; (8005668 <test_011_001_execute.lto_priv.185+0x148>)
 80055be:	f8cd 8000 	str.w	r8, [sp]
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80055c2:	2605      	movs	r6, #5
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80055c4:	481f      	ldr	r0, [pc, #124]	; (8005644 <test_011_001_execute.lto_priv.185+0x124>)
 80055c6:	4a29      	ldr	r2, [pc, #164]	; (800566c <test_011_001_execute.lto_priv.185+0x14c>)
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80055c8:	6026      	str	r6, [r4, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80055ca:	f7fe fec1 	bl	8004350 <chThdCreateFromHeap>
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80055ce:	4928      	ldr	r1, [pc, #160]	; (8005670 <test_011_001_execute.lto_priv.185+0x150>)
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80055d0:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80055d2:	fab0 f080 	clz	r0, r0
 80055d6:	40f0      	lsrs	r0, r6
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80055d8:	60bb      	str	r3, [r7, #8]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80055da:	f7fe fda9 	bl	8004130 <_test_assert>
 80055de:	2800      	cmp	r0, #0
 80055e0:	d1b6      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
  }

  /* [11.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 80055e2:	2306      	movs	r3, #6
 80055e4:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 80055e6:	f7fd fdab 	bl	8003140 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 80055ea:	4822      	ldr	r0, [pc, #136]	; (8005674 <test_011_001_execute.lto_priv.185+0x154>)
 80055ec:	4922      	ldr	r1, [pc, #136]	; (8005678 <test_011_001_execute.lto_priv.185+0x158>)
 80055ee:	f7fe fd77 	bl	80040e0 <_test_assert_sequence>
 80055f2:	2800      	cmp	r0, #0
 80055f4:	d1ac      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 80055f6:	2307      	movs	r3, #7
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 80055f8:	a904      	add	r1, sp, #16
 80055fa:	4812      	ldr	r0, [pc, #72]	; (8005644 <test_011_001_execute.lto_priv.185+0x124>)
    test_wait_threads();
    test_assert_sequence("AB", "invalid sequence");
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 80055fc:	6023      	str	r3, [r4, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 80055fe:	aa05      	add	r2, sp, #20
 8005600:	f7fe fe16 	bl	8004230 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8005604:	491d      	ldr	r1, [pc, #116]	; (800567c <test_011_001_execute.lto_priv.185+0x15c>)
 8005606:	1a28      	subs	r0, r5, r0
 8005608:	fab0 f080 	clz	r0, r0
 800560c:	0940      	lsrs	r0, r0, #5
 800560e:	f7fe fd8f 	bl	8004130 <_test_assert>
 8005612:	2800      	cmp	r0, #0
 8005614:	d19c      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
    test_assert(total1 == total2, "total free space changed");
 8005616:	9802      	ldr	r0, [sp, #8]
 8005618:	9b04      	ldr	r3, [sp, #16]
 800561a:	4919      	ldr	r1, [pc, #100]	; (8005680 <test_011_001_execute.lto_priv.185+0x160>)
 800561c:	1ac2      	subs	r2, r0, r3
 800561e:	4250      	negs	r0, r2
 8005620:	4150      	adcs	r0, r2
 8005622:	f7fe fd85 	bl	8004130 <_test_assert>
 8005626:	2800      	cmp	r0, #0
 8005628:	d192      	bne.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
    test_assert(largest1 == largest2, "largest fragment size changed");
 800562a:	9803      	ldr	r0, [sp, #12]
 800562c:	9b05      	ldr	r3, [sp, #20]
 800562e:	4915      	ldr	r1, [pc, #84]	; (8005684 <test_011_001_execute.lto_priv.185+0x164>)
 8005630:	1ac3      	subs	r3, r0, r3
 8005632:	4258      	negs	r0, r3
 8005634:	4158      	adcs	r0, r3
 8005636:	f7fe fd7b 	bl	8004130 <_test_assert>
 800563a:	e789      	b.n	8005550 <test_011_001_execute.lto_priv.185+0x30>
 800563c:	200012a0 	.word	0x200012a0
 8005640:	20000f5c 	.word	0x20000f5c
 8005644:	20000fc0 	.word	0x20000fc0
 8005648:	08008e80 	.word	0x08008e80
 800564c:	08007a10 	.word	0x08007a10
 8005650:	08008e00 	.word	0x08008e00
 8005654:	20000f60 	.word	0x20000f60
 8005658:	08008e28 	.word	0x08008e28
 800565c:	08008178 	.word	0x08008178
 8005660:	08008e08 	.word	0x08008e08
 8005664:	0800817c 	.word	0x0800817c
 8005668:	000200c8 	.word	0x000200c8
 800566c:	08008e10 	.word	0x08008e10
 8005670:	08008e40 	.word	0x08008e40
 8005674:	08008e90 	.word	0x08008e90
 8005678:	0800792c 	.word	0x0800792c
 800567c:	08008e94 	.word	0x08008e94
 8005680:	08008eac 	.word	0x08008eac
 8005684:	08008ec8 	.word	0x08008ec8
 8005688:	08005511 	.word	0x08005511
 800568c:	f3af 8000 	nop.w

08005690 <test_010_002_execute.lto_priv.183>:
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 8005690:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8005692:	4c15      	ldr	r4, [pc, #84]	; (80056e8 <test_010_002_execute.lto_priv.183+0x58>)
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 8005694:	b082      	sub	sp, #8
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8005696:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8005698:	aa01      	add	r2, sp, #4
 800569a:	4669      	mov	r1, sp
 800569c:	2000      	movs	r0, #0
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 800569e:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 80056a0:	f7fe fdc6 	bl	8004230 <chHeapStatus>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 80056a4:	2110      	movs	r1, #16
 80056a6:	4811      	ldr	r0, [pc, #68]	; (80056ec <test_010_002_execute.lto_priv.183+0x5c>)
 80056a8:	f001 fea2 	bl	80073f0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 80056ac:	4606      	mov	r6, r0
 80056ae:	3000      	adds	r0, #0
 80056b0:	490f      	ldr	r1, [pc, #60]	; (80056f0 <test_010_002_execute.lto_priv.183+0x60>)
 80056b2:	bf18      	it	ne
 80056b4:	2001      	movne	r0, #1
 80056b6:	f7fe fd3b 	bl	8004130 <_test_assert>
 80056ba:	4605      	mov	r5, r0
 80056bc:	b108      	cbz	r0, 80056c2 <test_010_002_execute.lto_priv.183+0x32>
  test_set_step(2);
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  }
}
 80056be:	b002      	add	sp, #8
 80056c0:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(1);
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
    chHeapFree(p1);
 80056c2:	4630      	mov	r0, r6
 80056c4:	f7fe fdec 	bl	80042a0 <chHeapFree>
  }

  /* [10.2.2] Testing allocation failure.*/
  test_set_step(2);
 80056c8:	2302      	movs	r3, #2
 80056ca:	4628      	mov	r0, r5
 80056cc:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 80056d0:	6023      	str	r3, [r4, #0]
 80056d2:	f001 fe8d 	bl	80073f0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 80056d6:	4907      	ldr	r1, [pc, #28]	; (80056f4 <test_010_002_execute.lto_priv.183+0x64>)
 80056d8:	fab0 f080 	clz	r0, r0
 80056dc:	0940      	lsrs	r0, r0, #5
 80056de:	f7fe fd27 	bl	8004130 <_test_assert>
  }
}
 80056e2:	b002      	add	sp, #8
 80056e4:	bd70      	pop	{r4, r5, r6, pc}
 80056e6:	bf00      	nop
 80056e8:	20000f5c 	.word	0x20000f5c
 80056ec:	20000fa0 	.word	0x20000fa0
 80056f0:	08008ee8 	.word	0x08008ee8
 80056f4:	08008efc 	.word	0x08008efc
 80056f8:	f3af 8000 	nop.w
 80056fc:	f3af 8000 	nop.w

08005700 <test_010_001_execute.lto_priv.182>:

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_010_001_execute(void) {
 8005700:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8005704:	4cbe      	ldr	r4, [pc, #760]	; (8005a00 <test_010_001_execute.lto_priv.182+0x300>)
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8005706:	48bf      	ldr	r0, [pc, #764]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_010_001_execute(void) {
 8005708:	b084      	sub	sp, #16
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 800570a:	2301      	movs	r3, #1
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 800570c:	a901      	add	r1, sp, #4
 800570e:	2200      	movs	r2, #0
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8005710:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8005712:	f7fe fd8d 	bl	8004230 <chHeapStatus>
 8005716:	49bc      	ldr	r1, [pc, #752]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 8005718:	f1a0 0001 	sub.w	r0, r0, #1
 800571c:	fab0 f080 	clz	r0, r0
 8005720:	0940      	lsrs	r0, r0, #5
 8005722:	f7fe fd05 	bl	8004130 <_test_assert>
 8005726:	b110      	cbz	r0, 800572e <test_010_001_execute.lto_priv.182+0x2e>
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
    test_assert(n == sz, "size changed");
  }
}
 8005728:	b004      	add	sp, #16
 800572a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  }

  /* [10.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 800572e:	2302      	movs	r3, #2
 8005730:	f44f 614d 	mov.w	r1, #3280	; 0xcd0
 8005734:	48b3      	ldr	r0, [pc, #716]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005736:	6023      	str	r3, [r4, #0]
 8005738:	f001 fe5a 	bl	80073f0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
    test_assert(p1 == NULL, "allocation not failed");
 800573c:	49b3      	ldr	r1, [pc, #716]	; (8005a0c <test_010_001_execute.lto_priv.182+0x30c>)
 800573e:	fab0 f080 	clz	r0, r0
 8005742:	0940      	lsrs	r0, r0, #5
 8005744:	f7fe fcf4 	bl	8004130 <_test_assert>
 8005748:	2800      	cmp	r0, #0
 800574a:	d1ed      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.3] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 800574c:	2303      	movs	r3, #3
 800574e:	2110      	movs	r1, #16
 8005750:	48ac      	ldr	r0, [pc, #688]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005752:	6023      	str	r3, [r4, #0]
 8005754:	f001 fe4c 	bl	80073f0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8005758:	4605      	mov	r5, r0
 800575a:	3000      	adds	r0, #0
 800575c:	bf18      	it	ne
 800575e:	2001      	movne	r0, #1
 8005760:	49ab      	ldr	r1, [pc, #684]	; (8005a10 <test_010_001_execute.lto_priv.182+0x310>)
 8005762:	f7fe fce5 	bl	8004130 <_test_assert>
 8005766:	2800      	cmp	r0, #0
 8005768:	d1de      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
    chHeapFree(p1);
 800576a:	4628      	mov	r0, r5
 800576c:	f7fe fd98 	bl	80042a0 <chHeapFree>
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8005770:	2304      	movs	r3, #4
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8005772:	a902      	add	r1, sp, #8
 8005774:	48a3      	ldr	r0, [pc, #652]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
    chHeapFree(p1);
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8005776:	6023      	str	r3, [r4, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8005778:	aa03      	add	r2, sp, #12
 800577a:	f7fe fd59 	bl	8004230 <chHeapStatus>
    test_assert(n == 1, "missing free block");
 800577e:	49a5      	ldr	r1, [pc, #660]	; (8005a14 <test_010_001_execute.lto_priv.182+0x314>)
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8005780:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8005782:	f1a0 0001 	sub.w	r0, r0, #1
 8005786:	fab0 f080 	clz	r0, r0
 800578a:	0940      	lsrs	r0, r0, #5
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 800578c:	9300      	str	r3, [sp, #0]
    test_assert(n == 1, "missing free block");
 800578e:	f7fe fccf 	bl	8004130 <_test_assert>
 8005792:	2800      	cmp	r0, #0
 8005794:	d1c8      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8005796:	9802      	ldr	r0, [sp, #8]
 8005798:	499f      	ldr	r1, [pc, #636]	; (8005a18 <test_010_001_execute.lto_priv.182+0x318>)
 800579a:	280f      	cmp	r0, #15
 800579c:	bf94      	ite	ls
 800579e:	2000      	movls	r0, #0
 80057a0:	2001      	movhi	r0, #1
 80057a2:	f7fe fcc5 	bl	8004130 <_test_assert>
 80057a6:	2800      	cmp	r0, #0
 80057a8:	d1be      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 80057aa:	9802      	ldr	r0, [sp, #8]
 80057ac:	9b03      	ldr	r3, [sp, #12]
 80057ae:	499a      	ldr	r1, [pc, #616]	; (8005a18 <test_010_001_execute.lto_priv.182+0x318>)
 80057b0:	1ac0      	subs	r0, r0, r3
 80057b2:	fab0 f080 	clz	r0, r0
 80057b6:	0940      	lsrs	r0, r0, #5
 80057b8:	f7fe fcba 	bl	8004130 <_test_assert>
 80057bc:	4605      	mov	r5, r0
 80057be:	2800      	cmp	r0, #0
 80057c0:	d1b2      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 80057c2:	2305      	movs	r3, #5
 80057c4:	2110      	movs	r1, #16
 80057c6:	488f      	ldr	r0, [pc, #572]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80057c8:	6023      	str	r3, [r4, #0]
 80057ca:	f001 fe11 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 80057ce:	2110      	movs	r1, #16
 80057d0:	4680      	mov	r8, r0
 80057d2:	488c      	ldr	r0, [pc, #560]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80057d4:	f001 fe0c 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 80057d8:	2110      	movs	r1, #16
 80057da:	4607      	mov	r7, r0
 80057dc:	4889      	ldr	r0, [pc, #548]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80057de:	f001 fe07 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 80057e2:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);                                 /* Does not merge.*/
 80057e4:	4640      	mov	r0, r8
 80057e6:	f7fe fd5b 	bl	80042a0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 80057ea:	4638      	mov	r0, r7
 80057ec:	f7fe fd58 	bl	80042a0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 80057f0:	4630      	mov	r0, r6
 80057f2:	f7fe fd55 	bl	80042a0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80057f6:	462a      	mov	r2, r5
 80057f8:	4669      	mov	r1, sp
 80057fa:	4882      	ldr	r0, [pc, #520]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80057fc:	f7fe fd18 	bl	8004230 <chHeapStatus>
 8005800:	1e42      	subs	r2, r0, #1
 8005802:	4250      	negs	r0, r2
 8005804:	4980      	ldr	r1, [pc, #512]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 8005806:	4150      	adcs	r0, r2
 8005808:	f7fe fc92 	bl	8004130 <_test_assert>
 800580c:	4605      	mov	r5, r0
 800580e:	2800      	cmp	r0, #0
 8005810:	d18a      	bne.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 8005812:	2306      	movs	r3, #6
 8005814:	2110      	movs	r1, #16
 8005816:	487b      	ldr	r0, [pc, #492]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005818:	6023      	str	r3, [r4, #0]
 800581a:	f001 fde9 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 800581e:	2110      	movs	r1, #16
 8005820:	4606      	mov	r6, r0
 8005822:	4878      	ldr	r0, [pc, #480]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005824:	f001 fde4 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 8005828:	2110      	movs	r1, #16
 800582a:	4607      	mov	r7, r0
 800582c:	4875      	ldr	r0, [pc, #468]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 800582e:	f001 fddf 	bl	80073f0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p3);                                 /* Merges forward.*/
 8005832:	f7fe fd35 	bl	80042a0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8005836:	4638      	mov	r0, r7
 8005838:	f7fe fd32 	bl	80042a0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 800583c:	4630      	mov	r0, r6
 800583e:	f7fe fd2f 	bl	80042a0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8005842:	462a      	mov	r2, r5
 8005844:	4669      	mov	r1, sp
 8005846:	486f      	ldr	r0, [pc, #444]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005848:	f7fe fcf2 	bl	8004230 <chHeapStatus>
 800584c:	1e43      	subs	r3, r0, #1
 800584e:	4258      	negs	r0, r3
 8005850:	496d      	ldr	r1, [pc, #436]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 8005852:	4158      	adcs	r0, r3
 8005854:	f7fe fc6c 	bl	8004130 <_test_assert>
 8005858:	4605      	mov	r5, r0
 800585a:	2800      	cmp	r0, #0
 800585c:	f47f af64 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 8005860:	2307      	movs	r3, #7
 8005862:	2111      	movs	r1, #17
 8005864:	4867      	ldr	r0, [pc, #412]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005866:	6023      	str	r3, [r4, #0]
 8005868:	f001 fdc2 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 800586c:	2110      	movs	r1, #16
 800586e:	4606      	mov	r6, r0
 8005870:	4864      	ldr	r0, [pc, #400]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005872:	f001 fdbd 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 8005876:	4607      	mov	r7, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 8005878:	4630      	mov	r0, r6
 800587a:	f7fe fd11 	bl	80042a0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 800587e:	462a      	mov	r2, r5
 8005880:	4669      	mov	r1, sp
 8005882:	4860      	ldr	r0, [pc, #384]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005884:	f7fe fcd4 	bl	8004230 <chHeapStatus>
 8005888:	f1a0 0802 	sub.w	r8, r0, #2
 800588c:	f1d8 0000 	rsbs	r0, r8, #0
 8005890:	4962      	ldr	r1, [pc, #392]	; (8005a1c <test_010_001_execute.lto_priv.182+0x31c>)
 8005892:	eb40 0008 	adc.w	r0, r0, r8
 8005896:	f7fe fc4b 	bl	8004130 <_test_assert>
 800589a:	4605      	mov	r5, r0
 800589c:	2800      	cmp	r0, #0
 800589e:	f47f af43 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
 80058a2:	2110      	movs	r1, #16
 80058a4:	4857      	ldr	r0, [pc, #348]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80058a6:	f001 fda3 	bl	80073f0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 80058aa:	462a      	mov	r2, r5
 80058ac:	4606      	mov	r6, r0
 80058ae:	4669      	mov	r1, sp
 80058b0:	4854      	ldr	r0, [pc, #336]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80058b2:	f7fe fcbd 	bl	8004230 <chHeapStatus>
 80058b6:	2801      	cmp	r0, #1
 80058b8:	f000 80a0 	beq.w	80059fc <test_010_001_execute.lto_priv.182+0x2fc>
 80058bc:	4851      	ldr	r0, [pc, #324]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80058be:	4669      	mov	r1, sp
 80058c0:	2200      	movs	r2, #0
 80058c2:	f7fe fcb5 	bl	8004230 <chHeapStatus>
 80058c6:	f1a0 0c02 	sub.w	ip, r0, #2
 80058ca:	f1dc 0000 	rsbs	r0, ip, #0
 80058ce:	eb40 000c 	adc.w	r0, r0, ip
 80058d2:	494d      	ldr	r1, [pc, #308]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 80058d4:	f7fe fc2c 	bl	8004130 <_test_assert>
 80058d8:	4605      	mov	r5, r0
 80058da:	2800      	cmp	r0, #0
 80058dc:	f47f af24 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 80058e0:	4638      	mov	r0, r7
 80058e2:	f7fe fcdd 	bl	80042a0 <chHeapFree>
    chHeapFree(p1);
 80058e6:	4630      	mov	r0, r6
 80058e8:	f7fe fcda 	bl	80042a0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80058ec:	462a      	mov	r2, r5
 80058ee:	4669      	mov	r1, sp
 80058f0:	4844      	ldr	r0, [pc, #272]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80058f2:	f7fe fc9d 	bl	8004230 <chHeapStatus>
 80058f6:	f100 3eff 	add.w	lr, r0, #4294967295
 80058fa:	f1de 0000 	rsbs	r0, lr, #0
 80058fe:	4942      	ldr	r1, [pc, #264]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 8005900:	eb40 000e 	adc.w	r0, r0, lr
 8005904:	f7fe fc14 	bl	8004130 <_test_assert>
 8005908:	4605      	mov	r5, r0
 800590a:	2800      	cmp	r0, #0
 800590c:	f47f af0c 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 8005910:	2308      	movs	r3, #8
 8005912:	2110      	movs	r1, #16
 8005914:	483b      	ldr	r0, [pc, #236]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005916:	6023      	str	r3, [r4, #0]
 8005918:	f001 fd6a 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 800591c:	2110      	movs	r1, #16
 800591e:	4607      	mov	r7, r0
 8005920:	4838      	ldr	r0, [pc, #224]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005922:	4c37      	ldr	r4, [pc, #220]	; (8005a00 <test_010_001_execute.lto_priv.182+0x300>)
 8005924:	f001 fd64 	bl	80073f0 <chHeapAllocAligned.constprop.40>
 8005928:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 800592a:	4638      	mov	r0, r7
 800592c:	f7fe fcb8 	bl	80042a0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8005930:	462a      	mov	r2, r5
 8005932:	4669      	mov	r1, sp
 8005934:	4833      	ldr	r0, [pc, #204]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005936:	f7fe fc7b 	bl	8004230 <chHeapStatus>
 800593a:	1e87      	subs	r7, r0, #2
 800593c:	4278      	negs	r0, r7
 800593e:	4937      	ldr	r1, [pc, #220]	; (8005a1c <test_010_001_execute.lto_priv.182+0x31c>)
 8005940:	4178      	adcs	r0, r7
 8005942:	f7fe fbf5 	bl	8004130 <_test_assert>
 8005946:	4605      	mov	r5, r0
 8005948:	2800      	cmp	r0, #0
 800594a:	f47f aeed 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
 800594e:	2120      	movs	r1, #32
 8005950:	482c      	ldr	r0, [pc, #176]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005952:	f001 fd4d 	bl	80073f0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
    chHeapFree(p1);
 8005956:	f7fe fca3 	bl	80042a0 <chHeapFree>
    chHeapFree(p2);
 800595a:	4630      	mov	r0, r6
 800595c:	f7fe fca0 	bl	80042a0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8005960:	462a      	mov	r2, r5
 8005962:	4669      	mov	r1, sp
 8005964:	4827      	ldr	r0, [pc, #156]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 8005966:	f7fe fc63 	bl	8004230 <chHeapStatus>
 800596a:	1e45      	subs	r5, r0, #1
 800596c:	4268      	negs	r0, r5
 800596e:	4926      	ldr	r1, [pc, #152]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 8005970:	4168      	adcs	r0, r5
 8005972:	f7fe fbdd 	bl	8004130 <_test_assert>
 8005976:	4602      	mov	r2, r0
 8005978:	2800      	cmp	r0, #0
 800597a:	f47f aed5 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 800597e:	2309      	movs	r3, #9
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8005980:	4669      	mov	r1, sp
 8005982:	4820      	ldr	r0, [pc, #128]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
    chHeapFree(p2);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 8005984:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8005986:	f7fe fc53 	bl	8004230 <chHeapStatus>
 800598a:	9900      	ldr	r1, [sp, #0]
 800598c:	481d      	ldr	r0, [pc, #116]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 800598e:	f001 fd2f 	bl	80073f0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, n);
    test_assert(p1 != NULL, "allocation failed");
 8005992:	4606      	mov	r6, r0
 8005994:	3000      	adds	r0, #0
 8005996:	491e      	ldr	r1, [pc, #120]	; (8005a10 <test_010_001_execute.lto_priv.182+0x310>)
 8005998:	bf18      	it	ne
 800599a:	2001      	movne	r0, #1
 800599c:	f7fe fbc8 	bl	8004130 <_test_assert>
 80059a0:	4601      	mov	r1, r0
 80059a2:	2800      	cmp	r0, #0
 80059a4:	f47f aec0 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 80059a8:	460a      	mov	r2, r1
 80059aa:	4816      	ldr	r0, [pc, #88]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
 80059ac:	f7fe fc40 	bl	8004230 <chHeapStatus>
 80059b0:	491b      	ldr	r1, [pc, #108]	; (8005a20 <test_010_001_execute.lto_priv.182+0x320>)
 80059b2:	fab0 f080 	clz	r0, r0
 80059b6:	0940      	lsrs	r0, r0, #5
 80059b8:	f7fe fbba 	bl	8004130 <_test_assert>
 80059bc:	4605      	mov	r5, r0
 80059be:	2800      	cmp	r0, #0
 80059c0:	f47f aeb2 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
    chHeapFree(p1);
 80059c4:	4630      	mov	r0, r6
 80059c6:	f7fe fc6b 	bl	80042a0 <chHeapFree>

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80059ca:	4669      	mov	r1, sp
 80059cc:	462a      	mov	r2, r5
    chHeapFree(p1);
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 80059ce:	230a      	movs	r3, #10
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80059d0:	480c      	ldr	r0, [pc, #48]	; (8005a04 <test_010_001_execute.lto_priv.182+0x304>)
    chHeapFree(p1);
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 80059d2:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 80059d4:	f7fe fc2c 	bl	8004230 <chHeapStatus>
 80059d8:	1e42      	subs	r2, r0, #1
 80059da:	4250      	negs	r0, r2
 80059dc:	4150      	adcs	r0, r2
 80059de:	490a      	ldr	r1, [pc, #40]	; (8005a08 <test_010_001_execute.lto_priv.182+0x308>)
 80059e0:	f7fe fba6 	bl	8004130 <_test_assert>
 80059e4:	2800      	cmp	r0, #0
 80059e6:	f47f ae9f 	bne.w	8005728 <test_010_001_execute.lto_priv.182+0x28>
    test_assert(n == sz, "size changed");
 80059ea:	e89d 0009 	ldmia.w	sp, {r0, r3}
 80059ee:	1ac3      	subs	r3, r0, r3
 80059f0:	4258      	negs	r0, r3
 80059f2:	490c      	ldr	r1, [pc, #48]	; (8005a24 <test_010_001_execute.lto_priv.182+0x324>)
 80059f4:	4158      	adcs	r0, r3
 80059f6:	f7fe fb9b 	bl	8004130 <_test_assert>
 80059fa:	e695      	b.n	8005728 <test_010_001_execute.lto_priv.182+0x28>
    chHeapFree(p1);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 80059fc:	2001      	movs	r0, #1
 80059fe:	e768      	b.n	80058d2 <test_010_001_execute.lto_priv.182+0x1d2>
 8005a00:	20000f5c 	.word	0x20000f5c
 8005a04:	20000fa0 	.word	0x20000fa0
 8005a08:	08008e80 	.word	0x08008e80
 8005a0c:	08008efc 	.word	0x08008efc
 8005a10:	08008ee8 	.word	0x08008ee8
 8005a14:	08008f14 	.word	0x08008f14
 8005a18:	08008f28 	.word	0x08008f28
 8005a1c:	08008f40 	.word	0x08008f40
 8005a20:	0800794c 	.word	0x0800794c
 8005a24:	08008f50 	.word	0x08008f50
 8005a28:	f3af 8000 	nop.w
 8005a2c:	f3af 8000 	nop.w

08005a30 <test_009_003_execute.lto_priv.180>:

static void test_009_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_003_execute(void) {
 8005a30:	b508      	push	{r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8005a32:	4b07      	ldr	r3, [pc, #28]	; (8005a50 <test_009_003_execute.lto_priv.180+0x20>)
 8005a34:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8005a36:	f44f 707a 	mov.w	r0, #1000	; 0x3e8

static void test_009_003_execute(void) {

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8005a3a:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8005a3c:	f001 fe28 	bl	8007690 <chGuardedPoolAllocTimeout.constprop.19>
 8005a40:	4904      	ldr	r1, [pc, #16]	; (8005a54 <test_009_003_execute.lto_priv.180+0x24>)
 8005a42:	fab0 f080 	clz	r0, r0
  }
}
 8005a46:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8005a4a:	0940      	lsrs	r0, r0, #5
 8005a4c:	f7fe bb70 	b.w	8004130 <_test_assert>
 8005a50:	20000f5c 	.word	0x20000f5c
 8005a54:	08008dd4 	.word	0x08008dd4
 8005a58:	f3af 8000 	nop.w
 8005a5c:	f3af 8000 	nop.w

08005a60 <test_009_002_execute.lto_priv.178>:

static void test_009_002_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_002_execute(void) {
 8005a60:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  unsigned i;

  /* [9.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 8005a64:	4f35      	ldr	r7, [pc, #212]	; (8005b3c <test_009_002_execute.lto_priv.178+0xdc>)
 8005a66:	4c36      	ldr	r4, [pc, #216]	; (8005b40 <test_009_002_execute.lto_priv.178+0xe0>)
 8005a68:	4d36      	ldr	r5, [pc, #216]	; (8005b44 <test_009_002_execute.lto_priv.178+0xe4>)
 8005a6a:	2301      	movs	r3, #1
 8005a6c:	603b      	str	r3, [r7, #0]
 8005a6e:	2604      	movs	r6, #4
 8005a70:	f04f 0920 	mov.w	r9, #32
 8005a74:	f04f 0800 	mov.w	r8, #0
 8005a78:	f389 8811 	msr	BASEPRI, r9
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005a7c:	68eb      	ldr	r3, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8005a7e:	4831      	ldr	r0, [pc, #196]	; (8005b44 <test_009_002_execute.lto_priv.178+0xe4>)
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005a80:	6023      	str	r3, [r4, #0]
  mp->next = php;
 8005a82:	60ec      	str	r4, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8005a84:	f000 fcac 	bl	80063e0 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8005a88:	f000 faca 	bl	8006020 <chSchRescheduleS>
 8005a8c:	f388 8811 	msr	BASEPRI, r8
  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8005a90:	692b      	ldr	r3, [r5, #16]
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8005a92:	3e01      	subs	r6, #1
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8005a94:	441c      	add	r4, r3
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8005a96:	d1ef      	bne.n	8005a78 <test_009_002_execute.lto_priv.178+0x18>
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 8005a98:	2302      	movs	r3, #2
 8005a9a:	603b      	str	r3, [r7, #0]
 8005a9c:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005a9e:	2000      	movs	r0, #0
 8005aa0:	f001 fdf6 	bl	8007690 <chGuardedPoolAllocTimeout.constprop.19>
 8005aa4:	3000      	adds	r0, #0
 8005aa6:	bf18      	it	ne
 8005aa8:	2001      	movne	r0, #1
 8005aaa:	4927      	ldr	r1, [pc, #156]	; (8005b48 <test_009_002_execute.lto_priv.178+0xe8>)
 8005aac:	f7fe fb40 	bl	8004130 <_test_assert>
 8005ab0:	2800      	cmp	r0, #0
 8005ab2:	d141      	bne.n	8005b38 <test_009_002_execute.lto_priv.178+0xd8>
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005ab4:	3c01      	subs	r4, #1
 8005ab6:	d1f2      	bne.n	8005a9e <test_009_002_execute.lto_priv.178+0x3e>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.3] Now must be empty.*/
  test_set_step(3);
 8005ab8:	2303      	movs	r3, #3
 8005aba:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005abc:	f001 fde8 	bl	8007690 <chGuardedPoolAllocTimeout.constprop.19>
 8005ac0:	4922      	ldr	r1, [pc, #136]	; (8005b4c <test_009_002_execute.lto_priv.178+0xec>)
 8005ac2:	fab0 f080 	clz	r0, r0
 8005ac6:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.3] Now must be empty.*/
  test_set_step(3);
 8005ac8:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8005b3c <test_009_002_execute.lto_priv.178+0xdc>
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005acc:	f7fe fb30 	bl	8004130 <_test_assert>
 8005ad0:	bb90      	cbnz	r0, 8005b38 <test_009_002_execute.lto_priv.178+0xd8>
 8005ad2:	4e1b      	ldr	r6, [pc, #108]	; (8005b40 <test_009_002_execute.lto_priv.178+0xe0>)
  }

  /* [9.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 8005ad4:	2304      	movs	r3, #4
 8005ad6:	f8c8 3000 	str.w	r3, [r8]
 8005ada:	f106 0910 	add.w	r9, r6, #16
 8005ade:	f04f 0820 	mov.w	r8, #32
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      chGuardedPoolFree(&gmp1, &objects[i]);
 8005ae2:	4633      	mov	r3, r6
 8005ae4:	f388 8811 	msr	BASEPRI, r8
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005ae8:	68ea      	ldr	r2, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8005aea:	4816      	ldr	r0, [pc, #88]	; (8005b44 <test_009_002_execute.lto_priv.178+0xe4>)
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005aec:	f846 2b04 	str.w	r2, [r6], #4
  mp->next = php;
 8005af0:	60eb      	str	r3, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8005af2:	f000 fc75 	bl	80063e0 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8005af6:	f000 fa93 	bl	8006020 <chSchRescheduleS>
 8005afa:	f384 8811 	msr	BASEPRI, r4

  /* [9.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005afe:	454e      	cmp	r6, r9
 8005b00:	d1ef      	bne.n	8005ae2 <test_009_002_execute.lto_priv.178+0x82>
      chGuardedPoolFree(&gmp1, &objects[i]);
  }

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 8005b02:	2305      	movs	r3, #5
 8005b04:	603b      	str	r3, [r7, #0]
 8005b06:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8005b08:	2000      	movs	r0, #0
 8005b0a:	f001 fdc1 	bl	8007690 <chGuardedPoolAllocTimeout.constprop.19>
 8005b0e:	3000      	adds	r0, #0
 8005b10:	bf18      	it	ne
 8005b12:	2001      	movne	r0, #1
 8005b14:	490c      	ldr	r1, [pc, #48]	; (8005b48 <test_009_002_execute.lto_priv.178+0xe8>)
 8005b16:	f7fe fb0b 	bl	8004130 <_test_assert>
 8005b1a:	b968      	cbnz	r0, 8005b38 <test_009_002_execute.lto_priv.178+0xd8>

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8005b1c:	3c01      	subs	r4, #1
 8005b1e:	d1f3      	bne.n	8005b08 <test_009_002_execute.lto_priv.178+0xa8>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.6] Now must be empty again.*/
  test_set_step(6);
 8005b20:	2306      	movs	r3, #6
 8005b22:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005b24:	f001 fdb4 	bl	8007690 <chGuardedPoolAllocTimeout.constprop.19>
 8005b28:	4908      	ldr	r1, [pc, #32]	; (8005b4c <test_009_002_execute.lto_priv.178+0xec>)
 8005b2a:	fab0 f080 	clz	r0, r0
  }
}
 8005b2e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  }

  /* [9.2.6] Now must be empty again.*/
  test_set_step(6);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8005b32:	0940      	lsrs	r0, r0, #5
 8005b34:	f7fe bafc 	b.w	8004130 <_test_assert>
 8005b38:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005b3c:	20000f5c 	.word	0x20000f5c
 8005b40:	20000f90 	.word	0x20000f90
 8005b44:	20000890 	.word	0x20000890
 8005b48:	08008dc8 	.word	0x08008dc8
 8005b4c:	08008dd4 	.word	0x08008dd4

08005b50 <test_008_003_teardown.lto_priv.173>:

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
 8005b50:	f001 bd16 	b.w	8007580 <chMBReset.constprop.30>
 8005b54:	f3af 8000 	nop.w
 8005b58:	f3af 8000 	nop.w
 8005b5c:	f3af 8000 	nop.w

08005b60 <test_008_003_execute.lto_priv.174>:
}

static void test_008_003_execute(void) {
 8005b60:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 8005b62:	4d58      	ldr	r5, [pc, #352]	; (8005cc4 <test_008_003_execute.lto_priv.174+0x164>)
 8005b64:	2301      	movs	r3, #1

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_003_execute(void) {
 8005b66:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 8005b68:	602b      	str	r3, [r5, #0]
 8005b6a:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8005b6c:	4620      	mov	r0, r4
 8005b6e:	f04f 31ff 	mov.w	r1, #4294967295
 8005b72:	f001 fd15 	bl	80075a0 <chMBPost.constprop.29>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8005b76:	4954      	ldr	r1, [pc, #336]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005b78:	fab0 f080 	clz	r0, r0
 8005b7c:	0940      	lsrs	r0, r0, #5
 8005b7e:	f7fe fad7 	bl	8004130 <_test_assert>
 8005b82:	3401      	adds	r4, #1
 8005b84:	b988      	cbnz	r0, 8005baa <test_008_003_execute.lto_priv.174+0x4a>
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8005b86:	2c46      	cmp	r4, #70	; 0x46
 8005b88:	d1f0      	bne.n	8005b6c <test_008_003_execute.lto_priv.174+0xc>
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8005b8a:	2302      	movs	r3, #2
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8005b8c:	2101      	movs	r1, #1
 8005b8e:	2058      	movs	r0, #88	; 0x58
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8005b90:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8005b92:	f001 fd05 	bl	80075a0 <chMBPost.constprop.29>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005b96:	494c      	ldr	r1, [pc, #304]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005b98:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8005b9c:	fab0 f080 	clz	r0, r0
 8005ba0:	0940      	lsrs	r0, r0, #5
 8005ba2:	f7fe fac5 	bl	8004130 <_test_assert>
 8005ba6:	4604      	mov	r4, r0
 8005ba8:	b108      	cbz	r0, 8005bae <test_008_003_execute.lto_priv.174+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 8005baa:	b003      	add	sp, #12
 8005bac:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005bae:	2320      	movs	r3, #32
 8005bb0:	f383 8811 	msr	BASEPRI, r3
 8005bb4:	4e45      	ldr	r6, [pc, #276]	; (8005ccc <test_008_003_execute.lto_priv.174+0x16c>)
 8005bb6:	6a73      	ldr	r3, [r6, #36]	; 0x24
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8005bb8:	2b00      	cmp	r3, #0
 8005bba:	dd7c      	ble.n	8005cb6 <test_008_003_execute.lto_priv.174+0x156>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8005bbc:	68b1      	ldr	r1, [r6, #8]
  if (mbp->wrptr >= mbp->top) {
 8005bbe:	6870      	ldr	r0, [r6, #4]
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8005bc0:	1d0a      	adds	r2, r1, #4
 8005bc2:	3b01      	subs	r3, #1
  if (mbp->wrptr >= mbp->top) {
 8005bc4:	4282      	cmp	r2, r0
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8005bc6:	f04f 0758 	mov.w	r7, #88	; 0x58
 8005bca:	6273      	str	r3, [r6, #36]	; 0x24
 8005bcc:	60b2      	str	r2, [r6, #8]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 8005bce:	bf28      	it	cs
 8005bd0:	6833      	ldrcs	r3, [r6, #0]
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8005bd2:	600f      	str	r7, [r1, #0]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
  }
  chSemSignalI(&mbp->fullsem);
 8005bd4:	483e      	ldr	r0, [pc, #248]	; (8005cd0 <test_008_003_execute.lto_priv.174+0x170>)
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 8005bd6:	bf28      	it	cs
 8005bd8:	60b3      	strcs	r3, [r6, #8]
  }
  chSemSignalI(&mbp->fullsem);
 8005bda:	f000 fc01 	bl	80063e0 <chSemSignalI>
 8005bde:	2300      	movs	r3, #0
 8005be0:	f383 8811 	msr	BASEPRI, r3
    msg1 = chMBPost(&mb1, 'X', 1);
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
    chSysLock();
    msg1 = chMBPostI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005be4:	4938      	ldr	r1, [pc, #224]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005be6:	4620      	mov	r0, r4
 8005be8:	f7fe faa2 	bl	8004130 <_test_assert>
 8005bec:	2800      	cmp	r0, #0
 8005bee:	d1dc      	bne.n	8005baa <test_008_003_execute.lto_priv.174+0x4a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 8005bf0:	2101      	movs	r1, #1
 8005bf2:	2058      	movs	r0, #88	; 0x58
 8005bf4:	f001 fcfc 	bl	80075f0 <chMBPostAhead.constprop.27>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005bf8:	4933      	ldr	r1, [pc, #204]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005bfa:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8005bfe:	fab0 f080 	clz	r0, r0
 8005c02:	0940      	lsrs	r0, r0, #5
 8005c04:	f7fe fa94 	bl	8004130 <_test_assert>
 8005c08:	4604      	mov	r4, r0
 8005c0a:	2800      	cmp	r0, #0
 8005c0c:	d1cd      	bne.n	8005baa <test_008_003_execute.lto_priv.174+0x4a>
 8005c0e:	2320      	movs	r3, #32
 8005c10:	f383 8811 	msr	BASEPRI, r3
 8005c14:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8005c16:	4a2d      	ldr	r2, [pc, #180]	; (8005ccc <test_008_003_execute.lto_priv.174+0x16c>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8005c18:	2900      	cmp	r1, #0
 8005c1a:	dd4e      	ble.n	8005cba <test_008_003_execute.lto_priv.174+0x15a>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 8005c1c:	68d3      	ldr	r3, [r2, #12]
 8005c1e:	6810      	ldr	r0, [r2, #0]
 8005c20:	3b04      	subs	r3, #4
 8005c22:	3901      	subs	r1, #1
 8005c24:	4283      	cmp	r3, r0
 8005c26:	6251      	str	r1, [r2, #36]	; 0x24
 8005c28:	60d3      	str	r3, [r2, #12]
 8005c2a:	d202      	bcs.n	8005c32 <test_008_003_execute.lto_priv.174+0xd2>
    mbp->rdptr = mbp->top - 1;
 8005c2c:	6853      	ldr	r3, [r2, #4]
 8005c2e:	3b04      	subs	r3, #4
 8005c30:	60d3      	str	r3, [r2, #12]
  }
  *mbp->rdptr = msg;
 8005c32:	2258      	movs	r2, #88	; 0x58
 8005c34:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 8005c36:	4826      	ldr	r0, [pc, #152]	; (8005cd0 <test_008_003_execute.lto_priv.174+0x170>)
 8005c38:	f000 fbd2 	bl	80063e0 <chSemSignalI>
 8005c3c:	2300      	movs	r3, #0
 8005c3e:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c42:	4921      	ldr	r1, [pc, #132]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005c44:	4620      	mov	r0, r4
 8005c46:	f7fe fa73 	bl	8004130 <_test_assert>
 8005c4a:	2800      	cmp	r0, #0
 8005c4c:	d1ad      	bne.n	8005baa <test_008_003_execute.lto_priv.174+0x4a>
  }

  /* [8.3.3] Resetting the mailbox.*/
  test_set_step(3);
 8005c4e:	2303      	movs	r3, #3
 8005c50:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 8005c52:	f001 fc95 	bl	8007580 <chMBReset.constprop.30>
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 8005c56:	2304      	movs	r3, #4
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8005c58:	eb0d 0003 	add.w	r0, sp, r3
 8005c5c:	2101      	movs	r1, #1
  {
    chMBReset(&mb1);
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 8005c5e:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8005c60:	f001 fcee 	bl	8007640 <chMBFetch.constprop.25>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005c64:	4918      	ldr	r1, [pc, #96]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005c66:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8005c6a:	fab0 f080 	clz	r0, r0
 8005c6e:	0940      	lsrs	r0, r0, #5
 8005c70:	f7fe fa5e 	bl	8004130 <_test_assert>
 8005c74:	4604      	mov	r4, r0
 8005c76:	2800      	cmp	r0, #0
 8005c78:	d197      	bne.n	8005baa <test_008_003_execute.lto_priv.174+0x4a>
 8005c7a:	2320      	movs	r3, #32
 8005c7c:	f383 8811 	msr	BASEPRI, r3
 8005c80:	69b2      	ldr	r2, [r6, #24]
 8005c82:	4b12      	ldr	r3, [pc, #72]	; (8005ccc <test_008_003_execute.lto_priv.174+0x16c>)
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8005c84:	2a00      	cmp	r2, #0
 8005c86:	dd1a      	ble.n	8005cbe <test_008_003_execute.lto_priv.174+0x15e>
 8005c88:	1e51      	subs	r1, r2, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8005c8a:	68da      	ldr	r2, [r3, #12]
 8005c8c:	6199      	str	r1, [r3, #24]
  if (mbp->rdptr >= mbp->top) {
 8005c8e:	6859      	ldr	r1, [r3, #4]

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8005c90:	6810      	ldr	r0, [r2, #0]
 8005c92:	9001      	str	r0, [sp, #4]
 8005c94:	3204      	adds	r2, #4
  if (mbp->rdptr >= mbp->top) {
 8005c96:	428a      	cmp	r2, r1

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8005c98:	60da      	str	r2, [r3, #12]
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
  }
  chSemSignalI(&mbp->emptysem);
 8005c9a:	480e      	ldr	r0, [pc, #56]	; (8005cd4 <test_008_003_execute.lto_priv.174+0x174>)
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
 8005c9c:	bf24      	itt	cs
 8005c9e:	681a      	ldrcs	r2, [r3, #0]
 8005ca0:	60da      	strcs	r2, [r3, #12]
  }
  chSemSignalI(&mbp->emptysem);
 8005ca2:	f000 fb9d 	bl	80063e0 <chSemSignalI>
 8005ca6:	2300      	movs	r3, #0
 8005ca8:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8005cac:	4906      	ldr	r1, [pc, #24]	; (8005cc8 <test_008_003_execute.lto_priv.174+0x168>)
 8005cae:	4620      	mov	r0, r4
 8005cb0:	f7fe fa3e 	bl	8004130 <_test_assert>
 8005cb4:	e779      	b.n	8005baa <test_008_003_execute.lto_priv.174+0x4a>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8005cb6:	2401      	movs	r4, #1
 8005cb8:	e791      	b.n	8005bde <test_008_003_execute.lto_priv.174+0x7e>
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8005cba:	2401      	movs	r4, #1
 8005cbc:	e7be      	b.n	8005c3c <test_008_003_execute.lto_priv.174+0xdc>
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8005cbe:	2401      	movs	r4, #1
 8005cc0:	e7f1      	b.n	8005ca6 <test_008_003_execute.lto_priv.174+0x146>
 8005cc2:	bf00      	nop
 8005cc4:	20000f5c 	.word	0x20000f5c
 8005cc8:	080079ac 	.word	0x080079ac
 8005ccc:	20000868 	.word	0x20000868
 8005cd0:	20000878 	.word	0x20000878
 8005cd4:	20000884 	.word	0x20000884
 8005cd8:	f3af 8000 	nop.w
 8005cdc:	f3af 8000 	nop.w

08005ce0 <msg_loop_test.lto_priv.90>:

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 8005ce0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005ce4:	4605      	mov	r5, r0
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 8005ce6:	f7fd fa1b 	bl	8003120 <test_wait_tick>
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
 8005cea:	2400      	movs	r4, #0
  start = test_wait_tick();
 8005cec:	4680      	mov	r8, r0
 8005cee:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    (void)chMsgSend(tp, 1);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 8005cf2:	f242 760f 	movw	r6, #9999	; 0x270f

  uint32_t n = 0;
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
 8005cf6:	4628      	mov	r0, r5
 8005cf8:	2101      	movs	r1, #1
 8005cfa:	f7fe fb71 	bl	80043e0 <chMsgSend>
 8005cfe:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8005d00:	ebc8 0303 	rsb	r3, r8, r3
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 8005d04:	42b3      	cmp	r3, r6
  uint32_t n = 0;
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 8005d06:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 8005d0a:	d9f4      	bls.n	8005cf6 <msg_loop_test.lto_priv.90+0x16>
  (void)chMsgSend(tp, 0);
 8005d0c:	4628      	mov	r0, r5
 8005d0e:	2100      	movs	r1, #0
 8005d10:	f7fe fb66 	bl	80043e0 <chMsgSend>
  return n;
}
 8005d14:	4620      	mov	r0, r4
 8005d16:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005d1a:	bf00      	nop
 8005d1c:	f3af 8000 	nop.w

08005d20 <wakeup.lto_priv.105>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8005d20:	b410      	push	{r4}
 8005d22:	2320      	movs	r3, #32
 8005d24:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8005d28:	f890 3020 	ldrb.w	r3, [r0, #32]
 8005d2c:	2b07      	cmp	r3, #7
 8005d2e:	d80e      	bhi.n	8005d4e <wakeup.lto_priv.105+0x2e>
 8005d30:	e8df f003 	tbb	[pc, r3]
 8005d34:	240d0d28 	.word	0x240d0d28
 8005d38:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8005d3c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8005d3e:	6893      	ldr	r3, [r2, #8]
 8005d40:	3301      	adds	r3, #1
 8005d42:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8005d44:	e890 000c 	ldmia.w	r0, {r2, r3}
 8005d48:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8005d4a:	6802      	ldr	r2, [r0, #0]
 8005d4c:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8005d4e:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005d52:	2200      	movs	r2, #0
 8005d54:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8005d56:	4b0e      	ldr	r3, [pc, #56]	; (8005d90 <wakeup.lto_priv.105+0x70>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8005d58:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005d5a:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8005d5e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8005d60:	689a      	ldr	r2, [r3, #8]
 8005d62:	428a      	cmp	r2, r1
 8005d64:	d2fb      	bcs.n	8005d5e <wakeup.lto_priv.105+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005d66:	685a      	ldr	r2, [r3, #4]
 8005d68:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8005d6a:	6003      	str	r3, [r0, #0]
 8005d6c:	2100      	movs	r1, #0
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005d6e:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8005d70:	6058      	str	r0, [r3, #4]
 8005d72:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8005d76:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005d7a:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8005d7c:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8005d7e:	2200      	movs	r2, #0
 8005d80:	601a      	str	r2, [r3, #0]
 8005d82:	e7e4      	b.n	8005d4e <wakeup.lto_priv.105+0x2e>
 8005d84:	2300      	movs	r3, #0
 8005d86:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8005d8a:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005d8e:	4770      	bx	lr
 8005d90:	200012a0 	.word	0x200012a0
 8005d94:	f3af 8000 	nop.w
 8005d98:	f3af 8000 	nop.w
 8005d9c:	f3af 8000 	nop.w

08005da0 <_idle_thread.lto_priv.76>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8005da0:	e7fe      	b.n	8005da0 <_idle_thread.lto_priv.76>
 8005da2:	bf00      	nop
 8005da4:	f3af 8000 	nop.w
 8005da8:	f3af 8000 	nop.w
 8005dac:	f3af 8000 	nop.w

08005db0 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8005db0:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8005db2:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005db4:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8005db6:	4606      	mov	r6, r0
 8005db8:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005dba:	d00d      	beq.n	8005dd8 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->flags |= flags;
 8005dbc:	68e3      	ldr	r3, [r4, #12]
 8005dbe:	432b      	orrs	r3, r5
 8005dc0:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8005dc2:	b115      	cbz	r5, 8005dca <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8005dc4:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8005dc6:	4213      	tst	r3, r2
 8005dc8:	d003      	beq.n	8005dd2 <chEvtBroadcastFlagsI+0x22>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 8005dca:	6860      	ldr	r0, [r4, #4]
 8005dcc:	68a1      	ldr	r1, [r4, #8]
 8005dce:	f7fe fb27 	bl	8004420 <chEvtSignalI>
    }
    elp = elp->next;
 8005dd2:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005dd4:	42a6      	cmp	r6, r4
 8005dd6:	d1f1      	bne.n	8005dbc <chEvtBroadcastFlagsI+0xc>
 8005dd8:	bd70      	pop	{r4, r5, r6, pc}
 8005dda:	bf00      	nop
 8005ddc:	f3af 8000 	nop.w

08005de0 <chEvtAddEvents>:
 8005de0:	2320      	movs	r3, #32
 8005de2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->epending |= events;
 8005de6:	4b04      	ldr	r3, [pc, #16]	; (8005df8 <chEvtAddEvents+0x18>)
 8005de8:	699a      	ldr	r2, [r3, #24]
 8005dea:	6b53      	ldr	r3, [r2, #52]	; 0x34
 8005dec:	4318      	orrs	r0, r3
 8005dee:	6350      	str	r0, [r2, #52]	; 0x34
 8005df0:	2300      	movs	r3, #0
 8005df2:	f383 8811 	msr	BASEPRI, r3
  events = currp->epending;
  chSysUnlock();

  return events;
}
 8005df6:	4770      	bx	lr
 8005df8:	200012a0 	.word	0x200012a0
 8005dfc:	f3af 8000 	nop.w

08005e00 <chEvtUnregister>:
 8005e00:	2320      	movs	r3, #32
 8005e02:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8005e06:	4602      	mov	r2, r0
 8005e08:	e002      	b.n	8005e10 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 8005e0a:	428b      	cmp	r3, r1
 8005e0c:	d007      	beq.n	8005e1e <chEvtUnregister+0x1e>
 8005e0e:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 8005e10:	6813      	ldr	r3, [r2, #0]
 8005e12:	4283      	cmp	r3, r0
 8005e14:	d1f9      	bne.n	8005e0a <chEvtUnregister+0xa>
 8005e16:	2300      	movs	r3, #0
 8005e18:	f383 8811 	msr	BASEPRI, r3
 8005e1c:	4770      	bx	lr
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
 8005e1e:	680b      	ldr	r3, [r1, #0]
 8005e20:	6013      	str	r3, [r2, #0]
 8005e22:	2300      	movs	r3, #0
 8005e24:	f383 8811 	msr	BASEPRI, r3
 8005e28:	4770      	bx	lr
 8005e2a:	bf00      	nop
 8005e2c:	f3af 8000 	nop.w

08005e30 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005e30:	4b0e      	ldr	r3, [pc, #56]	; (8005e6c <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8005e32:	490f      	ldr	r1, [pc, #60]	; (8005e70 <chTMStopMeasurementX+0x40>)
 8005e34:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8005e36:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8005e38:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8005e3a:	6f4f      	ldr	r7, [r1, #116]	; 0x74
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 8005e3c:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8005e3e:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8005e40:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8005e44:	1ad3      	subs	r3, r2, r3
 8005e46:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 8005e48:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 8005e4a:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8005e4c:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8005e4e:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 8005e52:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8005e54:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 8005e58:	bf88      	it	hi
 8005e5a:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 8005e5c:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8005e5e:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8005e60:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 8005e64:	bf38      	it	cc
 8005e66:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 8005e68:	bcf0      	pop	{r4, r5, r6, r7}
 8005e6a:	4770      	bx	lr
 8005e6c:	e0001000 	.word	0xe0001000
 8005e70:	200012a0 	.word	0x200012a0
 8005e74:	f3af 8000 	nop.w
 8005e78:	f3af 8000 	nop.w
 8005e7c:	f3af 8000 	nop.w

08005e80 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8005e80:	b570      	push	{r4, r5, r6, lr}
 8005e82:	2320      	movs	r3, #32
 8005e84:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8005e88:	4a12      	ldr	r2, [pc, #72]	; (8005ed4 <chThdYield+0x54>)
 8005e8a:	6810      	ldr	r0, [r2, #0]
 8005e8c:	6994      	ldr	r4, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8005e8e:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 8005e90:	68a1      	ldr	r1, [r4, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8005e92:	428b      	cmp	r3, r1
 8005e94:	d203      	bcs.n	8005e9e <chThdYield+0x1e>
 8005e96:	2300      	movs	r3, #0
 8005e98:	f383 8811 	msr	BASEPRI, r3
 8005e9c:	bd70      	pop	{r4, r5, r6, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005e9e:	6803      	ldr	r3, [r0, #0]
 8005ea0:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005ea2:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005ea4:	2500      	movs	r5, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8005ea6:	605a      	str	r2, [r3, #4]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005ea8:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005eac:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005eae:	f884 5020 	strb.w	r5, [r4, #32]
 8005eb2:	e000      	b.n	8005eb6 <chThdYield+0x36>
 8005eb4:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 8005eb6:	689a      	ldr	r2, [r3, #8]
 8005eb8:	4291      	cmp	r1, r2
 8005eba:	d9fb      	bls.n	8005eb4 <chThdYield+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005ebc:	685a      	ldr	r2, [r3, #4]
 8005ebe:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8005ec0:	6023      	str	r3, [r4, #0]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005ec2:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005ec4:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8005ec6:	605c      	str	r4, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005ec8:	f7fa fa04 	bl	80002d4 <_port_switch>
 8005ecc:	2300      	movs	r3, #0
 8005ece:	f383 8811 	msr	BASEPRI, r3
 8005ed2:	bd70      	pop	{r4, r5, r6, pc}
 8005ed4:	200012a0 	.word	0x200012a0
 8005ed8:	f3af 8000 	nop.w
 8005edc:	f3af 8000 	nop.w

08005ee0 <chThdRelease>:
 8005ee0:	2220      	movs	r2, #32
 8005ee2:	f382 8811 	msr	BASEPRI, r2
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8005ee6:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 8005eea:	3b01      	subs	r3, #1
 8005eec:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005ef0:	6a03      	ldr	r3, [r0, #32]
 8005ef2:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8005ef6:	2b0f      	cmp	r3, #15
 8005ef8:	d003      	beq.n	8005f02 <chThdRelease+0x22>
 8005efa:	2300      	movs	r3, #0
 8005efc:	f383 8811 	msr	BASEPRI, r3
 8005f00:	4770      	bx	lr
    REG_REMOVE(tp);
 8005f02:	6943      	ldr	r3, [r0, #20]
 8005f04:	6901      	ldr	r1, [r0, #16]
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8005f06:	b410      	push	{r4}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8005f08:	6119      	str	r1, [r3, #16]
 8005f0a:	6904      	ldr	r4, [r0, #16]
 8005f0c:	2100      	movs	r1, #0
 8005f0e:	6163      	str	r3, [r4, #20]
 8005f10:	f381 8811 	msr	BASEPRI, r1
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8005f14:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8005f18:	f003 0303 	and.w	r3, r3, #3
 8005f1c:	2b01      	cmp	r3, #1
 8005f1e:	d00d      	beq.n	8005f3c <chThdRelease+0x5c>
 8005f20:	2b02      	cmp	r3, #2
 8005f22:	d108      	bne.n	8005f36 <chThdRelease+0x56>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8005f24:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005f26:	69c0      	ldr	r0, [r0, #28]
 8005f28:	f382 8811 	msr	BASEPRI, r2
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8005f2c:	681a      	ldr	r2, [r3, #0]
 8005f2e:	6002      	str	r2, [r0, #0]
  mp->next = php;
 8005f30:	6018      	str	r0, [r3, #0]
 8005f32:	f381 8811 	msr	BASEPRI, r1
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8005f36:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005f3a:	4770      	bx	lr

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 8005f3c:	69c0      	ldr	r0, [r0, #28]
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8005f3e:	f85d 4b04 	ldr.w	r4, [sp], #4

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 8005f42:	f7fe b9ad 	b.w	80042a0 <chHeapFree>
 8005f46:	bf00      	nop
 8005f48:	f3af 8000 	nop.w
 8005f4c:	f3af 8000 	nop.w

08005f50 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8005f50:	6883      	ldr	r3, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8005f52:	6841      	ldr	r1, [r0, #4]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8005f54:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005f58:	4a1e      	ldr	r2, [pc, #120]	; (8005fd4 <chThdCreateSuspendedI+0x84>)
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 8005f5a:	e92d 04f0 	stmdb	sp!, {r4, r5, r6, r7, sl}
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005f5e:	6904      	ldr	r4, [r0, #16]
 8005f60:	f843 4c6c 	str.w	r4, [r3, #-108]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005f64:	2702      	movs	r7, #2
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005f66:	6944      	ldr	r4, [r0, #20]
 8005f68:	f843 4c68 	str.w	r4, [r3, #-104]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8005f6c:	6804      	ldr	r4, [r0, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005f6e:	f803 7c28 	strb.w	r7, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005f72:	2000      	movs	r0, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005f74:	2701      	movs	r7, #1
 8005f76:	f803 7c26 	strb.w	r7, [r3, #-38]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005f7a:	f803 0c27 	strb.w	r0, [r3, #-39]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005f7e:	6955      	ldr	r5, [r2, #20]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 8005f80:	f843 4c30 	str.w	r4, [r3, #-48]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 8005f84:	f843 1c2c 	str.w	r1, [r3, #-44]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8005f88:	f1a3 071c 	sub.w	r7, r3, #28
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 8005f8c:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005f90:	4e11      	ldr	r6, [pc, #68]	; (8005fd8 <chThdCreateSuspendedI+0x88>)
 8005f92:	f843 6c4c 	str.w	r6, [r3, #-76]
 8005f96:	f1a3 0a6c 	sub.w	sl, r3, #108	; 0x6c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8005f9a:	f1a3 0420 	sub.w	r4, r3, #32
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 8005f9e:	f843 ac3c 	str.w	sl, [r3, #-60]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005fa2:	f843 0c10 	str.w	r0, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8005fa6:	f843 0c14 	str.w	r0, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005faa:	f843 5c34 	str.w	r5, [r3, #-52]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8005fae:	f843 cc40 	str.w	ip, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005fb2:	f843 cc0c 	str.w	ip, [r3, #-12]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005fb6:	f843 2c38 	str.w	r2, [r3, #-56]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8005fba:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005fbc:	6129      	str	r1, [r5, #16]
 8005fbe:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005fc0:	f843 4c20 	str.w	r4, [r3, #-32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005fc4:	f843 7c1c 	str.w	r7, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 8005fc8:	f843 7c18 	str.w	r7, [r3, #-24]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 8005fcc:	e8bd 04f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl}
 8005fd0:	4770      	bx	lr
 8005fd2:	bf00      	nop
 8005fd4:	200012a0 	.word	0x200012a0
 8005fd8:	080002e5 	.word	0x080002e5
 8005fdc:	f3af 8000 	nop.w

08005fe0 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8005fe0:	4a0e      	ldr	r2, [pc, #56]	; (800601c <chSchDoReschedule+0x3c>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8005fe2:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8005fe4:	b470      	push	{r4, r5, r6}

  tqp->next             = tp->queue.next;
 8005fe6:	6803      	ldr	r3, [r0, #0]
  thread_t *otp = currp;
 8005fe8:	6994      	ldr	r4, [r2, #24]
 8005fea:	6013      	str	r3, [r2, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005fec:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005fee:	2500      	movs	r5, #0
 8005ff0:	68a1      	ldr	r1, [r4, #8]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005ff2:	605a      	str	r2, [r3, #4]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005ff4:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005ff8:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005ffa:	f884 5020 	strb.w	r5, [r4, #32]
 8005ffe:	e000      	b.n	8006002 <chSchDoReschedule+0x22>
 8006000:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8006002:	689a      	ldr	r2, [r3, #8]
 8006004:	428a      	cmp	r2, r1
 8006006:	d8fb      	bhi.n	8006000 <chSchDoReschedule+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006008:	685a      	ldr	r2, [r3, #4]
 800600a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800600c:	6023      	str	r3, [r4, #0]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800600e:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8006010:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006012:	605c      	str	r4, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 8006014:	bc70      	pop	{r4, r5, r6}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006016:	f7fa b95d 	b.w	80002d4 <_port_switch>
 800601a:	bf00      	nop
 800601c:	200012a0 	.word	0x200012a0

08006020 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8006020:	4a10      	ldr	r2, [pc, #64]	; (8006064 <chSchRescheduleS+0x44>)
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8006022:	b470      	push	{r4, r5, r6}
 8006024:	6810      	ldr	r0, [r2, #0]
 8006026:	6994      	ldr	r4, [r2, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8006028:	6883      	ldr	r3, [r0, #8]
 800602a:	68a1      	ldr	r1, [r4, #8]
 800602c:	428b      	cmp	r3, r1
 800602e:	d801      	bhi.n	8006034 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
  }
}
 8006030:	bc70      	pop	{r4, r5, r6}
 8006032:	4770      	bx	lr
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8006034:	6803      	ldr	r3, [r0, #0]
 8006036:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8006038:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800603a:	2500      	movs	r5, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800603c:	605a      	str	r2, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800603e:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8006042:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006044:	f884 5020 	strb.w	r5, [r4, #32]
 8006048:	e000      	b.n	800604c <chSchRescheduleS+0x2c>
 800604a:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 800604c:	689a      	ldr	r2, [r3, #8]
 800604e:	4291      	cmp	r1, r2
 8006050:	d3fb      	bcc.n	800604a <chSchRescheduleS+0x2a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006052:	685a      	ldr	r2, [r3, #4]
 8006054:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8006056:	6023      	str	r3, [r4, #0]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006058:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800605a:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 800605c:	605c      	str	r4, [r3, #4]
  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
  }
}
 800605e:	bc70      	pop	{r4, r5, r6}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006060:	f7fa b938 	b.w	80002d4 <_port_switch>
 8006064:	200012a0 	.word	0x200012a0
 8006068:	f3af 8000 	nop.w
 800606c:	f3af 8000 	nop.w

08006070 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8006070:	b510      	push	{r4, lr}
 8006072:	2320      	movs	r3, #32
 8006074:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 8006078:	4b08      	ldr	r3, [pc, #32]	; (800609c <chThdSetPriority+0x2c>)
 800607a:	699b      	ldr	r3, [r3, #24]
 800607c:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 800607e:	6899      	ldr	r1, [r3, #8]
 8006080:	428c      	cmp	r4, r1
 8006082:	d001      	beq.n	8006088 <chThdSetPriority+0x18>
 8006084:	4281      	cmp	r1, r0
 8006086:	d200      	bcs.n	800608a <chThdSetPriority+0x1a>
    currp->prio = newprio;
 8006088:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 800608a:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 800608c:	f7ff ffc8 	bl	8006020 <chSchRescheduleS>
 8006090:	2300      	movs	r3, #0
 8006092:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 8006096:	4620      	mov	r0, r4
 8006098:	bd10      	pop	{r4, pc}
 800609a:	bf00      	nop
 800609c:	200012a0 	.word	0x200012a0

080060a0 <chSchWakeupS>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 80060a0:	4b16      	ldr	r3, [pc, #88]	; (80060fc <chSchWakeupS+0x5c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80060a2:	b470      	push	{r4, r5, r6}
  thread_t *otp = currp;
 80060a4:	699e      	ldr	r6, [r3, #24]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80060a6:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 80060a8:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80060aa:	68b0      	ldr	r0, [r6, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 80060ac:	6269      	str	r1, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80060ae:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80060b0:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 80060b4:	d80c      	bhi.n	80060d0 <chSchWakeupS+0x30>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80060b6:	f885 2020 	strb.w	r2, [r5, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 80060ba:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 80060bc:	689a      	ldr	r2, [r3, #8]
 80060be:	4294      	cmp	r4, r2
 80060c0:	d9fb      	bls.n	80060ba <chSchWakeupS+0x1a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80060c2:	685a      	ldr	r2, [r3, #4]
 80060c4:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80060c6:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80060c8:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 80060ca:	605d      	str	r5, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80060cc:	bc70      	pop	{r4, r5, r6}
 80060ce:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80060d0:	f886 2020 	strb.w	r2, [r6, #32]
  cp = (thread_t *)&ch.rlist.queue;
 80060d4:	461a      	mov	r2, r3
  do {
    cp = cp->queue.next;
 80060d6:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 80060d8:	6891      	ldr	r1, [r2, #8]
 80060da:	4288      	cmp	r0, r1
 80060dc:	d9fb      	bls.n	80060d6 <chSchWakeupS+0x36>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80060de:	6850      	ldr	r0, [r2, #4]
 80060e0:	6070      	str	r0, [r6, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80060e2:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80060e4:	6032      	str	r2, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80060e6:	6006      	str	r6, [r0, #0]
  cp->queue.prev             = tp;
 80060e8:	6056      	str	r6, [r2, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 80060ea:	f885 4020 	strb.w	r4, [r5, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80060ee:	4631      	mov	r1, r6
 80060f0:	4628      	mov	r0, r5
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 80060f2:	619d      	str	r5, [r3, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 80060f4:	bc70      	pop	{r4, r5, r6}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 80060f6:	f7fa b8ed 	b.w	80002d4 <_port_switch>
 80060fa:	bf00      	nop
 80060fc:	200012a0 	.word	0x200012a0

08006100 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8006100:	b508      	push	{r3, lr}
 8006102:	2320      	movs	r3, #32
 8006104:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->cnt <= (cnt_t)0) {
 8006108:	6883      	ldr	r3, [r0, #8]
 800610a:	3301      	adds	r3, #1
 800610c:	2b00      	cmp	r3, #0
 800610e:	6083      	str	r3, [r0, #8]
 8006110:	dd03      	ble.n	800611a <chSemSignal+0x1a>
 8006112:	2300      	movs	r3, #0
 8006114:	f383 8811 	msr	BASEPRI, r3
 8006118:	bd08      	pop	{r3, pc}
 800611a:	4603      	mov	r3, r0
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800611c:	6800      	ldr	r0, [r0, #0]

  tqp->next             = tp->queue.next;
 800611e:	6802      	ldr	r2, [r0, #0]
 8006120:	601a      	str	r2, [r3, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8006122:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8006124:	6053      	str	r3, [r2, #4]
 8006126:	f7ff ffbb 	bl	80060a0 <chSchWakeupS>
 800612a:	2300      	movs	r3, #0
 800612c:	f383 8811 	msr	BASEPRI, r3
 8006130:	bd08      	pop	{r3, pc}
 8006132:	bf00      	nop
 8006134:	f3af 8000 	nop.w
 8006138:	f3af 8000 	nop.w
 800613c:	f3af 8000 	nop.w

08006140 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 8006140:	4b08      	ldr	r3, [pc, #32]	; (8006164 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8006142:	b430      	push	{r4, r5}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8006144:	681a      	ldr	r2, [r3, #0]
  thread_t *otp = currp;
 8006146:	6999      	ldr	r1, [r3, #24]

  tqp->next             = tp->queue.next;
 8006148:	6814      	ldr	r4, [r2, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 800614a:	f881 0020 	strb.w	r0, [r1, #32]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800614e:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 8006150:	6063      	str	r3, [r4, #4]
 8006152:	f882 5020 	strb.w	r5, [r2, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8006156:	601c      	str	r4, [r3, #0]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8006158:	4610      	mov	r0, r2
}
 800615a:	bc30      	pop	{r4, r5}
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800615c:	619a      	str	r2, [r3, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800615e:	f7fa b8b9 	b.w	80002d4 <_port_switch>
 8006162:	bf00      	nop
 8006164:	200012a0 	.word	0x200012a0
 8006168:	f3af 8000 	nop.w
 800616c:	f3af 8000 	nop.w

08006170 <chSemWait>:
 8006170:	2320      	movs	r3, #32
 8006172:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8006176:	6883      	ldr	r3, [r0, #8]
 8006178:	3b01      	subs	r3, #1
 800617a:	2b00      	cmp	r3, #0
 800617c:	6083      	str	r3, [r0, #8]
 800617e:	db04      	blt.n	800618a <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->u.rdymsg;
  }

  return MSG_OK;
 8006180:	2000      	movs	r0, #0
 8006182:	2300      	movs	r3, #0
 8006184:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 8006188:	4770      	bx	lr
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 800618a:	b510      	push	{r4, lr}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 800618c:	4c08      	ldr	r4, [pc, #32]	; (80061b0 <chSemWait+0x40>)
 800618e:	69a2      	ldr	r2, [r4, #24]
 8006190:	6250      	str	r0, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8006192:	6841      	ldr	r1, [r0, #4]
 8006194:	6051      	str	r1, [r2, #4]
 8006196:	4603      	mov	r3, r0
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 8006198:	6010      	str	r0, [r2, #0]
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 800619a:	600a      	str	r2, [r1, #0]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 800619c:	2005      	movs	r0, #5
  tqp->prev                  = tp;
 800619e:	605a      	str	r2, [r3, #4]
 80061a0:	f7ff ffce 	bl	8006140 <chSchGoSleepS>

    return currp->u.rdymsg;
 80061a4:	69a3      	ldr	r3, [r4, #24]
 80061a6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80061a8:	2300      	movs	r3, #0
 80061aa:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 80061ae:	bd10      	pop	{r4, pc}
 80061b0:	200012a0 	.word	0x200012a0
 80061b4:	f3af 8000 	nop.w
 80061b8:	f3af 8000 	nop.w
 80061bc:	f3af 8000 	nop.w

080061c0 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 80061c0:	b538      	push	{r3, r4, r5, lr}
 80061c2:	4604      	mov	r4, r0
 80061c4:	2320      	movs	r3, #32
 80061c6:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 80061ca:	f890 3020 	ldrb.w	r3, [r0, #32]
 80061ce:	2b0f      	cmp	r3, #15
 80061d0:	d007      	beq.n	80061e2 <chThdWait+0x22>
    list_insert(currp, &tp->waiting);
 80061d2:	4b08      	ldr	r3, [pc, #32]	; (80061f4 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
 80061d4:	6a82      	ldr	r2, [r0, #40]	; 0x28
 80061d6:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 80061d8:	2009      	movs	r0, #9
 80061da:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 80061dc:	62a3      	str	r3, [r4, #40]	; 0x28
 80061de:	f7ff ffaf 	bl	8006140 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 80061e2:	6a65      	ldr	r5, [r4, #36]	; 0x24
 80061e4:	2300      	movs	r3, #0
 80061e6:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 80061ea:	4620      	mov	r0, r4
 80061ec:	f7ff fe78 	bl	8005ee0 <chThdRelease>
#endif

  return msg;
}
 80061f0:	4628      	mov	r0, r5
 80061f2:	bd38      	pop	{r3, r4, r5, pc}
 80061f4:	200012a0 	.word	0x200012a0
 80061f8:	f3af 8000 	nop.w
 80061fc:	f3af 8000 	nop.w

08006200 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8006200:	2200      	movs	r2, #0
 8006202:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8006204:	4b08      	ldr	r3, [pc, #32]	; (8006228 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8006206:	b410      	push	{r4}
 8006208:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800620a:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800620e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8006210:	689a      	ldr	r2, [r3, #8]
 8006212:	428a      	cmp	r2, r1
 8006214:	d2fb      	bcs.n	800620e <chSchReadyI+0xe>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006216:	685a      	ldr	r2, [r3, #4]
 8006218:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800621a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800621c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800621e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006220:	605c      	str	r4, [r3, #4]

  return tp;
}
 8006222:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006226:	4770      	bx	lr
 8006228:	200012a0 	.word	0x200012a0
 800622c:	f3af 8000 	nop.w

08006230 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8006230:	4b12      	ldr	r3, [pc, #72]	; (800627c <chMtxUnlockS+0x4c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8006232:	b430      	push	{r4, r5}
 8006234:	4604      	mov	r4, r0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8006236:	6805      	ldr	r5, [r0, #0]
  thread_t *ctp = currp;
 8006238:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800623a:	68e3      	ldr	r3, [r4, #12]
 800623c:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800623e:	42ac      	cmp	r4, r5
 8006240:	d017      	beq.n	8006272 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8006242:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8006244:	b14b      	cbz	r3, 800625a <chMtxUnlockS+0x2a>
 8006246:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8006248:	4293      	cmp	r3, r2
 800624a:	d003      	beq.n	8006254 <chMtxUnlockS+0x24>
            (lmp->queue.next->prio > newprio)) {
 800624c:	6892      	ldr	r2, [r2, #8]
 800624e:	4291      	cmp	r1, r2
 8006250:	bf38      	it	cc
 8006252:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8006254:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8006256:	2b00      	cmp	r3, #0
 8006258:	d1f5      	bne.n	8006246 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800625a:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 800625c:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 800625e:	6081      	str	r1, [r0, #8]
 8006260:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 8006262:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 8006264:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 8006266:	60a5      	str	r5, [r4, #8]
      mp->next = tp->mtxlist;
 8006268:	60e2      	str	r2, [r4, #12]
      tp->mtxlist = mp;
 800626a:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800626c:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 800626e:	f7ff bfc7 	b.w	8006200 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
 8006272:	2300      	movs	r3, #0
 8006274:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 8006276:	bc30      	pop	{r4, r5}
 8006278:	4770      	bx	lr
 800627a:	bf00      	nop
 800627c:	200012a0 	.word	0x200012a0

08006280 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 8006280:	4b17      	ldr	r3, [pc, #92]	; (80062e0 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8006282:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8006284:	699d      	ldr	r5, [r3, #24]
 8006286:	2320      	movs	r3, #32
 8006288:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800628c:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800628e:	68c3      	ldr	r3, [r0, #12]
 8006290:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8006292:	42a0      	cmp	r0, r4
 8006294:	d01d      	beq.n	80062d2 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 8006296:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 8006298:	b14b      	cbz	r3, 80062ae <chMtxUnlock+0x2e>
 800629a:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800629c:	4293      	cmp	r3, r2
 800629e:	d003      	beq.n	80062a8 <chMtxUnlock+0x28>
            (lmp->queue.next->prio > newprio)) {
 80062a0:	6892      	ldr	r2, [r2, #8]
 80062a2:	4291      	cmp	r1, r2
 80062a4:	bf38      	it	cc
 80062a6:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80062a8:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80062aa:	2b00      	cmp	r3, #0
 80062ac:	d1f5      	bne.n	800629a <chMtxUnlock+0x1a>
 80062ae:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80062b0:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80062b2:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80062b4:	60a9      	str	r1, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80062b6:	4620      	mov	r0, r4
 80062b8:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80062ba:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 80062bc:	609c      	str	r4, [r3, #8]
      mp->next = tp->mtxlist;
 80062be:	60de      	str	r6, [r3, #12]
      tp->mtxlist = mp;
 80062c0:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80062c2:	f7ff ff9d 	bl	8006200 <chSchReadyI>
      chSchRescheduleS();
 80062c6:	f7ff feab 	bl	8006020 <chSchRescheduleS>
 80062ca:	2300      	movs	r3, #0
 80062cc:	f383 8811 	msr	BASEPRI, r3
 80062d0:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->owner = NULL;
 80062d2:	2300      	movs	r3, #0
 80062d4:	6083      	str	r3, [r0, #8]
 80062d6:	2300      	movs	r3, #0
 80062d8:	f383 8811 	msr	BASEPRI, r3
 80062dc:	bd70      	pop	{r4, r5, r6, pc}
 80062de:	bf00      	nop
 80062e0:	200012a0 	.word	0x200012a0
 80062e4:	f3af 8000 	nop.w
 80062e8:	f3af 8000 	nop.w
 80062ec:	f3af 8000 	nop.w

080062f0 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 80062f0:	4b30      	ldr	r3, [pc, #192]	; (80063b4 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80062f2:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 80062f4:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80062f6:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 80062f8:	2a00      	cmp	r2, #0
 80062fa:	d056      	beq.n	80063aa <chMtxLockS+0xba>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80062fc:	68a1      	ldr	r1, [r4, #8]
 80062fe:	6893      	ldr	r3, [r2, #8]
 8006300:	4299      	cmp	r1, r3
 8006302:	4605      	mov	r5, r0
 8006304:	d907      	bls.n	8006316 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8006306:	f892 3020 	ldrb.w	r3, [r2, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800630a:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800630c:	2b06      	cmp	r3, #6
 800630e:	d033      	beq.n	8006378 <chMtxLockS+0x88>
 8006310:	2b07      	cmp	r3, #7
 8006312:	d01d      	beq.n	8006350 <chMtxLockS+0x60>
 8006314:	b19b      	cbz	r3, 800633e <chMtxLockS+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8006316:	462b      	mov	r3, r5
 8006318:	e003      	b.n	8006322 <chMtxLockS+0x32>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800631a:	6899      	ldr	r1, [r3, #8]
 800631c:	68a2      	ldr	r2, [r4, #8]
 800631e:	4291      	cmp	r1, r2
 8006320:	d302      	bcc.n	8006328 <chMtxLockS+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8006322:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006324:	429d      	cmp	r5, r3
 8006326:	d1f8      	bne.n	800631a <chMtxLockS+0x2a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006328:	685a      	ldr	r2, [r3, #4]
 800632a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800632c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800632e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8006330:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8006332:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8006334:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8006336:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800633a:	f7ff bf01 	b.w	8006140 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800633e:	e892 000a 	ldmia.w	r2, {r1, r3}
 8006342:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8006344:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8006346:	4610      	mov	r0, r2
 8006348:	604b      	str	r3, [r1, #4]
 800634a:	f7ff ff59 	bl	8006200 <chSchReadyI>
 800634e:	e7e2      	b.n	8006316 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8006350:	e892 0009 	ldmia.w	r2, {r0, r3}
 8006354:	6018      	str	r0, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 8006356:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8006358:	6810      	ldr	r0, [r2, #0]
 800635a:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 800635c:	4633      	mov	r3, r6
 800635e:	e002      	b.n	8006366 <chMtxLockS+0x76>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006360:	6898      	ldr	r0, [r3, #8]
 8006362:	4288      	cmp	r0, r1
 8006364:	d302      	bcc.n	800636c <chMtxLockS+0x7c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8006366:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006368:	429e      	cmp	r6, r3
 800636a:	d1f9      	bne.n	8006360 <chMtxLockS+0x70>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800636c:	6859      	ldr	r1, [r3, #4]
 800636e:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8006370:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8006372:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 8006374:	605a      	str	r2, [r3, #4]
 8006376:	e7ce      	b.n	8006316 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8006378:	e892 0009 	ldmia.w	r2, {r0, r3}
 800637c:	6018      	str	r0, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 800637e:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 8006380:	6810      	ldr	r0, [r2, #0]
 8006382:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8006384:	4633      	mov	r3, r6
 8006386:	e002      	b.n	800638e <chMtxLockS+0x9e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006388:	6898      	ldr	r0, [r3, #8]
 800638a:	4288      	cmp	r0, r1
 800638c:	d302      	bcc.n	8006394 <chMtxLockS+0xa4>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 800638e:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8006390:	429e      	cmp	r6, r3
 8006392:	d1f9      	bne.n	8006388 <chMtxLockS+0x98>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8006394:	6859      	ldr	r1, [r3, #4]
 8006396:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 8006398:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800639a:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 800639c:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 800639e:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 80063a0:	68a1      	ldr	r1, [r4, #8]
 80063a2:	6893      	ldr	r3, [r2, #8]
 80063a4:	428b      	cmp	r3, r1
 80063a6:	d3ae      	bcc.n	8006306 <chMtxLockS+0x16>
 80063a8:	e7b5      	b.n	8006316 <chMtxLockS+0x26>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 80063aa:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80063ac:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 80063ae:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
 80063b0:	63a0      	str	r0, [r4, #56]	; 0x38
 80063b2:	bd70      	pop	{r4, r5, r6, pc}
 80063b4:	200012a0 	.word	0x200012a0
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 80063c0:	b508      	push	{r3, lr}
 80063c2:	2320      	movs	r3, #32
 80063c4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 80063c8:	f7ff ff92 	bl	80062f0 <chMtxLockS>
 80063cc:	2300      	movs	r3, #0
 80063ce:	f383 8811 	msr	BASEPRI, r3
 80063d2:	bd08      	pop	{r3, pc}
 80063d4:	f3af 8000 	nop.w
 80063d8:	f3af 8000 	nop.w
 80063dc:	f3af 8000 	nop.w

080063e0 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 80063e0:	6883      	ldr	r3, [r0, #8]
 80063e2:	3301      	adds	r3, #1
 80063e4:	2b00      	cmp	r3, #0
 80063e6:	6083      	str	r3, [r0, #8]
 80063e8:	dd00      	ble.n	80063ec <chSemSignalI+0xc>
 80063ea:	4770      	bx	lr
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80063ec:	6803      	ldr	r3, [r0, #0]

  tqp->next             = tp->queue.next;
 80063ee:	681a      	ldr	r2, [r3, #0]
 80063f0:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 80063f2:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80063f4:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 80063f6:	4618      	mov	r0, r3

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 80063f8:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 80063fa:	f7ff bf01 	b.w	8006200 <chSchReadyI>
 80063fe:	bf00      	nop

08006400 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8006400:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8006402:	6885      	ldr	r5, [r0, #8]
  sp->cnt = n;
 8006404:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8006406:	3501      	adds	r5, #1
 8006408:	2d00      	cmp	r5, #0
 800640a:	dc0c      	bgt.n	8006426 <chSemResetI+0x26>
 800640c:	4604      	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800640e:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 8006412:	6860      	ldr	r0, [r4, #4]

  tqp->prev             = tp->queue.prev;
 8006414:	6843      	ldr	r3, [r0, #4]
 8006416:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8006418:	601c      	str	r4, [r3, #0]
 800641a:	f7ff fef1 	bl	8006200 <chSchReadyI>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 800641e:	3501      	adds	r5, #1
 8006420:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8006422:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8006424:	d1f5      	bne.n	8006412 <chSemResetI+0x12>
 8006426:	bd70      	pop	{r4, r5, r6, pc}
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8006430:	b508      	push	{r3, lr}
 8006432:	2320      	movs	r3, #32
 8006434:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSemResetI(sp, n);
 8006438:	f7ff ffe2 	bl	8006400 <chSemResetI>
  chSchRescheduleS();
 800643c:	f7ff fdf0 	bl	8006020 <chSchRescheduleS>
 8006440:	2300      	movs	r3, #0
 8006442:	f383 8811 	msr	BASEPRI, r3
 8006446:	bd08      	pop	{r3, pc}
 8006448:	f3af 8000 	nop.w
 800644c:	f3af 8000 	nop.w

08006450 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8006450:	b538      	push	{r3, r4, r5, lr}
  thread_t *tp = currp;
 8006452:	4b10      	ldr	r3, [pc, #64]	; (8006494 <chThdExitS+0x44>)
 8006454:	699c      	ldr	r4, [r3, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 8006456:	6aa3      	ldr	r3, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 8006458:	6260      	str	r0, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800645a:	f104 0528 	add.w	r5, r4, #40	; 0x28
 800645e:	429d      	cmp	r5, r3
 8006460:	d007      	beq.n	8006472 <chThdExitS+0x22>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 8006462:	681a      	ldr	r2, [r3, #0]
 8006464:	62a2      	str	r2, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 8006466:	4618      	mov	r0, r3
 8006468:	f7ff feca 	bl	8006200 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 800646c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 800646e:	42ab      	cmp	r3, r5
 8006470:	d1f7      	bne.n	8006462 <chThdExitS+0x12>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 8006472:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 8006476:	b943      	cbnz	r3, 800648a <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 8006478:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 800647c:	079b      	lsls	r3, r3, #30
 800647e:	d104      	bne.n	800648a <chThdExitS+0x3a>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 8006480:	6963      	ldr	r3, [r4, #20]
 8006482:	6922      	ldr	r2, [r4, #16]
 8006484:	611a      	str	r2, [r3, #16]
 8006486:	6922      	ldr	r2, [r4, #16]
 8006488:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 800648a:	200f      	movs	r0, #15

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 800648c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 8006490:	f7ff be56 	b.w	8006140 <chSchGoSleepS>
 8006494:	200012a0 	.word	0x200012a0
 8006498:	f3af 8000 	nop.w
 800649c:	f3af 8000 	nop.w

080064a0 <chThdExit>:
 80064a0:	2320      	movs	r3, #32
 80064a2:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 80064a6:	f7ff bfd3 	b.w	8006450 <chThdExitS>
 80064aa:	bf00      	nop
 80064ac:	f3af 8000 	nop.w

080064b0 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80064b0:	4b1a      	ldr	r3, [pc, #104]	; (800651c <chVTDoResetI+0x6c>)
 80064b2:	69da      	ldr	r2, [r3, #28]
 80064b4:	4282      	cmp	r2, r0
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 80064b6:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 80064b8:	d010      	beq.n	80064dc <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 80064ba:	6841      	ldr	r1, [r0, #4]
 80064bc:	6802      	ldr	r2, [r0, #0]
 80064be:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 80064c0:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80064c2:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 80064c4:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80064c6:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 80064c8:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 80064ca:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 80064cc:	d003      	beq.n	80064d6 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 80064ce:	6883      	ldr	r3, [r0, #8]
 80064d0:	6891      	ldr	r1, [r2, #8]
 80064d2:	440b      	add	r3, r1
 80064d4:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80064d6:	f85d 4b04 	ldr.w	r4, [sp], #4
 80064da:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 80064dc:	4618      	mov	r0, r3
 80064de:	6811      	ldr	r1, [r2, #0]
 80064e0:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 80064e4:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80064e6:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 80064e8:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 80064ea:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 80064ec:	d011      	beq.n	8006512 <chVTDoResetI+0x62>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80064ee:	6894      	ldr	r4, [r2, #8]
 80064f0:	688a      	ldr	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80064f2:	6a98      	ldr	r0, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 80064f4:	18a3      	adds	r3, r4, r2
 80064f6:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 80064fa:	608b      	str	r3, [r1, #8]
 80064fc:	6a61      	ldr	r1, [r4, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 80064fe:	1a0a      	subs	r2, r1, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8006500:	4293      	cmp	r3, r2
 8006502:	d9e8      	bls.n	80064d6 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8006504:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8006506:	2b01      	cmp	r3, #1
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8006508:	bf98      	it	ls
 800650a:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800650c:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800650e:	6363      	str	r3, [r4, #52]	; 0x34
 8006510:	e7e1      	b.n	80064d6 <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8006512:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006516:	60dc      	str	r4, [r3, #12]
 8006518:	e7dd      	b.n	80064d6 <chVTDoResetI+0x26>
 800651a:	bf00      	nop
 800651c:	200012a0 	.word	0x200012a0

08006520 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8006520:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8006522:	4d1c      	ldr	r5, [pc, #112]	; (8006594 <chVTDoSetI+0x74>)
 8006524:	462e      	mov	r6, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006526:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 800652a:	f856 4f1c 	ldr.w	r4, [r6, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800652e:	6103      	str	r3, [r0, #16]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8006530:	2901      	cmp	r1, #1
 8006532:	bf98      	it	ls
 8006534:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8006536:	42b4      	cmp	r4, r6

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8006538:	60c2      	str	r2, [r0, #12]
 800653a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800653c:	d01b      	beq.n	8006576 <chVTDoSetI+0x56>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800653e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8006540:	1a9b      	subs	r3, r3, r2

    if (delta < now - ch.vtlist.lasttime) {
 8006542:	18c9      	adds	r1, r1, r3
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8006544:	68a3      	ldr	r3, [r4, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;

    if (delta < now - ch.vtlist.lasttime) {
 8006546:	d311      	bcc.n	800656c <chVTDoSetI+0x4c>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
    p = p->next;
 8006548:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 800654a:	1ac9      	subs	r1, r1, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800654c:	68a3      	ldr	r3, [r4, #8]
 800654e:	428b      	cmp	r3, r1
 8006550:	d3fa      	bcc.n	8006548 <chVTDoSetI+0x28>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 8006552:	6863      	ldr	r3, [r4, #4]
 8006554:	6043      	str	r3, [r0, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 8006556:	6004      	str	r4, [r0, #0]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 8006558:	6018      	str	r0, [r3, #0]
  p->prev = vtp;
 800655a:	6060      	str	r0, [r4, #4]
  vtp->delta = delta
 800655c:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 800655e:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 8006560:	f04f 32ff 	mov.w	r2, #4294967295
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 8006564:	1a59      	subs	r1, r3, r1
 8006566:	60a1      	str	r1, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 8006568:	626a      	str	r2, [r5, #36]	; 0x24
 800656a:	bdf0      	pop	{r4, r5, r6, r7, pc}
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 800656c:	4299      	cmp	r1, r3
 800656e:	d2ee      	bcs.n	800654e <chVTDoSetI+0x2e>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 8006570:	440a      	add	r2, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8006572:	637a      	str	r2, [r7, #52]	; 0x34
 8006574:	e7eb      	b.n	800654e <chVTDoSetI+0x2e>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 8006576:	eb01 0e03 	add.w	lr, r1, r3
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 800657a:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 800657c:	2202      	movs	r2, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 800657e:	62ab      	str	r3, [r5, #40]	; 0x28
      ch.vtlist.next = vtp;
 8006580:	61e8      	str	r0, [r5, #28]
      ch.vtlist.prev = vtp;
 8006582:	6228      	str	r0, [r5, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 8006584:	6004      	str	r4, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 8006586:	6044      	str	r4, [r0, #4]
      vtp->delta = delay;
 8006588:	6081      	str	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800658a:	f8c7 e034 	str.w	lr, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 800658e:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8006590:	60fa      	str	r2, [r7, #12]
 8006592:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8006594:	200012a0 	.word	0x200012a0
 8006598:	f3af 8000 	nop.w
 800659c:	f3af 8000 	nop.w

080065a0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80065a0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80065a2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80065a4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80065a6:	d012      	beq.n	80065ce <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80065a8:	4c0c      	ldr	r4, [pc, #48]	; (80065dc <chSchGoSleepTimeoutS+0x3c>)
 80065aa:	4a0d      	ldr	r2, [pc, #52]	; (80065e0 <chSchGoSleepTimeoutS+0x40>)
 80065ac:	69a3      	ldr	r3, [r4, #24]
 80065ae:	4605      	mov	r5, r0
 80065b0:	a801      	add	r0, sp, #4
 80065b2:	f7ff ffb5 	bl	8006520 <chVTDoSetI>
    chSchGoSleepS(newstate);
 80065b6:	4628      	mov	r0, r5
 80065b8:	f7ff fdc2 	bl	8006140 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 80065bc:	9b04      	ldr	r3, [sp, #16]
 80065be:	b113      	cbz	r3, 80065c6 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 80065c0:	a801      	add	r0, sp, #4
 80065c2:	f7ff ff75 	bl	80064b0 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 80065c6:	69a3      	ldr	r3, [r4, #24]
}
 80065c8:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80065ca:	b007      	add	sp, #28
 80065cc:	bd30      	pop	{r4, r5, pc}
 80065ce:	4c03      	ldr	r4, [pc, #12]	; (80065dc <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 80065d0:	f7ff fdb6 	bl	8006140 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 80065d4:	69a3      	ldr	r3, [r4, #24]
}
 80065d6:	6a58      	ldr	r0, [r3, #36]	; 0x24
 80065d8:	b007      	add	sp, #28
 80065da:	bd30      	pop	{r4, r5, pc}
 80065dc:	200012a0 	.word	0x200012a0
 80065e0:	08005d21 	.word	0x08005d21
 80065e4:	f3af 8000 	nop.w
 80065e8:	f3af 8000 	nop.w
 80065ec:	f3af 8000 	nop.w

080065f0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 80065f0:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 80065f2:	6880      	ldr	r0, [r0, #8]
 80065f4:	1e42      	subs	r2, r0, #1
 80065f6:	2a00      	cmp	r2, #0
 80065f8:	609a      	str	r2, [r3, #8]
 80065fa:	db01      	blt.n	8006600 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 80065fc:	2000      	movs	r0, #0
 80065fe:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8006600:	b410      	push	{r4}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8006602:	b161      	cbz	r1, 800661e <chSemWaitTimeoutS+0x2e>
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8006604:	4a09      	ldr	r2, [pc, #36]	; (800662c <chSemWaitTimeoutS+0x3c>)
 8006606:	6992      	ldr	r2, [r2, #24]
 8006608:	6253      	str	r3, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800660a:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800660c:	2005      	movs	r0, #5
 800660e:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->queue.prev->queue.next = tp;
 8006612:	6022      	str	r2, [r4, #0]
  tqp->prev                  = tp;
 8006614:	605a      	str	r2, [r3, #4]
  }

  return MSG_OK;
}
 8006616:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800661a:	f7ff bfc1 	b.w	80065a0 <chSchGoSleepTimeoutS>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;
 800661e:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8006620:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;

      return MSG_TIMEOUT;
 8006624:	f04f 30ff 	mov.w	r0, #4294967295

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8006628:	4770      	bx	lr
 800662a:	bf00      	nop
 800662c:	200012a0 	.word	0x200012a0

08006630 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8006630:	b169      	cbz	r1, 800664e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8006632:	4b08      	ldr	r3, [pc, #32]	; (8006654 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8006634:	b410      	push	{r4}
 8006636:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8006638:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800663a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800663c:	2004      	movs	r0, #4
 800663e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8006642:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8006644:	6053      	str	r3, [r2, #4]
}
 8006646:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800664a:	f7ff bfa9 	b.w	80065a0 <chSchGoSleepTimeoutS>
}
 800664e:	f04f 30ff 	mov.w	r0, #4294967295
 8006652:	4770      	bx	lr
 8006654:	200012a0 	.word	0x200012a0
 8006658:	f3af 8000 	nop.w
 800665c:	f3af 8000 	nop.w

08006660 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8006660:	b508      	push	{r3, lr}
 8006662:	4601      	mov	r1, r0
 8006664:	2320      	movs	r3, #32
 8006666:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 800666a:	2008      	movs	r0, #8
 800666c:	f7ff ff98 	bl	80065a0 <chSchGoSleepTimeoutS>
 8006670:	2300      	movs	r3, #0
 8006672:	f383 8811 	msr	BASEPRI, r3
 8006676:	bd08      	pop	{r3, pc}
 8006678:	f3af 8000 	nop.w
 800667c:	f3af 8000 	nop.w

08006680 <chSysRestoreStatusX.part.2.lto_priv.113>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 8006680:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 8006682:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 8006686:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 800668a:	b11c      	cbz	r4, 8006694 <chSysRestoreStatusX.part.2.lto_priv.113+0x14>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800668c:	2300      	movs	r3, #0
 800668e:	f383 8811 	msr	BASEPRI, r3
 8006692:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 8006694:	f7ff fcc4 	bl	8006020 <chSchRescheduleS>
 8006698:	f384 8811 	msr	BASEPRI, r4
 800669c:	bd10      	pop	{r4, pc}
 800669e:	bf00      	nop

080066a0 <chSysGetStatusAndLockX.part.1.lto_priv.114>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80066a0:	f3ef 8305 	mrs	r3, IPSR
 80066a4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80066a8:	b91b      	cbnz	r3, 80066b2 <chSysGetStatusAndLockX.part.1.lto_priv.114+0x12>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80066aa:	2320      	movs	r3, #32
 80066ac:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 80066b0:	4770      	bx	lr
 80066b2:	2320      	movs	r3, #32
 80066b4:	f383 8811 	msr	BASEPRI, r3
 80066b8:	4770      	bx	lr
 80066ba:	bf00      	nop
 80066bc:	f3af 8000 	nop.w

080066c0 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80066c0:	07c2      	lsls	r2, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 80066c2:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 80066c4:	d512      	bpl.n	80066ec <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
 80066c6:	4a2d      	ldr	r2, [pc, #180]	; (800677c <chSysIntegrityCheckI+0xbc>)
 80066c8:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066ca:	4291      	cmp	r1, r2
 80066cc:	d044      	beq.n	8006758 <chSysIntegrityCheckI+0x98>
 80066ce:	2300      	movs	r3, #0
      n++;
      tp = tp->queue.next;
 80066d0:	6809      	ldr	r1, [r1, #0]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066d2:	4291      	cmp	r1, r2
      n++;
 80066d4:	f103 0301 	add.w	r3, r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066d8:	d1fa      	bne.n	80066d0 <chSysIntegrityCheckI+0x10>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 80066da:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066dc:	428c      	cmp	r4, r1
 80066de:	d037      	beq.n	8006750 <chSysIntegrityCheckI+0x90>
      n--;
      tp = tp->queue.prev;
 80066e0:	6864      	ldr	r4, [r4, #4]
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066e2:	4294      	cmp	r4, r2
      n--;
 80066e4:	f103 33ff 	add.w	r3, r3, #4294967295
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80066e8:	d1fa      	bne.n	80066e0 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80066ea:	bb8b      	cbnz	r3, 8006750 <chSysIntegrityCheckI+0x90>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 80066ec:	0783      	lsls	r3, r0, #30
 80066ee:	d514      	bpl.n	800671a <chSysIntegrityCheckI+0x5a>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 80066f0:	4a22      	ldr	r2, [pc, #136]	; (800677c <chSysIntegrityCheckI+0xbc>)
 80066f2:	4614      	mov	r4, r2
 80066f4:	f854 1f1c 	ldr.w	r1, [r4, #28]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80066f8:	42a1      	cmp	r1, r4
 80066fa:	d033      	beq.n	8006764 <chSysIntegrityCheckI+0xa4>
 80066fc:	2300      	movs	r3, #0
      n++;
      vtp = vtp->next;
 80066fe:	6809      	ldr	r1, [r1, #0]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006700:	42a1      	cmp	r1, r4
      n++;
 8006702:	f103 0301 	add.w	r3, r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006706:	d1fa      	bne.n	80066fe <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 8006708:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800670a:	428a      	cmp	r2, r1
 800670c:	d020      	beq.n	8006750 <chSysIntegrityCheckI+0x90>
      n--;
      vtp = vtp->prev;
 800670e:	6852      	ldr	r2, [r2, #4]
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006710:	42a2      	cmp	r2, r4
      n--;
 8006712:	f103 33ff 	add.w	r3, r3, #4294967295
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006716:	d1fa      	bne.n	800670e <chSysIntegrityCheckI+0x4e>
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8006718:	b9d3      	cbnz	r3, 8006750 <chSysIntegrityCheckI+0x90>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800671a:	f010 0004 	ands.w	r0, r0, #4
 800671e:	d014      	beq.n	800674a <chSysIntegrityCheckI+0x8a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
 8006720:	4a16      	ldr	r2, [pc, #88]	; (800677c <chSysIntegrityCheckI+0xbc>)
 8006722:	6913      	ldr	r3, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8006724:	4293      	cmp	r3, r2
 8006726:	d023      	beq.n	8006770 <chSysIntegrityCheckI+0xb0>
 8006728:	2000      	movs	r0, #0
      n++;
      tp = tp->newer;
 800672a:	691b      	ldr	r3, [r3, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 800672c:	4293      	cmp	r3, r2
      n++;
 800672e:	f100 0001 	add.w	r0, r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 8006732:	d1fa      	bne.n	800672a <chSysIntegrityCheckI+0x6a>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 8006734:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8006736:	4299      	cmp	r1, r3
 8006738:	d00a      	beq.n	8006750 <chSysIntegrityCheckI+0x90>
      n--;
      tp = tp->older;
 800673a:	6949      	ldr	r1, [r1, #20]
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 800673c:	4291      	cmp	r1, r2
      n--;
 800673e:	f100 30ff 	add.w	r0, r0, #4294967295
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 8006742:	d1fa      	bne.n	800673a <chSysIntegrityCheckI+0x7a>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8006744:	3000      	adds	r0, #0
 8006746:	bf18      	it	ne
 8006748:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 800674a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800674e:	4770      	bx	lr
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 8006750:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 8006752:	f85d 4b04 	ldr.w	r4, [sp], #4
 8006756:	4770      	bx	lr
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 8006758:	6854      	ldr	r4, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800675a:	4294      	cmp	r4, r2
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800675c:	bf18      	it	ne
 800675e:	2300      	movne	r3, #0
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8006760:	d1be      	bne.n	80066e0 <chSysIntegrityCheckI+0x20>
 8006762:	e7c3      	b.n	80066ec <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 8006764:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8006766:	42a2      	cmp	r2, r4
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 8006768:	bf18      	it	ne
 800676a:	2300      	movne	r3, #0
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800676c:	d1cf      	bne.n	800670e <chSysIntegrityCheckI+0x4e>
 800676e:	e7d4      	b.n	800671a <chSysIntegrityCheckI+0x5a>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 8006770:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8006772:	4299      	cmp	r1, r3
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 8006774:	f04f 0000 	mov.w	r0, #0
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 8006778:	d1df      	bne.n	800673a <chSysIntegrityCheckI+0x7a>
 800677a:	e7e6      	b.n	800674a <chSysIntegrityCheckI+0x8a>
 800677c:	200012a0 	.word	0x200012a0

08006780 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8006780:	e7fe      	b.n	8006780 <BusFault_Handler>
 8006782:	bf00      	nop
 8006784:	f3af 8000 	nop.w
 8006788:	f3af 8000 	nop.w
 800678c:	f3af 8000 	nop.w

08006790 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8006790:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8006792:	4e11      	ldr	r6, [pc, #68]	; (80067d8 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 8006794:	2500      	movs	r5, #0
 8006796:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 800679a:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 800679e:	42a3      	cmp	r3, r4
 80067a0:	d20d      	bcs.n	80067be <__init_ram_areas+0x2e>
 80067a2:	3904      	subs	r1, #4
 80067a4:	461a      	mov	r2, r3
      *p = *tp;
 80067a6:	f851 0f04 	ldr.w	r0, [r1, #4]!
 80067aa:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80067ae:	42a2      	cmp	r2, r4
 80067b0:	d3f9      	bcc.n	80067a6 <__init_ram_areas+0x16>
 80067b2:	43da      	mvns	r2, r3
 80067b4:	4414      	add	r4, r2
 80067b6:	f024 0403 	bic.w	r4, r4, #3
 80067ba:	3404      	adds	r4, #4
 80067bc:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80067be:	68f2      	ldr	r2, [r6, #12]
 80067c0:	4293      	cmp	r3, r2
 80067c2:	d203      	bcs.n	80067cc <__init_ram_areas+0x3c>
      *p = 0;
 80067c4:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 80067c8:	4293      	cmp	r3, r2
 80067ca:	d3fb      	bcc.n	80067c4 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 80067cc:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80067ce:	42be      	cmp	r6, r7
 80067d0:	d3e3      	bcc.n	800679a <__init_ram_areas+0xa>
#endif
}
 80067d2:	bcf0      	pop	{r4, r5, r6, r7}
 80067d4:	4770      	bx	lr
 80067d6:	bf00      	nop
 80067d8:	08008f60 	.word	0x08008f60
 80067dc:	f3af 8000 	nop.w

080067e0 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 80067e0:	e7fe      	b.n	80067e0 <__default_exit>
 80067e2:	bf00      	nop
 80067e4:	f3af 8000 	nop.w
 80067e8:	f3af 8000 	nop.w
 80067ec:	f3af 8000 	nop.w

080067f0 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 80067f0:	4770      	bx	lr
 80067f2:	bf00      	nop
 80067f4:	f3af 8000 	nop.w
 80067f8:	f3af 8000 	nop.w
 80067fc:	f3af 8000 	nop.w

08006800 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8006800:	4770      	bx	lr
 8006802:	bf00      	nop
 8006804:	f3af 8000 	nop.w
 8006808:	f3af 8000 	nop.w
 800680c:	f3af 8000 	nop.w

08006810 <counterThread>:

#define UNUSED(x) (void)(x)

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8006810:	b508      	push	{r3, lr}
  UNUSED(arg);
  while (TRUE) {
    palSetPad(GPIOE, GPIOE_LED3_RED);
 8006812:	f44f 7500 	mov.w	r5, #512	; 0x200
 8006816:	4c06      	ldr	r4, [pc, #24]	; (8006830 <counterThread+0x20>)
 8006818:	462e      	mov	r6, r5
 800681a:	8326      	strh	r6, [r4, #24]
    chThdSleepMilliseconds(500);
 800681c:	f241 3088 	movw	r0, #5000	; 0x1388
 8006820:	f7ff ff1e 	bl	8006660 <chThdSleep>
    palClearPad(GPIOE, GPIOE_LED3_RED);
 8006824:	8365      	strh	r5, [r4, #26]
    chThdSleepMilliseconds(500);
 8006826:	f241 3088 	movw	r0, #5000	; 0x1388
 800682a:	f7ff ff19 	bl	8006660 <chThdSleep>
 800682e:	e7f4      	b.n	800681a <counterThread+0xa>
 8006830:	48001000 	.word	0x48001000
 8006834:	f3af 8000 	nop.w
 8006838:	f3af 8000 	nop.w
 800683c:	f3af 8000 	nop.w

08006840 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8006840:	b40e      	push	{r1, r2, r3}
 8006842:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006846:	b08e      	sub	sp, #56	; 0x38
 8006848:	ae17      	add	r6, sp, #92	; 0x5c
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 800684a:	2300      	movs	r3, #0
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 800684c:	f856 5b04 	ldr.w	r5, [r6], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8006850:	9607      	str	r6, [sp, #28]
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8006852:	4681      	mov	r9, r0
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8006854:	9301      	str	r3, [sp, #4]
 8006856:	4682      	mov	sl, r0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006858:	7829      	ldrb	r1, [r5, #0]
 800685a:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 800685c:	b171      	cbz	r1, 800687c <chprintf+0x3c>
      return n;
    if (c != '%') {
 800685e:	2925      	cmp	r1, #37	; 0x25
 8006860:	d012      	beq.n	8006888 <chprintf+0x48>
      streamPut(chp, (uint8_t)c);
      n++;
 8006862:	9c01      	ldr	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8006864:	f8da 2000 	ldr.w	r2, [sl]
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006868:	461d      	mov	r5, r3
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 800686a:	6892      	ldr	r2, [r2, #8]
 800686c:	4650      	mov	r0, sl
      n++;
 800686e:	3401      	adds	r4, #1
 8006870:	9401      	str	r4, [sp, #4]
  while (true) {
    c = *fmt++;
    if (c == 0)
      return n;
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
 8006872:	4790      	blx	r2
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 8006874:	7829      	ldrb	r1, [r5, #0]
 8006876:	1c6b      	adds	r3, r5, #1
    if (c == 0)
 8006878:	2900      	cmp	r1, #0
 800687a:	d1f0      	bne.n	800685e <chprintf+0x1e>
  va_start(ap, fmt);
  formatted_bytes = chvprintf(chp, fmt, ap);
  va_end(ap);

  return formatted_bytes;
}
 800687c:	9801      	ldr	r0, [sp, #4]
 800687e:	b00e      	add	sp, #56	; 0x38
 8006880:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8006884:	b003      	add	sp, #12
 8006886:	4770      	bx	lr
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8006888:	786a      	ldrb	r2, [r5, #1]
 800688a:	2a2d      	cmp	r2, #45	; 0x2d
 800688c:	bf03      	ittte	eq
 800688e:	78aa      	ldrbeq	r2, [r5, #2]
      fmt++;
 8006890:	1cab      	addeq	r3, r5, #2
      left_align = TRUE;
 8006892:	f04f 0901 	moveq.w	r9, #1
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8006896:	f04f 0900 	movne.w	r9, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 800689a:	2a30      	cmp	r2, #48	; 0x30
 800689c:	bf03      	ittte	eq
 800689e:	785a      	ldrbeq	r2, [r3, #1]
      fmt++;
 80068a0:	3301      	addeq	r3, #1
      filler = '0';
 80068a2:	f04f 0830 	moveq.w	r8, #48	; 0x30
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 80068a6:	f04f 0820 	movne.w	r8, #32
 80068aa:	1c59      	adds	r1, r3, #1
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 80068ac:	2700      	movs	r7, #0
 80068ae:	e005      	b.n	80068bc <chprintf+0x7c>
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
 80068b0:	7833      	ldrb	r3, [r6, #0]
 80068b2:	3604      	adds	r6, #4
 80068b4:	782a      	ldrb	r2, [r5, #0]
      else
        break;
      width = width * 10 + c;
 80068b6:	eb03 0740 	add.w	r7, r3, r0, lsl #1
 80068ba:	3101      	adds	r1, #1
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80068bc:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 80068c0:	b2db      	uxtb	r3, r3
 80068c2:	2b09      	cmp	r3, #9
      fmt++;
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
 80068c4:	460d      	mov	r5, r1
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 80068c6:	eb07 0087 	add.w	r0, r7, r7, lsl #2
      filler = '0';
    }
    width = 0;
    while (TRUE) {
      c = *fmt++;
      if (c >= '0' && c <= '9')
 80068ca:	d9f3      	bls.n	80068b4 <chprintf+0x74>
        c -= '0';
      else if (c == '*')
 80068cc:	2a2a      	cmp	r2, #42	; 0x2a
 80068ce:	d0ef      	beq.n	80068b0 <chprintf+0x70>
      else
        break;
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
 80068d0:	2a2e      	cmp	r2, #46	; 0x2e
 80068d2:	f04f 0b00 	mov.w	fp, #0
 80068d6:	d043      	beq.n	8006960 <chprintf+0x120>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80068d8:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 80068dc:	2b4c      	cmp	r3, #76	; 0x4c
 80068de:	d04e      	beq.n	800697e <chprintf+0x13e>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 80068e0:	f1a2 0144 	sub.w	r1, r2, #68	; 0x44
 80068e4:	2934      	cmp	r1, #52	; 0x34
 80068e6:	f200 8176 	bhi.w	8006bd6 <chprintf+0x396>
 80068ea:	e8df f011 	tbh	[pc, r1, lsl #1]
 80068ee:	0158      	.short	0x0158
 80068f0:	01740174 	.word	0x01740174
 80068f4:	01740174 	.word	0x01740174
 80068f8:	01740158 	.word	0x01740158
 80068fc:	01740174 	.word	0x01740174
 8006900:	01740174 	.word	0x01740174
 8006904:	0174012b 	.word	0x0174012b
 8006908:	01740174 	.word	0x01740174
 800690c:	01740174 	.word	0x01740174
 8006910:	01740160 	.word	0x01740160
 8006914:	01710174 	.word	0x01710174
 8006918:	01740174 	.word	0x01740174
 800691c:	01740174 	.word	0x01740174
 8006920:	01740174 	.word	0x01740174
 8006924:	01740174 	.word	0x01740174
 8006928:	01740174 	.word	0x01740174
 800692c:	01580162 	.word	0x01580162
 8006930:	00d50174 	.word	0x00d50174
 8006934:	01740174 	.word	0x01740174
 8006938:	01740158 	.word	0x01740158
 800693c:	01740174 	.word	0x01740174
 8006940:	01740174 	.word	0x01740174
 8006944:	0174012b 	.word	0x0174012b
 8006948:	01740174 	.word	0x01740174
 800694c:	01740089 	.word	0x01740089
 8006950:	01740160 	.word	0x01740160
 8006954:	01710174 	.word	0x01710174
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
 8006958:	7833      	ldrb	r3, [r6, #0]
 800695a:	3604      	adds	r6, #4
        else
          break;
        precision *= 10;
        precision += c;
 800695c:	eb03 0b41 	add.w	fp, r3, r1, lsl #1
      width = width * 10 + c;
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 8006960:	f815 2b01 	ldrb.w	r2, [r5], #1
        if (c >= '0' && c <= '9')
 8006964:	f1a2 0330 	sub.w	r3, r2, #48	; 0x30
 8006968:	b2db      	uxtb	r3, r3
 800696a:	2b09      	cmp	r3, #9
          c -= '0';
        else if (c == '*')
          c = va_arg(ap, int);
        else
          break;
        precision *= 10;
 800696c:	eb0b 018b 	add.w	r1, fp, fp, lsl #2
    }
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
        if (c >= '0' && c <= '9')
 8006970:	d9f4      	bls.n	800695c <chprintf+0x11c>
          c -= '0';
        else if (c == '*')
 8006972:	2a2a      	cmp	r2, #42	; 0x2a
 8006974:	d0f0      	beq.n	8006958 <chprintf+0x118>
        precision *= 10;
        precision += c;
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8006976:	f002 03df 	and.w	r3, r2, #223	; 0xdf
 800697a:	2b4c      	cmp	r3, #76	; 0x4c
 800697c:	d1b0      	bne.n	80068e0 <chprintf+0xa0>
      is_long = TRUE;
      if (*fmt)
 800697e:	782b      	ldrb	r3, [r5, #0]
 8006980:	2b00      	cmp	r3, #0
 8006982:	f000 8128 	beq.w	8006bd6 <chprintf+0x396>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8006986:	f1a3 0244 	sub.w	r2, r3, #68	; 0x44
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
        c = *fmt++;
 800698a:	3501      	adds	r5, #1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 800698c:	2a34      	cmp	r2, #52	; 0x34
 800698e:	f200 8121 	bhi.w	8006bd4 <chprintf+0x394>
 8006992:	e8df f012 	tbh	[pc, r2, lsl #1]
 8006996:	0104      	.short	0x0104
 8006998:	011f011f 	.word	0x011f011f
 800699c:	011f011f 	.word	0x011f011f
 80069a0:	011f0104 	.word	0x011f0104
 80069a4:	011f011f 	.word	0x011f011f
 80069a8:	011f011f 	.word	0x011f011f
 80069ac:	011f00d7 	.word	0x011f00d7
 80069b0:	011f011f 	.word	0x011f011f
 80069b4:	011f011f 	.word	0x011f011f
 80069b8:	011f010c 	.word	0x011f010c
 80069bc:	011d011f 	.word	0x011d011f
 80069c0:	011f011f 	.word	0x011f011f
 80069c4:	011f011f 	.word	0x011f011f
 80069c8:	011f011f 	.word	0x011f011f
 80069cc:	011f011f 	.word	0x011f011f
 80069d0:	011f011f 	.word	0x011f011f
 80069d4:	0104010e 	.word	0x0104010e
 80069d8:	0081011f 	.word	0x0081011f
 80069dc:	011f011f 	.word	0x011f011f
 80069e0:	011f0104 	.word	0x011f0104
 80069e4:	011f011f 	.word	0x011f011f
 80069e8:	011f011f 	.word	0x011f011f
 80069ec:	011f00d7 	.word	0x011f00d7
 80069f0:	011f011f 	.word	0x011f011f
 80069f4:	011f0035 	.word	0x011f0035
 80069f8:	011f010c 	.word	0x011f010c
 80069fc:	011d011f 	.word	0x011d011f
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8006a00:	6834      	ldr	r4, [r6, #0]
        s = "(null)";
 8006a02:	4b95      	ldr	r3, [pc, #596]	; (8006c58 <chprintf+0x418>)
 8006a04:	2c00      	cmp	r4, #0
 8006a06:	bf08      	it	eq
 8006a08:	461c      	moveq	r4, r3
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8006a0a:	3604      	adds	r6, #4
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8006a0c:	7823      	ldrb	r3, [r4, #0]
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
 8006a0e:	f1bb 0f00 	cmp.w	fp, #0
 8006a12:	f000 80ff 	beq.w	8006c14 <chprintf+0x3d4>
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8006a16:	2b00      	cmp	r3, #0
 8006a18:	f000 8101 	beq.w	8006c1e <chprintf+0x3de>
 8006a1c:	f10b 3bff 	add.w	fp, fp, #4294967295
 8006a20:	4620      	mov	r0, r4
 8006a22:	e002      	b.n	8006a2a <chprintf+0x1ea>
 8006a24:	f1bb 0b01 	subs.w	fp, fp, #1
 8006a28:	d403      	bmi.n	8006a32 <chprintf+0x1f2>
 8006a2a:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8006a2e:	2b00      	cmp	r3, #0
 8006a30:	d1f8      	bne.n	8006a24 <chprintf+0x1e4>
 8006a32:	1b00      	subs	r0, r0, r4
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8006a34:	1a3f      	subs	r7, r7, r0
 8006a36:	f100 3bff 	add.w	fp, r0, #4294967295
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8006a3a:	f04f 0820 	mov.w	r8, #32
 8006a3e:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006a42:	f1b9 0f00 	cmp.w	r9, #0
 8006a46:	f000 8090 	beq.w	8006b6a <chprintf+0x32a>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8006a4a:	f1bb 0f00 	cmp.w	fp, #0
 8006a4e:	db13      	blt.n	8006a78 <chprintf+0x238>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006a50:	46d9      	mov	r9, fp
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
 8006a52:	f8da 3000 	ldr.w	r3, [sl]
 8006a56:	f814 1b01 	ldrb.w	r1, [r4], #1
 8006a5a:	689b      	ldr	r3, [r3, #8]
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8006a5c:	f109 39ff 	add.w	r9, r9, #4294967295
      streamPut(chp, (uint8_t)*s++);
 8006a60:	4650      	mov	r0, sl
 8006a62:	4798      	blx	r3
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8006a64:	f1b9 3fff 	cmp.w	r9, #4294967295
 8006a68:	d1f3      	bne.n	8006a52 <chprintf+0x212>
 8006a6a:	9b01      	ldr	r3, [sp, #4]
 8006a6c:	3301      	adds	r3, #1
 8006a6e:	f1bb 0f00 	cmp.w	fp, #0
 8006a72:	bfa8      	it	ge
 8006a74:	445b      	addge	r3, fp
 8006a76:	9301      	str	r3, [sp, #4]
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8006a78:	2f00      	cmp	r7, #0
 8006a7a:	f43f aeed 	beq.w	8006858 <chprintf+0x18>
 8006a7e:	463c      	mov	r4, r7
      streamPut(chp, (uint8_t)filler);
 8006a80:	f8da 3000 	ldr.w	r3, [sl]
 8006a84:	4650      	mov	r0, sl
 8006a86:	689b      	ldr	r3, [r3, #8]
 8006a88:	4641      	mov	r1, r8
 8006a8a:	4798      	blx	r3
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8006a8c:	3c01      	subs	r4, #1
 8006a8e:	d1f7      	bne.n	8006a80 <chprintf+0x240>
 8006a90:	9b01      	ldr	r3, [sp, #4]
 8006a92:	443b      	add	r3, r7
 8006a94:	9301      	str	r3, [sp, #4]
 8006a96:	e6df      	b.n	8006858 <chprintf+0x18>
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8006a98:	3607      	adds	r6, #7
 8006a9a:	f026 0607 	bic.w	r6, r6, #7
 8006a9e:	e9d6 0100 	ldrd	r0, r1, [r6]
 8006aa2:	f7fa f81d 	bl	8000ae0 <__aeabi_d2f>
      if (f < 0) {
 8006aa6:	2100      	movs	r1, #0
      }
      p = ch_ltoa(p, l, 10);
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
 8006aa8:	3608      	adds	r6, #8
 8006aaa:	4604      	mov	r4, r0
      if (f < 0) {
 8006aac:	f7fa f8b6 	bl	8000c1c <__aeabi_fcmplt>
 8006ab0:	2800      	cmp	r0, #0
 8006ab2:	f040 80c5 	bne.w	8006c40 <chprintf+0x400>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8006ab6:	ab08      	add	r3, sp, #32
};

static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
 8006ab8:	f10b 3bff 	add.w	fp, fp, #4294967295
 8006abc:	f1bb 0f08 	cmp.w	fp, #8
 8006ac0:	bf28      	it	cs
 8006ac2:	f04f 0b08 	movcs.w	fp, #8
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8006ac6:	4a65      	ldr	r2, [pc, #404]	; (8006c5c <chprintf+0x41c>)
 8006ac8:	9302      	str	r3, [sp, #8]

  l = (long)num;
 8006aca:	4620      	mov	r0, r4
static char *ftoa(char *p, double num, unsigned long precision) {
  long l;

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];
 8006acc:	f852 302b 	ldr.w	r3, [r2, fp, lsl #2]
 8006ad0:	9304      	str	r3, [sp, #16]

  l = (long)num;
 8006ad2:	f7fa f8cb 	bl	8000c6c <__aeabi_f2iz>
  p = long_to_string_with_divisor(p, l, 10, 0);
 8006ad6:	9b02      	ldr	r3, [sp, #8]

  if ((precision == 0) || (precision > FLOAT_PRECISION))
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
 8006ad8:	4683      	mov	fp, r0
  p = long_to_string_with_divisor(p, l, 10, 0);
 8006ada:	220a      	movs	r2, #10
 8006adc:	4618      	mov	r0, r3
 8006ade:	4659      	mov	r1, fp
 8006ae0:	2300      	movs	r3, #0
 8006ae2:	f7fb ffbd 	bl	8002a60 <long_to_string_with_divisor.lto_priv.85>
  *p++ = '.';
 8006ae6:	4684      	mov	ip, r0
 8006ae8:	232e      	movs	r3, #46	; 0x2e
 8006aea:	f80c 3b01 	strb.w	r3, [ip], #1
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8006aee:	4620      	mov	r0, r4
    precision = FLOAT_PRECISION;
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
 8006af0:	f8cd c014 	str.w	ip, [sp, #20]
 8006af4:	f8cd c008 	str.w	ip, [sp, #8]
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
        f = -f;
      }
      p = ftoa(p, f, precision);
 8006af8:	f7f9 fd64 	bl	80005c4 <__aeabi_f2d>
 8006afc:	e9cd 0102 	strd	r0, r1, [sp, #8]
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8006b00:	4658      	mov	r0, fp
 8006b02:	f7f9 fd4d 	bl	80005a0 <__aeabi_i2d>
 8006b06:	4602      	mov	r2, r0
 8006b08:	460b      	mov	r3, r1
 8006b0a:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8006b0e:	f7f9 fbf9 	bl	8000304 <__aeabi_dsub>
 8006b12:	9c04      	ldr	r4, [sp, #16]
 8006b14:	e9cd 0102 	strd	r0, r1, [sp, #8]
 8006b18:	4620      	mov	r0, r4
 8006b1a:	f7f9 fd31 	bl	8000580 <__aeabi_ui2d>
 8006b1e:	4602      	mov	r2, r0
 8006b20:	460b      	mov	r3, r1
 8006b22:	e9dd 0102 	ldrd	r0, r1, [sp, #8]
 8006b26:	f7f9 fda1 	bl	800066c <__aeabi_dmul>
 8006b2a:	f7f9 ffb1 	bl	8000a90 <__aeabi_d2iz>
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8006b2e:	4b4c      	ldr	r3, [pc, #304]	; (8006c60 <chprintf+0x420>)
 8006b30:	f8dd c014 	ldr.w	ip, [sp, #20]
 8006b34:	4622      	mov	r2, r4
 8006b36:	fba3 2302 	umull	r2, r3, r3, r2
  precision = pow10[precision - 1];

  l = (long)num;
  p = long_to_string_with_divisor(p, l, 10, 0);
  *p++ = '.';
  l = (long)((num - l) * precision);
 8006b3a:	4601      	mov	r1, r0
  return long_to_string_with_divisor(p, l, 10, precision / 10);
 8006b3c:	08db      	lsrs	r3, r3, #3
 8006b3e:	4660      	mov	r0, ip
 8006b40:	220a      	movs	r2, #10
 8006b42:	e004      	b.n	8006b4e <chprintf+0x30e>
 8006b44:	2208      	movs	r2, #8
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8006b46:	6831      	ldr	r1, [r6, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8006b48:	a808      	add	r0, sp, #32
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8006b4a:	3604      	adds	r6, #4
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8006b4c:	2300      	movs	r3, #0
 8006b4e:	f7fb ff87 	bl	8002a60 <long_to_string_with_divisor.lto_priv.85>
 8006b52:	ab08      	add	r3, sp, #32
 8006b54:	1ac0      	subs	r0, r0, r3
 8006b56:	f100 3bff 	add.w	fp, r0, #4294967295
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8006b5a:	461c      	mov	r4, r3
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
 8006b5c:	1a3f      	subs	r7, r7, r0
 8006b5e:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      width = 0;
    if (left_align == FALSE)
 8006b62:	f1b9 0f00 	cmp.w	r9, #0
 8006b66:	f47f af70 	bne.w	8006a4a <chprintf+0x20a>
      width = -width;
 8006b6a:	f1c7 0900 	rsb	r9, r7, #0
    if (width < 0) {
 8006b6e:	f1b9 0f00 	cmp.w	r9, #0
 8006b72:	d03a      	beq.n	8006bea <chprintf+0x3aa>
      if (*s == '-' && filler == '0') {
 8006b74:	7821      	ldrb	r1, [r4, #0]
 8006b76:	292d      	cmp	r1, #45	; 0x2d
 8006b78:	d03d      	beq.n	8006bf6 <chprintf+0x3b6>
        streamPut(chp, (uint8_t)*s++);
        n++;
 8006b7a:	464f      	mov	r7, r9
        i--;
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8006b7c:	f8da 3000 	ldr.w	r3, [sl]
 8006b80:	4650      	mov	r0, sl
 8006b82:	689b      	ldr	r3, [r3, #8]
 8006b84:	4641      	mov	r1, r8
 8006b86:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8006b88:	3701      	adds	r7, #1
 8006b8a:	d1f7      	bne.n	8006b7c <chprintf+0x33c>
 8006b8c:	9b01      	ldr	r3, [sp, #4]
    }
    while (--i >= 0) {
 8006b8e:	f1bb 0f00 	cmp.w	fp, #0
 8006b92:	ebc9 0303 	rsb	r3, r9, r3
 8006b96:	9301      	str	r3, [sp, #4]
 8006b98:	f6bf af5a 	bge.w	8006a50 <chprintf+0x210>
 8006b9c:	e65c      	b.n	8006858 <chprintf+0x18>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8006b9e:	6831      	ldr	r1, [r6, #0]
      if (l < 0) {
 8006ba0:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8006ba2:	f106 0604 	add.w	r6, r6, #4
      if (l < 0) {
 8006ba6:	db44      	blt.n	8006c32 <chprintf+0x3f2>
    if (c != '%') {
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8006ba8:	a808      	add	r0, sp, #32
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8006baa:	220a      	movs	r2, #10
 8006bac:	e7ce      	b.n	8006b4c <chprintf+0x30c>
 8006bae:	220a      	movs	r2, #10
 8006bb0:	e7c9      	b.n	8006b46 <chprintf+0x306>
 8006bb2:	ab08      	add	r3, sp, #32
 8006bb4:	f10d 0021 	add.w	r0, sp, #33	; 0x21
 8006bb8:	1ac0      	subs	r0, r0, r3
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8006bba:	f04f 0820 	mov.w	r8, #32
      *p++ = va_arg(ap, int);
 8006bbe:	6833      	ldr	r3, [r6, #0]
 8006bc0:	f88d 3020 	strb.w	r3, [sp, #32]
 8006bc4:	f100 3bff 	add.w	fp, r0, #4294967295
 8006bc8:	3604      	adds	r6, #4
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8006bca:	eb0d 0408 	add.w	r4, sp, r8
 8006bce:	e7c5      	b.n	8006b5c <chprintf+0x31c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8006bd0:	2210      	movs	r2, #16
 8006bd2:	e7b8      	b.n	8006b46 <chprintf+0x306>
 8006bd4:	461a      	mov	r2, r3
 8006bd6:	ab08      	add	r3, sp, #32
 8006bd8:	f10d 0021 	add.w	r0, sp, #33	; 0x21
 8006bdc:	1ac0      	subs	r0, r0, r3
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8006bde:	f88d 2020 	strb.w	r2, [sp, #32]
 8006be2:	f100 3bff 	add.w	fp, r0, #4294967295
      streamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8006be6:	461c      	mov	r4, r3
 8006be8:	e7b8      	b.n	8006b5c <chprintf+0x31c>
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8006bea:	f1bb 0f00 	cmp.w	fp, #0
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
 8006bee:	464f      	mov	r7, r9
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8006bf0:	f6bf af2e 	bge.w	8006a50 <chprintf+0x210>
 8006bf4:	e630      	b.n	8006858 <chprintf+0x18>
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
 8006bf6:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 8006bfa:	d1be      	bne.n	8006b7a <chprintf+0x33a>
        streamPut(chp, (uint8_t)*s++);
 8006bfc:	f8da 3000 	ldr.w	r3, [sl]
 8006c00:	4650      	mov	r0, sl
 8006c02:	689b      	ldr	r3, [r3, #8]
 8006c04:	4798      	blx	r3
        n++;
 8006c06:	9b01      	ldr	r3, [sp, #4]
 8006c08:	3301      	adds	r3, #1
      width = 0;
    if (left_align == FALSE)
      width = -width;
    if (width < 0) {
      if (*s == '-' && filler == '0') {
        streamPut(chp, (uint8_t)*s++);
 8006c0a:	3401      	adds	r4, #1
        n++;
 8006c0c:	9301      	str	r3, [sp, #4]
 8006c0e:	f10b 3bff 	add.w	fp, fp, #4294967295
 8006c12:	e7b2      	b.n	8006b7a <chprintf+0x33a>
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
        s = "(null)";
      if (precision == 0)
        precision = 32767;
      for (p = s; *p && (--precision >= 0); p++)
 8006c14:	f647 7bfe 	movw	fp, #32766	; 0x7ffe
 8006c18:	2b00      	cmp	r3, #0
 8006c1a:	f47f af01 	bne.w	8006a20 <chprintf+0x1e0>
 8006c1e:	ea27 77e7 	bic.w	r7, r7, r7, asr #31
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006c22:	f1b9 0f00 	cmp.w	r9, #0
 8006c26:	d113      	bne.n	8006c50 <chprintf+0x410>
 8006c28:	f04f 3bff 	mov.w	fp, #4294967295
 8006c2c:	f04f 0820 	mov.w	r8, #32
 8006c30:	e79b      	b.n	8006b6a <chprintf+0x32a>
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8006c32:	232d      	movs	r3, #45	; 0x2d
        l = -l;
 8006c34:	4249      	negs	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8006c36:	f88d 3020 	strb.w	r3, [sp, #32]
 8006c3a:	f10d 0021 	add.w	r0, sp, #33	; 0x21
 8006c3e:	e7b4      	b.n	8006baa <chprintf+0x36a>
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8006c40:	232d      	movs	r3, #45	; 0x2d
 8006c42:	f88d 3020 	strb.w	r3, [sp, #32]
        f = -f;
 8006c46:	f104 4400 	add.w	r4, r4, #2147483648	; 0x80000000
      break;
#if CHPRINTF_USE_FLOAT
    case 'f':
      f = (float) va_arg(ap, double);
      if (f < 0) {
        *p++ = '-';
 8006c4a:	f10d 0321 	add.w	r3, sp, #33	; 0x21
 8006c4e:	e733      	b.n	8006ab8 <chprintf+0x278>
      break;
    }
    i = (int)(p - s);
    if ((width -= i) < 0)
      width = 0;
    if (left_align == FALSE)
 8006c50:	f04f 0820 	mov.w	r8, #32
 8006c54:	e710      	b.n	8006a78 <chprintf+0x238>
 8006c56:	bf00      	nop
 8006c58:	08009008 	.word	0x08009008
 8006c5c:	08009084 	.word	0x08009084
 8006c60:	cccccccd 	.word	0xcccccccd
 8006c64:	f3af 8000 	nop.w
 8006c68:	f3af 8000 	nop.w
 8006c6c:	f3af 8000 	nop.w

08006c70 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8006c70:	4bcb      	ldr	r3, [pc, #812]	; (8006fa0 <main+0x330>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8006c72:	48cc      	ldr	r0, [pc, #816]	; (8006fa4 <main+0x334>)
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8006c74:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8006c76:	f04f 31ff 	mov.w	r1, #4294967295
 8006c7a:	2200      	movs	r2, #0

/*
 * Application entry point.
 */

int main(void) {
 8006c7c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8006c80:	6299      	str	r1, [r3, #40]	; 0x28
 8006c82:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8006c84:	691c      	ldr	r4, [r3, #16]
 8006c86:	6119      	str	r1, [r3, #16]
 8006c88:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8006c8a:	68dc      	ldr	r4, [r3, #12]
 8006c8c:	60d9      	str	r1, [r3, #12]
 8006c8e:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8006c90:	69d9      	ldr	r1, [r3, #28]
 8006c92:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8006c96:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8006c98:	6801      	ldr	r1, [r0, #0]
 8006c9a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8006c9e:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8006ca0:	6a19      	ldr	r1, [r3, #32]
 8006ca2:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8006ca6:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8006caa:	b089      	sub	sp, #36	; 0x24
 8006cac:	d003      	beq.n	8006cb6 <main+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8006cae:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8006cb2:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8006cb4:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8006cb6:	4bba      	ldr	r3, [pc, #744]	; (8006fa0 <main+0x330>)
 8006cb8:	6a1a      	ldr	r2, [r3, #32]
 8006cba:	0412      	lsls	r2, r2, #16
 8006cbc:	d407      	bmi.n	8006cce <main+0x5e>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8006cbe:	6a1a      	ldr	r2, [r3, #32]
 8006cc0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8006cc4:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8006cc6:	6a1a      	ldr	r2, [r3, #32]
 8006cc8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8006ccc:	621a      	str	r2, [r3, #32]
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8006cce:	4eb4      	ldr	r6, [pc, #720]	; (8006fa0 <main+0x330>)

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8006cd0:	49b5      	ldr	r1, [pc, #724]	; (8006fa8 <main+0x338>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8006cd2:	69b2      	ldr	r2, [r6, #24]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8006cd4:	f8df a320 	ldr.w	sl, [pc, #800]	; 8006ff8 <main+0x388>
  gpiop->PUPDR   = config->pupdr;
 8006cd8:	f8df e320 	ldr.w	lr, [pc, #800]	; 8006ffc <main+0x38c>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8006cdc:	48b3      	ldr	r0, [pc, #716]	; (8006fac <main+0x33c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006cde:	f8df 9320 	ldr.w	r9, [pc, #800]	; 8007000 <main+0x390>
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8006ce2:	f8df c320 	ldr.w	ip, [pc, #800]	; 8007004 <main+0x394>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 8006ce6:	4db2      	ldr	r5, [pc, #712]	; (8006fb0 <main+0x340>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006ce8:	f8df b31c 	ldr.w	fp, [pc, #796]	; 8007008 <main+0x398>
 8006cec:	f8df 831c 	ldr.w	r8, [pc, #796]	; 800700c <main+0x39c>
 8006cf0:	4bb0      	ldr	r3, [pc, #704]	; (8006fb4 <main+0x344>)
 8006cf2:	4fb1      	ldr	r7, [pc, #708]	; (8006fb8 <main+0x348>)
 8006cf4:	f042 0201 	orr.w	r2, r2, #1
 8006cf8:	61b2      	str	r2, [r6, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8006cfa:	680a      	ldr	r2, [r1, #0]
 8006cfc:	f042 0220 	orr.w	r2, r2, #32
 8006d00:	600a      	str	r2, [r1, #0]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8006d02:	6971      	ldr	r1, [r6, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d04:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8006d08:	2400      	movs	r4, #0
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8006d0a:	f441 01fc 	orr.w	r1, r1, #8257536	; 0x7e0000
 8006d0e:	6171      	str	r1, [r6, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d10:	6054      	str	r4, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8006d12:	f8c2 a008 	str.w	sl, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8006d16:	f8c2 e00c 	str.w	lr, [r2, #12]
  gpiop->ODR     = config->odr;
 8006d1a:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8006d1e:	f8c2 e014 	str.w	lr, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8006d22:	6210      	str	r0, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8006d24:	f44f 206e 	mov.w	r0, #974848	; 0xee000
 8006d28:	6250      	str	r0, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006d2a:	f8c2 c000 	str.w	ip, [r2]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d2e:	20c0      	movs	r0, #192	; 0xc0
  gpiop->OSPEEDR = config->ospeedr;
 8006d30:	f24f 02c0 	movw	r2, #61632	; 0xf0c0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d34:	f8c9 0004 	str.w	r0, [r9, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8006d38:	f04f 4c88 	mov.w	ip, #1140850688	; 0x44000000
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8006d3c:	f8c9 2008 	str.w	r2, [r9, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8006d40:	f24a 0a80 	movw	sl, #41088	; 0xa080

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8006d44:	4a9d      	ldr	r2, [pc, #628]	; (8006fbc <main+0x34c>)
 8006d46:	f8c9 200c 	str.w	r2, [r9, #12]
  gpiop->ODR     = config->odr;
 8006d4a:	f8c9 e014 	str.w	lr, [r9, #20]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8006d4e:	f04f 4270 	mov.w	r2, #4026531840	; 0xf0000000
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8006d52:	f8c9 c020 	str.w	ip, [r9, #32]
  gpiop->AFRH    = config->afrh;
 8006d56:	f8c9 4024 	str.w	r4, [r9, #36]	; 0x24

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8006d5a:	f8df c2b4 	ldr.w	ip, [pc, #692]	; 8007010 <main+0x3a0>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8006d5e:	f8c9 a000 	str.w	sl, [r9]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8006d62:	f04f 3955 	mov.w	r9, #1431655765	; 0x55555555
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8006d66:	f8df a2ac 	ldr.w	sl, [pc, #684]	; 8007014 <main+0x3a4>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d6a:	f8cb 4004 	str.w	r4, [fp, #4]
 8006d6e:	4629      	mov	r1, r5
  gpiop->OSPEEDR = config->ospeedr;
 8006d70:	f8cb 2008 	str.w	r2, [fp, #8]
  gpiop->PUPDR   = config->pupdr;
 8006d74:	f8cb c00c 	str.w	ip, [fp, #12]
 8006d78:	4a91      	ldr	r2, [pc, #580]	; (8006fc0 <main+0x350>)
  gpiop->ODR     = config->odr;
 8006d7a:	f8cb e014 	str.w	lr, [fp, #20]
 8006d7e:	f04f 0cff 	mov.w	ip, #255	; 0xff
  gpiop->AFRL    = config->afrl;
 8006d82:	f8cb 4020 	str.w	r4, [fp, #32]
  gpiop->AFRH    = config->afrh;
 8006d86:	f8cb 4024 	str.w	r4, [fp, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006d8a:	f8cb 4000 	str.w	r4, [fp]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006d8e:	f8c8 4004 	str.w	r4, [r8, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8006d92:	f8c8 4008 	str.w	r4, [r8, #8]
  gpiop->PUPDR   = config->pupdr;
 8006d96:	f8c8 900c 	str.w	r9, [r8, #12]
  gpiop->ODR     = config->odr;
 8006d9a:	f8c8 e014 	str.w	lr, [r8, #20]
  gpiop->AFRL    = config->afrl;
 8006d9e:	f8c8 4020 	str.w	r4, [r8, #32]
  gpiop->AFRH    = config->afrh;
 8006da2:	f8c8 4024 	str.w	r4, [r8, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006da6:	f8c8 4000 	str.w	r4, [r8]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006daa:	605c      	str	r4, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8006dac:	f8c3 a008 	str.w	sl, [r3, #8]
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8006db0:	f8df a264 	ldr.w	sl, [pc, #612]	; 8007018 <main+0x3a8>
  gpiop->PUPDR   = config->pupdr;
 8006db4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8006db6:	f8df b264 	ldr.w	fp, [pc, #612]	; 800701c <main+0x3ac>
static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8006dba:	f8c3 c014 	str.w	ip, [r3, #20]
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8006dbe:	4a81      	ldr	r2, [pc, #516]	; (8006fc4 <main+0x354>)

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8006dc0:	f8df 825c 	ldr.w	r8, [pc, #604]	; 8007020 <main+0x3b0>
 8006dc4:	f8df c25c 	ldr.w	ip, [pc, #604]	; 8007024 <main+0x3b4>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8006dc8:	621c      	str	r4, [r3, #32]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8006dca:	f04f 090f 	mov.w	r9, #15
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8006dce:	625c      	str	r4, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006dd0:	f8c3 b000 	str.w	fp, [r3]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8006dd4:	607c      	str	r4, [r7, #4]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006dd6:	4b7c      	ldr	r3, [pc, #496]	; (8006fc8 <main+0x358>)
  gpiop->OSPEEDR = config->ospeedr;
 8006dd8:	f8c7 9008 	str.w	r9, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8006ddc:	f8c7 800c 	str.w	r8, [r7, #12]
  gpiop->ODR     = config->odr;
 8006de0:	f8c7 e014 	str.w	lr, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8006de4:	623c      	str	r4, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8006de6:	627c      	str	r4, [r7, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8006de8:	603c      	str	r4, [r7, #0]
 8006dea:	f841 cb04 	str.w	ip, [r1], #4
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8006dee:	f10a 0710 	add.w	r7, sl, #16
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8006df2:	f04f 0801 	mov.w	r8, #1
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006df6:	f105 0c0c 	add.w	ip, r5, #12
 8006dfa:	f105 0e30 	add.w	lr, r5, #48	; 0x30
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8006dfe:	f04f 0910 	mov.w	r9, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8006e02:	f102 0b10 	add.w	fp, r2, #16
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8006e06:	f8c5 a018 	str.w	sl, [r5, #24]
  iqp->q_rdptr   = bp;
 8006e0a:	f8c5 a024 	str.w	sl, [r5, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8006e0e:	f8c5 a020 	str.w	sl, [r5, #32]
  iqp->q_top     = bp + size;
 8006e12:	61ef      	str	r7, [r5, #28]
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8006e14:	f8df a210 	ldr.w	sl, [pc, #528]	; 8007028 <main+0x3b8>
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8006e18:	616c      	str	r4, [r5, #20]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006e1a:	2720      	movs	r7, #32
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8006e1c:	63ea      	str	r2, [r5, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8006e1e:	64aa      	str	r2, [r5, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8006e20:	646a      	str	r2, [r5, #68]	; 0x44
  oqp->q_top     = bp + size;
 8006e22:	f8c5 b040 	str.w	fp, [r5, #64]	; 0x40
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8006e26:	6069      	str	r1, [r5, #4]
 8006e28:	f8c5 c00c 	str.w	ip, [r5, #12]
  tqp->prev = (thread_t *)tqp;
 8006e2c:	f8c5 c010 	str.w	ip, [r5, #16]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006e30:	f8c5 e030 	str.w	lr, [r5, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8006e34:	f8c5 e034 	str.w	lr, [r5, #52]	; 0x34
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8006e38:	62ac      	str	r4, [r5, #40]	; 0x28
  iqp->q_link    = link;
 8006e3a:	62ed      	str	r5, [r5, #44]	; 0x2c
 8006e3c:	f885 8008 	strb.w	r8, [r5, #8]
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8006e40:	f8c5 9038 	str.w	r9, [r5, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8006e44:	f8c5 a04c 	str.w	sl, [r5, #76]	; 0x4c

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006e48:	f883 0325 	strb.w	r0, [r3, #805]	; 0x325
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006e4c:	f8c3 7184 	str.w	r7, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006e50:	605f      	str	r7, [r3, #4]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8006e52:	69f2      	ldr	r2, [r6, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006e54:	f8df c1d4 	ldr.w	ip, [pc, #468]	; 800702c <main+0x3bc>
  oqp->q_link    = link;
 8006e58:	652d      	str	r5, [r5, #80]	; 0x50

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8006e5a:	ea42 0208 	orr.w	r2, r2, r8
 8006e5e:	61f2      	str	r2, [r6, #28]

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006e60:	f8dc 0008 	ldr.w	r0, [ip, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006e64:	f8df a1c8 	ldr.w	sl, [pc, #456]	; 8007030 <main+0x3c0>

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1);
  iqObjectInit(&SD1.iqueue, sd_in_buf1, sizeof sd_in_buf1, NULL, &SD1);
  oqObjectInit(&SD1.oqueue, sd_out_buf1, sizeof sd_out_buf1, notify1, &SD1);
  SD1.usart = USART1;
 8006e68:	f8df e1c8 	ldr.w	lr, [pc, #456]	; 8007034 <main+0x3c4>
 8006e6c:	f8c5 e054 	str.w	lr, [r5, #84]	; 0x54

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006e70:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006e74:	ea40 0008 	orr.w	r0, r0, r8
  SD1.clock = STM32_USART1CLK;
 8006e78:	4954      	ldr	r1, [pc, #336]	; (8006fcc <main+0x35c>)
 8006e7a:	65a9      	str	r1, [r5, #88]	; 0x58

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006e7c:	f641 4e1f 	movw	lr, #7199	; 0x1c1f

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8006e80:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006e84:	f04f 31ff 	mov.w	r1, #4294967295

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8006e88:	f8c2 e028 	str.w	lr, [r2, #40]	; 0x28
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006e8c:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006e90:	f10a 0e1c 	add.w	lr, sl, #28

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8006e94:	f04f 0b80 	mov.w	fp, #128	; 0x80
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8006e98:	62d1      	str	r1, [r2, #44]	; 0x2c
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8006e9a:	a802      	add	r0, sp, #8
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8006e9c:	f8ca 1024 	str.w	r1, [sl, #36]	; 0x24
  STM32_ST_TIM->CCMR1  = 0;
 8006ea0:	6194      	str	r4, [r2, #24]
  tqp->prev = (thread_t *)tqp;
 8006ea2:	f8ca a004 	str.w	sl, [sl, #4]
  STM32_ST_TIM->CCR[0] = 0;
 8006ea6:	6354      	str	r4, [r2, #52]	; 0x34
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8006ea8:	f8ca 4008 	str.w	r4, [sl, #8]
  STM32_ST_TIM->DIER   = 0;
 8006eac:	60d4      	str	r4, [r2, #12]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8006eae:	f8ca a010 	str.w	sl, [sl, #16]
  STM32_ST_TIM->CR2    = 0;
 8006eb2:	6054      	str	r4, [r2, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8006eb4:	f8ca a014 	str.w	sl, [sl, #20]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8006eb8:	f8c2 8014 	str.w	r8, [r2, #20]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8006ebc:	f8ca 4028 	str.w	r4, [sl, #40]	; 0x28
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8006ec0:	f8c2 8000 	str.w	r8, [r2]
 8006ec4:	f883 b31c 	strb.w	fp, [r3, #796]	; 0x31c

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8006ec8:	2200      	movs	r2, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8006eca:	f8ca 4074 	str.w	r4, [sl, #116]	; 0x74
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8006ece:	f8c3 c180 	str.w	ip, [r3, #384]	; 0x180
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8006ed2:	f8ca e01c 	str.w	lr, [sl, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8006ed6:	f8c3 c000 	str.w	ip, [r3]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8006eda:	2300      	movs	r3, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8006edc:	9102      	str	r1, [sp, #8]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8006ede:	f8ca e020 	str.w	lr, [sl, #32]
  tmp->worst      = (rtcnt_t)0;
 8006ee2:	9403      	str	r4, [sp, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006ee4:	f8ca a000 	str.w	sl, [sl]
  tmp->last       = (rtcnt_t)0;
 8006ee8:	9404      	str	r4, [sp, #16]
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8006eea:	e9cd 2306 	strd	r2, r3, [sp, #24]
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
 8006eee:	9405      	str	r4, [sp, #20]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8006ef0:	f000 f936 	bl	8007160 <chTMStartMeasurementX.constprop.70>
  chTMStopMeasurementX(&tm);
 8006ef4:	a802      	add	r0, sp, #8
 8006ef6:	f7fe ff9b 	bl	8005e30 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8006efa:	4b35      	ldr	r3, [pc, #212]	; (8006fd0 <main+0x360>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8006efc:	4a35      	ldr	r2, [pc, #212]	; (8006fd4 <main+0x364>)
 8006efe:	4836      	ldr	r0, [pc, #216]	; (8006fd8 <main+0x368>)
 8006f00:	6018      	str	r0, [r3, #0]
 8006f02:	4836      	ldr	r0, [pc, #216]	; (8006fdc <main+0x36c>)
 8006f04:	6010      	str	r0, [r2, #0]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8006f06:	4a36      	ldr	r2, [pc, #216]	; (8006fe0 <main+0x370>)
  endmem  = __heap_end__;
 8006f08:	4936      	ldr	r1, [pc, #216]	; (8006fe4 <main+0x374>)
 8006f0a:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8006f0e:	4836      	ldr	r0, [pc, #216]	; (8006fe8 <main+0x378>)
 8006f10:	6008      	str	r0, [r1, #0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8006f12:	4936      	ldr	r1, [pc, #216]	; (8006fec <main+0x37c>)
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8006f14:	f8da e014 	ldr.w	lr, [sl, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8006f18:	f8ca b038 	str.w	fp, [sl, #56]	; 0x38
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8006f1c:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8006f20:	ea0c 0000 	and.w	r0, ip, r0
  reg_value  =  (reg_value                                   |
 8006f24:	4301      	orrs	r1, r0
  ch.tm.offset = tm.last;
 8006f26:	9804      	ldr	r0, [sp, #16]
 8006f28:	f8ca 0074 	str.w	r0, [sl, #116]	; 0x74
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8006f2c:	4830      	ldr	r0, [pc, #192]	; (8006ff0 <main+0x380>)
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8006f2e:	f8ca b06c 	str.w	fp, [sl, #108]	; 0x6c
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8006f32:	f8ca 0048 	str.w	r0, [sl, #72]	; 0x48
  REG_INSERT(tp);
 8006f36:	f10a 0c30 	add.w	ip, sl, #48	; 0x30
 8006f3a:	eb03 0b09 	add.w	fp, r3, r9

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006f3e:	482d      	ldr	r0, [pc, #180]	; (8006ff4 <main+0x384>)
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8006f40:	f88a 4051 	strb.w	r4, [sl, #81]	; 0x51
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8006f44:	f8ca 4064 	str.w	r4, [sl, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8006f48:	f88a 8052 	strb.w	r8, [sl, #82]	; 0x52
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8006f4c:	619c      	str	r4, [r3, #24]
  tp->name      = name;
  REG_INSERT(tp);
 8006f4e:	f8ca e044 	str.w	lr, [sl, #68]	; 0x44
 8006f52:	f8c3 b010 	str.w	fp, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8006f56:	f8c3 b014 	str.w	fp, [r3, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8006f5a:	f8ca 4068 	str.w	r4, [sl, #104]	; 0x68
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8006f5e:	f8ca a040 	str.w	sl, [sl, #64]	; 0x40
 8006f62:	f8ce c010 	str.w	ip, [lr, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8006f66:	60d1      	str	r1, [r2, #12]
 8006f68:	68c1      	ldr	r1, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006f6a:	f8df e0cc 	ldr.w	lr, [pc, #204]	; 8007038 <main+0x3c8>
  H_NEXT(&default_heap.header) = NULL;
 8006f6e:	609c      	str	r4, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8006f70:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8006f74:	60c1      	str	r1, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8006f76:	f8de 1000 	ldr.w	r1, [lr]
  H_PAGES(&default_heap.header) = 0;
 8006f7a:	60dc      	str	r4, [r3, #12]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8006f7c:	f10a 0058 	add.w	r0, sl, #88	; 0x58
 8006f80:	ea41 0308 	orr.w	r3, r1, r8
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8006f84:	f10a 015c 	add.w	r1, sl, #92	; 0x5c
 8006f88:	f8ca c014 	str.w	ip, [sl, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8006f8c:	f8ca c018 	str.w	ip, [sl, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8006f90:	f8ca 404c 	str.w	r4, [sl, #76]	; 0x4c
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8006f94:	f88a 8050 	strb.w	r8, [sl, #80]	; 0x50
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8006f98:	f8ca 0058 	str.w	r0, [sl, #88]	; 0x58
 8006f9c:	e04e      	b.n	800703c <main+0x3cc>
 8006f9e:	bf00      	nop
 8006fa0:	40021000 	.word	0x40021000
 8006fa4:	40007000 	.word	0x40007000
 8006fa8:	40010000 	.word	0x40010000
 8006fac:	55500000 	.word	0x55500000
 8006fb0:	20000fe8 	.word	0x20000fe8
 8006fb4:	48001000 	.word	0x48001000
 8006fb8:	48001400 	.word	0x48001400
 8006fbc:	55550515 	.word	0x55550515
 8006fc0:	01155515 	.word	0x01155515
 8006fc4:	20001280 	.word	0x20001280
 8006fc8:	e000e100 	.word	0xe000e100
 8006fcc:	02255100 	.word	0x02255100
 8006fd0:	20001320 	.word	0x20001320
 8006fd4:	20000fe4 	.word	0x20000fe4
 8006fd8:	080038d1 	.word	0x080038d1
 8006fdc:	20001360 	.word	0x20001360
 8006fe0:	e000ed00 	.word	0xe000ed00
 8006fe4:	20000fe0 	.word	0x20000fe0
 8006fe8:	2000a000 	.word	0x2000a000
 8006fec:	05fa0300 	.word	0x05fa0300
 8006ff0:	08008fe0 	.word	0x08008fe0
 8006ff4:	e000edf0 	.word	0xe000edf0
 8006ff8:	3cc0fc00 	.word	0x3cc0fc00
 8006ffc:	64151154 	.word	0x64151154
 8007000:	48000400 	.word	0x48000400
 8007004:	2a80a800 	.word	0x2a80a800
 8007008:	48000800 	.word	0x48000800
 800700c:	48000c00 	.word	0x48000c00
 8007010:	05555555 	.word	0x05555555
 8007014:	ffff00c0 	.word	0xffff00c0
 8007018:	20001270 	.word	0x20001270
 800701c:	55550040 	.word	0x55550040
 8007020:	55555550 	.word	0x55555550
 8007024:	08009064 	.word	0x08009064
 8007028:	080037a1 	.word	0x080037a1
 800702c:	e0042000 	.word	0xe0042000
 8007030:	200012a0 	.word	0x200012a0
 8007034:	40013800 	.word	0x40013800
 8007038:	e0001000 	.word	0xe0001000
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800703c:	f8ca 105c 	str.w	r1, [sl, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
 8007040:	f8ca 1060 	str.w	r1, [sl, #96]	; 0x60
 8007044:	f8ce 3000 	str.w	r3, [lr]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8007048:	f882 901f 	strb.w	r9, [r2, #31]
 800704c:	f882 7022 	strb.w	r7, [r2, #34]	; 0x22
 8007050:	f384 8811 	msr	BASEPRI, r4
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8007054:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8007056:	f387 8811 	msr	BASEPRI, r7
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 800705a:	4828      	ldr	r0, [pc, #160]	; (80070fc <main+0x48c>)
 800705c:	f7fe ff78 	bl	8005f50 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8007060:	4621      	mov	r1, r4
 8007062:	f7ff f81d 	bl	80060a0 <chSchWakeupS>
 8007066:	f384 8811 	msr	BASEPRI, r4
 800706a:	f387 8811 	msr	BASEPRI, r7
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 800706e:	7a2b      	ldrb	r3, [r5, #8]
 8007070:	4543      	cmp	r3, r8
 8007072:	d03d      	beq.n	80070f0 <main+0x480>
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8007074:	6dab      	ldr	r3, [r5, #88]	; 0x58
 8007076:	4922      	ldr	r1, [pc, #136]	; (8007100 <main+0x490>)
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8007078:	6d6a      	ldr	r2, [r5, #84]	; 0x54
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800707a:	fba1 1303 	umull	r1, r3, r1, r3
 800707e:	0b1b      	lsrs	r3, r3, #12
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8007080:	f04f 31ff 	mov.w	r1, #4294967295
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007084:	f04f 0e40 	mov.w	lr, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007088:	2701      	movs	r7, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800708a:	f240 142d 	movw	r4, #301	; 0x12d

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 800708e:	2002      	movs	r0, #2
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8007090:	60d3      	str	r3, [r2, #12]
 8007092:	2600      	movs	r6, #0

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8007094:	f8c2 e004 	str.w	lr, [r2, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8007098:	6097      	str	r7, [r2, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800709a:	6014      	str	r4, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800709c:	6211      	str	r1, [r2, #32]
 800709e:	7228      	strb	r0, [r5, #8]
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 80070a0:	f885 105c 	strb.w	r1, [r5, #92]	; 0x5c
 80070a4:	f386 8811 	msr	BASEPRI, r6
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PC4(RX) and PC5(TX). The default baud rate is 9600.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOC, 4, PAL_MODE_ALTERNATE(7));
 80070a8:	2010      	movs	r0, #16
 80070aa:	f000 fb19 	bl	80076e0 <_pal_lld_setgroupmode.constprop.6>
  palSetPadMode(GPIOC, 5, PAL_MODE_ALTERNATE(7));
 80070ae:	2020      	movs	r0, #32
 80070b0:	f000 fb16 	bl	80076e0 <_pal_lld_setgroupmode.constprop.6>
  chprintf((BaseSequentialStream*)&SD1, "\n\rUp and Running\n\r");
 80070b4:	4913      	ldr	r1, [pc, #76]	; (8007104 <main+0x494>)
 80070b6:	4814      	ldr	r0, [pc, #80]	; (8007108 <main+0x498>)
 80070b8:	4d14      	ldr	r5, [pc, #80]	; (800710c <main+0x49c>)
 80070ba:	4c15      	ldr	r4, [pc, #84]	; (8007110 <main+0x4a0>)
 80070bc:	f7ff fbc0 	bl	8006840 <chprintf>
 80070c0:	4b14      	ldr	r3, [pc, #80]	; (8007114 <main+0x4a4>)

  /* Initialize the command shell */ 
  shellInit();
  chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
 80070c2:	4815      	ldr	r0, [pc, #84]	; (8007118 <main+0x4a8>)
 80070c4:	601b      	str	r3, [r3, #0]
 80070c6:	4a15      	ldr	r2, [pc, #84]	; (800711c <main+0x4ac>)
 80070c8:	4633      	mov	r3, r6
 80070ca:	2181      	movs	r1, #129	; 0x81
 80070cc:	f000 f850 	bl	8007170 <chThdCreateStatic.constprop.69>

  while (TRUE) {
    thread_t *shelltp = chThdCreateFromHeap(NULL, SHELL_WA_SIZE,
 80070d0:	f640 01c8 	movw	r1, #2248	; 0x8c8
 80070d4:	4a12      	ldr	r2, [pc, #72]	; (8007120 <main+0x4b0>)
 80070d6:	9500      	str	r5, [sp, #0]
 80070d8:	2381      	movs	r3, #129	; 0x81
 80070da:	9401      	str	r4, [sp, #4]
 80070dc:	2000      	movs	r0, #0
 80070de:	f7fd f937 	bl	8004350 <chThdCreateFromHeap>
					    "shell", NORMALPRIO + 1,
					    shellThread, (void *)&shell_cfg1);
    chThdWait(shelltp);
 80070e2:	f7ff f86d 	bl	80061c0 <chThdWait>
    chThdSleepMilliseconds(1000);
 80070e6:	f242 7010 	movw	r0, #10000	; 0x2710
 80070ea:	f7ff fab9 	bl	8006660 <chThdSleep>
 80070ee:	e7ef      	b.n	80070d0 <main+0x460>
    config = &default_config;

  if (sdp->state == SD_STOP) {
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 80070f0:	69b3      	ldr	r3, [r6, #24]
 80070f2:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80070f6:	61b3      	str	r3, [r6, #24]
 80070f8:	e7bc      	b.n	8007074 <main+0x404>
 80070fa:	bf00      	nop
 80070fc:	08009044 	.word	0x08009044
 8007100:	1b4e81b5 	.word	0x1b4e81b5
 8007104:	08009010 	.word	0x08009010
 8007108:	20000fe8 	.word	0x20000fe8
 800710c:	08001f81 	.word	0x08001f81
 8007110:	0800905c 	.word	0x0800905c
 8007114:	20001190 	.word	0x20001190
 8007118:	20001048 	.word	0x20001048
 800711c:	08006811 	.word	0x08006811
 8007120:	08009024 	.word	0x08009024
 8007124:	f3af 8000 	nop.w
 8007128:	f3af 8000 	nop.w
 800712c:	f3af 8000 	nop.w

08007130 <cmd_myecho>:
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 8007130:	2900      	cmp	r1, #0
 8007132:	dd0e      	ble.n	8007152 <cmd_myecho+0x22>
    palClearPad(GPIOE, GPIOE_LED3_RED);
    chThdSleepMilliseconds(500);
  }
}

static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8007134:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8007136:	460f      	mov	r7, r1
 8007138:	4606      	mov	r6, r0
 800713a:	1f15      	subs	r5, r2, #4
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 800713c:	2400      	movs	r4, #0
 800713e:	3401      	adds	r4, #1
    chprintf(chp, "%s\n\r", argv[i]);
 8007140:	4630      	mov	r0, r6
 8007142:	4904      	ldr	r1, [pc, #16]	; (8007154 <cmd_myecho+0x24>)
 8007144:	f855 2f04 	ldr.w	r2, [r5, #4]!
 8007148:	f7ff fb7a 	bl	8006840 <chprintf>
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;

  (void)argv;

  for (i=0;i<argc;i++) {
 800714c:	42bc      	cmp	r4, r7
 800714e:	d1f6      	bne.n	800713e <cmd_myecho+0xe>
 8007150:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8007152:	4770      	bx	lr
 8007154:	0800902c 	.word	0x0800902c
 8007158:	f3af 8000 	nop.w
 800715c:	f3af 8000 	nop.w

08007160 <chTMStartMeasurementX.constprop.70>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8007160:	4b01      	ldr	r3, [pc, #4]	; (8007168 <chTMStartMeasurementX.constprop.70+0x8>)
 8007162:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8007164:	6083      	str	r3, [r0, #8]
 8007166:	4770      	bx	lr
 8007168:	e0001000 	.word	0xe0001000
 800716c:	f3af 8000 	nop.w

08007170 <chThdCreateStatic.constprop.69>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8007170:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8007174:	469a      	mov	sl, r3
 8007176:	4604      	mov	r4, r0
 8007178:	2320      	movs	r3, #32
 800717a:	f383 8811 	msr	BASEPRI, r3
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800717e:	4f21      	ldr	r7, [pc, #132]	; (8007204 <chThdCreateStatic.constprop.69+0x94>)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8007180:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8007184:	f8d7 b014 	ldr.w	fp, [r7, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8007188:	4b1f      	ldr	r3, [pc, #124]	; (8007208 <chThdCreateStatic.constprop.69+0x98>)
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 800718a:	4820      	ldr	r0, [pc, #128]	; (800720c <chThdCreateStatic.constprop.69+0x9c>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800718c:	f8c4 1108 	str.w	r1, [r4, #264]	; 0x108
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8007190:	2500      	movs	r5, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8007192:	f504 7680 	add.w	r6, r4, #256	; 0x100
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8007196:	f504 7296 	add.w	r2, r4, #300	; 0x12c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 800719a:	f04f 0c01 	mov.w	ip, #1
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 800719e:	f504 7e94 	add.w	lr, r4, #296	; 0x128
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80071a2:	f104 09dc 	add.w	r9, r4, #220	; 0xdc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80071a6:	f04f 0802 	mov.w	r8, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 80071aa:	f8c4 113c 	str.w	r1, [r4, #316]	; 0x13c
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 80071ae:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 80071b2:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 80071b6:	f8c4 a0e0 	str.w	sl, [r4, #224]	; 0xe0
 80071ba:	f8c4 910c 	str.w	r9, [r4, #268]	; 0x10c
 80071be:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80071c2:	f884 8120 	strb.w	r8, [r4, #288]	; 0x120
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80071c6:	f884 c122 	strb.w	ip, [r4, #290]	; 0x122
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80071ca:	f884 5121 	strb.w	r5, [r4, #289]	; 0x121
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 80071ce:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 80071d2:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80071d6:	f8c4 7110 	str.w	r7, [r4, #272]	; 0x110
 80071da:	f8c4 b114 	str.w	fp, [r4, #276]	; 0x114
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80071de:	4630      	mov	r0, r6
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80071e0:	f8cb 6010 	str.w	r6, [fp, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80071e4:	4629      	mov	r1, r5
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 80071e6:	f8c4 e128 	str.w	lr, [r4, #296]	; 0x128
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80071ea:	f8c4 212c 	str.w	r2, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 80071ee:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80071f2:	617e      	str	r6, [r7, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 80071f4:	f7fe ff54 	bl	80060a0 <chSchWakeupS>
 80071f8:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 80071fc:	4630      	mov	r0, r6
 80071fe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8007202:	bf00      	nop
 8007204:	200012a0 	.word	0x200012a0
 8007208:	080002e5 	.word	0x080002e5
 800720c:	080090a8 	.word	0x080090a8

08007210 <chSemSignalWait.constprop.63>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8007210:	b510      	push	{r4, lr}
 8007212:	2320      	movs	r3, #32
 8007214:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
 8007218:	4c15      	ldr	r4, [pc, #84]	; (8007270 <chSemSignalWait.constprop.63+0x60>)
 800721a:	68a3      	ldr	r3, [r4, #8]
 800721c:	3301      	adds	r3, #1
 800721e:	2b00      	cmp	r3, #0
 8007220:	60a3      	str	r3, [r4, #8]
 8007222:	dd1b      	ble.n	800725c <chSemSignalWait.constprop.63+0x4c>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8007224:	3b01      	subs	r3, #1
 8007226:	2b00      	cmp	r3, #0
 8007228:	60a3      	str	r3, [r4, #8]
 800722a:	4a11      	ldr	r2, [pc, #68]	; (8007270 <chSemSignalWait.constprop.63+0x60>)
 800722c:	db06      	blt.n	800723c <chSemSignalWait.constprop.63+0x2c>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 800722e:	f7fe fef7 	bl	8006020 <chSchRescheduleS>
    msg = MSG_OK;
 8007232:	2000      	movs	r0, #0
 8007234:	2300      	movs	r3, #0
 8007236:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 800723a:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 800723c:	490d      	ldr	r1, [pc, #52]	; (8007274 <chSemSignalWait.constprop.63+0x64>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800723e:	6853      	ldr	r3, [r2, #4]
 8007240:	698c      	ldr	r4, [r1, #24]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8007242:	2005      	movs	r0, #5
 8007244:	e884 000c 	stmia.w	r4, {r2, r3}
  tp->queue.prev->queue.next = tp;
 8007248:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 800724a:	6262      	str	r2, [r4, #36]	; 0x24
  tqp->prev                  = tp;
 800724c:	6054      	str	r4, [r2, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 800724e:	f7fe ff77 	bl	8006140 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8007252:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8007254:	2300      	movs	r3, #0
 8007256:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 800725a:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800725c:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 800725e:	6803      	ldr	r3, [r0, #0]
 8007260:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8007262:	605c      	str	r4, [r3, #4]
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8007264:	f7fe ffcc 	bl	8006200 <chSchReadyI>
 8007268:	2200      	movs	r2, #0
 800726a:	68a3      	ldr	r3, [r4, #8]
 800726c:	6242      	str	r2, [r0, #36]	; 0x24
 800726e:	e7d9      	b.n	8007224 <chSemSignalWait.constprop.63+0x14>
 8007270:	20001340 	.word	0x20001340
 8007274:	200012a0 	.word	0x200012a0
 8007278:	f3af 8000 	nop.w
 800727c:	f3af 8000 	nop.w

08007280 <chMtxTryLock.constprop.61>:
 8007280:	2320      	movs	r3, #32
 8007282:	f383 8811 	msr	BASEPRI, r3
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8007286:	4b09      	ldr	r3, [pc, #36]	; (80072ac <chMtxTryLock.constprop.61+0x2c>)
 8007288:	689a      	ldr	r2, [r3, #8]
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 800728a:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 800728c:	b11a      	cbz	r2, 8007296 <chMtxTryLock.constprop.61+0x16>
 800728e:	2300      	movs	r3, #0
 8007290:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8007294:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8007296:	4a06      	ldr	r2, [pc, #24]	; (80072b0 <chMtxTryLock.constprop.61+0x30>)
 8007298:	6992      	ldr	r2, [r2, #24]
 800729a:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 800729c:	6b91      	ldr	r1, [r2, #56]	; 0x38
 800729e:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 80072a0:	6393      	str	r3, [r2, #56]	; 0x38
 80072a2:	2001      	movs	r0, #1
 80072a4:	2300      	movs	r3, #0
 80072a6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 80072aa:	4770      	bx	lr
 80072ac:	20000858 	.word	0x20000858
 80072b0:	200012a0 	.word	0x200012a0
 80072b4:	f3af 8000 	nop.w
 80072b8:	f3af 8000 	nop.w
 80072bc:	f3af 8000 	nop.w

080072c0 <chCondSignal.constprop.59>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 80072c0:	b508      	push	{r3, lr}
 80072c2:	2320      	movs	r3, #32
 80072c4:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80072c8:	4b06      	ldr	r3, [pc, #24]	; (80072e4 <chCondSignal.constprop.59+0x24>)
 80072ca:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->queue)) {
 80072cc:	4298      	cmp	r0, r3
 80072ce:	d005      	beq.n	80072dc <chCondSignal.constprop.59+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80072d0:	6802      	ldr	r2, [r0, #0]
 80072d2:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80072d4:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 80072d6:	2100      	movs	r1, #0
 80072d8:	f7fe fee2 	bl	80060a0 <chSchWakeupS>
 80072dc:	2300      	movs	r3, #0
 80072de:	f383 8811 	msr	BASEPRI, r3
 80072e2:	bd08      	pop	{r3, pc}
 80072e4:	200008a8 	.word	0x200008a8
 80072e8:	f3af 8000 	nop.w
 80072ec:	f3af 8000 	nop.w

080072f0 <chCondSignalI.constprop.58>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80072f0:	4b07      	ldr	r3, [pc, #28]	; (8007310 <chCondSignalI.constprop.58+0x20>)
 80072f2:	681a      	ldr	r2, [r3, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 80072f4:	429a      	cmp	r2, r3
 80072f6:	d00a      	beq.n	800730e <chCondSignalI.constprop.58+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80072f8:	6811      	ldr	r1, [r2, #0]
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80072fa:	b410      	push	{r4}
  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 80072fc:	2400      	movs	r4, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80072fe:	604b      	str	r3, [r1, #4]
 8007300:	6254      	str	r4, [r2, #36]	; 0x24
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8007302:	6019      	str	r1, [r3, #0]
    (void) chSchReadyI(tp);
 8007304:	4610      	mov	r0, r2
  }
}
 8007306:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 800730a:	f7fe bf79 	b.w	8006200 <chSchReadyI>
 800730e:	4770      	bx	lr
 8007310:	200008a8 	.word	0x200008a8
 8007314:	f3af 8000 	nop.w
 8007318:	f3af 8000 	nop.w
 800731c:	f3af 8000 	nop.w

08007320 <chEvtGetAndClearEvents.constprop.50>:
 8007320:	2320      	movs	r3, #32
 8007322:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8007326:	4b04      	ldr	r3, [pc, #16]	; (8007338 <chEvtGetAndClearEvents.constprop.50+0x18>)
 8007328:	699a      	ldr	r2, [r3, #24]
  currp->epending &= ~events;
 800732a:	2300      	movs	r3, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 800732c:	6b50      	ldr	r0, [r2, #52]	; 0x34
  currp->epending &= ~events;
 800732e:	6353      	str	r3, [r2, #52]	; 0x34
 8007330:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8007334:	4770      	bx	lr
 8007336:	bf00      	nop
 8007338:	200012a0 	.word	0x200012a0
 800733c:	f3af 8000 	nop.w

08007340 <chEvtWaitOne.constprop.46>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 8007340:	4a0b      	ldr	r2, [pc, #44]	; (8007370 <chEvtWaitOne.constprop.46+0x30>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8007342:	b510      	push	{r4, lr}
 8007344:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8007346:	6994      	ldr	r4, [r2, #24]
 8007348:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800734c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800734e:	b933      	cbnz	r3, 800735e <chEvtWaitOne.constprop.46+0x1e>
    ctp->u.ewmask = events;
 8007350:	f04f 33ff 	mov.w	r3, #4294967295
 8007354:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8007356:	200a      	movs	r0, #10
 8007358:	f7fe fef2 	bl	8006140 <chSchGoSleepS>
    m = ctp->epending & events;
 800735c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 800735e:	4258      	negs	r0, r3
 8007360:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8007362:	ea23 0300 	bic.w	r3, r3, r0
 8007366:	6363      	str	r3, [r4, #52]	; 0x34
 8007368:	2300      	movs	r3, #0
 800736a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 800736e:	bd10      	pop	{r4, pc}
 8007370:	200012a0 	.word	0x200012a0
 8007374:	f3af 8000 	nop.w
 8007378:	f3af 8000 	nop.w
 800737c:	f3af 8000 	nop.w

08007380 <chEvtWaitAny.constprop.45>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8007380:	4a09      	ldr	r2, [pc, #36]	; (80073a8 <chEvtWaitAny.constprop.45+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8007382:	b510      	push	{r4, lr}
 8007384:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8007386:	6994      	ldr	r4, [r2, #24]
 8007388:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800738c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800738e:	b930      	cbnz	r0, 800739e <chEvtWaitAny.constprop.45+0x1e>
    ctp->u.ewmask = events;
 8007390:	f04f 33ff 	mov.w	r3, #4294967295
    chSchGoSleepS(CH_STATE_WTOREVT);
 8007394:	200a      	movs	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
    ctp->u.ewmask = events;
 8007396:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8007398:	f7fe fed2 	bl	8006140 <chSchGoSleepS>
    m = ctp->epending & events;
 800739c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 800739e:	2300      	movs	r3, #0
 80073a0:	6363      	str	r3, [r4, #52]	; 0x34
 80073a2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 80073a6:	bd10      	pop	{r4, pc}
 80073a8:	200012a0 	.word	0x200012a0
 80073ac:	f3af 8000 	nop.w

080073b0 <chEvtWaitAll.constprop.44>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 80073b0:	4a0c      	ldr	r2, [pc, #48]	; (80073e4 <chEvtWaitAll.constprop.44+0x34>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 80073b2:	b510      	push	{r4, lr}
 80073b4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 80073b6:	6994      	ldr	r4, [r2, #24]
 80073b8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 80073bc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 80073be:	f003 0205 	and.w	r2, r3, #5
 80073c2:	2a05      	cmp	r2, #5
 80073c4:	d005      	beq.n	80073d2 <chEvtWaitAll.constprop.44+0x22>
    ctp->u.ewmask = events;
 80073c6:	2305      	movs	r3, #5
 80073c8:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 80073ca:	200b      	movs	r0, #11
 80073cc:	f7fe feb8 	bl	8006140 <chSchGoSleepS>
 80073d0:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 80073d2:	f023 0305 	bic.w	r3, r3, #5
 80073d6:	6363      	str	r3, [r4, #52]	; 0x34
 80073d8:	2300      	movs	r3, #0
 80073da:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 80073de:	2005      	movs	r0, #5
 80073e0:	bd10      	pop	{r4, pc}
 80073e2:	bf00      	nop
 80073e4:	200012a0 	.word	0x200012a0
 80073e8:	f3af 8000 	nop.w
 80073ec:	f3af 8000 	nop.w

080073f0 <chHeapAllocAligned.constprop.40>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 80073f0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 80073f4:	4d3a      	ldr	r5, [pc, #232]	; (80074e0 <chHeapAllocAligned.constprop.40+0xf0>)
 80073f6:	2800      	cmp	r0, #0
 80073f8:	bf18      	it	ne
 80073fa:	4605      	movne	r5, r0

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80073fc:	f105 0710 	add.w	r7, r5, #16
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8007400:	1dce      	adds	r6, r1, #7

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007402:	4638      	mov	r0, r7
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8007404:	460c      	mov	r4, r1
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8007406:	08f6      	lsrs	r6, r6, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8007408:	f7fe ffda 	bl	80063c0 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 800740c:	f105 0e08 	add.w	lr, r5, #8
  while (H_NEXT(qp) != NULL) {
 8007410:	f8de 3000 	ldr.w	r3, [lr]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8007414:	f103 020f 	add.w	r2, r3, #15
 8007418:	f022 0207 	bic.w	r2, r2, #7
 800741c:	3a08      	subs	r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800741e:	1a98      	subs	r0, r3, r2

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8007420:	f103 0808 	add.w	r8, r3, #8
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8007424:	b183      	cbz	r3, 8007448 <chHeapAllocAligned.constprop.40+0x58>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8007426:	f8d3 c004 	ldr.w	ip, [r3, #4]
 800742a:	f10c 0101 	add.w	r1, ip, #1
 800742e:	00c9      	lsls	r1, r1, #3
 8007430:	f1a1 0908 	sub.w	r9, r1, #8
 8007434:	4419      	add	r1, r3
 8007436:	4448      	add	r0, r9
 8007438:	428a      	cmp	r2, r1
 800743a:	ea4f 00e0 	mov.w	r0, r0, asr #3
 800743e:	d201      	bcs.n	8007444 <chHeapAllocAligned.constprop.40+0x54>
 8007440:	4286      	cmp	r6, r0
 8007442:	d912      	bls.n	800746a <chHeapAllocAligned.constprop.40+0x7a>
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8007444:	469e      	mov	lr, r3
 8007446:	e7e3      	b.n	8007410 <chHeapAllocAligned.constprop.40+0x20>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8007448:	4638      	mov	r0, r7
 800744a:	f7fe ff19 	bl	8006280 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 800744e:	682b      	ldr	r3, [r5, #0]
 8007450:	2b00      	cmp	r3, #0
 8007452:	d042      	beq.n	80074da <chHeapAllocAligned.constprop.40+0xea>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 8007454:	1c70      	adds	r0, r6, #1
 8007456:	00c0      	lsls	r0, r0, #3
 8007458:	2108      	movs	r1, #8
 800745a:	4798      	blx	r3
    if (hp != NULL) {
 800745c:	2800      	cmp	r0, #0
 800745e:	d03c      	beq.n	80074da <chHeapAllocAligned.constprop.40+0xea>
      H_HEAP(hp) = heapp;
 8007460:	6005      	str	r5, [r0, #0]
      H_SIZE(hp) = size;
 8007462:	6044      	str	r4, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8007464:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8007466:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 800746a:	4293      	cmp	r3, r2
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 800746c:	4611      	mov	r1, r2

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 800746e:	46c2      	mov	sl, r8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8007470:	d217      	bcs.n	80074a2 <chHeapAllocAligned.constprop.40+0xb2>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8007472:	ebc8 0e02 	rsb	lr, r8, r2
 8007476:	ea4f 0eee 	mov.w	lr, lr, asr #3
        if (bpages > pages) {
 800747a:	4286      	cmp	r6, r0
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 800747c:	f8c3 e004 	str.w	lr, [r3, #4]
        if (bpages > pages) {
 8007480:	d20c      	bcs.n	800749c <chHeapAllocAligned.constprop.40+0xac>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 8007482:	f106 0e01 	add.w	lr, r6, #1
 8007486:	ea6f 0c06 	mvn.w	ip, r6
 800748a:	eb02 06ce 	add.w	r6, r2, lr, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 800748e:	4460      	add	r0, ip

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8007490:	f8d3 c000 	ldr.w	ip, [r3]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
 8007494:	6070      	str	r0, [r6, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8007496:	f842 c03e 	str.w	ip, [r2, lr, lsl #3]
          H_NEXT(hp) = fp;
 800749a:	601e      	str	r6, [r3, #0]
 800749c:	f102 0a08 	add.w	sl, r2, #8
 80074a0:	e00e      	b.n	80074c0 <chHeapAllocAligned.constprop.40+0xd0>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 80074a2:	4566      	cmp	r6, ip
 80074a4:	d014      	beq.n	80074d0 <chHeapAllocAligned.constprop.40+0xe0>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 80074a6:	3601      	adds	r6, #1
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80074a8:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 80074ac:	eba9 02c6 	sub.w	r2, r9, r6, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 80074b0:	6819      	ldr	r1, [r3, #0]
 80074b2:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 80074b6:	10d2      	asrs	r2, r2, #3
 80074b8:	6042      	str	r2, [r0, #4]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80074ba:	4619      	mov	r1, r3
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 80074bc:	f8ce 0000 	str.w	r0, [lr]
      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 80074c0:	4638      	mov	r0, r7
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 80074c2:	604c      	str	r4, [r1, #4]
      H_HEAP(hp) = heapp;
 80074c4:	600d      	str	r5, [r1, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 80074c6:	f7fe fedb 	bl	8006280 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 80074ca:	4650      	mov	r0, sl
 80074cc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 80074d0:	681a      	ldr	r2, [r3, #0]
 80074d2:	f8ce 2000 	str.w	r2, [lr]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80074d6:	4619      	mov	r1, r3
 80074d8:	e7f2      	b.n	80074c0 <chHeapAllocAligned.constprop.40+0xd0>
      return (void *)H_BLOCK(hp);
      /*lint -restore*/
    }
  }

  return NULL;
 80074da:	2000      	movs	r0, #0
 80074dc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80074e0:	20001320 	.word	0x20001320
 80074e4:	f3af 8000 	nop.w
 80074e8:	f3af 8000 	nop.w
 80074ec:	f3af 8000 	nop.w

080074f0 <chThdCreateFromMemoryPool.constprop.39>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80074f0:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80074f2:	4d13      	ldr	r5, [pc, #76]	; (8007540 <chThdCreateFromMemoryPool.constprop.39+0x50>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80074f4:	b087      	sub	sp, #28
 80074f6:	4607      	mov	r7, r0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80074f8:	4628      	mov	r0, r5
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 80074fa:	460e      	mov	r6, r1
 80074fc:	4614      	mov	r4, r2
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80074fe:	f7fc fe7f 	bl	8004200 <chPoolAlloc>
  if (wsp == NULL) {
 8007502:	b1d0      	cbz	r0, 800753a <chThdCreateFromMemoryPool.constprop.39+0x4a>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8007504:	686b      	ldr	r3, [r5, #4]
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8007506:	4a0f      	ldr	r2, [pc, #60]	; (8007544 <chThdCreateFromMemoryPool.constprop.39+0x54>)
 8007508:	9700      	str	r7, [sp, #0]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 800750a:	4403      	add	r3, r0
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 800750c:	9302      	str	r3, [sp, #8]
 800750e:	9001      	str	r0, [sp, #4]
 8007510:	9603      	str	r6, [sp, #12]
 8007512:	9405      	str	r4, [sp, #20]
 8007514:	9204      	str	r2, [sp, #16]
 8007516:	2320      	movs	r3, #32
 8007518:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800751c:	4668      	mov	r0, sp
 800751e:	f7fe fd17 	bl	8005f50 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8007522:	2302      	movs	r3, #2
 8007524:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 8007528:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 800752a:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 800752c:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 800752e:	f7fe fdb7 	bl	80060a0 <chSchWakeupS>
 8007532:	2300      	movs	r3, #0
 8007534:	f383 8811 	msr	BASEPRI, r3
 8007538:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 800753a:	b007      	add	sp, #28
 800753c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800753e:	bf00      	nop
 8007540:	20001350 	.word	0x20001350
 8007544:	08005511 	.word	0x08005511
 8007548:	f3af 8000 	nop.w
 800754c:	f3af 8000 	nop.w

08007550 <chMBResetI.constprop.31>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8007550:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8007552:	4c09      	ldr	r4, [pc, #36]	; (8007578 <chMBResetI.constprop.31+0x28>)
 8007554:	6823      	ldr	r3, [r4, #0]
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8007556:	6861      	ldr	r1, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8007558:	60a3      	str	r3, [r4, #8]
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 800755a:	1ac9      	subs	r1, r1, r3
 800755c:	f104 001c 	add.w	r0, r4, #28
 8007560:	1089      	asrs	r1, r1, #2

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
 8007562:	60e3      	str	r3, [r4, #12]
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8007564:	f7fe ff4c 	bl	8006400 <chSemResetI>
  chSemResetI(&mbp->fullsem, (cnt_t)0);
 8007568:	f104 0010 	add.w	r0, r4, #16
 800756c:	2100      	movs	r1, #0
}
 800756e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
  chSemResetI(&mbp->fullsem, (cnt_t)0);
 8007572:	f7fe bf45 	b.w	8006400 <chSemResetI>
 8007576:	bf00      	nop
 8007578:	20000868 	.word	0x20000868
 800757c:	f3af 8000 	nop.w

08007580 <chMBReset.constprop.30>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8007580:	b508      	push	{r3, lr}
 8007582:	2320      	movs	r3, #32
 8007584:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMBResetI(mbp);
 8007588:	f7ff ffe2 	bl	8007550 <chMBResetI.constprop.31>
  chSchRescheduleS();
 800758c:	f7fe fd48 	bl	8006020 <chSchRescheduleS>
 8007590:	2300      	movs	r3, #0
 8007592:	f383 8811 	msr	BASEPRI, r3
 8007596:	bd08      	pop	{r3, pc}
 8007598:	f3af 8000 	nop.w
 800759c:	f3af 8000 	nop.w

080075a0 <chMBPost.constprop.29>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80075a0:	b570      	push	{r4, r5, r6, lr}
 80075a2:	2320      	movs	r3, #32
 80075a4:	4606      	mov	r6, r0
 80075a6:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 80075aa:	4c0d      	ldr	r4, [pc, #52]	; (80075e0 <chMBPost.constprop.29+0x40>)
 80075ac:	f104 001c 	add.w	r0, r4, #28
 80075b0:	f7ff f81e 	bl	80065f0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 80075b4:	4605      	mov	r5, r0
 80075b6:	b968      	cbnz	r0, 80075d4 <chMBPost.constprop.29+0x34>
    *mbp->wrptr++ = msg;
 80075b8:	68a2      	ldr	r2, [r4, #8]
    if (mbp->wrptr >= mbp->top) {
 80075ba:	6861      	ldr	r1, [r4, #4]
      mbp->wrptr = mbp->buffer;
    }
    chSemSignalI(&mbp->fullsem);
 80075bc:	4809      	ldr	r0, [pc, #36]	; (80075e4 <chMBPost.constprop.29+0x44>)
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->wrptr++ = msg;
 80075be:	1d13      	adds	r3, r2, #4
    if (mbp->wrptr >= mbp->top) {
 80075c0:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->wrptr++ = msg;
 80075c2:	60a3      	str	r3, [r4, #8]
 80075c4:	6016      	str	r6, [r2, #0]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
 80075c6:	bf24      	itt	cs
 80075c8:	6823      	ldrcs	r3, [r4, #0]
 80075ca:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->fullsem);
 80075cc:	f7fe ff08 	bl	80063e0 <chSemSignalI>
    chSchRescheduleS();
 80075d0:	f7fe fd26 	bl	8006020 <chSchRescheduleS>
 80075d4:	2300      	movs	r3, #0
 80075d6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 80075da:	4628      	mov	r0, r5
 80075dc:	bd70      	pop	{r4, r5, r6, pc}
 80075de:	bf00      	nop
 80075e0:	20000868 	.word	0x20000868
 80075e4:	20000878 	.word	0x20000878
 80075e8:	f3af 8000 	nop.w
 80075ec:	f3af 8000 	nop.w

080075f0 <chMBPostAhead.constprop.27>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 80075f0:	b570      	push	{r4, r5, r6, lr}
 80075f2:	2320      	movs	r3, #32
 80075f4:	4606      	mov	r6, r0
 80075f6:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 80075fa:	4c0e      	ldr	r4, [pc, #56]	; (8007634 <chMBPostAhead.constprop.27+0x44>)
 80075fc:	f104 001c 	add.w	r0, r4, #28
 8007600:	f7fe fff6 	bl	80065f0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8007604:	4605      	mov	r5, r0
 8007606:	b958      	cbnz	r0, 8007620 <chMBPostAhead.constprop.27+0x30>
    if (--mbp->rdptr < mbp->buffer) {
 8007608:	68e3      	ldr	r3, [r4, #12]
 800760a:	6822      	ldr	r2, [r4, #0]
 800760c:	3b04      	subs	r3, #4
 800760e:	4293      	cmp	r3, r2
 8007610:	60e3      	str	r3, [r4, #12]
 8007612:	d30a      	bcc.n	800762a <chMBPostAhead.constprop.27+0x3a>
      mbp->rdptr = mbp->top - 1;
    }
    *mbp->rdptr = msg;
 8007614:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->fullsem);
 8007616:	4808      	ldr	r0, [pc, #32]	; (8007638 <chMBPostAhead.constprop.27+0x48>)
 8007618:	f7fe fee2 	bl	80063e0 <chSemSignalI>
    chSchRescheduleS();
 800761c:	f7fe fd00 	bl	8006020 <chSchRescheduleS>
 8007620:	2300      	movs	r3, #0
 8007622:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8007626:	4628      	mov	r0, r5
 8007628:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->rdptr < mbp->buffer) {
      mbp->rdptr = mbp->top - 1;
 800762a:	6863      	ldr	r3, [r4, #4]
 800762c:	3b04      	subs	r3, #4
 800762e:	60e3      	str	r3, [r4, #12]
 8007630:	e7f0      	b.n	8007614 <chMBPostAhead.constprop.27+0x24>
 8007632:	bf00      	nop
 8007634:	20000868 	.word	0x20000868
 8007638:	20000878 	.word	0x20000878
 800763c:	f3af 8000 	nop.w

08007640 <chMBFetch.constprop.25>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8007640:	b570      	push	{r4, r5, r6, lr}
 8007642:	2320      	movs	r3, #32
 8007644:	4606      	mov	r6, r0
 8007646:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
 800764a:	4c0d      	ldr	r4, [pc, #52]	; (8007680 <chMBFetch.constprop.25+0x40>)
 800764c:	f104 0010 	add.w	r0, r4, #16
 8007650:	f7fe ffce 	bl	80065f0 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8007654:	4605      	mov	r5, r0
 8007656:	b970      	cbnz	r0, 8007676 <chMBFetch.constprop.25+0x36>
    *msgp = *mbp->rdptr++;
 8007658:	68e3      	ldr	r3, [r4, #12]
    if (mbp->rdptr >= mbp->top) {
 800765a:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 800765c:	6819      	ldr	r1, [r3, #0]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
    }
    chSemSignalI(&mbp->emptysem);
 800765e:	4809      	ldr	r0, [pc, #36]	; (8007684 <chMBFetch.constprop.25+0x44>)
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 8007660:	3304      	adds	r3, #4
    if (mbp->rdptr >= mbp->top) {
 8007662:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 8007664:	60e3      	str	r3, [r4, #12]
 8007666:	6031      	str	r1, [r6, #0]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
 8007668:	bf24      	itt	cs
 800766a:	6823      	ldrcs	r3, [r4, #0]
 800766c:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->emptysem);
 800766e:	f7fe feb7 	bl	80063e0 <chSemSignalI>
    chSchRescheduleS();
 8007672:	f7fe fcd5 	bl	8006020 <chSchRescheduleS>
 8007676:	2300      	movs	r3, #0
 8007678:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 800767c:	4628      	mov	r0, r5
 800767e:	bd70      	pop	{r4, r5, r6, pc}
 8007680:	20000868 	.word	0x20000868
 8007684:	20000884 	.word	0x20000884
 8007688:	f3af 8000 	nop.w
 800768c:	f3af 8000 	nop.w

08007690 <chGuardedPoolAllocTimeout.constprop.19>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 8007690:	b510      	push	{r4, lr}
 8007692:	4601      	mov	r1, r0
 8007694:	2320      	movs	r3, #32
 8007696:	f383 8811 	msr	BASEPRI, r3
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 800769a:	4c0d      	ldr	r4, [pc, #52]	; (80076d0 <chGuardedPoolAllocTimeout.constprop.19+0x40>)
 800769c:	4620      	mov	r0, r4
 800769e:	f7fe ffa7 	bl	80065f0 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 80076a2:	b968      	cbnz	r0, 80076c0 <chGuardedPoolAllocTimeout.constprop.19+0x30>
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 80076a4:	68e0      	ldr	r0, [r4, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 80076a6:	b128      	cbz	r0, 80076b4 <chGuardedPoolAllocTimeout.constprop.19+0x24>
    mp->next = mp->next->next;
 80076a8:	6803      	ldr	r3, [r0, #0]
 80076aa:	60e3      	str	r3, [r4, #12]
 80076ac:	2300      	movs	r3, #0
 80076ae:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 80076b2:	bd10      	pop	{r4, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 80076b4:	6963      	ldr	r3, [r4, #20]
 80076b6:	b143      	cbz	r3, 80076ca <chGuardedPoolAllocTimeout.constprop.19+0x3a>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 80076b8:	6920      	ldr	r0, [r4, #16]
 80076ba:	2104      	movs	r1, #4
 80076bc:	4798      	blx	r3
 80076be:	e7f5      	b.n	80076ac <chGuardedPoolAllocTimeout.constprop.19+0x1c>
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
    return NULL;
 80076c0:	2000      	movs	r0, #0
 80076c2:	2300      	movs	r3, #0
 80076c4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 80076c8:	bd10      	pop	{r4, pc}
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
    return NULL;
 80076ca:	4618      	mov	r0, r3
 80076cc:	e7ee      	b.n	80076ac <chGuardedPoolAllocTimeout.constprop.19+0x1c>
 80076ce:	bf00      	nop
 80076d0:	20000890 	.word	0x20000890
 80076d4:	f3af 8000 	nop.w
 80076d8:	f3af 8000 	nop.w
 80076dc:	f3af 8000 	nop.w

080076e0 <_pal_lld_setgroupmode.constprop.6>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 80076e0:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 80076e4:	4b2b      	ldr	r3, [pc, #172]	; (8007794 <_pal_lld_setgroupmode.constprop.6+0xb4>)
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 80076e6:	2200      	movs	r2, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80076e8:	2502      	movs	r5, #2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80076ea:	f04f 0c07 	mov.w	ip, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80076ee:	f04f 0e0f 	mov.w	lr, #15
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 80076f2:	2701      	movs	r7, #1
      m2 = 3 << (bit * 2);
 80076f4:	2603      	movs	r6, #3
 80076f6:	e009      	b.n	800770c <_pal_lld_setgroupmode.constprop.6+0x2c>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80076f8:	6a19      	ldr	r1, [r3, #32]
 80076fa:	ea21 0109 	bic.w	r1, r1, r9
 80076fe:	ea41 0108 	orr.w	r1, r1, r8
 8007702:	6219      	str	r1, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8007704:	0840      	lsrs	r0, r0, #1
 8007706:	d02d      	beq.n	8007764 <_pal_lld_setgroupmode.constprop.6+0x84>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8007708:	00ad      	lsls	r5, r5, #2
    bit++;
 800770a:	3201      	adds	r2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800770c:	07c1      	lsls	r1, r0, #31
 800770e:	d5f9      	bpl.n	8007704 <_pal_lld_setgroupmode.constprop.6+0x24>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8007710:	6859      	ldr	r1, [r3, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8007712:	fa07 f402 	lsl.w	r4, r7, r2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8007716:	ea21 0104 	bic.w	r1, r1, r4
 800771a:	6059      	str	r1, [r3, #4]
 800771c:	0054      	lsls	r4, r2, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800771e:	6899      	ldr	r1, [r3, #8]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8007720:	fa06 f404 	lsl.w	r4, r6, r4
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8007724:	43e4      	mvns	r4, r4
 8007726:	4021      	ands	r1, r4
 8007728:	6099      	str	r1, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800772a:	f8d3 800c 	ldr.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800772e:	f002 0107 	and.w	r1, r2, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8007732:	ea04 0808 	and.w	r8, r4, r8
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8007736:	0089      	lsls	r1, r1, #2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8007738:	2d02      	cmp	r5, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800773a:	f8c3 800c 	str.w	r8, [r3, #12]
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800773e:	fa0e f901 	lsl.w	r9, lr, r1
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8007742:	fa0c f801 	lsl.w	r8, ip, r1
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 8007746:	d00f      	beq.n	8007768 <_pal_lld_setgroupmode.constprop.6+0x88>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8007748:	6819      	ldr	r1, [r3, #0]
 800774a:	400c      	ands	r4, r1
 800774c:	432c      	orrs	r4, r5
        if (bit < 8)
 800774e:	2a07      	cmp	r2, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 8007750:	601c      	str	r4, [r3, #0]
        if (bit < 8)
 8007752:	d9d1      	bls.n	80076f8 <_pal_lld_setgroupmode.constprop.6+0x18>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8007754:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8007756:	ea21 0109 	bic.w	r1, r1, r9
 800775a:	ea41 0108 	orr.w	r1, r1, r8
      }
    }
    mask >>= 1;
    if (!mask)
 800775e:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8007760:	6259      	str	r1, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 8007762:	d1d1      	bne.n	8007708 <_pal_lld_setgroupmode.constprop.6+0x28>
 8007764:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 8007768:	2a07      	cmp	r2, #7
 800776a:	d80b      	bhi.n	8007784 <_pal_lld_setgroupmode.constprop.6+0xa4>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800776c:	6a19      	ldr	r1, [r3, #32]
 800776e:	ea21 0109 	bic.w	r1, r1, r9
 8007772:	ea41 0108 	orr.w	r1, r1, r8
 8007776:	6219      	str	r1, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 8007778:	6819      	ldr	r1, [r3, #0]
 800777a:	400c      	ands	r4, r1
 800777c:	f044 0402 	orr.w	r4, r4, #2
 8007780:	601c      	str	r4, [r3, #0]
 8007782:	e7bf      	b.n	8007704 <_pal_lld_setgroupmode.constprop.6+0x24>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 8007784:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8007786:	ea21 0109 	bic.w	r1, r1, r9
 800778a:	ea41 0108 	orr.w	r1, r1, r8
 800778e:	6259      	str	r1, [r3, #36]	; 0x24
 8007790:	e7f2      	b.n	8007778 <_pal_lld_setgroupmode.constprop.6+0x98>
 8007792:	bf00      	nop
 8007794:	48000800 	.word	0x48000800
 8007798:	f3af 8000 	nop.w
 800779c:	f3af 8000 	nop.w

080077a0 <_test_assert_time_window.constprop.3>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80077a0:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 80077a4:	1a09      	subs	r1, r1, r0
 80077a6:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80077a8:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 80077aa:	428b      	cmp	r3, r1
 80077ac:	d308      	bcc.n	80077c0 <_test_assert_time_window.constprop.3+0x20>

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
  test_failure_message = msg;
 80077ae:	4905      	ldr	r1, [pc, #20]	; (80077c4 <_test_assert_time_window.constprop.3+0x24>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80077b0:	4a05      	ldr	r2, [pc, #20]	; (80077c8 <_test_assert_time_window.constprop.3+0x28>)
  test_global_fail     = true;
 80077b2:	4b06      	ldr	r3, [pc, #24]	; (80077cc <_test_assert_time_window.constprop.3+0x2c>)
  test_failure_message = msg;
 80077b4:	4806      	ldr	r0, [pc, #24]	; (80077d0 <_test_assert_time_window.constprop.3+0x30>)
 80077b6:	6008      	str	r0, [r1, #0]
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 80077b8:	2001      	movs	r0, #1
 80077ba:	7010      	strb	r0, [r2, #0]
  test_global_fail     = true;
 80077bc:	7018      	strb	r0, [r3, #0]
 80077be:	4770      	bx	lr

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 80077c0:	2000      	movs	r0, #0
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 80077c2:	4770      	bx	lr
 80077c4:	2000134c 	.word	0x2000134c
 80077c8:	20001318 	.word	0x20001318
 80077cc:	2000135c 	.word	0x2000135c
 80077d0:	080090b0 	.word	0x080090b0
 80077d4:	f3af 8000 	nop.w
 80077d8:	f3af 8000 	nop.w
 80077dc:	f3af 8000 	nop.w

080077e0 <strchr>:
 80077e0:	b2c9      	uxtb	r1, r1
 80077e2:	b470      	push	{r4, r5, r6}
 80077e4:	2900      	cmp	r1, #0
 80077e6:	d033      	beq.n	8007850 <strchr+0x70>
 80077e8:	0785      	lsls	r5, r0, #30
 80077ea:	d010      	beq.n	800780e <strchr+0x2e>
 80077ec:	7803      	ldrb	r3, [r0, #0]
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d059      	beq.n	80078a6 <strchr+0xc6>
 80077f2:	4299      	cmp	r1, r3
 80077f4:	bf18      	it	ne
 80077f6:	1c43      	addne	r3, r0, #1
 80077f8:	d106      	bne.n	8007808 <strchr+0x28>
 80077fa:	e027      	b.n	800784c <strchr+0x6c>
 80077fc:	f813 2b01 	ldrb.w	r2, [r3], #1
 8007800:	2a00      	cmp	r2, #0
 8007802:	d04d      	beq.n	80078a0 <strchr+0xc0>
 8007804:	4291      	cmp	r1, r2
 8007806:	d021      	beq.n	800784c <strchr+0x6c>
 8007808:	079a      	lsls	r2, r3, #30
 800780a:	4618      	mov	r0, r3
 800780c:	d1f6      	bne.n	80077fc <strchr+0x1c>
 800780e:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8007812:	6803      	ldr	r3, [r0, #0]
 8007814:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8007818:	e001      	b.n	800781e <strchr+0x3e>
 800781a:	f850 3f04 	ldr.w	r3, [r0, #4]!
 800781e:	ea83 0506 	eor.w	r5, r3, r6
 8007822:	f1a5 3401 	sub.w	r4, r5, #16843009	; 0x1010101
 8007826:	f1a3 3201 	sub.w	r2, r3, #16843009	; 0x1010101
 800782a:	ea24 0405 	bic.w	r4, r4, r5
 800782e:	ea22 0303 	bic.w	r3, r2, r3
 8007832:	4323      	orrs	r3, r4
 8007834:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 8007838:	d0ef      	beq.n	800781a <strchr+0x3a>
 800783a:	7803      	ldrb	r3, [r0, #0]
 800783c:	b923      	cbnz	r3, 8007848 <strchr+0x68>
 800783e:	e032      	b.n	80078a6 <strchr+0xc6>
 8007840:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8007844:	2b00      	cmp	r3, #0
 8007846:	d02e      	beq.n	80078a6 <strchr+0xc6>
 8007848:	4299      	cmp	r1, r3
 800784a:	d1f9      	bne.n	8007840 <strchr+0x60>
 800784c:	bc70      	pop	{r4, r5, r6}
 800784e:	4770      	bx	lr
 8007850:	0784      	lsls	r4, r0, #30
 8007852:	d00b      	beq.n	800786c <strchr+0x8c>
 8007854:	7803      	ldrb	r3, [r0, #0]
 8007856:	2b00      	cmp	r3, #0
 8007858:	d0f8      	beq.n	800784c <strchr+0x6c>
 800785a:	1c43      	adds	r3, r0, #1
 800785c:	e003      	b.n	8007866 <strchr+0x86>
 800785e:	7802      	ldrb	r2, [r0, #0]
 8007860:	3301      	adds	r3, #1
 8007862:	2a00      	cmp	r2, #0
 8007864:	d0f2      	beq.n	800784c <strchr+0x6c>
 8007866:	0799      	lsls	r1, r3, #30
 8007868:	4618      	mov	r0, r3
 800786a:	d1f8      	bne.n	800785e <strchr+0x7e>
 800786c:	6802      	ldr	r2, [r0, #0]
 800786e:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8007872:	ea23 0302 	bic.w	r3, r3, r2
 8007876:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800787a:	d108      	bne.n	800788e <strchr+0xae>
 800787c:	f850 2f04 	ldr.w	r2, [r0, #4]!
 8007880:	f1a2 3301 	sub.w	r3, r2, #16843009	; 0x1010101
 8007884:	ea23 0302 	bic.w	r3, r3, r2
 8007888:	f013 3f80 	tst.w	r3, #2155905152	; 0x80808080
 800788c:	d0f6      	beq.n	800787c <strchr+0x9c>
 800788e:	7803      	ldrb	r3, [r0, #0]
 8007890:	2b00      	cmp	r3, #0
 8007892:	d0db      	beq.n	800784c <strchr+0x6c>
 8007894:	f810 3f01 	ldrb.w	r3, [r0, #1]!
 8007898:	2b00      	cmp	r3, #0
 800789a:	d1fb      	bne.n	8007894 <strchr+0xb4>
 800789c:	bc70      	pop	{r4, r5, r6}
 800789e:	4770      	bx	lr
 80078a0:	4610      	mov	r0, r2
 80078a2:	bc70      	pop	{r4, r5, r6}
 80078a4:	4770      	bx	lr
 80078a6:	4618      	mov	r0, r3
 80078a8:	bc70      	pop	{r4, r5, r6}
 80078aa:	4770      	bx	lr

080078ac <strpbrk>:
 80078ac:	b430      	push	{r4, r5}
 80078ae:	7804      	ldrb	r4, [r0, #0]
 80078b0:	b1ec      	cbz	r4, 80078ee <strpbrk+0x42>
 80078b2:	780d      	ldrb	r5, [r1, #0]
 80078b4:	b1ad      	cbz	r5, 80078e2 <strpbrk+0x36>
 80078b6:	42ac      	cmp	r4, r5
 80078b8:	d00e      	beq.n	80078d8 <strpbrk+0x2c>
 80078ba:	460a      	mov	r2, r1
 80078bc:	e001      	b.n	80078c2 <strpbrk+0x16>
 80078be:	429c      	cmp	r4, r3
 80078c0:	d009      	beq.n	80078d6 <strpbrk+0x2a>
 80078c2:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80078c6:	2b00      	cmp	r3, #0
 80078c8:	d1f9      	bne.n	80078be <strpbrk+0x12>
 80078ca:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80078ce:	2c00      	cmp	r4, #0
 80078d0:	d1f0      	bne.n	80078b4 <strpbrk+0x8>
 80078d2:	7815      	ldrb	r5, [r2, #0]
 80078d4:	e000      	b.n	80078d8 <strpbrk+0x2c>
 80078d6:	4625      	mov	r5, r4
 80078d8:	2d00      	cmp	r5, #0
 80078da:	bf08      	it	eq
 80078dc:	2000      	moveq	r0, #0
 80078de:	bc30      	pop	{r4, r5}
 80078e0:	4770      	bx	lr
 80078e2:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 80078e6:	460a      	mov	r2, r1
 80078e8:	2c00      	cmp	r4, #0
 80078ea:	d1e3      	bne.n	80078b4 <strpbrk+0x8>
 80078ec:	e7f1      	b.n	80078d2 <strpbrk+0x26>
 80078ee:	4620      	mov	r0, r4
 80078f0:	bc30      	pop	{r4, r5}
 80078f2:	4770      	bx	lr

080078f4 <strspn>:
 80078f4:	b470      	push	{r4, r5, r6}
 80078f6:	7804      	ldrb	r4, [r0, #0]
 80078f8:	b1a4      	cbz	r4, 8007924 <strspn+0x30>
 80078fa:	780e      	ldrb	r6, [r1, #0]
 80078fc:	4605      	mov	r5, r0
 80078fe:	b14e      	cbz	r6, 8007914 <strspn+0x20>
 8007900:	42b4      	cmp	r4, r6
 8007902:	d00a      	beq.n	800791a <strspn+0x26>
 8007904:	460a      	mov	r2, r1
 8007906:	e001      	b.n	800790c <strspn+0x18>
 8007908:	429c      	cmp	r4, r3
 800790a:	d006      	beq.n	800791a <strspn+0x26>
 800790c:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8007910:	2b00      	cmp	r3, #0
 8007912:	d1f9      	bne.n	8007908 <strspn+0x14>
 8007914:	1a28      	subs	r0, r5, r0
 8007916:	bc70      	pop	{r4, r5, r6}
 8007918:	4770      	bx	lr
 800791a:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 800791e:	2c00      	cmp	r4, #0
 8007920:	d1ed      	bne.n	80078fe <strspn+0xa>
 8007922:	e7f7      	b.n	8007914 <strspn+0x20>
 8007924:	4620      	mov	r0, r4
 8007926:	e7f6      	b.n	8007916 <strspn+0x22>
