
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
                .align  2
                .thumb_func
                .global Reset_Handler
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i
 8000200:	b672      	cpsid	i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 8000202:	4826      	ldr	r0, [pc, #152]	; (800029c <endfiniloop+0x4>)
                msr     PSP, r0
 8000204:	f380 8809 	msr	PSP, r0

                /* Enforcing FPCA bit in the CONTROL register.*/
                movs    r0, #CRT0_CONTROL_INIT | CONTROL_FPCA

#else
                movs    r0, #CRT0_CONTROL_INIT
 8000208:	2002      	movs	r0, #2
#endif

                /* CONTROL register initialization as configured.*/
                msr     CONTROL, r0
 800020a:	f380 8814 	msr	CONTROL, r0
                isb
 800020e:	f3bf 8f6f 	isb	sy

#if CRT0_INIT_CORE == TRUE
                /* Core initialization.*/
                bl      __core_init
 8000212:	f000 f87d 	bl	8000310 <__core_init>
#endif

                /* Early initialization.*/
                bl      __early_init
 8000216:	f00b fc6b 	bl	800baf0 <__early_init>

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 800021a:	4821      	ldr	r0, [pc, #132]	; (80002a0 <endfiniloop+0x8>)
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 800021c:	4921      	ldr	r1, [pc, #132]	; (80002a4 <endfiniloop+0xc>)
                ldr     r2, =__main_stack_end__
 800021e:	4a22      	ldr	r2, [pc, #136]	; (80002a8 <endfiniloop+0x10>)

08000220 <msloop>:
msloop:
                cmp     r1, r2
 8000220:	4291      	cmp	r1, r2
                itt     lo
 8000222:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000224:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     msloop
 8000228:	f7ff bffa 	bcc.w	8000220 <msloop>

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 800022c:	491f      	ldr	r1, [pc, #124]	; (80002ac <endfiniloop+0x14>)
                ldr     r2, =__process_stack_end__
 800022e:	4a1b      	ldr	r2, [pc, #108]	; (800029c <endfiniloop+0x4>)

08000230 <psloop>:
psloop:
                cmp     r1, r2
 8000230:	4291      	cmp	r1, r2
                itt     lo
 8000232:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 8000234:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     psloop
 8000238:	f7ff bffa 	bcc.w	8000230 <psloop>
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 800023c:	491c      	ldr	r1, [pc, #112]	; (80002b0 <endfiniloop+0x18>)
                ldr     r2, =_data_start
 800023e:	4a1d      	ldr	r2, [pc, #116]	; (80002b4 <endfiniloop+0x1c>)
                ldr     r3, =_data_end
 8000240:	4b1d      	ldr	r3, [pc, #116]	; (80002b8 <endfiniloop+0x20>)

08000242 <dloop>:
dloop:
                cmp     r2, r3
 8000242:	429a      	cmp	r2, r3
                ittt    lo
 8000244:	bf3e      	ittt	cc
                ldrlo   r0, [r1], #4
 8000246:	f851 0b04 	ldrcc.w	r0, [r1], #4
                strlo   r0, [r2], #4
 800024a:	f842 0b04 	strcc.w	r0, [r2], #4
                blo     dloop
 800024e:	f7ff bff8 	bcc.w	8000242 <dloop>
#endif

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
 8000252:	2000      	movs	r0, #0
                ldr     r1, =_bss_start
 8000254:	4919      	ldr	r1, [pc, #100]	; (80002bc <endfiniloop+0x24>)
                ldr     r2, =_bss_end
 8000256:	4a1a      	ldr	r2, [pc, #104]	; (80002c0 <endfiniloop+0x28>)

08000258 <bloop>:
bloop:
                cmp     r1, r2
 8000258:	4291      	cmp	r1, r2
                itt     lo
 800025a:	bf3c      	itt	cc
                strlo   r0, [r1], #4
 800025c:	f841 0b04 	strcc.w	r0, [r1], #4
                blo     bloop
 8000260:	f7ff bffa 	bcc.w	8000258 <bloop>
#endif

#if CRT0_INIT_RAM_AREAS == TRUE
                /* RAM areas initialization.*/
                bl      __init_ram_areas
 8000264:	f000 f874 	bl	8000350 <__init_ram_areas>
#endif

                /* Late initialization..*/
                bl      __late_init
 8000268:	f000 f862 	bl	8000330 <__late_init>

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 800026c:	4c15      	ldr	r4, [pc, #84]	; (80002c4 <endfiniloop+0x2c>)
                ldr     r5, =__init_array_end
 800026e:	4d16      	ldr	r5, [pc, #88]	; (80002c8 <endfiniloop+0x30>)

08000270 <initloop>:
initloop:
                cmp     r4, r5
 8000270:	42ac      	cmp	r4, r5
                bge     endinitloop
 8000272:	f280 8005 	bge.w	8000280 <endinitloop>
                ldr     r1, [r4], #4
 8000276:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 800027a:	4788      	blx	r1
                b       initloop
 800027c:	f7ff bff8 	b.w	8000270 <initloop>

08000280 <endinitloop>:
endinitloop:
#endif

                /* Main program invocation, r0 contains the returned value.*/
                bl      main
 8000280:	f015 ff7e 	bl	8016180 <main>

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x34>)
                ldr     r5, =__fini_array_end
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x38>)

08000288 <finiloop>:
finiloop:
                cmp     r4, r5
 8000288:	42ac      	cmp	r4, r5
                bge     endfiniloop
 800028a:	f280 8005 	bge.w	8000298 <endfiniloop>
                ldr     r1, [r4], #4
 800028e:	f854 1b04 	ldr.w	r1, [r4], #4
                blx     r1
 8000292:	4788      	blx	r1
                b       finiloop
 8000294:	f7ff bff8 	b.w	8000288 <finiloop>

08000298 <endfiniloop>:
endfiniloop:
#endif

                /* Branching to the defined exit handler.*/
                b       __default_exit
 8000298:	f000 b852 	b.w	8000340 <__default_exit>
Reset_Handler:
                /* Interrupts are globally masked initially.*/
                cpsid   i

                /* PSP stack pointers initialization.*/
                ldr     r0, =__process_stack_end__
 800029c:	20000800 	.word	0x20000800

                /* Early initialization.*/
                bl      __early_init

#if CRT0_INIT_STACKS == TRUE
                ldr     r0, =CRT0_STACKS_FILL_PATTERN
 80002a0:	55555555 	.word	0x55555555
                /* Main Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__main_stack_base__
 80002a4:	20000000 	.word	0x20000000
                ldr     r2, =__main_stack_end__
 80002a8:	20000400 	.word	0x20000400
                blo     msloop

                /* Process Stack initialization. Note, it assumes that the
                   stack size is a multiple of 4 so the linker file must
                   ensure this.*/
                ldr     r1, =__process_stack_base__
 80002ac:	20000400 	.word	0x20000400
#endif

#if CRT0_INIT_DATA == TRUE
                /* Data initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                ldr     r1, =_textdata_start
 80002b0:	0801a8e0 	.word	0x0801a8e0
                ldr     r2, =_data_start
 80002b4:	20000800 	.word	0x20000800
                ldr     r3, =_data_end
 80002b8:	20001184 	.word	0x20001184

#if CRT0_INIT_BSS == TRUE
                /* BSS initialization. Note, it assumes that the DATA size
                  is a multiple of 4 so the linker file must ensure this.*/
                movs    r0, #0
                ldr     r1, =_bss_start
 80002bc:	20001188 	.word	0x20001188
                ldr     r2, =_bss_end
 80002c0:	200055bc 	.word	0x200055bc
                /* Late initialization..*/
                bl      __late_init

#if CRT0_CALL_CONSTRUCTORS == TRUE
                /* Constructors invocation.*/
                ldr     r4, =__init_array_start
 80002c4:	08000200 	.word	0x08000200
                ldr     r5, =__init_array_end
 80002c8:	08000200 	.word	0x08000200
                /* Main program invocation, r0 contains the returned value.*/
                bl      main

#if CRT0_CALL_DESTRUCTORS == TRUE
                /* Destructors invocation.*/
                ldr     r4, =__fini_array_start
 80002cc:	08000200 	.word	0x08000200
                ldr     r5, =__fini_array_end
 80002d0:	08000200 	.word	0x08000200
	...

080002e0 <_port_switch>:
 * Performs a context switch between two threads.
 *--------------------------------------------------------------------------*/
                .thumb_func
                .globl  _port_switch
_port_switch:
                push    {r4, r5, r6, r7, r8, r9, r10, r11, lr}
 80002e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
#if CORTEX_USE_FPU
                vpush   {s16-s31}
#endif

                str     sp, [r1, #CONTEXT_OFFSET]
 80002e4:	f8c1 d00c 	str.w	sp, [r1, #12]
#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) &&                                \
    ((CORTEX_MODEL == 3) || (CORTEX_MODEL == 4))
                /* Workaround for ARM errata 752419, only applied if
                   condition exists for it to be triggered.*/
                ldr     r3, [r0, #CONTEXT_OFFSET]
 80002e8:	68c3      	ldr	r3, [r0, #12]
                mov     sp, r3
 80002ea:	469d      	mov	sp, r3
#endif

#if CORTEX_USE_FPU
                vpop    {s16-s31}
#endif
                pop     {r4, r5, r6, r7, r8, r9, r10, r11, pc}
 80002ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002f0 <_port_thread_start>:
                bl      _stats_stop_measure_crit_thd
#endif
#if CORTEX_SIMPLIFIED_PRIORITY
                cpsie   i
#else
                movs    r3, #0              /* CORTEX_BASEPRI_DISABLED */
 80002f0:	2300      	movs	r3, #0
                msr     BASEPRI, r3
 80002f2:	f383 8811 	msr	BASEPRI, r3
#endif
                mov     r0, r5
 80002f6:	4628      	mov	r0, r5
                blx     r4
 80002f8:	47a0      	blx	r4
                movs    r0, #0              /* MSG_OK */
 80002fa:	2000      	movs	r0, #0
                bl      chThdExit
 80002fc:	f001 f838 	bl	8001370 <chThdExit>

08000300 <_port_switch_from_isr>:
                bl      _stats_start_measure_crit_thd
#endif
#if CH_DBG_SYSTEM_STATE_CHECK
                bl      _dbg_check_lock
#endif
                bl      chSchDoReschedule
 8000300:	f000 fdce 	bl	8000ea0 <chSchDoReschedule>

08000304 <_port_exit_from_isr>:
                movt    r3, #:upper16:SCB_ICSR
                mov     r2, ICSR_PENDSVSET
                str     r2, [r3, #0]
                cpsie   i
#else /* !CORTEX_SIMPLIFIED_PRIORITY */
                svc     #0
 8000304:	df00      	svc	0
#endif /* !CORTEX_SIMPLIFIED_PRIORITY */
.L1:            b       .L1
 8000306:	e7fe      	b.n	8000306 <_port_exit_from_isr+0x2>
	...

08000310 <__core_init>:

#if __CORTEX_M == 7
  SCB_EnableICache();
  SCB_EnableDCache();
#endif
}
 8000310:	4770      	bx	lr
 8000312:	bf00      	nop
 8000314:	f3af 8000 	nop.w
 8000318:	f3af 8000 	nop.w
 800031c:	f3af 8000 	nop.w
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __early_init(void) {}
 8000320:	4770      	bx	lr
 8000322:	bf00      	nop
 8000324:	f3af 8000 	nop.w
 8000328:	f3af 8000 	nop.w
 800032c:	f3af 8000 	nop.w

08000330 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8000330:	4770      	bx	lr
 8000332:	bf00      	nop
 8000334:	f3af 8000 	nop.w
 8000338:	f3af 8000 	nop.w
 800033c:	f3af 8000 	nop.w

08000340 <__default_exit>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
/*lint -restore*/

  while (true) {
  }
 8000340:	e7fe      	b.n	8000340 <__default_exit>
 8000342:	bf00      	nop
 8000344:	f3af 8000 	nop.w
 8000348:	f3af 8000 	nop.w
 800034c:	f3af 8000 	nop.w

08000350 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 8000350:	b084      	sub	sp, #16
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 8000352:	4b16      	ldr	r3, [pc, #88]	; (80003ac <__init_ram_areas+0x5c>)
 8000354:	9303      	str	r3, [sp, #12]

  do {
    uint32_t *tp = rap->init_text_area;
 8000356:	9b03      	ldr	r3, [sp, #12]
 8000358:	681b      	ldr	r3, [r3, #0]
 800035a:	9302      	str	r3, [sp, #8]
    uint32_t *p = rap->init_area;
 800035c:	9b03      	ldr	r3, [sp, #12]
 800035e:	685b      	ldr	r3, [r3, #4]
 8000360:	9301      	str	r3, [sp, #4]

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000362:	e009      	b.n	8000378 <__init_ram_areas+0x28>
      *p = *tp;
 8000364:	9b02      	ldr	r3, [sp, #8]
 8000366:	681a      	ldr	r2, [r3, #0]
 8000368:	9b01      	ldr	r3, [sp, #4]
 800036a:	601a      	str	r2, [r3, #0]
      p++;
 800036c:	9b01      	ldr	r3, [sp, #4]
 800036e:	3304      	adds	r3, #4
 8000370:	9301      	str	r3, [sp, #4]
      tp++;
 8000372:	9b02      	ldr	r3, [sp, #8]
 8000374:	3304      	adds	r3, #4
 8000376:	9302      	str	r3, [sp, #8]
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 8000378:	9b03      	ldr	r3, [sp, #12]
 800037a:	689a      	ldr	r2, [r3, #8]
 800037c:	9b01      	ldr	r3, [sp, #4]
 800037e:	429a      	cmp	r2, r3
 8000380:	d8f0      	bhi.n	8000364 <__init_ram_areas+0x14>
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000382:	e005      	b.n	8000390 <__init_ram_areas+0x40>
      *p = 0;
 8000384:	9b01      	ldr	r3, [sp, #4]
 8000386:	2200      	movs	r2, #0
 8000388:	601a      	str	r2, [r3, #0]
      p++;
 800038a:	9b01      	ldr	r3, [sp, #4]
 800038c:	3304      	adds	r3, #4
 800038e:	9301      	str	r3, [sp, #4]
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8000390:	9b03      	ldr	r3, [sp, #12]
 8000392:	68da      	ldr	r2, [r3, #12]
 8000394:	9b01      	ldr	r3, [sp, #4]
 8000396:	429a      	cmp	r2, r3
 8000398:	d8f4      	bhi.n	8000384 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 800039a:	9b03      	ldr	r3, [sp, #12]
 800039c:	3310      	adds	r3, #16
 800039e:	9303      	str	r3, [sp, #12]
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 80003a0:	9a03      	ldr	r2, [sp, #12]
 80003a2:	4b03      	ldr	r3, [pc, #12]	; (80003b0 <__init_ram_areas+0x60>)
 80003a4:	429a      	cmp	r2, r3
 80003a6:	d3d6      	bcc.n	8000356 <__init_ram_areas+0x6>
#endif
}
 80003a8:	b004      	add	sp, #16
 80003aa:	4770      	bx	lr
 80003ac:	08019390 	.word	0x08019390
 80003b0:	08019410 	.word	0x08019410
 80003b4:	f3af 8000 	nop.w
 80003b8:	f3af 8000 	nop.w
 80003bc:	f3af 8000 	nop.w

080003c0 <_unhandled_exception>:
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
/*lint -restore*/

  while (true) {
  }
 80003c0:	e7fe      	b.n	80003c0 <_unhandled_exception>
 80003c2:	bf00      	nop
 80003c4:	f3af 8000 	nop.w
 80003c8:	f3af 8000 	nop.w
 80003cc:	f3af 8000 	nop.w

080003d0 <NVIC_SetPriorityGrouping>:
  priority bits (__NVIC_PRIO_BITS), the smallest possible priority group is set.

    \param [in]      PriorityGroup  Priority grouping field.
 */
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
 80003d0:	b084      	sub	sp, #16
 80003d2:	9001      	str	r0, [sp, #4]
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */
 80003d4:	9b01      	ldr	r3, [sp, #4]
 80003d6:	f003 0307 	and.w	r3, r3, #7
 80003da:	9303      	str	r3, [sp, #12]

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80003dc:	4b0a      	ldr	r3, [pc, #40]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 80003de:	68db      	ldr	r3, [r3, #12]
 80003e0:	9302      	str	r3, [sp, #8]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
 80003e2:	9a02      	ldr	r2, [sp, #8]
 80003e4:	f64f 03ff 	movw	r3, #63743	; 0xf8ff
 80003e8:	4013      	ands	r3, r2
 80003ea:	9302      	str	r3, [sp, #8]
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
 80003ec:	9b03      	ldr	r3, [sp, #12]
 80003ee:	021a      	lsls	r2, r3, #8
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
 80003f0:	9b02      	ldr	r3, [sp, #8]
 80003f2:	4313      	orrs	r3, r2
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk));             /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 80003f4:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
 80003f8:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 80003fc:	9302      	str	r3, [sp, #8]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8)                       );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80003fe:	4b02      	ldr	r3, [pc, #8]	; (8000408 <NVIC_SetPriorityGrouping+0x38>)
 8000400:	9a02      	ldr	r2, [sp, #8]
 8000402:	60da      	str	r2, [r3, #12]
}
 8000404:	b004      	add	sp, #16
 8000406:	4770      	bx	lr
 8000408:	e000ed00 	.word	0xe000ed00
 800040c:	f3af 8000 	nop.w

08000410 <NVIC_SetPriority>:

    \param [in]      IRQn  Interrupt number.
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
 8000410:	b082      	sub	sp, #8
 8000412:	4603      	mov	r3, r0
 8000414:	9100      	str	r1, [sp, #0]
 8000416:	f88d 3007 	strb.w	r3, [sp, #7]
  if((int32_t)IRQn < 0) {
 800041a:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 800041e:	2b00      	cmp	r3, #0
 8000420:	da0c      	bge.n	800043c <NVIC_SetPriority+0x2c>
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000422:	490c      	ldr	r1, [pc, #48]	; (8000454 <NVIC_SetPriority+0x44>)
 8000424:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000428:	f003 030f 	and.w	r3, r3, #15
 800042c:	3b04      	subs	r3, #4
 800042e:	9a00      	ldr	r2, [sp, #0]
 8000430:	b2d2      	uxtb	r2, r2
 8000432:	0112      	lsls	r2, r2, #4
 8000434:	b2d2      	uxtb	r2, r2
 8000436:	440b      	add	r3, r1
 8000438:	761a      	strb	r2, [r3, #24]
 800043a:	e009      	b.n	8000450 <NVIC_SetPriority+0x40>
  }
  else {
    NVIC->IP[((uint32_t)(int32_t)IRQn)]               = (uint8_t)((priority << (8 - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800043c:	4906      	ldr	r1, [pc, #24]	; (8000458 <NVIC_SetPriority+0x48>)
 800043e:	f99d 3007 	ldrsb.w	r3, [sp, #7]
 8000442:	9a00      	ldr	r2, [sp, #0]
 8000444:	b2d2      	uxtb	r2, r2
 8000446:	0112      	lsls	r2, r2, #4
 8000448:	b2d2      	uxtb	r2, r2
 800044a:	440b      	add	r3, r1
 800044c:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
  }
}
 8000450:	b002      	add	sp, #8
 8000452:	4770      	bx	lr
 8000454:	e000ed00 	.word	0xe000ed00
 8000458:	e000e100 	.word	0xe000e100
 800045c:	f3af 8000 	nop.w

08000460 <port_init>:
/*===========================================================================*/

/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {
 8000460:	b508      	push	{r3, lr}

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 8000462:	4b0e      	ldr	r3, [pc, #56]	; (800049c <port_init+0x3c>)
 8000464:	2200      	movs	r2, #0
 8000466:	609a      	str	r2, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);
 8000468:	2003      	movs	r0, #3
 800046a:	f7ff ffb1 	bl	80003d0 <NVIC_SetPriorityGrouping>

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 800046e:	4b0c      	ldr	r3, [pc, #48]	; (80004a0 <port_init+0x40>)
 8000470:	4a0b      	ldr	r2, [pc, #44]	; (80004a0 <port_init+0x40>)
 8000472:	68d2      	ldr	r2, [r2, #12]
 8000474:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8000478:	60da      	str	r2, [r3, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 800047a:	4b0a      	ldr	r3, [pc, #40]	; (80004a4 <port_init+0x44>)
 800047c:	4a09      	ldr	r2, [pc, #36]	; (80004a4 <port_init+0x44>)
 800047e:	6812      	ldr	r2, [r2, #0]
 8000480:	f042 0201 	orr.w	r2, r2, #1
 8000484:	601a      	str	r2, [r3, #0]

  /* Initialization of the system vectors used by the port.*/
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  NVIC_SetPriority(SVCall_IRQn, CORTEX_PRIORITY_SVCALL);
 8000486:	f06f 0004 	mvn.w	r0, #4
 800048a:	2101      	movs	r1, #1
 800048c:	f7ff ffc0 	bl	8000410 <NVIC_SetPriority>
#endif
  NVIC_SetPriority(PendSV_IRQn, CORTEX_PRIORITY_PENDSV);
 8000490:	f06f 0001 	mvn.w	r0, #1
 8000494:	2102      	movs	r1, #2
 8000496:	f7ff ffbb 	bl	8000410 <NVIC_SetPriority>
}
 800049a:	bd08      	pop	{r3, pc}
 800049c:	e000ed00 	.word	0xe000ed00
 80004a0:	e000edf0 	.word	0xe000edf0
 80004a4:	e0001000 	.word	0xe0001000
 80004a8:	f3af 8000 	nop.w
 80004ac:	f3af 8000 	nop.w

080004b0 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 80004b0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 80004b2:	f3ef 8311 	mrs	r3, BASEPRI
 80004b6:	9300      	str	r3, [sp, #0]
  return(result);
 80004b8:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 80004ba:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 80004bc:	9b01      	ldr	r3, [sp, #4]
}
 80004be:	4618      	mov	r0, r3
 80004c0:	b002      	add	sp, #8
 80004c2:	4770      	bx	lr
 80004c4:	f3af 8000 	nop.w
 80004c8:	f3af 8000 	nop.w
 80004cc:	f3af 8000 	nop.w

080004d0 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 80004d0:	b082      	sub	sp, #8
 80004d2:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 80004d4:	9b01      	ldr	r3, [sp, #4]
 80004d6:	2b00      	cmp	r3, #0
 80004d8:	bf14      	ite	ne
 80004da:	2300      	movne	r3, #0
 80004dc:	2301      	moveq	r3, #1
 80004de:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80004e0:	4618      	mov	r0, r3
 80004e2:	b002      	add	sp, #8
 80004e4:	4770      	bx	lr
 80004e6:	bf00      	nop
 80004e8:	f3af 8000 	nop.w
 80004ec:	f3af 8000 	nop.w

080004f0 <port_is_isr_context>:
 *
 * @return              The execution context.
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {
 80004f0:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80004f2:	f3ef 8305 	mrs	r3, IPSR
 80004f6:	9301      	str	r3, [sp, #4]
  return(result);
 80004f8:	9b01      	ldr	r3, [sp, #4]

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80004fa:	f3c3 0308 	ubfx	r3, r3, #0, #9
 80004fe:	2b00      	cmp	r3, #0
 8000500:	bf0c      	ite	eq
 8000502:	2300      	moveq	r3, #0
 8000504:	2301      	movne	r3, #1
 8000506:	b2db      	uxtb	r3, r3
}
 8000508:	4618      	mov	r0, r3
 800050a:	b002      	add	sp, #8
 800050c:	4770      	bx	lr
 800050e:	bf00      	nop

08000510 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000510:	b082      	sub	sp, #8
 8000512:	2320      	movs	r3, #32
 8000514:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000516:	9b01      	ldr	r3, [sp, #4]
 8000518:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800051c:	b002      	add	sp, #8
 800051e:	4770      	bx	lr

08000520 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000520:	b082      	sub	sp, #8
 8000522:	2300      	movs	r3, #0
 8000524:	9301      	str	r3, [sp, #4]
 8000526:	9b01      	ldr	r3, [sp, #4]
 8000528:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800052c:	b002      	add	sp, #8
 800052e:	4770      	bx	lr

08000530 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000530:	b508      	push	{r3, lr}

  port_lock();
 8000532:	f7ff ffed 	bl	8000510 <port_lock>
}
 8000536:	bd08      	pop	{r3, pc}
 8000538:	f3af 8000 	nop.w
 800053c:	f3af 8000 	nop.w

08000540 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000540:	b508      	push	{r3, lr}

  port_unlock();
 8000542:	f7ff ffed 	bl	8000520 <port_unlock>
}
 8000546:	bd08      	pop	{r3, pc}
 8000548:	f3af 8000 	nop.w
 800054c:	f3af 8000 	nop.w

08000550 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 8000550:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 8000552:	4770      	bx	lr
 8000554:	f3af 8000 	nop.w
 8000558:	f3af 8000 	nop.w
 800055c:	f3af 8000 	nop.w

08000560 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 8000560:	b082      	sub	sp, #8
 8000562:	2300      	movs	r3, #0
 8000564:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000566:	9b01      	ldr	r3, [sp, #4]
 8000568:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800056c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800056e:	b002      	add	sp, #8
 8000570:	4770      	bx	lr
 8000572:	bf00      	nop
 8000574:	f3af 8000 	nop.w
 8000578:	f3af 8000 	nop.w
 800057c:	f3af 8000 	nop.w

08000580 <port_wait_for_interrupt>:
static inline void port_wait_for_interrupt(void) {

#if CORTEX_ENABLE_WFI_IDLE == TRUE
  __WFI();
#endif
}
 8000580:	4770      	bx	lr
 8000582:	bf00      	nop
 8000584:	f3af 8000 	nop.w
 8000588:	f3af 8000 	nop.w
 800058c:	f3af 8000 	nop.w

08000590 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000590:	4b01      	ldr	r3, [pc, #4]	; (8000598 <port_rt_get_counter_value+0x8>)
 8000592:	685b      	ldr	r3, [r3, #4]
}
 8000594:	4618      	mov	r0, r3
 8000596:	4770      	bx	lr
 8000598:	e0001000 	.word	0xe0001000
 800059c:	f3af 8000 	nop.w

080005a0 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 80005a0:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 80005a2:	f7ff ffdd 	bl	8000560 <port_enable>
}
 80005a6:	bd08      	pop	{r3, pc}
 80005a8:	f3af 8000 	nop.w
 80005ac:	f3af 8000 	nop.w

080005b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80005b0:	b508      	push	{r3, lr}

  port_lock();
 80005b2:	f7ff ffad 	bl	8000510 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80005b6:	bd08      	pop	{r3, pc}
 80005b8:	f3af 8000 	nop.w
 80005bc:	f3af 8000 	nop.w

080005c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80005c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80005c2:	f7ff ffad 	bl	8000520 <port_unlock>
}
 80005c6:	bd08      	pop	{r3, pc}
 80005c8:	f3af 8000 	nop.w
 80005cc:	f3af 8000 	nop.w

080005d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80005d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80005d2:	f7ff ffad 	bl	8000530 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80005d6:	bd08      	pop	{r3, pc}
 80005d8:	f3af 8000 	nop.w
 80005dc:	f3af 8000 	nop.w

080005e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80005e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80005e2:	f7ff ffad 	bl	8000540 <port_unlock_from_isr>
}
 80005e6:	bd08      	pop	{r3, pc}
 80005e8:	f3af 8000 	nop.w
 80005ec:	f3af 8000 	nop.w

080005f0 <chVTDoTickI>:
 *          to acquire the lock if needed. This is done in order to reduce
 *          interrupts jitter when many timers are in use.
 *
 * @iclass
 */
static inline void chVTDoTickI(void) {
 80005f0:	b500      	push	{lr}
 80005f2:	b083      	sub	sp, #12

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 80005f4:	4b18      	ldr	r3, [pc, #96]	; (8000658 <chVTDoTickI+0x68>)
 80005f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80005f8:	1c5a      	adds	r2, r3, #1
 80005fa:	4b17      	ldr	r3, [pc, #92]	; (8000658 <chVTDoTickI+0x68>)
 80005fc:	629a      	str	r2, [r3, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 80005fe:	4b16      	ldr	r3, [pc, #88]	; (8000658 <chVTDoTickI+0x68>)
 8000600:	69da      	ldr	r2, [r3, #28]
 8000602:	4b16      	ldr	r3, [pc, #88]	; (800065c <chVTDoTickI+0x6c>)
 8000604:	429a      	cmp	r2, r3
 8000606:	d024      	beq.n	8000652 <chVTDoTickI+0x62>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8000608:	4b13      	ldr	r3, [pc, #76]	; (8000658 <chVTDoTickI+0x68>)
 800060a:	69db      	ldr	r3, [r3, #28]
 800060c:	689a      	ldr	r2, [r3, #8]
 800060e:	3a01      	subs	r2, #1
 8000610:	609a      	str	r2, [r3, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000612:	e019      	b.n	8000648 <chVTDoTickI+0x58>
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
 8000614:	4b10      	ldr	r3, [pc, #64]	; (8000658 <chVTDoTickI+0x68>)
 8000616:	69db      	ldr	r3, [r3, #28]
 8000618:	9301      	str	r3, [sp, #4]
      fn = vtp->vt_func;
 800061a:	9b01      	ldr	r3, [sp, #4]
 800061c:	68db      	ldr	r3, [r3, #12]
 800061e:	9300      	str	r3, [sp, #0]
      vtp->vt_func = NULL;
 8000620:	9b01      	ldr	r3, [sp, #4]
 8000622:	2200      	movs	r2, #0
 8000624:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000626:	9b01      	ldr	r3, [sp, #4]
 8000628:	681b      	ldr	r3, [r3, #0]
 800062a:	4a0c      	ldr	r2, [pc, #48]	; (800065c <chVTDoTickI+0x6c>)
 800062c:	605a      	str	r2, [r3, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800062e:	9b01      	ldr	r3, [sp, #4]
 8000630:	681a      	ldr	r2, [r3, #0]
 8000632:	4b09      	ldr	r3, [pc, #36]	; (8000658 <chVTDoTickI+0x68>)
 8000634:	61da      	str	r2, [r3, #28]
      chSysUnlockFromISR();
 8000636:	f7ff ffd3 	bl	80005e0 <chSysUnlockFromISR>
      fn(vtp->vt_par);
 800063a:	9b01      	ldr	r3, [sp, #4]
 800063c:	691a      	ldr	r2, [r3, #16]
 800063e:	9b00      	ldr	r3, [sp, #0]
 8000640:	4610      	mov	r0, r2
 8000642:	4798      	blx	r3
      chSysLockFromISR();
 8000644:	f7ff ffc4 	bl	80005d0 <chSysLockFromISR>
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000648:	4b03      	ldr	r3, [pc, #12]	; (8000658 <chVTDoTickI+0x68>)
 800064a:	69db      	ldr	r3, [r3, #28]
 800064c:	689b      	ldr	r3, [r3, #8]
 800064e:	2b00      	cmp	r3, #0
 8000650:	d0e0      	beq.n	8000614 <chVTDoTickI+0x24>

  chDbgAssert((chVTGetSystemTimeX() - ch.vtlist.vt_lasttime) <=
              (now + delta - ch.vtlist.vt_lasttime),
              "exceeding delta");
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000652:	b003      	add	sp, #12
 8000654:	f85d fb04 	ldr.w	pc, [sp], #4
 8000658:	20001bc8 	.word	0x20001bc8
 800065c:	20001be4 	.word	0x20001be4

08000660 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8000660:	b082      	sub	sp, #8
 8000662:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8000664:	4b02      	ldr	r3, [pc, #8]	; (8000670 <chRegSetThreadName+0x10>)
 8000666:	699b      	ldr	r3, [r3, #24]
 8000668:	9a01      	ldr	r2, [sp, #4]
 800066a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800066c:	b002      	add	sp, #8
 800066e:	4770      	bx	lr
 8000670:	20001bc8 	.word	0x20001bc8
 8000674:	f3af 8000 	nop.w
 8000678:	f3af 8000 	nop.w
 800067c:	f3af 8000 	nop.w

08000680 <chRegSetThreadNameX>:
 * @param[in] tp        pointer to the thread
 * @param[in] name      thread name as a zero terminated string
 *
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {
 8000680:	b082      	sub	sp, #8
 8000682:	9001      	str	r0, [sp, #4]
 8000684:	9100      	str	r1, [sp, #0]

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8000686:	9b01      	ldr	r3, [sp, #4]
 8000688:	9a00      	ldr	r2, [sp, #0]
 800068a:	619a      	str	r2, [r3, #24]
#else
  (void)tp;
  (void)name;
#endif
}
 800068c:	b002      	add	sp, #8
 800068e:	4770      	bx	lr

08000690 <_idle_thread>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8000690:	b500      	push	{lr}
 8000692:	b083      	sub	sp, #12
 8000694:	9001      	str	r0, [sp, #4]
  (void)p;

  while (true) {
    /*lint -save -e522 [2.2] Apparently no side effects because it contains
      an asm instruction.*/
    port_wait_for_interrupt();
 8000696:	f7ff ff73 	bl	8000580 <port_wait_for_interrupt>
    /*lint -restore*/
    CH_CFG_IDLE_LOOP_HOOK();
  }
 800069a:	e7fc      	b.n	8000696 <_idle_thread+0x6>
 800069c:	f3af 8000 	nop.w

080006a0 <chSysInit>:
 * @post    The main thread is created with priority @p NORMALPRIO and
 *          interrupts are enabled.
 *
 * @special
 */
void chSysInit(void) {
 80006a0:	b500      	push	{lr}
 80006a2:	b085      	sub	sp, #20
#if CH_DBG_ENABLE_STACK_CHECK == TRUE
  extern stkalign_t __main_thread_stack_base__;
#endif

  port_init();
 80006a4:	f7ff fedc 	bl	8000460 <port_init>
  _scheduler_init();
 80006a8:	f000 fa6a 	bl	8000b80 <_scheduler_init>
  _vt_init();
 80006ac:	f000 f958 	bl	8000960 <_vt_init>
#if CH_CFG_USE_TM == TRUE
  _tm_init();
 80006b0:	f000 ffd6 	bl	8001660 <_tm_init>
#endif
#if CH_CFG_USE_MEMCORE == TRUE
  _core_init();
 80006b4:	f002 ffbc 	bl	8003630 <_core_init>
#endif
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
 80006b8:	f003 f81a 	bl	80036f0 <_heap_init>
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80006bc:	480f      	ldr	r0, [pc, #60]	; (80006fc <chSysInit+0x5c>)
 80006be:	2140      	movs	r1, #64	; 0x40
 80006c0:	f000 fd26 	bl	8001110 <_thread_init>
 80006c4:	4602      	mov	r2, r0
 80006c6:	4b0e      	ldr	r3, [pc, #56]	; (8000700 <chSysInit+0x60>)
 80006c8:	619a      	str	r2, [r3, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80006ca:	4b0d      	ldr	r3, [pc, #52]	; (8000700 <chSysInit+0x60>)
 80006cc:	699b      	ldr	r3, [r3, #24]
 80006ce:	2201      	movs	r2, #1
 80006d0:	771a      	strb	r2, [r3, #28]
#if CH_DBG_STATISTICS == TRUE
  /* Starting measurement for this thread.*/
  chTMStartMeasurementX(&currp->p_stats);
#endif

  chSysEnable();
 80006d2:	f7ff ff65 	bl	80005a0 <chSysEnable>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Note, &ch_debug points to the string "main" if the registry is
     active.*/
  chRegSetThreadName((const char *)&ch_debug);
 80006d6:	480b      	ldr	r0, [pc, #44]	; (8000704 <chSysInit+0x64>)
 80006d8:	f7ff ffc2 	bl	8000660 <chRegSetThreadName>
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 80006dc:	2300      	movs	r3, #0
 80006de:	9300      	str	r3, [sp, #0]
 80006e0:	4809      	ldr	r0, [pc, #36]	; (8000708 <chSysInit+0x68>)
 80006e2:	21d8      	movs	r1, #216	; 0xd8
 80006e4:	2201      	movs	r2, #1
 80006e6:	4b09      	ldr	r3, [pc, #36]	; (800070c <chSysInit+0x6c>)
 80006e8:	f000 fd7a 	bl	80011e0 <chThdCreateStatic>
 80006ec:	9003      	str	r0, [sp, #12]
                                      sizeof(ch.idle_thread_wa),
                                      IDLEPRIO,
                                      (tfunc_t)_idle_thread,
                                      NULL);
    chRegSetThreadNameX(tp, "idle");
 80006ee:	9803      	ldr	r0, [sp, #12]
 80006f0:	4907      	ldr	r1, [pc, #28]	; (8000710 <chSysInit+0x70>)
 80006f2:	f7ff ffc5 	bl	8000680 <chRegSetThreadNameX>
  }
#endif
}
 80006f6:	b005      	add	sp, #20
 80006f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80006fc:	20001bf8 	.word	0x20001bf8
 8000700:	20001bc8 	.word	0x20001bc8
 8000704:	08019420 	.word	0x08019420
 8000708:	20001c40 	.word	0x20001c40
 800070c:	08000691 	.word	0x08000691
 8000710:	08019410 	.word	0x08019410
 8000714:	f3af 8000 	nop.w
 8000718:	f3af 8000 	nop.w
 800071c:	f3af 8000 	nop.w

08000720 <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
 8000720:	b500      	push	{lr}
 8000722:	b083      	sub	sp, #12
 8000724:	9001      	str	r0, [sp, #4]

  port_disable();
 8000726:	f7ff ff13 	bl	8000550 <port_disable>
#if defined(CH_CFG_SYSTEM_HALT_HOOK) || defined(__DOXYGEN__)
  CH_CFG_SYSTEM_HALT_HOOK(reason);
#endif

  /* Pointing to the passed message.*/
  ch.dbg.panic_msg = reason;
 800072a:	4b02      	ldr	r3, [pc, #8]	; (8000734 <chSysHalt+0x14>)
 800072c:	9a01      	ldr	r2, [sp, #4]
 800072e:	62da      	str	r2, [r3, #44]	; 0x2c

  /* Harmless infinite loop.*/
  while (true) {
  }
 8000730:	e7fe      	b.n	8000730 <chSysHalt+0x10>
 8000732:	bf00      	nop
 8000734:	20001bc8 	.word	0x20001bc8
 8000738:	f3af 8000 	nop.w
 800073c:	f3af 8000 	nop.w

08000740 <chSysIntegrityCheckI>:
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8000740:	b086      	sub	sp, #24
 8000742:	9001      	str	r0, [sp, #4]
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8000744:	9b01      	ldr	r3, [sp, #4]
 8000746:	f003 0301 	and.w	r3, r3, #1
 800074a:	2b00      	cmp	r3, #0
 800074c:	d022      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 800074e:	2300      	movs	r3, #0
 8000750:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_queue.p_next;
 8000752:	4b3a      	ldr	r3, [pc, #232]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000754:	681b      	ldr	r3, [r3, #0]
 8000756:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000758:	e005      	b.n	8000766 <chSysIntegrityCheckI+0x26>
      n++;
 800075a:	9b05      	ldr	r3, [sp, #20]
 800075c:	3301      	adds	r3, #1
 800075e:	9305      	str	r3, [sp, #20]
      tp = tp->p_next;
 8000760:	9b04      	ldr	r3, [sp, #16]
 8000762:	681b      	ldr	r3, [r3, #0]
 8000764:	9304      	str	r3, [sp, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_queue.p_next;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000766:	9a04      	ldr	r2, [sp, #16]
 8000768:	4b34      	ldr	r3, [pc, #208]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800076a:	429a      	cmp	r2, r3
 800076c:	d1f5      	bne.n	800075a <chSysIntegrityCheckI+0x1a>
      n++;
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
 800076e:	4b33      	ldr	r3, [pc, #204]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000770:	685b      	ldr	r3, [r3, #4]
 8000772:	9304      	str	r3, [sp, #16]
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000774:	e005      	b.n	8000782 <chSysIntegrityCheckI+0x42>
      n--;
 8000776:	9b05      	ldr	r3, [sp, #20]
 8000778:	3b01      	subs	r3, #1
 800077a:	9305      	str	r3, [sp, #20]
      tp = tp->p_prev;
 800077c:	9b04      	ldr	r3, [sp, #16]
 800077e:	685b      	ldr	r3, [r3, #4]
 8000780:	9304      	str	r3, [sp, #16]
      tp = tp->p_next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_queue.p_prev;
    while (tp != (thread_t *)&ch.rlist.r_queue) {
 8000782:	9a04      	ldr	r2, [sp, #16]
 8000784:	4b2d      	ldr	r3, [pc, #180]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000786:	429a      	cmp	r2, r3
 8000788:	d1f5      	bne.n	8000776 <chSysIntegrityCheckI+0x36>
      n--;
      tp = tp->p_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800078a:	9b05      	ldr	r3, [sp, #20]
 800078c:	2b00      	cmp	r3, #0
 800078e:	d001      	beq.n	8000794 <chSysIntegrityCheckI+0x54>
      return true;
 8000790:	2301      	movs	r3, #1
 8000792:	e050      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 8000794:	9b01      	ldr	r3, [sp, #4]
 8000796:	f003 0302 	and.w	r3, r3, #2
 800079a:	2b00      	cmp	r3, #0
 800079c:	d022      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 800079e:	2300      	movs	r3, #0
 80007a0:	9305      	str	r3, [sp, #20]
    vtp = ch.vtlist.vt_next;
 80007a2:	4b26      	ldr	r3, [pc, #152]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007a4:	69db      	ldr	r3, [r3, #28]
 80007a6:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007a8:	e005      	b.n	80007b6 <chSysIntegrityCheckI+0x76>
      n++;
 80007aa:	9b05      	ldr	r3, [sp, #20]
 80007ac:	3301      	adds	r3, #1
 80007ae:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_next;
 80007b0:	9b03      	ldr	r3, [sp, #12]
 80007b2:	681b      	ldr	r3, [r3, #0]
 80007b4:	9303      	str	r3, [sp, #12]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.vt_next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007b6:	9a03      	ldr	r2, [sp, #12]
 80007b8:	4b21      	ldr	r3, [pc, #132]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007ba:	429a      	cmp	r2, r3
 80007bc:	d1f5      	bne.n	80007aa <chSysIntegrityCheckI+0x6a>
      n++;
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
 80007be:	4b1f      	ldr	r3, [pc, #124]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007c0:	6a1b      	ldr	r3, [r3, #32]
 80007c2:	9303      	str	r3, [sp, #12]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007c4:	e005      	b.n	80007d2 <chSysIntegrityCheckI+0x92>
      n--;
 80007c6:	9b05      	ldr	r3, [sp, #20]
 80007c8:	3b01      	subs	r3, #1
 80007ca:	9305      	str	r3, [sp, #20]
      vtp = vtp->vt_prev;
 80007cc:	9b03      	ldr	r3, [sp, #12]
 80007ce:	685b      	ldr	r3, [r3, #4]
 80007d0:	9303      	str	r3, [sp, #12]
      vtp = vtp->vt_next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.vt_prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80007d2:	9a03      	ldr	r2, [sp, #12]
 80007d4:	4b1a      	ldr	r3, [pc, #104]	; (8000840 <chSysIntegrityCheckI+0x100>)
 80007d6:	429a      	cmp	r2, r3
 80007d8:	d1f5      	bne.n	80007c6 <chSysIntegrityCheckI+0x86>
      n--;
      vtp = vtp->vt_prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 80007da:	9b05      	ldr	r3, [sp, #20]
 80007dc:	2b00      	cmp	r3, #0
 80007de:	d001      	beq.n	80007e4 <chSysIntegrityCheckI+0xa4>
      return true;
 80007e0:	2301      	movs	r3, #1
 80007e2:	e028      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 80007e4:	9b01      	ldr	r3, [sp, #4]
 80007e6:	f003 0304 	and.w	r3, r3, #4
 80007ea:	2b00      	cmp	r3, #0
 80007ec:	d022      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80007ee:	2300      	movs	r3, #0
 80007f0:	9305      	str	r3, [sp, #20]
    tp = ch.rlist.r_newer;
 80007f2:	4b12      	ldr	r3, [pc, #72]	; (800083c <chSysIntegrityCheckI+0xfc>)
 80007f4:	691b      	ldr	r3, [r3, #16]
 80007f6:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 80007f8:	e005      	b.n	8000806 <chSysIntegrityCheckI+0xc6>
      n++;
 80007fa:	9b05      	ldr	r3, [sp, #20]
 80007fc:	3301      	adds	r3, #1
 80007fe:	9305      	str	r3, [sp, #20]
      tp = tp->p_newer;
 8000800:	9b02      	ldr	r3, [sp, #8]
 8000802:	691b      	ldr	r3, [r3, #16]
 8000804:	9302      	str	r3, [sp, #8]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.r_newer;
    while (tp != (thread_t *)&ch.rlist) {
 8000806:	9a02      	ldr	r2, [sp, #8]
 8000808:	4b0c      	ldr	r3, [pc, #48]	; (800083c <chSysIntegrityCheckI+0xfc>)
 800080a:	429a      	cmp	r2, r3
 800080c:	d1f5      	bne.n	80007fa <chSysIntegrityCheckI+0xba>
      n++;
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
 800080e:	4b0b      	ldr	r3, [pc, #44]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000810:	695b      	ldr	r3, [r3, #20]
 8000812:	9302      	str	r3, [sp, #8]
    while (tp != (thread_t *)&ch.rlist) {
 8000814:	e005      	b.n	8000822 <chSysIntegrityCheckI+0xe2>
      n--;
 8000816:	9b05      	ldr	r3, [sp, #20]
 8000818:	3b01      	subs	r3, #1
 800081a:	9305      	str	r3, [sp, #20]
      tp = tp->p_older;
 800081c:	9b02      	ldr	r3, [sp, #8]
 800081e:	695b      	ldr	r3, [r3, #20]
 8000820:	9302      	str	r3, [sp, #8]
      tp = tp->p_newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.r_older;
    while (tp != (thread_t *)&ch.rlist) {
 8000822:	9a02      	ldr	r2, [sp, #8]
 8000824:	4b05      	ldr	r3, [pc, #20]	; (800083c <chSysIntegrityCheckI+0xfc>)
 8000826:	429a      	cmp	r2, r3
 8000828:	d1f5      	bne.n	8000816 <chSysIntegrityCheckI+0xd6>
      n--;
      tp = tp->p_older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800082a:	9b05      	ldr	r3, [sp, #20]
 800082c:	2b00      	cmp	r3, #0
 800082e:	d001      	beq.n	8000834 <chSysIntegrityCheckI+0xf4>
      return true;
 8000830:	2301      	movs	r3, #1
 8000832:	e000      	b.n	8000836 <chSysIntegrityCheckI+0xf6>
  if ((testmask & CH_INTEGRITY_PORT) != 0U) {
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
 8000834:	2300      	movs	r3, #0
}
 8000836:	4618      	mov	r0, r3
 8000838:	b006      	add	sp, #24
 800083a:	4770      	bx	lr
 800083c:	20001bc8 	.word	0x20001bc8
 8000840:	20001be4 	.word	0x20001be4
 8000844:	f3af 8000 	nop.w
 8000848:	f3af 8000 	nop.w
 800084c:	f3af 8000 	nop.w

08000850 <chSysTimerHandlerI>:
 *          and, together with the @p CH_CFG_TIME_QUANTUM macro, the round robin
 *          interval.
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {
 8000850:	b508      	push	{r3, lr}

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 8000852:	4b07      	ldr	r3, [pc, #28]	; (8000870 <chSysTimerHandlerI+0x20>)
 8000854:	699b      	ldr	r3, [r3, #24]
 8000856:	7fdb      	ldrb	r3, [r3, #31]
 8000858:	2b00      	cmp	r3, #0
 800085a:	d005      	beq.n	8000868 <chSysTimerHandlerI+0x18>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 800085c:	4b04      	ldr	r3, [pc, #16]	; (8000870 <chSysTimerHandlerI+0x20>)
 800085e:	699b      	ldr	r3, [r3, #24]
 8000860:	7fda      	ldrb	r2, [r3, #31]
 8000862:	3a01      	subs	r2, #1
 8000864:	b2d2      	uxtb	r2, r2
 8000866:	77da      	strb	r2, [r3, #31]
  }
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  currp->p_time++;
#endif
  chVTDoTickI();
 8000868:	f7ff fec2 	bl	80005f0 <chVTDoTickI>
#if defined(CH_CFG_SYSTEM_TICK_HOOK)
  CH_CFG_SYSTEM_TICK_HOOK();
#endif
}
 800086c:	bd08      	pop	{r3, pc}
 800086e:	bf00      	nop
 8000870:	20001bc8 	.word	0x20001bc8
 8000874:	f3af 8000 	nop.w
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <chSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {
 8000880:	b500      	push	{lr}
 8000882:	b083      	sub	sp, #12

  syssts_t sts = port_get_irq_status();
 8000884:	f7ff fe14 	bl	80004b0 <port_get_irq_status>
 8000888:	9001      	str	r0, [sp, #4]
  if (port_irq_enabled(sts)) {
 800088a:	9801      	ldr	r0, [sp, #4]
 800088c:	f7ff fe20 	bl	80004d0 <port_irq_enabled>
 8000890:	4603      	mov	r3, r0
 8000892:	2b00      	cmp	r3, #0
 8000894:	d009      	beq.n	80008aa <chSysGetStatusAndLockX+0x2a>
    if (port_is_isr_context()) {
 8000896:	f7ff fe2b 	bl	80004f0 <port_is_isr_context>
 800089a:	4603      	mov	r3, r0
 800089c:	2b00      	cmp	r3, #0
 800089e:	d002      	beq.n	80008a6 <chSysGetStatusAndLockX+0x26>
      chSysLockFromISR();
 80008a0:	f7ff fe96 	bl	80005d0 <chSysLockFromISR>
 80008a4:	e001      	b.n	80008aa <chSysGetStatusAndLockX+0x2a>
    }
    else {
      chSysLock();
 80008a6:	f7ff fe83 	bl	80005b0 <chSysLock>
    }
  }
  return sts;
 80008aa:	9b01      	ldr	r3, [sp, #4]
}
 80008ac:	4618      	mov	r0, r3
 80008ae:	b003      	add	sp, #12
 80008b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80008b4:	f3af 8000 	nop.w
 80008b8:	f3af 8000 	nop.w
 80008bc:	f3af 8000 	nop.w

080008c0 <chSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80008c0:	b500      	push	{lr}
 80008c2:	b083      	sub	sp, #12
 80008c4:	9001      	str	r0, [sp, #4]

  if (port_irq_enabled(sts)) {
 80008c6:	9801      	ldr	r0, [sp, #4]
 80008c8:	f7ff fe02 	bl	80004d0 <port_irq_enabled>
 80008cc:	4603      	mov	r3, r0
 80008ce:	2b00      	cmp	r3, #0
 80008d0:	d00b      	beq.n	80008ea <chSysRestoreStatusX+0x2a>
    if (port_is_isr_context()) {
 80008d2:	f7ff fe0d 	bl	80004f0 <port_is_isr_context>
 80008d6:	4603      	mov	r3, r0
 80008d8:	2b00      	cmp	r3, #0
 80008da:	d002      	beq.n	80008e2 <chSysRestoreStatusX+0x22>
      chSysUnlockFromISR();
 80008dc:	f7ff fe80 	bl	80005e0 <chSysUnlockFromISR>
 80008e0:	e003      	b.n	80008ea <chSysRestoreStatusX+0x2a>
    }
    else {
      chSchRescheduleS();
 80008e2:	f000 fa4d 	bl	8000d80 <chSchRescheduleS>
      chSysUnlock();
 80008e6:	f7ff fe6b 	bl	80005c0 <chSysUnlock>
    }
  }
}
 80008ea:	b003      	add	sp, #12
 80008ec:	f85d fb04 	ldr.w	pc, [sp], #4

080008f0 <chSysIsCounterWithinX>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {
 80008f0:	b084      	sub	sp, #16
 80008f2:	9003      	str	r0, [sp, #12]
 80008f4:	9102      	str	r1, [sp, #8]
 80008f6:	9201      	str	r2, [sp, #4]

  return (bool)((cnt - start) < (end - start));
 80008f8:	9a03      	ldr	r2, [sp, #12]
 80008fa:	9b02      	ldr	r3, [sp, #8]
 80008fc:	1ad2      	subs	r2, r2, r3
 80008fe:	9901      	ldr	r1, [sp, #4]
 8000900:	9b02      	ldr	r3, [sp, #8]
 8000902:	1acb      	subs	r3, r1, r3
 8000904:	429a      	cmp	r2, r3
 8000906:	bf2c      	ite	cs
 8000908:	2300      	movcs	r3, #0
 800090a:	2301      	movcc	r3, #1
 800090c:	b2db      	uxtb	r3, r3
}
 800090e:	4618      	mov	r0, r3
 8000910:	b004      	add	sp, #16
 8000912:	4770      	bx	lr
 8000914:	f3af 8000 	nop.w
 8000918:	f3af 8000 	nop.w
 800091c:	f3af 8000 	nop.w

08000920 <chSysPolledDelayX>:
 *
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
void chSysPolledDelayX(rtcnt_t cycles) {
 8000920:	b500      	push	{lr}
 8000922:	b085      	sub	sp, #20
 8000924:	9001      	str	r0, [sp, #4]
  rtcnt_t start = chSysGetRealtimeCounterX();
 8000926:	f7ff fe33 	bl	8000590 <port_rt_get_counter_value>
 800092a:	9003      	str	r0, [sp, #12]
  rtcnt_t end  = start + cycles;
 800092c:	9a03      	ldr	r2, [sp, #12]
 800092e:	9b01      	ldr	r3, [sp, #4]
 8000930:	4413      	add	r3, r2
 8000932:	9302      	str	r3, [sp, #8]

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8000934:	bf00      	nop
 8000936:	f7ff fe2b 	bl	8000590 <port_rt_get_counter_value>
 800093a:	4603      	mov	r3, r0
 800093c:	4618      	mov	r0, r3
 800093e:	9903      	ldr	r1, [sp, #12]
 8000940:	9a02      	ldr	r2, [sp, #8]
 8000942:	f7ff ffd5 	bl	80008f0 <chSysIsCounterWithinX>
 8000946:	4603      	mov	r3, r0
 8000948:	2b00      	cmp	r3, #0
 800094a:	d1f4      	bne.n	8000936 <chSysPolledDelayX+0x16>
  }
}
 800094c:	b005      	add	sp, #20
 800094e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000952:	bf00      	nop
 8000954:	f3af 8000 	nop.w
 8000958:	f3af 8000 	nop.w
 800095c:	f3af 8000 	nop.w

08000960 <_vt_init>:
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 8000960:	4b06      	ldr	r3, [pc, #24]	; (800097c <_vt_init+0x1c>)
 8000962:	4a07      	ldr	r2, [pc, #28]	; (8000980 <_vt_init+0x20>)
 8000964:	61da      	str	r2, [r3, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000966:	4b05      	ldr	r3, [pc, #20]	; (800097c <_vt_init+0x1c>)
 8000968:	4a05      	ldr	r2, [pc, #20]	; (8000980 <_vt_init+0x20>)
 800096a:	621a      	str	r2, [r3, #32]
  ch.vtlist.vt_delta = (systime_t)-1;
 800096c:	4b03      	ldr	r3, [pc, #12]	; (800097c <_vt_init+0x1c>)
 800096e:	f04f 32ff 	mov.w	r2, #4294967295
 8000972:	625a      	str	r2, [r3, #36]	; 0x24
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8000974:	4b01      	ldr	r3, [pc, #4]	; (800097c <_vt_init+0x1c>)
 8000976:	2200      	movs	r2, #0
 8000978:	629a      	str	r2, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.vt_lasttime = (systime_t)0;
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800097a:	4770      	bx	lr
 800097c:	20001bc8 	.word	0x20001bc8
 8000980:	20001be4 	.word	0x20001be4
 8000984:	f3af 8000 	nop.w
 8000988:	f3af 8000 	nop.w
 800098c:	f3af 8000 	nop.w

08000990 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8000990:	b086      	sub	sp, #24
 8000992:	9003      	str	r0, [sp, #12]
 8000994:	9102      	str	r1, [sp, #8]
 8000996:	9201      	str	r2, [sp, #4]
 8000998:	9300      	str	r3, [sp, #0]
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 800099a:	9b03      	ldr	r3, [sp, #12]
 800099c:	9a00      	ldr	r2, [sp, #0]
 800099e:	611a      	str	r2, [r3, #16]
  vtp->vt_func = vtfunc;
 80009a0:	9b03      	ldr	r3, [sp, #12]
 80009a2:	9a01      	ldr	r2, [sp, #4]
 80009a4:	60da      	str	r2, [r3, #12]
      port_timer_set_alarm(ch.vtlist.vt_lasttime + delta);
    }
  }
#else /* CH_CFG_ST_TIMEDELTA == 0 */
  /* Delta is initially equal to the specified delay.*/
  delta = delay;
 80009a6:	9b02      	ldr	r3, [sp, #8]
 80009a8:	9304      	str	r3, [sp, #16]

  /* Pointer to the first element in the delta list.*/
  p = ch.vtlist.vt_next;
 80009aa:	4b17      	ldr	r3, [pc, #92]	; (8000a08 <chVTDoSetI+0x78>)
 80009ac:	69db      	ldr	r3, [r3, #28]
 80009ae:	9305      	str	r3, [sp, #20]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009b0:	e007      	b.n	80009c2 <chVTDoSetI+0x32>
    delta -= p->vt_delta;
 80009b2:	9b05      	ldr	r3, [sp, #20]
 80009b4:	689b      	ldr	r3, [r3, #8]
 80009b6:	9a04      	ldr	r2, [sp, #16]
 80009b8:	1ad3      	subs	r3, r2, r3
 80009ba:	9304      	str	r3, [sp, #16]
    p = p->vt_next;
 80009bc:	9b05      	ldr	r3, [sp, #20]
 80009be:	681b      	ldr	r3, [r3, #0]
 80009c0:	9305      	str	r3, [sp, #20]
  p = ch.vtlist.vt_next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->vt_delta < delta) {
 80009c2:	9b05      	ldr	r3, [sp, #20]
 80009c4:	689a      	ldr	r2, [r3, #8]
 80009c6:	9b04      	ldr	r3, [sp, #16]
 80009c8:	429a      	cmp	r2, r3
 80009ca:	d3f2      	bcc.n	80009b2 <chVTDoSetI+0x22>
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 80009cc:	9b03      	ldr	r3, [sp, #12]
 80009ce:	9a05      	ldr	r2, [sp, #20]
 80009d0:	601a      	str	r2, [r3, #0]
  vtp->vt_prev = vtp->vt_next->vt_prev;
 80009d2:	9b03      	ldr	r3, [sp, #12]
 80009d4:	681b      	ldr	r3, [r3, #0]
 80009d6:	685a      	ldr	r2, [r3, #4]
 80009d8:	9b03      	ldr	r3, [sp, #12]
 80009da:	605a      	str	r2, [r3, #4]
  vtp->vt_prev->vt_next = vtp;
 80009dc:	9b03      	ldr	r3, [sp, #12]
 80009de:	685b      	ldr	r3, [r3, #4]
 80009e0:	9a03      	ldr	r2, [sp, #12]
 80009e2:	601a      	str	r2, [r3, #0]
  p->vt_prev = vtp;
 80009e4:	9b05      	ldr	r3, [sp, #20]
 80009e6:	9a03      	ldr	r2, [sp, #12]
 80009e8:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 80009ea:	9b03      	ldr	r3, [sp, #12]
 80009ec:	9a04      	ldr	r2, [sp, #16]
 80009ee:	609a      	str	r2, [r3, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 80009f0:	9b05      	ldr	r3, [sp, #20]
 80009f2:	689a      	ldr	r2, [r3, #8]
 80009f4:	9b04      	ldr	r3, [sp, #16]
 80009f6:	1ad2      	subs	r2, r2, r3
 80009f8:	9b05      	ldr	r3, [sp, #20]
 80009fa:	609a      	str	r2, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 80009fc:	4b02      	ldr	r3, [pc, #8]	; (8000a08 <chVTDoSetI+0x78>)
 80009fe:	f04f 32ff 	mov.w	r2, #4294967295
 8000a02:	625a      	str	r2, [r3, #36]	; 0x24
}
 8000a04:	b006      	add	sp, #24
 8000a06:	4770      	bx	lr
 8000a08:	20001bc8 	.word	0x20001bc8
 8000a0c:	f3af 8000 	nop.w

08000a10 <chVTDoResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8000a10:	b082      	sub	sp, #8
 8000a12:	9001      	str	r0, [sp, #4]
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000a14:	9b01      	ldr	r3, [sp, #4]
 8000a16:	681b      	ldr	r3, [r3, #0]
 8000a18:	9a01      	ldr	r2, [sp, #4]
 8000a1a:	6812      	ldr	r2, [r2, #0]
 8000a1c:	6891      	ldr	r1, [r2, #8]
 8000a1e:	9a01      	ldr	r2, [sp, #4]
 8000a20:	6892      	ldr	r2, [r2, #8]
 8000a22:	440a      	add	r2, r1
 8000a24:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000a26:	9b01      	ldr	r3, [sp, #4]
 8000a28:	685b      	ldr	r3, [r3, #4]
 8000a2a:	9a01      	ldr	r2, [sp, #4]
 8000a2c:	6812      	ldr	r2, [r2, #0]
 8000a2e:	601a      	str	r2, [r3, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000a30:	9b01      	ldr	r3, [sp, #4]
 8000a32:	681b      	ldr	r3, [r3, #0]
 8000a34:	9a01      	ldr	r2, [sp, #4]
 8000a36:	6852      	ldr	r2, [r2, #4]
 8000a38:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;
 8000a3a:	9b01      	ldr	r3, [sp, #4]
 8000a3c:	2200      	movs	r2, #0
 8000a3e:	60da      	str	r2, [r3, #12]

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000a40:	4b02      	ldr	r3, [pc, #8]	; (8000a4c <chVTDoResetI+0x3c>)
 8000a42:	f04f 32ff 	mov.w	r2, #4294967295
 8000a46:	625a      	str	r2, [r3, #36]	; 0x24
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.vt_lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8000a48:	b002      	add	sp, #8
 8000a4a:	4770      	bx	lr
 8000a4c:	20001bc8 	.word	0x20001bc8

08000a50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000a50:	b082      	sub	sp, #8
 8000a52:	2320      	movs	r3, #32
 8000a54:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000a56:	9b01      	ldr	r3, [sp, #4]
 8000a58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a5c:	b002      	add	sp, #8
 8000a5e:	4770      	bx	lr

08000a60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000a60:	b082      	sub	sp, #8
 8000a62:	2300      	movs	r3, #0
 8000a64:	9301      	str	r3, [sp, #4]
 8000a66:	9b01      	ldr	r3, [sp, #4]
 8000a68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000a6c:	b002      	add	sp, #8
 8000a6e:	4770      	bx	lr

08000a70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8000a70:	b508      	push	{r3, lr}

  port_lock();
 8000a72:	f7ff ffed 	bl	8000a50 <port_lock>
}
 8000a76:	bd08      	pop	{r3, pc}
 8000a78:	f3af 8000 	nop.w
 8000a7c:	f3af 8000 	nop.w

08000a80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8000a80:	b508      	push	{r3, lr}

  port_unlock();
 8000a82:	f7ff ffed 	bl	8000a60 <port_unlock>
}
 8000a86:	bd08      	pop	{r3, pc}
 8000a88:	f3af 8000 	nop.w
 8000a8c:	f3af 8000 	nop.w

08000a90 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000a90:	b082      	sub	sp, #8
 8000a92:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000a94:	9b01      	ldr	r3, [sp, #4]
 8000a96:	9a01      	ldr	r2, [sp, #4]
 8000a98:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000a9a:	9b01      	ldr	r3, [sp, #4]
 8000a9c:	9a01      	ldr	r2, [sp, #4]
 8000a9e:	605a      	str	r2, [r3, #4]
}
 8000aa0:	b002      	add	sp, #8
 8000aa2:	4770      	bx	lr
 8000aa4:	f3af 8000 	nop.w
 8000aa8:	f3af 8000 	nop.w
 8000aac:	f3af 8000 	nop.w

08000ab0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000ab0:	b084      	sub	sp, #16
 8000ab2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000ab4:	9b01      	ldr	r3, [sp, #4]
 8000ab6:	681b      	ldr	r3, [r3, #0]
 8000ab8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000aba:	9b03      	ldr	r3, [sp, #12]
 8000abc:	681a      	ldr	r2, [r3, #0]
 8000abe:	9b01      	ldr	r3, [sp, #4]
 8000ac0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000ac2:	9b01      	ldr	r3, [sp, #4]
 8000ac4:	681b      	ldr	r3, [r3, #0]
 8000ac6:	9a01      	ldr	r2, [sp, #4]
 8000ac8:	605a      	str	r2, [r3, #4]

  return tp;
 8000aca:	9b03      	ldr	r3, [sp, #12]
}
 8000acc:	4618      	mov	r0, r3
 8000ace:	b004      	add	sp, #16
 8000ad0:	4770      	bx	lr
 8000ad2:	bf00      	nop
 8000ad4:	f3af 8000 	nop.w
 8000ad8:	f3af 8000 	nop.w
 8000adc:	f3af 8000 	nop.w

08000ae0 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8000ae0:	b082      	sub	sp, #8
 8000ae2:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8000ae4:	9b01      	ldr	r3, [sp, #4]
 8000ae6:	685b      	ldr	r3, [r3, #4]
 8000ae8:	9a01      	ldr	r2, [sp, #4]
 8000aea:	6812      	ldr	r2, [r2, #0]
 8000aec:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8000aee:	9b01      	ldr	r3, [sp, #4]
 8000af0:	681b      	ldr	r3, [r3, #0]
 8000af2:	9a01      	ldr	r2, [sp, #4]
 8000af4:	6852      	ldr	r2, [r2, #4]
 8000af6:	605a      	str	r2, [r3, #4]

  return tp;
 8000af8:	9b01      	ldr	r3, [sp, #4]
}
 8000afa:	4618      	mov	r0, r3
 8000afc:	b002      	add	sp, #8
 8000afe:	4770      	bx	lr

08000b00 <chSchIsRescRequiredI>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000b00:	4b06      	ldr	r3, [pc, #24]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b02:	681b      	ldr	r3, [r3, #0]
 8000b04:	689a      	ldr	r2, [r3, #8]
 8000b06:	4b05      	ldr	r3, [pc, #20]	; (8000b1c <chSchIsRescRequiredI+0x1c>)
 8000b08:	699b      	ldr	r3, [r3, #24]
 8000b0a:	689b      	ldr	r3, [r3, #8]
 8000b0c:	429a      	cmp	r2, r3
 8000b0e:	bf94      	ite	ls
 8000b10:	2300      	movls	r3, #0
 8000b12:	2301      	movhi	r3, #1
 8000b14:	b2db      	uxtb	r3, r3
}
 8000b16:	4618      	mov	r0, r3
 8000b18:	4770      	bx	lr
 8000b1a:	bf00      	nop
 8000b1c:	20001bc8 	.word	0x20001bc8

08000b20 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8000b20:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8000b22:	f7ff ffa5 	bl	8000a70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8000b26:	bd08      	pop	{r3, pc}
 8000b28:	f3af 8000 	nop.w
 8000b2c:	f3af 8000 	nop.w

08000b30 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8000b30:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8000b32:	f7ff ffa5 	bl	8000a80 <port_unlock_from_isr>
}
 8000b36:	bd08      	pop	{r3, pc}
 8000b38:	f3af 8000 	nop.w
 8000b3c:	f3af 8000 	nop.w

08000b40 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8000b40:	b082      	sub	sp, #8
 8000b42:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8000b44:	9b01      	ldr	r3, [sp, #4]
 8000b46:	68db      	ldr	r3, [r3, #12]
 8000b48:	2b00      	cmp	r3, #0
 8000b4a:	bf0c      	ite	eq
 8000b4c:	2300      	moveq	r3, #0
 8000b4e:	2301      	movne	r3, #1
 8000b50:	b2db      	uxtb	r3, r3
}
 8000b52:	4618      	mov	r0, r3
 8000b54:	b002      	add	sp, #8
 8000b56:	4770      	bx	lr
 8000b58:	f3af 8000 	nop.w
 8000b5c:	f3af 8000 	nop.w

08000b60 <chSemFastSignalI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastSignalI(semaphore_t *sp) {
 8000b60:	b082      	sub	sp, #8
 8000b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt++;
 8000b64:	9b01      	ldr	r3, [sp, #4]
 8000b66:	689b      	ldr	r3, [r3, #8]
 8000b68:	1c5a      	adds	r2, r3, #1
 8000b6a:	9b01      	ldr	r3, [sp, #4]
 8000b6c:	609a      	str	r2, [r3, #8]
}
 8000b6e:	b002      	add	sp, #8
 8000b70:	4770      	bx	lr
 8000b72:	bf00      	nop
 8000b74:	f3af 8000 	nop.w
 8000b78:	f3af 8000 	nop.w
 8000b7c:	f3af 8000 	nop.w

08000b80 <_scheduler_init>:
/**
 * @brief   Scheduler initialization.
 *
 * @notapi
 */
void _scheduler_init(void) {
 8000b80:	b508      	push	{r3, lr}

  queue_init(&ch.rlist.r_queue);
 8000b82:	4806      	ldr	r0, [pc, #24]	; (8000b9c <_scheduler_init+0x1c>)
 8000b84:	f7ff ff84 	bl	8000a90 <queue_init>
  ch.rlist.r_prio = NOPRIO;
 8000b88:	4b04      	ldr	r3, [pc, #16]	; (8000b9c <_scheduler_init+0x1c>)
 8000b8a:	2200      	movs	r2, #0
 8000b8c:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 8000b8e:	4b03      	ldr	r3, [pc, #12]	; (8000b9c <_scheduler_init+0x1c>)
 8000b90:	4a02      	ldr	r2, [pc, #8]	; (8000b9c <_scheduler_init+0x1c>)
 8000b92:	611a      	str	r2, [r3, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 8000b94:	4b01      	ldr	r3, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b96:	4a01      	ldr	r2, [pc, #4]	; (8000b9c <_scheduler_init+0x1c>)
 8000b98:	615a      	str	r2, [r3, #20]
#endif
}
 8000b9a:	bd08      	pop	{r3, pc}
 8000b9c:	20001bc8 	.word	0x20001bc8

08000ba0 <chSchReadyI>:
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8000ba0:	b084      	sub	sp, #16
 8000ba2:	9001      	str	r0, [sp, #4]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000ba4:	9b01      	ldr	r3, [sp, #4]
 8000ba6:	2200      	movs	r2, #0
 8000ba8:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000baa:	4b0e      	ldr	r3, [pc, #56]	; (8000be4 <chSchReadyI+0x44>)
 8000bac:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8000bae:	9b03      	ldr	r3, [sp, #12]
 8000bb0:	681b      	ldr	r3, [r3, #0]
 8000bb2:	9303      	str	r3, [sp, #12]
  } while (cp->p_prio >= tp->p_prio);
 8000bb4:	9b03      	ldr	r3, [sp, #12]
 8000bb6:	689a      	ldr	r2, [r3, #8]
 8000bb8:	9b01      	ldr	r3, [sp, #4]
 8000bba:	689b      	ldr	r3, [r3, #8]
 8000bbc:	429a      	cmp	r2, r3
 8000bbe:	d2f6      	bcs.n	8000bae <chSchReadyI+0xe>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000bc0:	9b01      	ldr	r3, [sp, #4]
 8000bc2:	9a03      	ldr	r2, [sp, #12]
 8000bc4:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8000bc6:	9b03      	ldr	r3, [sp, #12]
 8000bc8:	685a      	ldr	r2, [r3, #4]
 8000bca:	9b01      	ldr	r3, [sp, #4]
 8000bcc:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000bce:	9b01      	ldr	r3, [sp, #4]
 8000bd0:	685b      	ldr	r3, [r3, #4]
 8000bd2:	9a01      	ldr	r2, [sp, #4]
 8000bd4:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8000bd6:	9b03      	ldr	r3, [sp, #12]
 8000bd8:	9a01      	ldr	r2, [sp, #4]
 8000bda:	605a      	str	r2, [r3, #4]

  return tp;
 8000bdc:	9b01      	ldr	r3, [sp, #4]
}
 8000bde:	4618      	mov	r0, r3
 8000be0:	b004      	add	sp, #16
 8000be2:	4770      	bx	lr
 8000be4:	20001bc8 	.word	0x20001bc8
 8000be8:	f3af 8000 	nop.w
 8000bec:	f3af 8000 	nop.w

08000bf0 <chSchGoSleepS>:
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000bf0:	b500      	push	{lr}
 8000bf2:	b085      	sub	sp, #20
 8000bf4:	4603      	mov	r3, r0
 8000bf6:	f88d 3007 	strb.w	r3, [sp, #7]
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000bfa:	4b0e      	ldr	r3, [pc, #56]	; (8000c34 <chSchGoSleepS+0x44>)
 8000bfc:	699b      	ldr	r3, [r3, #24]
 8000bfe:	9303      	str	r3, [sp, #12]
  otp->p_state = newstate;
 8000c00:	9b03      	ldr	r3, [sp, #12]
 8000c02:	f89d 2007 	ldrb.w	r2, [sp, #7]
 8000c06:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000c08:	9b03      	ldr	r3, [sp, #12]
 8000c0a:	220a      	movs	r2, #10
 8000c0c:	77da      	strb	r2, [r3, #31]
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c0e:	4809      	ldr	r0, [pc, #36]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c10:	f7ff ff4e 	bl	8000ab0 <queue_fifo_remove>
 8000c14:	4602      	mov	r2, r0
 8000c16:	4b07      	ldr	r3, [pc, #28]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c18:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c1a:	4b06      	ldr	r3, [pc, #24]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c1c:	699b      	ldr	r3, [r3, #24]
 8000c1e:	2201      	movs	r2, #1
 8000c20:	771a      	strb	r2, [r3, #28]
  chSysSwitch(currp, otp);
 8000c22:	4b04      	ldr	r3, [pc, #16]	; (8000c34 <chSchGoSleepS+0x44>)
 8000c24:	699b      	ldr	r3, [r3, #24]
 8000c26:	4618      	mov	r0, r3
 8000c28:	9903      	ldr	r1, [sp, #12]
 8000c2a:	f7ff fb59 	bl	80002e0 <_port_switch>
}
 8000c2e:	b005      	add	sp, #20
 8000c30:	f85d fb04 	ldr.w	pc, [sp], #4
 8000c34:	20001bc8 	.word	0x20001bc8
 8000c38:	f3af 8000 	nop.w
 8000c3c:	f3af 8000 	nop.w

08000c40 <wakeup>:

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8000c40:	b500      	push	{lr}
 8000c42:	b085      	sub	sp, #20
 8000c44:	9001      	str	r0, [sp, #4]
  thread_t *tp = (thread_t *)p;
 8000c46:	9b01      	ldr	r3, [sp, #4]
 8000c48:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8000c4a:	f7ff ff69 	bl	8000b20 <chSysLockFromISR>
  switch (tp->p_state) {
 8000c4e:	9b03      	ldr	r3, [sp, #12]
 8000c50:	7f1b      	ldrb	r3, [r3, #28]
 8000c52:	2b07      	cmp	r3, #7
 8000c54:	d823      	bhi.n	8000c9e <wakeup+0x5e>
 8000c56:	a201      	add	r2, pc, #4	; (adr r2, 8000c5c <wakeup+0x1c>)
 8000c58:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8000c5c:	08000c7d 	.word	0x08000c7d
 8000c60:	08000c9f 	.word	0x08000c9f
 8000c64:	08000c9f 	.word	0x08000c9f
 8000c68:	08000c83 	.word	0x08000c83
 8000c6c:	08000c97 	.word	0x08000c97
 8000c70:	08000c8d 	.word	0x08000c8d
 8000c74:	08000c9f 	.word	0x08000c9f
 8000c78:	08000c97 	.word	0x08000c97
  case CH_STATE_READY:
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
 8000c7c:	f7ff ff58 	bl	8000b30 <chSysUnlockFromISR>
    return;
 8000c80:	e017      	b.n	8000cb2 <wakeup+0x72>
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 8000c82:	9b03      	ldr	r3, [sp, #12]
 8000c84:	6a1b      	ldr	r3, [r3, #32]
 8000c86:	2200      	movs	r2, #0
 8000c88:	601a      	str	r2, [r3, #0]
    break;
 8000c8a:	e009      	b.n	8000ca0 <wakeup+0x60>
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8000c8c:	9b03      	ldr	r3, [sp, #12]
 8000c8e:	6a1b      	ldr	r3, [r3, #32]
 8000c90:	4618      	mov	r0, r3
 8000c92:	f7ff ff65 	bl	8000b60 <chSemFastSignalI>
#if (CH_CFG_USE_CONDVARS == TRUE) && (CH_CFG_USE_CONDVARS_TIMEOUT == TRUE)
  case CH_STATE_WTCOND:
#endif
  case CH_STATE_QUEUED:
    /* States requiring dequeuing.*/
    (void) queue_dequeue(tp);
 8000c96:	9803      	ldr	r0, [sp, #12]
 8000c98:	f7ff ff22 	bl	8000ae0 <queue_dequeue>
    break;
 8000c9c:	e000      	b.n	8000ca0 <wakeup+0x60>
  default:
    /* Any other state, nothing to do.*/
    break;
 8000c9e:	bf00      	nop
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8000ca0:	9b03      	ldr	r3, [sp, #12]
 8000ca2:	f04f 32ff 	mov.w	r2, #4294967295
 8000ca6:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 8000ca8:	9803      	ldr	r0, [sp, #12]
 8000caa:	f7ff ff79 	bl	8000ba0 <chSchReadyI>
  chSysUnlockFromISR();
 8000cae:	f7ff ff3f 	bl	8000b30 <chSysUnlockFromISR>
}
 8000cb2:	b005      	add	sp, #20
 8000cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8000cb8:	f3af 8000 	nop.w
 8000cbc:	f3af 8000 	nop.w

08000cc0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000cc0:	b500      	push	{lr}
 8000cc2:	b089      	sub	sp, #36	; 0x24
 8000cc4:	4603      	mov	r3, r0
 8000cc6:	9100      	str	r1, [sp, #0]
 8000cc8:	f88d 3007 	strb.w	r3, [sp, #7]

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000ccc:	9b00      	ldr	r3, [sp, #0]
 8000cce:	f1b3 3fff 	cmp.w	r3, #4294967295
 8000cd2:	d019      	beq.n	8000d08 <chSchGoSleepTimeoutS+0x48>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 8000cd4:	4b12      	ldr	r3, [pc, #72]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000cd6:	699b      	ldr	r3, [r3, #24]
 8000cd8:	aa03      	add	r2, sp, #12
 8000cda:	4610      	mov	r0, r2
 8000cdc:	9900      	ldr	r1, [sp, #0]
 8000cde:	4a11      	ldr	r2, [pc, #68]	; (8000d24 <chSchGoSleepTimeoutS+0x64>)
 8000ce0:	f7ff fe56 	bl	8000990 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8000ce4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000ce8:	4618      	mov	r0, r3
 8000cea:	f7ff ff81 	bl	8000bf0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000cee:	ab03      	add	r3, sp, #12
 8000cf0:	4618      	mov	r0, r3
 8000cf2:	f7ff ff25 	bl	8000b40 <chVTIsArmedI>
 8000cf6:	4603      	mov	r3, r0
 8000cf8:	2b00      	cmp	r3, #0
 8000cfa:	d004      	beq.n	8000d06 <chSchGoSleepTimeoutS+0x46>
      chVTDoResetI(&vt);
 8000cfc:	ab03      	add	r3, sp, #12
 8000cfe:	4618      	mov	r0, r3
 8000d00:	f7ff fe86 	bl	8000a10 <chVTDoResetI>
 8000d04:	e005      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
 8000d06:	e004      	b.n	8000d12 <chSchGoSleepTimeoutS+0x52>
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000d08:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8000d0c:	4618      	mov	r0, r3
 8000d0e:	f7ff ff6f 	bl	8000bf0 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000d12:	4b03      	ldr	r3, [pc, #12]	; (8000d20 <chSchGoSleepTimeoutS+0x60>)
 8000d14:	699b      	ldr	r3, [r3, #24]
 8000d16:	6a1b      	ldr	r3, [r3, #32]
}
 8000d18:	4618      	mov	r0, r3
 8000d1a:	b009      	add	sp, #36	; 0x24
 8000d1c:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d20:	20001bc8 	.word	0x20001bc8
 8000d24:	08000c41 	.word	0x08000c41
 8000d28:	f3af 8000 	nop.w
 8000d2c:	f3af 8000 	nop.w

08000d30 <chSchWakeupS>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8000d30:	b500      	push	{lr}
 8000d32:	b085      	sub	sp, #20
 8000d34:	9001      	str	r0, [sp, #4]
 8000d36:	9100      	str	r1, [sp, #0]
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8000d38:	9b01      	ldr	r3, [sp, #4]
 8000d3a:	9a00      	ldr	r2, [sp, #0]
 8000d3c:	621a      	str	r2, [r3, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8000d3e:	9b01      	ldr	r3, [sp, #4]
 8000d40:	689a      	ldr	r2, [r3, #8]
 8000d42:	4b0e      	ldr	r3, [pc, #56]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d44:	699b      	ldr	r3, [r3, #24]
 8000d46:	689b      	ldr	r3, [r3, #8]
 8000d48:	429a      	cmp	r2, r3
 8000d4a:	d803      	bhi.n	8000d54 <chSchWakeupS+0x24>
    (void) chSchReadyI(ntp);
 8000d4c:	9801      	ldr	r0, [sp, #4]
 8000d4e:	f7ff ff27 	bl	8000ba0 <chSchReadyI>
 8000d52:	e00f      	b.n	8000d74 <chSchWakeupS+0x44>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8000d54:	4b09      	ldr	r3, [pc, #36]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d56:	699b      	ldr	r3, [r3, #24]
 8000d58:	4618      	mov	r0, r3
 8000d5a:	f7ff ff21 	bl	8000ba0 <chSchReadyI>
 8000d5e:	9003      	str	r0, [sp, #12]
    setcurrp(ntp);
 8000d60:	4b06      	ldr	r3, [pc, #24]	; (8000d7c <chSchWakeupS+0x4c>)
 8000d62:	9a01      	ldr	r2, [sp, #4]
 8000d64:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8000d66:	9b01      	ldr	r3, [sp, #4]
 8000d68:	2201      	movs	r2, #1
 8000d6a:	771a      	strb	r2, [r3, #28]
    chSysSwitch(ntp, otp);
 8000d6c:	9801      	ldr	r0, [sp, #4]
 8000d6e:	9903      	ldr	r1, [sp, #12]
 8000d70:	f7ff fab6 	bl	80002e0 <_port_switch>
  }
}
 8000d74:	b005      	add	sp, #20
 8000d76:	f85d fb04 	ldr.w	pc, [sp], #4
 8000d7a:	bf00      	nop
 8000d7c:	20001bc8 	.word	0x20001bc8

08000d80 <chSchRescheduleS>:
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8000d80:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000d82:	f7ff febd 	bl	8000b00 <chSchIsRescRequiredI>
 8000d86:	4603      	mov	r3, r0
 8000d88:	2b00      	cmp	r3, #0
 8000d8a:	d001      	beq.n	8000d90 <chSchRescheduleS+0x10>
    chSchDoRescheduleAhead();
 8000d8c:	f000 f850 	bl	8000e30 <chSchDoRescheduleAhead>
  }
}
 8000d90:	bd08      	pop	{r3, pc}
 8000d92:	bf00      	nop
 8000d94:	f3af 8000 	nop.w
 8000d98:	f3af 8000 	nop.w
 8000d9c:	f3af 8000 	nop.w

08000da0 <chSchIsPreemptionRequired>:
 *                      immediately.
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
 8000da0:	b082      	sub	sp, #8
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 8000da2:	4b0f      	ldr	r3, [pc, #60]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000da4:	681b      	ldr	r3, [r3, #0]
 8000da6:	689b      	ldr	r3, [r3, #8]
 8000da8:	9301      	str	r3, [sp, #4]
  tprio_t p2 = currp->p_prio;
 8000daa:	4b0d      	ldr	r3, [pc, #52]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000dac:	699b      	ldr	r3, [r3, #24]
 8000dae:	689b      	ldr	r3, [r3, #8]
 8000db0:	9300      	str	r3, [sp, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 8000db2:	4b0b      	ldr	r3, [pc, #44]	; (8000de0 <chSchIsPreemptionRequired+0x40>)
 8000db4:	699b      	ldr	r3, [r3, #24]
 8000db6:	7fdb      	ldrb	r3, [r3, #31]
 8000db8:	2b00      	cmp	r3, #0
 8000dba:	d007      	beq.n	8000dcc <chSchIsPreemptionRequired+0x2c>
 8000dbc:	9a01      	ldr	r2, [sp, #4]
 8000dbe:	9b00      	ldr	r3, [sp, #0]
 8000dc0:	429a      	cmp	r2, r3
 8000dc2:	bf94      	ite	ls
 8000dc4:	2300      	movls	r3, #0
 8000dc6:	2301      	movhi	r3, #1
 8000dc8:	b2db      	uxtb	r3, r3
 8000dca:	e006      	b.n	8000dda <chSchIsPreemptionRequired+0x3a>
 8000dcc:	9a01      	ldr	r2, [sp, #4]
 8000dce:	9b00      	ldr	r3, [sp, #0]
 8000dd0:	429a      	cmp	r2, r3
 8000dd2:	bf34      	ite	cc
 8000dd4:	2300      	movcc	r3, #0
 8000dd6:	2301      	movcs	r3, #1
 8000dd8:	b2db      	uxtb	r3, r3
#else
  /* If the round robin preemption feature is not enabled then performs a
     simpler comparison.*/
  return p1 > p2;
#endif
}
 8000dda:	4618      	mov	r0, r3
 8000ddc:	b002      	add	sp, #8
 8000dde:	4770      	bx	lr
 8000de0:	20001bc8 	.word	0x20001bc8
 8000de4:	f3af 8000 	nop.w
 8000de8:	f3af 8000 	nop.w
 8000dec:	f3af 8000 	nop.w

08000df0 <chSchDoRescheduleBehind>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleBehind(void) {
 8000df0:	b500      	push	{lr}
 8000df2:	b083      	sub	sp, #12
  thread_t *otp;

  otp = currp;
 8000df4:	4b0d      	ldr	r3, [pc, #52]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000df6:	699b      	ldr	r3, [r3, #24]
 8000df8:	9301      	str	r3, [sp, #4]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000dfa:	480c      	ldr	r0, [pc, #48]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000dfc:	f7ff fe58 	bl	8000ab0 <queue_fifo_remove>
 8000e00:	4602      	mov	r2, r0
 8000e02:	4b0a      	ldr	r3, [pc, #40]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e04:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e06:	4b09      	ldr	r3, [pc, #36]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e08:	699b      	ldr	r3, [r3, #24]
 8000e0a:	2201      	movs	r2, #1
 8000e0c:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000e0e:	9b01      	ldr	r3, [sp, #4]
 8000e10:	220a      	movs	r2, #10
 8000e12:	77da      	strb	r2, [r3, #31]
#endif
  (void) chSchReadyI(otp);
 8000e14:	9801      	ldr	r0, [sp, #4]
 8000e16:	f7ff fec3 	bl	8000ba0 <chSchReadyI>
  chSysSwitch(currp, otp);
 8000e1a:	4b04      	ldr	r3, [pc, #16]	; (8000e2c <chSchDoRescheduleBehind+0x3c>)
 8000e1c:	699b      	ldr	r3, [r3, #24]
 8000e1e:	4618      	mov	r0, r3
 8000e20:	9901      	ldr	r1, [sp, #4]
 8000e22:	f7ff fa5d 	bl	80002e0 <_port_switch>
}
 8000e26:	b003      	add	sp, #12
 8000e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e2c:	20001bc8 	.word	0x20001bc8

08000e30 <chSchDoRescheduleAhead>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 8000e30:	b500      	push	{lr}
 8000e32:	b083      	sub	sp, #12
  thread_t *otp, *cp;

  otp = currp;
 8000e34:	4b18      	ldr	r3, [pc, #96]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e36:	699b      	ldr	r3, [r3, #24]
 8000e38:	9300      	str	r3, [sp, #0]
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000e3a:	4817      	ldr	r0, [pc, #92]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e3c:	f7ff fe38 	bl	8000ab0 <queue_fifo_remove>
 8000e40:	4602      	mov	r2, r0
 8000e42:	4b15      	ldr	r3, [pc, #84]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e44:	619a      	str	r2, [r3, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000e46:	4b14      	ldr	r3, [pc, #80]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e48:	699b      	ldr	r3, [r3, #24]
 8000e4a:	2201      	movs	r2, #1
 8000e4c:	771a      	strb	r2, [r3, #28]

  otp->p_state = CH_STATE_READY;
 8000e4e:	9b00      	ldr	r3, [sp, #0]
 8000e50:	2200      	movs	r2, #0
 8000e52:	771a      	strb	r2, [r3, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
 8000e54:	4b10      	ldr	r3, [pc, #64]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e56:	9301      	str	r3, [sp, #4]
  do {
    cp = cp->p_next;
 8000e58:	9b01      	ldr	r3, [sp, #4]
 8000e5a:	681b      	ldr	r3, [r3, #0]
 8000e5c:	9301      	str	r3, [sp, #4]
  } while (cp->p_prio > otp->p_prio);
 8000e5e:	9b01      	ldr	r3, [sp, #4]
 8000e60:	689a      	ldr	r2, [r3, #8]
 8000e62:	9b00      	ldr	r3, [sp, #0]
 8000e64:	689b      	ldr	r3, [r3, #8]
 8000e66:	429a      	cmp	r2, r3
 8000e68:	d8f6      	bhi.n	8000e58 <chSchDoRescheduleAhead+0x28>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000e6a:	9b00      	ldr	r3, [sp, #0]
 8000e6c:	9a01      	ldr	r2, [sp, #4]
 8000e6e:	601a      	str	r2, [r3, #0]
  otp->p_prev = cp->p_prev;
 8000e70:	9b01      	ldr	r3, [sp, #4]
 8000e72:	685a      	ldr	r2, [r3, #4]
 8000e74:	9b00      	ldr	r3, [sp, #0]
 8000e76:	605a      	str	r2, [r3, #4]
  otp->p_prev->p_next = otp;
 8000e78:	9b00      	ldr	r3, [sp, #0]
 8000e7a:	685b      	ldr	r3, [r3, #4]
 8000e7c:	9a00      	ldr	r2, [sp, #0]
 8000e7e:	601a      	str	r2, [r3, #0]
  cp->p_prev = otp;
 8000e80:	9b01      	ldr	r3, [sp, #4]
 8000e82:	9a00      	ldr	r2, [sp, #0]
 8000e84:	605a      	str	r2, [r3, #4]

  chSysSwitch(currp, otp);
 8000e86:	4b04      	ldr	r3, [pc, #16]	; (8000e98 <chSchDoRescheduleAhead+0x68>)
 8000e88:	699b      	ldr	r3, [r3, #24]
 8000e8a:	4618      	mov	r0, r3
 8000e8c:	9900      	ldr	r1, [sp, #0]
 8000e8e:	f7ff fa27 	bl	80002e0 <_port_switch>
}
 8000e92:	b003      	add	sp, #12
 8000e94:	f85d fb04 	ldr.w	pc, [sp], #4
 8000e98:	20001bc8 	.word	0x20001bc8
 8000e9c:	f3af 8000 	nop.w

08000ea0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8000ea0:	b508      	push	{r3, lr}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 8000ea2:	4b05      	ldr	r3, [pc, #20]	; (8000eb8 <chSchDoReschedule+0x18>)
 8000ea4:	699b      	ldr	r3, [r3, #24]
 8000ea6:	7fdb      	ldrb	r3, [r3, #31]
 8000ea8:	2b00      	cmp	r3, #0
 8000eaa:	d102      	bne.n	8000eb2 <chSchDoReschedule+0x12>
    /* The thread consumed its time quantum so it is enqueued behind threads
       with same priority level, however, it acquires a new time quantum.*/
    chSchDoRescheduleBehind();
 8000eac:	f7ff ffa0 	bl	8000df0 <chSchDoRescheduleBehind>
 8000eb0:	e001      	b.n	8000eb6 <chSchDoReschedule+0x16>
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 8000eb2:	f7ff ffbd 	bl	8000e30 <chSchDoRescheduleAhead>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 8000eb6:	bd08      	pop	{r3, pc}
 8000eb8:	20001bc8 	.word	0x20001bc8
 8000ebc:	f3af 8000 	nop.w

08000ec0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8000ec0:	b082      	sub	sp, #8
 8000ec2:	2320      	movs	r3, #32
 8000ec4:	9301      	str	r3, [sp, #4]
 8000ec6:	9b01      	ldr	r3, [sp, #4]
 8000ec8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000ecc:	b002      	add	sp, #8
 8000ece:	4770      	bx	lr

08000ed0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8000ed0:	b082      	sub	sp, #8
 8000ed2:	2300      	movs	r3, #0
 8000ed4:	9301      	str	r3, [sp, #4]
 8000ed6:	9b01      	ldr	r3, [sp, #4]
 8000ed8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8000edc:	b002      	add	sp, #8
 8000ede:	4770      	bx	lr

08000ee0 <list_init>:
 *
 * @param[in] tlp       pointer to the threads list object
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {
 8000ee0:	b082      	sub	sp, #8
 8000ee2:	9001      	str	r0, [sp, #4]

  tlp->p_next = (thread_t *)tlp;
 8000ee4:	9b01      	ldr	r3, [sp, #4]
 8000ee6:	9a01      	ldr	r2, [sp, #4]
 8000ee8:	601a      	str	r2, [r3, #0]
}
 8000eea:	b002      	add	sp, #8
 8000eec:	4770      	bx	lr
 8000eee:	bf00      	nop

08000ef0 <list_notempty>:
 * @param[in] tlp       pointer to the threads list object
 * @return              The status of the list.
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {
 8000ef0:	b082      	sub	sp, #8
 8000ef2:	9001      	str	r0, [sp, #4]

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8000ef4:	9b01      	ldr	r3, [sp, #4]
 8000ef6:	681a      	ldr	r2, [r3, #0]
 8000ef8:	9b01      	ldr	r3, [sp, #4]
 8000efa:	429a      	cmp	r2, r3
 8000efc:	bf0c      	ite	eq
 8000efe:	2300      	moveq	r3, #0
 8000f00:	2301      	movne	r3, #1
 8000f02:	b2db      	uxtb	r3, r3
}
 8000f04:	4618      	mov	r0, r3
 8000f06:	b002      	add	sp, #8
 8000f08:	4770      	bx	lr
 8000f0a:	bf00      	nop
 8000f0c:	f3af 8000 	nop.w

08000f10 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8000f10:	b082      	sub	sp, #8
 8000f12:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8000f14:	9b01      	ldr	r3, [sp, #4]
 8000f16:	9a01      	ldr	r2, [sp, #4]
 8000f18:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8000f1a:	9b01      	ldr	r3, [sp, #4]
 8000f1c:	9a01      	ldr	r2, [sp, #4]
 8000f1e:	605a      	str	r2, [r3, #4]
}
 8000f20:	b002      	add	sp, #8
 8000f22:	4770      	bx	lr
 8000f24:	f3af 8000 	nop.w
 8000f28:	f3af 8000 	nop.w
 8000f2c:	f3af 8000 	nop.w

08000f30 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8000f30:	b082      	sub	sp, #8
 8000f32:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000f34:	9b01      	ldr	r3, [sp, #4]
 8000f36:	681a      	ldr	r2, [r3, #0]
 8000f38:	9b01      	ldr	r3, [sp, #4]
 8000f3a:	429a      	cmp	r2, r3
 8000f3c:	bf0c      	ite	eq
 8000f3e:	2300      	moveq	r3, #0
 8000f40:	2301      	movne	r3, #1
 8000f42:	b2db      	uxtb	r3, r3
}
 8000f44:	4618      	mov	r0, r3
 8000f46:	b002      	add	sp, #8
 8000f48:	4770      	bx	lr
 8000f4a:	bf00      	nop
 8000f4c:	f3af 8000 	nop.w

08000f50 <list_insert>:

/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {
 8000f50:	b082      	sub	sp, #8
 8000f52:	9001      	str	r0, [sp, #4]
 8000f54:	9100      	str	r1, [sp, #0]

  tp->p_next = tlp->p_next;
 8000f56:	9b00      	ldr	r3, [sp, #0]
 8000f58:	681a      	ldr	r2, [r3, #0]
 8000f5a:	9b01      	ldr	r3, [sp, #4]
 8000f5c:	601a      	str	r2, [r3, #0]
  tlp->p_next = tp;
 8000f5e:	9b00      	ldr	r3, [sp, #0]
 8000f60:	9a01      	ldr	r2, [sp, #4]
 8000f62:	601a      	str	r2, [r3, #0]
}
 8000f64:	b002      	add	sp, #8
 8000f66:	4770      	bx	lr
 8000f68:	f3af 8000 	nop.w
 8000f6c:	f3af 8000 	nop.w

08000f70 <list_remove>:

static inline thread_t *list_remove(threads_list_t *tlp) {
 8000f70:	b084      	sub	sp, #16
 8000f72:	9001      	str	r0, [sp, #4]

  thread_t *tp = tlp->p_next;
 8000f74:	9b01      	ldr	r3, [sp, #4]
 8000f76:	681b      	ldr	r3, [r3, #0]
 8000f78:	9303      	str	r3, [sp, #12]
  tlp->p_next = tp->p_next;
 8000f7a:	9b03      	ldr	r3, [sp, #12]
 8000f7c:	681a      	ldr	r2, [r3, #0]
 8000f7e:	9b01      	ldr	r3, [sp, #4]
 8000f80:	601a      	str	r2, [r3, #0]

  return tp;
 8000f82:	9b03      	ldr	r3, [sp, #12]
}
 8000f84:	4618      	mov	r0, r3
 8000f86:	b004      	add	sp, #16
 8000f88:	4770      	bx	lr
 8000f8a:	bf00      	nop
 8000f8c:	f3af 8000 	nop.w

08000f90 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8000f90:	b082      	sub	sp, #8
 8000f92:	9001      	str	r0, [sp, #4]
 8000f94:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8000f96:	9b01      	ldr	r3, [sp, #4]
 8000f98:	9a00      	ldr	r2, [sp, #0]
 8000f9a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000f9c:	9b00      	ldr	r3, [sp, #0]
 8000f9e:	685a      	ldr	r2, [r3, #4]
 8000fa0:	9b01      	ldr	r3, [sp, #4]
 8000fa2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000fa4:	9b01      	ldr	r3, [sp, #4]
 8000fa6:	685b      	ldr	r3, [r3, #4]
 8000fa8:	9a01      	ldr	r2, [sp, #4]
 8000faa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8000fac:	9b00      	ldr	r3, [sp, #0]
 8000fae:	9a01      	ldr	r2, [sp, #4]
 8000fb0:	605a      	str	r2, [r3, #4]
}
 8000fb2:	b002      	add	sp, #8
 8000fb4:	4770      	bx	lr
 8000fb6:	bf00      	nop
 8000fb8:	f3af 8000 	nop.w
 8000fbc:	f3af 8000 	nop.w

08000fc0 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8000fc0:	b084      	sub	sp, #16
 8000fc2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8000fc4:	9b01      	ldr	r3, [sp, #4]
 8000fc6:	681b      	ldr	r3, [r3, #0]
 8000fc8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8000fca:	9b03      	ldr	r3, [sp, #12]
 8000fcc:	681a      	ldr	r2, [r3, #0]
 8000fce:	9b01      	ldr	r3, [sp, #4]
 8000fd0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fd2:	9b01      	ldr	r3, [sp, #4]
 8000fd4:	681b      	ldr	r3, [r3, #0]
 8000fd6:	9a01      	ldr	r2, [sp, #4]
 8000fd8:	605a      	str	r2, [r3, #4]

  return tp;
 8000fda:	9b03      	ldr	r3, [sp, #12]
}
 8000fdc:	4618      	mov	r0, r3
 8000fde:	b004      	add	sp, #16
 8000fe0:	4770      	bx	lr
 8000fe2:	bf00      	nop
 8000fe4:	f3af 8000 	nop.w
 8000fe8:	f3af 8000 	nop.w
 8000fec:	f3af 8000 	nop.w

08000ff0 <chSchCanYieldS>:
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.r_queue) >= currp->p_prio;
 8000ff0:	4b06      	ldr	r3, [pc, #24]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff2:	681b      	ldr	r3, [r3, #0]
 8000ff4:	689a      	ldr	r2, [r3, #8]
 8000ff6:	4b05      	ldr	r3, [pc, #20]	; (800100c <chSchCanYieldS+0x1c>)
 8000ff8:	699b      	ldr	r3, [r3, #24]
 8000ffa:	689b      	ldr	r3, [r3, #8]
 8000ffc:	429a      	cmp	r2, r3
 8000ffe:	bf34      	ite	cc
 8001000:	2300      	movcc	r3, #0
 8001002:	2301      	movcs	r3, #1
 8001004:	b2db      	uxtb	r3, r3
}
 8001006:	4618      	mov	r0, r3
 8001008:	4770      	bx	lr
 800100a:	bf00      	nop
 800100c:	20001bc8 	.word	0x20001bc8

08001010 <chSchDoYieldS>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal or higher priority, if any.
 *
 * @sclass
 */
static inline void chSchDoYieldS(void) {
 8001010:	b508      	push	{r3, lr}

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 8001012:	f7ff ffed 	bl	8000ff0 <chSchCanYieldS>
 8001016:	4603      	mov	r3, r0
 8001018:	2b00      	cmp	r3, #0
 800101a:	d001      	beq.n	8001020 <chSchDoYieldS+0x10>
    chSchDoRescheduleBehind();
 800101c:	f7ff fee8 	bl	8000df0 <chSchDoRescheduleBehind>
  }
}
 8001020:	bd08      	pop	{r3, pc}
 8001022:	bf00      	nop
 8001024:	f3af 8000 	nop.w
 8001028:	f3af 8000 	nop.w
 800102c:	f3af 8000 	nop.w

08001030 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001030:	b508      	push	{r3, lr}

  port_lock();
 8001032:	f7ff ff45 	bl	8000ec0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001036:	bd08      	pop	{r3, pc}
 8001038:	f3af 8000 	nop.w
 800103c:	f3af 8000 	nop.w

08001040 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001040:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001042:	f7ff ff45 	bl	8000ed0 <port_unlock>
}
 8001046:	bd08      	pop	{r3, pc}
 8001048:	f3af 8000 	nop.w
 800104c:	f3af 8000 	nop.w

08001050 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8001050:	4b01      	ldr	r3, [pc, #4]	; (8001058 <chVTGetSystemTimeX+0x8>)
 8001052:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8001054:	4618      	mov	r0, r3
 8001056:	4770      	bx	lr
 8001058:	20001bc8 	.word	0x20001bc8
 800105c:	f3af 8000 	nop.w

08001060 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 8001060:	b084      	sub	sp, #16
 8001062:	9003      	str	r0, [sp, #12]
 8001064:	9102      	str	r1, [sp, #8]
 8001066:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8001068:	9a03      	ldr	r2, [sp, #12]
 800106a:	9b02      	ldr	r3, [sp, #8]
 800106c:	1ad2      	subs	r2, r2, r3
 800106e:	9901      	ldr	r1, [sp, #4]
 8001070:	9b02      	ldr	r3, [sp, #8]
 8001072:	1acb      	subs	r3, r1, r3
 8001074:	429a      	cmp	r2, r3
 8001076:	bf2c      	ite	cs
 8001078:	2300      	movcs	r3, #0
 800107a:	2301      	movcc	r3, #1
 800107c:	b2db      	uxtb	r3, r3
}
 800107e:	4618      	mov	r0, r3
 8001080:	b004      	add	sp, #16
 8001082:	4770      	bx	lr
 8001084:	f3af 8000 	nop.w
 8001088:	f3af 8000 	nop.w
 800108c:	f3af 8000 	nop.w

08001090 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8001090:	4b01      	ldr	r3, [pc, #4]	; (8001098 <chThdGetSelfX+0x8>)
 8001092:	699b      	ldr	r3, [r3, #24]
}
 8001094:	4618      	mov	r0, r3
 8001096:	4770      	bx	lr
 8001098:	20001bc8 	.word	0x20001bc8
 800109c:	f3af 8000 	nop.w

080010a0 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 80010a0:	b500      	push	{lr}
 80010a2:	b083      	sub	sp, #12
 80010a4:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 80010a6:	9801      	ldr	r0, [sp, #4]
 80010a8:	f7ff fd7a 	bl	8000ba0 <chSchReadyI>
 80010ac:	4603      	mov	r3, r0
}
 80010ae:	4618      	mov	r0, r3
 80010b0:	b003      	add	sp, #12
 80010b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80010b6:	bf00      	nop
 80010b8:	f3af 8000 	nop.w
 80010bc:	f3af 8000 	nop.w

080010c0 <chThdSleepS>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @sclass
 */
static inline void chThdSleepS(systime_t time) {
 80010c0:	b500      	push	{lr}
 80010c2:	b083      	sub	sp, #12
 80010c4:	9001      	str	r0, [sp, #4]

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80010c6:	2008      	movs	r0, #8
 80010c8:	9901      	ldr	r1, [sp, #4]
 80010ca:	f7ff fdf9 	bl	8000cc0 <chSchGoSleepTimeoutS>
}
 80010ce:	b003      	add	sp, #12
 80010d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80010d4:	f3af 8000 	nop.w
 80010d8:	f3af 8000 	nop.w
 80010dc:	f3af 8000 	nop.w

080010e0 <chThdDoDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void chThdDoDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 80010e0:	b500      	push	{lr}
 80010e2:	b085      	sub	sp, #20
 80010e4:	9001      	str	r0, [sp, #4]
 80010e6:	9100      	str	r1, [sp, #0]
  thread_t *tp;

  chDbgAssert(queue_notempty(tqp), "empty queue");

  tp = queue_fifo_remove(tqp);
 80010e8:	9801      	ldr	r0, [sp, #4]
 80010ea:	f7ff ff69 	bl	8000fc0 <queue_fifo_remove>
 80010ee:	9003      	str	r0, [sp, #12]

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80010f0:	9b03      	ldr	r3, [sp, #12]
 80010f2:	9a00      	ldr	r2, [sp, #0]
 80010f4:	621a      	str	r2, [r3, #32]
  (void) chSchReadyI(tp);
 80010f6:	9803      	ldr	r0, [sp, #12]
 80010f8:	f7ff fd52 	bl	8000ba0 <chSchReadyI>
}
 80010fc:	b005      	add	sp, #20
 80010fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001102:	bf00      	nop
 8001104:	f3af 8000 	nop.w
 8001108:	f3af 8000 	nop.w
 800110c:	f3af 8000 	nop.w

08001110 <_thread_init>:
 * @param[in] prio      the priority level for the new thread
 * @return              The same thread pointer passed as parameter.
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {
 8001110:	b500      	push	{lr}
 8001112:	b083      	sub	sp, #12
 8001114:	9001      	str	r0, [sp, #4]
 8001116:	9100      	str	r1, [sp, #0]

  tp->p_prio = prio;
 8001118:	9b01      	ldr	r3, [sp, #4]
 800111a:	9a00      	ldr	r2, [sp, #0]
 800111c:	609a      	str	r2, [r3, #8]
  tp->p_state = CH_STATE_WTSTART;
 800111e:	9b01      	ldr	r3, [sp, #4]
 8001120:	2202      	movs	r2, #2
 8001122:	771a      	strb	r2, [r3, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8001124:	9b01      	ldr	r3, [sp, #4]
 8001126:	2200      	movs	r2, #0
 8001128:	775a      	strb	r2, [r3, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800112a:	9b01      	ldr	r3, [sp, #4]
 800112c:	220a      	movs	r2, #10
 800112e:	77da      	strb	r2, [r3, #31]
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8001130:	9b01      	ldr	r3, [sp, #4]
 8001132:	9a00      	ldr	r2, [sp, #0]
 8001134:	63da      	str	r2, [r3, #60]	; 0x3c
  tp->p_mtxlist = NULL;
 8001136:	9b01      	ldr	r3, [sp, #4]
 8001138:	2200      	movs	r2, #0
 800113a:	639a      	str	r2, [r3, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 800113c:	9b01      	ldr	r3, [sp, #4]
 800113e:	2200      	movs	r2, #0
 8001140:	635a      	str	r2, [r3, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8001142:	9b01      	ldr	r3, [sp, #4]
 8001144:	2201      	movs	r2, #1
 8001146:	779a      	strb	r2, [r3, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8001148:	9b01      	ldr	r3, [sp, #4]
 800114a:	2200      	movs	r2, #0
 800114c:	619a      	str	r2, [r3, #24]
  REG_INSERT(tp);
 800114e:	9b01      	ldr	r3, [sp, #4]
 8001150:	4a0d      	ldr	r2, [pc, #52]	; (8001188 <_thread_init+0x78>)
 8001152:	611a      	str	r2, [r3, #16]
 8001154:	4b0c      	ldr	r3, [pc, #48]	; (8001188 <_thread_init+0x78>)
 8001156:	695a      	ldr	r2, [r3, #20]
 8001158:	9b01      	ldr	r3, [sp, #4]
 800115a:	615a      	str	r2, [r3, #20]
 800115c:	9b01      	ldr	r3, [sp, #4]
 800115e:	695b      	ldr	r3, [r3, #20]
 8001160:	9a01      	ldr	r2, [sp, #4]
 8001162:	611a      	str	r2, [r3, #16]
 8001164:	4b08      	ldr	r3, [pc, #32]	; (8001188 <_thread_init+0x78>)
 8001166:	9a01      	ldr	r2, [sp, #4]
 8001168:	615a      	str	r2, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 800116a:	9b01      	ldr	r3, [sp, #4]
 800116c:	3324      	adds	r3, #36	; 0x24
 800116e:	4618      	mov	r0, r3
 8001170:	f7ff feb6 	bl	8000ee0 <list_init>
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8001174:	9b01      	ldr	r3, [sp, #4]
 8001176:	3328      	adds	r3, #40	; 0x28
 8001178:	4618      	mov	r0, r3
 800117a:	f7ff fec9 	bl	8000f10 <queue_init>
  chTMObjectInit(&tp->p_stats);
#endif
#if defined(CH_CFG_THREAD_INIT_HOOK)
  CH_CFG_THREAD_INIT_HOOK(tp);
#endif
  return tp;
 800117e:	9b01      	ldr	r3, [sp, #4]
}
 8001180:	4618      	mov	r0, r3
 8001182:	b003      	add	sp, #12
 8001184:	f85d fb04 	ldr.w	pc, [sp], #4
 8001188:	20001bc8 	.word	0x20001bc8
 800118c:	f3af 8000 	nop.w

08001190 <chThdCreateI>:
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateI(void *wsp, size_t size,
                       tprio_t prio, tfunc_t pf, void *arg) {
 8001190:	b500      	push	{lr}
 8001192:	b087      	sub	sp, #28
 8001194:	9003      	str	r0, [sp, #12]
 8001196:	9102      	str	r1, [sp, #8]
 8001198:	9201      	str	r2, [sp, #4]
 800119a:	9300      	str	r3, [sp, #0]
  /* The thread structure is laid out in the lower part of the thread
     workspace.*/
  thread_t *tp = wsp;
 800119c:	9b03      	ldr	r3, [sp, #12]
 800119e:	9305      	str	r3, [sp, #20]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 80011a0:	9b02      	ldr	r3, [sp, #8]
 80011a2:	3b24      	subs	r3, #36	; 0x24
 80011a4:	9a03      	ldr	r2, [sp, #12]
 80011a6:	441a      	add	r2, r3
 80011a8:	9b05      	ldr	r3, [sp, #20]
 80011aa:	60da      	str	r2, [r3, #12]
 80011ac:	9b05      	ldr	r3, [sp, #20]
 80011ae:	68db      	ldr	r3, [r3, #12]
 80011b0:	9a00      	ldr	r2, [sp, #0]
 80011b2:	601a      	str	r2, [r3, #0]
 80011b4:	9b05      	ldr	r3, [sp, #20]
 80011b6:	68db      	ldr	r3, [r3, #12]
 80011b8:	9a08      	ldr	r2, [sp, #32]
 80011ba:	605a      	str	r2, [r3, #4]
 80011bc:	9b05      	ldr	r3, [sp, #20]
 80011be:	68db      	ldr	r3, [r3, #12]
 80011c0:	4a05      	ldr	r2, [pc, #20]	; (80011d8 <chThdCreateI+0x48>)
 80011c2:	621a      	str	r2, [r3, #32]

  return _thread_init(tp, prio);
 80011c4:	9805      	ldr	r0, [sp, #20]
 80011c6:	9901      	ldr	r1, [sp, #4]
 80011c8:	f7ff ffa2 	bl	8001110 <_thread_init>
 80011cc:	4603      	mov	r3, r0
}
 80011ce:	4618      	mov	r0, r3
 80011d0:	b007      	add	sp, #28
 80011d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80011d6:	bf00      	nop
 80011d8:	080002f1 	.word	0x080002f1
 80011dc:	f3af 8000 	nop.w

080011e0 <chThdCreateStatic>:
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
                            tprio_t prio, tfunc_t pf, void *arg) {
 80011e0:	b500      	push	{lr}
 80011e2:	b089      	sub	sp, #36	; 0x24
 80011e4:	9005      	str	r0, [sp, #20]
 80011e6:	9104      	str	r1, [sp, #16]
 80011e8:	9203      	str	r2, [sp, #12]
 80011ea:	9302      	str	r3, [sp, #8]
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80011ec:	f7ff ff20 	bl	8001030 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 80011f0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80011f2:	9300      	str	r3, [sp, #0]
 80011f4:	9805      	ldr	r0, [sp, #20]
 80011f6:	9904      	ldr	r1, [sp, #16]
 80011f8:	9a03      	ldr	r2, [sp, #12]
 80011fa:	9b02      	ldr	r3, [sp, #8]
 80011fc:	f7ff ffc8 	bl	8001190 <chThdCreateI>
 8001200:	9007      	str	r0, [sp, #28]
  chSchWakeupS(tp, MSG_OK);
 8001202:	9807      	ldr	r0, [sp, #28]
 8001204:	2100      	movs	r1, #0
 8001206:	f7ff fd93 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 800120a:	f7ff ff19 	bl	8001040 <chSysUnlock>

  return tp;
 800120e:	9b07      	ldr	r3, [sp, #28]
}
 8001210:	4618      	mov	r0, r3
 8001212:	b009      	add	sp, #36	; 0x24
 8001214:	f85d fb04 	ldr.w	pc, [sp], #4
 8001218:	f3af 8000 	nop.w
 800121c:	f3af 8000 	nop.w

08001220 <chThdStart>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdStart(thread_t *tp) {
 8001220:	b500      	push	{lr}
 8001222:	b083      	sub	sp, #12
 8001224:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001226:	f7ff ff03 	bl	8001030 <chSysLock>
  tp = chThdStartI(tp);
 800122a:	9801      	ldr	r0, [sp, #4]
 800122c:	f7ff ff38 	bl	80010a0 <chThdStartI>
 8001230:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 8001232:	f7ff ff05 	bl	8001040 <chSysUnlock>

  return tp;
 8001236:	9b01      	ldr	r3, [sp, #4]
}
 8001238:	4618      	mov	r0, r3
 800123a:	b003      	add	sp, #12
 800123c:	f85d fb04 	ldr.w	pc, [sp], #4

08001240 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 8001240:	b500      	push	{lr}
 8001242:	b085      	sub	sp, #20
 8001244:	9001      	str	r0, [sp, #4]
  tprio_t oldprio;

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
 8001246:	f7ff fef3 	bl	8001030 <chSysLock>
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->p_realprio;
 800124a:	4b11      	ldr	r3, [pc, #68]	; (8001290 <chThdSetPriority+0x50>)
 800124c:	699b      	ldr	r3, [r3, #24]
 800124e:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001250:	9303      	str	r3, [sp, #12]
  if ((currp->p_prio == currp->p_realprio) || (newprio > currp->p_prio)) {
 8001252:	4b0f      	ldr	r3, [pc, #60]	; (8001290 <chThdSetPriority+0x50>)
 8001254:	699b      	ldr	r3, [r3, #24]
 8001256:	689a      	ldr	r2, [r3, #8]
 8001258:	4b0d      	ldr	r3, [pc, #52]	; (8001290 <chThdSetPriority+0x50>)
 800125a:	699b      	ldr	r3, [r3, #24]
 800125c:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800125e:	429a      	cmp	r2, r3
 8001260:	d005      	beq.n	800126e <chThdSetPriority+0x2e>
 8001262:	4b0b      	ldr	r3, [pc, #44]	; (8001290 <chThdSetPriority+0x50>)
 8001264:	699b      	ldr	r3, [r3, #24]
 8001266:	689a      	ldr	r2, [r3, #8]
 8001268:	9b01      	ldr	r3, [sp, #4]
 800126a:	429a      	cmp	r2, r3
 800126c:	d203      	bcs.n	8001276 <chThdSetPriority+0x36>
    currp->p_prio = newprio;
 800126e:	4b08      	ldr	r3, [pc, #32]	; (8001290 <chThdSetPriority+0x50>)
 8001270:	699b      	ldr	r3, [r3, #24]
 8001272:	9a01      	ldr	r2, [sp, #4]
 8001274:	609a      	str	r2, [r3, #8]
  }
  currp->p_realprio = newprio;
 8001276:	4b06      	ldr	r3, [pc, #24]	; (8001290 <chThdSetPriority+0x50>)
 8001278:	699b      	ldr	r3, [r3, #24]
 800127a:	9a01      	ldr	r2, [sp, #4]
 800127c:	63da      	str	r2, [r3, #60]	; 0x3c
#else
  oldprio = currp->p_prio;
  currp->p_prio = newprio;
#endif
  chSchRescheduleS();
 800127e:	f7ff fd7f 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001282:	f7ff fedd 	bl	8001040 <chSysUnlock>

  return oldprio;
 8001286:	9b03      	ldr	r3, [sp, #12]
}
 8001288:	4618      	mov	r0, r3
 800128a:	b005      	add	sp, #20
 800128c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001290:	20001bc8 	.word	0x20001bc8
 8001294:	f3af 8000 	nop.w
 8001298:	f3af 8000 	nop.w
 800129c:	f3af 8000 	nop.w

080012a0 <chThdTerminate>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdTerminate(thread_t *tp) {
 80012a0:	b500      	push	{lr}
 80012a2:	b083      	sub	sp, #12
 80012a4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012a6:	f7ff fec3 	bl	8001030 <chSysLock>
  tp->p_flags |= CH_FLAG_TERMINATE;
 80012aa:	9b01      	ldr	r3, [sp, #4]
 80012ac:	7f5b      	ldrb	r3, [r3, #29]
 80012ae:	f043 0304 	orr.w	r3, r3, #4
 80012b2:	b2da      	uxtb	r2, r3
 80012b4:	9b01      	ldr	r3, [sp, #4]
 80012b6:	775a      	strb	r2, [r3, #29]
  chSysUnlock();
 80012b8:	f7ff fec2 	bl	8001040 <chSysUnlock>
}
 80012bc:	b003      	add	sp, #12
 80012be:	f85d fb04 	ldr.w	pc, [sp], #4
 80012c2:	bf00      	nop
 80012c4:	f3af 8000 	nop.w
 80012c8:	f3af 8000 	nop.w
 80012cc:	f3af 8000 	nop.w

080012d0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80012d0:	b500      	push	{lr}
 80012d2:	b083      	sub	sp, #12
 80012d4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012d6:	f7ff feab 	bl	8001030 <chSysLock>
  chThdSleepS(time);
 80012da:	9801      	ldr	r0, [sp, #4]
 80012dc:	f7ff fef0 	bl	80010c0 <chThdSleepS>
  chSysUnlock();
 80012e0:	f7ff feae 	bl	8001040 <chSysUnlock>
}
 80012e4:	b003      	add	sp, #12
 80012e6:	f85d fb04 	ldr.w	pc, [sp], #4
 80012ea:	bf00      	nop
 80012ec:	f3af 8000 	nop.w

080012f0 <chThdSleepUntil>:
 *
 * @param[in] time      absolute system time
 *
 * @api
 */
void chThdSleepUntil(systime_t time) {
 80012f0:	b500      	push	{lr}
 80012f2:	b083      	sub	sp, #12
 80012f4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80012f6:	f7ff fe9b 	bl	8001030 <chSysLock>
  time -= chVTGetSystemTimeX();
 80012fa:	f7ff fea9 	bl	8001050 <chVTGetSystemTimeX>
 80012fe:	4603      	mov	r3, r0
 8001300:	9a01      	ldr	r2, [sp, #4]
 8001302:	1ad3      	subs	r3, r2, r3
 8001304:	9301      	str	r3, [sp, #4]
  if (time > (systime_t)0) {
 8001306:	9b01      	ldr	r3, [sp, #4]
 8001308:	2b00      	cmp	r3, #0
 800130a:	d002      	beq.n	8001312 <chThdSleepUntil+0x22>
    chThdSleepS(time);
 800130c:	9801      	ldr	r0, [sp, #4]
 800130e:	f7ff fed7 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 8001312:	f7ff fe95 	bl	8001040 <chSysUnlock>
}
 8001316:	b003      	add	sp, #12
 8001318:	f85d fb04 	ldr.w	pc, [sp], #4
 800131c:	f3af 8000 	nop.w

08001320 <chThdSleepUntilWindowed>:
 * @param[in] next      absolute system time of the next deadline
 * @return				the @p next parameter
 *
 * @api
 */
systime_t chThdSleepUntilWindowed(systime_t prev, systime_t next) {
 8001320:	b500      	push	{lr}
 8001322:	b085      	sub	sp, #20
 8001324:	9001      	str	r0, [sp, #4]
 8001326:	9100      	str	r1, [sp, #0]
  systime_t time;

  chSysLock();
 8001328:	f7ff fe82 	bl	8001030 <chSysLock>
  time = chVTGetSystemTimeX();
 800132c:	f7ff fe90 	bl	8001050 <chVTGetSystemTimeX>
 8001330:	9003      	str	r0, [sp, #12]
  if (chVTIsTimeWithinX(time, prev, next)) {
 8001332:	9803      	ldr	r0, [sp, #12]
 8001334:	9901      	ldr	r1, [sp, #4]
 8001336:	9a00      	ldr	r2, [sp, #0]
 8001338:	f7ff fe92 	bl	8001060 <chVTIsTimeWithinX>
 800133c:	4603      	mov	r3, r0
 800133e:	2b00      	cmp	r3, #0
 8001340:	d005      	beq.n	800134e <chThdSleepUntilWindowed+0x2e>
	chThdSleepS(next - time);
 8001342:	9a00      	ldr	r2, [sp, #0]
 8001344:	9b03      	ldr	r3, [sp, #12]
 8001346:	1ad3      	subs	r3, r2, r3
 8001348:	4618      	mov	r0, r3
 800134a:	f7ff feb9 	bl	80010c0 <chThdSleepS>
  }
  chSysUnlock();
 800134e:	f7ff fe77 	bl	8001040 <chSysUnlock>

  return next;
 8001352:	9b00      	ldr	r3, [sp, #0]
}
 8001354:	4618      	mov	r0, r3
 8001356:	b005      	add	sp, #20
 8001358:	f85d fb04 	ldr.w	pc, [sp], #4
 800135c:	f3af 8000 	nop.w

08001360 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 8001360:	b508      	push	{r3, lr}

  chSysLock();
 8001362:	f7ff fe65 	bl	8001030 <chSysLock>
  chSchDoYieldS();
 8001366:	f7ff fe53 	bl	8001010 <chSchDoYieldS>
  chSysUnlock();
 800136a:	f7ff fe69 	bl	8001040 <chSysUnlock>
}
 800136e:	bd08      	pop	{r3, pc}

08001370 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 8001370:	b500      	push	{lr}
 8001372:	b083      	sub	sp, #12
 8001374:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001376:	f7ff fe5b 	bl	8001030 <chSysLock>
  chThdExitS(msg);
 800137a:	9801      	ldr	r0, [sp, #4]
 800137c:	f000 f808 	bl	8001390 <chThdExitS>
  /* The thread never returns here.*/
}
 8001380:	b003      	add	sp, #12
 8001382:	f85d fb04 	ldr.w	pc, [sp], #4
 8001386:	bf00      	nop
 8001388:	f3af 8000 	nop.w
 800138c:	f3af 8000 	nop.w

08001390 <chThdExitS>:
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001390:	b500      	push	{lr}
 8001392:	b085      	sub	sp, #20
 8001394:	9001      	str	r0, [sp, #4]
  thread_t *tp = currp;
 8001396:	4b17      	ldr	r3, [pc, #92]	; (80013f4 <chThdExitS+0x64>)
 8001398:	699b      	ldr	r3, [r3, #24]
 800139a:	9303      	str	r3, [sp, #12]

  tp->p_u.exitcode = msg;
 800139c:	9b03      	ldr	r3, [sp, #12]
 800139e:	9a01      	ldr	r2, [sp, #4]
 80013a0:	621a      	str	r2, [r3, #32]
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013a2:	e008      	b.n	80013b6 <chThdExitS+0x26>
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 80013a4:	9b03      	ldr	r3, [sp, #12]
 80013a6:	3324      	adds	r3, #36	; 0x24
 80013a8:	4618      	mov	r0, r3
 80013aa:	f7ff fde1 	bl	8000f70 <list_remove>
 80013ae:	4603      	mov	r3, r0
 80013b0:	4618      	mov	r0, r3
 80013b2:	f7ff fbf5 	bl	8000ba0 <chSchReadyI>
  tp->p_u.exitcode = msg;
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 80013b6:	9b03      	ldr	r3, [sp, #12]
 80013b8:	3324      	adds	r3, #36	; 0x24
 80013ba:	4618      	mov	r0, r3
 80013bc:	f7ff fd98 	bl	8000ef0 <list_notempty>
 80013c0:	4603      	mov	r3, r0
 80013c2:	2b00      	cmp	r3, #0
 80013c4:	d1ee      	bne.n	80013a4 <chThdExitS+0x14>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 80013c6:	9b03      	ldr	r3, [sp, #12]
 80013c8:	7f5b      	ldrb	r3, [r3, #29]
 80013ca:	f003 0303 	and.w	r3, r3, #3
 80013ce:	2b00      	cmp	r3, #0
 80013d0:	d109      	bne.n	80013e6 <chThdExitS+0x56>
    REG_REMOVE(tp);
 80013d2:	9b03      	ldr	r3, [sp, #12]
 80013d4:	695b      	ldr	r3, [r3, #20]
 80013d6:	9a03      	ldr	r2, [sp, #12]
 80013d8:	6912      	ldr	r2, [r2, #16]
 80013da:	611a      	str	r2, [r3, #16]
 80013dc:	9b03      	ldr	r3, [sp, #12]
 80013de:	691b      	ldr	r3, [r3, #16]
 80013e0:	9a03      	ldr	r2, [sp, #12]
 80013e2:	6952      	ldr	r2, [r2, #20]
 80013e4:	615a      	str	r2, [r3, #20]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 80013e6:	200f      	movs	r0, #15
 80013e8:	f7ff fc02 	bl	8000bf0 <chSchGoSleepS>

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 80013ec:	b005      	add	sp, #20
 80013ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80013f2:	bf00      	nop
 80013f4:	20001bc8 	.word	0x20001bc8
 80013f8:	f3af 8000 	nop.w
 80013fc:	f3af 8000 	nop.w

08001400 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8001400:	b500      	push	{lr}
 8001402:	b085      	sub	sp, #20
 8001404:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chDbgCheck(tp != NULL);

  chSysLock();
 8001406:	f7ff fe13 	bl	8001030 <chSysLock>
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_DYNAMIC == TRUE
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
#endif
  if (tp->p_state != CH_STATE_FINAL) {
 800140a:	9b01      	ldr	r3, [sp, #4]
 800140c:	7f1b      	ldrb	r3, [r3, #28]
 800140e:	2b0f      	cmp	r3, #15
 8001410:	d00a      	beq.n	8001428 <chThdWait+0x28>
    list_insert(currp, &tp->p_waiting);
 8001412:	4b0c      	ldr	r3, [pc, #48]	; (8001444 <chThdWait+0x44>)
 8001414:	699a      	ldr	r2, [r3, #24]
 8001416:	9b01      	ldr	r3, [sp, #4]
 8001418:	3324      	adds	r3, #36	; 0x24
 800141a:	4610      	mov	r0, r2
 800141c:	4619      	mov	r1, r3
 800141e:	f7ff fd97 	bl	8000f50 <list_insert>
    chSchGoSleepS(CH_STATE_WTEXIT);
 8001422:	2009      	movs	r0, #9
 8001424:	f7ff fbe4 	bl	8000bf0 <chSchGoSleepS>
  }
  msg = tp->p_u.exitcode;
 8001428:	9b01      	ldr	r3, [sp, #4]
 800142a:	6a1b      	ldr	r3, [r3, #32]
 800142c:	9303      	str	r3, [sp, #12]
  chSysUnlock();
 800142e:	f7ff fe07 	bl	8001040 <chSysUnlock>

#if CH_CFG_USE_DYNAMIC == TRUE
  /* Releasing a lock if it is a dynamic thread.*/
  chThdRelease(tp);
 8001432:	9801      	ldr	r0, [sp, #4]
 8001434:	f000 f9c4 	bl	80017c0 <chThdRelease>
#endif

  return msg;
 8001438:	9b03      	ldr	r3, [sp, #12]
}
 800143a:	4618      	mov	r0, r3
 800143c:	b005      	add	sp, #20
 800143e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001442:	bf00      	nop
 8001444:	20001bc8 	.word	0x20001bc8
 8001448:	f3af 8000 	nop.w
 800144c:	f3af 8000 	nop.w

08001450 <chThdSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendS(thread_reference_t *trp) {
 8001450:	b500      	push	{lr}
 8001452:	b085      	sub	sp, #20
 8001454:	9001      	str	r0, [sp, #4]
  thread_t *tp = chThdGetSelfX();
 8001456:	f7ff fe1b 	bl	8001090 <chThdGetSelfX>
 800145a:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 800145c:	9b01      	ldr	r3, [sp, #4]
 800145e:	9a03      	ldr	r2, [sp, #12]
 8001460:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 8001462:	9b03      	ldr	r3, [sp, #12]
 8001464:	9a01      	ldr	r2, [sp, #4]
 8001466:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 8001468:	2003      	movs	r0, #3
 800146a:	f7ff fbc1 	bl	8000bf0 <chSchGoSleepS>

  return chThdGetSelfX()->p_u.rdymsg;
 800146e:	f7ff fe0f 	bl	8001090 <chThdGetSelfX>
 8001472:	4603      	mov	r3, r0
 8001474:	6a1b      	ldr	r3, [r3, #32]
}
 8001476:	4618      	mov	r0, r3
 8001478:	b005      	add	sp, #20
 800147a:	f85d fb04 	ldr.w	pc, [sp], #4
 800147e:	bf00      	nop

08001480 <chThdSuspendTimeoutS>:
 * @return              The wake up message.
 * @retval MSG_TIMEOUT  if the operation timed out.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
 8001480:	b500      	push	{lr}
 8001482:	b085      	sub	sp, #20
 8001484:	9001      	str	r0, [sp, #4]
 8001486:	9100      	str	r1, [sp, #0]
  thread_t *tp = chThdGetSelfX();
 8001488:	f7ff fe02 	bl	8001090 <chThdGetSelfX>
 800148c:	9003      	str	r0, [sp, #12]

  chDbgAssert(*trp == NULL, "not NULL");

  if (TIME_IMMEDIATE == timeout) {
 800148e:	9b00      	ldr	r3, [sp, #0]
 8001490:	2b00      	cmp	r3, #0
 8001492:	d102      	bne.n	800149a <chThdSuspendTimeoutS+0x1a>
    return MSG_TIMEOUT;
 8001494:	f04f 33ff 	mov.w	r3, #4294967295
 8001498:	e00a      	b.n	80014b0 <chThdSuspendTimeoutS+0x30>
  }

  *trp = tp;
 800149a:	9b01      	ldr	r3, [sp, #4]
 800149c:	9a03      	ldr	r2, [sp, #12]
 800149e:	601a      	str	r2, [r3, #0]
  tp->p_u.wttrp = trp;
 80014a0:	9b03      	ldr	r3, [sp, #12]
 80014a2:	9a01      	ldr	r2, [sp, #4]
 80014a4:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80014a6:	2003      	movs	r0, #3
 80014a8:	9900      	ldr	r1, [sp, #0]
 80014aa:	f7ff fc09 	bl	8000cc0 <chSchGoSleepTimeoutS>
 80014ae:	4603      	mov	r3, r0
}
 80014b0:	4618      	mov	r0, r3
 80014b2:	b005      	add	sp, #20
 80014b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80014b8:	f3af 8000 	nop.w
 80014bc:	f3af 8000 	nop.w

080014c0 <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
 80014c0:	b500      	push	{lr}
 80014c2:	b085      	sub	sp, #20
 80014c4:	9001      	str	r0, [sp, #4]
 80014c6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014c8:	9b01      	ldr	r3, [sp, #4]
 80014ca:	681b      	ldr	r3, [r3, #0]
 80014cc:	2b00      	cmp	r3, #0
 80014ce:	d00b      	beq.n	80014e8 <chThdResumeI+0x28>
    thread_t *tp = *trp;
 80014d0:	9b01      	ldr	r3, [sp, #4]
 80014d2:	681b      	ldr	r3, [r3, #0]
 80014d4:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 80014d6:	9b01      	ldr	r3, [sp, #4]
 80014d8:	2200      	movs	r2, #0
 80014da:	601a      	str	r2, [r3, #0]
    tp->p_u.rdymsg = msg;
 80014dc:	9b03      	ldr	r3, [sp, #12]
 80014de:	9a00      	ldr	r2, [sp, #0]
 80014e0:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80014e2:	9803      	ldr	r0, [sp, #12]
 80014e4:	f7ff fb5c 	bl	8000ba0 <chSchReadyI>
  }
}
 80014e8:	b005      	add	sp, #20
 80014ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80014ee:	bf00      	nop

080014f0 <chThdResumeS>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeS(thread_reference_t *trp, msg_t msg) {
 80014f0:	b500      	push	{lr}
 80014f2:	b085      	sub	sp, #20
 80014f4:	9001      	str	r0, [sp, #4]
 80014f6:	9100      	str	r1, [sp, #0]

  if (*trp != NULL) {
 80014f8:	9b01      	ldr	r3, [sp, #4]
 80014fa:	681b      	ldr	r3, [r3, #0]
 80014fc:	2b00      	cmp	r3, #0
 80014fe:	d009      	beq.n	8001514 <chThdResumeS+0x24>
    thread_t *tp = *trp;
 8001500:	9b01      	ldr	r3, [sp, #4]
 8001502:	681b      	ldr	r3, [r3, #0]
 8001504:	9303      	str	r3, [sp, #12]

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001506:	9b01      	ldr	r3, [sp, #4]
 8001508:	2200      	movs	r2, #0
 800150a:	601a      	str	r2, [r3, #0]
    chSchWakeupS(tp, msg);
 800150c:	9803      	ldr	r0, [sp, #12]
 800150e:	9900      	ldr	r1, [sp, #0]
 8001510:	f7ff fc0e 	bl	8000d30 <chSchWakeupS>
  }
}
 8001514:	b005      	add	sp, #20
 8001516:	f85d fb04 	ldr.w	pc, [sp], #4
 800151a:	bf00      	nop
 800151c:	f3af 8000 	nop.w

08001520 <chThdResume>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @api
 */
void chThdResume(thread_reference_t *trp, msg_t msg) {
 8001520:	b500      	push	{lr}
 8001522:	b083      	sub	sp, #12
 8001524:	9001      	str	r0, [sp, #4]
 8001526:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001528:	f7ff fd82 	bl	8001030 <chSysLock>
  chThdResumeS(trp, msg);
 800152c:	9801      	ldr	r0, [sp, #4]
 800152e:	9900      	ldr	r1, [sp, #0]
 8001530:	f7ff ffde 	bl	80014f0 <chThdResumeS>
  chSysUnlock();
 8001534:	f7ff fd84 	bl	8001040 <chSysUnlock>
}
 8001538:	b003      	add	sp, #12
 800153a:	f85d fb04 	ldr.w	pc, [sp], #4
 800153e:	bf00      	nop

08001540 <chThdEnqueueTimeoutS>:
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8001540:	b500      	push	{lr}
 8001542:	b083      	sub	sp, #12
 8001544:	9001      	str	r0, [sp, #4]
 8001546:	9100      	str	r1, [sp, #0]

  if (TIME_IMMEDIATE == timeout) {
 8001548:	9b00      	ldr	r3, [sp, #0]
 800154a:	2b00      	cmp	r3, #0
 800154c:	d102      	bne.n	8001554 <chThdEnqueueTimeoutS+0x14>
    return MSG_TIMEOUT;
 800154e:	f04f 33ff 	mov.w	r3, #4294967295
 8001552:	e00a      	b.n	800156a <chThdEnqueueTimeoutS+0x2a>
  }

  queue_insert(currp, tqp);
 8001554:	4b07      	ldr	r3, [pc, #28]	; (8001574 <chThdEnqueueTimeoutS+0x34>)
 8001556:	699b      	ldr	r3, [r3, #24]
 8001558:	4618      	mov	r0, r3
 800155a:	9901      	ldr	r1, [sp, #4]
 800155c:	f7ff fd18 	bl	8000f90 <queue_insert>

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8001560:	2004      	movs	r0, #4
 8001562:	9900      	ldr	r1, [sp, #0]
 8001564:	f7ff fbac 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001568:	4603      	mov	r3, r0
}
 800156a:	4618      	mov	r0, r3
 800156c:	b003      	add	sp, #12
 800156e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001572:	bf00      	nop
 8001574:	20001bc8 	.word	0x20001bc8
 8001578:	f3af 8000 	nop.w
 800157c:	f3af 8000 	nop.w

08001580 <chThdDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8001580:	b500      	push	{lr}
 8001582:	b083      	sub	sp, #12
 8001584:	9001      	str	r0, [sp, #4]
 8001586:	9100      	str	r1, [sp, #0]

  if (queue_notempty(tqp)) {
 8001588:	9801      	ldr	r0, [sp, #4]
 800158a:	f7ff fcd1 	bl	8000f30 <queue_notempty>
 800158e:	4603      	mov	r3, r0
 8001590:	2b00      	cmp	r3, #0
 8001592:	d003      	beq.n	800159c <chThdDequeueNextI+0x1c>
    chThdDoDequeueNextI(tqp, msg);
 8001594:	9801      	ldr	r0, [sp, #4]
 8001596:	9900      	ldr	r1, [sp, #0]
 8001598:	f7ff fda2 	bl	80010e0 <chThdDoDequeueNextI>
  }
}
 800159c:	b003      	add	sp, #12
 800159e:	f85d fb04 	ldr.w	pc, [sp], #4
 80015a2:	bf00      	nop
 80015a4:	f3af 8000 	nop.w
 80015a8:	f3af 8000 	nop.w
 80015ac:	f3af 8000 	nop.w

080015b0 <chThdDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 80015b0:	b500      	push	{lr}
 80015b2:	b083      	sub	sp, #12
 80015b4:	9001      	str	r0, [sp, #4]
 80015b6:	9100      	str	r1, [sp, #0]

  while (queue_notempty(tqp)) {
 80015b8:	e003      	b.n	80015c2 <chThdDequeueAllI+0x12>
    chThdDoDequeueNextI(tqp, msg);
 80015ba:	9801      	ldr	r0, [sp, #4]
 80015bc:	9900      	ldr	r1, [sp, #0]
 80015be:	f7ff fd8f 	bl	80010e0 <chThdDoDequeueNextI>
 *
 * @iclass
 */
void chThdDequeueAllI(threads_queue_t *tqp, msg_t msg) {

  while (queue_notempty(tqp)) {
 80015c2:	9801      	ldr	r0, [sp, #4]
 80015c4:	f7ff fcb4 	bl	8000f30 <queue_notempty>
 80015c8:	4603      	mov	r3, r0
 80015ca:	2b00      	cmp	r3, #0
 80015cc:	d1f5      	bne.n	80015ba <chThdDequeueAllI+0xa>
    chThdDoDequeueNextI(tqp, msg);
  }
}
 80015ce:	b003      	add	sp, #12
 80015d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80015d4:	f3af 8000 	nop.w
 80015d8:	f3af 8000 	nop.w
 80015dc:	f3af 8000 	nop.w

080015e0 <port_rt_get_counter_value>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 80015e0:	4b01      	ldr	r3, [pc, #4]	; (80015e8 <port_rt_get_counter_value+0x8>)
 80015e2:	685b      	ldr	r3, [r3, #4]
}
 80015e4:	4618      	mov	r0, r3
 80015e6:	4770      	bx	lr
 80015e8:	e0001000 	.word	0xe0001000
 80015ec:	f3af 8000 	nop.w

080015f0 <tm_stop>:
/* Module local functions.                                                   */
/*===========================================================================*/

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {
 80015f0:	b084      	sub	sp, #16
 80015f2:	9003      	str	r0, [sp, #12]
 80015f4:	9102      	str	r1, [sp, #8]
 80015f6:	9201      	str	r2, [sp, #4]

  tmp->n++;
 80015f8:	9b03      	ldr	r3, [sp, #12]
 80015fa:	68db      	ldr	r3, [r3, #12]
 80015fc:	1c5a      	adds	r2, r3, #1
 80015fe:	9b03      	ldr	r3, [sp, #12]
 8001600:	60da      	str	r2, [r3, #12]
  tmp->last = (now - tmp->last) - offset;
 8001602:	9b03      	ldr	r3, [sp, #12]
 8001604:	689b      	ldr	r3, [r3, #8]
 8001606:	9a02      	ldr	r2, [sp, #8]
 8001608:	1ad2      	subs	r2, r2, r3
 800160a:	9b01      	ldr	r3, [sp, #4]
 800160c:	1ad2      	subs	r2, r2, r3
 800160e:	9b03      	ldr	r3, [sp, #12]
 8001610:	609a      	str	r2, [r3, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8001612:	9b03      	ldr	r3, [sp, #12]
 8001614:	e9d3 0104 	ldrd	r0, r1, [r3, #16]
 8001618:	9b03      	ldr	r3, [sp, #12]
 800161a:	689b      	ldr	r3, [r3, #8]
 800161c:	461a      	mov	r2, r3
 800161e:	f04f 0300 	mov.w	r3, #0
 8001622:	1812      	adds	r2, r2, r0
 8001624:	eb43 0301 	adc.w	r3, r3, r1
 8001628:	9903      	ldr	r1, [sp, #12]
 800162a:	e9c1 2304 	strd	r2, r3, [r1, #16]
  if (tmp->last > tmp->worst) {
 800162e:	9b03      	ldr	r3, [sp, #12]
 8001630:	689a      	ldr	r2, [r3, #8]
 8001632:	9b03      	ldr	r3, [sp, #12]
 8001634:	685b      	ldr	r3, [r3, #4]
 8001636:	429a      	cmp	r2, r3
 8001638:	d903      	bls.n	8001642 <tm_stop+0x52>
    tmp->worst = tmp->last;
 800163a:	9b03      	ldr	r3, [sp, #12]
 800163c:	689a      	ldr	r2, [r3, #8]
 800163e:	9b03      	ldr	r3, [sp, #12]
 8001640:	605a      	str	r2, [r3, #4]
  }
  if (tmp->last < tmp->best) {
 8001642:	9b03      	ldr	r3, [sp, #12]
 8001644:	689a      	ldr	r2, [r3, #8]
 8001646:	9b03      	ldr	r3, [sp, #12]
 8001648:	681b      	ldr	r3, [r3, #0]
 800164a:	429a      	cmp	r2, r3
 800164c:	d203      	bcs.n	8001656 <tm_stop+0x66>
    tmp->best = tmp->last;
 800164e:	9b03      	ldr	r3, [sp, #12]
 8001650:	689a      	ldr	r2, [r3, #8]
 8001652:	9b03      	ldr	r3, [sp, #12]
 8001654:	601a      	str	r2, [r3, #0]
  }
}
 8001656:	b004      	add	sp, #16
 8001658:	4770      	bx	lr
 800165a:	bf00      	nop
 800165c:	f3af 8000 	nop.w

08001660 <_tm_init>:
/**
 * @brief   Initializes the time measurement unit.
 *
 * @init
 */
void _tm_init(void) {
 8001660:	b500      	push	{lr}
 8001662:	b087      	sub	sp, #28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8001664:	4b0a      	ldr	r3, [pc, #40]	; (8001690 <_tm_init+0x30>)
 8001666:	2200      	movs	r2, #0
 8001668:	675a      	str	r2, [r3, #116]	; 0x74
  chTMObjectInit(&tm);
 800166a:	466b      	mov	r3, sp
 800166c:	4618      	mov	r0, r3
 800166e:	f000 f817 	bl	80016a0 <chTMObjectInit>
  chTMStartMeasurementX(&tm);
 8001672:	466b      	mov	r3, sp
 8001674:	4618      	mov	r0, r3
 8001676:	f000 f82b 	bl	80016d0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800167a:	466b      	mov	r3, sp
 800167c:	4618      	mov	r0, r3
 800167e:	f000 f837 	bl	80016f0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8001682:	9a02      	ldr	r2, [sp, #8]
 8001684:	4b02      	ldr	r3, [pc, #8]	; (8001690 <_tm_init+0x30>)
 8001686:	675a      	str	r2, [r3, #116]	; 0x74
}
 8001688:	b007      	add	sp, #28
 800168a:	f85d fb04 	ldr.w	pc, [sp], #4
 800168e:	bf00      	nop
 8001690:	20001bc8 	.word	0x20001bc8
 8001694:	f3af 8000 	nop.w
 8001698:	f3af 8000 	nop.w
 800169c:	f3af 8000 	nop.w

080016a0 <chTMObjectInit>:
 *
 * @param[out] tmp      pointer to a @p TimeMeasurement structure
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {
 80016a0:	b082      	sub	sp, #8
 80016a2:	9001      	str	r0, [sp, #4]

  tmp->best       = (rtcnt_t)-1;
 80016a4:	9b01      	ldr	r3, [sp, #4]
 80016a6:	f04f 32ff 	mov.w	r2, #4294967295
 80016aa:	601a      	str	r2, [r3, #0]
  tmp->worst      = (rtcnt_t)0;
 80016ac:	9b01      	ldr	r3, [sp, #4]
 80016ae:	2200      	movs	r2, #0
 80016b0:	605a      	str	r2, [r3, #4]
  tmp->last       = (rtcnt_t)0;
 80016b2:	9b01      	ldr	r3, [sp, #4]
 80016b4:	2200      	movs	r2, #0
 80016b6:	609a      	str	r2, [r3, #8]
  tmp->n          = (ucnt_t)0;
 80016b8:	9b01      	ldr	r3, [sp, #4]
 80016ba:	2200      	movs	r2, #0
 80016bc:	60da      	str	r2, [r3, #12]
  tmp->cumulative = (rttime_t)0;
 80016be:	9901      	ldr	r1, [sp, #4]
 80016c0:	f04f 0200 	mov.w	r2, #0
 80016c4:	f04f 0300 	mov.w	r3, #0
 80016c8:	e9c1 2304 	strd	r2, r3, [r1, #16]
}
 80016cc:	b002      	add	sp, #8
 80016ce:	4770      	bx	lr

080016d0 <chTMStartMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p TimeMeasurement structure
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {
 80016d0:	b500      	push	{lr}
 80016d2:	b083      	sub	sp, #12
 80016d4:	9001      	str	r0, [sp, #4]

  tmp->last = chSysGetRealtimeCounterX();
 80016d6:	f7ff ff83 	bl	80015e0 <port_rt_get_counter_value>
 80016da:	4602      	mov	r2, r0
 80016dc:	9b01      	ldr	r3, [sp, #4]
 80016de:	609a      	str	r2, [r3, #8]
}
 80016e0:	b003      	add	sp, #12
 80016e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80016e6:	bf00      	nop
 80016e8:	f3af 8000 	nop.w
 80016ec:	f3af 8000 	nop.w

080016f0 <chTMStopMeasurementX>:
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 80016f0:	b500      	push	{lr}
 80016f2:	b083      	sub	sp, #12
 80016f4:	9001      	str	r0, [sp, #4]

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 80016f6:	f7ff ff73 	bl	80015e0 <port_rt_get_counter_value>
 80016fa:	4602      	mov	r2, r0
 80016fc:	4b04      	ldr	r3, [pc, #16]	; (8001710 <chTMStopMeasurementX+0x20>)
 80016fe:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001700:	9801      	ldr	r0, [sp, #4]
 8001702:	4611      	mov	r1, r2
 8001704:	461a      	mov	r2, r3
 8001706:	f7ff ff73 	bl	80015f0 <tm_stop>
}
 800170a:	b003      	add	sp, #12
 800170c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001710:	20001bc8 	.word	0x20001bc8
 8001714:	f3af 8000 	nop.w
 8001718:	f3af 8000 	nop.w
 800171c:	f3af 8000 	nop.w

08001720 <chTMChainMeasurementToX>:
 *
 *
 * @xclass
 */
NOINLINE void chTMChainMeasurementToX(time_measurement_t *tmp1,
                                      time_measurement_t *tmp2) {
 8001720:	b500      	push	{lr}
 8001722:	b083      	sub	sp, #12
 8001724:	9001      	str	r0, [sp, #4]
 8001726:	9100      	str	r1, [sp, #0]

  /* Starts new measurement.*/
  tmp2->last = chSysGetRealtimeCounterX();
 8001728:	f7ff ff5a 	bl	80015e0 <port_rt_get_counter_value>
 800172c:	4602      	mov	r2, r0
 800172e:	9b00      	ldr	r3, [sp, #0]
 8001730:	609a      	str	r2, [r3, #8]

  /* Stops previous measurement using the same time stamp.*/
  tm_stop(tmp1, tmp2->last, (rtcnt_t)0);
 8001732:	9b00      	ldr	r3, [sp, #0]
 8001734:	689b      	ldr	r3, [r3, #8]
 8001736:	9801      	ldr	r0, [sp, #4]
 8001738:	4619      	mov	r1, r3
 800173a:	2200      	movs	r2, #0
 800173c:	f7ff ff58 	bl	80015f0 <tm_stop>
}
 8001740:	b003      	add	sp, #12
 8001742:	f85d fb04 	ldr.w	pc, [sp], #4
 8001746:	bf00      	nop
 8001748:	f3af 8000 	nop.w
 800174c:	f3af 8000 	nop.w

08001750 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001750:	b082      	sub	sp, #8
 8001752:	2320      	movs	r3, #32
 8001754:	9301      	str	r3, [sp, #4]
 8001756:	9b01      	ldr	r3, [sp, #4]
 8001758:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800175c:	b002      	add	sp, #8
 800175e:	4770      	bx	lr

08001760 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001760:	b082      	sub	sp, #8
 8001762:	2300      	movs	r3, #0
 8001764:	9301      	str	r3, [sp, #4]
 8001766:	9b01      	ldr	r3, [sp, #4]
 8001768:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800176c:	b002      	add	sp, #8
 800176e:	4770      	bx	lr

08001770 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001770:	b508      	push	{r3, lr}

  port_lock();
 8001772:	f7ff ffed 	bl	8001750 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001776:	bd08      	pop	{r3, pc}
 8001778:	f3af 8000 	nop.w
 800177c:	f3af 8000 	nop.w

08001780 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001780:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001782:	f7ff ffed 	bl	8001760 <port_unlock>
}
 8001786:	bd08      	pop	{r3, pc}
 8001788:	f3af 8000 	nop.w
 800178c:	f3af 8000 	nop.w

08001790 <chThdAddRef>:
 * @return              The same thread pointer passed as parameter
 *                      representing the new reference.
 *
 * @api
 */
thread_t *chThdAddRef(thread_t *tp) {
 8001790:	b500      	push	{lr}
 8001792:	b083      	sub	sp, #12
 8001794:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001796:	f7ff ffeb 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs < (trefs_t)255, "too many references");
  tp->p_refs++;
 800179a:	9b01      	ldr	r3, [sp, #4]
 800179c:	7f9b      	ldrb	r3, [r3, #30]
 800179e:	3301      	adds	r3, #1
 80017a0:	b2da      	uxtb	r2, r3
 80017a2:	9b01      	ldr	r3, [sp, #4]
 80017a4:	779a      	strb	r2, [r3, #30]
  chSysUnlock();
 80017a6:	f7ff ffeb 	bl	8001780 <chSysUnlock>

  return tp;
 80017aa:	9b01      	ldr	r3, [sp, #4]
}
 80017ac:	4618      	mov	r0, r3
 80017ae:	b003      	add	sp, #12
 80017b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80017b4:	f3af 8000 	nop.w
 80017b8:	f3af 8000 	nop.w
 80017bc:	f3af 8000 	nop.w

080017c0 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 80017c0:	b500      	push	{lr}
 80017c2:	b085      	sub	sp, #20
 80017c4:	9001      	str	r0, [sp, #4]
  trefs_t refs;

  chSysLock();
 80017c6:	f7ff ffd3 	bl	8001770 <chSysLock>
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 80017ca:	9b01      	ldr	r3, [sp, #4]
 80017cc:	7f9b      	ldrb	r3, [r3, #30]
 80017ce:	3b01      	subs	r3, #1
 80017d0:	b2da      	uxtb	r2, r3
 80017d2:	9b01      	ldr	r3, [sp, #4]
 80017d4:	779a      	strb	r2, [r3, #30]
  refs = tp->p_refs;
 80017d6:	9b01      	ldr	r3, [sp, #4]
 80017d8:	7f9b      	ldrb	r3, [r3, #30]
 80017da:	f88d 300f 	strb.w	r3, [sp, #15]

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 80017de:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80017e2:	2b00      	cmp	r3, #0
 80017e4:	d12f      	bne.n	8001846 <chThdRelease+0x86>
 80017e6:	9b01      	ldr	r3, [sp, #4]
 80017e8:	7f1b      	ldrb	r3, [r3, #28]
 80017ea:	2b0f      	cmp	r3, #15
 80017ec:	d12b      	bne.n	8001846 <chThdRelease+0x86>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 80017ee:	9b01      	ldr	r3, [sp, #4]
 80017f0:	7f5b      	ldrb	r3, [r3, #29]
 80017f2:	f003 0303 	and.w	r3, r3, #3
 80017f6:	2b01      	cmp	r3, #1
 80017f8:	d002      	beq.n	8001800 <chThdRelease+0x40>
 80017fa:	2b02      	cmp	r3, #2
 80017fc:	d010      	beq.n	8001820 <chThdRelease+0x60>
      return;
#endif
    default:
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
 80017fe:	e022      	b.n	8001846 <chThdRelease+0x86>
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001800:	9b01      	ldr	r3, [sp, #4]
 8001802:	695b      	ldr	r3, [r3, #20]
 8001804:	9a01      	ldr	r2, [sp, #4]
 8001806:	6912      	ldr	r2, [r2, #16]
 8001808:	611a      	str	r2, [r3, #16]
 800180a:	9b01      	ldr	r3, [sp, #4]
 800180c:	691b      	ldr	r3, [r3, #16]
 800180e:	9a01      	ldr	r2, [sp, #4]
 8001810:	6952      	ldr	r2, [r2, #20]
 8001812:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001814:	f7ff ffb4 	bl	8001780 <chSysUnlock>
      chHeapFree(tp);
 8001818:	9801      	ldr	r0, [sp, #4]
 800181a:	f002 f819 	bl	8003850 <chHeapFree>
      return;
 800181e:	e014      	b.n	800184a <chThdRelease+0x8a>
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001820:	9b01      	ldr	r3, [sp, #4]
 8001822:	695b      	ldr	r3, [r3, #20]
 8001824:	9a01      	ldr	r2, [sp, #4]
 8001826:	6912      	ldr	r2, [r2, #16]
 8001828:	611a      	str	r2, [r3, #16]
 800182a:	9b01      	ldr	r3, [sp, #4]
 800182c:	691b      	ldr	r3, [r3, #16]
 800182e:	9a01      	ldr	r2, [sp, #4]
 8001830:	6952      	ldr	r2, [r2, #20]
 8001832:	615a      	str	r2, [r3, #20]
#endif
      chSysUnlock();
 8001834:	f7ff ffa4 	bl	8001780 <chSysUnlock>
      chPoolFree(tp->p_mpool, tp);
 8001838:	9b01      	ldr	r3, [sp, #4]
 800183a:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800183c:	4618      	mov	r0, r3
 800183e:	9901      	ldr	r1, [sp, #4]
 8001840:	f002 f93e 	bl	8003ac0 <chPoolFree>
      return;
 8001844:	e001      	b.n	800184a <chThdRelease+0x8a>
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
  chSysUnlock();
 8001846:	f7ff ff9b 	bl	8001780 <chSysUnlock>
}
 800184a:	b005      	add	sp, #20
 800184c:	f85d fb04 	ldr.w	pc, [sp], #4

08001850 <chThdCreateFromHeap>:
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
                              tprio_t prio, tfunc_t pf, void *arg) {
 8001850:	b500      	push	{lr}
 8001852:	b089      	sub	sp, #36	; 0x24
 8001854:	9005      	str	r0, [sp, #20]
 8001856:	9104      	str	r1, [sp, #16]
 8001858:	9203      	str	r2, [sp, #12]
 800185a:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
 800185c:	9805      	ldr	r0, [sp, #20]
 800185e:	9904      	ldr	r1, [sp, #16]
 8001860:	f001 ff7e 	bl	8003760 <chHeapAlloc>
 8001864:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 8001866:	9b07      	ldr	r3, [sp, #28]
 8001868:	2b00      	cmp	r3, #0
 800186a:	d101      	bne.n	8001870 <chThdCreateFromHeap+0x20>
    return NULL;
 800186c:	2300      	movs	r3, #0
 800186e:	e014      	b.n	800189a <chThdCreateFromHeap+0x4a>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 8001870:	f7ff ff7e 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, size, prio, pf, arg);
 8001874:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001876:	9300      	str	r3, [sp, #0]
 8001878:	9807      	ldr	r0, [sp, #28]
 800187a:	9904      	ldr	r1, [sp, #16]
 800187c:	9a03      	ldr	r2, [sp, #12]
 800187e:	9b02      	ldr	r3, [sp, #8]
 8001880:	f7ff fc86 	bl	8001190 <chThdCreateI>
 8001884:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8001886:	9b06      	ldr	r3, [sp, #24]
 8001888:	2201      	movs	r2, #1
 800188a:	775a      	strb	r2, [r3, #29]
  chSchWakeupS(tp, MSG_OK);
 800188c:	9806      	ldr	r0, [sp, #24]
 800188e:	2100      	movs	r1, #0
 8001890:	f7ff fa4e 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 8001894:	f7ff ff74 	bl	8001780 <chSysUnlock>

  return tp;
 8001898:	9b06      	ldr	r3, [sp, #24]
}
 800189a:	4618      	mov	r0, r3
 800189c:	b009      	add	sp, #36	; 0x24
 800189e:	f85d fb04 	ldr.w	pc, [sp], #4
 80018a2:	bf00      	nop
 80018a4:	f3af 8000 	nop.w
 80018a8:	f3af 8000 	nop.w
 80018ac:	f3af 8000 	nop.w

080018b0 <chThdCreateFromMemoryPool>:
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, tprio_t prio,
                                    tfunc_t pf, void *arg) {
 80018b0:	b500      	push	{lr}
 80018b2:	b089      	sub	sp, #36	; 0x24
 80018b4:	9005      	str	r0, [sp, #20]
 80018b6:	9104      	str	r1, [sp, #16]
 80018b8:	9203      	str	r2, [sp, #12]
 80018ba:	9302      	str	r3, [sp, #8]
  void *wsp;
  thread_t *tp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 80018bc:	9805      	ldr	r0, [sp, #20]
 80018be:	f002 f8df 	bl	8003a80 <chPoolAlloc>
 80018c2:	9007      	str	r0, [sp, #28]
  if (wsp == NULL) {
 80018c4:	9b07      	ldr	r3, [sp, #28]
 80018c6:	2b00      	cmp	r3, #0
 80018c8:	d101      	bne.n	80018ce <chThdCreateFromMemoryPool+0x1e>
    return NULL;
 80018ca:	2300      	movs	r3, #0
 80018cc:	e019      	b.n	8001902 <chThdCreateFromMemoryPool+0x52>
  _thread_memfill((uint8_t *)wsp + sizeof(thread_t),
                  (uint8_t *)wsp + mp->mp_object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
 80018ce:	f7ff ff4f 	bl	8001770 <chSysLock>
  tp = chThdCreateI(wsp, mp->mp_object_size, prio, pf, arg);
 80018d2:	9b05      	ldr	r3, [sp, #20]
 80018d4:	685b      	ldr	r3, [r3, #4]
 80018d6:	9a02      	ldr	r2, [sp, #8]
 80018d8:	9200      	str	r2, [sp, #0]
 80018da:	9807      	ldr	r0, [sp, #28]
 80018dc:	4619      	mov	r1, r3
 80018de:	9a04      	ldr	r2, [sp, #16]
 80018e0:	9b03      	ldr	r3, [sp, #12]
 80018e2:	f7ff fc55 	bl	8001190 <chThdCreateI>
 80018e6:	9006      	str	r0, [sp, #24]
  tp->p_flags = CH_FLAG_MODE_MPOOL;
 80018e8:	9b06      	ldr	r3, [sp, #24]
 80018ea:	2202      	movs	r2, #2
 80018ec:	775a      	strb	r2, [r3, #29]
  tp->p_mpool = mp;
 80018ee:	9b06      	ldr	r3, [sp, #24]
 80018f0:	9a05      	ldr	r2, [sp, #20]
 80018f2:	641a      	str	r2, [r3, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 80018f4:	9806      	ldr	r0, [sp, #24]
 80018f6:	2100      	movs	r1, #0
 80018f8:	f7ff fa1a 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80018fc:	f7ff ff40 	bl	8001780 <chSysUnlock>

  return tp;
 8001900:	9b06      	ldr	r3, [sp, #24]
}
 8001902:	4618      	mov	r0, r3
 8001904:	b009      	add	sp, #36	; 0x24
 8001906:	f85d fb04 	ldr.w	pc, [sp], #4
 800190a:	bf00      	nop
 800190c:	f3af 8000 	nop.w

08001910 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001910:	b082      	sub	sp, #8
 8001912:	2320      	movs	r3, #32
 8001914:	9301      	str	r3, [sp, #4]
 8001916:	9b01      	ldr	r3, [sp, #4]
 8001918:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800191c:	b002      	add	sp, #8
 800191e:	4770      	bx	lr

08001920 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001920:	b082      	sub	sp, #8
 8001922:	2300      	movs	r3, #0
 8001924:	9301      	str	r3, [sp, #4]
 8001926:	9b01      	ldr	r3, [sp, #4]
 8001928:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800192c:	b002      	add	sp, #8
 800192e:	4770      	bx	lr

08001930 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001930:	b508      	push	{r3, lr}

  port_lock();
 8001932:	f7ff ffed 	bl	8001910 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001936:	bd08      	pop	{r3, pc}
 8001938:	f3af 8000 	nop.w
 800193c:	f3af 8000 	nop.w

08001940 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001940:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001942:	f7ff ffed 	bl	8001920 <port_unlock>
}
 8001946:	bd08      	pop	{r3, pc}
 8001948:	f3af 8000 	nop.w
 800194c:	f3af 8000 	nop.w

08001950 <chRegFirstThread>:
 *
 * @return              A reference to the most ancient thread.
 *
 * @api
 */
thread_t *chRegFirstThread(void) {
 8001950:	b500      	push	{lr}
 8001952:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8001954:	f7ff ffec 	bl	8001930 <chSysLock>
  tp = ch.rlist.r_newer;
 8001958:	4b07      	ldr	r3, [pc, #28]	; (8001978 <chRegFirstThread+0x28>)
 800195a:	691b      	ldr	r3, [r3, #16]
 800195c:	9301      	str	r3, [sp, #4]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 800195e:	9b01      	ldr	r3, [sp, #4]
 8001960:	7f9b      	ldrb	r3, [r3, #30]
 8001962:	3301      	adds	r3, #1
 8001964:	b2da      	uxtb	r2, r3
 8001966:	9b01      	ldr	r3, [sp, #4]
 8001968:	779a      	strb	r2, [r3, #30]
#endif
  chSysUnlock();
 800196a:	f7ff ffe9 	bl	8001940 <chSysUnlock>

  return tp;
 800196e:	9b01      	ldr	r3, [sp, #4]
}
 8001970:	4618      	mov	r0, r3
 8001972:	b003      	add	sp, #12
 8001974:	f85d fb04 	ldr.w	pc, [sp], #4
 8001978:	20001bc8 	.word	0x20001bc8
 800197c:	f3af 8000 	nop.w

08001980 <chRegNextThread>:
 * @return              A reference to the next thread.
 * @retval NULL         if there is no next thread.
 *
 * @api
 */
thread_t *chRegNextThread(thread_t *tp) {
 8001980:	b500      	push	{lr}
 8001982:	b085      	sub	sp, #20
 8001984:	9001      	str	r0, [sp, #4]
  thread_t *ntp;

  chSysLock();
 8001986:	f7ff ffd3 	bl	8001930 <chSysLock>
  ntp = tp->p_newer;
 800198a:	9b01      	ldr	r3, [sp, #4]
 800198c:	691b      	ldr	r3, [r3, #16]
 800198e:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 8001990:	9a03      	ldr	r2, [sp, #12]
 8001992:	4b0b      	ldr	r3, [pc, #44]	; (80019c0 <chRegNextThread+0x40>)
 8001994:	429a      	cmp	r2, r3
 8001996:	d102      	bne.n	800199e <chRegNextThread+0x1e>
  /*lint -restore*/
    ntp = NULL;
 8001998:	2300      	movs	r3, #0
 800199a:	9303      	str	r3, [sp, #12]
 800199c:	e005      	b.n	80019aa <chRegNextThread+0x2a>
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 800199e:	9b03      	ldr	r3, [sp, #12]
 80019a0:	7f9b      	ldrb	r3, [r3, #30]
 80019a2:	3301      	adds	r3, #1
 80019a4:	b2da      	uxtb	r2, r3
 80019a6:	9b03      	ldr	r3, [sp, #12]
 80019a8:	779a      	strb	r2, [r3, #30]
  }
#endif
  chSysUnlock();
 80019aa:	f7ff ffc9 	bl	8001940 <chSysUnlock>
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 80019ae:	9801      	ldr	r0, [sp, #4]
 80019b0:	f7ff ff06 	bl	80017c0 <chThdRelease>
#endif

  return ntp;
 80019b4:	9b03      	ldr	r3, [sp, #12]
}
 80019b6:	4618      	mov	r0, r3
 80019b8:	b005      	add	sp, #20
 80019ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80019be:	bf00      	nop
 80019c0:	20001bc8 	.word	0x20001bc8
 80019c4:	f3af 8000 	nop.w
 80019c8:	f3af 8000 	nop.w
 80019cc:	f3af 8000 	nop.w

080019d0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80019d0:	b082      	sub	sp, #8
 80019d2:	2320      	movs	r3, #32
 80019d4:	9301      	str	r3, [sp, #4]
 80019d6:	9b01      	ldr	r3, [sp, #4]
 80019d8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019dc:	b002      	add	sp, #8
 80019de:	4770      	bx	lr

080019e0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80019e0:	b082      	sub	sp, #8
 80019e2:	2300      	movs	r3, #0
 80019e4:	9301      	str	r3, [sp, #4]
 80019e6:	9b01      	ldr	r3, [sp, #4]
 80019e8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80019ec:	b002      	add	sp, #8
 80019ee:	4770      	bx	lr

080019f0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80019f0:	b082      	sub	sp, #8
 80019f2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80019f4:	9b01      	ldr	r3, [sp, #4]
 80019f6:	9a01      	ldr	r2, [sp, #4]
 80019f8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80019fa:	9b01      	ldr	r3, [sp, #4]
 80019fc:	9a01      	ldr	r2, [sp, #4]
 80019fe:	605a      	str	r2, [r3, #4]
}
 8001a00:	b002      	add	sp, #8
 8001a02:	4770      	bx	lr
 8001a04:	f3af 8000 	nop.w
 8001a08:	f3af 8000 	nop.w
 8001a0c:	f3af 8000 	nop.w

08001a10 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8001a10:	b082      	sub	sp, #8
 8001a12:	9001      	str	r0, [sp, #4]
 8001a14:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8001a16:	9b01      	ldr	r3, [sp, #4]
 8001a18:	9a00      	ldr	r2, [sp, #0]
 8001a1a:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8001a1c:	9b00      	ldr	r3, [sp, #0]
 8001a1e:	685a      	ldr	r2, [r3, #4]
 8001a20:	9b01      	ldr	r3, [sp, #4]
 8001a22:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001a24:	9b01      	ldr	r3, [sp, #4]
 8001a26:	685b      	ldr	r3, [r3, #4]
 8001a28:	9a01      	ldr	r2, [sp, #4]
 8001a2a:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8001a2c:	9b00      	ldr	r3, [sp, #0]
 8001a2e:	9a01      	ldr	r2, [sp, #4]
 8001a30:	605a      	str	r2, [r3, #4]
}
 8001a32:	b002      	add	sp, #8
 8001a34:	4770      	bx	lr
 8001a36:	bf00      	nop
 8001a38:	f3af 8000 	nop.w
 8001a3c:	f3af 8000 	nop.w

08001a40 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001a40:	b084      	sub	sp, #16
 8001a42:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001a44:	9b01      	ldr	r3, [sp, #4]
 8001a46:	681b      	ldr	r3, [r3, #0]
 8001a48:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001a4a:	9b03      	ldr	r3, [sp, #12]
 8001a4c:	681a      	ldr	r2, [r3, #0]
 8001a4e:	9b01      	ldr	r3, [sp, #4]
 8001a50:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001a52:	9b01      	ldr	r3, [sp, #4]
 8001a54:	681b      	ldr	r3, [r3, #0]
 8001a56:	9a01      	ldr	r2, [sp, #4]
 8001a58:	605a      	str	r2, [r3, #4]

  return tp;
 8001a5a:	9b03      	ldr	r3, [sp, #12]
}
 8001a5c:	4618      	mov	r0, r3
 8001a5e:	b004      	add	sp, #16
 8001a60:	4770      	bx	lr
 8001a62:	bf00      	nop
 8001a64:	f3af 8000 	nop.w
 8001a68:	f3af 8000 	nop.w
 8001a6c:	f3af 8000 	nop.w

08001a70 <queue_lifo_remove>:

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
 8001a70:	b084      	sub	sp, #16
 8001a72:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_prev;
 8001a74:	9b01      	ldr	r3, [sp, #4]
 8001a76:	685b      	ldr	r3, [r3, #4]
 8001a78:	9303      	str	r3, [sp, #12]

  tqp->p_prev = tp->p_prev;
 8001a7a:	9b03      	ldr	r3, [sp, #12]
 8001a7c:	685a      	ldr	r2, [r3, #4]
 8001a7e:	9b01      	ldr	r3, [sp, #4]
 8001a80:	605a      	str	r2, [r3, #4]
  tqp->p_prev->p_next = (thread_t *)tqp;
 8001a82:	9b01      	ldr	r3, [sp, #4]
 8001a84:	685b      	ldr	r3, [r3, #4]
 8001a86:	9a01      	ldr	r2, [sp, #4]
 8001a88:	601a      	str	r2, [r3, #0]

  return tp;
 8001a8a:	9b03      	ldr	r3, [sp, #12]
}
 8001a8c:	4618      	mov	r0, r3
 8001a8e:	b004      	add	sp, #16
 8001a90:	4770      	bx	lr
 8001a92:	bf00      	nop
 8001a94:	f3af 8000 	nop.w
 8001a98:	f3af 8000 	nop.w
 8001a9c:	f3af 8000 	nop.w

08001aa0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001aa0:	b508      	push	{r3, lr}

  port_lock();
 8001aa2:	f7ff ff95 	bl	80019d0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001aa6:	bd08      	pop	{r3, pc}
 8001aa8:	f3af 8000 	nop.w
 8001aac:	f3af 8000 	nop.w

08001ab0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ab0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ab2:	f7ff ff95 	bl	80019e0 <port_unlock>
}
 8001ab6:	bd08      	pop	{r3, pc}
 8001ab8:	f3af 8000 	nop.w
 8001abc:	f3af 8000 	nop.w

08001ac0 <chSemObjectInit>:
 * @param[in] n         initial value of the semaphore counter. Must be
 *                      non-negative.
 *
 * @init
 */
void chSemObjectInit(semaphore_t *sp, cnt_t n) {
 8001ac0:	b500      	push	{lr}
 8001ac2:	b083      	sub	sp, #12
 8001ac4:	9001      	str	r0, [sp, #4]
 8001ac6:	9100      	str	r1, [sp, #0]

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->s_queue);
 8001ac8:	9b01      	ldr	r3, [sp, #4]
 8001aca:	4618      	mov	r0, r3
 8001acc:	f7ff ff90 	bl	80019f0 <queue_init>
  sp->s_cnt = n;
 8001ad0:	9b01      	ldr	r3, [sp, #4]
 8001ad2:	9a00      	ldr	r2, [sp, #0]
 8001ad4:	609a      	str	r2, [r3, #8]
}
 8001ad6:	b003      	add	sp, #12
 8001ad8:	f85d fb04 	ldr.w	pc, [sp], #4
 8001adc:	f3af 8000 	nop.w

08001ae0 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8001ae0:	b500      	push	{lr}
 8001ae2:	b083      	sub	sp, #12
 8001ae4:	9001      	str	r0, [sp, #4]
 8001ae6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8001ae8:	f7ff ffda 	bl	8001aa0 <chSysLock>
  chSemResetI(sp, n);
 8001aec:	9801      	ldr	r0, [sp, #4]
 8001aee:	9900      	ldr	r1, [sp, #0]
 8001af0:	f000 f80e 	bl	8001b10 <chSemResetI>
  chSchRescheduleS();
 8001af4:	f7ff f944 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8001af8:	f7ff ffda 	bl	8001ab0 <chSysUnlock>
}
 8001afc:	b003      	add	sp, #12
 8001afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8001b02:	bf00      	nop
 8001b04:	f3af 8000 	nop.w
 8001b08:	f3af 8000 	nop.w
 8001b0c:	f3af 8000 	nop.w

08001b10 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8001b10:	b500      	push	{lr}
 8001b12:	b085      	sub	sp, #20
 8001b14:	9001      	str	r0, [sp, #4]
 8001b16:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
 8001b18:	9b01      	ldr	r3, [sp, #4]
 8001b1a:	689b      	ldr	r3, [r3, #8]
 8001b1c:	9303      	str	r3, [sp, #12]
  sp->s_cnt = n;
 8001b1e:	9b01      	ldr	r3, [sp, #4]
 8001b20:	9a00      	ldr	r2, [sp, #0]
 8001b22:	609a      	str	r2, [r3, #8]
  while (++cnt <= (cnt_t)0) {
 8001b24:	e00b      	b.n	8001b3e <chSemResetI+0x2e>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
 8001b26:	9b01      	ldr	r3, [sp, #4]
 8001b28:	4618      	mov	r0, r3
 8001b2a:	f7ff ffa1 	bl	8001a70 <queue_lifo_remove>
 8001b2e:	4603      	mov	r3, r0
 8001b30:	4618      	mov	r0, r3
 8001b32:	f7ff f835 	bl	8000ba0 <chSchReadyI>
 8001b36:	4603      	mov	r3, r0
 8001b38:	f06f 0201 	mvn.w	r2, #1
 8001b3c:	621a      	str	r2, [r3, #32]
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  cnt = sp->s_cnt;
  sp->s_cnt = n;
  while (++cnt <= (cnt_t)0) {
 8001b3e:	9b03      	ldr	r3, [sp, #12]
 8001b40:	3301      	adds	r3, #1
 8001b42:	9303      	str	r3, [sp, #12]
 8001b44:	9b03      	ldr	r3, [sp, #12]
 8001b46:	2b00      	cmp	r3, #0
 8001b48:	dded      	ble.n	8001b26 <chSemResetI+0x16>
    chSchReadyI(queue_lifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 8001b4a:	b005      	add	sp, #20
 8001b4c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b50 <chSemWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 8001b50:	b500      	push	{lr}
 8001b52:	b085      	sub	sp, #20
 8001b54:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8001b56:	f7ff ffa3 	bl	8001aa0 <chSysLock>
  msg = chSemWaitS(sp);
 8001b5a:	9801      	ldr	r0, [sp, #4]
 8001b5c:	f000 f808 	bl	8001b70 <chSemWaitS>
 8001b60:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001b62:	f7ff ffa5 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001b66:	9b03      	ldr	r3, [sp, #12]
}
 8001b68:	4618      	mov	r0, r3
 8001b6a:	b005      	add	sp, #20
 8001b6c:	f85d fb04 	ldr.w	pc, [sp], #4

08001b70 <chSemWaitS>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @sclass
 */
msg_t chSemWaitS(semaphore_t *sp) {
 8001b70:	b500      	push	{lr}
 8001b72:	b083      	sub	sp, #12
 8001b74:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001b76:	9b01      	ldr	r3, [sp, #4]
 8001b78:	689b      	ldr	r3, [r3, #8]
 8001b7a:	1e5a      	subs	r2, r3, #1
 8001b7c:	9b01      	ldr	r3, [sp, #4]
 8001b7e:	609a      	str	r2, [r3, #8]
 8001b80:	9b01      	ldr	r3, [sp, #4]
 8001b82:	689b      	ldr	r3, [r3, #8]
 8001b84:	2b00      	cmp	r3, #0
 8001b86:	da11      	bge.n	8001bac <chSemWaitS+0x3c>
    currp->p_u.wtsemp = sp;
 8001b88:	4b0b      	ldr	r3, [pc, #44]	; (8001bb8 <chSemWaitS+0x48>)
 8001b8a:	699b      	ldr	r3, [r3, #24]
 8001b8c:	9a01      	ldr	r2, [sp, #4]
 8001b8e:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001b90:	4b09      	ldr	r3, [pc, #36]	; (8001bb8 <chSemWaitS+0x48>)
 8001b92:	699a      	ldr	r2, [r3, #24]
 8001b94:	9b01      	ldr	r3, [sp, #4]
 8001b96:	4610      	mov	r0, r2
 8001b98:	4619      	mov	r1, r3
 8001b9a:	f7ff ff39 	bl	8001a10 <queue_insert>
    chSchGoSleepS(CH_STATE_WTSEM);
 8001b9e:	2005      	movs	r0, #5
 8001ba0:	f7ff f826 	bl	8000bf0 <chSchGoSleepS>

    return currp->p_u.rdymsg;
 8001ba4:	4b04      	ldr	r3, [pc, #16]	; (8001bb8 <chSemWaitS+0x48>)
 8001ba6:	699b      	ldr	r3, [r3, #24]
 8001ba8:	6a1b      	ldr	r3, [r3, #32]
 8001baa:	e000      	b.n	8001bae <chSemWaitS+0x3e>
  }

  return MSG_OK;
 8001bac:	2300      	movs	r3, #0
}
 8001bae:	4618      	mov	r0, r3
 8001bb0:	b003      	add	sp, #12
 8001bb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8001bb6:	bf00      	nop
 8001bb8:	20001bc8 	.word	0x20001bc8
 8001bbc:	f3af 8000 	nop.w

08001bc0 <chSemWaitTimeout>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
 8001bc0:	b500      	push	{lr}
 8001bc2:	b085      	sub	sp, #20
 8001bc4:	9001      	str	r0, [sp, #4]
 8001bc6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 8001bc8:	f7ff ff6a 	bl	8001aa0 <chSysLock>
  msg = chSemWaitTimeoutS(sp, time);
 8001bcc:	9801      	ldr	r0, [sp, #4]
 8001bce:	9900      	ldr	r1, [sp, #0]
 8001bd0:	f000 f80e 	bl	8001bf0 <chSemWaitTimeoutS>
 8001bd4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8001bd6:	f7ff ff6b 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001bda:	9b03      	ldr	r3, [sp, #12]
}
 8001bdc:	4618      	mov	r0, r3
 8001bde:	b005      	add	sp, #20
 8001be0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001be4:	f3af 8000 	nop.w
 8001be8:	f3af 8000 	nop.w
 8001bec:	f3af 8000 	nop.w

08001bf0 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8001bf0:	b500      	push	{lr}
 8001bf2:	b083      	sub	sp, #12
 8001bf4:	9001      	str	r0, [sp, #4]
 8001bf6:	9100      	str	r1, [sp, #0]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (--sp->s_cnt < (cnt_t)0) {
 8001bf8:	9b01      	ldr	r3, [sp, #4]
 8001bfa:	689b      	ldr	r3, [r3, #8]
 8001bfc:	1e5a      	subs	r2, r3, #1
 8001bfe:	9b01      	ldr	r3, [sp, #4]
 8001c00:	609a      	str	r2, [r3, #8]
 8001c02:	9b01      	ldr	r3, [sp, #4]
 8001c04:	689b      	ldr	r3, [r3, #8]
 8001c06:	2b00      	cmp	r3, #0
 8001c08:	da1b      	bge.n	8001c42 <chSemWaitTimeoutS+0x52>
    if (TIME_IMMEDIATE == time) {
 8001c0a:	9b00      	ldr	r3, [sp, #0]
 8001c0c:	2b00      	cmp	r3, #0
 8001c0e:	d107      	bne.n	8001c20 <chSemWaitTimeoutS+0x30>
      sp->s_cnt++;
 8001c10:	9b01      	ldr	r3, [sp, #4]
 8001c12:	689b      	ldr	r3, [r3, #8]
 8001c14:	1c5a      	adds	r2, r3, #1
 8001c16:	9b01      	ldr	r3, [sp, #4]
 8001c18:	609a      	str	r2, [r3, #8]

      return MSG_TIMEOUT;
 8001c1a:	f04f 33ff 	mov.w	r3, #4294967295
 8001c1e:	e011      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
    }
    currp->p_u.wtsemp = sp;
 8001c20:	4b0a      	ldr	r3, [pc, #40]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c22:	699b      	ldr	r3, [r3, #24]
 8001c24:	9a01      	ldr	r2, [sp, #4]
 8001c26:	621a      	str	r2, [r3, #32]
    sem_insert(currp, &sp->s_queue);
 8001c28:	4b08      	ldr	r3, [pc, #32]	; (8001c4c <chSemWaitTimeoutS+0x5c>)
 8001c2a:	699a      	ldr	r2, [r3, #24]
 8001c2c:	9b01      	ldr	r3, [sp, #4]
 8001c2e:	4610      	mov	r0, r2
 8001c30:	4619      	mov	r1, r3
 8001c32:	f7ff feed 	bl	8001a10 <queue_insert>

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 8001c36:	2005      	movs	r0, #5
 8001c38:	9900      	ldr	r1, [sp, #0]
 8001c3a:	f7ff f841 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8001c3e:	4603      	mov	r3, r0
 8001c40:	e000      	b.n	8001c44 <chSemWaitTimeoutS+0x54>
  }

  return MSG_OK;
 8001c42:	2300      	movs	r3, #0
}
 8001c44:	4618      	mov	r0, r3
 8001c46:	b003      	add	sp, #12
 8001c48:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c4c:	20001bc8 	.word	0x20001bc8

08001c50 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8001c50:	b500      	push	{lr}
 8001c52:	b083      	sub	sp, #12
 8001c54:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001c56:	f7ff ff23 	bl	8001aa0 <chSysLock>
  if (++sp->s_cnt <= (cnt_t)0) {
 8001c5a:	9b01      	ldr	r3, [sp, #4]
 8001c5c:	689b      	ldr	r3, [r3, #8]
 8001c5e:	1c5a      	adds	r2, r3, #1
 8001c60:	9b01      	ldr	r3, [sp, #4]
 8001c62:	609a      	str	r2, [r3, #8]
 8001c64:	9b01      	ldr	r3, [sp, #4]
 8001c66:	689b      	ldr	r3, [r3, #8]
 8001c68:	2b00      	cmp	r3, #0
 8001c6a:	dc08      	bgt.n	8001c7e <chSemSignal+0x2e>
    chSchWakeupS(queue_fifo_remove(&sp->s_queue), MSG_OK);
 8001c6c:	9b01      	ldr	r3, [sp, #4]
 8001c6e:	4618      	mov	r0, r3
 8001c70:	f7ff fee6 	bl	8001a40 <queue_fifo_remove>
 8001c74:	4603      	mov	r3, r0
 8001c76:	4618      	mov	r0, r3
 8001c78:	2100      	movs	r1, #0
 8001c7a:	f7ff f859 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 8001c7e:	f7ff ff17 	bl	8001ab0 <chSysUnlock>
}
 8001c82:	b003      	add	sp, #12
 8001c84:	f85d fb04 	ldr.w	pc, [sp], #4
 8001c88:	f3af 8000 	nop.w
 8001c8c:	f3af 8000 	nop.w

08001c90 <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
 8001c90:	b500      	push	{lr}
 8001c92:	b085      	sub	sp, #20
 8001c94:	9001      	str	r0, [sp, #4]
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  if (++sp->s_cnt <= (cnt_t)0) {
 8001c96:	9b01      	ldr	r3, [sp, #4]
 8001c98:	689b      	ldr	r3, [r3, #8]
 8001c9a:	1c5a      	adds	r2, r3, #1
 8001c9c:	9b01      	ldr	r3, [sp, #4]
 8001c9e:	609a      	str	r2, [r3, #8]
 8001ca0:	9b01      	ldr	r3, [sp, #4]
 8001ca2:	689b      	ldr	r3, [r3, #8]
 8001ca4:	2b00      	cmp	r3, #0
 8001ca6:	dc0a      	bgt.n	8001cbe <chSemSignalI+0x2e>
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->s_queue);
 8001ca8:	9b01      	ldr	r3, [sp, #4]
 8001caa:	4618      	mov	r0, r3
 8001cac:	f7ff fec8 	bl	8001a40 <queue_fifo_remove>
 8001cb0:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 8001cb2:	9b03      	ldr	r3, [sp, #12]
 8001cb4:	2200      	movs	r2, #0
 8001cb6:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 8001cb8:	9803      	ldr	r0, [sp, #12]
 8001cba:	f7fe ff71 	bl	8000ba0 <chSchReadyI>
  }
}
 8001cbe:	b005      	add	sp, #20
 8001cc0:	f85d fb04 	ldr.w	pc, [sp], #4
 8001cc4:	f3af 8000 	nop.w
 8001cc8:	f3af 8000 	nop.w
 8001ccc:	f3af 8000 	nop.w

08001cd0 <chSemAddCounterI>:
 * @param[in] n         value to be added to the semaphore counter. The value
 *                      must be positive.
 *
 * @iclass
 */
void chSemAddCounterI(semaphore_t *sp, cnt_t n) {
 8001cd0:	b500      	push	{lr}
 8001cd2:	b083      	sub	sp, #12
 8001cd4:	9001      	str	r0, [sp, #4]
 8001cd6:	9100      	str	r1, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001cd8:	e016      	b.n	8001d08 <chSemAddCounterI+0x38>
    if (++sp->s_cnt <= (cnt_t)0) {
 8001cda:	9b01      	ldr	r3, [sp, #4]
 8001cdc:	689b      	ldr	r3, [r3, #8]
 8001cde:	1c5a      	adds	r2, r3, #1
 8001ce0:	9b01      	ldr	r3, [sp, #4]
 8001ce2:	609a      	str	r2, [r3, #8]
 8001ce4:	9b01      	ldr	r3, [sp, #4]
 8001ce6:	689b      	ldr	r3, [r3, #8]
 8001ce8:	2b00      	cmp	r3, #0
 8001cea:	dc0a      	bgt.n	8001d02 <chSemAddCounterI+0x32>
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
 8001cec:	9b01      	ldr	r3, [sp, #4]
 8001cee:	4618      	mov	r0, r3
 8001cf0:	f7ff fea6 	bl	8001a40 <queue_fifo_remove>
 8001cf4:	4603      	mov	r3, r0
 8001cf6:	4618      	mov	r0, r3
 8001cf8:	f7fe ff52 	bl	8000ba0 <chSchReadyI>
 8001cfc:	4603      	mov	r3, r0
 8001cfe:	2200      	movs	r2, #0
 8001d00:	621a      	str	r2, [r3, #32]
    }
    n--;
 8001d02:	9b00      	ldr	r3, [sp, #0]
 8001d04:	3b01      	subs	r3, #1
 8001d06:	9300      	str	r3, [sp, #0]
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->s_cnt >= (cnt_t)0) && queue_isempty(&sp->s_queue)) ||
              ((sp->s_cnt < (cnt_t)0) && queue_notempty(&sp->s_queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001d08:	9b00      	ldr	r3, [sp, #0]
 8001d0a:	2b00      	cmp	r3, #0
 8001d0c:	dce5      	bgt.n	8001cda <chSemAddCounterI+0xa>
    if (++sp->s_cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->s_queue))->p_u.rdymsg = MSG_OK;
    }
    n--;
  }
}
 8001d0e:	b003      	add	sp, #12
 8001d10:	f85d fb04 	ldr.w	pc, [sp], #4
 8001d14:	f3af 8000 	nop.w
 8001d18:	f3af 8000 	nop.w
 8001d1c:	f3af 8000 	nop.w

08001d20 <chSemSignalWait>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8001d20:	b500      	push	{lr}
 8001d22:	b085      	sub	sp, #20
 8001d24:	9001      	str	r0, [sp, #4]
 8001d26:	9100      	str	r1, [sp, #0]
              "inconsistent semaphore");
  chDbgAssert(((spw->s_cnt >= (cnt_t)0) && queue_isempty(&spw->s_queue)) ||
              ((spw->s_cnt < (cnt_t)0) && queue_notempty(&spw->s_queue)),
              "inconsistent semaphore");

  chSysLock();
 8001d28:	f7ff feba 	bl	8001aa0 <chSysLock>
  if (++sps->s_cnt <= (cnt_t)0) {
 8001d2c:	9b01      	ldr	r3, [sp, #4]
 8001d2e:	689b      	ldr	r3, [r3, #8]
 8001d30:	1c5a      	adds	r2, r3, #1
 8001d32:	9b01      	ldr	r3, [sp, #4]
 8001d34:	609a      	str	r2, [r3, #8]
 8001d36:	9b01      	ldr	r3, [sp, #4]
 8001d38:	689b      	ldr	r3, [r3, #8]
 8001d3a:	2b00      	cmp	r3, #0
 8001d3c:	dc0a      	bgt.n	8001d54 <chSemSignalWait+0x34>
    chSchReadyI(queue_fifo_remove(&sps->s_queue))->p_u.rdymsg = MSG_OK;
 8001d3e:	9b01      	ldr	r3, [sp, #4]
 8001d40:	4618      	mov	r0, r3
 8001d42:	f7ff fe7d 	bl	8001a40 <queue_fifo_remove>
 8001d46:	4603      	mov	r3, r0
 8001d48:	4618      	mov	r0, r3
 8001d4a:	f7fe ff29 	bl	8000ba0 <chSchReadyI>
 8001d4e:	4603      	mov	r3, r0
 8001d50:	2200      	movs	r2, #0
 8001d52:	621a      	str	r2, [r3, #32]
  }
  if (--spw->s_cnt < (cnt_t)0) {
 8001d54:	9b00      	ldr	r3, [sp, #0]
 8001d56:	689b      	ldr	r3, [r3, #8]
 8001d58:	1e5a      	subs	r2, r3, #1
 8001d5a:	9b00      	ldr	r3, [sp, #0]
 8001d5c:	609a      	str	r2, [r3, #8]
 8001d5e:	9b00      	ldr	r3, [sp, #0]
 8001d60:	689b      	ldr	r3, [r3, #8]
 8001d62:	2b00      	cmp	r3, #0
 8001d64:	da11      	bge.n	8001d8a <chSemSignalWait+0x6a>
    thread_t *ctp = currp;
 8001d66:	4b0e      	ldr	r3, [pc, #56]	; (8001da0 <chSemSignalWait+0x80>)
 8001d68:	699b      	ldr	r3, [r3, #24]
 8001d6a:	9302      	str	r3, [sp, #8]
    sem_insert(ctp, &spw->s_queue);
 8001d6c:	9b00      	ldr	r3, [sp, #0]
 8001d6e:	9802      	ldr	r0, [sp, #8]
 8001d70:	4619      	mov	r1, r3
 8001d72:	f7ff fe4d 	bl	8001a10 <queue_insert>
    ctp->p_u.wtsemp = spw;
 8001d76:	9b02      	ldr	r3, [sp, #8]
 8001d78:	9a00      	ldr	r2, [sp, #0]
 8001d7a:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTSEM);
 8001d7c:	2005      	movs	r0, #5
 8001d7e:	f7fe ff37 	bl	8000bf0 <chSchGoSleepS>
    msg = ctp->p_u.rdymsg;
 8001d82:	9b02      	ldr	r3, [sp, #8]
 8001d84:	6a1b      	ldr	r3, [r3, #32]
 8001d86:	9303      	str	r3, [sp, #12]
 8001d88:	e003      	b.n	8001d92 <chSemSignalWait+0x72>
  }
  else {
    chSchRescheduleS();
 8001d8a:	f7fe fff9 	bl	8000d80 <chSchRescheduleS>
    msg = MSG_OK;
 8001d8e:	2300      	movs	r3, #0
 8001d90:	9303      	str	r3, [sp, #12]
  }
  chSysUnlock();
 8001d92:	f7ff fe8d 	bl	8001ab0 <chSysUnlock>

  return msg;
 8001d96:	9b03      	ldr	r3, [sp, #12]
}
 8001d98:	4618      	mov	r0, r3
 8001d9a:	b005      	add	sp, #20
 8001d9c:	f85d fb04 	ldr.w	pc, [sp], #4
 8001da0:	20001bc8 	.word	0x20001bc8
 8001da4:	f3af 8000 	nop.w
 8001da8:	f3af 8000 	nop.w
 8001dac:	f3af 8000 	nop.w

08001db0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8001db0:	b082      	sub	sp, #8
 8001db2:	2320      	movs	r3, #32
 8001db4:	9301      	str	r3, [sp, #4]
 8001db6:	9b01      	ldr	r3, [sp, #4]
 8001db8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dbc:	b002      	add	sp, #8
 8001dbe:	4770      	bx	lr

08001dc0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8001dc0:	b082      	sub	sp, #8
 8001dc2:	2300      	movs	r3, #0
 8001dc4:	9301      	str	r3, [sp, #4]
 8001dc6:	9b01      	ldr	r3, [sp, #4]
 8001dc8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8001dcc:	b002      	add	sp, #8
 8001dce:	4770      	bx	lr

08001dd0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8001dd0:	b082      	sub	sp, #8
 8001dd2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8001dd4:	9b01      	ldr	r3, [sp, #4]
 8001dd6:	9a01      	ldr	r2, [sp, #4]
 8001dd8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8001dda:	9b01      	ldr	r3, [sp, #4]
 8001ddc:	9a01      	ldr	r2, [sp, #4]
 8001dde:	605a      	str	r2, [r3, #4]
}
 8001de0:	b002      	add	sp, #8
 8001de2:	4770      	bx	lr
 8001de4:	f3af 8000 	nop.w
 8001de8:	f3af 8000 	nop.w
 8001dec:	f3af 8000 	nop.w

08001df0 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8001df0:	b082      	sub	sp, #8
 8001df2:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001df4:	9b01      	ldr	r3, [sp, #4]
 8001df6:	681a      	ldr	r2, [r3, #0]
 8001df8:	9b01      	ldr	r3, [sp, #4]
 8001dfa:	429a      	cmp	r2, r3
 8001dfc:	bf0c      	ite	eq
 8001dfe:	2300      	moveq	r3, #0
 8001e00:	2301      	movne	r3, #1
 8001e02:	b2db      	uxtb	r3, r3
}
 8001e04:	4618      	mov	r0, r3
 8001e06:	b002      	add	sp, #8
 8001e08:	4770      	bx	lr
 8001e0a:	bf00      	nop
 8001e0c:	f3af 8000 	nop.w

08001e10 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8001e10:	b084      	sub	sp, #16
 8001e12:	9001      	str	r0, [sp, #4]
 8001e14:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8001e16:	9b00      	ldr	r3, [sp, #0]
 8001e18:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 8001e1a:	9b03      	ldr	r3, [sp, #12]
 8001e1c:	681b      	ldr	r3, [r3, #0]
 8001e1e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 8001e20:	9a03      	ldr	r2, [sp, #12]
 8001e22:	9b00      	ldr	r3, [sp, #0]
 8001e24:	429a      	cmp	r2, r3
 8001e26:	d005      	beq.n	8001e34 <queue_prio_insert+0x24>
 8001e28:	9b03      	ldr	r3, [sp, #12]
 8001e2a:	689a      	ldr	r2, [r3, #8]
 8001e2c:	9b01      	ldr	r3, [sp, #4]
 8001e2e:	689b      	ldr	r3, [r3, #8]
 8001e30:	429a      	cmp	r2, r3
 8001e32:	d2f2      	bcs.n	8001e1a <queue_prio_insert+0xa>
  tp->p_next = cp;
 8001e34:	9b01      	ldr	r3, [sp, #4]
 8001e36:	9a03      	ldr	r2, [sp, #12]
 8001e38:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 8001e3a:	9b03      	ldr	r3, [sp, #12]
 8001e3c:	685a      	ldr	r2, [r3, #4]
 8001e3e:	9b01      	ldr	r3, [sp, #4]
 8001e40:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8001e42:	9b01      	ldr	r3, [sp, #4]
 8001e44:	685b      	ldr	r3, [r3, #4]
 8001e46:	9a01      	ldr	r2, [sp, #4]
 8001e48:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 8001e4a:	9b03      	ldr	r3, [sp, #12]
 8001e4c:	9a01      	ldr	r2, [sp, #4]
 8001e4e:	605a      	str	r2, [r3, #4]
}
 8001e50:	b004      	add	sp, #16
 8001e52:	4770      	bx	lr
 8001e54:	f3af 8000 	nop.w
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8001e60:	b084      	sub	sp, #16
 8001e62:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8001e64:	9b01      	ldr	r3, [sp, #4]
 8001e66:	681b      	ldr	r3, [r3, #0]
 8001e68:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8001e6a:	9b03      	ldr	r3, [sp, #12]
 8001e6c:	681a      	ldr	r2, [r3, #0]
 8001e6e:	9b01      	ldr	r3, [sp, #4]
 8001e70:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001e72:	9b01      	ldr	r3, [sp, #4]
 8001e74:	681b      	ldr	r3, [r3, #0]
 8001e76:	9a01      	ldr	r2, [sp, #4]
 8001e78:	605a      	str	r2, [r3, #4]

  return tp;
 8001e7a:	9b03      	ldr	r3, [sp, #12]
}
 8001e7c:	4618      	mov	r0, r3
 8001e7e:	b004      	add	sp, #16
 8001e80:	4770      	bx	lr
 8001e82:	bf00      	nop
 8001e84:	f3af 8000 	nop.w
 8001e88:	f3af 8000 	nop.w
 8001e8c:	f3af 8000 	nop.w

08001e90 <queue_dequeue>:
  tqp->p_prev->p_next = (thread_t *)tqp;

  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {
 8001e90:	b082      	sub	sp, #8
 8001e92:	9001      	str	r0, [sp, #4]

  tp->p_prev->p_next = tp->p_next;
 8001e94:	9b01      	ldr	r3, [sp, #4]
 8001e96:	685b      	ldr	r3, [r3, #4]
 8001e98:	9a01      	ldr	r2, [sp, #4]
 8001e9a:	6812      	ldr	r2, [r2, #0]
 8001e9c:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001e9e:	9b01      	ldr	r3, [sp, #4]
 8001ea0:	681b      	ldr	r3, [r3, #0]
 8001ea2:	9a01      	ldr	r2, [sp, #4]
 8001ea4:	6852      	ldr	r2, [r2, #4]
 8001ea6:	605a      	str	r2, [r3, #4]

  return tp;
 8001ea8:	9b01      	ldr	r3, [sp, #4]
}
 8001eaa:	4618      	mov	r0, r3
 8001eac:	b002      	add	sp, #8
 8001eae:	4770      	bx	lr

08001eb0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8001eb0:	b508      	push	{r3, lr}

  port_lock();
 8001eb2:	f7ff ff7d 	bl	8001db0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8001eb6:	bd08      	pop	{r3, pc}
 8001eb8:	f3af 8000 	nop.w
 8001ebc:	f3af 8000 	nop.w

08001ec0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8001ec0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8001ec2:	f7ff ff7d 	bl	8001dc0 <port_unlock>
}
 8001ec6:	bd08      	pop	{r3, pc}
 8001ec8:	f3af 8000 	nop.w
 8001ecc:	f3af 8000 	nop.w

08001ed0 <chMtxQueueNotEmptyS>:
 * @return              The mutex queue status.
 *
 * @deprecated
 * @sclass
 */
static inline bool chMtxQueueNotEmptyS(mutex_t *mp) {
 8001ed0:	b500      	push	{lr}
 8001ed2:	b083      	sub	sp, #12
 8001ed4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();

  return queue_notempty(&mp->m_queue);
 8001ed6:	9b01      	ldr	r3, [sp, #4]
 8001ed8:	4618      	mov	r0, r3
 8001eda:	f7ff ff89 	bl	8001df0 <queue_notempty>
 8001ede:	4603      	mov	r3, r0
}
 8001ee0:	4618      	mov	r0, r3
 8001ee2:	b003      	add	sp, #12
 8001ee4:	f85d fb04 	ldr.w	pc, [sp], #4
 8001ee8:	f3af 8000 	nop.w
 8001eec:	f3af 8000 	nop.w

08001ef0 <chMtxObjectInit>:
 *
 * @param[out] mp       pointer to a @p mutex_t structure
 *
 * @init
 */
void chMtxObjectInit(mutex_t *mp) {
 8001ef0:	b500      	push	{lr}
 8001ef2:	b083      	sub	sp, #12
 8001ef4:	9001      	str	r0, [sp, #4]

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
 8001ef6:	9b01      	ldr	r3, [sp, #4]
 8001ef8:	4618      	mov	r0, r3
 8001efa:	f7ff ff69 	bl	8001dd0 <queue_init>
  mp->m_owner = NULL;
 8001efe:	9b01      	ldr	r3, [sp, #4]
 8001f00:	2200      	movs	r2, #0
 8001f02:	609a      	str	r2, [r3, #8]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  mp->m_cnt = (cnt_t)0;
#endif
}
 8001f04:	b003      	add	sp, #12
 8001f06:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f0a:	bf00      	nop
 8001f0c:	f3af 8000 	nop.w

08001f10 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8001f10:	b500      	push	{lr}
 8001f12:	b083      	sub	sp, #12
 8001f14:	9001      	str	r0, [sp, #4]

  chSysLock();
 8001f16:	f7ff ffcb 	bl	8001eb0 <chSysLock>
  chMtxLockS(mp);
 8001f1a:	9801      	ldr	r0, [sp, #4]
 8001f1c:	f000 f808 	bl	8001f30 <chMtxLockS>
  chSysUnlock();
 8001f20:	f7ff ffce 	bl	8001ec0 <chSysUnlock>
}
 8001f24:	b003      	add	sp, #12
 8001f26:	f85d fb04 	ldr.w	pc, [sp], #4
 8001f2a:	bf00      	nop
 8001f2c:	f3af 8000 	nop.w

08001f30 <chMtxLockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8001f30:	b500      	push	{lr}
 8001f32:	b085      	sub	sp, #20
 8001f34:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8001f36:	4b2d      	ldr	r3, [pc, #180]	; (8001fec <chMtxLockS+0xbc>)
 8001f38:	699b      	ldr	r3, [r3, #24]
 8001f3a:	9302      	str	r3, [sp, #8]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8001f3c:	9b01      	ldr	r3, [sp, #4]
 8001f3e:	689b      	ldr	r3, [r3, #8]
 8001f40:	2b00      	cmp	r3, #0
 8001f42:	d045      	beq.n	8001fd0 <chMtxLockS+0xa0>
    else {
#endif
      /* Priority inheritance protocol; explores the thread-mutex dependencies
         boosting the priority of all the affected threads to equal the
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;
 8001f44:	9b01      	ldr	r3, [sp, #4]
 8001f46:	689b      	ldr	r3, [r3, #8]
 8001f48:	9303      	str	r3, [sp, #12]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001f4a:	e02f      	b.n	8001fac <chMtxLockS+0x7c>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8001f4c:	9b02      	ldr	r3, [sp, #8]
 8001f4e:	689a      	ldr	r2, [r3, #8]
 8001f50:	9b03      	ldr	r3, [sp, #12]
 8001f52:	609a      	str	r2, [r3, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8001f54:	9b03      	ldr	r3, [sp, #12]
 8001f56:	7f1b      	ldrb	r3, [r3, #28]
 8001f58:	2b06      	cmp	r3, #6
 8001f5a:	d004      	beq.n	8001f66 <chMtxLockS+0x36>
 8001f5c:	2b07      	cmp	r3, #7
 8001f5e:	d011      	beq.n	8001f84 <chMtxLockS+0x54>
 8001f60:	2b00      	cmp	r3, #0
 8001f62:	d01a      	beq.n	8001f9a <chMtxLockS+0x6a>
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
          break;
        default:
          /* Nothing to do for other states.*/
          break;
 8001f64:	e021      	b.n	8001faa <chMtxLockS+0x7a>

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f66:	9803      	ldr	r0, [sp, #12]
 8001f68:	f7ff ff92 	bl	8001e90 <queue_dequeue>
 8001f6c:	4602      	mov	r2, r0
 8001f6e:	9b03      	ldr	r3, [sp, #12]
 8001f70:	6a1b      	ldr	r3, [r3, #32]
 8001f72:	4610      	mov	r0, r2
 8001f74:	4619      	mov	r1, r3
 8001f76:	f7ff ff4b 	bl	8001e10 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 8001f7a:	9b03      	ldr	r3, [sp, #12]
 8001f7c:	6a1b      	ldr	r3, [r3, #32]
 8001f7e:	689b      	ldr	r3, [r3, #8]
 8001f80:	9303      	str	r3, [sp, #12]
          /*lint -e{9042} [16.1] Continues the while.*/
          continue;
 8001f82:	e013      	b.n	8001fac <chMtxLockS+0x7c>
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001f84:	9803      	ldr	r0, [sp, #12]
 8001f86:	f7ff ff83 	bl	8001e90 <queue_dequeue>
 8001f8a:	4602      	mov	r2, r0
 8001f8c:	9b03      	ldr	r3, [sp, #12]
 8001f8e:	6a1b      	ldr	r3, [r3, #32]
 8001f90:	4610      	mov	r0, r2
 8001f92:	4619      	mov	r1, r3
 8001f94:	f7ff ff3c 	bl	8001e10 <queue_prio_insert>
          break;
 8001f98:	e007      	b.n	8001faa <chMtxLockS+0x7a>
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001f9a:	9803      	ldr	r0, [sp, #12]
 8001f9c:	f7ff ff78 	bl	8001e90 <queue_dequeue>
 8001fa0:	4603      	mov	r3, r0
 8001fa2:	4618      	mov	r0, r3
 8001fa4:	f7fe fdfc 	bl	8000ba0 <chSchReadyI>
          break;
 8001fa8:	bf00      	nop
        default:
          /* Nothing to do for other states.*/
          break;
        }
        break;
 8001faa:	e005      	b.n	8001fb8 <chMtxLockS+0x88>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8001fac:	9b03      	ldr	r3, [sp, #12]
 8001fae:	689a      	ldr	r2, [r3, #8]
 8001fb0:	9b02      	ldr	r3, [sp, #8]
 8001fb2:	689b      	ldr	r3, [r3, #8]
 8001fb4:	429a      	cmp	r2, r3
 8001fb6:	d3c9      	bcc.n	8001f4c <chMtxLockS+0x1c>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001fb8:	9b01      	ldr	r3, [sp, #4]
 8001fba:	9802      	ldr	r0, [sp, #8]
 8001fbc:	4619      	mov	r1, r3
 8001fbe:	f7ff ff27 	bl	8001e10 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 8001fc2:	9b02      	ldr	r3, [sp, #8]
 8001fc4:	9a01      	ldr	r2, [sp, #4]
 8001fc6:	621a      	str	r2, [r3, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001fc8:	2006      	movs	r0, #6
 8001fca:	f7fe fe11 	bl	8000bf0 <chSchGoSleepS>
 8001fce:	e009      	b.n	8001fe4 <chMtxLockS+0xb4>
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 8001fd0:	9b01      	ldr	r3, [sp, #4]
 8001fd2:	9a02      	ldr	r2, [sp, #8]
 8001fd4:	609a      	str	r2, [r3, #8]
    mp->m_next = ctp->p_mtxlist;
 8001fd6:	9b02      	ldr	r3, [sp, #8]
 8001fd8:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8001fda:	9b01      	ldr	r3, [sp, #4]
 8001fdc:	60da      	str	r2, [r3, #12]
    ctp->p_mtxlist = mp;
 8001fde:	9b02      	ldr	r3, [sp, #8]
 8001fe0:	9a01      	ldr	r2, [sp, #4]
 8001fe2:	639a      	str	r2, [r3, #56]	; 0x38
  }
}
 8001fe4:	b005      	add	sp, #20
 8001fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8001fea:	bf00      	nop
 8001fec:	20001bc8 	.word	0x20001bc8

08001ff0 <chMtxTryLock>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @api
 */
bool chMtxTryLock(mutex_t *mp) {
 8001ff0:	b500      	push	{lr}
 8001ff2:	b085      	sub	sp, #20
 8001ff4:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 8001ff6:	f7ff ff5b 	bl	8001eb0 <chSysLock>
  b = chMtxTryLockS(mp);
 8001ffa:	9801      	ldr	r0, [sp, #4]
 8001ffc:	f000 f810 	bl	8002020 <chMtxTryLockS>
 8002000:	4603      	mov	r3, r0
 8002002:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 8002006:	f7ff ff5b 	bl	8001ec0 <chSysUnlock>

  return b;
 800200a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800200e:	4618      	mov	r0, r3
 8002010:	b005      	add	sp, #20
 8002012:	f85d fb04 	ldr.w	pc, [sp], #4
 8002016:	bf00      	nop
 8002018:	f3af 8000 	nop.w
 800201c:	f3af 8000 	nop.w

08002020 <chMtxTryLockS>:
 * @retval true         if the mutex has been successfully acquired
 * @retval false        if the lock attempt failed.
 *
 * @sclass
 */
bool chMtxTryLockS(mutex_t *mp) {
 8002020:	b082      	sub	sp, #8
 8002022:	9001      	str	r0, [sp, #4]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->m_owner != NULL) {
 8002024:	9b01      	ldr	r3, [sp, #4]
 8002026:	689b      	ldr	r3, [r3, #8]
 8002028:	2b00      	cmp	r3, #0
 800202a:	d001      	beq.n	8002030 <chMtxTryLockS+0x10>
    if (mp->m_owner == currp) {
      mp->m_cnt++;
      return true;
    }
#endif
    return false;
 800202c:	2300      	movs	r3, #0
 800202e:	e00d      	b.n	800204c <chMtxTryLockS+0x2c>

  chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

  mp->m_cnt++;
#endif
  mp->m_owner = currp;
 8002030:	4b08      	ldr	r3, [pc, #32]	; (8002054 <chMtxTryLockS+0x34>)
 8002032:	699a      	ldr	r2, [r3, #24]
 8002034:	9b01      	ldr	r3, [sp, #4]
 8002036:	609a      	str	r2, [r3, #8]
  mp->m_next = currp->p_mtxlist;
 8002038:	4b06      	ldr	r3, [pc, #24]	; (8002054 <chMtxTryLockS+0x34>)
 800203a:	699b      	ldr	r3, [r3, #24]
 800203c:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800203e:	9b01      	ldr	r3, [sp, #4]
 8002040:	60da      	str	r2, [r3, #12]
  currp->p_mtxlist = mp;
 8002042:	4b04      	ldr	r3, [pc, #16]	; (8002054 <chMtxTryLockS+0x34>)
 8002044:	699b      	ldr	r3, [r3, #24]
 8002046:	9a01      	ldr	r2, [sp, #4]
 8002048:	639a      	str	r2, [r3, #56]	; 0x38
  return true;
 800204a:	2301      	movs	r3, #1
}
 800204c:	4618      	mov	r0, r3
 800204e:	b002      	add	sp, #8
 8002050:	4770      	bx	lr
 8002052:	bf00      	nop
 8002054:	20001bc8 	.word	0x20001bc8
 8002058:	f3af 8000 	nop.w
 800205c:	f3af 8000 	nop.w

08002060 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8002060:	b500      	push	{lr}
 8002062:	b087      	sub	sp, #28
 8002064:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002066:	4b26      	ldr	r3, [pc, #152]	; (8002100 <chMtxUnlock+0xa0>)
 8002068:	699b      	ldr	r3, [r3, #24]
 800206a:	9303      	str	r3, [sp, #12]
  mutex_t *lmp;

  chDbgCheck(mp != NULL);

  chSysLock();
 800206c:	f7ff ff20 	bl	8001eb0 <chSysLock>
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8002070:	9b01      	ldr	r3, [sp, #4]
 8002072:	68da      	ldr	r2, [r3, #12]
 8002074:	9b03      	ldr	r3, [sp, #12]
 8002076:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002078:	9801      	ldr	r0, [sp, #4]
 800207a:	f7ff ff29 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800207e:	4603      	mov	r3, r0
 8002080:	2b00      	cmp	r3, #0
 8002082:	d034      	beq.n	80020ee <chMtxUnlock+0x8e>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002084:	9b03      	ldr	r3, [sp, #12]
 8002086:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002088:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 800208a:	9b03      	ldr	r3, [sp, #12]
 800208c:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800208e:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 8002090:	e012      	b.n	80020b8 <chMtxUnlock+0x58>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002092:	9805      	ldr	r0, [sp, #20]
 8002094:	f7ff ff1c 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002098:	4603      	mov	r3, r0
 800209a:	2b00      	cmp	r3, #0
 800209c:	d009      	beq.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800209e:	9b05      	ldr	r3, [sp, #20]
 80020a0:	681b      	ldr	r3, [r3, #0]
 80020a2:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80020a4:	9b04      	ldr	r3, [sp, #16]
 80020a6:	429a      	cmp	r2, r3
 80020a8:	d903      	bls.n	80020b2 <chMtxUnlock+0x52>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 80020aa:	9b05      	ldr	r3, [sp, #20]
 80020ac:	681b      	ldr	r3, [r3, #0]
 80020ae:	689b      	ldr	r3, [r3, #8]
 80020b0:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 80020b2:	9b05      	ldr	r3, [sp, #20]
 80020b4:	68db      	ldr	r3, [r3, #12]
 80020b6:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 80020b8:	9b05      	ldr	r3, [sp, #20]
 80020ba:	2b00      	cmp	r3, #0
 80020bc:	d1e9      	bne.n	8002092 <chMtxUnlock+0x32>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 80020be:	9b03      	ldr	r3, [sp, #12]
 80020c0:	9a04      	ldr	r2, [sp, #16]
 80020c2:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 80020c4:	9b01      	ldr	r3, [sp, #4]
 80020c6:	4618      	mov	r0, r3
 80020c8:	f7ff feca 	bl	8001e60 <queue_fifo_remove>
 80020cc:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 80020ce:	9b01      	ldr	r3, [sp, #4]
 80020d0:	9a02      	ldr	r2, [sp, #8]
 80020d2:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 80020d4:	9b02      	ldr	r3, [sp, #8]
 80020d6:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80020d8:	9b01      	ldr	r3, [sp, #4]
 80020da:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 80020dc:	9b02      	ldr	r3, [sp, #8]
 80020de:	9a01      	ldr	r2, [sp, #4]
 80020e0:	639a      	str	r2, [r3, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 80020e2:	9802      	ldr	r0, [sp, #8]
 80020e4:	f7fe fd5c 	bl	8000ba0 <chSchReadyI>
      chSchRescheduleS();
 80020e8:	f7fe fe4a 	bl	8000d80 <chSchRescheduleS>
 80020ec:	e002      	b.n	80020f4 <chMtxUnlock+0x94>
    }
    else {
      mp->m_owner = NULL;
 80020ee:	9b01      	ldr	r3, [sp, #4]
 80020f0:	2200      	movs	r2, #0
 80020f2:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif

  chSysUnlock();
 80020f4:	f7ff fee4 	bl	8001ec0 <chSysUnlock>
}
 80020f8:	b007      	add	sp, #28
 80020fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80020fe:	bf00      	nop
 8002100:	20001bc8 	.word	0x20001bc8
 8002104:	f3af 8000 	nop.w
 8002108:	f3af 8000 	nop.w
 800210c:	f3af 8000 	nop.w

08002110 <chMtxUnlockS>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8002110:	b500      	push	{lr}
 8002112:	b087      	sub	sp, #28
 8002114:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002116:	4b23      	ldr	r3, [pc, #140]	; (80021a4 <chMtxUnlockS+0x94>)
 8002118:	699b      	ldr	r3, [r3, #24]
 800211a:	9303      	str	r3, [sp, #12]
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 800211c:	9b01      	ldr	r3, [sp, #4]
 800211e:	68da      	ldr	r2, [r3, #12]
 8002120:	9b03      	ldr	r3, [sp, #12]
 8002122:	639a      	str	r2, [r3, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8002124:	9801      	ldr	r0, [sp, #4]
 8002126:	f7ff fed3 	bl	8001ed0 <chMtxQueueNotEmptyS>
 800212a:	4603      	mov	r3, r0
 800212c:	2b00      	cmp	r3, #0
 800212e:	d032      	beq.n	8002196 <chMtxUnlockS+0x86>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8002130:	9b03      	ldr	r3, [sp, #12]
 8002132:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8002134:	9304      	str	r3, [sp, #16]
      lmp = ctp->p_mtxlist;
 8002136:	9b03      	ldr	r3, [sp, #12]
 8002138:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 800213a:	9305      	str	r3, [sp, #20]
      while (lmp != NULL) {
 800213c:	e012      	b.n	8002164 <chMtxUnlockS+0x54>
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 800213e:	9805      	ldr	r0, [sp, #20]
 8002140:	f7ff fec6 	bl	8001ed0 <chMtxQueueNotEmptyS>
 8002144:	4603      	mov	r3, r0
 8002146:	2b00      	cmp	r3, #0
 8002148:	d009      	beq.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 800214a:	9b05      	ldr	r3, [sp, #20]
 800214c:	681b      	ldr	r3, [r3, #0]
 800214e:	689a      	ldr	r2, [r3, #8]
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8002150:	9b04      	ldr	r3, [sp, #16]
 8002152:	429a      	cmp	r2, r3
 8002154:	d903      	bls.n	800215e <chMtxUnlockS+0x4e>
            (lmp->m_queue.p_next->p_prio > newprio)) {
          newprio = lmp->m_queue.p_next->p_prio;
 8002156:	9b05      	ldr	r3, [sp, #20]
 8002158:	681b      	ldr	r3, [r3, #0]
 800215a:	689b      	ldr	r3, [r3, #8]
 800215c:	9304      	str	r3, [sp, #16]
        }
        lmp = lmp->m_next;
 800215e:	9b05      	ldr	r3, [sp, #20]
 8002160:	68db      	ldr	r3, [r3, #12]
 8002162:	9305      	str	r3, [sp, #20]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8002164:	9b05      	ldr	r3, [sp, #20]
 8002166:	2b00      	cmp	r3, #0
 8002168:	d1e9      	bne.n	800213e <chMtxUnlockS+0x2e>
        lmp = lmp->m_next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 800216a:	9b03      	ldr	r3, [sp, #12]
 800216c:	9a04      	ldr	r2, [sp, #16]
 800216e:	609a      	str	r2, [r3, #8]
      /* Awakens the highest priority thread waiting for the unlocked mutex and
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
 8002170:	9b01      	ldr	r3, [sp, #4]
 8002172:	4618      	mov	r0, r3
 8002174:	f7ff fe74 	bl	8001e60 <queue_fifo_remove>
 8002178:	9002      	str	r0, [sp, #8]
      mp->m_owner = tp;
 800217a:	9b01      	ldr	r3, [sp, #4]
 800217c:	9a02      	ldr	r2, [sp, #8]
 800217e:	609a      	str	r2, [r3, #8]
      mp->m_next = tp->p_mtxlist;
 8002180:	9b02      	ldr	r3, [sp, #8]
 8002182:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8002184:	9b01      	ldr	r3, [sp, #4]
 8002186:	60da      	str	r2, [r3, #12]
      tp->p_mtxlist = mp;
 8002188:	9b02      	ldr	r3, [sp, #8]
 800218a:	9a01      	ldr	r2, [sp, #4]
 800218c:	639a      	str	r2, [r3, #56]	; 0x38
      (void) chSchReadyI(tp);
 800218e:	9802      	ldr	r0, [sp, #8]
 8002190:	f7fe fd06 	bl	8000ba0 <chSchReadyI>
 8002194:	e002      	b.n	800219c <chMtxUnlockS+0x8c>
    }
    else {
      mp->m_owner = NULL;
 8002196:	9b01      	ldr	r3, [sp, #4]
 8002198:	2200      	movs	r2, #0
 800219a:	609a      	str	r2, [r3, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 800219c:	b007      	add	sp, #28
 800219e:	f85d fb04 	ldr.w	pc, [sp], #4
 80021a2:	bf00      	nop
 80021a4:	20001bc8 	.word	0x20001bc8
 80021a8:	f3af 8000 	nop.w
 80021ac:	f3af 8000 	nop.w

080021b0 <chMtxUnlockAll>:
 *          this function does not have any overhead related to the priority
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
 80021b0:	b500      	push	{lr}
 80021b2:	b085      	sub	sp, #20
  thread_t *ctp = currp;
 80021b4:	4b1d      	ldr	r3, [pc, #116]	; (800222c <chMtxUnlockAll+0x7c>)
 80021b6:	699b      	ldr	r3, [r3, #24]
 80021b8:	9303      	str	r3, [sp, #12]

  chSysLock();
 80021ba:	f7ff fe79 	bl	8001eb0 <chSysLock>
  if (ctp->p_mtxlist != NULL) {
 80021be:	9b03      	ldr	r3, [sp, #12]
 80021c0:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021c2:	2b00      	cmp	r3, #0
 80021c4:	d02c      	beq.n	8002220 <chMtxUnlockAll+0x70>
    do {
      mutex_t *mp = ctp->p_mtxlist;
 80021c6:	9b03      	ldr	r3, [sp, #12]
 80021c8:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80021ca:	9302      	str	r3, [sp, #8]
      ctp->p_mtxlist = mp->m_next;
 80021cc:	9b02      	ldr	r3, [sp, #8]
 80021ce:	68da      	ldr	r2, [r3, #12]
 80021d0:	9b03      	ldr	r3, [sp, #12]
 80021d2:	639a      	str	r2, [r3, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 80021d4:	9802      	ldr	r0, [sp, #8]
 80021d6:	f7ff fe7b 	bl	8001ed0 <chMtxQueueNotEmptyS>
 80021da:	4603      	mov	r3, r0
 80021dc:	2b00      	cmp	r3, #0
 80021de:	d012      	beq.n	8002206 <chMtxUnlockAll+0x56>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->m_queue);
 80021e0:	9b02      	ldr	r3, [sp, #8]
 80021e2:	4618      	mov	r0, r3
 80021e4:	f7ff fe3c 	bl	8001e60 <queue_fifo_remove>
 80021e8:	9001      	str	r0, [sp, #4]
        mp->m_owner = tp;
 80021ea:	9b02      	ldr	r3, [sp, #8]
 80021ec:	9a01      	ldr	r2, [sp, #4]
 80021ee:	609a      	str	r2, [r3, #8]
        mp->m_next = tp->p_mtxlist;
 80021f0:	9b01      	ldr	r3, [sp, #4]
 80021f2:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80021f4:	9b02      	ldr	r3, [sp, #8]
 80021f6:	60da      	str	r2, [r3, #12]
        tp->p_mtxlist = mp;
 80021f8:	9b01      	ldr	r3, [sp, #4]
 80021fa:	9a02      	ldr	r2, [sp, #8]
 80021fc:	639a      	str	r2, [r3, #56]	; 0x38
        (void) chSchReadyI(tp);
 80021fe:	9801      	ldr	r0, [sp, #4]
 8002200:	f7fe fcce 	bl	8000ba0 <chSchReadyI>
 8002204:	e002      	b.n	800220c <chMtxUnlockAll+0x5c>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->m_cnt = (cnt_t)0;
#endif
        mp->m_owner = NULL;
 8002206:	9b02      	ldr	r3, [sp, #8]
 8002208:	2200      	movs	r2, #0
 800220a:	609a      	str	r2, [r3, #8]
      }
    } while (ctp->p_mtxlist != NULL);
 800220c:	9b03      	ldr	r3, [sp, #12]
 800220e:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 8002210:	2b00      	cmp	r3, #0
 8002212:	d1d8      	bne.n	80021c6 <chMtxUnlockAll+0x16>
    ctp->p_prio = ctp->p_realprio;
 8002214:	9b03      	ldr	r3, [sp, #12]
 8002216:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 8002218:	9b03      	ldr	r3, [sp, #12]
 800221a:	609a      	str	r2, [r3, #8]
    chSchRescheduleS();
 800221c:	f7fe fdb0 	bl	8000d80 <chSchRescheduleS>
  }
  chSysUnlock();
 8002220:	f7ff fe4e 	bl	8001ec0 <chSysUnlock>
}
 8002224:	b005      	add	sp, #20
 8002226:	f85d fb04 	ldr.w	pc, [sp], #4
 800222a:	bf00      	nop
 800222c:	20001bc8 	.word	0x20001bc8

08002230 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002230:	b082      	sub	sp, #8
 8002232:	2320      	movs	r3, #32
 8002234:	9301      	str	r3, [sp, #4]
 8002236:	9b01      	ldr	r3, [sp, #4]
 8002238:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800223c:	b002      	add	sp, #8
 800223e:	4770      	bx	lr

08002240 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002240:	b082      	sub	sp, #8
 8002242:	2300      	movs	r3, #0
 8002244:	9301      	str	r3, [sp, #4]
 8002246:	9b01      	ldr	r3, [sp, #4]
 8002248:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800224c:	b002      	add	sp, #8
 800224e:	4770      	bx	lr

08002250 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8002250:	b082      	sub	sp, #8
 8002252:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8002254:	9b01      	ldr	r3, [sp, #4]
 8002256:	9a01      	ldr	r2, [sp, #4]
 8002258:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 800225a:	9b01      	ldr	r3, [sp, #4]
 800225c:	9a01      	ldr	r2, [sp, #4]
 800225e:	605a      	str	r2, [r3, #4]
}
 8002260:	b002      	add	sp, #8
 8002262:	4770      	bx	lr
 8002264:	f3af 8000 	nop.w
 8002268:	f3af 8000 	nop.w
 800226c:	f3af 8000 	nop.w

08002270 <queue_notempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {
 8002270:	b082      	sub	sp, #8
 8002272:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8002274:	9b01      	ldr	r3, [sp, #4]
 8002276:	681a      	ldr	r2, [r3, #0]
 8002278:	9b01      	ldr	r3, [sp, #4]
 800227a:	429a      	cmp	r2, r3
 800227c:	bf0c      	ite	eq
 800227e:	2300      	moveq	r3, #0
 8002280:	2301      	movne	r3, #1
 8002282:	b2db      	uxtb	r3, r3
}
 8002284:	4618      	mov	r0, r3
 8002286:	b002      	add	sp, #8
 8002288:	4770      	bx	lr
 800228a:	bf00      	nop
 800228c:	f3af 8000 	nop.w

08002290 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 8002290:	b084      	sub	sp, #16
 8002292:	9001      	str	r0, [sp, #4]
 8002294:	9100      	str	r1, [sp, #0]

  thread_t *cp = (thread_t *)tqp;
 8002296:	9b00      	ldr	r3, [sp, #0]
 8002298:	9303      	str	r3, [sp, #12]
  do {
    cp = cp->p_next;
 800229a:	9b03      	ldr	r3, [sp, #12]
 800229c:	681b      	ldr	r3, [r3, #0]
 800229e:	9303      	str	r3, [sp, #12]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80022a0:	9a03      	ldr	r2, [sp, #12]
 80022a2:	9b00      	ldr	r3, [sp, #0]
 80022a4:	429a      	cmp	r2, r3
 80022a6:	d005      	beq.n	80022b4 <queue_prio_insert+0x24>
 80022a8:	9b03      	ldr	r3, [sp, #12]
 80022aa:	689a      	ldr	r2, [r3, #8]
 80022ac:	9b01      	ldr	r3, [sp, #4]
 80022ae:	689b      	ldr	r3, [r3, #8]
 80022b0:	429a      	cmp	r2, r3
 80022b2:	d2f2      	bcs.n	800229a <queue_prio_insert+0xa>
  tp->p_next = cp;
 80022b4:	9b01      	ldr	r3, [sp, #4]
 80022b6:	9a03      	ldr	r2, [sp, #12]
 80022b8:	601a      	str	r2, [r3, #0]
  tp->p_prev = cp->p_prev;
 80022ba:	9b03      	ldr	r3, [sp, #12]
 80022bc:	685a      	ldr	r2, [r3, #4]
 80022be:	9b01      	ldr	r3, [sp, #4]
 80022c0:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 80022c2:	9b01      	ldr	r3, [sp, #4]
 80022c4:	685b      	ldr	r3, [r3, #4]
 80022c6:	9a01      	ldr	r2, [sp, #4]
 80022c8:	601a      	str	r2, [r3, #0]
  cp->p_prev = tp;
 80022ca:	9b03      	ldr	r3, [sp, #12]
 80022cc:	9a01      	ldr	r2, [sp, #4]
 80022ce:	605a      	str	r2, [r3, #4]
}
 80022d0:	b004      	add	sp, #16
 80022d2:	4770      	bx	lr
 80022d4:	f3af 8000 	nop.w
 80022d8:	f3af 8000 	nop.w
 80022dc:	f3af 8000 	nop.w

080022e0 <queue_fifo_remove>:
  tp->p_prev = tqp->p_prev;
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 80022e0:	b084      	sub	sp, #16
 80022e2:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 80022e4:	9b01      	ldr	r3, [sp, #4]
 80022e6:	681b      	ldr	r3, [r3, #0]
 80022e8:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 80022ea:	9b03      	ldr	r3, [sp, #12]
 80022ec:	681a      	ldr	r2, [r3, #0]
 80022ee:	9b01      	ldr	r3, [sp, #4]
 80022f0:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80022f2:	9b01      	ldr	r3, [sp, #4]
 80022f4:	681b      	ldr	r3, [r3, #0]
 80022f6:	9a01      	ldr	r2, [sp, #4]
 80022f8:	605a      	str	r2, [r3, #4]

  return tp;
 80022fa:	9b03      	ldr	r3, [sp, #12]
}
 80022fc:	4618      	mov	r0, r3
 80022fe:	b004      	add	sp, #16
 8002300:	4770      	bx	lr
 8002302:	bf00      	nop
 8002304:	f3af 8000 	nop.w
 8002308:	f3af 8000 	nop.w
 800230c:	f3af 8000 	nop.w

08002310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002310:	b508      	push	{r3, lr}

  port_lock();
 8002312:	f7ff ff8d 	bl	8002230 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002316:	bd08      	pop	{r3, pc}
 8002318:	f3af 8000 	nop.w
 800231c:	f3af 8000 	nop.w

08002320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002322:	f7ff ff8d 	bl	8002240 <port_unlock>
}
 8002326:	bd08      	pop	{r3, pc}
 8002328:	f3af 8000 	nop.w
 800232c:	f3af 8000 	nop.w

08002330 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 8002330:	4b01      	ldr	r3, [pc, #4]	; (8002338 <chThdGetSelfX+0x8>)
 8002332:	699b      	ldr	r3, [r3, #24]
}
 8002334:	4618      	mov	r0, r3
 8002336:	4770      	bx	lr
 8002338:	20001bc8 	.word	0x20001bc8
 800233c:	f3af 8000 	nop.w

08002340 <chMtxGetNextMutexS>:
 * @return              A pointer to the next mutex in the stack.
 * @retval NULL         if the stack is empty.
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {
 8002340:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_mtxlist;
 8002342:	f7ff fff5 	bl	8002330 <chThdGetSelfX>
 8002346:	4603      	mov	r3, r0
 8002348:	6b9b      	ldr	r3, [r3, #56]	; 0x38
}
 800234a:	4618      	mov	r0, r3
 800234c:	bd08      	pop	{r3, pc}
 800234e:	bf00      	nop

08002350 <chCondObjectInit>:
 *
 * @param[out] cp       pointer to a @p condition_variable_t structure
 *
 * @init
 */
void chCondObjectInit(condition_variable_t *cp) {
 8002350:	b500      	push	{lr}
 8002352:	b083      	sub	sp, #12
 8002354:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  queue_init(&cp->c_queue);
 8002356:	9b01      	ldr	r3, [sp, #4]
 8002358:	4618      	mov	r0, r3
 800235a:	f7ff ff79 	bl	8002250 <queue_init>
}
 800235e:	b003      	add	sp, #12
 8002360:	f85d fb04 	ldr.w	pc, [sp], #4
 8002364:	f3af 8000 	nop.w
 8002368:	f3af 8000 	nop.w
 800236c:	f3af 8000 	nop.w

08002370 <chCondSignal>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8002370:	b500      	push	{lr}
 8002372:	b083      	sub	sp, #12
 8002374:	9001      	str	r0, [sp, #4]

  chDbgCheck(cp != NULL);

  chSysLock();
 8002376:	f7ff ffcb 	bl	8002310 <chSysLock>
  if (queue_notempty(&cp->c_queue)) {
 800237a:	9b01      	ldr	r3, [sp, #4]
 800237c:	4618      	mov	r0, r3
 800237e:	f7ff ff77 	bl	8002270 <queue_notempty>
 8002382:	4603      	mov	r3, r0
 8002384:	2b00      	cmp	r3, #0
 8002386:	d008      	beq.n	800239a <chCondSignal+0x2a>
    chSchWakeupS(queue_fifo_remove(&cp->c_queue), MSG_OK);
 8002388:	9b01      	ldr	r3, [sp, #4]
 800238a:	4618      	mov	r0, r3
 800238c:	f7ff ffa8 	bl	80022e0 <queue_fifo_remove>
 8002390:	4603      	mov	r3, r0
 8002392:	4618      	mov	r0, r3
 8002394:	2100      	movs	r1, #0
 8002396:	f7fe fccb 	bl	8000d30 <chSchWakeupS>
  }
  chSysUnlock();
 800239a:	f7ff ffc1 	bl	8002320 <chSysUnlock>
}
 800239e:	b003      	add	sp, #12
 80023a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80023a4:	f3af 8000 	nop.w
 80023a8:	f3af 8000 	nop.w
 80023ac:	f3af 8000 	nop.w

080023b0 <chCondSignalI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 80023b0:	b500      	push	{lr}
 80023b2:	b085      	sub	sp, #20
 80023b4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->c_queue)) {
 80023b6:	9b01      	ldr	r3, [sp, #4]
 80023b8:	4618      	mov	r0, r3
 80023ba:	f7ff ff59 	bl	8002270 <queue_notempty>
 80023be:	4603      	mov	r3, r0
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	d00a      	beq.n	80023da <chCondSignalI+0x2a>
    thread_t *tp = queue_fifo_remove(&cp->c_queue);
 80023c4:	9b01      	ldr	r3, [sp, #4]
 80023c6:	4618      	mov	r0, r3
 80023c8:	f7ff ff8a 	bl	80022e0 <queue_fifo_remove>
 80023cc:	9003      	str	r0, [sp, #12]
    tp->p_u.rdymsg = MSG_OK;
 80023ce:	9b03      	ldr	r3, [sp, #12]
 80023d0:	2200      	movs	r2, #0
 80023d2:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 80023d4:	9803      	ldr	r0, [sp, #12]
 80023d6:	f7fe fbe3 	bl	8000ba0 <chSchReadyI>
  }
}
 80023da:	b005      	add	sp, #20
 80023dc:	f85d fb04 	ldr.w	pc, [sp], #4

080023e0 <chCondBroadcast>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondBroadcast(condition_variable_t *cp) {
 80023e0:	b500      	push	{lr}
 80023e2:	b083      	sub	sp, #12
 80023e4:	9001      	str	r0, [sp, #4]

  chSysLock();
 80023e6:	f7ff ff93 	bl	8002310 <chSysLock>
  chCondBroadcastI(cp);
 80023ea:	9801      	ldr	r0, [sp, #4]
 80023ec:	f000 f808 	bl	8002400 <chCondBroadcastI>
  chSchRescheduleS();
 80023f0:	f7fe fcc6 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80023f4:	f7ff ff94 	bl	8002320 <chSysUnlock>
}
 80023f8:	b003      	add	sp, #12
 80023fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80023fe:	bf00      	nop

08002400 <chCondBroadcastI>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondBroadcastI(condition_variable_t *cp) {
 8002400:	b500      	push	{lr}
 8002402:	b083      	sub	sp, #12
 8002404:	9001      	str	r0, [sp, #4]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002406:	e00b      	b.n	8002420 <chCondBroadcastI+0x20>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
 8002408:	9b01      	ldr	r3, [sp, #4]
 800240a:	4618      	mov	r0, r3
 800240c:	f7ff ff68 	bl	80022e0 <queue_fifo_remove>
 8002410:	4603      	mov	r3, r0
 8002412:	4618      	mov	r0, r3
 8002414:	f7fe fbc4 	bl	8000ba0 <chSchReadyI>
 8002418:	4603      	mov	r3, r0
 800241a:	f06f 0201 	mvn.w	r2, #1
 800241e:	621a      	str	r2, [r3, #32]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->c_queue)) {
 8002420:	9b01      	ldr	r3, [sp, #4]
 8002422:	4618      	mov	r0, r3
 8002424:	f7ff ff24 	bl	8002270 <queue_notempty>
 8002428:	4603      	mov	r3, r0
 800242a:	2b00      	cmp	r3, #0
 800242c:	d1ec      	bne.n	8002408 <chCondBroadcastI+0x8>
    chSchReadyI(queue_fifo_remove(&cp->c_queue))->p_u.rdymsg = MSG_RESET;
  }
}
 800242e:	b003      	add	sp, #12
 8002430:	f85d fb04 	ldr.w	pc, [sp], #4
 8002434:	f3af 8000 	nop.w
 8002438:	f3af 8000 	nop.w
 800243c:	f3af 8000 	nop.w

08002440 <chCondWait>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @api
 */
msg_t chCondWait(condition_variable_t *cp) {
 8002440:	b500      	push	{lr}
 8002442:	b085      	sub	sp, #20
 8002444:	9001      	str	r0, [sp, #4]
  msg_t msg;

  chSysLock();
 8002446:	f7ff ff63 	bl	8002310 <chSysLock>
  msg = chCondWaitS(cp);
 800244a:	9801      	ldr	r0, [sp, #4]
 800244c:	f000 f808 	bl	8002460 <chCondWaitS>
 8002450:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8002452:	f7ff ff65 	bl	8002320 <chSysUnlock>
  return msg;
 8002456:	9b03      	ldr	r3, [sp, #12]
}
 8002458:	4618      	mov	r0, r3
 800245a:	b005      	add	sp, #20
 800245c:	f85d fb04 	ldr.w	pc, [sp], #4

08002460 <chCondWaitS>:
 * @retval MSG_RESET    if the condition variable has been signaled using
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
 8002460:	b500      	push	{lr}
 8002462:	b087      	sub	sp, #28
 8002464:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002466:	4b0f      	ldr	r3, [pc, #60]	; (80024a4 <chCondWaitS+0x44>)
 8002468:	699b      	ldr	r3, [r3, #24]
 800246a:	9305      	str	r3, [sp, #20]
  chDbgCheckClassS();
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 800246c:	f7ff ff68 	bl	8002340 <chMtxGetNextMutexS>
 8002470:	9004      	str	r0, [sp, #16]
  chMtxUnlockS(mp);
 8002472:	9804      	ldr	r0, [sp, #16]
 8002474:	f7ff fe4c 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->p_u.wtobjp = cp;
 8002478:	9b05      	ldr	r3, [sp, #20]
 800247a:	9a01      	ldr	r2, [sp, #4]
 800247c:	621a      	str	r2, [r3, #32]
  queue_prio_insert(ctp, &cp->c_queue);
 800247e:	9b01      	ldr	r3, [sp, #4]
 8002480:	9805      	ldr	r0, [sp, #20]
 8002482:	4619      	mov	r1, r3
 8002484:	f7ff ff04 	bl	8002290 <queue_prio_insert>
  chSchGoSleepS(CH_STATE_WTCOND);
 8002488:	2007      	movs	r0, #7
 800248a:	f7fe fbb1 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 800248e:	9b05      	ldr	r3, [sp, #20]
 8002490:	6a1b      	ldr	r3, [r3, #32]
 8002492:	9303      	str	r3, [sp, #12]
  chMtxLockS(mp);
 8002494:	9804      	ldr	r0, [sp, #16]
 8002496:	f7ff fd4b 	bl	8001f30 <chMtxLockS>

  return msg;
 800249a:	9b03      	ldr	r3, [sp, #12]
}
 800249c:	4618      	mov	r0, r3
 800249e:	b007      	add	sp, #28
 80024a0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024a4:	20001bc8 	.word	0x20001bc8
 80024a8:	f3af 8000 	nop.w
 80024ac:	f3af 8000 	nop.w

080024b0 <chCondWaitTimeout>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @api
 */
msg_t chCondWaitTimeout(condition_variable_t *cp, systime_t time) {
 80024b0:	b500      	push	{lr}
 80024b2:	b085      	sub	sp, #20
 80024b4:	9001      	str	r0, [sp, #4]
 80024b6:	9100      	str	r1, [sp, #0]
  msg_t msg;

  chSysLock();
 80024b8:	f7ff ff2a 	bl	8002310 <chSysLock>
  msg = chCondWaitTimeoutS(cp, time);
 80024bc:	9801      	ldr	r0, [sp, #4]
 80024be:	9900      	ldr	r1, [sp, #0]
 80024c0:	f000 f80e 	bl	80024e0 <chCondWaitTimeoutS>
 80024c4:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 80024c6:	f7ff ff2b 	bl	8002320 <chSysUnlock>

  return msg;
 80024ca:	9b03      	ldr	r3, [sp, #12]
}
 80024cc:	4618      	mov	r0, r3
 80024ce:	b005      	add	sp, #20
 80024d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80024d4:	f3af 8000 	nop.w
 80024d8:	f3af 8000 	nop.w
 80024dc:	f3af 8000 	nop.w

080024e0 <chCondWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the condition variable has not been signaled within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chCondWaitTimeoutS(condition_variable_t *cp, systime_t time) {
 80024e0:	b500      	push	{lr}
 80024e2:	b085      	sub	sp, #20
 80024e4:	9001      	str	r0, [sp, #4]
 80024e6:	9100      	str	r1, [sp, #0]
  chDbgCheckClassS();
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->p_mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
 80024e8:	f7ff ff2a 	bl	8002340 <chMtxGetNextMutexS>
 80024ec:	9003      	str	r0, [sp, #12]
  chMtxUnlockS(mp);
 80024ee:	9803      	ldr	r0, [sp, #12]
 80024f0:	f7ff fe0e 	bl	8002110 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->p_u.wtobjp = cp;
 80024f4:	4b0d      	ldr	r3, [pc, #52]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024f6:	699b      	ldr	r3, [r3, #24]
 80024f8:	9a01      	ldr	r2, [sp, #4]
 80024fa:	621a      	str	r2, [r3, #32]
  queue_prio_insert(currp, &cp->c_queue);
 80024fc:	4b0b      	ldr	r3, [pc, #44]	; (800252c <chCondWaitTimeoutS+0x4c>)
 80024fe:	699a      	ldr	r2, [r3, #24]
 8002500:	9b01      	ldr	r3, [sp, #4]
 8002502:	4610      	mov	r0, r2
 8002504:	4619      	mov	r1, r3
 8002506:	f7ff fec3 	bl	8002290 <queue_prio_insert>
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
 800250a:	2007      	movs	r0, #7
 800250c:	9900      	ldr	r1, [sp, #0]
 800250e:	f7fe fbd7 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002512:	9002      	str	r0, [sp, #8]
  if (msg != MSG_TIMEOUT) {
 8002514:	9b02      	ldr	r3, [sp, #8]
 8002516:	f1b3 3fff 	cmp.w	r3, #4294967295
 800251a:	d002      	beq.n	8002522 <chCondWaitTimeoutS+0x42>
    chMtxLockS(mp);
 800251c:	9803      	ldr	r0, [sp, #12]
 800251e:	f7ff fd07 	bl	8001f30 <chMtxLockS>
  }

  return msg;
 8002522:	9b02      	ldr	r3, [sp, #8]
}
 8002524:	4618      	mov	r0, r3
 8002526:	b005      	add	sp, #20
 8002528:	f85d fb04 	ldr.w	pc, [sp], #4
 800252c:	20001bc8 	.word	0x20001bc8

08002530 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002530:	b082      	sub	sp, #8
 8002532:	2320      	movs	r3, #32
 8002534:	9301      	str	r3, [sp, #4]
 8002536:	9b01      	ldr	r3, [sp, #4]
 8002538:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800253c:	b002      	add	sp, #8
 800253e:	4770      	bx	lr

08002540 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002540:	b082      	sub	sp, #8
 8002542:	2300      	movs	r3, #0
 8002544:	9301      	str	r3, [sp, #4]
 8002546:	9b01      	ldr	r3, [sp, #4]
 8002548:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800254c:	b002      	add	sp, #8
 800254e:	4770      	bx	lr

08002550 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002550:	b508      	push	{r3, lr}

  port_lock();
 8002552:	f7ff ffed 	bl	8002530 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002556:	bd08      	pop	{r3, pc}
 8002558:	f3af 8000 	nop.w
 800255c:	f3af 8000 	nop.w

08002560 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002560:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002562:	f7ff ffed 	bl	8002540 <port_unlock>
}
 8002566:	bd08      	pop	{r3, pc}
 8002568:	f3af 8000 	nop.w
 800256c:	f3af 8000 	nop.w

08002570 <chEvtRegisterMaskWithFlags>:
 * @api
 */
void chEvtRegisterMaskWithFlags(event_source_t *esp,
                                event_listener_t *elp,
                                eventmask_t events,
                                eventflags_t wflags) {
 8002570:	b500      	push	{lr}
 8002572:	b085      	sub	sp, #20
 8002574:	9003      	str	r0, [sp, #12]
 8002576:	9102      	str	r1, [sp, #8]
 8002578:	9201      	str	r2, [sp, #4]
 800257a:	9300      	str	r3, [sp, #0]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
 800257c:	f7ff ffe8 	bl	8002550 <chSysLock>
  elp->el_next     = esp->es_next;
 8002580:	9b03      	ldr	r3, [sp, #12]
 8002582:	681a      	ldr	r2, [r3, #0]
 8002584:	9b02      	ldr	r3, [sp, #8]
 8002586:	601a      	str	r2, [r3, #0]
  esp->es_next     = elp;
 8002588:	9b03      	ldr	r3, [sp, #12]
 800258a:	9a02      	ldr	r2, [sp, #8]
 800258c:	601a      	str	r2, [r3, #0]
  elp->el_listener = currp;
 800258e:	4b09      	ldr	r3, [pc, #36]	; (80025b4 <chEvtRegisterMaskWithFlags+0x44>)
 8002590:	699a      	ldr	r2, [r3, #24]
 8002592:	9b02      	ldr	r3, [sp, #8]
 8002594:	605a      	str	r2, [r3, #4]
  elp->el_events   = events;
 8002596:	9b02      	ldr	r3, [sp, #8]
 8002598:	9a01      	ldr	r2, [sp, #4]
 800259a:	609a      	str	r2, [r3, #8]
  elp->el_flags    = (eventflags_t)0;
 800259c:	9b02      	ldr	r3, [sp, #8]
 800259e:	2200      	movs	r2, #0
 80025a0:	60da      	str	r2, [r3, #12]
  elp->el_wflags   = wflags;
 80025a2:	9b02      	ldr	r3, [sp, #8]
 80025a4:	9a00      	ldr	r2, [sp, #0]
 80025a6:	611a      	str	r2, [r3, #16]
  chSysUnlock();
 80025a8:	f7ff ffda 	bl	8002560 <chSysUnlock>
}
 80025ac:	b005      	add	sp, #20
 80025ae:	f85d fb04 	ldr.w	pc, [sp], #4
 80025b2:	bf00      	nop
 80025b4:	20001bc8 	.word	0x20001bc8
 80025b8:	f3af 8000 	nop.w
 80025bc:	f3af 8000 	nop.w

080025c0 <chEvtUnregister>:
 * @param[in] esp       pointer to the  @p event_source_t structure
 * @param[in] elp       pointer to the @p event_listener_t structure
 *
 * @api
 */
void chEvtUnregister(event_source_t *esp, event_listener_t *elp) {
 80025c0:	b500      	push	{lr}
 80025c2:	b085      	sub	sp, #20
 80025c4:	9001      	str	r0, [sp, #4]
 80025c6:	9100      	str	r1, [sp, #0]
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 80025c8:	9b01      	ldr	r3, [sp, #4]
 80025ca:	9303      	str	r3, [sp, #12]
  /*lint -restore*/
  chSysLock();
 80025cc:	f7ff ffc0 	bl	8002550 <chSysLock>
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025d0:	e00c      	b.n	80025ec <chEvtUnregister+0x2c>
  /*lint -restore*/
    if (p->el_next == elp) {
 80025d2:	9b03      	ldr	r3, [sp, #12]
 80025d4:	681a      	ldr	r2, [r3, #0]
 80025d6:	9b00      	ldr	r3, [sp, #0]
 80025d8:	429a      	cmp	r2, r3
 80025da:	d104      	bne.n	80025e6 <chEvtUnregister+0x26>
      p->el_next = elp->el_next;
 80025dc:	9b00      	ldr	r3, [sp, #0]
 80025de:	681a      	ldr	r2, [r3, #0]
 80025e0:	9b03      	ldr	r3, [sp, #12]
 80025e2:	601a      	str	r2, [r3, #0]
      break;
 80025e4:	e007      	b.n	80025f6 <chEvtUnregister+0x36>
    }
    p = p->el_next;
 80025e6:	9b03      	ldr	r3, [sp, #12]
 80025e8:	681b      	ldr	r3, [r3, #0]
 80025ea:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->el_next != (event_listener_t *)esp) {
 80025ec:	9b03      	ldr	r3, [sp, #12]
 80025ee:	681a      	ldr	r2, [r3, #0]
 80025f0:	9b01      	ldr	r3, [sp, #4]
 80025f2:	429a      	cmp	r2, r3
 80025f4:	d1ed      	bne.n	80025d2 <chEvtUnregister+0x12>
      p->el_next = elp->el_next;
      break;
    }
    p = p->el_next;
  }
  chSysUnlock();
 80025f6:	f7ff ffb3 	bl	8002560 <chSysUnlock>
}
 80025fa:	b005      	add	sp, #20
 80025fc:	f85d fb04 	ldr.w	pc, [sp], #4

08002600 <chEvtGetAndClearEvents>:
 * @param[in] events    the events to be cleared
 * @return              The pending events that were cleared.
 *
 * @api
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
 8002600:	b500      	push	{lr}
 8002602:	b085      	sub	sp, #20
 8002604:	9001      	str	r0, [sp, #4]
  eventmask_t m;

  chSysLock();
 8002606:	f7ff ffa3 	bl	8002550 <chSysLock>
  m = currp->p_epending & events;
 800260a:	4b0b      	ldr	r3, [pc, #44]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800260c:	699b      	ldr	r3, [r3, #24]
 800260e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002610:	9b01      	ldr	r3, [sp, #4]
 8002612:	4013      	ands	r3, r2
 8002614:	9303      	str	r3, [sp, #12]
  currp->p_epending &= ~events;
 8002616:	4b08      	ldr	r3, [pc, #32]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 8002618:	699b      	ldr	r3, [r3, #24]
 800261a:	4a07      	ldr	r2, [pc, #28]	; (8002638 <chEvtGetAndClearEvents+0x38>)
 800261c:	6992      	ldr	r2, [r2, #24]
 800261e:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002620:	9a01      	ldr	r2, [sp, #4]
 8002622:	43d2      	mvns	r2, r2
 8002624:	400a      	ands	r2, r1
 8002626:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002628:	f7ff ff9a 	bl	8002560 <chSysUnlock>

  return m;
 800262c:	9b03      	ldr	r3, [sp, #12]
}
 800262e:	4618      	mov	r0, r3
 8002630:	b005      	add	sp, #20
 8002632:	f85d fb04 	ldr.w	pc, [sp], #4
 8002636:	bf00      	nop
 8002638:	20001bc8 	.word	0x20001bc8
 800263c:	f3af 8000 	nop.w

08002640 <chEvtAddEvents>:
 * @param[in] events    the events to be added
 * @return              The current pending events.
 *
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {
 8002640:	b500      	push	{lr}
 8002642:	b083      	sub	sp, #12
 8002644:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002646:	f7ff ff83 	bl	8002550 <chSysLock>
  currp->p_epending |= events;
 800264a:	4b09      	ldr	r3, [pc, #36]	; (8002670 <chEvtAddEvents+0x30>)
 800264c:	699b      	ldr	r3, [r3, #24]
 800264e:	4a08      	ldr	r2, [pc, #32]	; (8002670 <chEvtAddEvents+0x30>)
 8002650:	6992      	ldr	r2, [r2, #24]
 8002652:	6b51      	ldr	r1, [r2, #52]	; 0x34
 8002654:	9a01      	ldr	r2, [sp, #4]
 8002656:	430a      	orrs	r2, r1
 8002658:	635a      	str	r2, [r3, #52]	; 0x34
  events = currp->p_epending;
 800265a:	4b05      	ldr	r3, [pc, #20]	; (8002670 <chEvtAddEvents+0x30>)
 800265c:	699b      	ldr	r3, [r3, #24]
 800265e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8002660:	9301      	str	r3, [sp, #4]
  chSysUnlock();
 8002662:	f7ff ff7d 	bl	8002560 <chSysUnlock>

  return events;
 8002666:	9b01      	ldr	r3, [sp, #4]
}
 8002668:	4618      	mov	r0, r3
 800266a:	b003      	add	sp, #12
 800266c:	f85d fb04 	ldr.w	pc, [sp], #4
 8002670:	20001bc8 	.word	0x20001bc8
 8002674:	f3af 8000 	nop.w
 8002678:	f3af 8000 	nop.w
 800267c:	f3af 8000 	nop.w

08002680 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8002680:	b500      	push	{lr}
 8002682:	b085      	sub	sp, #20
 8002684:	9001      	str	r0, [sp, #4]
 8002686:	9100      	str	r1, [sp, #0]
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8002688:	9b01      	ldr	r3, [sp, #4]
 800268a:	681b      	ldr	r3, [r3, #0]
 800268c:	9303      	str	r3, [sp, #12]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800268e:	e01a      	b.n	80026c6 <chEvtBroadcastFlagsI+0x46>
  /*lint -restore*/
    elp->el_flags |= flags;
 8002690:	9b03      	ldr	r3, [sp, #12]
 8002692:	68da      	ldr	r2, [r3, #12]
 8002694:	9b00      	ldr	r3, [sp, #0]
 8002696:	431a      	orrs	r2, r3
 8002698:	9b03      	ldr	r3, [sp, #12]
 800269a:	60da      	str	r2, [r3, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 800269c:	9b00      	ldr	r3, [sp, #0]
 800269e:	2b00      	cmp	r3, #0
 80026a0:	d006      	beq.n	80026b0 <chEvtBroadcastFlagsI+0x30>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 80026a2:	9b03      	ldr	r3, [sp, #12]
 80026a4:	68da      	ldr	r2, [r3, #12]
 80026a6:	9b03      	ldr	r3, [sp, #12]
 80026a8:	691b      	ldr	r3, [r3, #16]
 80026aa:	4013      	ands	r3, r2
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 80026ac:	2b00      	cmp	r3, #0
 80026ae:	d007      	beq.n	80026c0 <chEvtBroadcastFlagsI+0x40>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 80026b0:	9b03      	ldr	r3, [sp, #12]
 80026b2:	685a      	ldr	r2, [r3, #4]
 80026b4:	9b03      	ldr	r3, [sp, #12]
 80026b6:	689b      	ldr	r3, [r3, #8]
 80026b8:	4610      	mov	r0, r2
 80026ba:	4619      	mov	r1, r3
 80026bc:	f000 f840 	bl	8002740 <chEvtSignalI>
    }
    elp = elp->el_next;
 80026c0:	9b03      	ldr	r3, [sp, #12]
 80026c2:	681b      	ldr	r3, [r3, #0]
 80026c4:	9303      	str	r3, [sp, #12]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 80026c6:	9a03      	ldr	r2, [sp, #12]
 80026c8:	9b01      	ldr	r3, [sp, #4]
 80026ca:	429a      	cmp	r2, r3
 80026cc:	d1e0      	bne.n	8002690 <chEvtBroadcastFlagsI+0x10>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
  }
}
 80026ce:	b005      	add	sp, #20
 80026d0:	f85d fb04 	ldr.w	pc, [sp], #4
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <chEvtGetAndClearFlags>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @api
 */
eventflags_t chEvtGetAndClearFlags(event_listener_t *elp) {
 80026e0:	b500      	push	{lr}
 80026e2:	b085      	sub	sp, #20
 80026e4:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  chSysLock();
 80026e6:	f7ff ff33 	bl	8002550 <chSysLock>
  flags = elp->el_flags;
 80026ea:	9b01      	ldr	r3, [sp, #4]
 80026ec:	68db      	ldr	r3, [r3, #12]
 80026ee:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80026f0:	9b01      	ldr	r3, [sp, #4]
 80026f2:	2200      	movs	r2, #0
 80026f4:	60da      	str	r2, [r3, #12]
  chSysUnlock();
 80026f6:	f7ff ff33 	bl	8002560 <chSysUnlock>

  return flags;
 80026fa:	9b03      	ldr	r3, [sp, #12]
}
 80026fc:	4618      	mov	r0, r3
 80026fe:	b005      	add	sp, #20
 8002700:	f85d fb04 	ldr.w	pc, [sp], #4
 8002704:	f3af 8000 	nop.w
 8002708:	f3af 8000 	nop.w
 800270c:	f3af 8000 	nop.w

08002710 <chEvtSignal>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @api
 */
void chEvtSignal(thread_t *tp, eventmask_t events) {
 8002710:	b500      	push	{lr}
 8002712:	b083      	sub	sp, #12
 8002714:	9001      	str	r0, [sp, #4]
 8002716:	9100      	str	r1, [sp, #0]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002718:	f7ff ff1a 	bl	8002550 <chSysLock>
  chEvtSignalI(tp, events);
 800271c:	9801      	ldr	r0, [sp, #4]
 800271e:	9900      	ldr	r1, [sp, #0]
 8002720:	f000 f80e 	bl	8002740 <chEvtSignalI>
  chSchRescheduleS();
 8002724:	f7fe fb2c 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002728:	f7ff ff1a 	bl	8002560 <chSysUnlock>
}
 800272c:	b003      	add	sp, #12
 800272e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002732:	bf00      	nop
 8002734:	f3af 8000 	nop.w
 8002738:	f3af 8000 	nop.w
 800273c:	f3af 8000 	nop.w

08002740 <chEvtSignalI>:
 * @param[in] tp        the thread to be signaled
 * @param[in] events    the events set to be ORed
 *
 * @iclass
 */
void chEvtSignalI(thread_t *tp, eventmask_t events) {
 8002740:	b500      	push	{lr}
 8002742:	b083      	sub	sp, #12
 8002744:	9001      	str	r0, [sp, #4]
 8002746:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8002748:	9b01      	ldr	r3, [sp, #4]
 800274a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800274c:	9b00      	ldr	r3, [sp, #0]
 800274e:	431a      	orrs	r2, r3
 8002750:	9b01      	ldr	r3, [sp, #4]
 8002752:	635a      	str	r2, [r3, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002754:	9b01      	ldr	r3, [sp, #4]
 8002756:	7f1b      	ldrb	r3, [r3, #28]
 8002758:	2b0a      	cmp	r3, #10
 800275a:	d106      	bne.n	800276a <chEvtSignalI+0x2a>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800275c:	9b01      	ldr	r3, [sp, #4]
 800275e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002760:	9b01      	ldr	r3, [sp, #4]
 8002762:	6a1b      	ldr	r3, [r3, #32]
 8002764:	4013      	ands	r3, r2
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8002766:	2b00      	cmp	r3, #0
 8002768:	d10c      	bne.n	8002784 <chEvtSignalI+0x44>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 800276a:	9b01      	ldr	r3, [sp, #4]
 800276c:	7f1b      	ldrb	r3, [r3, #28]
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 800276e:	2b0b      	cmp	r3, #11
 8002770:	d10e      	bne.n	8002790 <chEvtSignalI+0x50>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8002772:	9b01      	ldr	r3, [sp, #4]
 8002774:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002776:	9b01      	ldr	r3, [sp, #4]
 8002778:	6a1b      	ldr	r3, [r3, #32]
 800277a:	401a      	ands	r2, r3
 800277c:	9b01      	ldr	r3, [sp, #4]
 800277e:	6a1b      	ldr	r3, [r3, #32]

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8002780:	429a      	cmp	r2, r3
 8002782:	d105      	bne.n	8002790 <chEvtSignalI+0x50>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8002784:	9b01      	ldr	r3, [sp, #4]
 8002786:	2200      	movs	r2, #0
 8002788:	621a      	str	r2, [r3, #32]
    (void) chSchReadyI(tp);
 800278a:	9801      	ldr	r0, [sp, #4]
 800278c:	f7fe fa08 	bl	8000ba0 <chSchReadyI>
  }
}
 8002790:	b003      	add	sp, #12
 8002792:	f85d fb04 	ldr.w	pc, [sp], #4
 8002796:	bf00      	nop
 8002798:	f3af 8000 	nop.w
 800279c:	f3af 8000 	nop.w

080027a0 <chEvtBroadcastFlags>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {
 80027a0:	b500      	push	{lr}
 80027a2:	b083      	sub	sp, #12
 80027a4:	9001      	str	r0, [sp, #4]
 80027a6:	9100      	str	r1, [sp, #0]

  chSysLock();
 80027a8:	f7ff fed2 	bl	8002550 <chSysLock>
  chEvtBroadcastFlagsI(esp, flags);
 80027ac:	9801      	ldr	r0, [sp, #4]
 80027ae:	9900      	ldr	r1, [sp, #0]
 80027b0:	f7ff ff66 	bl	8002680 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 80027b4:	f7fe fae4 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 80027b8:	f7ff fed2 	bl	8002560 <chSysUnlock>
}
 80027bc:	b003      	add	sp, #12
 80027be:	f85d fb04 	ldr.w	pc, [sp], #4
 80027c2:	bf00      	nop
 80027c4:	f3af 8000 	nop.w
 80027c8:	f3af 8000 	nop.w
 80027cc:	f3af 8000 	nop.w

080027d0 <chEvtGetAndClearFlagsI>:
 * @return              The flags added to the listener by the associated
 *                      event source.
 *
 * @iclass
 */
eventflags_t chEvtGetAndClearFlagsI(event_listener_t *elp) {
 80027d0:	b084      	sub	sp, #16
 80027d2:	9001      	str	r0, [sp, #4]
  eventflags_t flags;

  flags = elp->el_flags;
 80027d4:	9b01      	ldr	r3, [sp, #4]
 80027d6:	68db      	ldr	r3, [r3, #12]
 80027d8:	9303      	str	r3, [sp, #12]
  elp->el_flags = (eventflags_t)0;
 80027da:	9b01      	ldr	r3, [sp, #4]
 80027dc:	2200      	movs	r2, #0
 80027de:	60da      	str	r2, [r3, #12]

  return flags;
 80027e0:	9b03      	ldr	r3, [sp, #12]
}
 80027e2:	4618      	mov	r0, r3
 80027e4:	b004      	add	sp, #16
 80027e6:	4770      	bx	lr
 80027e8:	f3af 8000 	nop.w
 80027ec:	f3af 8000 	nop.w

080027f0 <chEvtDispatch>:
 * @param[in] handlers  an array of @p evhandler_t. The array must have size
 *                      equal to the number of bits in eventmask_t.
 *
 * @api
 */
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
 80027f0:	b500      	push	{lr}
 80027f2:	b085      	sub	sp, #20
 80027f4:	9001      	str	r0, [sp, #4]
 80027f6:	9100      	str	r1, [sp, #0]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 80027f8:	2300      	movs	r3, #0
 80027fa:	9303      	str	r3, [sp, #12]
  while (events != (eventmask_t)0) {
 80027fc:	e019      	b.n	8002832 <chEvtDispatch+0x42>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 80027fe:	9a00      	ldr	r2, [sp, #0]
 8002800:	9b03      	ldr	r3, [sp, #12]
 8002802:	fa22 f303 	lsr.w	r3, r2, r3
 8002806:	f003 0301 	and.w	r3, r3, #1
 800280a:	2b00      	cmp	r3, #0
 800280c:	d00e      	beq.n	800282c <chEvtDispatch+0x3c>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 800280e:	2201      	movs	r2, #1
 8002810:	9b03      	ldr	r3, [sp, #12]
 8002812:	fa02 f303 	lsl.w	r3, r2, r3
 8002816:	43db      	mvns	r3, r3
 8002818:	9a00      	ldr	r2, [sp, #0]
 800281a:	4013      	ands	r3, r2
 800281c:	9300      	str	r3, [sp, #0]
      handlers[eid](eid);
 800281e:	9b03      	ldr	r3, [sp, #12]
 8002820:	009b      	lsls	r3, r3, #2
 8002822:	9a01      	ldr	r2, [sp, #4]
 8002824:	4413      	add	r3, r2
 8002826:	681b      	ldr	r3, [r3, #0]
 8002828:	9803      	ldr	r0, [sp, #12]
 800282a:	4798      	blx	r3
    }
    eid++;
 800282c:	9b03      	ldr	r3, [sp, #12]
 800282e:	3301      	adds	r3, #1
 8002830:	9303      	str	r3, [sp, #12]
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002832:	9b00      	ldr	r3, [sp, #0]
 8002834:	2b00      	cmp	r3, #0
 8002836:	d1e2      	bne.n	80027fe <chEvtDispatch+0xe>
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
  }
}
 8002838:	b005      	add	sp, #20
 800283a:	f85d fb04 	ldr.w	pc, [sp], #4
 800283e:	bf00      	nop

08002840 <chEvtWaitOne>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8002840:	b500      	push	{lr}
 8002842:	b085      	sub	sp, #20
 8002844:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002846:	4b15      	ldr	r3, [pc, #84]	; (800289c <chEvtWaitOne+0x5c>)
 8002848:	699b      	ldr	r3, [r3, #24]
 800284a:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800284c:	f7ff fe80 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002850:	9b02      	ldr	r3, [sp, #8]
 8002852:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002854:	9b01      	ldr	r3, [sp, #4]
 8002856:	4013      	ands	r3, r2
 8002858:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800285a:	9b03      	ldr	r3, [sp, #12]
 800285c:	2b00      	cmp	r3, #0
 800285e:	d10a      	bne.n	8002876 <chEvtWaitOne+0x36>
    ctp->p_u.ewmask = events;
 8002860:	9b02      	ldr	r3, [sp, #8]
 8002862:	9a01      	ldr	r2, [sp, #4]
 8002864:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 8002866:	200a      	movs	r0, #10
 8002868:	f7fe f9c2 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 800286c:	9b02      	ldr	r3, [sp, #8]
 800286e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002870:	9b01      	ldr	r3, [sp, #4]
 8002872:	4013      	ands	r3, r2
 8002874:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 8002876:	9b03      	ldr	r3, [sp, #12]
 8002878:	425b      	negs	r3, r3
 800287a:	9a03      	ldr	r2, [sp, #12]
 800287c:	4013      	ands	r3, r2
 800287e:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 8002880:	9b02      	ldr	r3, [sp, #8]
 8002882:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002884:	9b03      	ldr	r3, [sp, #12]
 8002886:	43db      	mvns	r3, r3
 8002888:	401a      	ands	r2, r3
 800288a:	9b02      	ldr	r3, [sp, #8]
 800288c:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 800288e:	f7ff fe67 	bl	8002560 <chSysUnlock>

  return m;
 8002892:	9b03      	ldr	r3, [sp, #12]
}
 8002894:	4618      	mov	r0, r3
 8002896:	b005      	add	sp, #20
 8002898:	f85d fb04 	ldr.w	pc, [sp], #4
 800289c:	20001bc8 	.word	0x20001bc8

080028a0 <chEvtWaitAny>:
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 80028a0:	b500      	push	{lr}
 80028a2:	b085      	sub	sp, #20
 80028a4:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 80028a6:	4b13      	ldr	r3, [pc, #76]	; (80028f4 <chEvtWaitAny+0x54>)
 80028a8:	699b      	ldr	r3, [r3, #24]
 80028aa:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80028ac:	f7ff fe50 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80028b0:	9b02      	ldr	r3, [sp, #8]
 80028b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028b4:	9b01      	ldr	r3, [sp, #4]
 80028b6:	4013      	ands	r3, r2
 80028b8:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80028ba:	9b03      	ldr	r3, [sp, #12]
 80028bc:	2b00      	cmp	r3, #0
 80028be:	d10a      	bne.n	80028d6 <chEvtWaitAny+0x36>
    ctp->p_u.ewmask = events;
 80028c0:	9b02      	ldr	r3, [sp, #8]
 80028c2:	9a01      	ldr	r2, [sp, #4]
 80028c4:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTOREVT);
 80028c6:	200a      	movs	r0, #10
 80028c8:	f7fe f992 	bl	8000bf0 <chSchGoSleepS>
    m = ctp->p_epending & events;
 80028cc:	9b02      	ldr	r3, [sp, #8]
 80028ce:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028d0:	9b01      	ldr	r3, [sp, #4]
 80028d2:	4013      	ands	r3, r2
 80028d4:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 80028d6:	9b02      	ldr	r3, [sp, #8]
 80028d8:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80028da:	9b03      	ldr	r3, [sp, #12]
 80028dc:	43db      	mvns	r3, r3
 80028de:	401a      	ands	r2, r3
 80028e0:	9b02      	ldr	r3, [sp, #8]
 80028e2:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80028e4:	f7ff fe3c 	bl	8002560 <chSysUnlock>

  return m;
 80028e8:	9b03      	ldr	r3, [sp, #12]
}
 80028ea:	4618      	mov	r0, r3
 80028ec:	b005      	add	sp, #20
 80028ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80028f2:	bf00      	nop
 80028f4:	20001bc8 	.word	0x20001bc8
 80028f8:	f3af 8000 	nop.w
 80028fc:	f3af 8000 	nop.w

08002900 <chEvtWaitAll>:
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8002900:	b500      	push	{lr}
 8002902:	b085      	sub	sp, #20
 8002904:	9001      	str	r0, [sp, #4]
  thread_t *ctp = currp;
 8002906:	4b10      	ldr	r3, [pc, #64]	; (8002948 <chEvtWaitAll+0x48>)
 8002908:	699b      	ldr	r3, [r3, #24]
 800290a:	9303      	str	r3, [sp, #12]

  chSysLock();
 800290c:	f7ff fe20 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002910:	9b03      	ldr	r3, [sp, #12]
 8002912:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002914:	9b01      	ldr	r3, [sp, #4]
 8002916:	401a      	ands	r2, r3
 8002918:	9b01      	ldr	r3, [sp, #4]
 800291a:	429a      	cmp	r2, r3
 800291c:	d005      	beq.n	800292a <chEvtWaitAll+0x2a>
    ctp->p_u.ewmask = events;
 800291e:	9b03      	ldr	r3, [sp, #12]
 8002920:	9a01      	ldr	r2, [sp, #4]
 8002922:	621a      	str	r2, [r3, #32]
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8002924:	200b      	movs	r0, #11
 8002926:	f7fe f963 	bl	8000bf0 <chSchGoSleepS>
  }
  ctp->p_epending &= ~events;
 800292a:	9b03      	ldr	r3, [sp, #12]
 800292c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800292e:	9b01      	ldr	r3, [sp, #4]
 8002930:	43db      	mvns	r3, r3
 8002932:	401a      	ands	r2, r3
 8002934:	9b03      	ldr	r3, [sp, #12]
 8002936:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002938:	f7ff fe12 	bl	8002560 <chSysUnlock>

  return events;
 800293c:	9b01      	ldr	r3, [sp, #4]
}
 800293e:	4618      	mov	r0, r3
 8002940:	b005      	add	sp, #20
 8002942:	f85d fb04 	ldr.w	pc, [sp], #4
 8002946:	bf00      	nop
 8002948:	20001bc8 	.word	0x20001bc8
 800294c:	f3af 8000 	nop.w

08002950 <chEvtWaitOneTimeout>:
 * @return              The mask of the lowest event id served and cleared.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
 8002950:	b500      	push	{lr}
 8002952:	b085      	sub	sp, #20
 8002954:	9001      	str	r0, [sp, #4]
 8002956:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002958:	4b1c      	ldr	r3, [pc, #112]	; (80029cc <chEvtWaitOneTimeout+0x7c>)
 800295a:	699b      	ldr	r3, [r3, #24]
 800295c:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 800295e:	f7ff fdf7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 8002962:	9b02      	ldr	r3, [sp, #8]
 8002964:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002966:	9b01      	ldr	r3, [sp, #4]
 8002968:	4013      	ands	r3, r2
 800296a:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 800296c:	9b03      	ldr	r3, [sp, #12]
 800296e:	2b00      	cmp	r3, #0
 8002970:	d119      	bne.n	80029a6 <chEvtWaitOneTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 8002972:	9b00      	ldr	r3, [sp, #0]
 8002974:	2b00      	cmp	r3, #0
 8002976:	d103      	bne.n	8002980 <chEvtWaitOneTimeout+0x30>
      chSysUnlock();
 8002978:	f7ff fdf2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 800297c:	2300      	movs	r3, #0
 800297e:	e021      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    ctp->p_u.ewmask = events;
 8002980:	9b02      	ldr	r3, [sp, #8]
 8002982:	9a01      	ldr	r2, [sp, #4]
 8002984:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002986:	200a      	movs	r0, #10
 8002988:	9900      	ldr	r1, [sp, #0]
 800298a:	f7fe f999 	bl	8000cc0 <chSchGoSleepTimeoutS>
 800298e:	4603      	mov	r3, r0
 8002990:	2b00      	cmp	r3, #0
 8002992:	da03      	bge.n	800299c <chEvtWaitOneTimeout+0x4c>
      chSysUnlock();
 8002994:	f7ff fde4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002998:	2300      	movs	r3, #0
 800299a:	e013      	b.n	80029c4 <chEvtWaitOneTimeout+0x74>
    }
    m = ctp->p_epending & events;
 800299c:	9b02      	ldr	r3, [sp, #8]
 800299e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029a0:	9b01      	ldr	r3, [sp, #4]
 80029a2:	4013      	ands	r3, r2
 80029a4:	9303      	str	r3, [sp, #12]
  }
  m ^= m & (m - (eventmask_t)1);
 80029a6:	9b03      	ldr	r3, [sp, #12]
 80029a8:	425b      	negs	r3, r3
 80029aa:	9a03      	ldr	r2, [sp, #12]
 80029ac:	4013      	ands	r3, r2
 80029ae:	9303      	str	r3, [sp, #12]
  ctp->p_epending &= ~m;
 80029b0:	9b02      	ldr	r3, [sp, #8]
 80029b2:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029b4:	9b03      	ldr	r3, [sp, #12]
 80029b6:	43db      	mvns	r3, r3
 80029b8:	401a      	ands	r2, r3
 80029ba:	9b02      	ldr	r3, [sp, #8]
 80029bc:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 80029be:	f7ff fdcf 	bl	8002560 <chSysUnlock>

  return m;
 80029c2:	9b03      	ldr	r3, [sp, #12]
}
 80029c4:	4618      	mov	r0, r3
 80029c6:	b005      	add	sp, #20
 80029c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80029cc:	20001bc8 	.word	0x20001bc8

080029d0 <chEvtWaitAnyTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
 80029d0:	b500      	push	{lr}
 80029d2:	b085      	sub	sp, #20
 80029d4:	9001      	str	r0, [sp, #4]
 80029d6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 80029d8:	4b1a      	ldr	r3, [pc, #104]	; (8002a44 <chEvtWaitAnyTimeout+0x74>)
 80029da:	699b      	ldr	r3, [r3, #24]
 80029dc:	9302      	str	r3, [sp, #8]
  eventmask_t m;

  chSysLock();
 80029de:	f7ff fdb7 	bl	8002550 <chSysLock>
  m = ctp->p_epending & events;
 80029e2:	9b02      	ldr	r3, [sp, #8]
 80029e4:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 80029e6:	9b01      	ldr	r3, [sp, #4]
 80029e8:	4013      	ands	r3, r2
 80029ea:	9303      	str	r3, [sp, #12]
  if (m == (eventmask_t)0) {
 80029ec:	9b03      	ldr	r3, [sp, #12]
 80029ee:	2b00      	cmp	r3, #0
 80029f0:	d119      	bne.n	8002a26 <chEvtWaitAnyTimeout+0x56>
    if (TIME_IMMEDIATE == time) {
 80029f2:	9b00      	ldr	r3, [sp, #0]
 80029f4:	2b00      	cmp	r3, #0
 80029f6:	d103      	bne.n	8002a00 <chEvtWaitAnyTimeout+0x30>
      chSysUnlock();
 80029f8:	f7ff fdb2 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 80029fc:	2300      	movs	r3, #0
 80029fe:	e01c      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    ctp->p_u.ewmask = events;
 8002a00:	9b02      	ldr	r3, [sp, #8]
 8002a02:	9a01      	ldr	r2, [sp, #4]
 8002a04:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002a06:	200a      	movs	r0, #10
 8002a08:	9900      	ldr	r1, [sp, #0]
 8002a0a:	f7fe f959 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a0e:	4603      	mov	r3, r0
 8002a10:	2b00      	cmp	r3, #0
 8002a12:	da03      	bge.n	8002a1c <chEvtWaitAnyTimeout+0x4c>
      chSysUnlock();
 8002a14:	f7ff fda4 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a18:	2300      	movs	r3, #0
 8002a1a:	e00e      	b.n	8002a3a <chEvtWaitAnyTimeout+0x6a>
    }
    m = ctp->p_epending & events;
 8002a1c:	9b02      	ldr	r3, [sp, #8]
 8002a1e:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a20:	9b01      	ldr	r3, [sp, #4]
 8002a22:	4013      	ands	r3, r2
 8002a24:	9303      	str	r3, [sp, #12]
  }
  ctp->p_epending &= ~m;
 8002a26:	9b02      	ldr	r3, [sp, #8]
 8002a28:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a2a:	9b03      	ldr	r3, [sp, #12]
 8002a2c:	43db      	mvns	r3, r3
 8002a2e:	401a      	ands	r2, r3
 8002a30:	9b02      	ldr	r3, [sp, #8]
 8002a32:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002a34:	f7ff fd94 	bl	8002560 <chSysUnlock>

  return m;
 8002a38:	9b03      	ldr	r3, [sp, #12]
}
 8002a3a:	4618      	mov	r0, r3
 8002a3c:	b005      	add	sp, #20
 8002a3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8002a42:	bf00      	nop
 8002a44:	20001bc8 	.word	0x20001bc8
 8002a48:	f3af 8000 	nop.w
 8002a4c:	f3af 8000 	nop.w

08002a50 <chEvtWaitAllTimeout>:
 * @return              The mask of the served and cleared events.
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
 8002a50:	b500      	push	{lr}
 8002a52:	b085      	sub	sp, #20
 8002a54:	9001      	str	r0, [sp, #4]
 8002a56:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002a58:	4b17      	ldr	r3, [pc, #92]	; (8002ab8 <chEvtWaitAllTimeout+0x68>)
 8002a5a:	699b      	ldr	r3, [r3, #24]
 8002a5c:	9303      	str	r3, [sp, #12]

  chSysLock();
 8002a5e:	f7ff fd77 	bl	8002550 <chSysLock>
  if ((ctp->p_epending & events) != events) {
 8002a62:	9b03      	ldr	r3, [sp, #12]
 8002a64:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a66:	9b01      	ldr	r3, [sp, #4]
 8002a68:	401a      	ands	r2, r3
 8002a6a:	9b01      	ldr	r3, [sp, #4]
 8002a6c:	429a      	cmp	r2, r3
 8002a6e:	d014      	beq.n	8002a9a <chEvtWaitAllTimeout+0x4a>
    if (TIME_IMMEDIATE == time) {
 8002a70:	9b00      	ldr	r3, [sp, #0]
 8002a72:	2b00      	cmp	r3, #0
 8002a74:	d103      	bne.n	8002a7e <chEvtWaitAllTimeout+0x2e>
      chSysUnlock();
 8002a76:	f7ff fd73 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a7a:	2300      	movs	r3, #0
 8002a7c:	e017      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
    ctp->p_u.ewmask = events;
 8002a7e:	9b03      	ldr	r3, [sp, #12]
 8002a80:	9a01      	ldr	r2, [sp, #4]
 8002a82:	621a      	str	r2, [r3, #32]
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002a84:	200b      	movs	r0, #11
 8002a86:	9900      	ldr	r1, [sp, #0]
 8002a88:	f7fe f91a 	bl	8000cc0 <chSchGoSleepTimeoutS>
 8002a8c:	4603      	mov	r3, r0
 8002a8e:	2b00      	cmp	r3, #0
 8002a90:	da03      	bge.n	8002a9a <chEvtWaitAllTimeout+0x4a>
      chSysUnlock();
 8002a92:	f7ff fd65 	bl	8002560 <chSysUnlock>
      return (eventmask_t)0;
 8002a96:	2300      	movs	r3, #0
 8002a98:	e009      	b.n	8002aae <chEvtWaitAllTimeout+0x5e>
    }
  }
  ctp->p_epending &= ~events;
 8002a9a:	9b03      	ldr	r3, [sp, #12]
 8002a9c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 8002a9e:	9b01      	ldr	r3, [sp, #4]
 8002aa0:	43db      	mvns	r3, r3
 8002aa2:	401a      	ands	r2, r3
 8002aa4:	9b03      	ldr	r3, [sp, #12]
 8002aa6:	635a      	str	r2, [r3, #52]	; 0x34
  chSysUnlock();
 8002aa8:	f7ff fd5a 	bl	8002560 <chSysUnlock>

  return events;
 8002aac:	9b01      	ldr	r3, [sp, #4]
}
 8002aae:	4618      	mov	r0, r3
 8002ab0:	b005      	add	sp, #20
 8002ab2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002ab6:	bf00      	nop
 8002ab8:	20001bc8 	.word	0x20001bc8
 8002abc:	f3af 8000 	nop.w

08002ac0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002ac0:	b082      	sub	sp, #8
 8002ac2:	2320      	movs	r3, #32
 8002ac4:	9301      	str	r3, [sp, #4]
 8002ac6:	9b01      	ldr	r3, [sp, #4]
 8002ac8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002acc:	b002      	add	sp, #8
 8002ace:	4770      	bx	lr

08002ad0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002ad0:	b082      	sub	sp, #8
 8002ad2:	2300      	movs	r3, #0
 8002ad4:	9301      	str	r3, [sp, #4]
 8002ad6:	9b01      	ldr	r3, [sp, #4]
 8002ad8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002adc:	b002      	add	sp, #8
 8002ade:	4770      	bx	lr

08002ae0 <queue_insert>:
  tp->p_prev = cp->p_prev;
  tp->p_prev->p_next = tp;
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {
 8002ae0:	b082      	sub	sp, #8
 8002ae2:	9001      	str	r0, [sp, #4]
 8002ae4:	9100      	str	r1, [sp, #0]

  tp->p_next = (thread_t *)tqp;
 8002ae6:	9b01      	ldr	r3, [sp, #4]
 8002ae8:	9a00      	ldr	r2, [sp, #0]
 8002aea:	601a      	str	r2, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8002aec:	9b00      	ldr	r3, [sp, #0]
 8002aee:	685a      	ldr	r2, [r3, #4]
 8002af0:	9b01      	ldr	r3, [sp, #4]
 8002af2:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8002af4:	9b01      	ldr	r3, [sp, #4]
 8002af6:	685b      	ldr	r3, [r3, #4]
 8002af8:	9a01      	ldr	r2, [sp, #4]
 8002afa:	601a      	str	r2, [r3, #0]
  tqp->p_prev = tp;
 8002afc:	9b00      	ldr	r3, [sp, #0]
 8002afe:	9a01      	ldr	r2, [sp, #4]
 8002b00:	605a      	str	r2, [r3, #4]
}
 8002b02:	b002      	add	sp, #8
 8002b04:	4770      	bx	lr
 8002b06:	bf00      	nop
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <queue_fifo_remove>:

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
 8002b10:	b084      	sub	sp, #16
 8002b12:	9001      	str	r0, [sp, #4]
  thread_t *tp = tqp->p_next;
 8002b14:	9b01      	ldr	r3, [sp, #4]
 8002b16:	681b      	ldr	r3, [r3, #0]
 8002b18:	9303      	str	r3, [sp, #12]

  tqp->p_next = tp->p_next;
 8002b1a:	9b03      	ldr	r3, [sp, #12]
 8002b1c:	681a      	ldr	r2, [r3, #0]
 8002b1e:	9b01      	ldr	r3, [sp, #4]
 8002b20:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8002b22:	9b01      	ldr	r3, [sp, #4]
 8002b24:	681b      	ldr	r3, [r3, #0]
 8002b26:	9a01      	ldr	r2, [sp, #4]
 8002b28:	605a      	str	r2, [r3, #4]

  return tp;
 8002b2a:	9b03      	ldr	r3, [sp, #12]
}
 8002b2c:	4618      	mov	r0, r3
 8002b2e:	b004      	add	sp, #16
 8002b30:	4770      	bx	lr
 8002b32:	bf00      	nop
 8002b34:	f3af 8000 	nop.w
 8002b38:	f3af 8000 	nop.w
 8002b3c:	f3af 8000 	nop.w

08002b40 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002b40:	b508      	push	{r3, lr}

  port_lock();
 8002b42:	f7ff ffbd 	bl	8002ac0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002b46:	bd08      	pop	{r3, pc}
 8002b48:	f3af 8000 	nop.w
 8002b4c:	f3af 8000 	nop.w

08002b50 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002b50:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002b52:	f7ff ffbd 	bl	8002ad0 <port_unlock>
}
 8002b56:	bd08      	pop	{r3, pc}
 8002b58:	f3af 8000 	nop.w
 8002b5c:	f3af 8000 	nop.w

08002b60 <chMsgIsPendingI>:
 * @param[in] tp        pointer to the thread
 * @return              The pending messages status.
 *
 * @iclass
 */
static inline bool chMsgIsPendingI(thread_t *tp) {
 8002b60:	b082      	sub	sp, #8
 8002b62:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(tp->p_msgqueue.p_next != (thread_t *)&tp->p_msgqueue);
 8002b64:	9b01      	ldr	r3, [sp, #4]
 8002b66:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002b68:	9b01      	ldr	r3, [sp, #4]
 8002b6a:	3328      	adds	r3, #40	; 0x28
 8002b6c:	429a      	cmp	r2, r3
 8002b6e:	bf0c      	ite	eq
 8002b70:	2300      	moveq	r3, #0
 8002b72:	2301      	movne	r3, #1
 8002b74:	b2db      	uxtb	r3, r3
}
 8002b76:	4618      	mov	r0, r3
 8002b78:	b002      	add	sp, #8
 8002b7a:	4770      	bx	lr
 8002b7c:	f3af 8000 	nop.w

08002b80 <chMsgReleaseS>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @sclass
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {
 8002b80:	b500      	push	{lr}
 8002b82:	b083      	sub	sp, #12
 8002b84:	9001      	str	r0, [sp, #4]
 8002b86:	9100      	str	r1, [sp, #0]

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002b88:	9801      	ldr	r0, [sp, #4]
 8002b8a:	9900      	ldr	r1, [sp, #0]
 8002b8c:	f7fe f8d0 	bl	8000d30 <chSchWakeupS>
}
 8002b90:	b003      	add	sp, #12
 8002b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8002b96:	bf00      	nop
 8002b98:	f3af 8000 	nop.w
 8002b9c:	f3af 8000 	nop.w

08002ba0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 8002ba0:	b500      	push	{lr}
 8002ba2:	b085      	sub	sp, #20
 8002ba4:	9001      	str	r0, [sp, #4]
 8002ba6:	9100      	str	r1, [sp, #0]
  thread_t *ctp = currp;
 8002ba8:	4b13      	ldr	r3, [pc, #76]	; (8002bf8 <chMsgSend+0x58>)
 8002baa:	699b      	ldr	r3, [r3, #24]
 8002bac:	9303      	str	r3, [sp, #12]

  chDbgCheck(tp != NULL);

  chSysLock();
 8002bae:	f7ff ffc7 	bl	8002b40 <chSysLock>
  ctp->p_msg = msg;
 8002bb2:	9b03      	ldr	r3, [sp, #12]
 8002bb4:	9a00      	ldr	r2, [sp, #0]
 8002bb6:	631a      	str	r2, [r3, #48]	; 0x30
  ctp->p_u.wtobjp = &tp->p_msgqueue;
 8002bb8:	9b01      	ldr	r3, [sp, #4]
 8002bba:	f103 0228 	add.w	r2, r3, #40	; 0x28
 8002bbe:	9b03      	ldr	r3, [sp, #12]
 8002bc0:	621a      	str	r2, [r3, #32]
  msg_insert(ctp, &tp->p_msgqueue);
 8002bc2:	9b01      	ldr	r3, [sp, #4]
 8002bc4:	3328      	adds	r3, #40	; 0x28
 8002bc6:	9803      	ldr	r0, [sp, #12]
 8002bc8:	4619      	mov	r1, r3
 8002bca:	f7ff ff89 	bl	8002ae0 <queue_insert>
  if (tp->p_state == CH_STATE_WTMSG) {
 8002bce:	9b01      	ldr	r3, [sp, #4]
 8002bd0:	7f1b      	ldrb	r3, [r3, #28]
 8002bd2:	2b0e      	cmp	r3, #14
 8002bd4:	d102      	bne.n	8002bdc <chMsgSend+0x3c>
    (void) chSchReadyI(tp);
 8002bd6:	9801      	ldr	r0, [sp, #4]
 8002bd8:	f7fd ffe2 	bl	8000ba0 <chSchReadyI>
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8002bdc:	200c      	movs	r0, #12
 8002bde:	f7fe f807 	bl	8000bf0 <chSchGoSleepS>
  msg = ctp->p_u.rdymsg;
 8002be2:	9b03      	ldr	r3, [sp, #12]
 8002be4:	6a1b      	ldr	r3, [r3, #32]
 8002be6:	9300      	str	r3, [sp, #0]
  chSysUnlock();
 8002be8:	f7ff ffb2 	bl	8002b50 <chSysUnlock>

  return msg;
 8002bec:	9b00      	ldr	r3, [sp, #0]
}
 8002bee:	4618      	mov	r0, r3
 8002bf0:	b005      	add	sp, #20
 8002bf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8002bf6:	bf00      	nop
 8002bf8:	20001bc8 	.word	0x20001bc8
 8002bfc:	f3af 8000 	nop.w

08002c00 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 8002c00:	b500      	push	{lr}
 8002c02:	b083      	sub	sp, #12
  thread_t *tp;

  chSysLock();
 8002c04:	f7ff ff9c 	bl	8002b40 <chSysLock>
  if (!chMsgIsPendingI(currp)) {
 8002c08:	4b0f      	ldr	r3, [pc, #60]	; (8002c48 <chMsgWait+0x48>)
 8002c0a:	699b      	ldr	r3, [r3, #24]
 8002c0c:	4618      	mov	r0, r3
 8002c0e:	f7ff ffa7 	bl	8002b60 <chMsgIsPendingI>
 8002c12:	4603      	mov	r3, r0
 8002c14:	f083 0301 	eor.w	r3, r3, #1
 8002c18:	b2db      	uxtb	r3, r3
 8002c1a:	2b00      	cmp	r3, #0
 8002c1c:	d002      	beq.n	8002c24 <chMsgWait+0x24>
    chSchGoSleepS(CH_STATE_WTMSG);
 8002c1e:	200e      	movs	r0, #14
 8002c20:	f7fd ffe6 	bl	8000bf0 <chSchGoSleepS>
  }
  tp = queue_fifo_remove(&currp->p_msgqueue);
 8002c24:	4b08      	ldr	r3, [pc, #32]	; (8002c48 <chMsgWait+0x48>)
 8002c26:	699b      	ldr	r3, [r3, #24]
 8002c28:	3328      	adds	r3, #40	; 0x28
 8002c2a:	4618      	mov	r0, r3
 8002c2c:	f7ff ff70 	bl	8002b10 <queue_fifo_remove>
 8002c30:	9001      	str	r0, [sp, #4]
  tp->p_state = CH_STATE_SNDMSG;
 8002c32:	9b01      	ldr	r3, [sp, #4]
 8002c34:	220d      	movs	r2, #13
 8002c36:	771a      	strb	r2, [r3, #28]
  chSysUnlock();
 8002c38:	f7ff ff8a 	bl	8002b50 <chSysUnlock>

  return tp;
 8002c3c:	9b01      	ldr	r3, [sp, #4]
}
 8002c3e:	4618      	mov	r0, r3
 8002c40:	b003      	add	sp, #12
 8002c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c46:	bf00      	nop
 8002c48:	20001bc8 	.word	0x20001bc8
 8002c4c:	f3af 8000 	nop.w

08002c50 <chMsgRelease>:
 * @param[in] tp        pointer to the thread
 * @param[in] msg       message to be returned to the sender
 *
 * @api
 */
void chMsgRelease(thread_t *tp, msg_t msg) {
 8002c50:	b500      	push	{lr}
 8002c52:	b083      	sub	sp, #12
 8002c54:	9001      	str	r0, [sp, #4]
 8002c56:	9100      	str	r1, [sp, #0]

  chSysLock();
 8002c58:	f7ff ff72 	bl	8002b40 <chSysLock>
  chDbgAssert(tp->p_state == CH_STATE_SNDMSG, "invalid state");
  chMsgReleaseS(tp, msg);
 8002c5c:	9801      	ldr	r0, [sp, #4]
 8002c5e:	9900      	ldr	r1, [sp, #0]
 8002c60:	f7ff ff8e 	bl	8002b80 <chMsgReleaseS>
  chSysUnlock();
 8002c64:	f7ff ff74 	bl	8002b50 <chSysUnlock>
}
 8002c68:	b003      	add	sp, #12
 8002c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002c6e:	bf00      	nop

08002c70 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8002c70:	b082      	sub	sp, #8
 8002c72:	2320      	movs	r3, #32
 8002c74:	9301      	str	r3, [sp, #4]
 8002c76:	9b01      	ldr	r3, [sp, #4]
 8002c78:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c7c:	b002      	add	sp, #8
 8002c7e:	4770      	bx	lr

08002c80 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8002c80:	b082      	sub	sp, #8
 8002c82:	2300      	movs	r3, #0
 8002c84:	9301      	str	r3, [sp, #4]
 8002c86:	9b01      	ldr	r3, [sp, #4]
 8002c88:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8002c8c:	b002      	add	sp, #8
 8002c8e:	4770      	bx	lr

08002c90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8002c90:	b508      	push	{r3, lr}

  port_lock();
 8002c92:	f7ff ffed 	bl	8002c70 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8002c96:	bd08      	pop	{r3, pc}
 8002c98:	f3af 8000 	nop.w
 8002c9c:	f3af 8000 	nop.w

08002ca0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8002ca0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8002ca2:	f7ff ffed 	bl	8002c80 <port_unlock>
}
 8002ca6:	bd08      	pop	{r3, pc}
 8002ca8:	f3af 8000 	nop.w
 8002cac:	f3af 8000 	nop.w

08002cb0 <chSemFastWaitI>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @iclass
 */
static inline void chSemFastWaitI(semaphore_t *sp) {
 8002cb0:	b082      	sub	sp, #8
 8002cb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  sp->s_cnt--;
 8002cb4:	9b01      	ldr	r3, [sp, #4]
 8002cb6:	689b      	ldr	r3, [r3, #8]
 8002cb8:	1e5a      	subs	r2, r3, #1
 8002cba:	9b01      	ldr	r3, [sp, #4]
 8002cbc:	609a      	str	r2, [r3, #8]
}
 8002cbe:	b002      	add	sp, #8
 8002cc0:	4770      	bx	lr
 8002cc2:	bf00      	nop
 8002cc4:	f3af 8000 	nop.w
 8002cc8:	f3af 8000 	nop.w
 8002ccc:	f3af 8000 	nop.w

08002cd0 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 8002cd0:	b082      	sub	sp, #8
 8002cd2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 8002cd4:	9b01      	ldr	r3, [sp, #4]
 8002cd6:	689b      	ldr	r3, [r3, #8]
}
 8002cd8:	4618      	mov	r0, r3
 8002cda:	b002      	add	sp, #8
 8002cdc:	4770      	bx	lr
 8002cde:	bf00      	nop

08002ce0 <chMBObjectInit>:
 * @param[in] buf       pointer to the messages buffer as an array of @p msg_t
 * @param[in] n         number of elements in the buffer array
 *
 * @init
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {
 8002ce0:	b500      	push	{lr}
 8002ce2:	b085      	sub	sp, #20
 8002ce4:	9003      	str	r0, [sp, #12]
 8002ce6:	9102      	str	r1, [sp, #8]
 8002ce8:	9201      	str	r2, [sp, #4]

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->mb_buffer = buf;
 8002cea:	9b03      	ldr	r3, [sp, #12]
 8002cec:	9a02      	ldr	r2, [sp, #8]
 8002cee:	601a      	str	r2, [r3, #0]
  mbp->mb_rdptr = buf;
 8002cf0:	9b03      	ldr	r3, [sp, #12]
 8002cf2:	9a02      	ldr	r2, [sp, #8]
 8002cf4:	60da      	str	r2, [r3, #12]
  mbp->mb_wrptr = buf;
 8002cf6:	9b03      	ldr	r3, [sp, #12]
 8002cf8:	9a02      	ldr	r2, [sp, #8]
 8002cfa:	609a      	str	r2, [r3, #8]
  mbp->mb_top = &buf[n];
 8002cfc:	9b01      	ldr	r3, [sp, #4]
 8002cfe:	009b      	lsls	r3, r3, #2
 8002d00:	9a02      	ldr	r2, [sp, #8]
 8002d02:	441a      	add	r2, r3
 8002d04:	9b03      	ldr	r3, [sp, #12]
 8002d06:	605a      	str	r2, [r3, #4]
  chSemObjectInit(&mbp->mb_emptysem, n);
 8002d08:	9b03      	ldr	r3, [sp, #12]
 8002d0a:	331c      	adds	r3, #28
 8002d0c:	4618      	mov	r0, r3
 8002d0e:	9901      	ldr	r1, [sp, #4]
 8002d10:	f7fe fed6 	bl	8001ac0 <chSemObjectInit>
  chSemObjectInit(&mbp->mb_fullsem, (cnt_t)0);
 8002d14:	9b03      	ldr	r3, [sp, #12]
 8002d16:	3310      	adds	r3, #16
 8002d18:	4618      	mov	r0, r3
 8002d1a:	2100      	movs	r1, #0
 8002d1c:	f7fe fed0 	bl	8001ac0 <chSemObjectInit>
}
 8002d20:	b005      	add	sp, #20
 8002d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d26:	bf00      	nop
 8002d28:	f3af 8000 	nop.w
 8002d2c:	f3af 8000 	nop.w

08002d30 <chMBReset>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8002d30:	b500      	push	{lr}
 8002d32:	b083      	sub	sp, #12
 8002d34:	9001      	str	r0, [sp, #4]

  chSysLock();
 8002d36:	f7ff ffab 	bl	8002c90 <chSysLock>
  chMBResetI(mbp);
 8002d3a:	9801      	ldr	r0, [sp, #4]
 8002d3c:	f000 f808 	bl	8002d50 <chMBResetI>
  chSchRescheduleS();
 8002d40:	f7fe f81e 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 8002d44:	f7ff ffac 	bl	8002ca0 <chSysUnlock>
}
 8002d48:	b003      	add	sp, #12
 8002d4a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d4e:	bf00      	nop

08002d50 <chMBResetI>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8002d50:	b500      	push	{lr}
 8002d52:	b083      	sub	sp, #12
 8002d54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->mb_wrptr = mbp->mb_buffer;
 8002d56:	9b01      	ldr	r3, [sp, #4]
 8002d58:	681a      	ldr	r2, [r3, #0]
 8002d5a:	9b01      	ldr	r3, [sp, #4]
 8002d5c:	609a      	str	r2, [r3, #8]
  mbp->mb_rdptr = mbp->mb_buffer;
 8002d5e:	9b01      	ldr	r3, [sp, #4]
 8002d60:	681a      	ldr	r2, [r3, #0]
 8002d62:	9b01      	ldr	r3, [sp, #4]
 8002d64:	60da      	str	r2, [r3, #12]
  chSemResetI(&mbp->mb_emptysem, (cnt_t)(mbp->mb_top - mbp->mb_buffer));
 8002d66:	9b01      	ldr	r3, [sp, #4]
 8002d68:	f103 021c 	add.w	r2, r3, #28
 8002d6c:	9b01      	ldr	r3, [sp, #4]
 8002d6e:	685b      	ldr	r3, [r3, #4]
 8002d70:	4619      	mov	r1, r3
 8002d72:	9b01      	ldr	r3, [sp, #4]
 8002d74:	681b      	ldr	r3, [r3, #0]
 8002d76:	1acb      	subs	r3, r1, r3
 8002d78:	109b      	asrs	r3, r3, #2
 8002d7a:	4610      	mov	r0, r2
 8002d7c:	4619      	mov	r1, r3
 8002d7e:	f7fe fec7 	bl	8001b10 <chSemResetI>
  chSemResetI(&mbp->mb_fullsem, (cnt_t)0);
 8002d82:	9b01      	ldr	r3, [sp, #4]
 8002d84:	3310      	adds	r3, #16
 8002d86:	4618      	mov	r0, r3
 8002d88:	2100      	movs	r1, #0
 8002d8a:	f7fe fec1 	bl	8001b10 <chSemResetI>
}
 8002d8e:	b003      	add	sp, #12
 8002d90:	f85d fb04 	ldr.w	pc, [sp], #4
 8002d94:	f3af 8000 	nop.w
 8002d98:	f3af 8000 	nop.w
 8002d9c:	f3af 8000 	nop.w

08002da0 <chMBPost>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002da0:	b500      	push	{lr}
 8002da2:	b087      	sub	sp, #28
 8002da4:	9003      	str	r0, [sp, #12]
 8002da6:	9102      	str	r1, [sp, #8]
 8002da8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002daa:	f7ff ff71 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostS(mbp, msg, timeout);
 8002dae:	9803      	ldr	r0, [sp, #12]
 8002db0:	9902      	ldr	r1, [sp, #8]
 8002db2:	9a01      	ldr	r2, [sp, #4]
 8002db4:	f000 f80c 	bl	8002dd0 <chMBPostS>
 8002db8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002dba:	f7ff ff71 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002dbe:	9b05      	ldr	r3, [sp, #20]
}
 8002dc0:	4618      	mov	r0, r3
 8002dc2:	b007      	add	sp, #28
 8002dc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002dc8:	f3af 8000 	nop.w
 8002dcc:	f3af 8000 	nop.w

08002dd0 <chMBPostS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002dd0:	b500      	push	{lr}
 8002dd2:	b087      	sub	sp, #28
 8002dd4:	9003      	str	r0, [sp, #12]
 8002dd6:	9102      	str	r1, [sp, #8]
 8002dd8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002dda:	9b03      	ldr	r3, [sp, #12]
 8002ddc:	331c      	adds	r3, #28
 8002dde:	4618      	mov	r0, r3
 8002de0:	9901      	ldr	r1, [sp, #4]
 8002de2:	f7fe ff05 	bl	8001bf0 <chSemWaitTimeoutS>
 8002de6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002de8:	9b05      	ldr	r3, [sp, #20]
 8002dea:	2b00      	cmp	r3, #0
 8002dec:	d117      	bne.n	8002e1e <chMBPostS+0x4e>
    *mbp->mb_wrptr++ = msg;
 8002dee:	9b03      	ldr	r3, [sp, #12]
 8002df0:	689b      	ldr	r3, [r3, #8]
 8002df2:	1d19      	adds	r1, r3, #4
 8002df4:	9a03      	ldr	r2, [sp, #12]
 8002df6:	6091      	str	r1, [r2, #8]
 8002df8:	9a02      	ldr	r2, [sp, #8]
 8002dfa:	601a      	str	r2, [r3, #0]
    if (mbp->mb_wrptr >= mbp->mb_top) {
 8002dfc:	9b03      	ldr	r3, [sp, #12]
 8002dfe:	689a      	ldr	r2, [r3, #8]
 8002e00:	9b03      	ldr	r3, [sp, #12]
 8002e02:	685b      	ldr	r3, [r3, #4]
 8002e04:	429a      	cmp	r2, r3
 8002e06:	d303      	bcc.n	8002e10 <chMBPostS+0x40>
      mbp->mb_wrptr = mbp->mb_buffer;
 8002e08:	9b03      	ldr	r3, [sp, #12]
 8002e0a:	681a      	ldr	r2, [r3, #0]
 8002e0c:	9b03      	ldr	r3, [sp, #12]
 8002e0e:	609a      	str	r2, [r3, #8]
    }
    chSemSignalI(&mbp->mb_fullsem);
 8002e10:	9b03      	ldr	r3, [sp, #12]
 8002e12:	3310      	adds	r3, #16
 8002e14:	4618      	mov	r0, r3
 8002e16:	f7fe ff3b 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002e1a:	f7fd ffb1 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002e1e:	9b05      	ldr	r3, [sp, #20]
}
 8002e20:	4618      	mov	r0, r3
 8002e22:	b007      	add	sp, #28
 8002e24:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e28:	f3af 8000 	nop.w
 8002e2c:	f3af 8000 	nop.w

08002e30 <chMBPostI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {
 8002e30:	b500      	push	{lr}
 8002e32:	b083      	sub	sp, #12
 8002e34:	9001      	str	r0, [sp, #4]
 8002e36:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002e38:	9b01      	ldr	r3, [sp, #4]
 8002e3a:	331c      	adds	r3, #28
 8002e3c:	4618      	mov	r0, r3
 8002e3e:	f7ff ff47 	bl	8002cd0 <chSemGetCounterI>
 8002e42:	4603      	mov	r3, r0
 8002e44:	2b00      	cmp	r3, #0
 8002e46:	dc02      	bgt.n	8002e4e <chMBPostI+0x1e>
    return MSG_TIMEOUT;
 8002e48:	f04f 33ff 	mov.w	r3, #4294967295
 8002e4c:	e01b      	b.n	8002e86 <chMBPostI+0x56>
  }

  chSemFastWaitI(&mbp->mb_emptysem);
 8002e4e:	9b01      	ldr	r3, [sp, #4]
 8002e50:	331c      	adds	r3, #28
 8002e52:	4618      	mov	r0, r3
 8002e54:	f7ff ff2c 	bl	8002cb0 <chSemFastWaitI>
  *mbp->mb_wrptr++ = msg;
 8002e58:	9b01      	ldr	r3, [sp, #4]
 8002e5a:	689b      	ldr	r3, [r3, #8]
 8002e5c:	1d19      	adds	r1, r3, #4
 8002e5e:	9a01      	ldr	r2, [sp, #4]
 8002e60:	6091      	str	r1, [r2, #8]
 8002e62:	9a00      	ldr	r2, [sp, #0]
 8002e64:	601a      	str	r2, [r3, #0]
  if (mbp->mb_wrptr >= mbp->mb_top) {
 8002e66:	9b01      	ldr	r3, [sp, #4]
 8002e68:	689a      	ldr	r2, [r3, #8]
 8002e6a:	9b01      	ldr	r3, [sp, #4]
 8002e6c:	685b      	ldr	r3, [r3, #4]
 8002e6e:	429a      	cmp	r2, r3
 8002e70:	d303      	bcc.n	8002e7a <chMBPostI+0x4a>
     mbp->mb_wrptr = mbp->mb_buffer;
 8002e72:	9b01      	ldr	r3, [sp, #4]
 8002e74:	681a      	ldr	r2, [r3, #0]
 8002e76:	9b01      	ldr	r3, [sp, #4]
 8002e78:	609a      	str	r2, [r3, #8]
  }
  chSemSignalI(&mbp->mb_fullsem);
 8002e7a:	9b01      	ldr	r3, [sp, #4]
 8002e7c:	3310      	adds	r3, #16
 8002e7e:	4618      	mov	r0, r3
 8002e80:	f7fe ff06 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002e84:	2300      	movs	r3, #0
}
 8002e86:	4618      	mov	r0, r3
 8002e88:	b003      	add	sp, #12
 8002e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002e8e:	bf00      	nop

08002e90 <chMBPostAhead>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002e90:	b500      	push	{lr}
 8002e92:	b087      	sub	sp, #28
 8002e94:	9003      	str	r0, [sp, #12]
 8002e96:	9102      	str	r1, [sp, #8]
 8002e98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002e9a:	f7ff fef9 	bl	8002c90 <chSysLock>
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
 8002e9e:	9803      	ldr	r0, [sp, #12]
 8002ea0:	9902      	ldr	r1, [sp, #8]
 8002ea2:	9a01      	ldr	r2, [sp, #4]
 8002ea4:	f000 f80c 	bl	8002ec0 <chMBPostAheadS>
 8002ea8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002eaa:	f7ff fef9 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002eae:	9b05      	ldr	r3, [sp, #20]
}
 8002eb0:	4618      	mov	r0, r3
 8002eb2:	b007      	add	sp, #28
 8002eb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <chMBPostAheadS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBPostAheadS(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8002ec0:	b500      	push	{lr}
 8002ec2:	b087      	sub	sp, #28
 8002ec4:	9003      	str	r0, [sp, #12]
 8002ec6:	9102      	str	r1, [sp, #8]
 8002ec8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->mb_emptysem, timeout);
 8002eca:	9b03      	ldr	r3, [sp, #12]
 8002ecc:	331c      	adds	r3, #28
 8002ece:	4618      	mov	r0, r3
 8002ed0:	9901      	ldr	r1, [sp, #4]
 8002ed2:	f7fe fe8d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002ed6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002ed8:	9b05      	ldr	r3, [sp, #20]
 8002eda:	2b00      	cmp	r3, #0
 8002edc:	d11a      	bne.n	8002f14 <chMBPostAheadS+0x54>
    if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002ede:	9b03      	ldr	r3, [sp, #12]
 8002ee0:	68db      	ldr	r3, [r3, #12]
 8002ee2:	1f1a      	subs	r2, r3, #4
 8002ee4:	9b03      	ldr	r3, [sp, #12]
 8002ee6:	60da      	str	r2, [r3, #12]
 8002ee8:	9b03      	ldr	r3, [sp, #12]
 8002eea:	68da      	ldr	r2, [r3, #12]
 8002eec:	9b03      	ldr	r3, [sp, #12]
 8002eee:	681b      	ldr	r3, [r3, #0]
 8002ef0:	429a      	cmp	r2, r3
 8002ef2:	d204      	bcs.n	8002efe <chMBPostAheadS+0x3e>
      mbp->mb_rdptr = mbp->mb_top - 1;
 8002ef4:	9b03      	ldr	r3, [sp, #12]
 8002ef6:	685b      	ldr	r3, [r3, #4]
 8002ef8:	1f1a      	subs	r2, r3, #4
 8002efa:	9b03      	ldr	r3, [sp, #12]
 8002efc:	60da      	str	r2, [r3, #12]
    }
    *mbp->mb_rdptr = msg;
 8002efe:	9b03      	ldr	r3, [sp, #12]
 8002f00:	68db      	ldr	r3, [r3, #12]
 8002f02:	9a02      	ldr	r2, [sp, #8]
 8002f04:	601a      	str	r2, [r3, #0]
    chSemSignalI(&mbp->mb_fullsem);
 8002f06:	9b03      	ldr	r3, [sp, #12]
 8002f08:	3310      	adds	r3, #16
 8002f0a:	4618      	mov	r0, r3
 8002f0c:	f7fe fec0 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 8002f10:	f7fd ff36 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8002f14:	9b05      	ldr	r3, [sp, #20]
}
 8002f16:	4618      	mov	r0, r3
 8002f18:	b007      	add	sp, #28
 8002f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f1e:	bf00      	nop

08002f20 <chMBPostAheadI>:
 * @retval MSG_TIMEOUT  if the mailbox is full and the message cannot be
 *                      posted.
 *
 * @iclass
 */
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {
 8002f20:	b500      	push	{lr}
 8002f22:	b083      	sub	sp, #12
 8002f24:	9001      	str	r0, [sp, #4]
 8002f26:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->mb_emptysem) <= (cnt_t)0) {
 8002f28:	9b01      	ldr	r3, [sp, #4]
 8002f2a:	331c      	adds	r3, #28
 8002f2c:	4618      	mov	r0, r3
 8002f2e:	f7ff fecf 	bl	8002cd0 <chSemGetCounterI>
 8002f32:	4603      	mov	r3, r0
 8002f34:	2b00      	cmp	r3, #0
 8002f36:	dc02      	bgt.n	8002f3e <chMBPostAheadI+0x1e>
    return MSG_TIMEOUT;
 8002f38:	f04f 33ff 	mov.w	r3, #4294967295
 8002f3c:	e01e      	b.n	8002f7c <chMBPostAheadI+0x5c>
  }
  chSemFastWaitI(&mbp->mb_emptysem);
 8002f3e:	9b01      	ldr	r3, [sp, #4]
 8002f40:	331c      	adds	r3, #28
 8002f42:	4618      	mov	r0, r3
 8002f44:	f7ff feb4 	bl	8002cb0 <chSemFastWaitI>
  if (--mbp->mb_rdptr < mbp->mb_buffer) {
 8002f48:	9b01      	ldr	r3, [sp, #4]
 8002f4a:	68db      	ldr	r3, [r3, #12]
 8002f4c:	1f1a      	subs	r2, r3, #4
 8002f4e:	9b01      	ldr	r3, [sp, #4]
 8002f50:	60da      	str	r2, [r3, #12]
 8002f52:	9b01      	ldr	r3, [sp, #4]
 8002f54:	68da      	ldr	r2, [r3, #12]
 8002f56:	9b01      	ldr	r3, [sp, #4]
 8002f58:	681b      	ldr	r3, [r3, #0]
 8002f5a:	429a      	cmp	r2, r3
 8002f5c:	d204      	bcs.n	8002f68 <chMBPostAheadI+0x48>
    mbp->mb_rdptr = mbp->mb_top - 1;
 8002f5e:	9b01      	ldr	r3, [sp, #4]
 8002f60:	685b      	ldr	r3, [r3, #4]
 8002f62:	1f1a      	subs	r2, r3, #4
 8002f64:	9b01      	ldr	r3, [sp, #4]
 8002f66:	60da      	str	r2, [r3, #12]
  }
  *mbp->mb_rdptr = msg;
 8002f68:	9b01      	ldr	r3, [sp, #4]
 8002f6a:	68db      	ldr	r3, [r3, #12]
 8002f6c:	9a00      	ldr	r2, [sp, #0]
 8002f6e:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->mb_fullsem);
 8002f70:	9b01      	ldr	r3, [sp, #4]
 8002f72:	3310      	adds	r3, #16
 8002f74:	4618      	mov	r0, r3
 8002f76:	f7fe fe8b 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8002f7a:	2300      	movs	r3, #0
}
 8002f7c:	4618      	mov	r0, r3
 8002f7e:	b003      	add	sp, #12
 8002f80:	f85d fb04 	ldr.w	pc, [sp], #4
 8002f84:	f3af 8000 	nop.w
 8002f88:	f3af 8000 	nop.w
 8002f8c:	f3af 8000 	nop.w

08002f90 <chMBFetch>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002f90:	b500      	push	{lr}
 8002f92:	b087      	sub	sp, #28
 8002f94:	9003      	str	r0, [sp, #12]
 8002f96:	9102      	str	r1, [sp, #8]
 8002f98:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chSysLock();
 8002f9a:	f7ff fe79 	bl	8002c90 <chSysLock>
  rdymsg = chMBFetchS(mbp, msgp, timeout);
 8002f9e:	9803      	ldr	r0, [sp, #12]
 8002fa0:	9902      	ldr	r1, [sp, #8]
 8002fa2:	9a01      	ldr	r2, [sp, #4]
 8002fa4:	f000 f80c 	bl	8002fc0 <chMBFetchS>
 8002fa8:	9005      	str	r0, [sp, #20]
  chSysUnlock();
 8002faa:	f7ff fe79 	bl	8002ca0 <chSysUnlock>

  return rdymsg;
 8002fae:	9b05      	ldr	r3, [sp, #20]
}
 8002fb0:	4618      	mov	r0, r3
 8002fb2:	b007      	add	sp, #28
 8002fb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8002fb8:	f3af 8000 	nop.w
 8002fbc:	f3af 8000 	nop.w

08002fc0 <chMBFetchS>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @sclass
 */
msg_t chMBFetchS(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8002fc0:	b500      	push	{lr}
 8002fc2:	b087      	sub	sp, #28
 8002fc4:	9003      	str	r0, [sp, #12]
 8002fc6:	9102      	str	r1, [sp, #8]
 8002fc8:	9201      	str	r2, [sp, #4]
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->mb_fullsem, timeout);
 8002fca:	9b03      	ldr	r3, [sp, #12]
 8002fcc:	3310      	adds	r3, #16
 8002fce:	4618      	mov	r0, r3
 8002fd0:	9901      	ldr	r1, [sp, #4]
 8002fd2:	f7fe fe0d 	bl	8001bf0 <chSemWaitTimeoutS>
 8002fd6:	9005      	str	r0, [sp, #20]
  if (rdymsg == MSG_OK) {
 8002fd8:	9b05      	ldr	r3, [sp, #20]
 8002fda:	2b00      	cmp	r3, #0
 8002fdc:	d118      	bne.n	8003010 <chMBFetchS+0x50>
    *msgp = *mbp->mb_rdptr++;
 8002fde:	9b03      	ldr	r3, [sp, #12]
 8002fe0:	68db      	ldr	r3, [r3, #12]
 8002fe2:	1d19      	adds	r1, r3, #4
 8002fe4:	9a03      	ldr	r2, [sp, #12]
 8002fe6:	60d1      	str	r1, [r2, #12]
 8002fe8:	681a      	ldr	r2, [r3, #0]
 8002fea:	9b02      	ldr	r3, [sp, #8]
 8002fec:	601a      	str	r2, [r3, #0]
    if (mbp->mb_rdptr >= mbp->mb_top) {
 8002fee:	9b03      	ldr	r3, [sp, #12]
 8002ff0:	68da      	ldr	r2, [r3, #12]
 8002ff2:	9b03      	ldr	r3, [sp, #12]
 8002ff4:	685b      	ldr	r3, [r3, #4]
 8002ff6:	429a      	cmp	r2, r3
 8002ff8:	d303      	bcc.n	8003002 <chMBFetchS+0x42>
      mbp->mb_rdptr = mbp->mb_buffer;
 8002ffa:	9b03      	ldr	r3, [sp, #12]
 8002ffc:	681a      	ldr	r2, [r3, #0]
 8002ffe:	9b03      	ldr	r3, [sp, #12]
 8003000:	60da      	str	r2, [r3, #12]
    }
    chSemSignalI(&mbp->mb_emptysem);
 8003002:	9b03      	ldr	r3, [sp, #12]
 8003004:	331c      	adds	r3, #28
 8003006:	4618      	mov	r0, r3
 8003008:	f7fe fe42 	bl	8001c90 <chSemSignalI>
    chSchRescheduleS();
 800300c:	f7fd feb8 	bl	8000d80 <chSchRescheduleS>
  }

  return rdymsg;
 8003010:	9b05      	ldr	r3, [sp, #20]
}
 8003012:	4618      	mov	r0, r3
 8003014:	b007      	add	sp, #28
 8003016:	f85d fb04 	ldr.w	pc, [sp], #4
 800301a:	bf00      	nop
 800301c:	f3af 8000 	nop.w

08003020 <chMBFetchI>:
 * @retval MSG_TIMEOUT  if the mailbox is empty and a message cannot be
 *                      fetched.
 *
 * @iclass
 */
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {
 8003020:	b500      	push	{lr}
 8003022:	b083      	sub	sp, #12
 8003024:	9001      	str	r0, [sp, #4]
 8003026:	9100      	str	r1, [sp, #0]

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->mb_fullsem) <= (cnt_t)0) {
 8003028:	9b01      	ldr	r3, [sp, #4]
 800302a:	3310      	adds	r3, #16
 800302c:	4618      	mov	r0, r3
 800302e:	f7ff fe4f 	bl	8002cd0 <chSemGetCounterI>
 8003032:	4603      	mov	r3, r0
 8003034:	2b00      	cmp	r3, #0
 8003036:	dc02      	bgt.n	800303e <chMBFetchI+0x1e>
    return MSG_TIMEOUT;
 8003038:	f04f 33ff 	mov.w	r3, #4294967295
 800303c:	e01c      	b.n	8003078 <chMBFetchI+0x58>
  }
  chSemFastWaitI(&mbp->mb_fullsem);
 800303e:	9b01      	ldr	r3, [sp, #4]
 8003040:	3310      	adds	r3, #16
 8003042:	4618      	mov	r0, r3
 8003044:	f7ff fe34 	bl	8002cb0 <chSemFastWaitI>
  *msgp = *mbp->mb_rdptr++;
 8003048:	9b01      	ldr	r3, [sp, #4]
 800304a:	68db      	ldr	r3, [r3, #12]
 800304c:	1d19      	adds	r1, r3, #4
 800304e:	9a01      	ldr	r2, [sp, #4]
 8003050:	60d1      	str	r1, [r2, #12]
 8003052:	681a      	ldr	r2, [r3, #0]
 8003054:	9b00      	ldr	r3, [sp, #0]
 8003056:	601a      	str	r2, [r3, #0]
  if (mbp->mb_rdptr >= mbp->mb_top) {
 8003058:	9b01      	ldr	r3, [sp, #4]
 800305a:	68da      	ldr	r2, [r3, #12]
 800305c:	9b01      	ldr	r3, [sp, #4]
 800305e:	685b      	ldr	r3, [r3, #4]
 8003060:	429a      	cmp	r2, r3
 8003062:	d303      	bcc.n	800306c <chMBFetchI+0x4c>
    mbp->mb_rdptr = mbp->mb_buffer;
 8003064:	9b01      	ldr	r3, [sp, #4]
 8003066:	681a      	ldr	r2, [r3, #0]
 8003068:	9b01      	ldr	r3, [sp, #4]
 800306a:	60da      	str	r2, [r3, #12]
  }
  chSemSignalI(&mbp->mb_emptysem);
 800306c:	9b01      	ldr	r3, [sp, #4]
 800306e:	331c      	adds	r3, #28
 8003070:	4618      	mov	r0, r3
 8003072:	f7fe fe0d 	bl	8001c90 <chSemSignalI>

  return MSG_OK;
 8003076:	2300      	movs	r3, #0
}
 8003078:	4618      	mov	r0, r3
 800307a:	b003      	add	sp, #12
 800307c:	f85d fb04 	ldr.w	pc, [sp], #4

08003080 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003080:	b082      	sub	sp, #8
 8003082:	2320      	movs	r3, #32
 8003084:	9301      	str	r3, [sp, #4]
 8003086:	9b01      	ldr	r3, [sp, #4]
 8003088:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800308c:	b002      	add	sp, #8
 800308e:	4770      	bx	lr

08003090 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003090:	b082      	sub	sp, #8
 8003092:	2300      	movs	r3, #0
 8003094:	9301      	str	r3, [sp, #4]
 8003096:	9b01      	ldr	r3, [sp, #4]
 8003098:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800309c:	b002      	add	sp, #8
 800309e:	4770      	bx	lr

080030a0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 80030a0:	b082      	sub	sp, #8
 80030a2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 80030a4:	9b01      	ldr	r3, [sp, #4]
 80030a6:	9a01      	ldr	r2, [sp, #4]
 80030a8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 80030aa:	9b01      	ldr	r3, [sp, #4]
 80030ac:	9a01      	ldr	r2, [sp, #4]
 80030ae:	605a      	str	r2, [r3, #4]
}
 80030b0:	b002      	add	sp, #8
 80030b2:	4770      	bx	lr
 80030b4:	f3af 8000 	nop.w
 80030b8:	f3af 8000 	nop.w
 80030bc:	f3af 8000 	nop.w

080030c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80030c0:	b508      	push	{r3, lr}

  port_lock();
 80030c2:	f7ff ffdd 	bl	8003080 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80030c6:	bd08      	pop	{r3, pc}
 80030c8:	f3af 8000 	nop.w
 80030cc:	f3af 8000 	nop.w

080030d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80030d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80030d2:	f7ff ffdd 	bl	8003090 <port_unlock>
}
 80030d6:	bd08      	pop	{r3, pc}
 80030d8:	f3af 8000 	nop.w
 80030dc:	f3af 8000 	nop.w

080030e0 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 80030e0:	b500      	push	{lr}
 80030e2:	b083      	sub	sp, #12
 80030e4:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 80030e6:	9801      	ldr	r0, [sp, #4]
 80030e8:	f7ff ffda 	bl	80030a0 <queue_init>
}
 80030ec:	b003      	add	sp, #12
 80030ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80030f2:	bf00      	nop
 80030f4:	f3af 8000 	nop.w
 80030f8:	f3af 8000 	nop.w
 80030fc:	f3af 8000 	nop.w

08003100 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8003100:	b082      	sub	sp, #8
 8003102:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8003104:	9b01      	ldr	r3, [sp, #4]
 8003106:	689b      	ldr	r3, [r3, #8]
 8003108:	2b00      	cmp	r3, #0
 800310a:	bf14      	ite	ne
 800310c:	2300      	movne	r3, #0
 800310e:	2301      	moveq	r3, #1
 8003110:	b2db      	uxtb	r3, r3
}
 8003112:	4618      	mov	r0, r3
 8003114:	b002      	add	sp, #8
 8003116:	4770      	bx	lr
 8003118:	f3af 8000 	nop.w
 800311c:	f3af 8000 	nop.w

08003120 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 8003120:	b082      	sub	sp, #8
 8003122:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 8003124:	9b01      	ldr	r3, [sp, #4]
 8003126:	695a      	ldr	r2, [r3, #20]
 8003128:	9b01      	ldr	r3, [sp, #4]
 800312a:	699b      	ldr	r3, [r3, #24]
 800312c:	429a      	cmp	r2, r3
 800312e:	d105      	bne.n	800313c <chIQIsFullI+0x1c>
 8003130:	9b01      	ldr	r3, [sp, #4]
 8003132:	689b      	ldr	r3, [r3, #8]
 8003134:	2b00      	cmp	r3, #0
 8003136:	d001      	beq.n	800313c <chIQIsFullI+0x1c>
 8003138:	2301      	movs	r3, #1
 800313a:	e000      	b.n	800313e <chIQIsFullI+0x1e>
 800313c:	2300      	movs	r3, #0
 800313e:	f003 0301 	and.w	r3, r3, #1
 8003142:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003144:	4618      	mov	r0, r3
 8003146:	b002      	add	sp, #8
 8003148:	4770      	bx	lr
 800314a:	bf00      	nop
 800314c:	f3af 8000 	nop.w

08003150 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 8003150:	b082      	sub	sp, #8
 8003152:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8003154:	9b01      	ldr	r3, [sp, #4]
 8003156:	695a      	ldr	r2, [r3, #20]
 8003158:	9b01      	ldr	r3, [sp, #4]
 800315a:	699b      	ldr	r3, [r3, #24]
 800315c:	429a      	cmp	r2, r3
 800315e:	d105      	bne.n	800316c <chOQIsEmptyI+0x1c>
 8003160:	9b01      	ldr	r3, [sp, #4]
 8003162:	689b      	ldr	r3, [r3, #8]
 8003164:	2b00      	cmp	r3, #0
 8003166:	d001      	beq.n	800316c <chOQIsEmptyI+0x1c>
 8003168:	2301      	movs	r3, #1
 800316a:	e000      	b.n	800316e <chOQIsEmptyI+0x1e>
 800316c:	2300      	movs	r3, #0
 800316e:	f003 0301 	and.w	r3, r3, #1
 8003172:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 8003174:	4618      	mov	r0, r3
 8003176:	b002      	add	sp, #8
 8003178:	4770      	bx	lr
 800317a:	bf00      	nop
 800317c:	f3af 8000 	nop.w

08003180 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8003180:	b082      	sub	sp, #8
 8003182:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8003184:	9b01      	ldr	r3, [sp, #4]
 8003186:	689b      	ldr	r3, [r3, #8]
 8003188:	2b00      	cmp	r3, #0
 800318a:	bf14      	ite	ne
 800318c:	2300      	movne	r3, #0
 800318e:	2301      	moveq	r3, #1
 8003190:	b2db      	uxtb	r3, r3
}
 8003192:	4618      	mov	r0, r3
 8003194:	b002      	add	sp, #8
 8003196:	4770      	bx	lr
 8003198:	f3af 8000 	nop.w
 800319c:	f3af 8000 	nop.w

080031a0 <chIQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {
 80031a0:	b500      	push	{lr}
 80031a2:	b085      	sub	sp, #20
 80031a4:	9003      	str	r0, [sp, #12]
 80031a6:	9102      	str	r1, [sp, #8]
 80031a8:	9201      	str	r2, [sp, #4]
 80031aa:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&iqp->q_waiting);
 80031ac:	9b03      	ldr	r3, [sp, #12]
 80031ae:	4618      	mov	r0, r3
 80031b0:	f7ff ff96 	bl	80030e0 <chThdQueueObjectInit>
  iqp->q_counter = 0;
 80031b4:	9b03      	ldr	r3, [sp, #12]
 80031b6:	2200      	movs	r2, #0
 80031b8:	609a      	str	r2, [r3, #8]
  iqp->q_buffer  = bp;
 80031ba:	9b03      	ldr	r3, [sp, #12]
 80031bc:	9a02      	ldr	r2, [sp, #8]
 80031be:	60da      	str	r2, [r3, #12]
  iqp->q_rdptr   = bp;
 80031c0:	9b03      	ldr	r3, [sp, #12]
 80031c2:	9a02      	ldr	r2, [sp, #8]
 80031c4:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr   = bp;
 80031c6:	9b03      	ldr	r3, [sp, #12]
 80031c8:	9a02      	ldr	r2, [sp, #8]
 80031ca:	615a      	str	r2, [r3, #20]
  iqp->q_top     = bp + size;
 80031cc:	9a02      	ldr	r2, [sp, #8]
 80031ce:	9b01      	ldr	r3, [sp, #4]
 80031d0:	441a      	add	r2, r3
 80031d2:	9b03      	ldr	r3, [sp, #12]
 80031d4:	611a      	str	r2, [r3, #16]
  iqp->q_notify  = infy;
 80031d6:	9b03      	ldr	r3, [sp, #12]
 80031d8:	9a00      	ldr	r2, [sp, #0]
 80031da:	61da      	str	r2, [r3, #28]
  iqp->q_link    = link;
 80031dc:	9b03      	ldr	r3, [sp, #12]
 80031de:	9a06      	ldr	r2, [sp, #24]
 80031e0:	621a      	str	r2, [r3, #32]
}
 80031e2:	b005      	add	sp, #20
 80031e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80031e8:	f3af 8000 	nop.w
 80031ec:	f3af 8000 	nop.w

080031f0 <chIQResetI>:
 *
 * @param[in] iqp       pointer to an @p input_queue_t structure
 *
 * @iclass
 */
void chIQResetI(input_queue_t *iqp) {
 80031f0:	b500      	push	{lr}
 80031f2:	b083      	sub	sp, #12
 80031f4:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  iqp->q_rdptr = iqp->q_buffer;
 80031f6:	9b01      	ldr	r3, [sp, #4]
 80031f8:	68da      	ldr	r2, [r3, #12]
 80031fa:	9b01      	ldr	r3, [sp, #4]
 80031fc:	619a      	str	r2, [r3, #24]
  iqp->q_wrptr = iqp->q_buffer;
 80031fe:	9b01      	ldr	r3, [sp, #4]
 8003200:	68da      	ldr	r2, [r3, #12]
 8003202:	9b01      	ldr	r3, [sp, #4]
 8003204:	615a      	str	r2, [r3, #20]
  iqp->q_counter = 0;
 8003206:	9b01      	ldr	r3, [sp, #4]
 8003208:	2200      	movs	r2, #0
 800320a:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&iqp->q_waiting, Q_RESET);
 800320c:	9b01      	ldr	r3, [sp, #4]
 800320e:	4618      	mov	r0, r3
 8003210:	f06f 0101 	mvn.w	r1, #1
 8003214:	f7fe f9cc 	bl	80015b0 <chThdDequeueAllI>
}
 8003218:	b003      	add	sp, #12
 800321a:	f85d fb04 	ldr.w	pc, [sp], #4
 800321e:	bf00      	nop

08003220 <chIQPutI>:
 * @retval Q_FULL       if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t chIQPutI(input_queue_t *iqp, uint8_t b) {
 8003220:	b500      	push	{lr}
 8003222:	b083      	sub	sp, #12
 8003224:	9001      	str	r0, [sp, #4]
 8003226:	460b      	mov	r3, r1
 8003228:	f88d 3003 	strb.w	r3, [sp, #3]

  chDbgCheckClassI();

  if (chIQIsFullI(iqp)) {
 800322c:	9801      	ldr	r0, [sp, #4]
 800322e:	f7ff ff77 	bl	8003120 <chIQIsFullI>
 8003232:	4603      	mov	r3, r0
 8003234:	2b00      	cmp	r3, #0
 8003236:	d002      	beq.n	800323e <chIQPutI+0x1e>
    return Q_FULL;
 8003238:	f06f 0303 	mvn.w	r3, #3
 800323c:	e01c      	b.n	8003278 <chIQPutI+0x58>
  }

  iqp->q_counter++;
 800323e:	9b01      	ldr	r3, [sp, #4]
 8003240:	689b      	ldr	r3, [r3, #8]
 8003242:	1c5a      	adds	r2, r3, #1
 8003244:	9b01      	ldr	r3, [sp, #4]
 8003246:	609a      	str	r2, [r3, #8]
  *iqp->q_wrptr++ = b;
 8003248:	9b01      	ldr	r3, [sp, #4]
 800324a:	695b      	ldr	r3, [r3, #20]
 800324c:	1c59      	adds	r1, r3, #1
 800324e:	9a01      	ldr	r2, [sp, #4]
 8003250:	6151      	str	r1, [r2, #20]
 8003252:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8003256:	701a      	strb	r2, [r3, #0]
  if (iqp->q_wrptr >= iqp->q_top) {
 8003258:	9b01      	ldr	r3, [sp, #4]
 800325a:	695a      	ldr	r2, [r3, #20]
 800325c:	9b01      	ldr	r3, [sp, #4]
 800325e:	691b      	ldr	r3, [r3, #16]
 8003260:	429a      	cmp	r2, r3
 8003262:	d303      	bcc.n	800326c <chIQPutI+0x4c>
    iqp->q_wrptr = iqp->q_buffer;
 8003264:	9b01      	ldr	r3, [sp, #4]
 8003266:	68da      	ldr	r2, [r3, #12]
 8003268:	9b01      	ldr	r3, [sp, #4]
 800326a:	615a      	str	r2, [r3, #20]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 800326c:	9b01      	ldr	r3, [sp, #4]
 800326e:	4618      	mov	r0, r3
 8003270:	2100      	movs	r1, #0
 8003272:	f7fe f985 	bl	8001580 <chThdDequeueNextI>

  return Q_OK;
 8003276:	2300      	movs	r3, #0
}
 8003278:	4618      	mov	r0, r3
 800327a:	b003      	add	sp, #12
 800327c:	f85d fb04 	ldr.w	pc, [sp], #4

08003280 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003280:	b500      	push	{lr}
 8003282:	b085      	sub	sp, #20
 8003284:	9001      	str	r0, [sp, #4]
 8003286:	9100      	str	r1, [sp, #0]
  uint8_t b;

  chSysLock();
 8003288:	f7ff ff1a 	bl	80030c0 <chSysLock>
  if (iqp->q_notify != NULL) {
 800328c:	9b01      	ldr	r3, [sp, #4]
 800328e:	69db      	ldr	r3, [r3, #28]
 8003290:	2b00      	cmp	r3, #0
 8003292:	d004      	beq.n	800329e <chIQGetTimeout+0x1e>
    iqp->q_notify(iqp);
 8003294:	9b01      	ldr	r3, [sp, #4]
 8003296:	69db      	ldr	r3, [r3, #28]
 8003298:	9801      	ldr	r0, [sp, #4]
 800329a:	4798      	blx	r3
  }

  while (chIQIsEmptyI(iqp)) {
 800329c:	e00d      	b.n	80032ba <chIQGetTimeout+0x3a>
 800329e:	e00c      	b.n	80032ba <chIQGetTimeout+0x3a>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 80032a0:	9b01      	ldr	r3, [sp, #4]
 80032a2:	4618      	mov	r0, r3
 80032a4:	9900      	ldr	r1, [sp, #0]
 80032a6:	f7fe f94b 	bl	8001540 <chThdEnqueueTimeoutS>
 80032aa:	9003      	str	r0, [sp, #12]
    if (msg < Q_OK) {
 80032ac:	9b03      	ldr	r3, [sp, #12]
 80032ae:	2b00      	cmp	r3, #0
 80032b0:	da03      	bge.n	80032ba <chIQGetTimeout+0x3a>
      chSysUnlock();
 80032b2:	f7ff ff0d 	bl	80030d0 <chSysUnlock>
      return msg;
 80032b6:	9b03      	ldr	r3, [sp, #12]
 80032b8:	e020      	b.n	80032fc <chIQGetTimeout+0x7c>
  chSysLock();
  if (iqp->q_notify != NULL) {
    iqp->q_notify(iqp);
  }

  while (chIQIsEmptyI(iqp)) {
 80032ba:	9801      	ldr	r0, [sp, #4]
 80032bc:	f7ff ff20 	bl	8003100 <chIQIsEmptyI>
 80032c0:	4603      	mov	r3, r0
 80032c2:	2b00      	cmp	r3, #0
 80032c4:	d1ec      	bne.n	80032a0 <chIQGetTimeout+0x20>
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 80032c6:	9b01      	ldr	r3, [sp, #4]
 80032c8:	689b      	ldr	r3, [r3, #8]
 80032ca:	1e5a      	subs	r2, r3, #1
 80032cc:	9b01      	ldr	r3, [sp, #4]
 80032ce:	609a      	str	r2, [r3, #8]
  b = *iqp->q_rdptr++;
 80032d0:	9b01      	ldr	r3, [sp, #4]
 80032d2:	699b      	ldr	r3, [r3, #24]
 80032d4:	1c59      	adds	r1, r3, #1
 80032d6:	9a01      	ldr	r2, [sp, #4]
 80032d8:	6191      	str	r1, [r2, #24]
 80032da:	781b      	ldrb	r3, [r3, #0]
 80032dc:	f88d 300b 	strb.w	r3, [sp, #11]
  if (iqp->q_rdptr >= iqp->q_top) {
 80032e0:	9b01      	ldr	r3, [sp, #4]
 80032e2:	699a      	ldr	r2, [r3, #24]
 80032e4:	9b01      	ldr	r3, [sp, #4]
 80032e6:	691b      	ldr	r3, [r3, #16]
 80032e8:	429a      	cmp	r2, r3
 80032ea:	d303      	bcc.n	80032f4 <chIQGetTimeout+0x74>
    iqp->q_rdptr = iqp->q_buffer;
 80032ec:	9b01      	ldr	r3, [sp, #4]
 80032ee:	68da      	ldr	r2, [r3, #12]
 80032f0:	9b01      	ldr	r3, [sp, #4]
 80032f2:	619a      	str	r2, [r3, #24]
  }
  chSysUnlock();
 80032f4:	f7ff feec 	bl	80030d0 <chSysUnlock>

  return (msg_t)b;
 80032f8:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 80032fc:	4618      	mov	r0, r3
 80032fe:	b005      	add	sp, #20
 8003300:	f85d fb04 	ldr.w	pc, [sp], #4
 8003304:	f3af 8000 	nop.w
 8003308:	f3af 8000 	nop.w
 800330c:	f3af 8000 	nop.w

08003310 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8003310:	b500      	push	{lr}
 8003312:	b087      	sub	sp, #28
 8003314:	9003      	str	r0, [sp, #12]
 8003316:	9102      	str	r1, [sp, #8]
 8003318:	9201      	str	r2, [sp, #4]
 800331a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = iqp->q_notify;
 800331c:	9b03      	ldr	r3, [sp, #12]
 800331e:	69db      	ldr	r3, [r3, #28]
 8003320:	9304      	str	r3, [sp, #16]
  size_t r = 0;
 8003322:	2300      	movs	r3, #0
 8003324:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003326:	f7ff fecb 	bl	80030c0 <chSysLock>
  while (true) {
    if (nfy != NULL) {
 800332a:	9b04      	ldr	r3, [sp, #16]
 800332c:	2b00      	cmp	r3, #0
 800332e:	d003      	beq.n	8003338 <chIQReadTimeout+0x28>
      nfy(iqp);
 8003330:	9b04      	ldr	r3, [sp, #16]
 8003332:	9803      	ldr	r0, [sp, #12]
 8003334:	4798      	blx	r3
    }

    while (chIQIsEmptyI(iqp)) {
 8003336:	e00c      	b.n	8003352 <chIQReadTimeout+0x42>
 8003338:	e00b      	b.n	8003352 <chIQReadTimeout+0x42>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 800333a:	9b03      	ldr	r3, [sp, #12]
 800333c:	4618      	mov	r0, r3
 800333e:	9900      	ldr	r1, [sp, #0]
 8003340:	f7fe f8fe 	bl	8001540 <chThdEnqueueTimeoutS>
 8003344:	4603      	mov	r3, r0
 8003346:	2b00      	cmp	r3, #0
 8003348:	d003      	beq.n	8003352 <chIQReadTimeout+0x42>
        chSysUnlock();
 800334a:	f7ff fec1 	bl	80030d0 <chSysUnlock>
        return r;
 800334e:	9b05      	ldr	r3, [sp, #20]
 8003350:	e02e      	b.n	80033b0 <chIQReadTimeout+0xa0>
  while (true) {
    if (nfy != NULL) {
      nfy(iqp);
    }

    while (chIQIsEmptyI(iqp)) {
 8003352:	9803      	ldr	r0, [sp, #12]
 8003354:	f7ff fed4 	bl	8003100 <chIQIsEmptyI>
 8003358:	4603      	mov	r3, r0
 800335a:	2b00      	cmp	r3, #0
 800335c:	d1ed      	bne.n	800333a <chIQReadTimeout+0x2a>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 800335e:	9b03      	ldr	r3, [sp, #12]
 8003360:	689b      	ldr	r3, [r3, #8]
 8003362:	1e5a      	subs	r2, r3, #1
 8003364:	9b03      	ldr	r3, [sp, #12]
 8003366:	609a      	str	r2, [r3, #8]
    *bp++ = *iqp->q_rdptr++;
 8003368:	9b02      	ldr	r3, [sp, #8]
 800336a:	1c5a      	adds	r2, r3, #1
 800336c:	9202      	str	r2, [sp, #8]
 800336e:	9a03      	ldr	r2, [sp, #12]
 8003370:	6992      	ldr	r2, [r2, #24]
 8003372:	1c50      	adds	r0, r2, #1
 8003374:	9903      	ldr	r1, [sp, #12]
 8003376:	6188      	str	r0, [r1, #24]
 8003378:	7812      	ldrb	r2, [r2, #0]
 800337a:	701a      	strb	r2, [r3, #0]
    if (iqp->q_rdptr >= iqp->q_top) {
 800337c:	9b03      	ldr	r3, [sp, #12]
 800337e:	699a      	ldr	r2, [r3, #24]
 8003380:	9b03      	ldr	r3, [sp, #12]
 8003382:	691b      	ldr	r3, [r3, #16]
 8003384:	429a      	cmp	r2, r3
 8003386:	d303      	bcc.n	8003390 <chIQReadTimeout+0x80>
      iqp->q_rdptr = iqp->q_buffer;
 8003388:	9b03      	ldr	r3, [sp, #12]
 800338a:	68da      	ldr	r2, [r3, #12]
 800338c:	9b03      	ldr	r3, [sp, #12]
 800338e:	619a      	str	r2, [r3, #24]
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 8003390:	f7ff fe9e 	bl	80030d0 <chSysUnlock>

    r++;
 8003394:	9b05      	ldr	r3, [sp, #20]
 8003396:	3301      	adds	r3, #1
 8003398:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 800339a:	9b01      	ldr	r3, [sp, #4]
 800339c:	3b01      	subs	r3, #1
 800339e:	9301      	str	r3, [sp, #4]
 80033a0:	9b01      	ldr	r3, [sp, #4]
 80033a2:	2b00      	cmp	r3, #0
 80033a4:	d101      	bne.n	80033aa <chIQReadTimeout+0x9a>
      return r;
 80033a6:	9b05      	ldr	r3, [sp, #20]
 80033a8:	e002      	b.n	80033b0 <chIQReadTimeout+0xa0>
    }

    chSysLock();
 80033aa:	f7ff fe89 	bl	80030c0 <chSysLock>
  }
 80033ae:	e7bc      	b.n	800332a <chIQReadTimeout+0x1a>
}
 80033b0:	4618      	mov	r0, r3
 80033b2:	b007      	add	sp, #28
 80033b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80033b8:	f3af 8000 	nop.w
 80033bc:	f3af 8000 	nop.w

080033c0 <chOQObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {
 80033c0:	b500      	push	{lr}
 80033c2:	b085      	sub	sp, #20
 80033c4:	9003      	str	r0, [sp, #12]
 80033c6:	9102      	str	r1, [sp, #8]
 80033c8:	9201      	str	r2, [sp, #4]
 80033ca:	9300      	str	r3, [sp, #0]

  chThdQueueObjectInit(&oqp->q_waiting);
 80033cc:	9b03      	ldr	r3, [sp, #12]
 80033ce:	4618      	mov	r0, r3
 80033d0:	f7ff fe86 	bl	80030e0 <chThdQueueObjectInit>
  oqp->q_counter = size;
 80033d4:	9b03      	ldr	r3, [sp, #12]
 80033d6:	9a01      	ldr	r2, [sp, #4]
 80033d8:	609a      	str	r2, [r3, #8]
  oqp->q_buffer  = bp;
 80033da:	9b03      	ldr	r3, [sp, #12]
 80033dc:	9a02      	ldr	r2, [sp, #8]
 80033de:	60da      	str	r2, [r3, #12]
  oqp->q_rdptr   = bp;
 80033e0:	9b03      	ldr	r3, [sp, #12]
 80033e2:	9a02      	ldr	r2, [sp, #8]
 80033e4:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr   = bp;
 80033e6:	9b03      	ldr	r3, [sp, #12]
 80033e8:	9a02      	ldr	r2, [sp, #8]
 80033ea:	615a      	str	r2, [r3, #20]
  oqp->q_top     = bp + size;
 80033ec:	9a02      	ldr	r2, [sp, #8]
 80033ee:	9b01      	ldr	r3, [sp, #4]
 80033f0:	441a      	add	r2, r3
 80033f2:	9b03      	ldr	r3, [sp, #12]
 80033f4:	611a      	str	r2, [r3, #16]
  oqp->q_notify  = onfy;
 80033f6:	9b03      	ldr	r3, [sp, #12]
 80033f8:	9a00      	ldr	r2, [sp, #0]
 80033fa:	61da      	str	r2, [r3, #28]
  oqp->q_link    = link;
 80033fc:	9b03      	ldr	r3, [sp, #12]
 80033fe:	9a06      	ldr	r2, [sp, #24]
 8003400:	621a      	str	r2, [r3, #32]
}
 8003402:	b005      	add	sp, #20
 8003404:	f85d fb04 	ldr.w	pc, [sp], #4
 8003408:	f3af 8000 	nop.w
 800340c:	f3af 8000 	nop.w

08003410 <chOQResetI>:
 *
 * @param[in] oqp       pointer to an @p output_queue_t structure
 *
 * @iclass
 */
void chOQResetI(output_queue_t *oqp) {
 8003410:	b500      	push	{lr}
 8003412:	b083      	sub	sp, #12
 8003414:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  oqp->q_rdptr = oqp->q_buffer;
 8003416:	9b01      	ldr	r3, [sp, #4]
 8003418:	68da      	ldr	r2, [r3, #12]
 800341a:	9b01      	ldr	r3, [sp, #4]
 800341c:	619a      	str	r2, [r3, #24]
  oqp->q_wrptr = oqp->q_buffer;
 800341e:	9b01      	ldr	r3, [sp, #4]
 8003420:	68da      	ldr	r2, [r3, #12]
 8003422:	9b01      	ldr	r3, [sp, #4]
 8003424:	615a      	str	r2, [r3, #20]
  oqp->q_counter = chQSizeX(oqp);
 8003426:	9b01      	ldr	r3, [sp, #4]
 8003428:	691b      	ldr	r3, [r3, #16]
 800342a:	461a      	mov	r2, r3
 800342c:	9b01      	ldr	r3, [sp, #4]
 800342e:	68db      	ldr	r3, [r3, #12]
 8003430:	1ad3      	subs	r3, r2, r3
 8003432:	461a      	mov	r2, r3
 8003434:	9b01      	ldr	r3, [sp, #4]
 8003436:	609a      	str	r2, [r3, #8]
  chThdDequeueAllI(&oqp->q_waiting, Q_RESET);
 8003438:	9b01      	ldr	r3, [sp, #4]
 800343a:	4618      	mov	r0, r3
 800343c:	f06f 0101 	mvn.w	r1, #1
 8003440:	f7fe f8b6 	bl	80015b0 <chThdDequeueAllI>
}
 8003444:	b003      	add	sp, #12
 8003446:	f85d fb04 	ldr.w	pc, [sp], #4
 800344a:	bf00      	nop
 800344c:	f3af 8000 	nop.w

08003450 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003450:	b500      	push	{lr}
 8003452:	b087      	sub	sp, #28
 8003454:	9003      	str	r0, [sp, #12]
 8003456:	460b      	mov	r3, r1
 8003458:	9201      	str	r2, [sp, #4]
 800345a:	f88d 300b 	strb.w	r3, [sp, #11]

  chSysLock();
 800345e:	f7ff fe2f 	bl	80030c0 <chSysLock>
  while (chOQIsFullI(oqp)) {
 8003462:	e00c      	b.n	800347e <chOQPutTimeout+0x2e>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8003464:	9b03      	ldr	r3, [sp, #12]
 8003466:	4618      	mov	r0, r3
 8003468:	9901      	ldr	r1, [sp, #4]
 800346a:	f7fe f869 	bl	8001540 <chThdEnqueueTimeoutS>
 800346e:	9005      	str	r0, [sp, #20]
    if (msg < Q_OK) {
 8003470:	9b05      	ldr	r3, [sp, #20]
 8003472:	2b00      	cmp	r3, #0
 8003474:	da03      	bge.n	800347e <chOQPutTimeout+0x2e>
      chSysUnlock();
 8003476:	f7ff fe2b 	bl	80030d0 <chSysUnlock>
      return msg;
 800347a:	9b05      	ldr	r3, [sp, #20]
 800347c:	e027      	b.n	80034ce <chOQPutTimeout+0x7e>
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  chSysLock();
  while (chOQIsFullI(oqp)) {
 800347e:	9803      	ldr	r0, [sp, #12]
 8003480:	f7ff fe7e 	bl	8003180 <chOQIsFullI>
 8003484:	4603      	mov	r3, r0
 8003486:	2b00      	cmp	r3, #0
 8003488:	d1ec      	bne.n	8003464 <chOQPutTimeout+0x14>
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 800348a:	9b03      	ldr	r3, [sp, #12]
 800348c:	689b      	ldr	r3, [r3, #8]
 800348e:	1e5a      	subs	r2, r3, #1
 8003490:	9b03      	ldr	r3, [sp, #12]
 8003492:	609a      	str	r2, [r3, #8]
  *oqp->q_wrptr++ = b;
 8003494:	9b03      	ldr	r3, [sp, #12]
 8003496:	695b      	ldr	r3, [r3, #20]
 8003498:	1c59      	adds	r1, r3, #1
 800349a:	9a03      	ldr	r2, [sp, #12]
 800349c:	6151      	str	r1, [r2, #20]
 800349e:	f89d 200b 	ldrb.w	r2, [sp, #11]
 80034a2:	701a      	strb	r2, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 80034a4:	9b03      	ldr	r3, [sp, #12]
 80034a6:	695a      	ldr	r2, [r3, #20]
 80034a8:	9b03      	ldr	r3, [sp, #12]
 80034aa:	691b      	ldr	r3, [r3, #16]
 80034ac:	429a      	cmp	r2, r3
 80034ae:	d303      	bcc.n	80034b8 <chOQPutTimeout+0x68>
    oqp->q_wrptr = oqp->q_buffer;
 80034b0:	9b03      	ldr	r3, [sp, #12]
 80034b2:	68da      	ldr	r2, [r3, #12]
 80034b4:	9b03      	ldr	r3, [sp, #12]
 80034b6:	615a      	str	r2, [r3, #20]
  }

  if (oqp->q_notify != NULL) {
 80034b8:	9b03      	ldr	r3, [sp, #12]
 80034ba:	69db      	ldr	r3, [r3, #28]
 80034bc:	2b00      	cmp	r3, #0
 80034be:	d003      	beq.n	80034c8 <chOQPutTimeout+0x78>
    oqp->q_notify(oqp);
 80034c0:	9b03      	ldr	r3, [sp, #12]
 80034c2:	69db      	ldr	r3, [r3, #28]
 80034c4:	9803      	ldr	r0, [sp, #12]
 80034c6:	4798      	blx	r3
  }
  chSysUnlock();
 80034c8:	f7ff fe02 	bl	80030d0 <chSysUnlock>

  return Q_OK;
 80034cc:	2300      	movs	r3, #0
}
 80034ce:	4618      	mov	r0, r3
 80034d0:	b007      	add	sp, #28
 80034d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80034d6:	bf00      	nop
 80034d8:	f3af 8000 	nop.w
 80034dc:	f3af 8000 	nop.w

080034e0 <chOQGetI>:
 * @return              The byte value from the queue.
 * @retval Q_EMPTY      if the queue is empty.
 *
 * @iclass
 */
msg_t chOQGetI(output_queue_t *oqp) {
 80034e0:	b500      	push	{lr}
 80034e2:	b085      	sub	sp, #20
 80034e4:	9001      	str	r0, [sp, #4]
  uint8_t b;

  chDbgCheckClassI();

  if (chOQIsEmptyI(oqp)) {
 80034e6:	9801      	ldr	r0, [sp, #4]
 80034e8:	f7ff fe32 	bl	8003150 <chOQIsEmptyI>
 80034ec:	4603      	mov	r3, r0
 80034ee:	2b00      	cmp	r3, #0
 80034f0:	d002      	beq.n	80034f8 <chOQGetI+0x18>
    return Q_EMPTY;
 80034f2:	f06f 0302 	mvn.w	r3, #2
 80034f6:	e01d      	b.n	8003534 <chOQGetI+0x54>
  }

  oqp->q_counter++;
 80034f8:	9b01      	ldr	r3, [sp, #4]
 80034fa:	689b      	ldr	r3, [r3, #8]
 80034fc:	1c5a      	adds	r2, r3, #1
 80034fe:	9b01      	ldr	r3, [sp, #4]
 8003500:	609a      	str	r2, [r3, #8]
  b = *oqp->q_rdptr++;
 8003502:	9b01      	ldr	r3, [sp, #4]
 8003504:	699b      	ldr	r3, [r3, #24]
 8003506:	1c59      	adds	r1, r3, #1
 8003508:	9a01      	ldr	r2, [sp, #4]
 800350a:	6191      	str	r1, [r2, #24]
 800350c:	781b      	ldrb	r3, [r3, #0]
 800350e:	f88d 300f 	strb.w	r3, [sp, #15]
  if (oqp->q_rdptr >= oqp->q_top) {
 8003512:	9b01      	ldr	r3, [sp, #4]
 8003514:	699a      	ldr	r2, [r3, #24]
 8003516:	9b01      	ldr	r3, [sp, #4]
 8003518:	691b      	ldr	r3, [r3, #16]
 800351a:	429a      	cmp	r2, r3
 800351c:	d303      	bcc.n	8003526 <chOQGetI+0x46>
    oqp->q_rdptr = oqp->q_buffer;
 800351e:	9b01      	ldr	r3, [sp, #4]
 8003520:	68da      	ldr	r2, [r3, #12]
 8003522:	9b01      	ldr	r3, [sp, #4]
 8003524:	619a      	str	r2, [r3, #24]
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 8003526:	9b01      	ldr	r3, [sp, #4]
 8003528:	4618      	mov	r0, r3
 800352a:	2100      	movs	r1, #0
 800352c:	f7fe f828 	bl	8001580 <chThdDequeueNextI>

  return (msg_t)b;
 8003530:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8003534:	4618      	mov	r0, r3
 8003536:	b005      	add	sp, #20
 8003538:	f85d fb04 	ldr.w	pc, [sp], #4
 800353c:	f3af 8000 	nop.w

08003540 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8003540:	b500      	push	{lr}
 8003542:	b087      	sub	sp, #28
 8003544:	9003      	str	r0, [sp, #12]
 8003546:	9102      	str	r1, [sp, #8]
 8003548:	9201      	str	r2, [sp, #4]
 800354a:	9300      	str	r3, [sp, #0]
  qnotify_t nfy = oqp->q_notify;
 800354c:	9b03      	ldr	r3, [sp, #12]
 800354e:	69db      	ldr	r3, [r3, #28]
 8003550:	9304      	str	r3, [sp, #16]
  size_t w = 0;
 8003552:	2300      	movs	r3, #0
 8003554:	9305      	str	r3, [sp, #20]

  chDbgCheck(n > 0U);

  chSysLock();
 8003556:	f7ff fdb3 	bl	80030c0 <chSysLock>
  while (true) {
    while (chOQIsFullI(oqp)) {
 800355a:	e00b      	b.n	8003574 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 800355c:	9b03      	ldr	r3, [sp, #12]
 800355e:	4618      	mov	r0, r3
 8003560:	9900      	ldr	r1, [sp, #0]
 8003562:	f7fd ffed 	bl	8001540 <chThdEnqueueTimeoutS>
 8003566:	4603      	mov	r3, r0
 8003568:	2b00      	cmp	r3, #0
 800356a:	d003      	beq.n	8003574 <chOQWriteTimeout+0x34>
        chSysUnlock();
 800356c:	f7ff fdb0 	bl	80030d0 <chSysUnlock>
        return w;
 8003570:	9b05      	ldr	r3, [sp, #20]
 8003572:	e035      	b.n	80035e0 <chOQWriteTimeout+0xa0>

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8003574:	9803      	ldr	r0, [sp, #12]
 8003576:	f7ff fe03 	bl	8003180 <chOQIsFullI>
 800357a:	4603      	mov	r3, r0
 800357c:	2b00      	cmp	r3, #0
 800357e:	d1ed      	bne.n	800355c <chOQWriteTimeout+0x1c>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8003580:	9b03      	ldr	r3, [sp, #12]
 8003582:	689b      	ldr	r3, [r3, #8]
 8003584:	1e5a      	subs	r2, r3, #1
 8003586:	9b03      	ldr	r3, [sp, #12]
 8003588:	609a      	str	r2, [r3, #8]
    *oqp->q_wrptr++ = *bp++;
 800358a:	9b03      	ldr	r3, [sp, #12]
 800358c:	695b      	ldr	r3, [r3, #20]
 800358e:	1c59      	adds	r1, r3, #1
 8003590:	9a03      	ldr	r2, [sp, #12]
 8003592:	6151      	str	r1, [r2, #20]
 8003594:	9a02      	ldr	r2, [sp, #8]
 8003596:	1c51      	adds	r1, r2, #1
 8003598:	9102      	str	r1, [sp, #8]
 800359a:	7812      	ldrb	r2, [r2, #0]
 800359c:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 800359e:	9b03      	ldr	r3, [sp, #12]
 80035a0:	695a      	ldr	r2, [r3, #20]
 80035a2:	9b03      	ldr	r3, [sp, #12]
 80035a4:	691b      	ldr	r3, [r3, #16]
 80035a6:	429a      	cmp	r2, r3
 80035a8:	d303      	bcc.n	80035b2 <chOQWriteTimeout+0x72>
      oqp->q_wrptr = oqp->q_buffer;
 80035aa:	9b03      	ldr	r3, [sp, #12]
 80035ac:	68da      	ldr	r2, [r3, #12]
 80035ae:	9b03      	ldr	r3, [sp, #12]
 80035b0:	615a      	str	r2, [r3, #20]
    }

    if (nfy != NULL) {
 80035b2:	9b04      	ldr	r3, [sp, #16]
 80035b4:	2b00      	cmp	r3, #0
 80035b6:	d002      	beq.n	80035be <chOQWriteTimeout+0x7e>
      nfy(oqp);
 80035b8:	9b04      	ldr	r3, [sp, #16]
 80035ba:	9803      	ldr	r0, [sp, #12]
 80035bc:	4798      	blx	r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/
 80035be:	f7ff fd87 	bl	80030d0 <chSysUnlock>

    w++;
 80035c2:	9b05      	ldr	r3, [sp, #20]
 80035c4:	3301      	adds	r3, #1
 80035c6:	9305      	str	r3, [sp, #20]
    if (--n == 0U) {
 80035c8:	9b01      	ldr	r3, [sp, #4]
 80035ca:	3b01      	subs	r3, #1
 80035cc:	9301      	str	r3, [sp, #4]
 80035ce:	9b01      	ldr	r3, [sp, #4]
 80035d0:	2b00      	cmp	r3, #0
 80035d2:	d101      	bne.n	80035d8 <chOQWriteTimeout+0x98>
      return w;
 80035d4:	9b05      	ldr	r3, [sp, #20]
 80035d6:	e003      	b.n	80035e0 <chOQWriteTimeout+0xa0>
    }
    chSysLock();
 80035d8:	f7ff fd72 	bl	80030c0 <chSysLock>
  }
 80035dc:	bf00      	nop

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 80035de:	e7c9      	b.n	8003574 <chOQWriteTimeout+0x34>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 80035e0:	4618      	mov	r0, r3
 80035e2:	b007      	add	sp, #28
 80035e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80035e8:	f3af 8000 	nop.w
 80035ec:	f3af 8000 	nop.w

080035f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80035f0:	b082      	sub	sp, #8
 80035f2:	2320      	movs	r3, #32
 80035f4:	9301      	str	r3, [sp, #4]
 80035f6:	9b01      	ldr	r3, [sp, #4]
 80035f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80035fc:	b002      	add	sp, #8
 80035fe:	4770      	bx	lr

08003600 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003600:	b082      	sub	sp, #8
 8003602:	2300      	movs	r3, #0
 8003604:	9301      	str	r3, [sp, #4]
 8003606:	9b01      	ldr	r3, [sp, #4]
 8003608:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800360c:	b002      	add	sp, #8
 800360e:	4770      	bx	lr

08003610 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003610:	b508      	push	{r3, lr}

  port_lock();
 8003612:	f7ff ffed 	bl	80035f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003616:	bd08      	pop	{r3, pc}
 8003618:	f3af 8000 	nop.w
 800361c:	f3af 8000 	nop.w

08003620 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003620:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003622:	f7ff ffed 	bl	8003600 <port_unlock>
}
 8003626:	bd08      	pop	{r3, pc}
 8003628:	f3af 8000 	nop.w
 800362c:	f3af 8000 	nop.w

08003630 <_core_init>:
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8003630:	4b06      	ldr	r3, [pc, #24]	; (800364c <_core_init+0x1c>)
 8003632:	3307      	adds	r3, #7
 8003634:	f023 0307 	bic.w	r3, r3, #7
 8003638:	461a      	mov	r2, r3
 800363a:	4b05      	ldr	r3, [pc, #20]	; (8003650 <_core_init+0x20>)
 800363c:	601a      	str	r2, [r3, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800363e:	4b05      	ldr	r3, [pc, #20]	; (8003654 <_core_init+0x24>)
 8003640:	f023 0307 	bic.w	r3, r3, #7
 8003644:	461a      	mov	r2, r3
 8003646:	4b04      	ldr	r3, [pc, #16]	; (8003658 <_core_init+0x28>)
 8003648:	601a      	str	r2, [r3, #0]

  nextmem = (uint8_t *)&buffer[0];
  endmem = (uint8_t *)&buffer[MEM_ALIGN_NEXT(CH_CFG_MEMCORE_SIZE) /
                              MEM_ALIGN_SIZE];
#endif
}
 800364a:	4770      	bx	lr
 800364c:	200055c0 	.word	0x200055c0
 8003650:	20001188 	.word	0x20001188
 8003654:	20018000 	.word	0x20018000
 8003658:	2000118c 	.word	0x2000118c
 800365c:	f3af 8000 	nop.w

08003660 <chCoreAlloc>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAlloc(size_t size) {
 8003660:	b500      	push	{lr}
 8003662:	b085      	sub	sp, #20
 8003664:	9001      	str	r0, [sp, #4]
  void *p;

  chSysLock();
 8003666:	f7ff ffd3 	bl	8003610 <chSysLock>
  p = chCoreAllocI(size);
 800366a:	9801      	ldr	r0, [sp, #4]
 800366c:	f000 f808 	bl	8003680 <chCoreAllocI>
 8003670:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003672:	f7ff ffd5 	bl	8003620 <chSysUnlock>

  return p;
 8003676:	9b03      	ldr	r3, [sp, #12]
}
 8003678:	4618      	mov	r0, r3
 800367a:	b005      	add	sp, #20
 800367c:	f85d fb04 	ldr.w	pc, [sp], #4

08003680 <chCoreAllocI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocI(size_t size) {
 8003680:	b084      	sub	sp, #16
 8003682:	9001      	str	r0, [sp, #4]
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8003684:	9b01      	ldr	r3, [sp, #4]
 8003686:	3307      	adds	r3, #7
 8003688:	f023 0307 	bic.w	r3, r3, #7
 800368c:	9301      	str	r3, [sp, #4]
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800368e:	4b0c      	ldr	r3, [pc, #48]	; (80036c0 <chCoreAllocI+0x40>)
 8003690:	681b      	ldr	r3, [r3, #0]
 8003692:	461a      	mov	r2, r3
 8003694:	4b0b      	ldr	r3, [pc, #44]	; (80036c4 <chCoreAllocI+0x44>)
 8003696:	681b      	ldr	r3, [r3, #0]
 8003698:	1ad3      	subs	r3, r2, r3
 800369a:	461a      	mov	r2, r3
 800369c:	9b01      	ldr	r3, [sp, #4]
 800369e:	429a      	cmp	r2, r3
 80036a0:	d201      	bcs.n	80036a6 <chCoreAllocI+0x26>
  /*lint -restore*/
    return NULL;
 80036a2:	2300      	movs	r3, #0
 80036a4:	e009      	b.n	80036ba <chCoreAllocI+0x3a>
  }
  p = nextmem;
 80036a6:	4b07      	ldr	r3, [pc, #28]	; (80036c4 <chCoreAllocI+0x44>)
 80036a8:	681b      	ldr	r3, [r3, #0]
 80036aa:	9303      	str	r3, [sp, #12]
  nextmem += size;
 80036ac:	4b05      	ldr	r3, [pc, #20]	; (80036c4 <chCoreAllocI+0x44>)
 80036ae:	681a      	ldr	r2, [r3, #0]
 80036b0:	9b01      	ldr	r3, [sp, #4]
 80036b2:	441a      	add	r2, r3
 80036b4:	4b03      	ldr	r3, [pc, #12]	; (80036c4 <chCoreAllocI+0x44>)
 80036b6:	601a      	str	r2, [r3, #0]

  return p;
 80036b8:	9b03      	ldr	r3, [sp, #12]
}
 80036ba:	4618      	mov	r0, r3
 80036bc:	b004      	add	sp, #16
 80036be:	4770      	bx	lr
 80036c0:	2000118c 	.word	0x2000118c
 80036c4:	20001188 	.word	0x20001188
 80036c8:	f3af 8000 	nop.w
 80036cc:	f3af 8000 	nop.w

080036d0 <chCoreGetStatusX>:
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 80036d0:	4b03      	ldr	r3, [pc, #12]	; (80036e0 <chCoreGetStatusX+0x10>)
 80036d2:	681b      	ldr	r3, [r3, #0]
 80036d4:	461a      	mov	r2, r3
 80036d6:	4b03      	ldr	r3, [pc, #12]	; (80036e4 <chCoreGetStatusX+0x14>)
 80036d8:	681b      	ldr	r3, [r3, #0]
 80036da:	1ad3      	subs	r3, r2, r3
  /*lint -restore*/
}
 80036dc:	4618      	mov	r0, r3
 80036de:	4770      	bx	lr
 80036e0:	2000118c 	.word	0x2000118c
 80036e4:	20001188 	.word	0x20001188
 80036e8:	f3af 8000 	nop.w
 80036ec:	f3af 8000 	nop.w

080036f0 <_heap_init>:
/**
 * @brief   Initializes the default heap.
 *
 * @notapi
 */
void _heap_init(void) {
 80036f0:	b508      	push	{r3, lr}

  default_heap.h_provider = chCoreAlloc;
 80036f2:	4b06      	ldr	r3, [pc, #24]	; (800370c <_heap_init+0x1c>)
 80036f4:	4a06      	ldr	r2, [pc, #24]	; (8003710 <_heap_init+0x20>)
 80036f6:	601a      	str	r2, [r3, #0]
  default_heap.h_free.h.u.next = NULL;
 80036f8:	4b04      	ldr	r3, [pc, #16]	; (800370c <_heap_init+0x1c>)
 80036fa:	2200      	movs	r2, #0
 80036fc:	609a      	str	r2, [r3, #8]
  default_heap.h_free.h.size = 0;
 80036fe:	4b03      	ldr	r3, [pc, #12]	; (800370c <_heap_init+0x1c>)
 8003700:	2200      	movs	r2, #0
 8003702:	60da      	str	r2, [r3, #12]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.h_mtx);
 8003704:	4803      	ldr	r0, [pc, #12]	; (8003714 <_heap_init+0x24>)
 8003706:	f7fe fbf3 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&default_heap.h_sem, (cnt_t)1);
#endif
}
 800370a:	bd08      	pop	{r3, pc}
 800370c:	20001190 	.word	0x20001190
 8003710:	08003661 	.word	0x08003661
 8003714:	200011a0 	.word	0x200011a0
 8003718:	f3af 8000 	nop.w
 800371c:	f3af 8000 	nop.w

08003720 <chHeapObjectInit>:
 * @param[in] buf       heap buffer base
 * @param[in] size      heap size
 *
 * @init
 */
void chHeapObjectInit(memory_heap_t *heapp, void *buf, size_t size) {
 8003720:	b500      	push	{lr}
 8003722:	b087      	sub	sp, #28
 8003724:	9003      	str	r0, [sp, #12]
 8003726:	9102      	str	r1, [sp, #8]
 8003728:	9201      	str	r2, [sp, #4]
  union heap_header *hp = buf;
 800372a:	9b02      	ldr	r3, [sp, #8]
 800372c:	9305      	str	r3, [sp, #20]

  chDbgCheck(MEM_IS_ALIGNED(buf) && MEM_IS_ALIGNED(size));

  heapp->h_provider = NULL;
 800372e:	9b03      	ldr	r3, [sp, #12]
 8003730:	2200      	movs	r2, #0
 8003732:	601a      	str	r2, [r3, #0]
  heapp->h_free.h.u.next = hp;
 8003734:	9b03      	ldr	r3, [sp, #12]
 8003736:	9a05      	ldr	r2, [sp, #20]
 8003738:	609a      	str	r2, [r3, #8]
  heapp->h_free.h.size = 0;
 800373a:	9b03      	ldr	r3, [sp, #12]
 800373c:	2200      	movs	r2, #0
 800373e:	60da      	str	r2, [r3, #12]
  hp->h.u.next = NULL;
 8003740:	9b05      	ldr	r3, [sp, #20]
 8003742:	2200      	movs	r2, #0
 8003744:	601a      	str	r2, [r3, #0]
  hp->h.size = size - sizeof(union heap_header);
 8003746:	9b01      	ldr	r3, [sp, #4]
 8003748:	f1a3 0208 	sub.w	r2, r3, #8
 800374c:	9b05      	ldr	r3, [sp, #20]
 800374e:	605a      	str	r2, [r3, #4]
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&heapp->h_mtx);
 8003750:	9b03      	ldr	r3, [sp, #12]
 8003752:	3310      	adds	r3, #16
 8003754:	4618      	mov	r0, r3
 8003756:	f7fe fbcb 	bl	8001ef0 <chMtxObjectInit>
#else
  chSemObjectInit(&heapp->h_sem, (cnt_t)1);
#endif
}
 800375a:	b007      	add	sp, #28
 800375c:	f85d fb04 	ldr.w	pc, [sp], #4

08003760 <chHeapAlloc>:
 * @return              A pointer to the allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAlloc(memory_heap_t *heapp, size_t size) {
 8003760:	b500      	push	{lr}
 8003762:	b087      	sub	sp, #28
 8003764:	9001      	str	r0, [sp, #4]
 8003766:	9100      	str	r1, [sp, #0]
  union heap_header *qp, *hp, *fp;

  if (heapp == NULL) {
 8003768:	9b01      	ldr	r3, [sp, #4]
 800376a:	2b00      	cmp	r3, #0
 800376c:	d101      	bne.n	8003772 <chHeapAlloc+0x12>
    heapp = &default_heap;
 800376e:	4b37      	ldr	r3, [pc, #220]	; (800384c <chHeapAlloc+0xec>)
 8003770:	9301      	str	r3, [sp, #4]
  }

  size = MEM_ALIGN_NEXT(size);
 8003772:	9b00      	ldr	r3, [sp, #0]
 8003774:	3307      	adds	r3, #7
 8003776:	f023 0307 	bic.w	r3, r3, #7
 800377a:	9300      	str	r3, [sp, #0]
  qp = &heapp->h_free;
 800377c:	9b01      	ldr	r3, [sp, #4]
 800377e:	3308      	adds	r3, #8
 8003780:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003782:	9b01      	ldr	r3, [sp, #4]
 8003784:	3310      	adds	r3, #16
 8003786:	4618      	mov	r0, r3
 8003788:	f7fe fbc2 	bl	8001f10 <chMtxLock>
  while (qp->h.u.next != NULL) {
 800378c:	e036      	b.n	80037fc <chHeapAlloc+0x9c>
    hp = qp->h.u.next;
 800378e:	9b05      	ldr	r3, [sp, #20]
 8003790:	681b      	ldr	r3, [r3, #0]
 8003792:	9304      	str	r3, [sp, #16]
    if (hp->h.size >= size) {
 8003794:	9b04      	ldr	r3, [sp, #16]
 8003796:	685a      	ldr	r2, [r3, #4]
 8003798:	9b00      	ldr	r3, [sp, #0]
 800379a:	429a      	cmp	r2, r3
 800379c:	d32c      	bcc.n	80037f8 <chHeapAlloc+0x98>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 800379e:	9b04      	ldr	r3, [sp, #16]
 80037a0:	685a      	ldr	r2, [r3, #4]
 80037a2:	9b00      	ldr	r3, [sp, #0]
 80037a4:	3308      	adds	r3, #8
 80037a6:	429a      	cmp	r2, r3
 80037a8:	d204      	bcs.n	80037b4 <chHeapAlloc+0x54>
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80037aa:	9b04      	ldr	r3, [sp, #16]
 80037ac:	681a      	ldr	r2, [r3, #0]
 80037ae:	9b05      	ldr	r3, [sp, #20]
 80037b0:	601a      	str	r2, [r3, #0]
 80037b2:	e016      	b.n	80037e2 <chHeapAlloc+0x82>
      }
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
 80037b4:	9b00      	ldr	r3, [sp, #0]
 80037b6:	3308      	adds	r3, #8
 80037b8:	9a04      	ldr	r2, [sp, #16]
 80037ba:	4413      	add	r3, r2
 80037bc:	9303      	str	r3, [sp, #12]
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80037be:	9b04      	ldr	r3, [sp, #16]
 80037c0:	681a      	ldr	r2, [r3, #0]
 80037c2:	9b03      	ldr	r3, [sp, #12]
 80037c4:	601a      	str	r2, [r3, #0]
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80037c6:	9b04      	ldr	r3, [sp, #16]
 80037c8:	685a      	ldr	r2, [r3, #4]
 80037ca:	9b00      	ldr	r3, [sp, #0]
 80037cc:	1ad3      	subs	r3, r2, r3
 80037ce:	f1a3 0208 	sub.w	r2, r3, #8
 80037d2:	9b03      	ldr	r3, [sp, #12]
 80037d4:	605a      	str	r2, [r3, #4]
        qp->h.u.next = fp;
 80037d6:	9b05      	ldr	r3, [sp, #20]
 80037d8:	9a03      	ldr	r2, [sp, #12]
 80037da:	601a      	str	r2, [r3, #0]
        hp->h.size = size;
 80037dc:	9b04      	ldr	r3, [sp, #16]
 80037de:	9a00      	ldr	r2, [sp, #0]
 80037e0:	605a      	str	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 80037e2:	9b04      	ldr	r3, [sp, #16]
 80037e4:	9a01      	ldr	r2, [sp, #4]
 80037e6:	601a      	str	r2, [r3, #0]
      H_UNLOCK(heapp);
 80037e8:	9b01      	ldr	r3, [sp, #4]
 80037ea:	3310      	adds	r3, #16
 80037ec:	4618      	mov	r0, r3
 80037ee:	f7fe fc37 	bl	8002060 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)(hp + 1);
 80037f2:	9b04      	ldr	r3, [sp, #16]
 80037f4:	3308      	adds	r3, #8
 80037f6:	e024      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
    qp = hp;
 80037f8:	9b04      	ldr	r3, [sp, #16]
 80037fa:	9305      	str	r3, [sp, #20]

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 80037fc:	9b05      	ldr	r3, [sp, #20]
 80037fe:	681b      	ldr	r3, [r3, #0]
 8003800:	2b00      	cmp	r3, #0
 8003802:	d1c4      	bne.n	800378e <chHeapAlloc+0x2e>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8003804:	9b01      	ldr	r3, [sp, #4]
 8003806:	3310      	adds	r3, #16
 8003808:	4618      	mov	r0, r3
 800380a:	f7fe fc29 	bl	8002060 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800380e:	9b01      	ldr	r3, [sp, #4]
 8003810:	681b      	ldr	r3, [r3, #0]
 8003812:	2b00      	cmp	r3, #0
 8003814:	d014      	beq.n	8003840 <chHeapAlloc+0xe0>
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8003816:	9b01      	ldr	r3, [sp, #4]
 8003818:	681b      	ldr	r3, [r3, #0]
 800381a:	9a00      	ldr	r2, [sp, #0]
 800381c:	3208      	adds	r2, #8
 800381e:	4610      	mov	r0, r2
 8003820:	4798      	blx	r3
 8003822:	9004      	str	r0, [sp, #16]
    if (hp != NULL) {
 8003824:	9b04      	ldr	r3, [sp, #16]
 8003826:	2b00      	cmp	r3, #0
 8003828:	d00a      	beq.n	8003840 <chHeapAlloc+0xe0>
      hp->h.u.heap = heapp;
 800382a:	9b04      	ldr	r3, [sp, #16]
 800382c:	9a01      	ldr	r2, [sp, #4]
 800382e:	601a      	str	r2, [r3, #0]
      hp->h.size = size;
 8003830:	9b04      	ldr	r3, [sp, #16]
 8003832:	9a00      	ldr	r2, [sp, #0]
 8003834:	605a      	str	r2, [r3, #4]
      hp++;
 8003836:	9b04      	ldr	r3, [sp, #16]
 8003838:	3308      	adds	r3, #8
 800383a:	9304      	str	r3, [sp, #16]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)hp;
 800383c:	9b04      	ldr	r3, [sp, #16]
 800383e:	e000      	b.n	8003842 <chHeapAlloc+0xe2>
      /*lint -restore*/
    }
  }

  return NULL;
 8003840:	2300      	movs	r3, #0
}
 8003842:	4618      	mov	r0, r3
 8003844:	b007      	add	sp, #28
 8003846:	f85d fb04 	ldr.w	pc, [sp], #4
 800384a:	bf00      	nop
 800384c:	20001190 	.word	0x20001190

08003850 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8003850:	b500      	push	{lr}
 8003852:	b087      	sub	sp, #28
 8003854:	9001      	str	r0, [sp, #4]
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 8003856:	9b01      	ldr	r3, [sp, #4]
 8003858:	3b08      	subs	r3, #8
 800385a:	9304      	str	r3, [sp, #16]
  /*lint -restore*/
  heapp = hp->h.u.heap;
 800385c:	9b04      	ldr	r3, [sp, #16]
 800385e:	681b      	ldr	r3, [r3, #0]
 8003860:	9303      	str	r3, [sp, #12]
  qp = &heapp->h_free;
 8003862:	9b03      	ldr	r3, [sp, #12]
 8003864:	3308      	adds	r3, #8
 8003866:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
 8003868:	9b03      	ldr	r3, [sp, #12]
 800386a:	3310      	adds	r3, #16
 800386c:	4618      	mov	r0, r3
 800386e:	f7fe fb4f 	bl	8001f10 <chMtxLock>
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 8003872:	9b03      	ldr	r3, [sp, #12]
 8003874:	f103 0208 	add.w	r2, r3, #8
 8003878:	9b05      	ldr	r3, [sp, #20]
 800387a:	429a      	cmp	r2, r3
 800387c:	d003      	beq.n	8003886 <chHeapFree+0x36>
 800387e:	9a04      	ldr	r2, [sp, #16]
 8003880:	9b05      	ldr	r3, [sp, #20]
 8003882:	429a      	cmp	r2, r3
 8003884:	d93e      	bls.n	8003904 <chHeapFree+0xb4>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 8003886:	9b05      	ldr	r3, [sp, #20]
 8003888:	681b      	ldr	r3, [r3, #0]

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 800388a:	2b00      	cmp	r3, #0
 800388c:	d004      	beq.n	8003898 <chHeapFree+0x48>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 800388e:	9b05      	ldr	r3, [sp, #20]
 8003890:	681a      	ldr	r2, [r3, #0]
 8003892:	9b04      	ldr	r3, [sp, #16]
 8003894:	429a      	cmp	r2, r3
 8003896:	d935      	bls.n	8003904 <chHeapFree+0xb4>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 8003898:	9b05      	ldr	r3, [sp, #20]
 800389a:	681a      	ldr	r2, [r3, #0]
 800389c:	9b04      	ldr	r3, [sp, #16]
 800389e:	601a      	str	r2, [r3, #0]
      qp->h.u.next = hp;
 80038a0:	9b05      	ldr	r3, [sp, #20]
 80038a2:	9a04      	ldr	r2, [sp, #16]
 80038a4:	601a      	str	r2, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80038a6:	9b04      	ldr	r3, [sp, #16]
 80038a8:	685b      	ldr	r3, [r3, #4]
 80038aa:	3308      	adds	r3, #8
 80038ac:	9a04      	ldr	r2, [sp, #16]
 80038ae:	441a      	add	r2, r3
 80038b0:	9b04      	ldr	r3, [sp, #16]
 80038b2:	681b      	ldr	r3, [r3, #0]
 80038b4:	429a      	cmp	r2, r3
 80038b6:	d10e      	bne.n	80038d6 <chHeapFree+0x86>
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80038b8:	9b04      	ldr	r3, [sp, #16]
 80038ba:	685a      	ldr	r2, [r3, #4]
 80038bc:	9b04      	ldr	r3, [sp, #16]
 80038be:	681b      	ldr	r3, [r3, #0]
 80038c0:	685b      	ldr	r3, [r3, #4]
 80038c2:	4413      	add	r3, r2
 80038c4:	f103 0208 	add.w	r2, r3, #8
 80038c8:	9b04      	ldr	r3, [sp, #16]
 80038ca:	605a      	str	r2, [r3, #4]
        hp->h.u.next = hp->h.u.next->h.u.next;
 80038cc:	9b04      	ldr	r3, [sp, #16]
 80038ce:	681b      	ldr	r3, [r3, #0]
 80038d0:	681a      	ldr	r2, [r3, #0]
 80038d2:	9b04      	ldr	r3, [sp, #16]
 80038d4:	601a      	str	r2, [r3, #0]
      }
      if ((LIMIT(qp) == hp)) {
 80038d6:	9b05      	ldr	r3, [sp, #20]
 80038d8:	685b      	ldr	r3, [r3, #4]
 80038da:	3308      	adds	r3, #8
 80038dc:	9a05      	ldr	r2, [sp, #20]
 80038de:	441a      	add	r2, r3
 80038e0:	9b04      	ldr	r3, [sp, #16]
 80038e2:	429a      	cmp	r2, r3
 80038e4:	d10d      	bne.n	8003902 <chHeapFree+0xb2>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 80038e6:	9b05      	ldr	r3, [sp, #20]
 80038e8:	685a      	ldr	r2, [r3, #4]
 80038ea:	9b04      	ldr	r3, [sp, #16]
 80038ec:	685b      	ldr	r3, [r3, #4]
 80038ee:	4413      	add	r3, r2
 80038f0:	f103 0208 	add.w	r2, r3, #8
 80038f4:	9b05      	ldr	r3, [sp, #20]
 80038f6:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 80038f8:	9b04      	ldr	r3, [sp, #16]
 80038fa:	681a      	ldr	r2, [r3, #0]
 80038fc:	9b05      	ldr	r3, [sp, #20]
 80038fe:	601a      	str	r2, [r3, #0]
      }
      break;
 8003900:	e004      	b.n	800390c <chHeapFree+0xbc>
 8003902:	e003      	b.n	800390c <chHeapFree+0xbc>
    }
    qp = qp->h.u.next;
 8003904:	9b05      	ldr	r3, [sp, #20]
 8003906:	681b      	ldr	r3, [r3, #0]
 8003908:	9305      	str	r3, [sp, #20]
  }
 800390a:	e7b2      	b.n	8003872 <chHeapFree+0x22>
  H_UNLOCK(heapp);
 800390c:	9b03      	ldr	r3, [sp, #12]
 800390e:	3310      	adds	r3, #16
 8003910:	4618      	mov	r0, r3
 8003912:	f7fe fba5 	bl	8002060 <chMtxUnlock>

  return;
 8003916:	bf00      	nop
}
 8003918:	b007      	add	sp, #28
 800391a:	f85d fb04 	ldr.w	pc, [sp], #4
 800391e:	bf00      	nop

08003920 <chHeapStatus>:
 *                      fragmented free space
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *sizep) {
 8003920:	b500      	push	{lr}
 8003922:	b087      	sub	sp, #28
 8003924:	9001      	str	r0, [sp, #4]
 8003926:	9100      	str	r1, [sp, #0]
  union heap_header *qp;
  size_t n, sz;

  if (heapp == NULL) {
 8003928:	9b01      	ldr	r3, [sp, #4]
 800392a:	2b00      	cmp	r3, #0
 800392c:	d101      	bne.n	8003932 <chHeapStatus+0x12>
    heapp = &default_heap;
 800392e:	4b17      	ldr	r3, [pc, #92]	; (800398c <chHeapStatus+0x6c>)
 8003930:	9301      	str	r3, [sp, #4]
  }

  H_LOCK(heapp);
 8003932:	9b01      	ldr	r3, [sp, #4]
 8003934:	3310      	adds	r3, #16
 8003936:	4618      	mov	r0, r3
 8003938:	f7fe faea 	bl	8001f10 <chMtxLock>
  sz = 0;
 800393c:	2300      	movs	r3, #0
 800393e:	9303      	str	r3, [sp, #12]
  n = 0;
 8003940:	2300      	movs	r3, #0
 8003942:	9304      	str	r3, [sp, #16]
  qp = &heapp->h_free;
 8003944:	9b01      	ldr	r3, [sp, #4]
 8003946:	3308      	adds	r3, #8
 8003948:	9305      	str	r3, [sp, #20]
  while (qp->h.u.next != NULL) {
 800394a:	e00b      	b.n	8003964 <chHeapStatus+0x44>
    sz += qp->h.u.next->h.size;
 800394c:	9b05      	ldr	r3, [sp, #20]
 800394e:	681b      	ldr	r3, [r3, #0]
 8003950:	685b      	ldr	r3, [r3, #4]
 8003952:	9a03      	ldr	r2, [sp, #12]
 8003954:	4413      	add	r3, r2
 8003956:	9303      	str	r3, [sp, #12]
    n++;
 8003958:	9b04      	ldr	r3, [sp, #16]
 800395a:	3301      	adds	r3, #1
 800395c:	9304      	str	r3, [sp, #16]
    qp = qp->h.u.next;
 800395e:	9b05      	ldr	r3, [sp, #20]
 8003960:	681b      	ldr	r3, [r3, #0]
 8003962:	9305      	str	r3, [sp, #20]

  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 8003964:	9b05      	ldr	r3, [sp, #20]
 8003966:	681b      	ldr	r3, [r3, #0]
 8003968:	2b00      	cmp	r3, #0
 800396a:	d1ef      	bne.n	800394c <chHeapStatus+0x2c>
    sz += qp->h.u.next->h.size;
    n++;
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
 800396c:	9b00      	ldr	r3, [sp, #0]
 800396e:	2b00      	cmp	r3, #0
 8003970:	d002      	beq.n	8003978 <chHeapStatus+0x58>
    *sizep = sz;
 8003972:	9b00      	ldr	r3, [sp, #0]
 8003974:	9a03      	ldr	r2, [sp, #12]
 8003976:	601a      	str	r2, [r3, #0]
  }
  H_UNLOCK(heapp);
 8003978:	9b01      	ldr	r3, [sp, #4]
 800397a:	3310      	adds	r3, #16
 800397c:	4618      	mov	r0, r3
 800397e:	f7fe fb6f 	bl	8002060 <chMtxUnlock>

  return n;
 8003982:	9b04      	ldr	r3, [sp, #16]
}
 8003984:	4618      	mov	r0, r3
 8003986:	b007      	add	sp, #28
 8003988:	f85d fb04 	ldr.w	pc, [sp], #4
 800398c:	20001190 	.word	0x20001190

08003990 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003990:	b082      	sub	sp, #8
 8003992:	2320      	movs	r3, #32
 8003994:	9301      	str	r3, [sp, #4]
 8003996:	9b01      	ldr	r3, [sp, #4]
 8003998:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800399c:	b002      	add	sp, #8
 800399e:	4770      	bx	lr

080039a0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80039a0:	b082      	sub	sp, #8
 80039a2:	2300      	movs	r3, #0
 80039a4:	9301      	str	r3, [sp, #4]
 80039a6:	9b01      	ldr	r3, [sp, #4]
 80039a8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80039ac:	b002      	add	sp, #8
 80039ae:	4770      	bx	lr

080039b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80039b0:	b508      	push	{r3, lr}

  port_lock();
 80039b2:	f7ff ffed 	bl	8003990 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80039b6:	bd08      	pop	{r3, pc}
 80039b8:	f3af 8000 	nop.w
 80039bc:	f3af 8000 	nop.w

080039c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80039c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80039c2:	f7ff ffed 	bl	80039a0 <port_unlock>
}
 80039c6:	bd08      	pop	{r3, pc}
 80039c8:	f3af 8000 	nop.w
 80039cc:	f3af 8000 	nop.w

080039d0 <chPoolAdd>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be added
 *
 * @api
 */
static inline void chPoolAdd(memory_pool_t *mp, void *objp) {
 80039d0:	b500      	push	{lr}
 80039d2:	b083      	sub	sp, #12
 80039d4:	9001      	str	r0, [sp, #4]
 80039d6:	9100      	str	r1, [sp, #0]

  chPoolFree(mp, objp);
 80039d8:	9801      	ldr	r0, [sp, #4]
 80039da:	9900      	ldr	r1, [sp, #0]
 80039dc:	f000 f870 	bl	8003ac0 <chPoolFree>
}
 80039e0:	b003      	add	sp, #12
 80039e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80039e6:	bf00      	nop
 80039e8:	f3af 8000 	nop.w
 80039ec:	f3af 8000 	nop.w

080039f0 <chPoolObjectInit>:
 *                      @p NULL if the pool is not allowed to grow
 *                      automatically
 *
 * @init
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {
 80039f0:	b084      	sub	sp, #16
 80039f2:	9003      	str	r0, [sp, #12]
 80039f4:	9102      	str	r1, [sp, #8]
 80039f6:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->mp_next = NULL;
 80039f8:	9b03      	ldr	r3, [sp, #12]
 80039fa:	2200      	movs	r2, #0
 80039fc:	601a      	str	r2, [r3, #0]
  mp->mp_object_size = size;
 80039fe:	9b03      	ldr	r3, [sp, #12]
 8003a00:	9a02      	ldr	r2, [sp, #8]
 8003a02:	605a      	str	r2, [r3, #4]
  mp->mp_provider = provider;
 8003a04:	9b03      	ldr	r3, [sp, #12]
 8003a06:	9a01      	ldr	r2, [sp, #4]
 8003a08:	609a      	str	r2, [r3, #8]
}
 8003a0a:	b004      	add	sp, #16
 8003a0c:	4770      	bx	lr
 8003a0e:	bf00      	nop

08003a10 <chPoolLoadArray>:
 * @param[in] p         pointer to the array first element
 * @param[in] n         number of elements in the array
 *
 * @api
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {
 8003a10:	b500      	push	{lr}
 8003a12:	b085      	sub	sp, #20
 8003a14:	9003      	str	r0, [sp, #12]
 8003a16:	9102      	str	r1, [sp, #8]
 8003a18:	9201      	str	r2, [sp, #4]

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a1a:	e00b      	b.n	8003a34 <chPoolLoadArray+0x24>
    chPoolAdd(mp, p);
 8003a1c:	9803      	ldr	r0, [sp, #12]
 8003a1e:	9902      	ldr	r1, [sp, #8]
 8003a20:	f7ff ffd6 	bl	80039d0 <chPoolAdd>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
 8003a24:	9b03      	ldr	r3, [sp, #12]
 8003a26:	685b      	ldr	r3, [r3, #4]
 8003a28:	9a02      	ldr	r2, [sp, #8]
 8003a2a:	4413      	add	r3, r2
 8003a2c:	9302      	str	r3, [sp, #8]
    /*lint -restore*/
    n--;
 8003a2e:	9b01      	ldr	r3, [sp, #4]
 8003a30:	3b01      	subs	r3, #1
 8003a32:	9301      	str	r3, [sp, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8003a34:	9b01      	ldr	r3, [sp, #4]
 8003a36:	2b00      	cmp	r3, #0
 8003a38:	d1f0      	bne.n	8003a1c <chPoolLoadArray+0xc>
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->mp_object_size);
    /*lint -restore*/
    n--;
  }
}
 8003a3a:	b005      	add	sp, #20
 8003a3c:	f85d fb04 	ldr.w	pc, [sp], #4

08003a40 <chPoolAllocI>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @iclass
 */
void *chPoolAllocI(memory_pool_t *mp) {
 8003a40:	b500      	push	{lr}
 8003a42:	b085      	sub	sp, #20
 8003a44:	9001      	str	r0, [sp, #4]
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->mp_next;
 8003a46:	9b01      	ldr	r3, [sp, #4]
 8003a48:	681b      	ldr	r3, [r3, #0]
 8003a4a:	9303      	str	r3, [sp, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8003a4c:	9b03      	ldr	r3, [sp, #12]
 8003a4e:	2b00      	cmp	r3, #0
 8003a50:	d005      	beq.n	8003a5e <chPoolAllocI+0x1e>
    mp->mp_next = mp->mp_next->ph_next;
 8003a52:	9b01      	ldr	r3, [sp, #4]
 8003a54:	681b      	ldr	r3, [r3, #0]
 8003a56:	681a      	ldr	r2, [r3, #0]
 8003a58:	9b01      	ldr	r3, [sp, #4]
 8003a5a:	601a      	str	r2, [r3, #0]
 8003a5c:	e00a      	b.n	8003a74 <chPoolAllocI+0x34>
  }
  else if (mp->mp_provider != NULL) {
 8003a5e:	9b01      	ldr	r3, [sp, #4]
 8003a60:	689b      	ldr	r3, [r3, #8]
 8003a62:	2b00      	cmp	r3, #0
 8003a64:	d006      	beq.n	8003a74 <chPoolAllocI+0x34>
    objp = mp->mp_provider(mp->mp_object_size);
 8003a66:	9b01      	ldr	r3, [sp, #4]
 8003a68:	689b      	ldr	r3, [r3, #8]
 8003a6a:	9a01      	ldr	r2, [sp, #4]
 8003a6c:	6852      	ldr	r2, [r2, #4]
 8003a6e:	4610      	mov	r0, r2
 8003a70:	4798      	blx	r3
 8003a72:	9003      	str	r0, [sp, #12]
  }
  /*lint -restore*/

  return objp;
 8003a74:	9b03      	ldr	r3, [sp, #12]
}
 8003a76:	4618      	mov	r0, r3
 8003a78:	b005      	add	sp, #20
 8003a7a:	f85d fb04 	ldr.w	pc, [sp], #4
 8003a7e:	bf00      	nop

08003a80 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8003a80:	b500      	push	{lr}
 8003a82:	b085      	sub	sp, #20
 8003a84:	9001      	str	r0, [sp, #4]
  void *objp;

  chSysLock();
 8003a86:	f7ff ff93 	bl	80039b0 <chSysLock>
  objp = chPoolAllocI(mp);
 8003a8a:	9801      	ldr	r0, [sp, #4]
 8003a8c:	f7ff ffd8 	bl	8003a40 <chPoolAllocI>
 8003a90:	9003      	str	r0, [sp, #12]
  chSysUnlock();
 8003a92:	f7ff ff95 	bl	80039c0 <chSysUnlock>

  return objp;
 8003a96:	9b03      	ldr	r3, [sp, #12]
}
 8003a98:	4618      	mov	r0, r3
 8003a9a:	b005      	add	sp, #20
 8003a9c:	f85d fb04 	ldr.w	pc, [sp], #4

08003aa0 <chPoolFreeI>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @iclass
 */
void chPoolFreeI(memory_pool_t *mp, void *objp) {
 8003aa0:	b084      	sub	sp, #16
 8003aa2:	9001      	str	r0, [sp, #4]
 8003aa4:	9100      	str	r1, [sp, #0]
  struct pool_header *php = objp;
 8003aa6:	9b00      	ldr	r3, [sp, #0]
 8003aa8:	9303      	str	r3, [sp, #12]

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8003aaa:	9b01      	ldr	r3, [sp, #4]
 8003aac:	681a      	ldr	r2, [r3, #0]
 8003aae:	9b03      	ldr	r3, [sp, #12]
 8003ab0:	601a      	str	r2, [r3, #0]
  mp->mp_next = php;
 8003ab2:	9b01      	ldr	r3, [sp, #4]
 8003ab4:	9a03      	ldr	r2, [sp, #12]
 8003ab6:	601a      	str	r2, [r3, #0]
}
 8003ab8:	b004      	add	sp, #16
 8003aba:	4770      	bx	lr
 8003abc:	f3af 8000 	nop.w

08003ac0 <chPoolFree>:
 * @param[in] mp        pointer to a @p memory_pool_t structure
 * @param[in] objp      the pointer to the object to be released
 *
 * @api
 */
void chPoolFree(memory_pool_t *mp, void *objp) {
 8003ac0:	b500      	push	{lr}
 8003ac2:	b083      	sub	sp, #12
 8003ac4:	9001      	str	r0, [sp, #4]
 8003ac6:	9100      	str	r1, [sp, #0]

  chSysLock();
 8003ac8:	f7ff ff72 	bl	80039b0 <chSysLock>
  chPoolFreeI(mp, objp);
 8003acc:	9801      	ldr	r0, [sp, #4]
 8003ace:	9900      	ldr	r1, [sp, #0]
 8003ad0:	f7ff ffe6 	bl	8003aa0 <chPoolFreeI>
  chSysUnlock();
 8003ad4:	f7ff ff74 	bl	80039c0 <chSysUnlock>
}
 8003ad8:	b003      	add	sp, #12
 8003ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8003ade:	bf00      	nop

08003ae0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003ae0:	b082      	sub	sp, #8
 8003ae2:	2320      	movs	r3, #32
 8003ae4:	9301      	str	r3, [sp, #4]
 8003ae6:	9b01      	ldr	r3, [sp, #4]
 8003ae8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003aec:	b002      	add	sp, #8
 8003aee:	4770      	bx	lr

08003af0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003af0:	b082      	sub	sp, #8
 8003af2:	2300      	movs	r3, #0
 8003af4:	9301      	str	r3, [sp, #4]
 8003af6:	9b01      	ldr	r3, [sp, #4]
 8003af8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003afc:	b002      	add	sp, #8
 8003afe:	4770      	bx	lr

08003b00 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8003b00:	b508      	push	{r3, lr}

  port_lock();
 8003b02:	f7ff ffed 	bl	8003ae0 <port_lock>
}
 8003b06:	bd08      	pop	{r3, pc}
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8003b10:	b508      	push	{r3, lr}

  port_unlock();
 8003b12:	f7ff ffed 	bl	8003af0 <port_unlock>
}
 8003b16:	bd08      	pop	{r3, pc}
 8003b18:	f3af 8000 	nop.w
 8003b1c:	f3af 8000 	nop.w

08003b20 <SVC_Handler>:
 * @details The SVC vector is used for exception mode re-entering after a
 *          context switch.
 * @note    The PendSV vector is only used in advanced kernel mode.
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void SVC_Handler(void) {
 8003b20:	b510      	push	{r4, lr}
 8003b22:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b24:	f3ef 8309 	mrs	r3, PSP
 8003b28:	461c      	mov	r4, r3
  return(result);
 8003b2a:	4623      	mov	r3, r4
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
#endif

  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();
 8003b2c:	9301      	str	r3, [sp, #4]

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003b2e:	9b01      	ldr	r3, [sp, #4]
 8003b30:	3320      	adds	r3, #32
 8003b32:	9301      	str	r3, [sp, #4]

  /* Restoring real position of the original stack frame.*/
  __set_PSP((uint32_t)ctxp);
 8003b34:	9b01      	ldr	r3, [sp, #4]
 8003b36:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b38:	9b00      	ldr	r3, [sp, #0]
 8003b3a:	f383 8809 	msr	PSP, r3

  /* Restoring the normal interrupts status.*/
  port_unlock_from_isr();
 8003b3e:	f7ff ffe7 	bl	8003b10 <port_unlock_from_isr>
}
 8003b42:	b002      	add	sp, #8
 8003b44:	bd10      	pop	{r4, pc}
 8003b46:	bf00      	nop
 8003b48:	f3af 8000 	nop.w
 8003b4c:	f3af 8000 	nop.w

08003b50 <_port_irq_epilogue>:
/*===========================================================================*/

/**
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {
 8003b50:	b510      	push	{r4, lr}
 8003b52:	b082      	sub	sp, #8

  port_lock_from_isr();
 8003b54:	f7ff ffd4 	bl	8003b00 <port_lock_from_isr>
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003b58:	4b13      	ldr	r3, [pc, #76]	; (8003ba8 <_port_irq_epilogue+0x58>)
 8003b5a:	685b      	ldr	r3, [r3, #4]
 8003b5c:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8003b60:	2b00      	cmp	r3, #0
 8003b62:	d01d      	beq.n	8003ba0 <_port_irq_epilogue+0x50>
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003b64:	f3ef 8309 	mrs	r3, PSP
 8003b68:	461c      	mov	r4, r3
  return(result);
 8003b6a:	4623      	mov	r3, r4
      /* Enforcing a lazy FPU state save by accessing the FPCSR register.*/
      (void) __get_FPSCR();
#endif

    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();
 8003b6c:	9301      	str	r3, [sp, #4]

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003b6e:	9b01      	ldr	r3, [sp, #4]
 8003b70:	3b20      	subs	r3, #32
 8003b72:	9301      	str	r3, [sp, #4]

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8003b74:	9b01      	ldr	r3, [sp, #4]
 8003b76:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 8003b7a:	61da      	str	r2, [r3, #28]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
#endif

    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);
 8003b7c:	9b01      	ldr	r3, [sp, #4]
 8003b7e:	9300      	str	r3, [sp, #0]

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003b80:	9b00      	ldr	r3, [sp, #0]
 8003b82:	f383 8809 	msr	PSP, r3

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003b86:	f7fd f90b 	bl	8000da0 <chSchIsPreemptionRequired>
 8003b8a:	4603      	mov	r3, r0
 8003b8c:	2b00      	cmp	r3, #0
 8003b8e:	d003      	beq.n	8003b98 <_port_irq_epilogue+0x48>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003b90:	9b01      	ldr	r3, [sp, #4]
 8003b92:	4a06      	ldr	r2, [pc, #24]	; (8003bac <_port_irq_epilogue+0x5c>)
 8003b94:	619a      	str	r2, [r3, #24]
      ctxp->pc = (regarm_t)_port_exit_from_isr;
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b96:	e005      	b.n	8003ba4 <_port_irq_epilogue+0x54>
      ctxp->pc = (regarm_t)_port_switch_from_isr;
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 8003b98:	9b01      	ldr	r3, [sp, #4]
 8003b9a:	4a05      	ldr	r2, [pc, #20]	; (8003bb0 <_port_irq_epilogue+0x60>)
 8003b9c:	619a      	str	r2, [r3, #24]
    }

    /* Note, returning without unlocking is intentional, this is done in
       order to keep the rest of the context switch atomic.*/
    return;
 8003b9e:	e001      	b.n	8003ba4 <_port_irq_epilogue+0x54>
  }
  port_unlock_from_isr();
 8003ba0:	f7ff ffb6 	bl	8003b10 <port_unlock_from_isr>
}
 8003ba4:	b002      	add	sp, #8
 8003ba6:	bd10      	pop	{r4, pc}
 8003ba8:	e000ed00 	.word	0xe000ed00
 8003bac:	08000301 	.word	0x08000301
 8003bb0:	08000304 	.word	0x08000304
 8003bb4:	f3af 8000 	nop.w
 8003bb8:	f3af 8000 	nop.w
 8003bbc:	f3af 8000 	nop.w

08003bc0 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
 8003bc0:	4770      	bx	lr
 8003bc2:	bf00      	nop
 8003bc4:	f3af 8000 	nop.w
 8003bc8:	f3af 8000 	nop.w
 8003bcc:	f3af 8000 	nop.w

08003bd0 <halInit>:
 *          board-specific initialization is performed by invoking
 *          @p boardInit() (usually defined in @p board.c).
 *
 * @init
 */
void halInit(void) {
 8003bd0:	b508      	push	{r3, lr}

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
 8003bd2:	f7ff fff5 	bl	8003bc0 <osalInit>

  /* Platform low level initializations.*/
  hal_lld_init();
 8003bd6:	f003 fc63 	bl	80074a0 <hal_lld_init>

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
 8003bda:	4809      	ldr	r0, [pc, #36]	; (8003c00 <halInit+0x30>)
 8003bdc:	f004 fa28 	bl	8008030 <_pal_lld_init>
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
 8003be0:	f002 fade 	bl	80061a0 <sdInit>
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
 8003be4:	f001 ff44 	bl	8005a70 <sdcInit>
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
 8003be8:	f002 fc32 	bl	8006450 <spiInit>
#endif
#if (HAL_USE_UART == TRUE) || defined(__DOXYGEN__)
  uartInit();
#endif
#if (HAL_USE_USB == TRUE) || defined(__DOXYGEN__)
  usbInit();
 8003bec:	f003 f820 	bl	8006c30 <usbInit>
#endif
#if (HAL_USE_SERIAL_USB == TRUE) || defined(__DOXYGEN__)
  sduInit();
#endif
#if (HAL_USE_RTC == TRUE) || defined(__DOXYGEN__)
  rtcInit();
 8003bf0:	f001 fa36 	bl	8005060 <rtcInit>
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
 8003bf4:	f007 ff94 	bl	800bb20 <boardInit>
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
 8003bf8:	f000 f832 	bl	8003c60 <stInit>
#endif
}
 8003bfc:	bd08      	pop	{r3, pc}
 8003bfe:	bf00      	nop
 8003c00:	08019630 	.word	0x08019630
 8003c04:	f3af 8000 	nop.w
 8003c08:	f3af 8000 	nop.w
 8003c0c:	f3af 8000 	nop.w

08003c10 <st_lld_start_alarm>:
 *
 * @param[in] time      the time to be set for the first alarm
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {
 8003c10:	b082      	sub	sp, #8
 8003c12:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c14:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c18:	9a01      	ldr	r2, [sp, #4]
 8003c1a:	635a      	str	r2, [r3, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 8003c1c:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c20:	2200      	movs	r2, #0
 8003c22:	611a      	str	r2, [r3, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 8003c24:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c28:	2202      	movs	r2, #2
 8003c2a:	60da      	str	r2, [r3, #12]
}
 8003c2c:	b002      	add	sp, #8
 8003c2e:	4770      	bx	lr

08003c30 <st_lld_stop_alarm>:
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8003c30:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c34:	2200      	movs	r2, #0
 8003c36:	60da      	str	r2, [r3, #12]
}
 8003c38:	4770      	bx	lr
 8003c3a:	bf00      	nop
 8003c3c:	f3af 8000 	nop.w

08003c40 <st_lld_set_alarm>:
 *
 * @param[in] time      the time to be set for the next alarm
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {
 8003c40:	b082      	sub	sp, #8
 8003c42:	9001      	str	r0, [sp, #4]

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003c44:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c48:	9a01      	ldr	r2, [sp, #4]
 8003c4a:	635a      	str	r2, [r3, #52]	; 0x34
}
 8003c4c:	b002      	add	sp, #8
 8003c4e:	4770      	bx	lr

08003c50 <st_lld_get_alarm>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_alarm(void) {

  return (systime_t)STM32_ST_TIM->CCR[0];
 8003c50:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8003c54:	6b5b      	ldr	r3, [r3, #52]	; 0x34
}
 8003c56:	4618      	mov	r0, r3
 8003c58:	4770      	bx	lr
 8003c5a:	bf00      	nop
 8003c5c:	f3af 8000 	nop.w

08003c60 <stInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void stInit(void) {
 8003c60:	b508      	push	{r3, lr}

  st_lld_init();
 8003c62:	f004 f99d 	bl	8007fa0 <st_lld_init>
}
 8003c66:	bd08      	pop	{r3, pc}
 8003c68:	f3af 8000 	nop.w
 8003c6c:	f3af 8000 	nop.w

08003c70 <stStartAlarm>:
 *
 * @param[in] abstime   the time to be set for the first alarm
 *
 * @api
 */
void stStartAlarm(systime_t abstime) {
 8003c70:	b500      	push	{lr}
 8003c72:	b083      	sub	sp, #12
 8003c74:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() == false, "already active");

  st_lld_start_alarm(abstime);
 8003c76:	9801      	ldr	r0, [sp, #4]
 8003c78:	f7ff ffca 	bl	8003c10 <st_lld_start_alarm>
}
 8003c7c:	b003      	add	sp, #12
 8003c7e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003c82:	bf00      	nop
 8003c84:	f3af 8000 	nop.w
 8003c88:	f3af 8000 	nop.w
 8003c8c:	f3af 8000 	nop.w

08003c90 <stStopAlarm>:
 * @note    This functionality is only available in free running mode, the
 *          behavior in periodic mode is undefined.
 *
 * @api
 */
void stStopAlarm(void) {
 8003c90:	b508      	push	{r3, lr}

  st_lld_stop_alarm();
 8003c92:	f7ff ffcd 	bl	8003c30 <st_lld_stop_alarm>
}
 8003c96:	bd08      	pop	{r3, pc}
 8003c98:	f3af 8000 	nop.w
 8003c9c:	f3af 8000 	nop.w

08003ca0 <stSetAlarm>:
 *
 * @param[in] abstime   the time to be set for the next alarm
 *
 * @api
 */
void stSetAlarm(systime_t abstime) {
 8003ca0:	b500      	push	{lr}
 8003ca2:	b083      	sub	sp, #12
 8003ca4:	9001      	str	r0, [sp, #4]

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  st_lld_set_alarm(abstime);
 8003ca6:	9801      	ldr	r0, [sp, #4]
 8003ca8:	f7ff ffca 	bl	8003c40 <st_lld_set_alarm>
}
 8003cac:	b003      	add	sp, #12
 8003cae:	f85d fb04 	ldr.w	pc, [sp], #4
 8003cb2:	bf00      	nop
 8003cb4:	f3af 8000 	nop.w
 8003cb8:	f3af 8000 	nop.w
 8003cbc:	f3af 8000 	nop.w

08003cc0 <stGetAlarm>:
 *
 * @return              The currently set alarm time.
 *
 * @api
 */
systime_t stGetAlarm(void) {
 8003cc0:	b508      	push	{r3, lr}

  osalDbgAssert(stIsAlarmActive() != false, "not active");

  return st_lld_get_alarm();
 8003cc2:	f7ff ffc5 	bl	8003c50 <st_lld_get_alarm>
 8003cc6:	4603      	mov	r3, r0
}
 8003cc8:	4618      	mov	r0, r3
 8003cca:	bd08      	pop	{r3, pc}
 8003ccc:	f3af 8000 	nop.w

08003cd0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8003cd0:	b082      	sub	sp, #8
 8003cd2:	2320      	movs	r3, #32
 8003cd4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003cd6:	9b01      	ldr	r3, [sp, #4]
 8003cd8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cdc:	b002      	add	sp, #8
 8003cde:	4770      	bx	lr

08003ce0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8003ce0:	b082      	sub	sp, #8
 8003ce2:	2300      	movs	r3, #0
 8003ce4:	9301      	str	r3, [sp, #4]
 8003ce6:	9b01      	ldr	r3, [sp, #4]
 8003ce8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8003cec:	b002      	add	sp, #8
 8003cee:	4770      	bx	lr

08003cf0 <queue_init>:
 *
 * @param[in] tqp       pointer to the threads queue object
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {
 8003cf0:	b082      	sub	sp, #8
 8003cf2:	9001      	str	r0, [sp, #4]

  tqp->p_next = (thread_t *)tqp;
 8003cf4:	9b01      	ldr	r3, [sp, #4]
 8003cf6:	9a01      	ldr	r2, [sp, #4]
 8003cf8:	601a      	str	r2, [r3, #0]
  tqp->p_prev = (thread_t *)tqp;
 8003cfa:	9b01      	ldr	r3, [sp, #4]
 8003cfc:	9a01      	ldr	r2, [sp, #4]
 8003cfe:	605a      	str	r2, [r3, #4]
}
 8003d00:	b002      	add	sp, #8
 8003d02:	4770      	bx	lr
 8003d04:	f3af 8000 	nop.w
 8003d08:	f3af 8000 	nop.w
 8003d0c:	f3af 8000 	nop.w

08003d10 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8003d10:	b508      	push	{r3, lr}

  port_lock();
 8003d12:	f7ff ffdd 	bl	8003cd0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8003d16:	bd08      	pop	{r3, pc}
 8003d18:	f3af 8000 	nop.w
 8003d1c:	f3af 8000 	nop.w

08003d20 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8003d20:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8003d22:	f7ff ffdd 	bl	8003ce0 <port_unlock>
}
 8003d26:	bd08      	pop	{r3, pc}
 8003d28:	f3af 8000 	nop.w
 8003d2c:	f3af 8000 	nop.w

08003d30 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8003d30:	4b01      	ldr	r3, [pc, #4]	; (8003d38 <chVTGetSystemTimeX+0x8>)
 8003d32:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8003d34:	4618      	mov	r0, r3
 8003d36:	4770      	bx	lr
 8003d38:	20001bc8 	.word	0x20001bc8
 8003d3c:	f3af 8000 	nop.w

08003d40 <chThdQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void chThdQueueObjectInit(threads_queue_t *tqp) {
 8003d40:	b500      	push	{lr}
 8003d42:	b083      	sub	sp, #12
 8003d44:	9001      	str	r0, [sp, #4]

  queue_init(tqp);
 8003d46:	9801      	ldr	r0, [sp, #4]
 8003d48:	f7ff ffd2 	bl	8003cf0 <queue_init>
}
 8003d4c:	b003      	add	sp, #12
 8003d4e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003d52:	bf00      	nop
 8003d54:	f3af 8000 	nop.w
 8003d58:	f3af 8000 	nop.w
 8003d5c:	f3af 8000 	nop.w

08003d60 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8003d60:	b508      	push	{r3, lr}

  chSysLock();
 8003d62:	f7ff ffd5 	bl	8003d10 <chSysLock>
}
 8003d66:	bd08      	pop	{r3, pc}
 8003d68:	f3af 8000 	nop.w
 8003d6c:	f3af 8000 	nop.w

08003d70 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8003d70:	b508      	push	{r3, lr}

  chSysUnlock();
 8003d72:	f7ff ffd5 	bl	8003d20 <chSysUnlock>
}
 8003d76:	bd08      	pop	{r3, pc}
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <osalOsGetSystemTimeX>:
 *
 * @return              The system time in ticks.
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {
 8003d80:	b508      	push	{r3, lr}

  return chVTGetSystemTimeX();
 8003d82:	f7ff ffd5 	bl	8003d30 <chVTGetSystemTimeX>
 8003d86:	4603      	mov	r3, r0
}
 8003d88:	4618      	mov	r0, r3
 8003d8a:	bd08      	pop	{r3, pc}
 8003d8c:	f3af 8000 	nop.w

08003d90 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
 8003d90:	b500      	push	{lr}
 8003d92:	b083      	sub	sp, #12
 8003d94:	9001      	str	r0, [sp, #4]

  chThdQueueObjectInit(tqp);
 8003d96:	9801      	ldr	r0, [sp, #4]
 8003d98:	f7ff ffd2 	bl	8003d40 <chThdQueueObjectInit>
}
 8003d9c:	b003      	add	sp, #12
 8003d9e:	f85d fb04 	ldr.w	pc, [sp], #4
 8003da2:	bf00      	nop
 8003da4:	f3af 8000 	nop.w
 8003da8:	f3af 8000 	nop.w
 8003dac:	f3af 8000 	nop.w

08003db0 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
 8003db0:	b500      	push	{lr}
 8003db2:	b083      	sub	sp, #12
 8003db4:	9001      	str	r0, [sp, #4]
 8003db6:	9100      	str	r1, [sp, #0]

  return chThdEnqueueTimeoutS(tqp, time);
 8003db8:	9801      	ldr	r0, [sp, #4]
 8003dba:	9900      	ldr	r1, [sp, #0]
 8003dbc:	f7fd fbc0 	bl	8001540 <chThdEnqueueTimeoutS>
 8003dc0:	4603      	mov	r3, r0
}
 8003dc2:	4618      	mov	r0, r3
 8003dc4:	b003      	add	sp, #12
 8003dc6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003dca:	bf00      	nop
 8003dcc:	f3af 8000 	nop.w

08003dd0 <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
 8003dd0:	b500      	push	{lr}
 8003dd2:	b083      	sub	sp, #12
 8003dd4:	9001      	str	r0, [sp, #4]
 8003dd6:	9100      	str	r1, [sp, #0]

  chThdDequeueNextI(tqp, msg);
 8003dd8:	9801      	ldr	r0, [sp, #4]
 8003dda:	9900      	ldr	r1, [sp, #0]
 8003ddc:	f7fd fbd0 	bl	8001580 <chThdDequeueNextI>
}
 8003de0:	b003      	add	sp, #12
 8003de2:	f85d fb04 	ldr.w	pc, [sp], #4
 8003de6:	bf00      	nop
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <osalThreadDequeueAllI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadDequeueAllI(threads_queue_t *tqp, msg_t msg) {
 8003df0:	b500      	push	{lr}
 8003df2:	b083      	sub	sp, #12
 8003df4:	9001      	str	r0, [sp, #4]
 8003df6:	9100      	str	r1, [sp, #0]

  chThdDequeueAllI(tqp, msg);
 8003df8:	9801      	ldr	r0, [sp, #4]
 8003dfa:	9900      	ldr	r1, [sp, #0]
 8003dfc:	f7fd fbd8 	bl	80015b0 <chThdDequeueAllI>
}
 8003e00:	b003      	add	sp, #12
 8003e02:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e06:	bf00      	nop
 8003e08:	f3af 8000 	nop.w
 8003e0c:	f3af 8000 	nop.w

08003e10 <ibqObjectInit>:
 *
 * @init
 */
void ibqObjectInit(input_buffers_queue_t *ibqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t infy, void *link) {
 8003e10:	b500      	push	{lr}
 8003e12:	b085      	sub	sp, #20
 8003e14:	9003      	str	r0, [sp, #12]
 8003e16:	9102      	str	r1, [sp, #8]
 8003e18:	9201      	str	r2, [sp, #4]
 8003e1a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((ibqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&ibqp->waiting);
 8003e1c:	9b03      	ldr	r3, [sp, #12]
 8003e1e:	4618      	mov	r0, r3
 8003e20:	f7ff ffb6 	bl	8003d90 <osalThreadQueueObjectInit>
  ibqp->bcounter = 0;
 8003e24:	9b03      	ldr	r3, [sp, #12]
 8003e26:	2200      	movs	r2, #0
 8003e28:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = bp;
 8003e2a:	9b03      	ldr	r3, [sp, #12]
 8003e2c:	9a02      	ldr	r2, [sp, #8]
 8003e2e:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = bp;
 8003e30:	9b03      	ldr	r3, [sp, #12]
 8003e32:	9a02      	ldr	r2, [sp, #8]
 8003e34:	60da      	str	r2, [r3, #12]
  ibqp->btop     = bp + ((size + sizeof (size_t)) * n);
 8003e36:	9b01      	ldr	r3, [sp, #4]
 8003e38:	3304      	adds	r3, #4
 8003e3a:	9a00      	ldr	r2, [sp, #0]
 8003e3c:	fb02 f303 	mul.w	r3, r2, r3
 8003e40:	9a02      	ldr	r2, [sp, #8]
 8003e42:	441a      	add	r2, r3
 8003e44:	9b03      	ldr	r3, [sp, #12]
 8003e46:	615a      	str	r2, [r3, #20]
  ibqp->bsize    = size + sizeof (size_t);
 8003e48:	9b01      	ldr	r3, [sp, #4]
 8003e4a:	1d1a      	adds	r2, r3, #4
 8003e4c:	9b03      	ldr	r3, [sp, #12]
 8003e4e:	619a      	str	r2, [r3, #24]
  ibqp->bn       = n;
 8003e50:	9b03      	ldr	r3, [sp, #12]
 8003e52:	9a00      	ldr	r2, [sp, #0]
 8003e54:	61da      	str	r2, [r3, #28]
  ibqp->buffers  = bp;
 8003e56:	9b03      	ldr	r3, [sp, #12]
 8003e58:	9a02      	ldr	r2, [sp, #8]
 8003e5a:	621a      	str	r2, [r3, #32]
  ibqp->ptr      = NULL;
 8003e5c:	9b03      	ldr	r3, [sp, #12]
 8003e5e:	2200      	movs	r2, #0
 8003e60:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003e62:	9b03      	ldr	r3, [sp, #12]
 8003e64:	2200      	movs	r2, #0
 8003e66:	629a      	str	r2, [r3, #40]	; 0x28
  ibqp->notify   = infy;
 8003e68:	9b03      	ldr	r3, [sp, #12]
 8003e6a:	9a06      	ldr	r2, [sp, #24]
 8003e6c:	62da      	str	r2, [r3, #44]	; 0x2c
  ibqp->link     = link;
 8003e6e:	9b03      	ldr	r3, [sp, #12]
 8003e70:	9a07      	ldr	r2, [sp, #28]
 8003e72:	631a      	str	r2, [r3, #48]	; 0x30
}
 8003e74:	b005      	add	sp, #20
 8003e76:	f85d fb04 	ldr.w	pc, [sp], #4
 8003e7a:	bf00      	nop
 8003e7c:	f3af 8000 	nop.w

08003e80 <ibqResetI>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @iclass
 */
void ibqResetI(input_buffers_queue_t *ibqp) {
 8003e80:	b500      	push	{lr}
 8003e82:	b083      	sub	sp, #12
 8003e84:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  ibqp->bcounter = 0;
 8003e86:	9b01      	ldr	r3, [sp, #4]
 8003e88:	2200      	movs	r2, #0
 8003e8a:	609a      	str	r2, [r3, #8]
  ibqp->brdptr   = ibqp->buffers;
 8003e8c:	9b01      	ldr	r3, [sp, #4]
 8003e8e:	6a1a      	ldr	r2, [r3, #32]
 8003e90:	9b01      	ldr	r3, [sp, #4]
 8003e92:	611a      	str	r2, [r3, #16]
  ibqp->bwrptr   = ibqp->buffers;
 8003e94:	9b01      	ldr	r3, [sp, #4]
 8003e96:	6a1a      	ldr	r2, [r3, #32]
 8003e98:	9b01      	ldr	r3, [sp, #4]
 8003e9a:	60da      	str	r2, [r3, #12]
  ibqp->ptr      = NULL;
 8003e9c:	9b01      	ldr	r3, [sp, #4]
 8003e9e:	2200      	movs	r2, #0
 8003ea0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top      = NULL;
 8003ea2:	9b01      	ldr	r3, [sp, #4]
 8003ea4:	2200      	movs	r2, #0
 8003ea6:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&ibqp->waiting, MSG_RESET);
 8003ea8:	9b01      	ldr	r3, [sp, #4]
 8003eaa:	4618      	mov	r0, r3
 8003eac:	f06f 0101 	mvn.w	r1, #1
 8003eb0:	f7ff ff9e 	bl	8003df0 <osalThreadDequeueAllI>
}
 8003eb4:	b003      	add	sp, #12
 8003eb6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003eba:	bf00      	nop
 8003ebc:	f3af 8000 	nop.w

08003ec0 <ibqGetEmptyBufferI>:
 * @return              A pointer to the next buffer to be filled.
 * @retval NULL         if the queue is full.
 *
 * @iclass
 */
uint8_t *ibqGetEmptyBufferI(input_buffers_queue_t *ibqp) {
 8003ec0:	b082      	sub	sp, #8
 8003ec2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  if (ibqIsFullI(ibqp)) {
 8003ec4:	9b01      	ldr	r3, [sp, #4]
 8003ec6:	68da      	ldr	r2, [r3, #12]
 8003ec8:	9b01      	ldr	r3, [sp, #4]
 8003eca:	691b      	ldr	r3, [r3, #16]
 8003ecc:	429a      	cmp	r2, r3
 8003ece:	d105      	bne.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed0:	9b01      	ldr	r3, [sp, #4]
 8003ed2:	689b      	ldr	r3, [r3, #8]
 8003ed4:	2b00      	cmp	r3, #0
 8003ed6:	d001      	beq.n	8003edc <ibqGetEmptyBufferI+0x1c>
 8003ed8:	2301      	movs	r3, #1
 8003eda:	e000      	b.n	8003ede <ibqGetEmptyBufferI+0x1e>
 8003edc:	2300      	movs	r3, #0
 8003ede:	f003 0301 	and.w	r3, r3, #1
 8003ee2:	b2db      	uxtb	r3, r3
 8003ee4:	2b00      	cmp	r3, #0
 8003ee6:	d001      	beq.n	8003eec <ibqGetEmptyBufferI+0x2c>
    return NULL;
 8003ee8:	2300      	movs	r3, #0
 8003eea:	e002      	b.n	8003ef2 <ibqGetEmptyBufferI+0x32>
  }

  return ibqp->bwrptr + sizeof (size_t);
 8003eec:	9b01      	ldr	r3, [sp, #4]
 8003eee:	68db      	ldr	r3, [r3, #12]
 8003ef0:	3304      	adds	r3, #4
}
 8003ef2:	4618      	mov	r0, r3
 8003ef4:	b002      	add	sp, #8
 8003ef6:	4770      	bx	lr
 8003ef8:	f3af 8000 	nop.w
 8003efc:	f3af 8000 	nop.w

08003f00 <ibqPostFullBufferI>:
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @iclass
 */
void ibqPostFullBufferI(input_buffers_queue_t *ibqp, size_t size) {
 8003f00:	b500      	push	{lr}
 8003f02:	b083      	sub	sp, #12
 8003f04:	9001      	str	r0, [sp, #4]
 8003f06:	9100      	str	r1, [sp, #0]

  osalDbgCheck((size > 0U) && (size <= (ibqp->bsize - sizeof (size_t))));
  osalDbgAssert(!ibqIsFullI(ibqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)ibqp->bwrptr) = size;
 8003f08:	9b01      	ldr	r3, [sp, #4]
 8003f0a:	68db      	ldr	r3, [r3, #12]
 8003f0c:	9a00      	ldr	r2, [sp, #0]
 8003f0e:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  ibqp->bcounter++;
 8003f10:	9b01      	ldr	r3, [sp, #4]
 8003f12:	689b      	ldr	r3, [r3, #8]
 8003f14:	1c5a      	adds	r2, r3, #1
 8003f16:	9b01      	ldr	r3, [sp, #4]
 8003f18:	609a      	str	r2, [r3, #8]
  ibqp->bwrptr += ibqp->bsize;
 8003f1a:	9b01      	ldr	r3, [sp, #4]
 8003f1c:	68da      	ldr	r2, [r3, #12]
 8003f1e:	9b01      	ldr	r3, [sp, #4]
 8003f20:	699b      	ldr	r3, [r3, #24]
 8003f22:	441a      	add	r2, r3
 8003f24:	9b01      	ldr	r3, [sp, #4]
 8003f26:	60da      	str	r2, [r3, #12]
  if (ibqp->bwrptr >= ibqp->btop) {
 8003f28:	9b01      	ldr	r3, [sp, #4]
 8003f2a:	68da      	ldr	r2, [r3, #12]
 8003f2c:	9b01      	ldr	r3, [sp, #4]
 8003f2e:	695b      	ldr	r3, [r3, #20]
 8003f30:	429a      	cmp	r2, r3
 8003f32:	d303      	bcc.n	8003f3c <ibqPostFullBufferI+0x3c>
    ibqp->bwrptr = ibqp->buffers;
 8003f34:	9b01      	ldr	r3, [sp, #4]
 8003f36:	6a1a      	ldr	r2, [r3, #32]
 8003f38:	9b01      	ldr	r3, [sp, #4]
 8003f3a:	60da      	str	r2, [r3, #12]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&ibqp->waiting, MSG_OK);
 8003f3c:	9b01      	ldr	r3, [sp, #4]
 8003f3e:	4618      	mov	r0, r3
 8003f40:	2100      	movs	r1, #0
 8003f42:	f7ff ff45 	bl	8003dd0 <osalThreadDequeueNextI>
}
 8003f46:	b003      	add	sp, #12
 8003f48:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f4c:	f3af 8000 	nop.w

08003f50 <ibqGetFullBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetFullBufferTimeout(input_buffers_queue_t *ibqp,
                              systime_t timeout) {
 8003f50:	b500      	push	{lr}
 8003f52:	b085      	sub	sp, #20
 8003f54:	9001      	str	r0, [sp, #4]
 8003f56:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8003f58:	f7ff ff02 	bl	8003d60 <osalSysLock>
  msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8003f5c:	9801      	ldr	r0, [sp, #4]
 8003f5e:	9900      	ldr	r1, [sp, #0]
 8003f60:	f000 f80e 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8003f64:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8003f66:	f7ff ff03 	bl	8003d70 <osalSysUnlock>

  return msg;
 8003f6a:	9b03      	ldr	r3, [sp, #12]
}
 8003f6c:	4618      	mov	r0, r3
 8003f6e:	b005      	add	sp, #20
 8003f70:	f85d fb04 	ldr.w	pc, [sp], #4
 8003f74:	f3af 8000 	nop.w
 8003f78:	f3af 8000 	nop.w
 8003f7c:	f3af 8000 	nop.w

08003f80 <ibqGetFullBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {
 8003f80:	b500      	push	{lr}
 8003f82:	b085      	sub	sp, #20
 8003f84:	9001      	str	r0, [sp, #4]
 8003f86:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003f88:	e00a      	b.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&ibqp->waiting, timeout);
 8003f8a:	9b01      	ldr	r3, [sp, #4]
 8003f8c:	4618      	mov	r0, r3
 8003f8e:	9900      	ldr	r1, [sp, #0]
 8003f90:	f7ff ff0e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8003f94:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8003f96:	9b03      	ldr	r3, [sp, #12]
 8003f98:	2b00      	cmp	r3, #0
 8003f9a:	da01      	bge.n	8003fa0 <ibqGetFullBufferTimeoutS+0x20>
       return msg;
 8003f9c:	9b03      	ldr	r3, [sp, #12]
 8003f9e:	e011      	b.n	8003fc4 <ibqGetFullBufferTimeoutS+0x44>
  msg_t ibqGetFullBufferTimeoutS(input_buffers_queue_t *ibqp,
                                 systime_t timeout) {

  osalDbgCheckClassS();

  while (ibqIsEmptyI(ibqp)) {
 8003fa0:	9b01      	ldr	r3, [sp, #4]
 8003fa2:	689b      	ldr	r3, [r3, #8]
 8003fa4:	2b00      	cmp	r3, #0
 8003fa6:	d0f0      	beq.n	8003f8a <ibqGetFullBufferTimeoutS+0xa>
  }

  osalDbgAssert(!ibqIsEmptyI(ibqp), "still empty");

  /* Setting up the "current" buffer and its boundary.*/
  ibqp->ptr = ibqp->brdptr + sizeof (size_t);
 8003fa8:	9b01      	ldr	r3, [sp, #4]
 8003faa:	691b      	ldr	r3, [r3, #16]
 8003fac:	1d1a      	adds	r2, r3, #4
 8003fae:	9b01      	ldr	r3, [sp, #4]
 8003fb0:	625a      	str	r2, [r3, #36]	; 0x24
  ibqp->top = ibqp->ptr + *((size_t *)ibqp->brdptr);
 8003fb2:	9b01      	ldr	r3, [sp, #4]
 8003fb4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8003fb6:	9b01      	ldr	r3, [sp, #4]
 8003fb8:	691b      	ldr	r3, [r3, #16]
 8003fba:	681b      	ldr	r3, [r3, #0]
 8003fbc:	441a      	add	r2, r3
 8003fbe:	9b01      	ldr	r3, [sp, #4]
 8003fc0:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8003fc2:	2300      	movs	r3, #0
}
 8003fc4:	4618      	mov	r0, r3
 8003fc6:	b005      	add	sp, #20
 8003fc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fcc:	f3af 8000 	nop.w

08003fd0 <ibqReleaseEmptyBuffer>:
 *
 * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
 *
 * @api
 */
void ibqReleaseEmptyBuffer(input_buffers_queue_t *ibqp) {
 8003fd0:	b500      	push	{lr}
 8003fd2:	b083      	sub	sp, #12
 8003fd4:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8003fd6:	f7ff fec3 	bl	8003d60 <osalSysLock>
  ibqReleaseEmptyBufferS(ibqp);
 8003fda:	9801      	ldr	r0, [sp, #4]
 8003fdc:	f000 f808 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  osalSysUnlock();
 8003fe0:	f7ff fec6 	bl	8003d70 <osalSysUnlock>
}
 8003fe4:	b003      	add	sp, #12
 8003fe6:	f85d fb04 	ldr.w	pc, [sp], #4
 8003fea:	bf00      	nop
 8003fec:	f3af 8000 	nop.w

08003ff0 <ibqReleaseEmptyBufferS>:
   *
   * @param[in] ibqp      pointer to the @p input_buffers_queue_t object
   *
   * @sclass
   */
  void ibqReleaseEmptyBufferS(input_buffers_queue_t *ibqp) {
 8003ff0:	b500      	push	{lr}
 8003ff2:	b083      	sub	sp, #12
 8003ff4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassS();
  osalDbgAssert(!ibqIsEmptyI(ibqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  ibqp->bcounter--;
 8003ff6:	9b01      	ldr	r3, [sp, #4]
 8003ff8:	689b      	ldr	r3, [r3, #8]
 8003ffa:	1e5a      	subs	r2, r3, #1
 8003ffc:	9b01      	ldr	r3, [sp, #4]
 8003ffe:	609a      	str	r2, [r3, #8]
  ibqp->brdptr += ibqp->bsize;
 8004000:	9b01      	ldr	r3, [sp, #4]
 8004002:	691a      	ldr	r2, [r3, #16]
 8004004:	9b01      	ldr	r3, [sp, #4]
 8004006:	699b      	ldr	r3, [r3, #24]
 8004008:	441a      	add	r2, r3
 800400a:	9b01      	ldr	r3, [sp, #4]
 800400c:	611a      	str	r2, [r3, #16]
  if (ibqp->brdptr >= ibqp->btop) {
 800400e:	9b01      	ldr	r3, [sp, #4]
 8004010:	691a      	ldr	r2, [r3, #16]
 8004012:	9b01      	ldr	r3, [sp, #4]
 8004014:	695b      	ldr	r3, [r3, #20]
 8004016:	429a      	cmp	r2, r3
 8004018:	d303      	bcc.n	8004022 <ibqReleaseEmptyBufferS+0x32>
    ibqp->brdptr = ibqp->buffers;
 800401a:	9b01      	ldr	r3, [sp, #4]
 800401c:	6a1a      	ldr	r2, [r3, #32]
 800401e:	9b01      	ldr	r3, [sp, #4]
 8004020:	611a      	str	r2, [r3, #16]
  }

  /* No "current" buffer.*/
  ibqp->ptr = NULL;
 8004022:	9b01      	ldr	r3, [sp, #4]
 8004024:	2200      	movs	r2, #0
 8004026:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (ibqp->notify != NULL) {
 8004028:	9b01      	ldr	r3, [sp, #4]
 800402a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800402c:	2b00      	cmp	r3, #0
 800402e:	d003      	beq.n	8004038 <ibqReleaseEmptyBufferS+0x48>
    ibqp->notify(ibqp);
 8004030:	9b01      	ldr	r3, [sp, #4]
 8004032:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8004034:	9801      	ldr	r0, [sp, #4]
 8004036:	4798      	blx	r3
  }
}
 8004038:	b003      	add	sp, #12
 800403a:	f85d fb04 	ldr.w	pc, [sp], #4
 800403e:	bf00      	nop

08004040 <ibqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t ibqGetTimeout(input_buffers_queue_t *ibqp, systime_t timeout) {
 8004040:	b500      	push	{lr}
 8004042:	b085      	sub	sp, #20
 8004044:	9001      	str	r0, [sp, #4]
 8004046:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004048:	f7ff fe8a 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (ibqp->ptr == NULL) {
 800404c:	9b01      	ldr	r3, [sp, #4]
 800404e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004050:	2b00      	cmp	r3, #0
 8004052:	d10b      	bne.n	800406c <ibqGetTimeout+0x2c>
    msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 8004054:	9801      	ldr	r0, [sp, #4]
 8004056:	9900      	ldr	r1, [sp, #0]
 8004058:	f7ff ff92 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 800405c:	9003      	str	r0, [sp, #12]
    if (msg != MSG_OK) {
 800405e:	9b03      	ldr	r3, [sp, #12]
 8004060:	2b00      	cmp	r3, #0
 8004062:	d003      	beq.n	800406c <ibqGetTimeout+0x2c>
      osalSysUnlock();
 8004064:	f7ff fe84 	bl	8003d70 <osalSysUnlock>
      return msg;
 8004068:	9b03      	ldr	r3, [sp, #12]
 800406a:	e014      	b.n	8004096 <ibqGetTimeout+0x56>
    }
  }

  /* Next byte from the buffer.*/
  msg = (msg_t)*ibqp->ptr;
 800406c:	9b01      	ldr	r3, [sp, #4]
 800406e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004070:	781b      	ldrb	r3, [r3, #0]
 8004072:	9303      	str	r3, [sp, #12]
  ibqp->ptr++;
 8004074:	9b01      	ldr	r3, [sp, #4]
 8004076:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004078:	1c5a      	adds	r2, r3, #1
 800407a:	9b01      	ldr	r3, [sp, #4]
 800407c:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully read then it is returned as
     empty in the queue.*/
  if (ibqp->ptr >= ibqp->top) {
 800407e:	9b01      	ldr	r3, [sp, #4]
 8004080:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004082:	9b01      	ldr	r3, [sp, #4]
 8004084:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004086:	429a      	cmp	r2, r3
 8004088:	d302      	bcc.n	8004090 <ibqGetTimeout+0x50>
    ibqReleaseEmptyBufferS(ibqp);
 800408a:	9801      	ldr	r0, [sp, #4]
 800408c:	f7ff ffb0 	bl	8003ff0 <ibqReleaseEmptyBufferS>
  }

  osalSysUnlock();
 8004090:	f7ff fe6e 	bl	8003d70 <osalSysUnlock>
  return msg;
 8004094:	9b03      	ldr	r3, [sp, #12]
}
 8004096:	4618      	mov	r0, r3
 8004098:	b005      	add	sp, #20
 800409a:	f85d fb04 	ldr.w	pc, [sp], #4
 800409e:	bf00      	nop

080040a0 <ibqReadTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t ibqReadTimeout(input_buffers_queue_t *ibqp, uint8_t *bp,
                      size_t n, systime_t timeout) {
 80040a0:	b500      	push	{lr}
 80040a2:	b08b      	sub	sp, #44	; 0x2c
 80040a4:	9003      	str	r0, [sp, #12]
 80040a6:	9102      	str	r1, [sp, #8]
 80040a8:	9201      	str	r2, [sp, #4]
 80040aa:	9300      	str	r3, [sp, #0]
  size_t r = 0;
 80040ac:	2300      	movs	r3, #0
 80040ae:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 80040b0:	f7ff fe56 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 80040b4:	f7ff fe64 	bl	8003d80 <osalOsGetSystemTimeX>
 80040b8:	4602      	mov	r2, r0
 80040ba:	9b00      	ldr	r3, [sp, #0]
 80040bc:	4413      	add	r3, r2
 80040be:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (ibqp->ptr == NULL) {
 80040c0:	9b03      	ldr	r3, [sp, #12]
 80040c2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80040c4:	2b00      	cmp	r3, #0
 80040c6:	d126      	bne.n	8004116 <ibqReadTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80040c8:	9b00      	ldr	r3, [sp, #0]
 80040ca:	f1b3 3fff 	cmp.w	r3, #4294967295
 80040ce:	d002      	beq.n	80040d6 <ibqReadTimeout+0x36>
 80040d0:	9b00      	ldr	r3, [sp, #0]
 80040d2:	2b00      	cmp	r3, #0
 80040d4:	d105      	bne.n	80040e2 <ibqReadTimeout+0x42>
        msg = ibqGetFullBufferTimeoutS(ibqp, timeout);
 80040d6:	9803      	ldr	r0, [sp, #12]
 80040d8:	9900      	ldr	r1, [sp, #0]
 80040da:	f7ff ff51 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 80040de:	9007      	str	r0, [sp, #28]
 80040e0:	e012      	b.n	8004108 <ibqReadTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80040e2:	f7ff fe4d 	bl	8003d80 <osalOsGetSystemTimeX>
 80040e6:	4603      	mov	r3, r0
 80040e8:	9a06      	ldr	r2, [sp, #24]
 80040ea:	1ad3      	subs	r3, r2, r3
 80040ec:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80040ee:	9a05      	ldr	r2, [sp, #20]
 80040f0:	9b00      	ldr	r3, [sp, #0]
 80040f2:	429a      	cmp	r2, r3
 80040f4:	d903      	bls.n	80040fe <ibqReadTimeout+0x5e>
          osalSysUnlock();
 80040f6:	f7ff fe3b 	bl	8003d70 <osalSysUnlock>
          return r;
 80040fa:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80040fc:	e05c      	b.n	80041b8 <ibqReadTimeout+0x118>
        }
        msg = ibqGetFullBufferTimeoutS(ibqp, next_timeout);
 80040fe:	9803      	ldr	r0, [sp, #12]
 8004100:	9905      	ldr	r1, [sp, #20]
 8004102:	f7ff ff3d 	bl	8003f80 <ibqGetFullBufferTimeoutS>
 8004106:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 8004108:	9b07      	ldr	r3, [sp, #28]
 800410a:	2b00      	cmp	r3, #0
 800410c:	d003      	beq.n	8004116 <ibqReadTimeout+0x76>
        osalSysUnlock();
 800410e:	f7ff fe2f 	bl	8003d70 <osalSysUnlock>
        return r;
 8004112:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004114:	e050      	b.n	80041b8 <ibqReadTimeout+0x118>
      }
    }

    /* Size of the data chunk present in the current buffer.*/
    size = (size_t)ibqp->top - (size_t)ibqp->ptr;
 8004116:	9b03      	ldr	r3, [sp, #12]
 8004118:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800411a:	461a      	mov	r2, r3
 800411c:	9b03      	ldr	r3, [sp, #12]
 800411e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004120:	1ad3      	subs	r3, r2, r3
 8004122:	9308      	str	r3, [sp, #32]
    if (size > (n - r)) {
 8004124:	9a01      	ldr	r2, [sp, #4]
 8004126:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004128:	1ad2      	subs	r2, r2, r3
 800412a:	9b08      	ldr	r3, [sp, #32]
 800412c:	429a      	cmp	r2, r3
 800412e:	d203      	bcs.n	8004138 <ibqReadTimeout+0x98>
      size = n - r;
 8004130:	9a01      	ldr	r2, [sp, #4]
 8004132:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004134:	1ad3      	subs	r3, r2, r3
 8004136:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004138:	9b08      	ldr	r3, [sp, #32]
 800413a:	2b40      	cmp	r3, #64	; 0x40
 800413c:	d913      	bls.n	8004166 <ibqReadTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(bp, ibqp->ptr, 64U);
 800413e:	9b03      	ldr	r3, [sp, #12]
 8004140:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004142:	9802      	ldr	r0, [sp, #8]
 8004144:	4619      	mov	r1, r3
 8004146:	2240      	movs	r2, #64	; 0x40
 8004148:	f012 fc02 	bl	8016950 <memcpy>
      bp        += 64U;
 800414c:	9b02      	ldr	r3, [sp, #8]
 800414e:	3340      	adds	r3, #64	; 0x40
 8004150:	9302      	str	r3, [sp, #8]
      ibqp->ptr += 64U;
 8004152:	9b03      	ldr	r3, [sp, #12]
 8004154:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004156:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800415a:	9b03      	ldr	r3, [sp, #12]
 800415c:	625a      	str	r2, [r3, #36]	; 0x24
      r         += 64U;
 800415e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004160:	3340      	adds	r3, #64	; 0x40
 8004162:	9309      	str	r3, [sp, #36]	; 0x24
 8004164:	e014      	b.n	8004190 <ibqReadTimeout+0xf0>
    }
    else {
      memcpy(bp, ibqp->ptr, size);
 8004166:	9b03      	ldr	r3, [sp, #12]
 8004168:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800416a:	9802      	ldr	r0, [sp, #8]
 800416c:	4619      	mov	r1, r3
 800416e:	9a08      	ldr	r2, [sp, #32]
 8004170:	f012 fbee 	bl	8016950 <memcpy>
      bp        += size;
 8004174:	9a02      	ldr	r2, [sp, #8]
 8004176:	9b08      	ldr	r3, [sp, #32]
 8004178:	4413      	add	r3, r2
 800417a:	9302      	str	r3, [sp, #8]
      ibqp->ptr += size;
 800417c:	9b03      	ldr	r3, [sp, #12]
 800417e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004180:	9b08      	ldr	r3, [sp, #32]
 8004182:	441a      	add	r2, r3
 8004184:	9b03      	ldr	r3, [sp, #12]
 8004186:	625a      	str	r2, [r3, #36]	; 0x24
      r         += size;
 8004188:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800418a:	9b08      	ldr	r3, [sp, #32]
 800418c:	4413      	add	r3, r2
 800418e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (ibqp->ptr >= ibqp->top) {
 8004190:	9b03      	ldr	r3, [sp, #12]
 8004192:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004194:	9b03      	ldr	r3, [sp, #12]
 8004196:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004198:	429a      	cmp	r2, r3
 800419a:	d302      	bcc.n	80041a2 <ibqReadTimeout+0x102>
      ibqReleaseEmptyBufferS(ibqp);
 800419c:	9803      	ldr	r0, [sp, #12]
 800419e:	f7ff ff27 	bl	8003ff0 <ibqReleaseEmptyBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 80041a2:	f7ff fde5 	bl	8003d70 <osalSysUnlock>
    if (r >= n) {
 80041a6:	9a09      	ldr	r2, [sp, #36]	; 0x24
 80041a8:	9b01      	ldr	r3, [sp, #4]
 80041aa:	429a      	cmp	r2, r3
 80041ac:	d301      	bcc.n	80041b2 <ibqReadTimeout+0x112>
      return r;
 80041ae:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80041b0:	e002      	b.n	80041b8 <ibqReadTimeout+0x118>
    }
    osalSysLock();
 80041b2:	f7ff fdd5 	bl	8003d60 <osalSysLock>
  }
 80041b6:	e783      	b.n	80040c0 <ibqReadTimeout+0x20>
}
 80041b8:	4618      	mov	r0, r3
 80041ba:	b00b      	add	sp, #44	; 0x2c
 80041bc:	f85d fb04 	ldr.w	pc, [sp], #4

080041c0 <obqObjectInit>:
 *
 * @init
 */
void obqObjectInit(output_buffers_queue_t *obqp, uint8_t *bp,
                   size_t size, size_t n,
                   bqnotify_t onfy, void *link) {
 80041c0:	b500      	push	{lr}
 80041c2:	b085      	sub	sp, #20
 80041c4:	9003      	str	r0, [sp, #12]
 80041c6:	9102      	str	r1, [sp, #8]
 80041c8:	9201      	str	r2, [sp, #4]
 80041ca:	9300      	str	r3, [sp, #0]

  osalDbgCheck((obqp != NULL) && (bp != NULL) && (size >= 2U));

  osalThreadQueueObjectInit(&obqp->waiting);
 80041cc:	9b03      	ldr	r3, [sp, #12]
 80041ce:	4618      	mov	r0, r3
 80041d0:	f7ff fdde 	bl	8003d90 <osalThreadQueueObjectInit>
  obqp->bcounter = n;
 80041d4:	9b03      	ldr	r3, [sp, #12]
 80041d6:	9a00      	ldr	r2, [sp, #0]
 80041d8:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = bp;
 80041da:	9b03      	ldr	r3, [sp, #12]
 80041dc:	9a02      	ldr	r2, [sp, #8]
 80041de:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = bp;
 80041e0:	9b03      	ldr	r3, [sp, #12]
 80041e2:	9a02      	ldr	r2, [sp, #8]
 80041e4:	60da      	str	r2, [r3, #12]
  obqp->btop     = bp + ((size + sizeof (size_t)) * n);
 80041e6:	9b01      	ldr	r3, [sp, #4]
 80041e8:	3304      	adds	r3, #4
 80041ea:	9a00      	ldr	r2, [sp, #0]
 80041ec:	fb02 f303 	mul.w	r3, r2, r3
 80041f0:	9a02      	ldr	r2, [sp, #8]
 80041f2:	441a      	add	r2, r3
 80041f4:	9b03      	ldr	r3, [sp, #12]
 80041f6:	615a      	str	r2, [r3, #20]
  obqp->bsize    = size + sizeof (size_t);
 80041f8:	9b01      	ldr	r3, [sp, #4]
 80041fa:	1d1a      	adds	r2, r3, #4
 80041fc:	9b03      	ldr	r3, [sp, #12]
 80041fe:	619a      	str	r2, [r3, #24]
  obqp->bn       = n;
 8004200:	9b03      	ldr	r3, [sp, #12]
 8004202:	9a00      	ldr	r2, [sp, #0]
 8004204:	61da      	str	r2, [r3, #28]
  obqp->buffers  = bp;
 8004206:	9b03      	ldr	r3, [sp, #12]
 8004208:	9a02      	ldr	r2, [sp, #8]
 800420a:	621a      	str	r2, [r3, #32]
  obqp->ptr      = NULL;
 800420c:	9b03      	ldr	r3, [sp, #12]
 800420e:	2200      	movs	r2, #0
 8004210:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004212:	9b03      	ldr	r3, [sp, #12]
 8004214:	2200      	movs	r2, #0
 8004216:	629a      	str	r2, [r3, #40]	; 0x28
  obqp->notify   = onfy;
 8004218:	9b03      	ldr	r3, [sp, #12]
 800421a:	9a06      	ldr	r2, [sp, #24]
 800421c:	62da      	str	r2, [r3, #44]	; 0x2c
  obqp->link     = link;
 800421e:	9b03      	ldr	r3, [sp, #12]
 8004220:	9a07      	ldr	r2, [sp, #28]
 8004222:	631a      	str	r2, [r3, #48]	; 0x30
}
 8004224:	b005      	add	sp, #20
 8004226:	f85d fb04 	ldr.w	pc, [sp], #4
 800422a:	bf00      	nop
 800422c:	f3af 8000 	nop.w

08004230 <obqResetI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqResetI(output_buffers_queue_t *obqp) {
 8004230:	b500      	push	{lr}
 8004232:	b083      	sub	sp, #12
 8004234:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  obqp->bcounter = bqSizeX(obqp);
 8004236:	9b01      	ldr	r3, [sp, #4]
 8004238:	69da      	ldr	r2, [r3, #28]
 800423a:	9b01      	ldr	r3, [sp, #4]
 800423c:	609a      	str	r2, [r3, #8]
  obqp->brdptr   = obqp->buffers;
 800423e:	9b01      	ldr	r3, [sp, #4]
 8004240:	6a1a      	ldr	r2, [r3, #32]
 8004242:	9b01      	ldr	r3, [sp, #4]
 8004244:	611a      	str	r2, [r3, #16]
  obqp->bwrptr   = obqp->buffers;
 8004246:	9b01      	ldr	r3, [sp, #4]
 8004248:	6a1a      	ldr	r2, [r3, #32]
 800424a:	9b01      	ldr	r3, [sp, #4]
 800424c:	60da      	str	r2, [r3, #12]
  obqp->ptr      = NULL;
 800424e:	9b01      	ldr	r3, [sp, #4]
 8004250:	2200      	movs	r2, #0
 8004252:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top      = NULL;
 8004254:	9b01      	ldr	r3, [sp, #4]
 8004256:	2200      	movs	r2, #0
 8004258:	629a      	str	r2, [r3, #40]	; 0x28
  osalThreadDequeueAllI(&obqp->waiting, MSG_RESET);
 800425a:	9b01      	ldr	r3, [sp, #4]
 800425c:	4618      	mov	r0, r3
 800425e:	f06f 0101 	mvn.w	r1, #1
 8004262:	f7ff fdc5 	bl	8003df0 <osalThreadDequeueAllI>
}
 8004266:	b003      	add	sp, #12
 8004268:	f85d fb04 	ldr.w	pc, [sp], #4
 800426c:	f3af 8000 	nop.w

08004270 <obqGetFullBufferI>:
 * @retval NULL         if the queue is empty.
 *
 * @iclass
 */
uint8_t *obqGetFullBufferI(output_buffers_queue_t *obqp,
                           size_t *sizep) {
 8004270:	b082      	sub	sp, #8
 8004272:	9001      	str	r0, [sp, #4]
 8004274:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassI();

  if (obqIsEmptyI(obqp)) {
 8004276:	9b01      	ldr	r3, [sp, #4]
 8004278:	68da      	ldr	r2, [r3, #12]
 800427a:	9b01      	ldr	r3, [sp, #4]
 800427c:	691b      	ldr	r3, [r3, #16]
 800427e:	429a      	cmp	r2, r3
 8004280:	d105      	bne.n	800428e <obqGetFullBufferI+0x1e>
 8004282:	9b01      	ldr	r3, [sp, #4]
 8004284:	689b      	ldr	r3, [r3, #8]
 8004286:	2b00      	cmp	r3, #0
 8004288:	d001      	beq.n	800428e <obqGetFullBufferI+0x1e>
 800428a:	2301      	movs	r3, #1
 800428c:	e000      	b.n	8004290 <obqGetFullBufferI+0x20>
 800428e:	2300      	movs	r3, #0
 8004290:	f003 0301 	and.w	r3, r3, #1
 8004294:	b2db      	uxtb	r3, r3
 8004296:	2b00      	cmp	r3, #0
 8004298:	d001      	beq.n	800429e <obqGetFullBufferI+0x2e>
    return NULL;
 800429a:	2300      	movs	r3, #0
 800429c:	e007      	b.n	80042ae <obqGetFullBufferI+0x3e>
  }

  /* Buffer size.*/
  *sizep = *((size_t *)obqp->brdptr);
 800429e:	9b01      	ldr	r3, [sp, #4]
 80042a0:	691b      	ldr	r3, [r3, #16]
 80042a2:	681a      	ldr	r2, [r3, #0]
 80042a4:	9b00      	ldr	r3, [sp, #0]
 80042a6:	601a      	str	r2, [r3, #0]

  return obqp->brdptr + sizeof (size_t);
 80042a8:	9b01      	ldr	r3, [sp, #4]
 80042aa:	691b      	ldr	r3, [r3, #16]
 80042ac:	3304      	adds	r3, #4
}
 80042ae:	4618      	mov	r0, r3
 80042b0:	b002      	add	sp, #8
 80042b2:	4770      	bx	lr
 80042b4:	f3af 8000 	nop.w
 80042b8:	f3af 8000 	nop.w
 80042bc:	f3af 8000 	nop.w

080042c0 <obqReleaseEmptyBufferI>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @iclass
 */
void obqReleaseEmptyBufferI(output_buffers_queue_t *obqp) {
 80042c0:	b500      	push	{lr}
 80042c2:	b083      	sub	sp, #12
 80042c4:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgAssert(!obqIsEmptyI(obqp), "buffers queue empty");

  /* Freeing a buffer slot in the queue.*/
  obqp->bcounter++;
 80042c6:	9b01      	ldr	r3, [sp, #4]
 80042c8:	689b      	ldr	r3, [r3, #8]
 80042ca:	1c5a      	adds	r2, r3, #1
 80042cc:	9b01      	ldr	r3, [sp, #4]
 80042ce:	609a      	str	r2, [r3, #8]
  obqp->brdptr += obqp->bsize;
 80042d0:	9b01      	ldr	r3, [sp, #4]
 80042d2:	691a      	ldr	r2, [r3, #16]
 80042d4:	9b01      	ldr	r3, [sp, #4]
 80042d6:	699b      	ldr	r3, [r3, #24]
 80042d8:	441a      	add	r2, r3
 80042da:	9b01      	ldr	r3, [sp, #4]
 80042dc:	611a      	str	r2, [r3, #16]
  if (obqp->brdptr >= obqp->btop) {
 80042de:	9b01      	ldr	r3, [sp, #4]
 80042e0:	691a      	ldr	r2, [r3, #16]
 80042e2:	9b01      	ldr	r3, [sp, #4]
 80042e4:	695b      	ldr	r3, [r3, #20]
 80042e6:	429a      	cmp	r2, r3
 80042e8:	d303      	bcc.n	80042f2 <obqReleaseEmptyBufferI+0x32>
    obqp->brdptr = obqp->buffers;
 80042ea:	9b01      	ldr	r3, [sp, #4]
 80042ec:	6a1a      	ldr	r2, [r3, #32]
 80042ee:	9b01      	ldr	r3, [sp, #4]
 80042f0:	611a      	str	r2, [r3, #16]
  }

  /* Waking up one waiting thread, if any.*/
  osalThreadDequeueNextI(&obqp->waiting, MSG_OK);
 80042f2:	9b01      	ldr	r3, [sp, #4]
 80042f4:	4618      	mov	r0, r3
 80042f6:	2100      	movs	r1, #0
 80042f8:	f7ff fd6a 	bl	8003dd0 <osalThreadDequeueNextI>
}
 80042fc:	b003      	add	sp, #12
 80042fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004302:	bf00      	nop
 8004304:	f3af 8000 	nop.w
 8004308:	f3af 8000 	nop.w
 800430c:	f3af 8000 	nop.w

08004310 <obqGetEmptyBufferTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqGetEmptyBufferTimeout(output_buffers_queue_t *obqp,
                                systime_t timeout) {
 8004310:	b500      	push	{lr}
 8004312:	b085      	sub	sp, #20
 8004314:	9001      	str	r0, [sp, #4]
 8004316:	9100      	str	r1, [sp, #0]
  msg_t msg;

  osalSysLock();
 8004318:	f7ff fd22 	bl	8003d60 <osalSysLock>
  msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800431c:	9801      	ldr	r0, [sp, #4]
 800431e:	9900      	ldr	r1, [sp, #0]
 8004320:	f000 f80e 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004324:	9003      	str	r0, [sp, #12]
  osalSysUnlock();
 8004326:	f7ff fd23 	bl	8003d70 <osalSysUnlock>

  return msg;
 800432a:	9b03      	ldr	r3, [sp, #12]
}
 800432c:	4618      	mov	r0, r3
 800432e:	b005      	add	sp, #20
 8004330:	f85d fb04 	ldr.w	pc, [sp], #4
 8004334:	f3af 8000 	nop.w
 8004338:	f3af 8000 	nop.w
 800433c:	f3af 8000 	nop.w

08004340 <obqGetEmptyBufferTimeoutS>:
   * @retval MSG_RESET    if the queue has been reset.
   *
   * @sclass
   */
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {
 8004340:	b500      	push	{lr}
 8004342:	b085      	sub	sp, #20
 8004344:	9001      	str	r0, [sp, #4]
 8004346:	9100      	str	r1, [sp, #0]

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004348:	e00a      	b.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
    msg_t msg = osalThreadEnqueueTimeoutS(&obqp->waiting, timeout);
 800434a:	9b01      	ldr	r3, [sp, #4]
 800434c:	4618      	mov	r0, r3
 800434e:	9900      	ldr	r1, [sp, #0]
 8004350:	f7ff fd2e 	bl	8003db0 <osalThreadEnqueueTimeoutS>
 8004354:	9003      	str	r0, [sp, #12]
    if (msg < MSG_OK) {
 8004356:	9b03      	ldr	r3, [sp, #12]
 8004358:	2b00      	cmp	r3, #0
 800435a:	da01      	bge.n	8004360 <obqGetEmptyBufferTimeoutS+0x20>
      return msg;
 800435c:	9b03      	ldr	r3, [sp, #12]
 800435e:	e010      	b.n	8004382 <obqGetEmptyBufferTimeoutS+0x42>
  msg_t obqGetEmptyBufferTimeoutS(output_buffers_queue_t *obqp,
                                  systime_t timeout) {

  osalDbgCheckClassS();

  while (obqIsFullI(obqp)) {
 8004360:	9b01      	ldr	r3, [sp, #4]
 8004362:	689b      	ldr	r3, [r3, #8]
 8004364:	2b00      	cmp	r3, #0
 8004366:	d0f0      	beq.n	800434a <obqGetEmptyBufferTimeoutS+0xa>
  }

  osalDbgAssert(!obqIsFullI(obqp), "still full");

  /* Setting up the "current" buffer and its boundary.*/
  obqp->ptr = obqp->bwrptr + sizeof (size_t);
 8004368:	9b01      	ldr	r3, [sp, #4]
 800436a:	68db      	ldr	r3, [r3, #12]
 800436c:	1d1a      	adds	r2, r3, #4
 800436e:	9b01      	ldr	r3, [sp, #4]
 8004370:	625a      	str	r2, [r3, #36]	; 0x24
  obqp->top = obqp->bwrptr + obqp->bsize;
 8004372:	9b01      	ldr	r3, [sp, #4]
 8004374:	68da      	ldr	r2, [r3, #12]
 8004376:	9b01      	ldr	r3, [sp, #4]
 8004378:	699b      	ldr	r3, [r3, #24]
 800437a:	441a      	add	r2, r3
 800437c:	9b01      	ldr	r3, [sp, #4]
 800437e:	629a      	str	r2, [r3, #40]	; 0x28

  return MSG_OK;
 8004380:	2300      	movs	r3, #0
}
 8004382:	4618      	mov	r0, r3
 8004384:	b005      	add	sp, #20
 8004386:	f85d fb04 	ldr.w	pc, [sp], #4
 800438a:	bf00      	nop
 800438c:	f3af 8000 	nop.w

08004390 <obqPostFullBuffer>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @api
 */
void obqPostFullBuffer(output_buffers_queue_t *obqp, size_t size) {
 8004390:	b500      	push	{lr}
 8004392:	b083      	sub	sp, #12
 8004394:	9001      	str	r0, [sp, #4]
 8004396:	9100      	str	r1, [sp, #0]

  osalSysLock();
 8004398:	f7ff fce2 	bl	8003d60 <osalSysLock>
  obqPostFullBufferS(obqp, size);
 800439c:	9801      	ldr	r0, [sp, #4]
 800439e:	9900      	ldr	r1, [sp, #0]
 80043a0:	f000 f806 	bl	80043b0 <obqPostFullBufferS>
  osalSysUnlock();
 80043a4:	f7ff fce4 	bl	8003d70 <osalSysUnlock>
}
 80043a8:	b003      	add	sp, #12
 80043aa:	f85d fb04 	ldr.w	pc, [sp], #4
 80043ae:	bf00      	nop

080043b0 <obqPostFullBufferS>:
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 * @param[in] size      used size of the buffer, cannot be zero
 *
 * @sclass
 */
void obqPostFullBufferS(output_buffers_queue_t *obqp, size_t size) {
 80043b0:	b500      	push	{lr}
 80043b2:	b083      	sub	sp, #12
 80043b4:	9001      	str	r0, [sp, #4]
 80043b6:	9100      	str	r1, [sp, #0]
  osalDbgCheckClassS();
  osalDbgCheck((size > 0U) && (size <= (obqp->bsize - sizeof (size_t))));
  osalDbgAssert(!obqIsFullI(obqp), "buffers queue full");

  /* Writing size field in the buffer.*/
  *((size_t *)obqp->bwrptr) = size;
 80043b8:	9b01      	ldr	r3, [sp, #4]
 80043ba:	68db      	ldr	r3, [r3, #12]
 80043bc:	9a00      	ldr	r2, [sp, #0]
 80043be:	601a      	str	r2, [r3, #0]

  /* Posting the buffer in the queue.*/
  obqp->bcounter--;
 80043c0:	9b01      	ldr	r3, [sp, #4]
 80043c2:	689b      	ldr	r3, [r3, #8]
 80043c4:	1e5a      	subs	r2, r3, #1
 80043c6:	9b01      	ldr	r3, [sp, #4]
 80043c8:	609a      	str	r2, [r3, #8]
  obqp->bwrptr += obqp->bsize;
 80043ca:	9b01      	ldr	r3, [sp, #4]
 80043cc:	68da      	ldr	r2, [r3, #12]
 80043ce:	9b01      	ldr	r3, [sp, #4]
 80043d0:	699b      	ldr	r3, [r3, #24]
 80043d2:	441a      	add	r2, r3
 80043d4:	9b01      	ldr	r3, [sp, #4]
 80043d6:	60da      	str	r2, [r3, #12]
  if (obqp->bwrptr >= obqp->btop) {
 80043d8:	9b01      	ldr	r3, [sp, #4]
 80043da:	68da      	ldr	r2, [r3, #12]
 80043dc:	9b01      	ldr	r3, [sp, #4]
 80043de:	695b      	ldr	r3, [r3, #20]
 80043e0:	429a      	cmp	r2, r3
 80043e2:	d303      	bcc.n	80043ec <obqPostFullBufferS+0x3c>
    obqp->bwrptr = obqp->buffers;
 80043e4:	9b01      	ldr	r3, [sp, #4]
 80043e6:	6a1a      	ldr	r2, [r3, #32]
 80043e8:	9b01      	ldr	r3, [sp, #4]
 80043ea:	60da      	str	r2, [r3, #12]
  }

  /* No "current" buffer.*/
  obqp->ptr = NULL;
 80043ec:	9b01      	ldr	r3, [sp, #4]
 80043ee:	2200      	movs	r2, #0
 80043f0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Notifying the buffer release.*/
  if (obqp->notify != NULL) {
 80043f2:	9b01      	ldr	r3, [sp, #4]
 80043f4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043f6:	2b00      	cmp	r3, #0
 80043f8:	d003      	beq.n	8004402 <obqPostFullBufferS+0x52>
    obqp->notify(obqp);
 80043fa:	9b01      	ldr	r3, [sp, #4]
 80043fc:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80043fe:	9801      	ldr	r0, [sp, #4]
 8004400:	4798      	blx	r3
  }
}
 8004402:	b003      	add	sp, #12
 8004404:	f85d fb04 	ldr.w	pc, [sp], #4
 8004408:	f3af 8000 	nop.w
 800440c:	f3af 8000 	nop.w

08004410 <obqPutTimeout>:
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t obqPutTimeout(output_buffers_queue_t *obqp, uint8_t b,
                    systime_t timeout) {
 8004410:	b500      	push	{lr}
 8004412:	b087      	sub	sp, #28
 8004414:	9003      	str	r0, [sp, #12]
 8004416:	460b      	mov	r3, r1
 8004418:	9201      	str	r2, [sp, #4]
 800441a:	f88d 300b 	strb.w	r3, [sp, #11]
  msg_t msg;

  osalSysLock();
 800441e:	f7ff fc9f 	bl	8003d60 <osalSysLock>

  /* This condition indicates that a new buffer must be acquired.*/
  if (obqp->ptr == NULL) {
 8004422:	9b03      	ldr	r3, [sp, #12]
 8004424:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004426:	2b00      	cmp	r3, #0
 8004428:	d10b      	bne.n	8004442 <obqPutTimeout+0x32>
    msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 800442a:	9803      	ldr	r0, [sp, #12]
 800442c:	9901      	ldr	r1, [sp, #4]
 800442e:	f7ff ff87 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 8004432:	9005      	str	r0, [sp, #20]
    if (msg != MSG_OK) {
 8004434:	9b05      	ldr	r3, [sp, #20]
 8004436:	2b00      	cmp	r3, #0
 8004438:	d003      	beq.n	8004442 <obqPutTimeout+0x32>
      osalSysUnlock();
 800443a:	f7ff fc99 	bl	8003d70 <osalSysUnlock>
      return msg;
 800443e:	9b05      	ldr	r3, [sp, #20]
 8004440:	e019      	b.n	8004476 <obqPutTimeout+0x66>
    }
  }

  /* Writing the byte to the buffer.*/
  *obqp->ptr = b;
 8004442:	9b03      	ldr	r3, [sp, #12]
 8004444:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004446:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800444a:	701a      	strb	r2, [r3, #0]
  obqp->ptr++;
 800444c:	9b03      	ldr	r3, [sp, #12]
 800444e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004450:	1c5a      	adds	r2, r3, #1
 8004452:	9b03      	ldr	r3, [sp, #12]
 8004454:	625a      	str	r2, [r3, #36]	; 0x24

  /* If the current buffer has been fully written then it is posted as
     full in the queue.*/
  if (obqp->ptr >= obqp->top) {
 8004456:	9b03      	ldr	r3, [sp, #12]
 8004458:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 800445a:	9b03      	ldr	r3, [sp, #12]
 800445c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800445e:	429a      	cmp	r2, r3
 8004460:	d306      	bcc.n	8004470 <obqPutTimeout+0x60>
    obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 8004462:	9b03      	ldr	r3, [sp, #12]
 8004464:	699b      	ldr	r3, [r3, #24]
 8004466:	3b04      	subs	r3, #4
 8004468:	9803      	ldr	r0, [sp, #12]
 800446a:	4619      	mov	r1, r3
 800446c:	f7ff ffa0 	bl	80043b0 <obqPostFullBufferS>
  }

  osalSysUnlock();
 8004470:	f7ff fc7e 	bl	8003d70 <osalSysUnlock>
  return MSG_OK;
 8004474:	2300      	movs	r3, #0
}
 8004476:	4618      	mov	r0, r3
 8004478:	b007      	add	sp, #28
 800447a:	f85d fb04 	ldr.w	pc, [sp], #4
 800447e:	bf00      	nop

08004480 <obqWriteTimeout>:
 * @retval 0            if a timeout occurred.
 *
 * @api
 */
size_t obqWriteTimeout(output_buffers_queue_t *obqp, const uint8_t *bp,
                       size_t n, systime_t timeout) {
 8004480:	b500      	push	{lr}
 8004482:	b08b      	sub	sp, #44	; 0x2c
 8004484:	9003      	str	r0, [sp, #12]
 8004486:	9102      	str	r1, [sp, #8]
 8004488:	9201      	str	r2, [sp, #4]
 800448a:	9300      	str	r3, [sp, #0]
  size_t w = 0;
 800448c:	2300      	movs	r3, #0
 800448e:	9309      	str	r3, [sp, #36]	; 0x24
  systime_t deadline;

  osalSysLock();
 8004490:	f7ff fc66 	bl	8003d60 <osalSysLock>

  /* Time window for the whole operation.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8004494:	f7ff fc74 	bl	8003d80 <osalOsGetSystemTimeX>
 8004498:	4602      	mov	r2, r0
 800449a:	9b00      	ldr	r3, [sp, #0]
 800449c:	4413      	add	r3, r2
 800449e:	9306      	str	r3, [sp, #24]

  while (true) {
    size_t size;

    /* This condition indicates that a new buffer must be acquired.*/
    if (obqp->ptr == NULL) {
 80044a0:	9b03      	ldr	r3, [sp, #12]
 80044a2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80044a4:	2b00      	cmp	r3, #0
 80044a6:	d126      	bne.n	80044f6 <obqWriteTimeout+0x76>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 80044a8:	9b00      	ldr	r3, [sp, #0]
 80044aa:	f1b3 3fff 	cmp.w	r3, #4294967295
 80044ae:	d002      	beq.n	80044b6 <obqWriteTimeout+0x36>
 80044b0:	9b00      	ldr	r3, [sp, #0]
 80044b2:	2b00      	cmp	r3, #0
 80044b4:	d105      	bne.n	80044c2 <obqWriteTimeout+0x42>
        msg = obqGetEmptyBufferTimeoutS(obqp, timeout);
 80044b6:	9803      	ldr	r0, [sp, #12]
 80044b8:	9900      	ldr	r1, [sp, #0]
 80044ba:	f7ff ff41 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044be:	9007      	str	r0, [sp, #28]
 80044c0:	e012      	b.n	80044e8 <obqWriteTimeout+0x68>
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 80044c2:	f7ff fc5d 	bl	8003d80 <osalOsGetSystemTimeX>
 80044c6:	4603      	mov	r3, r0
 80044c8:	9a06      	ldr	r2, [sp, #24]
 80044ca:	1ad3      	subs	r3, r2, r3
 80044cc:	9305      	str	r3, [sp, #20]

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 80044ce:	9a05      	ldr	r2, [sp, #20]
 80044d0:	9b00      	ldr	r3, [sp, #0]
 80044d2:	429a      	cmp	r2, r3
 80044d4:	d903      	bls.n	80044de <obqWriteTimeout+0x5e>
          osalSysUnlock();
 80044d6:	f7ff fc4b 	bl	8003d70 <osalSysUnlock>
          return w;
 80044da:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044dc:	e060      	b.n	80045a0 <obqWriteTimeout+0x120>
        }
        msg = obqGetEmptyBufferTimeoutS(obqp, next_timeout);
 80044de:	9803      	ldr	r0, [sp, #12]
 80044e0:	9905      	ldr	r1, [sp, #20]
 80044e2:	f7ff ff2d 	bl	8004340 <obqGetEmptyBufferTimeoutS>
 80044e6:	9007      	str	r0, [sp, #28]
      }

      /* Anything except MSG_OK interrupts the operation.*/
      if (msg != MSG_OK) {
 80044e8:	9b07      	ldr	r3, [sp, #28]
 80044ea:	2b00      	cmp	r3, #0
 80044ec:	d003      	beq.n	80044f6 <obqWriteTimeout+0x76>
        osalSysUnlock();
 80044ee:	f7ff fc3f 	bl	8003d70 <osalSysUnlock>
        return w;
 80044f2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80044f4:	e054      	b.n	80045a0 <obqWriteTimeout+0x120>
      }
    }

    /* Size of the space available in the current buffer.*/
    size = (size_t)obqp->top - (size_t)obqp->ptr;
 80044f6:	9b03      	ldr	r3, [sp, #12]
 80044f8:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80044fa:	461a      	mov	r2, r3
 80044fc:	9b03      	ldr	r3, [sp, #12]
 80044fe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004500:	1ad3      	subs	r3, r2, r3
 8004502:	9308      	str	r3, [sp, #32]
    if (size > (n - w)) {
 8004504:	9a01      	ldr	r2, [sp, #4]
 8004506:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004508:	1ad2      	subs	r2, r2, r3
 800450a:	9b08      	ldr	r3, [sp, #32]
 800450c:	429a      	cmp	r2, r3
 800450e:	d203      	bcs.n	8004518 <obqWriteTimeout+0x98>
      size = n - w;
 8004510:	9a01      	ldr	r2, [sp, #4]
 8004512:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004514:	1ad3      	subs	r3, r2, r3
 8004516:	9308      	str	r3, [sp, #32]
    }

    /* Smaller chunks in order to not make the critical zone too long,
       this impacts throughput however.*/
    if (size > 64U) {
 8004518:	9b08      	ldr	r3, [sp, #32]
 800451a:	2b40      	cmp	r3, #64	; 0x40
 800451c:	d913      	bls.n	8004546 <obqWriteTimeout+0xc6>
      /* Giving the compiler a chance to optimize for a fixed size move.*/
      memcpy(obqp->ptr, bp, 64U);
 800451e:	9b03      	ldr	r3, [sp, #12]
 8004520:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004522:	4618      	mov	r0, r3
 8004524:	9902      	ldr	r1, [sp, #8]
 8004526:	2240      	movs	r2, #64	; 0x40
 8004528:	f012 fa12 	bl	8016950 <memcpy>
      bp        += 64U;
 800452c:	9b02      	ldr	r3, [sp, #8]
 800452e:	3340      	adds	r3, #64	; 0x40
 8004530:	9302      	str	r3, [sp, #8]
      obqp->ptr += 64U;
 8004532:	9b03      	ldr	r3, [sp, #12]
 8004534:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004536:	f103 0240 	add.w	r2, r3, #64	; 0x40
 800453a:	9b03      	ldr	r3, [sp, #12]
 800453c:	625a      	str	r2, [r3, #36]	; 0x24
      w         += 64U;
 800453e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004540:	3340      	adds	r3, #64	; 0x40
 8004542:	9309      	str	r3, [sp, #36]	; 0x24
 8004544:	e014      	b.n	8004570 <obqWriteTimeout+0xf0>
    }
    else {
      memcpy(obqp->ptr, bp, size);
 8004546:	9b03      	ldr	r3, [sp, #12]
 8004548:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800454a:	4618      	mov	r0, r3
 800454c:	9902      	ldr	r1, [sp, #8]
 800454e:	9a08      	ldr	r2, [sp, #32]
 8004550:	f012 f9fe 	bl	8016950 <memcpy>
      bp        += size;
 8004554:	9a02      	ldr	r2, [sp, #8]
 8004556:	9b08      	ldr	r3, [sp, #32]
 8004558:	4413      	add	r3, r2
 800455a:	9302      	str	r3, [sp, #8]
      obqp->ptr += size;
 800455c:	9b03      	ldr	r3, [sp, #12]
 800455e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004560:	9b08      	ldr	r3, [sp, #32]
 8004562:	441a      	add	r2, r3
 8004564:	9b03      	ldr	r3, [sp, #12]
 8004566:	625a      	str	r2, [r3, #36]	; 0x24
      w         += size;
 8004568:	9a09      	ldr	r2, [sp, #36]	; 0x24
 800456a:	9b08      	ldr	r3, [sp, #32]
 800456c:	4413      	add	r3, r2
 800456e:	9309      	str	r3, [sp, #36]	; 0x24
    }

    /* Has the current data buffer been finished? if so then release it.*/
    if (obqp->ptr >= obqp->top) {
 8004570:	9b03      	ldr	r3, [sp, #12]
 8004572:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8004574:	9b03      	ldr	r3, [sp, #12]
 8004576:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8004578:	429a      	cmp	r2, r3
 800457a:	d306      	bcc.n	800458a <obqWriteTimeout+0x10a>
      obqPostFullBufferS(obqp, obqp->bsize - sizeof (size_t));
 800457c:	9b03      	ldr	r3, [sp, #12]
 800457e:	699b      	ldr	r3, [r3, #24]
 8004580:	3b04      	subs	r3, #4
 8004582:	9803      	ldr	r0, [sp, #12]
 8004584:	4619      	mov	r1, r3
 8004586:	f7ff ff13 	bl	80043b0 <obqPostFullBufferS>
    }

    /* Giving a preemption chance.*/
    osalSysUnlock();
 800458a:	f7ff fbf1 	bl	8003d70 <osalSysUnlock>
    if (w >= n) {
 800458e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8004590:	9b01      	ldr	r3, [sp, #4]
 8004592:	429a      	cmp	r2, r3
 8004594:	d301      	bcc.n	800459a <obqWriteTimeout+0x11a>
      return w;
 8004596:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8004598:	e002      	b.n	80045a0 <obqWriteTimeout+0x120>
    }
    osalSysLock();
 800459a:	f7ff fbe1 	bl	8003d60 <osalSysLock>
  }
 800459e:	e77f      	b.n	80044a0 <obqWriteTimeout+0x20>
}
 80045a0:	4618      	mov	r0, r3
 80045a2:	b00b      	add	sp, #44	; 0x2c
 80045a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80045a8:	f3af 8000 	nop.w
 80045ac:	f3af 8000 	nop.w

080045b0 <obqTryFlushI>:
 * @retval false        if no new filled buffer has been posted to the queue.
 * @retval true         if a new filled buffer has been posted to the queue.
 *
 * @iclass
 */
bool obqTryFlushI(output_buffers_queue_t *obqp) {
 80045b0:	b084      	sub	sp, #16
 80045b2:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();

  /* If queue is empty and there is a buffer partially filled and
     it is not being written.*/
  if (obqIsEmptyI(obqp) && (obqp->ptr != NULL)) {
 80045b4:	9b01      	ldr	r3, [sp, #4]
 80045b6:	68da      	ldr	r2, [r3, #12]
 80045b8:	9b01      	ldr	r3, [sp, #4]
 80045ba:	691b      	ldr	r3, [r3, #16]
 80045bc:	429a      	cmp	r2, r3
 80045be:	d105      	bne.n	80045cc <obqTryFlushI+0x1c>
 80045c0:	9b01      	ldr	r3, [sp, #4]
 80045c2:	689b      	ldr	r3, [r3, #8]
 80045c4:	2b00      	cmp	r3, #0
 80045c6:	d001      	beq.n	80045cc <obqTryFlushI+0x1c>
 80045c8:	2301      	movs	r3, #1
 80045ca:	e000      	b.n	80045ce <obqTryFlushI+0x1e>
 80045cc:	2300      	movs	r3, #0
 80045ce:	f003 0301 	and.w	r3, r3, #1
 80045d2:	b2db      	uxtb	r3, r3
 80045d4:	2b00      	cmp	r3, #0
 80045d6:	d02d      	beq.n	8004634 <obqTryFlushI+0x84>
 80045d8:	9b01      	ldr	r3, [sp, #4]
 80045da:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045dc:	2b00      	cmp	r3, #0
 80045de:	d029      	beq.n	8004634 <obqTryFlushI+0x84>
    size_t size = (size_t)obqp->ptr - ((size_t)obqp->bwrptr + sizeof (size_t));
 80045e0:	9b01      	ldr	r3, [sp, #4]
 80045e2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80045e4:	461a      	mov	r2, r3
 80045e6:	9b01      	ldr	r3, [sp, #4]
 80045e8:	68db      	ldr	r3, [r3, #12]
 80045ea:	1ad3      	subs	r3, r2, r3
 80045ec:	3b04      	subs	r3, #4
 80045ee:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 80045f0:	9b03      	ldr	r3, [sp, #12]
 80045f2:	2b00      	cmp	r3, #0
 80045f4:	d01e      	beq.n	8004634 <obqTryFlushI+0x84>

      /* Writing size field in the buffer.*/
      *((size_t *)obqp->bwrptr) = size;
 80045f6:	9b01      	ldr	r3, [sp, #4]
 80045f8:	68db      	ldr	r3, [r3, #12]
 80045fa:	9a03      	ldr	r2, [sp, #12]
 80045fc:	601a      	str	r2, [r3, #0]

      /* Posting the buffer in the queue.*/
      obqp->bcounter--;
 80045fe:	9b01      	ldr	r3, [sp, #4]
 8004600:	689b      	ldr	r3, [r3, #8]
 8004602:	1e5a      	subs	r2, r3, #1
 8004604:	9b01      	ldr	r3, [sp, #4]
 8004606:	609a      	str	r2, [r3, #8]
      obqp->bwrptr += obqp->bsize;
 8004608:	9b01      	ldr	r3, [sp, #4]
 800460a:	68da      	ldr	r2, [r3, #12]
 800460c:	9b01      	ldr	r3, [sp, #4]
 800460e:	699b      	ldr	r3, [r3, #24]
 8004610:	441a      	add	r2, r3
 8004612:	9b01      	ldr	r3, [sp, #4]
 8004614:	60da      	str	r2, [r3, #12]
      if (obqp->bwrptr >= obqp->btop) {
 8004616:	9b01      	ldr	r3, [sp, #4]
 8004618:	68da      	ldr	r2, [r3, #12]
 800461a:	9b01      	ldr	r3, [sp, #4]
 800461c:	695b      	ldr	r3, [r3, #20]
 800461e:	429a      	cmp	r2, r3
 8004620:	d303      	bcc.n	800462a <obqTryFlushI+0x7a>
        obqp->bwrptr = obqp->buffers;
 8004622:	9b01      	ldr	r3, [sp, #4]
 8004624:	6a1a      	ldr	r2, [r3, #32]
 8004626:	9b01      	ldr	r3, [sp, #4]
 8004628:	60da      	str	r2, [r3, #12]
      }

      /* No "current" buffer.*/
      obqp->ptr = NULL;
 800462a:	9b01      	ldr	r3, [sp, #4]
 800462c:	2200      	movs	r2, #0
 800462e:	625a      	str	r2, [r3, #36]	; 0x24

      return true;
 8004630:	2301      	movs	r3, #1
 8004632:	e000      	b.n	8004636 <obqTryFlushI+0x86>
    }
  }
  return false;
 8004634:	2300      	movs	r3, #0
}
 8004636:	4618      	mov	r0, r3
 8004638:	b004      	add	sp, #16
 800463a:	4770      	bx	lr
 800463c:	f3af 8000 	nop.w

08004640 <obqFlush>:
 *
 * @param[in] obqp      pointer to the @p output_buffers_queue_t object
 *
 * @api
 */
void obqFlush(output_buffers_queue_t *obqp) {
 8004640:	b500      	push	{lr}
 8004642:	b085      	sub	sp, #20
 8004644:	9001      	str	r0, [sp, #4]

  osalSysLock();
 8004646:	f7ff fb8b 	bl	8003d60 <osalSysLock>

  /* If there is a buffer partially filled and not being written.*/
  if (obqp->ptr != NULL) {
 800464a:	9b01      	ldr	r3, [sp, #4]
 800464c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800464e:	2b00      	cmp	r3, #0
 8004650:	d00e      	beq.n	8004670 <obqFlush+0x30>
    size_t size = (size_t)obqp->ptr - (size_t)obqp->bwrptr - sizeof (size_t);
 8004652:	9b01      	ldr	r3, [sp, #4]
 8004654:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8004656:	461a      	mov	r2, r3
 8004658:	9b01      	ldr	r3, [sp, #4]
 800465a:	68db      	ldr	r3, [r3, #12]
 800465c:	1ad3      	subs	r3, r2, r3
 800465e:	3b04      	subs	r3, #4
 8004660:	9303      	str	r3, [sp, #12]

    if (size > 0U) {
 8004662:	9b03      	ldr	r3, [sp, #12]
 8004664:	2b00      	cmp	r3, #0
 8004666:	d003      	beq.n	8004670 <obqFlush+0x30>
      obqPostFullBufferS(obqp, size);
 8004668:	9801      	ldr	r0, [sp, #4]
 800466a:	9903      	ldr	r1, [sp, #12]
 800466c:	f7ff fea0 	bl	80043b0 <obqPostFullBufferS>
    }
  }

  osalSysUnlock();
 8004670:	f7ff fb7e 	bl	8003d70 <osalSysUnlock>
}
 8004674:	b005      	add	sp, #20
 8004676:	f85d fb04 	ldr.w	pc, [sp], #4
 800467a:	bf00      	nop
 800467c:	f3af 8000 	nop.w

08004680 <_mmcsd_get_slice>:
 *
 * @notapi
 */
uint32_t _mmcsd_get_slice(const uint32_t *data,
                          uint32_t end,
                          uint32_t start) {
 8004680:	b088      	sub	sp, #32
 8004682:	9003      	str	r0, [sp, #12]
 8004684:	9102      	str	r1, [sp, #8]
 8004686:	9201      	str	r2, [sp, #4]
  unsigned startidx, endidx, startoff;
  uint32_t endmask;

  osalDbgCheck((end >= start) && ((end - start) < 32U));

  startidx = start / 32U;
 8004688:	9b01      	ldr	r3, [sp, #4]
 800468a:	095b      	lsrs	r3, r3, #5
 800468c:	9307      	str	r3, [sp, #28]
  startoff = start % 32U;
 800468e:	9b01      	ldr	r3, [sp, #4]
 8004690:	f003 031f 	and.w	r3, r3, #31
 8004694:	9306      	str	r3, [sp, #24]
  endidx   = end / 32U;
 8004696:	9b02      	ldr	r3, [sp, #8]
 8004698:	095b      	lsrs	r3, r3, #5
 800469a:	9305      	str	r3, [sp, #20]
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;
 800469c:	9b02      	ldr	r3, [sp, #8]
 800469e:	f003 031f 	and.w	r3, r3, #31
 80046a2:	3301      	adds	r3, #1
 80046a4:	2201      	movs	r2, #1
 80046a6:	fa02 f303 	lsl.w	r3, r2, r3
 80046aa:	3b01      	subs	r3, #1
 80046ac:	9304      	str	r3, [sp, #16]

  /* One or two pieces?*/
  if (startidx < endidx) {
 80046ae:	9a07      	ldr	r2, [sp, #28]
 80046b0:	9b05      	ldr	r3, [sp, #20]
 80046b2:	429a      	cmp	r2, r3
 80046b4:	d214      	bcs.n	80046e0 <_mmcsd_get_slice+0x60>
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046b6:	9b07      	ldr	r3, [sp, #28]
 80046b8:	009b      	lsls	r3, r3, #2
 80046ba:	9a03      	ldr	r2, [sp, #12]
 80046bc:	4413      	add	r3, r2
 80046be:	681a      	ldr	r2, [r3, #0]
 80046c0:	9b06      	ldr	r3, [sp, #24]
 80046c2:	40da      	lsrs	r2, r3
           ((data[endidx] & endmask) << (32U - startoff));
 80046c4:	9b05      	ldr	r3, [sp, #20]
 80046c6:	009b      	lsls	r3, r3, #2
 80046c8:	9903      	ldr	r1, [sp, #12]
 80046ca:	440b      	add	r3, r1
 80046cc:	6819      	ldr	r1, [r3, #0]
 80046ce:	9b04      	ldr	r3, [sp, #16]
 80046d0:	4019      	ands	r1, r3
 80046d2:	9b06      	ldr	r3, [sp, #24]
 80046d4:	f1c3 0320 	rsb	r3, r3, #32
 80046d8:	fa01 f303 	lsl.w	r3, r1, r3
  endidx   = end / 32U;
  endmask  = ((uint32_t)1U << ((end % 32U) + 1U)) - 1U;

  /* One or two pieces?*/
  if (startidx < endidx) {
    return (data[startidx] >> startoff) |               /* Two pieces case. */
 80046dc:	4313      	orrs	r3, r2
 80046de:	e009      	b.n	80046f4 <_mmcsd_get_slice+0x74>
           ((data[endidx] & endmask) << (32U - startoff));
  }
  return (data[startidx] & endmask) >> startoff;        /* One piece case.  */
 80046e0:	9b07      	ldr	r3, [sp, #28]
 80046e2:	009b      	lsls	r3, r3, #2
 80046e4:	9a03      	ldr	r2, [sp, #12]
 80046e6:	4413      	add	r3, r2
 80046e8:	681a      	ldr	r2, [r3, #0]
 80046ea:	9b04      	ldr	r3, [sp, #16]
 80046ec:	401a      	ands	r2, r3
 80046ee:	9b06      	ldr	r3, [sp, #24]
 80046f0:	fa22 f303 	lsr.w	r3, r2, r3
}
 80046f4:	4618      	mov	r0, r3
 80046f6:	b008      	add	sp, #32
 80046f8:	4770      	bx	lr
 80046fa:	bf00      	nop
 80046fc:	f3af 8000 	nop.w

08004700 <_mmcsd_get_capacity>:
 * @return              The card capacity.
 * @retval 0            CSD format error
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity(const uint32_t *csd) {
 8004700:	b500      	push	{lr}
 8004702:	b087      	sub	sp, #28
 8004704:	9001      	str	r0, [sp, #4]
  uint32_t a, b, c;

  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 8004706:	9801      	ldr	r0, [sp, #4]
 8004708:	217f      	movs	r1, #127	; 0x7f
 800470a:	227e      	movs	r2, #126	; 0x7e
 800470c:	f7ff ffb8 	bl	8004680 <_mmcsd_get_slice>
 8004710:	4603      	mov	r3, r0
 8004712:	2b00      	cmp	r3, #0
 8004714:	d004      	beq.n	8004720 <_mmcsd_get_capacity+0x20>
 8004716:	2b01      	cmp	r3, #1
 8004718:	d01e      	beq.n	8004758 <_mmcsd_get_capacity+0x58>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
  default:
    /* Reserved value detected.*/
    break;
 800471a:	bf00      	nop
  }
  return 0U;
 800471c:	2300      	movs	r3, #0
 800471e:	e023      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  osalDbgCheck(NULL != csd);

  switch (_mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
  case 0:
    /* CSD version 1.0 */
    a = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004720:	9801      	ldr	r0, [sp, #4]
 8004722:	2149      	movs	r1, #73	; 0x49
 8004724:	223e      	movs	r2, #62	; 0x3e
 8004726:	f7ff ffab 	bl	8004680 <_mmcsd_get_slice>
 800472a:	9005      	str	r0, [sp, #20]
    b = _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 800472c:	9801      	ldr	r0, [sp, #4]
 800472e:	2131      	movs	r1, #49	; 0x31
 8004730:	222f      	movs	r2, #47	; 0x2f
 8004732:	f7ff ffa5 	bl	8004680 <_mmcsd_get_slice>
 8004736:	9004      	str	r0, [sp, #16]
    c = _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004738:	9801      	ldr	r0, [sp, #4]
 800473a:	2153      	movs	r1, #83	; 0x53
 800473c:	2250      	movs	r2, #80	; 0x50
 800473e:	f7ff ff9f 	bl	8004680 <_mmcsd_get_slice>
 8004742:	9003      	str	r0, [sp, #12]
    return ((a + 1U) << (b + 2U)) << (c - 9U);  /* 2^9 == MMCSD_BLOCK_SIZE. */
 8004744:	9b05      	ldr	r3, [sp, #20]
 8004746:	1c5a      	adds	r2, r3, #1
 8004748:	9b04      	ldr	r3, [sp, #16]
 800474a:	3302      	adds	r3, #2
 800474c:	409a      	lsls	r2, r3
 800474e:	9b03      	ldr	r3, [sp, #12]
 8004750:	3b09      	subs	r3, #9
 8004752:	fa02 f303 	lsl.w	r3, r2, r3
 8004756:	e007      	b.n	8004768 <_mmcsd_get_capacity+0x68>
  case 1:
    /* CSD version 2.0.*/
    return 1024U * (_mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE) + 1U);
 8004758:	9801      	ldr	r0, [sp, #4]
 800475a:	2145      	movs	r1, #69	; 0x45
 800475c:	2230      	movs	r2, #48	; 0x30
 800475e:	f7ff ff8f 	bl	8004680 <_mmcsd_get_slice>
 8004762:	4603      	mov	r3, r0
 8004764:	3301      	adds	r3, #1
 8004766:	029b      	lsls	r3, r3, #10
  default:
    /* Reserved value detected.*/
    break;
  }
  return 0U;
}
 8004768:	4618      	mov	r0, r3
 800476a:	b007      	add	sp, #28
 800476c:	f85d fb04 	ldr.w	pc, [sp], #4

08004770 <_mmcsd_get_capacity_ext>:
 *
 * @return              The card capacity.
 *
 * @notapi
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {
 8004770:	b082      	sub	sp, #8
 8004772:	9001      	str	r0, [sp, #4]

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004774:	9b01      	ldr	r3, [sp, #4]
 8004776:	33d7      	adds	r3, #215	; 0xd7
 8004778:	781b      	ldrb	r3, [r3, #0]
 800477a:	061a      	lsls	r2, r3, #24
         ((uint32_t)ext_csd[214] << 16U) +
 800477c:	9b01      	ldr	r3, [sp, #4]
 800477e:	33d6      	adds	r3, #214	; 0xd6
 8004780:	781b      	ldrb	r3, [r3, #0]
 8004782:	041b      	lsls	r3, r3, #16
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004784:	441a      	add	r2, r3
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
 8004786:	9b01      	ldr	r3, [sp, #4]
 8004788:	33d5      	adds	r3, #213	; 0xd5
 800478a:	781b      	ldrb	r3, [r3, #0]
 800478c:	021b      	lsls	r3, r3, #8
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
         ((uint32_t)ext_csd[214] << 16U) +
 800478e:	441a      	add	r2, r3
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
 8004790:	9b01      	ldr	r3, [sp, #4]
 8004792:	33d4      	adds	r3, #212	; 0xd4
 8004794:	781b      	ldrb	r3, [r3, #0]
 */
uint32_t _mmcsd_get_capacity_ext(const uint8_t *ext_csd) {

  osalDbgCheck(NULL != ext_csd);

  return ((uint32_t)ext_csd[215] << 24U) +
 8004796:	4413      	add	r3, r2
         ((uint32_t)ext_csd[214] << 16U) +
         ((uint32_t)ext_csd[213] << 8U)  +
         (uint32_t)ext_csd[212];
}
 8004798:	4618      	mov	r0, r3
 800479a:	b002      	add	sp, #8
 800479c:	4770      	bx	lr
 800479e:	bf00      	nop

080047a0 <_mmcsd_unpack_sdc_cid>:
 * @param[out] cidsdc   pointer to the @p unpacked_sdc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_sdc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_cid_t *cidsdc) {
 80047a0:	b500      	push	{lr}
 80047a2:	b085      	sub	sp, #20
 80047a4:	9001      	str	r0, [sp, #4]
 80047a6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidsdc));

  cid = sdcp->cid;
 80047a8:	9b01      	ldr	r3, [sp, #4]
 80047aa:	3308      	adds	r3, #8
 80047ac:	9303      	str	r3, [sp, #12]
  cidsdc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_CRC_SLICE);
 80047ae:	9803      	ldr	r0, [sp, #12]
 80047b0:	2107      	movs	r1, #7
 80047b2:	2201      	movs	r2, #1
 80047b4:	f7ff ff64 	bl	8004680 <_mmcsd_get_slice>
 80047b8:	4603      	mov	r3, r0
 80047ba:	b2da      	uxtb	r2, r3
 80047bc:	9b00      	ldr	r3, [sp, #0]
 80047be:	751a      	strb	r2, [r3, #20]
  cidsdc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_Y_SLICE) +
 80047c0:	9803      	ldr	r0, [sp, #12]
 80047c2:	2113      	movs	r1, #19
 80047c4:	220c      	movs	r2, #12
 80047c6:	f7ff ff5b 	bl	8004680 <_mmcsd_get_slice>
 80047ca:	4603      	mov	r3, r0
 80047cc:	b29b      	uxth	r3, r3
 80047ce:	f503 63fa 	add.w	r3, r3, #2000	; 0x7d0
 80047d2:	b29a      	uxth	r2, r3
 80047d4:	9b00      	ldr	r3, [sp, #0]
 80047d6:	825a      	strh	r2, [r3, #18]
                             2000U;
  cidsdc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MDT_M_SLICE);
 80047d8:	9803      	ldr	r0, [sp, #12]
 80047da:	210b      	movs	r1, #11
 80047dc:	2208      	movs	r2, #8
 80047de:	f7ff ff4f 	bl	8004680 <_mmcsd_get_slice>
 80047e2:	4603      	mov	r3, r0
 80047e4:	b2da      	uxtb	r2, r3
 80047e6:	9b00      	ldr	r3, [sp, #0]
 80047e8:	741a      	strb	r2, [r3, #16]
  cidsdc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_MID_SLICE);
 80047ea:	9803      	ldr	r0, [sp, #12]
 80047ec:	217f      	movs	r1, #127	; 0x7f
 80047ee:	2278      	movs	r2, #120	; 0x78
 80047f0:	f7ff ff46 	bl	8004680 <_mmcsd_get_slice>
 80047f4:	4603      	mov	r3, r0
 80047f6:	b2da      	uxtb	r2, r3
 80047f8:	9b00      	ldr	r3, [sp, #0]
 80047fa:	701a      	strb	r2, [r3, #0]
  cidsdc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_SDC_OID_SLICE);
 80047fc:	9803      	ldr	r0, [sp, #12]
 80047fe:	2177      	movs	r1, #119	; 0x77
 8004800:	2268      	movs	r2, #104	; 0x68
 8004802:	f7ff ff3d 	bl	8004680 <_mmcsd_get_slice>
 8004806:	4603      	mov	r3, r0
 8004808:	b29a      	uxth	r2, r3
 800480a:	9b00      	ldr	r3, [sp, #0]
 800480c:	805a      	strh	r2, [r3, #2]
  cidsdc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM0_SLICE);
 800480e:	9803      	ldr	r0, [sp, #12]
 8004810:	2147      	movs	r1, #71	; 0x47
 8004812:	2240      	movs	r2, #64	; 0x40
 8004814:	f7ff ff34 	bl	8004680 <_mmcsd_get_slice>
 8004818:	4603      	mov	r3, r0
 800481a:	b2da      	uxtb	r2, r3
 800481c:	9b00      	ldr	r3, [sp, #0]
 800481e:	721a      	strb	r2, [r3, #8]
  cidsdc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM1_SLICE);
 8004820:	9803      	ldr	r0, [sp, #12]
 8004822:	214f      	movs	r1, #79	; 0x4f
 8004824:	2248      	movs	r2, #72	; 0x48
 8004826:	f7ff ff2b 	bl	8004680 <_mmcsd_get_slice>
 800482a:	4603      	mov	r3, r0
 800482c:	b2da      	uxtb	r2, r3
 800482e:	9b00      	ldr	r3, [sp, #0]
 8004830:	71da      	strb	r2, [r3, #7]
  cidsdc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM2_SLICE);
 8004832:	9803      	ldr	r0, [sp, #12]
 8004834:	2157      	movs	r1, #87	; 0x57
 8004836:	2250      	movs	r2, #80	; 0x50
 8004838:	f7ff ff22 	bl	8004680 <_mmcsd_get_slice>
 800483c:	4603      	mov	r3, r0
 800483e:	b2da      	uxtb	r2, r3
 8004840:	9b00      	ldr	r3, [sp, #0]
 8004842:	719a      	strb	r2, [r3, #6]
  cidsdc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM3_SLICE);
 8004844:	9803      	ldr	r0, [sp, #12]
 8004846:	215f      	movs	r1, #95	; 0x5f
 8004848:	2258      	movs	r2, #88	; 0x58
 800484a:	f7ff ff19 	bl	8004680 <_mmcsd_get_slice>
 800484e:	4603      	mov	r3, r0
 8004850:	b2da      	uxtb	r2, r3
 8004852:	9b00      	ldr	r3, [sp, #0]
 8004854:	715a      	strb	r2, [r3, #5]
  cidsdc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_SDC_PNM4_SLICE);
 8004856:	9803      	ldr	r0, [sp, #12]
 8004858:	2167      	movs	r1, #103	; 0x67
 800485a:	2260      	movs	r2, #96	; 0x60
 800485c:	f7ff ff10 	bl	8004680 <_mmcsd_get_slice>
 8004860:	4603      	mov	r3, r0
 8004862:	b2da      	uxtb	r2, r3
 8004864:	9b00      	ldr	r3, [sp, #0]
 8004866:	711a      	strb	r2, [r3, #4]
  cidsdc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_N_SLICE);
 8004868:	9803      	ldr	r0, [sp, #12]
 800486a:	213f      	movs	r1, #63	; 0x3f
 800486c:	223c      	movs	r2, #60	; 0x3c
 800486e:	f7ff ff07 	bl	8004680 <_mmcsd_get_slice>
 8004872:	4603      	mov	r3, r0
 8004874:	b2da      	uxtb	r2, r3
 8004876:	9b00      	ldr	r3, [sp, #0]
 8004878:	725a      	strb	r2, [r3, #9]
  cidsdc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_SDC_PRV_M_SLICE);
 800487a:	9803      	ldr	r0, [sp, #12]
 800487c:	213b      	movs	r1, #59	; 0x3b
 800487e:	2238      	movs	r2, #56	; 0x38
 8004880:	f7ff fefe 	bl	8004680 <_mmcsd_get_slice>
 8004884:	4603      	mov	r3, r0
 8004886:	b2da      	uxtb	r2, r3
 8004888:	9b00      	ldr	r3, [sp, #0]
 800488a:	729a      	strb	r2, [r3, #10]
  cidsdc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_SDC_PSN_SLICE);
 800488c:	9803      	ldr	r0, [sp, #12]
 800488e:	2137      	movs	r1, #55	; 0x37
 8004890:	2218      	movs	r2, #24
 8004892:	f7ff fef5 	bl	8004680 <_mmcsd_get_slice>
 8004896:	4602      	mov	r2, r0
 8004898:	9b00      	ldr	r3, [sp, #0]
 800489a:	60da      	str	r2, [r3, #12]
}
 800489c:	b005      	add	sp, #20
 800489e:	f85d fb04 	ldr.w	pc, [sp], #4
 80048a2:	bf00      	nop
 80048a4:	f3af 8000 	nop.w
 80048a8:	f3af 8000 	nop.w
 80048ac:	f3af 8000 	nop.w

080048b0 <_mmcsd_unpack_mmc_cid>:
 * @param[out] cidmmc   pointer to the @p unpacked_mmc_cid_t object
 *
 * @notapi
 */
void _mmcsd_unpack_mmc_cid(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_cid_t *cidmmc) {
 80048b0:	b500      	push	{lr}
 80048b2:	b085      	sub	sp, #20
 80048b4:	9001      	str	r0, [sp, #4]
 80048b6:	9100      	str	r1, [sp, #0]
  const uint32_t *cid;

  osalDbgCheck((NULL != sdcp) && (NULL != cidmmc));

  cid = sdcp->cid;
 80048b8:	9b01      	ldr	r3, [sp, #4]
 80048ba:	3308      	adds	r3, #8
 80048bc:	9303      	str	r3, [sp, #12]
  cidmmc->crc    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_CRC_SLICE);
 80048be:	9803      	ldr	r0, [sp, #12]
 80048c0:	2107      	movs	r1, #7
 80048c2:	2201      	movs	r2, #1
 80048c4:	f7ff fedc 	bl	8004680 <_mmcsd_get_slice>
 80048c8:	4603      	mov	r3, r0
 80048ca:	b2da      	uxtb	r2, r3
 80048cc:	9b00      	ldr	r3, [sp, #0]
 80048ce:	751a      	strb	r2, [r3, #20]
  cidmmc->mdt_y  = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_Y_SLICE) +
 80048d0:	9803      	ldr	r0, [sp, #12]
 80048d2:	210b      	movs	r1, #11
 80048d4:	2208      	movs	r2, #8
 80048d6:	f7ff fed3 	bl	8004680 <_mmcsd_get_slice>
 80048da:	4603      	mov	r3, r0
 80048dc:	b29b      	uxth	r3, r3
 80048de:	f203 73cd 	addw	r3, r3, #1997	; 0x7cd
 80048e2:	b29a      	uxth	r2, r3
 80048e4:	9b00      	ldr	r3, [sp, #0]
 80048e6:	825a      	strh	r2, [r3, #18]
                             1997U;
  cidmmc->mdt_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MDT_M_SLICE);
 80048e8:	9803      	ldr	r0, [sp, #12]
 80048ea:	210f      	movs	r1, #15
 80048ec:	220c      	movs	r2, #12
 80048ee:	f7ff fec7 	bl	8004680 <_mmcsd_get_slice>
 80048f2:	4603      	mov	r3, r0
 80048f4:	b2da      	uxtb	r2, r3
 80048f6:	9b00      	ldr	r3, [sp, #0]
 80048f8:	741a      	strb	r2, [r3, #16]
  cidmmc->mid    = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_MID_SLICE);
 80048fa:	9803      	ldr	r0, [sp, #12]
 80048fc:	217f      	movs	r1, #127	; 0x7f
 80048fe:	2278      	movs	r2, #120	; 0x78
 8004900:	f7ff febe 	bl	8004680 <_mmcsd_get_slice>
 8004904:	4603      	mov	r3, r0
 8004906:	b2da      	uxtb	r2, r3
 8004908:	9b00      	ldr	r3, [sp, #0]
 800490a:	701a      	strb	r2, [r3, #0]
  cidmmc->oid    = (uint16_t)_mmcsd_get_slice(cid, MMCSD_CID_MMC_OID_SLICE);
 800490c:	9803      	ldr	r0, [sp, #12]
 800490e:	2177      	movs	r1, #119	; 0x77
 8004910:	2268      	movs	r2, #104	; 0x68
 8004912:	f7ff feb5 	bl	8004680 <_mmcsd_get_slice>
 8004916:	4603      	mov	r3, r0
 8004918:	b29a      	uxth	r2, r3
 800491a:	9b00      	ldr	r3, [sp, #0]
 800491c:	805a      	strh	r2, [r3, #2]
  cidmmc->pnm[5] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM0_SLICE);
 800491e:	9803      	ldr	r0, [sp, #12]
 8004920:	213f      	movs	r1, #63	; 0x3f
 8004922:	2238      	movs	r2, #56	; 0x38
 8004924:	f7ff feac 	bl	8004680 <_mmcsd_get_slice>
 8004928:	4603      	mov	r3, r0
 800492a:	b2da      	uxtb	r2, r3
 800492c:	9b00      	ldr	r3, [sp, #0]
 800492e:	725a      	strb	r2, [r3, #9]
  cidmmc->pnm[4] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM1_SLICE);
 8004930:	9803      	ldr	r0, [sp, #12]
 8004932:	2147      	movs	r1, #71	; 0x47
 8004934:	2240      	movs	r2, #64	; 0x40
 8004936:	f7ff fea3 	bl	8004680 <_mmcsd_get_slice>
 800493a:	4603      	mov	r3, r0
 800493c:	b2da      	uxtb	r2, r3
 800493e:	9b00      	ldr	r3, [sp, #0]
 8004940:	721a      	strb	r2, [r3, #8]
  cidmmc->pnm[3] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM2_SLICE);
 8004942:	9803      	ldr	r0, [sp, #12]
 8004944:	214f      	movs	r1, #79	; 0x4f
 8004946:	2248      	movs	r2, #72	; 0x48
 8004948:	f7ff fe9a 	bl	8004680 <_mmcsd_get_slice>
 800494c:	4603      	mov	r3, r0
 800494e:	b2da      	uxtb	r2, r3
 8004950:	9b00      	ldr	r3, [sp, #0]
 8004952:	71da      	strb	r2, [r3, #7]
  cidmmc->pnm[2] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM3_SLICE);
 8004954:	9803      	ldr	r0, [sp, #12]
 8004956:	2157      	movs	r1, #87	; 0x57
 8004958:	2250      	movs	r2, #80	; 0x50
 800495a:	f7ff fe91 	bl	8004680 <_mmcsd_get_slice>
 800495e:	4603      	mov	r3, r0
 8004960:	b2da      	uxtb	r2, r3
 8004962:	9b00      	ldr	r3, [sp, #0]
 8004964:	719a      	strb	r2, [r3, #6]
  cidmmc->pnm[1] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM4_SLICE);
 8004966:	9803      	ldr	r0, [sp, #12]
 8004968:	215f      	movs	r1, #95	; 0x5f
 800496a:	2258      	movs	r2, #88	; 0x58
 800496c:	f7ff fe88 	bl	8004680 <_mmcsd_get_slice>
 8004970:	4603      	mov	r3, r0
 8004972:	b2da      	uxtb	r2, r3
 8004974:	9b00      	ldr	r3, [sp, #0]
 8004976:	715a      	strb	r2, [r3, #5]
  cidmmc->pnm[0] = (char)    _mmcsd_get_slice(cid, MMCSD_CID_MMC_PNM5_SLICE);
 8004978:	9803      	ldr	r0, [sp, #12]
 800497a:	2167      	movs	r1, #103	; 0x67
 800497c:	2260      	movs	r2, #96	; 0x60
 800497e:	f7ff fe7f 	bl	8004680 <_mmcsd_get_slice>
 8004982:	4603      	mov	r3, r0
 8004984:	b2da      	uxtb	r2, r3
 8004986:	9b00      	ldr	r3, [sp, #0]
 8004988:	711a      	strb	r2, [r3, #4]
  cidmmc->prv_n  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_N_SLICE);
 800498a:	9803      	ldr	r0, [sp, #12]
 800498c:	2137      	movs	r1, #55	; 0x37
 800498e:	2234      	movs	r2, #52	; 0x34
 8004990:	f7ff fe76 	bl	8004680 <_mmcsd_get_slice>
 8004994:	4603      	mov	r3, r0
 8004996:	b2da      	uxtb	r2, r3
 8004998:	9b00      	ldr	r3, [sp, #0]
 800499a:	729a      	strb	r2, [r3, #10]
  cidmmc->prv_m  = (uint8_t) _mmcsd_get_slice(cid, MMCSD_CID_MMC_PRV_M_SLICE);
 800499c:	9803      	ldr	r0, [sp, #12]
 800499e:	2133      	movs	r1, #51	; 0x33
 80049a0:	2230      	movs	r2, #48	; 0x30
 80049a2:	f7ff fe6d 	bl	8004680 <_mmcsd_get_slice>
 80049a6:	4603      	mov	r3, r0
 80049a8:	b2da      	uxtb	r2, r3
 80049aa:	9b00      	ldr	r3, [sp, #0]
 80049ac:	72da      	strb	r2, [r3, #11]
  cidmmc->psn    =           _mmcsd_get_slice(cid, MMCSD_CID_MMC_PSN_SLICE);
 80049ae:	9803      	ldr	r0, [sp, #12]
 80049b0:	212f      	movs	r1, #47	; 0x2f
 80049b2:	2210      	movs	r2, #16
 80049b4:	f7ff fe64 	bl	8004680 <_mmcsd_get_slice>
 80049b8:	4602      	mov	r2, r0
 80049ba:	9b00      	ldr	r3, [sp, #0]
 80049bc:	60da      	str	r2, [r3, #12]
}
 80049be:	b005      	add	sp, #20
 80049c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80049c4:	f3af 8000 	nop.w
 80049c8:	f3af 8000 	nop.w
 80049cc:	f3af 8000 	nop.w

080049d0 <_mmcsd_unpack_csd_mmc>:
 * @param[out] csdmmc   pointer to the @p unpacked_mmc_csd_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_mmc(const MMCSDBlockDevice *sdcp,
                           unpacked_mmc_csd_t *csdmmc) {
 80049d0:	b500      	push	{lr}
 80049d2:	b085      	sub	sp, #20
 80049d4:	9001      	str	r0, [sp, #4]
 80049d6:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck((NULL != sdcp) && (NULL != csdmmc));

  csd = sdcp->csd;
 80049d8:	9b01      	ldr	r3, [sp, #4]
 80049da:	3318      	adds	r3, #24
 80049dc:	9303      	str	r3, [sp, #12]
  csdmmc->c_size             = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_SLICE);
 80049de:	9803      	ldr	r0, [sp, #12]
 80049e0:	2149      	movs	r1, #73	; 0x49
 80049e2:	223e      	movs	r2, #62	; 0x3e
 80049e4:	f7ff fe4c 	bl	8004680 <_mmcsd_get_slice>
 80049e8:	4603      	mov	r3, r0
 80049ea:	b29a      	uxth	r2, r3
 80049ec:	9b00      	ldr	r3, [sp, #0]
 80049ee:	81da      	strh	r2, [r3, #14]
  csdmmc->c_size_mult        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_C_SIZE_MULT_SLICE);
 80049f0:	9803      	ldr	r0, [sp, #12]
 80049f2:	2131      	movs	r1, #49	; 0x31
 80049f4:	222f      	movs	r2, #47	; 0x2f
 80049f6:	f7ff fe43 	bl	8004680 <_mmcsd_get_slice>
 80049fa:	4603      	mov	r3, r0
 80049fc:	b2da      	uxtb	r2, r3
 80049fe:	9b00      	ldr	r3, [sp, #0]
 8004a00:	751a      	strb	r2, [r3, #20]
  csdmmc->ccc                = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_MMC_CCC_SLICE);
 8004a02:	9803      	ldr	r0, [sp, #12]
 8004a04:	215f      	movs	r1, #95	; 0x5f
 8004a06:	2254      	movs	r2, #84	; 0x54
 8004a08:	f7ff fe3a 	bl	8004680 <_mmcsd_get_slice>
 8004a0c:	4603      	mov	r3, r0
 8004a0e:	b29a      	uxth	r2, r3
 8004a10:	9b00      	ldr	r3, [sp, #0]
 8004a12:	80da      	strh	r2, [r3, #6]
  csdmmc->copy               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_COPY_SLICE);
 8004a14:	9803      	ldr	r0, [sp, #12]
 8004a16:	210e      	movs	r1, #14
 8004a18:	220e      	movs	r2, #14
 8004a1a:	f7ff fe31 	bl	8004680 <_mmcsd_get_slice>
 8004a1e:	4603      	mov	r3, r0
 8004a20:	b2da      	uxtb	r2, r3
 8004a22:	9b00      	ldr	r3, [sp, #0]
 8004a24:	77da      	strb	r2, [r3, #31]
  csdmmc->crc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CRC_SLICE);
 8004a26:	9803      	ldr	r0, [sp, #12]
 8004a28:	2107      	movs	r1, #7
 8004a2a:	2201      	movs	r2, #1
 8004a2c:	f7ff fe28 	bl	8004680 <_mmcsd_get_slice>
 8004a30:	4603      	mov	r3, r0
 8004a32:	b2da      	uxtb	r2, r3
 8004a34:	9b00      	ldr	r3, [sp, #0]
 8004a36:	f883 2024 	strb.w	r2, [r3, #36]	; 0x24
  csdmmc->csd_structure      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE);
 8004a3a:	9803      	ldr	r0, [sp, #12]
 8004a3c:	217f      	movs	r1, #127	; 0x7f
 8004a3e:	227e      	movs	r2, #126	; 0x7e
 8004a40:	f7ff fe1e 	bl	8004680 <_mmcsd_get_slice>
 8004a44:	4603      	mov	r3, r0
 8004a46:	b2da      	uxtb	r2, r3
 8004a48:	9b00      	ldr	r3, [sp, #0]
 8004a4a:	701a      	strb	r2, [r3, #0]
  csdmmc->dsr_imp            = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_DSR_IMP_SLICE);
 8004a4c:	9803      	ldr	r0, [sp, #12]
 8004a4e:	214c      	movs	r1, #76	; 0x4c
 8004a50:	224c      	movs	r2, #76	; 0x4c
 8004a52:	f7ff fe15 	bl	8004680 <_mmcsd_get_slice>
 8004a56:	4603      	mov	r3, r0
 8004a58:	b2da      	uxtb	r2, r3
 8004a5a:	9b00      	ldr	r3, [sp, #0]
 8004a5c:	731a      	strb	r2, [r3, #12]
  csdmmc->ecc                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ECC_SLICE);
 8004a5e:	9803      	ldr	r0, [sp, #12]
 8004a60:	2109      	movs	r1, #9
 8004a62:	2208      	movs	r2, #8
 8004a64:	f7ff fe0c 	bl	8004680 <_mmcsd_get_slice>
 8004a68:	4603      	mov	r3, r0
 8004a6a:	b2da      	uxtb	r2, r3
 8004a6c:	9b00      	ldr	r3, [sp, #0]
 8004a6e:	f883 2023 	strb.w	r2, [r3, #35]	; 0x23
  csdmmc->erase_grp_mult     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_MULT_SLICE);
 8004a72:	9803      	ldr	r0, [sp, #12]
 8004a74:	2129      	movs	r1, #41	; 0x29
 8004a76:	2225      	movs	r2, #37	; 0x25
 8004a78:	f7ff fe02 	bl	8004680 <_mmcsd_get_slice>
 8004a7c:	4603      	mov	r3, r0
 8004a7e:	b2da      	uxtb	r2, r3
 8004a80:	9b00      	ldr	r3, [sp, #0]
 8004a82:	759a      	strb	r2, [r3, #22]
  csdmmc->erase_grp_size     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_ERASE_GRP_SIZE_SLICE);
 8004a84:	9803      	ldr	r0, [sp, #12]
 8004a86:	212e      	movs	r1, #46	; 0x2e
 8004a88:	222a      	movs	r2, #42	; 0x2a
 8004a8a:	f7ff fdf9 	bl	8004680 <_mmcsd_get_slice>
 8004a8e:	4603      	mov	r3, r0
 8004a90:	b2da      	uxtb	r2, r3
 8004a92:	9b00      	ldr	r3, [sp, #0]
 8004a94:	755a      	strb	r2, [r3, #21]
  csdmmc->file_format        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_SLICE);
 8004a96:	9803      	ldr	r0, [sp, #12]
 8004a98:	210b      	movs	r1, #11
 8004a9a:	220a      	movs	r2, #10
 8004a9c:	f7ff fdf0 	bl	8004680 <_mmcsd_get_slice>
 8004aa0:	4603      	mov	r3, r0
 8004aa2:	b2da      	uxtb	r2, r3
 8004aa4:	9b00      	ldr	r3, [sp, #0]
 8004aa6:	f883 2022 	strb.w	r2, [r3, #34]	; 0x22
  csdmmc->file_format_grp    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_FILE_FORMAT_GRP_SLICE);
 8004aaa:	9803      	ldr	r0, [sp, #12]
 8004aac:	210f      	movs	r1, #15
 8004aae:	220f      	movs	r2, #15
 8004ab0:	f7ff fde6 	bl	8004680 <_mmcsd_get_slice>
 8004ab4:	4603      	mov	r3, r0
 8004ab6:	b2da      	uxtb	r2, r3
 8004ab8:	9b00      	ldr	r3, [sp, #0]
 8004aba:	779a      	strb	r2, [r3, #30]
  csdmmc->nsac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_NSAC_SLICE);
 8004abc:	9803      	ldr	r0, [sp, #12]
 8004abe:	216f      	movs	r1, #111	; 0x6f
 8004ac0:	2268      	movs	r2, #104	; 0x68
 8004ac2:	f7ff fddd 	bl	8004680 <_mmcsd_get_slice>
 8004ac6:	4603      	mov	r3, r0
 8004ac8:	b2da      	uxtb	r2, r3
 8004aca:	9b00      	ldr	r3, [sp, #0]
 8004acc:	70da      	strb	r2, [r3, #3]
  csdmmc->perm_write_protect = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_PERM_WRITE_PROTECT_SLICE);
 8004ace:	9803      	ldr	r0, [sp, #12]
 8004ad0:	210d      	movs	r1, #13
 8004ad2:	220d      	movs	r2, #13
 8004ad4:	f7ff fdd4 	bl	8004680 <_mmcsd_get_slice>
 8004ad8:	4603      	mov	r3, r0
 8004ada:	b2da      	uxtb	r2, r3
 8004adc:	9b00      	ldr	r3, [sp, #0]
 8004ade:	f883 2020 	strb.w	r2, [r3, #32]
  csdmmc->r2w_factor         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_R2W_FACTOR_SLICE);
 8004ae2:	9803      	ldr	r0, [sp, #12]
 8004ae4:	211c      	movs	r1, #28
 8004ae6:	221a      	movs	r2, #26
 8004ae8:	f7ff fdca 	bl	8004680 <_mmcsd_get_slice>
 8004aec:	4603      	mov	r3, r0
 8004aee:	b2da      	uxtb	r2, r3
 8004af0:	9b00      	ldr	r3, [sp, #0]
 8004af2:	769a      	strb	r2, [r3, #26]
  csdmmc->read_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_LEN_SLICE);
 8004af4:	9803      	ldr	r0, [sp, #12]
 8004af6:	2153      	movs	r1, #83	; 0x53
 8004af8:	2250      	movs	r2, #80	; 0x50
 8004afa:	f7ff fdc1 	bl	8004680 <_mmcsd_get_slice>
 8004afe:	4603      	mov	r3, r0
 8004b00:	b2da      	uxtb	r2, r3
 8004b02:	9b00      	ldr	r3, [sp, #0]
 8004b04:	721a      	strb	r2, [r3, #8]
  csdmmc->read_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BL_PARTIAL_SLICE);
 8004b06:	9803      	ldr	r0, [sp, #12]
 8004b08:	214f      	movs	r1, #79	; 0x4f
 8004b0a:	224f      	movs	r2, #79	; 0x4f
 8004b0c:	f7ff fdb8 	bl	8004680 <_mmcsd_get_slice>
 8004b10:	4603      	mov	r3, r0
 8004b12:	b2da      	uxtb	r2, r3
 8004b14:	9b00      	ldr	r3, [sp, #0]
 8004b16:	725a      	strb	r2, [r3, #9]
  csdmmc->read_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_READ_BLK_MISALIGN_SLICE);
 8004b18:	9803      	ldr	r0, [sp, #12]
 8004b1a:	214d      	movs	r1, #77	; 0x4d
 8004b1c:	224d      	movs	r2, #77	; 0x4d
 8004b1e:	f7ff fdaf 	bl	8004680 <_mmcsd_get_slice>
 8004b22:	4603      	mov	r3, r0
 8004b24:	b2da      	uxtb	r2, r3
 8004b26:	9b00      	ldr	r3, [sp, #0]
 8004b28:	72da      	strb	r2, [r3, #11]
  csdmmc->spec_vers          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_SPEC_VERS_SLICE);
 8004b2a:	9803      	ldr	r0, [sp, #12]
 8004b2c:	217d      	movs	r1, #125	; 0x7d
 8004b2e:	227a      	movs	r2, #122	; 0x7a
 8004b30:	f7ff fda6 	bl	8004680 <_mmcsd_get_slice>
 8004b34:	4603      	mov	r3, r0
 8004b36:	b2da      	uxtb	r2, r3
 8004b38:	9b00      	ldr	r3, [sp, #0]
 8004b3a:	705a      	strb	r2, [r3, #1]
  csdmmc->taac               = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TAAC_SLICE);
 8004b3c:	9803      	ldr	r0, [sp, #12]
 8004b3e:	2177      	movs	r1, #119	; 0x77
 8004b40:	2270      	movs	r2, #112	; 0x70
 8004b42:	f7ff fd9d 	bl	8004680 <_mmcsd_get_slice>
 8004b46:	4603      	mov	r3, r0
 8004b48:	b2da      	uxtb	r2, r3
 8004b4a:	9b00      	ldr	r3, [sp, #0]
 8004b4c:	709a      	strb	r2, [r3, #2]
  csdmmc->tmp_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TMP_WRITE_PROTECT_SLICE);
 8004b4e:	9803      	ldr	r0, [sp, #12]
 8004b50:	210c      	movs	r1, #12
 8004b52:	220c      	movs	r2, #12
 8004b54:	f7ff fd94 	bl	8004680 <_mmcsd_get_slice>
 8004b58:	4603      	mov	r3, r0
 8004b5a:	b2da      	uxtb	r2, r3
 8004b5c:	9b00      	ldr	r3, [sp, #0]
 8004b5e:	f883 2021 	strb.w	r2, [r3, #33]	; 0x21
  csdmmc->tran_speed         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_TRAN_SPEED_SLICE);
 8004b62:	9803      	ldr	r0, [sp, #12]
 8004b64:	2167      	movs	r1, #103	; 0x67
 8004b66:	2260      	movs	r2, #96	; 0x60
 8004b68:	f7ff fd8a 	bl	8004680 <_mmcsd_get_slice>
 8004b6c:	4603      	mov	r3, r0
 8004b6e:	b2da      	uxtb	r2, r3
 8004b70:	9b00      	ldr	r3, [sp, #0]
 8004b72:	711a      	strb	r2, [r3, #4]
  csdmmc->vdd_r_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MAX_SLICE);
 8004b74:	9803      	ldr	r0, [sp, #12]
 8004b76:	213a      	movs	r1, #58	; 0x3a
 8004b78:	2238      	movs	r2, #56	; 0x38
 8004b7a:	f7ff fd81 	bl	8004680 <_mmcsd_get_slice>
 8004b7e:	4603      	mov	r3, r0
 8004b80:	b2da      	uxtb	r2, r3
 8004b82:	9b00      	ldr	r3, [sp, #0]
 8004b84:	745a      	strb	r2, [r3, #17]
  csdmmc->vdd_r_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_R_CURR_MIN_SLICE);
 8004b86:	9803      	ldr	r0, [sp, #12]
 8004b88:	213d      	movs	r1, #61	; 0x3d
 8004b8a:	223b      	movs	r2, #59	; 0x3b
 8004b8c:	f7ff fd78 	bl	8004680 <_mmcsd_get_slice>
 8004b90:	4603      	mov	r3, r0
 8004b92:	b2da      	uxtb	r2, r3
 8004b94:	9b00      	ldr	r3, [sp, #0]
 8004b96:	741a      	strb	r2, [r3, #16]
  csdmmc->vdd_w_curr_max     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MAX_SLICE);
 8004b98:	9803      	ldr	r0, [sp, #12]
 8004b9a:	2134      	movs	r1, #52	; 0x34
 8004b9c:	2232      	movs	r2, #50	; 0x32
 8004b9e:	f7ff fd6f 	bl	8004680 <_mmcsd_get_slice>
 8004ba2:	4603      	mov	r3, r0
 8004ba4:	b2da      	uxtb	r2, r3
 8004ba6:	9b00      	ldr	r3, [sp, #0]
 8004ba8:	74da      	strb	r2, [r3, #19]
  csdmmc->vdd_w_curr_min     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_VDD_W_CURR_MIN_SLICE);
 8004baa:	9803      	ldr	r0, [sp, #12]
 8004bac:	2137      	movs	r1, #55	; 0x37
 8004bae:	2235      	movs	r2, #53	; 0x35
 8004bb0:	f7ff fd66 	bl	8004680 <_mmcsd_get_slice>
 8004bb4:	4603      	mov	r3, r0
 8004bb6:	b2da      	uxtb	r2, r3
 8004bb8:	9b00      	ldr	r3, [sp, #0]
 8004bba:	749a      	strb	r2, [r3, #18]
  csdmmc->wp_grp_enable      = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_ENABLE_SLICE);
 8004bbc:	9803      	ldr	r0, [sp, #12]
 8004bbe:	211f      	movs	r1, #31
 8004bc0:	221f      	movs	r2, #31
 8004bc2:	f7ff fd5d 	bl	8004680 <_mmcsd_get_slice>
 8004bc6:	4603      	mov	r3, r0
 8004bc8:	b2da      	uxtb	r2, r3
 8004bca:	9b00      	ldr	r3, [sp, #0]
 8004bcc:	761a      	strb	r2, [r3, #24]
  csdmmc->wp_grp_size        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WP_GRP_SIZE_SLICE);
 8004bce:	9803      	ldr	r0, [sp, #12]
 8004bd0:	2124      	movs	r1, #36	; 0x24
 8004bd2:	2220      	movs	r2, #32
 8004bd4:	f7ff fd54 	bl	8004680 <_mmcsd_get_slice>
 8004bd8:	4603      	mov	r3, r0
 8004bda:	b2da      	uxtb	r2, r3
 8004bdc:	9b00      	ldr	r3, [sp, #0]
 8004bde:	75da      	strb	r2, [r3, #23]
  csdmmc->write_bl_len       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_LEN_SLICE);
 8004be0:	9803      	ldr	r0, [sp, #12]
 8004be2:	2119      	movs	r1, #25
 8004be4:	2216      	movs	r2, #22
 8004be6:	f7ff fd4b 	bl	8004680 <_mmcsd_get_slice>
 8004bea:	4603      	mov	r3, r0
 8004bec:	b2da      	uxtb	r2, r3
 8004bee:	9b00      	ldr	r3, [sp, #0]
 8004bf0:	76da      	strb	r2, [r3, #27]
  csdmmc->write_bl_partial   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BL_PARTIAL_SLICE);
 8004bf2:	9803      	ldr	r0, [sp, #12]
 8004bf4:	2115      	movs	r1, #21
 8004bf6:	2215      	movs	r2, #21
 8004bf8:	f7ff fd42 	bl	8004680 <_mmcsd_get_slice>
 8004bfc:	4603      	mov	r3, r0
 8004bfe:	b2da      	uxtb	r2, r3
 8004c00:	9b00      	ldr	r3, [sp, #0]
 8004c02:	771a      	strb	r2, [r3, #28]
  csdmmc->write_blk_misalign = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_MMC_WRITE_BLK_MISALIGN_SLICE);
 8004c04:	9803      	ldr	r0, [sp, #12]
 8004c06:	214e      	movs	r1, #78	; 0x4e
 8004c08:	224e      	movs	r2, #78	; 0x4e
 8004c0a:	f7ff fd39 	bl	8004680 <_mmcsd_get_slice>
 8004c0e:	4603      	mov	r3, r0
 8004c10:	b2da      	uxtb	r2, r3
 8004c12:	9b00      	ldr	r3, [sp, #0]
 8004c14:	729a      	strb	r2, [r3, #10]
}
 8004c16:	b005      	add	sp, #20
 8004c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8004c1c:	f3af 8000 	nop.w

08004c20 <_mmcsd_unpack_csd_v10>:
 * @param[out] csd10    pointer to the @p unpacked_sdc_csd_10_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v10(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_10_t *csd10) {
 8004c20:	b500      	push	{lr}
 8004c22:	b085      	sub	sp, #20
 8004c24:	9001      	str	r0, [sp, #4]
 8004c26:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004c28:	9b01      	ldr	r3, [sp, #4]
 8004c2a:	3318      	adds	r3, #24
 8004c2c:	9303      	str	r3, [sp, #12]
  csd10->c_size              = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_SLICE);
 8004c2e:	9803      	ldr	r0, [sp, #12]
 8004c30:	2149      	movs	r1, #73	; 0x49
 8004c32:	223e      	movs	r2, #62	; 0x3e
 8004c34:	f7ff fd24 	bl	8004680 <_mmcsd_get_slice>
 8004c38:	4603      	mov	r3, r0
 8004c3a:	b29a      	uxth	r2, r3
 8004c3c:	9b00      	ldr	r3, [sp, #0]
 8004c3e:	819a      	strh	r2, [r3, #12]
  csd10->c_size_mult         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_C_SIZE_MULT_SLICE);
 8004c40:	9803      	ldr	r0, [sp, #12]
 8004c42:	2131      	movs	r1, #49	; 0x31
 8004c44:	222f      	movs	r2, #47	; 0x2f
 8004c46:	f7ff fd1b 	bl	8004680 <_mmcsd_get_slice>
 8004c4a:	4603      	mov	r3, r0
 8004c4c:	b2da      	uxtb	r2, r3
 8004c4e:	9b00      	ldr	r3, [sp, #0]
 8004c50:	749a      	strb	r2, [r3, #18]
  csd10->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_10_CCC_SLICE);
 8004c52:	9803      	ldr	r0, [sp, #12]
 8004c54:	215f      	movs	r1, #95	; 0x5f
 8004c56:	2254      	movs	r2, #84	; 0x54
 8004c58:	f7ff fd12 	bl	8004680 <_mmcsd_get_slice>
 8004c5c:	4603      	mov	r3, r0
 8004c5e:	b29a      	uxth	r2, r3
 8004c60:	9b00      	ldr	r3, [sp, #0]
 8004c62:	809a      	strh	r2, [r3, #4]
  csd10->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_COPY_SLICE);
 8004c64:	9803      	ldr	r0, [sp, #12]
 8004c66:	210e      	movs	r1, #14
 8004c68:	220e      	movs	r2, #14
 8004c6a:	f7ff fd09 	bl	8004680 <_mmcsd_get_slice>
 8004c6e:	4603      	mov	r3, r0
 8004c70:	b2da      	uxtb	r2, r3
 8004c72:	9b00      	ldr	r3, [sp, #0]
 8004c74:	76da      	strb	r2, [r3, #27]
  csd10->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CRC_SLICE);
 8004c76:	9803      	ldr	r0, [sp, #12]
 8004c78:	2107      	movs	r1, #7
 8004c7a:	2201      	movs	r2, #1
 8004c7c:	f7ff fd00 	bl	8004680 <_mmcsd_get_slice>
 8004c80:	4603      	mov	r3, r0
 8004c82:	b2da      	uxtb	r2, r3
 8004c84:	9b00      	ldr	r3, [sp, #0]
 8004c86:	77da      	strb	r2, [r3, #31]
  csd10->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE);
 8004c88:	9803      	ldr	r0, [sp, #12]
 8004c8a:	217f      	movs	r1, #127	; 0x7f
 8004c8c:	227e      	movs	r2, #126	; 0x7e
 8004c8e:	f7ff fcf7 	bl	8004680 <_mmcsd_get_slice>
 8004c92:	4603      	mov	r3, r0
 8004c94:	b2da      	uxtb	r2, r3
 8004c96:	9b00      	ldr	r3, [sp, #0]
 8004c98:	701a      	strb	r2, [r3, #0]
  csd10->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_DSR_IMP_SLICE);
 8004c9a:	9803      	ldr	r0, [sp, #12]
 8004c9c:	214c      	movs	r1, #76	; 0x4c
 8004c9e:	224c      	movs	r2, #76	; 0x4c
 8004ca0:	f7ff fcee 	bl	8004680 <_mmcsd_get_slice>
 8004ca4:	4603      	mov	r3, r0
 8004ca6:	b2da      	uxtb	r2, r3
 8004ca8:	9b00      	ldr	r3, [sp, #0]
 8004caa:	729a      	strb	r2, [r3, #10]
  csd10->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_BLK_EN_SLICE);
 8004cac:	9803      	ldr	r0, [sp, #12]
 8004cae:	212e      	movs	r1, #46	; 0x2e
 8004cb0:	222e      	movs	r2, #46	; 0x2e
 8004cb2:	f7ff fce5 	bl	8004680 <_mmcsd_get_slice>
 8004cb6:	4603      	mov	r3, r0
 8004cb8:	b2da      	uxtb	r2, r3
 8004cba:	9b00      	ldr	r3, [sp, #0]
 8004cbc:	74da      	strb	r2, [r3, #19]
  csd10->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_ERASE_SECTOR_SIZE_SLICE);
 8004cbe:	9803      	ldr	r0, [sp, #12]
 8004cc0:	212d      	movs	r1, #45	; 0x2d
 8004cc2:	2227      	movs	r2, #39	; 0x27
 8004cc4:	f7ff fcdc 	bl	8004680 <_mmcsd_get_slice>
 8004cc8:	4603      	mov	r3, r0
 8004cca:	b2da      	uxtb	r2, r3
 8004ccc:	9b00      	ldr	r3, [sp, #0]
 8004cce:	751a      	strb	r2, [r3, #20]
  csd10->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_SLICE);
 8004cd0:	9803      	ldr	r0, [sp, #12]
 8004cd2:	210b      	movs	r1, #11
 8004cd4:	220a      	movs	r2, #10
 8004cd6:	f7ff fcd3 	bl	8004680 <_mmcsd_get_slice>
 8004cda:	4603      	mov	r3, r0
 8004cdc:	b2da      	uxtb	r2, r3
 8004cde:	9b00      	ldr	r3, [sp, #0]
 8004ce0:	779a      	strb	r2, [r3, #30]
  csd10->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_FILE_FORMAT_GRP_SLICE);
 8004ce2:	9803      	ldr	r0, [sp, #12]
 8004ce4:	210f      	movs	r1, #15
 8004ce6:	220f      	movs	r2, #15
 8004ce8:	f7ff fcca 	bl	8004680 <_mmcsd_get_slice>
 8004cec:	4603      	mov	r3, r0
 8004cee:	b2da      	uxtb	r2, r3
 8004cf0:	9b00      	ldr	r3, [sp, #0]
 8004cf2:	769a      	strb	r2, [r3, #26]
  csd10->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_NSAC_SLICE);
 8004cf4:	9803      	ldr	r0, [sp, #12]
 8004cf6:	216f      	movs	r1, #111	; 0x6f
 8004cf8:	2268      	movs	r2, #104	; 0x68
 8004cfa:	f7ff fcc1 	bl	8004680 <_mmcsd_get_slice>
 8004cfe:	4603      	mov	r3, r0
 8004d00:	b2da      	uxtb	r2, r3
 8004d02:	9b00      	ldr	r3, [sp, #0]
 8004d04:	709a      	strb	r2, [r3, #2]
  csd10->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_PERM_WRITE_PROTECT_SLICE);
 8004d06:	9803      	ldr	r0, [sp, #12]
 8004d08:	210d      	movs	r1, #13
 8004d0a:	220d      	movs	r2, #13
 8004d0c:	f7ff fcb8 	bl	8004680 <_mmcsd_get_slice>
 8004d10:	4603      	mov	r3, r0
 8004d12:	b2da      	uxtb	r2, r3
 8004d14:	9b00      	ldr	r3, [sp, #0]
 8004d16:	771a      	strb	r2, [r3, #28]
  csd10->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_R2W_FACTOR_SLICE);
 8004d18:	9803      	ldr	r0, [sp, #12]
 8004d1a:	211c      	movs	r1, #28
 8004d1c:	221a      	movs	r2, #26
 8004d1e:	f7ff fcaf 	bl	8004680 <_mmcsd_get_slice>
 8004d22:	4603      	mov	r3, r0
 8004d24:	b2da      	uxtb	r2, r3
 8004d26:	9b00      	ldr	r3, [sp, #0]
 8004d28:	75da      	strb	r2, [r3, #23]
  csd10->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_LEN_SLICE);
 8004d2a:	9803      	ldr	r0, [sp, #12]
 8004d2c:	2153      	movs	r1, #83	; 0x53
 8004d2e:	2250      	movs	r2, #80	; 0x50
 8004d30:	f7ff fca6 	bl	8004680 <_mmcsd_get_slice>
 8004d34:	4603      	mov	r3, r0
 8004d36:	b2da      	uxtb	r2, r3
 8004d38:	9b00      	ldr	r3, [sp, #0]
 8004d3a:	719a      	strb	r2, [r3, #6]
  csd10->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BL_PARTIAL_SLICE);
 8004d3c:	9803      	ldr	r0, [sp, #12]
 8004d3e:	214f      	movs	r1, #79	; 0x4f
 8004d40:	224f      	movs	r2, #79	; 0x4f
 8004d42:	f7ff fc9d 	bl	8004680 <_mmcsd_get_slice>
 8004d46:	4603      	mov	r3, r0
 8004d48:	b2da      	uxtb	r2, r3
 8004d4a:	9b00      	ldr	r3, [sp, #0]
 8004d4c:	71da      	strb	r2, [r3, #7]
  csd10->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_READ_BLK_MISALIGN_SLICE);
 8004d4e:	9803      	ldr	r0, [sp, #12]
 8004d50:	214d      	movs	r1, #77	; 0x4d
 8004d52:	224d      	movs	r2, #77	; 0x4d
 8004d54:	f7ff fc94 	bl	8004680 <_mmcsd_get_slice>
 8004d58:	4603      	mov	r3, r0
 8004d5a:	b2da      	uxtb	r2, r3
 8004d5c:	9b00      	ldr	r3, [sp, #0]
 8004d5e:	725a      	strb	r2, [r3, #9]
  csd10->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TAAC_SLICE);
 8004d60:	9803      	ldr	r0, [sp, #12]
 8004d62:	2177      	movs	r1, #119	; 0x77
 8004d64:	2270      	movs	r2, #112	; 0x70
 8004d66:	f7ff fc8b 	bl	8004680 <_mmcsd_get_slice>
 8004d6a:	4603      	mov	r3, r0
 8004d6c:	b2da      	uxtb	r2, r3
 8004d6e:	9b00      	ldr	r3, [sp, #0]
 8004d70:	705a      	strb	r2, [r3, #1]
  csd10->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TMP_WRITE_PROTECT_SLICE);
 8004d72:	9803      	ldr	r0, [sp, #12]
 8004d74:	210c      	movs	r1, #12
 8004d76:	220c      	movs	r2, #12
 8004d78:	f7ff fc82 	bl	8004680 <_mmcsd_get_slice>
 8004d7c:	4603      	mov	r3, r0
 8004d7e:	b2da      	uxtb	r2, r3
 8004d80:	9b00      	ldr	r3, [sp, #0]
 8004d82:	775a      	strb	r2, [r3, #29]
  csd10->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_TRANS_SPEED_SLICE);
 8004d84:	9803      	ldr	r0, [sp, #12]
 8004d86:	2167      	movs	r1, #103	; 0x67
 8004d88:	2260      	movs	r2, #96	; 0x60
 8004d8a:	f7ff fc79 	bl	8004680 <_mmcsd_get_slice>
 8004d8e:	4603      	mov	r3, r0
 8004d90:	b2da      	uxtb	r2, r3
 8004d92:	9b00      	ldr	r3, [sp, #0]
 8004d94:	70da      	strb	r2, [r3, #3]
  csd10->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_ENABLE_SLICE);
 8004d96:	9803      	ldr	r0, [sp, #12]
 8004d98:	211f      	movs	r1, #31
 8004d9a:	221f      	movs	r2, #31
 8004d9c:	f7ff fc70 	bl	8004680 <_mmcsd_get_slice>
 8004da0:	4603      	mov	r3, r0
 8004da2:	b2da      	uxtb	r2, r3
 8004da4:	9b00      	ldr	r3, [sp, #0]
 8004da6:	759a      	strb	r2, [r3, #22]
  csd10->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WP_GRP_SIZE_SLICE);
 8004da8:	9803      	ldr	r0, [sp, #12]
 8004daa:	2126      	movs	r1, #38	; 0x26
 8004dac:	2220      	movs	r2, #32
 8004dae:	f7ff fc67 	bl	8004680 <_mmcsd_get_slice>
 8004db2:	4603      	mov	r3, r0
 8004db4:	b2da      	uxtb	r2, r3
 8004db6:	9b00      	ldr	r3, [sp, #0]
 8004db8:	755a      	strb	r2, [r3, #21]
  csd10->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_LEN_SLICE);
 8004dba:	9803      	ldr	r0, [sp, #12]
 8004dbc:	2119      	movs	r1, #25
 8004dbe:	220c      	movs	r2, #12
 8004dc0:	f7ff fc5e 	bl	8004680 <_mmcsd_get_slice>
 8004dc4:	4603      	mov	r3, r0
 8004dc6:	b2da      	uxtb	r2, r3
 8004dc8:	9b00      	ldr	r3, [sp, #0]
 8004dca:	761a      	strb	r2, [r3, #24]
  csd10->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BL_PARTIAL_SLICE);
 8004dcc:	9803      	ldr	r0, [sp, #12]
 8004dce:	2115      	movs	r1, #21
 8004dd0:	2215      	movs	r2, #21
 8004dd2:	f7ff fc55 	bl	8004680 <_mmcsd_get_slice>
 8004dd6:	4603      	mov	r3, r0
 8004dd8:	b2da      	uxtb	r2, r3
 8004dda:	9b00      	ldr	r3, [sp, #0]
 8004ddc:	765a      	strb	r2, [r3, #25]
  csd10->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_10_WRITE_BLK_MISALIGN_SLICE);
 8004dde:	9803      	ldr	r0, [sp, #12]
 8004de0:	214e      	movs	r1, #78	; 0x4e
 8004de2:	224e      	movs	r2, #78	; 0x4e
 8004de4:	f7ff fc4c 	bl	8004680 <_mmcsd_get_slice>
 8004de8:	4603      	mov	r3, r0
 8004dea:	b2da      	uxtb	r2, r3
 8004dec:	9b00      	ldr	r3, [sp, #0]
 8004dee:	721a      	strb	r2, [r3, #8]
}
 8004df0:	b005      	add	sp, #20
 8004df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8004df6:	bf00      	nop
 8004df8:	f3af 8000 	nop.w
 8004dfc:	f3af 8000 	nop.w

08004e00 <_mmcsd_unpack_csd_v20>:
 * @param[out] csd20    pointer to the @p unpacked_sdc_csd_20_t object
 *
 * @notapi
 */
void _mmcsd_unpack_csd_v20(const MMCSDBlockDevice *sdcp,
                           unpacked_sdc_csd_20_t *csd20) {
 8004e00:	b500      	push	{lr}
 8004e02:	b085      	sub	sp, #20
 8004e04:	9001      	str	r0, [sp, #4]
 8004e06:	9100      	str	r1, [sp, #0]
  const uint32_t *csd;

  osalDbgCheck(NULL != sdcp);

  csd = sdcp->csd;
 8004e08:	9b01      	ldr	r3, [sp, #4]
 8004e0a:	3318      	adds	r3, #24
 8004e0c:	9303      	str	r3, [sp, #12]
  csd20->c_size              =           _mmcsd_get_slice(csd, MMCSD_CSD_20_C_SIZE_SLICE);
 8004e0e:	9803      	ldr	r0, [sp, #12]
 8004e10:	2145      	movs	r1, #69	; 0x45
 8004e12:	2230      	movs	r2, #48	; 0x30
 8004e14:	f7ff fc34 	bl	8004680 <_mmcsd_get_slice>
 8004e18:	4602      	mov	r2, r0
 8004e1a:	9b00      	ldr	r3, [sp, #0]
 8004e1c:	60da      	str	r2, [r3, #12]
  csd20->crc                 = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CRC_SLICE);
 8004e1e:	9803      	ldr	r0, [sp, #12]
 8004e20:	2107      	movs	r1, #7
 8004e22:	2201      	movs	r2, #1
 8004e24:	f7ff fc2c 	bl	8004680 <_mmcsd_get_slice>
 8004e28:	4603      	mov	r3, r0
 8004e2a:	b2da      	uxtb	r2, r3
 8004e2c:	9b00      	ldr	r3, [sp, #0]
 8004e2e:	771a      	strb	r2, [r3, #28]
  csd20->ccc                 = (uint16_t)_mmcsd_get_slice(csd, MMCSD_CSD_20_CCC_SLICE);
 8004e30:	9803      	ldr	r0, [sp, #12]
 8004e32:	215f      	movs	r1, #95	; 0x5f
 8004e34:	2254      	movs	r2, #84	; 0x54
 8004e36:	f7ff fc23 	bl	8004680 <_mmcsd_get_slice>
 8004e3a:	4603      	mov	r3, r0
 8004e3c:	b29a      	uxth	r2, r3
 8004e3e:	9b00      	ldr	r3, [sp, #0]
 8004e40:	809a      	strh	r2, [r3, #4]
  csd20->copy                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_COPY_SLICE);
 8004e42:	9803      	ldr	r0, [sp, #12]
 8004e44:	210e      	movs	r1, #14
 8004e46:	220e      	movs	r2, #14
 8004e48:	f7ff fc1a 	bl	8004680 <_mmcsd_get_slice>
 8004e4c:	4603      	mov	r3, r0
 8004e4e:	b2da      	uxtb	r2, r3
 8004e50:	9b00      	ldr	r3, [sp, #0]
 8004e52:	761a      	strb	r2, [r3, #24]
  csd20->csd_structure       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_CSD_STRUCTURE_SLICE);
 8004e54:	9803      	ldr	r0, [sp, #12]
 8004e56:	217f      	movs	r1, #127	; 0x7f
 8004e58:	227e      	movs	r2, #126	; 0x7e
 8004e5a:	f7ff fc11 	bl	8004680 <_mmcsd_get_slice>
 8004e5e:	4603      	mov	r3, r0
 8004e60:	b2da      	uxtb	r2, r3
 8004e62:	9b00      	ldr	r3, [sp, #0]
 8004e64:	701a      	strb	r2, [r3, #0]
  csd20->dsr_imp             = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_DSR_IMP_SLICE);
 8004e66:	9803      	ldr	r0, [sp, #12]
 8004e68:	214c      	movs	r1, #76	; 0x4c
 8004e6a:	224c      	movs	r2, #76	; 0x4c
 8004e6c:	f7ff fc08 	bl	8004680 <_mmcsd_get_slice>
 8004e70:	4603      	mov	r3, r0
 8004e72:	b2da      	uxtb	r2, r3
 8004e74:	9b00      	ldr	r3, [sp, #0]
 8004e76:	729a      	strb	r2, [r3, #10]
  csd20->erase_blk_en        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_BLK_EN_SLICE);
 8004e78:	9803      	ldr	r0, [sp, #12]
 8004e7a:	212e      	movs	r1, #46	; 0x2e
 8004e7c:	222e      	movs	r2, #46	; 0x2e
 8004e7e:	f7ff fbff 	bl	8004680 <_mmcsd_get_slice>
 8004e82:	4603      	mov	r3, r0
 8004e84:	b2da      	uxtb	r2, r3
 8004e86:	9b00      	ldr	r3, [sp, #0]
 8004e88:	741a      	strb	r2, [r3, #16]
  csd20->file_format         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_SLICE);
 8004e8a:	9803      	ldr	r0, [sp, #12]
 8004e8c:	210b      	movs	r1, #11
 8004e8e:	220a      	movs	r2, #10
 8004e90:	f7ff fbf6 	bl	8004680 <_mmcsd_get_slice>
 8004e94:	4603      	mov	r3, r0
 8004e96:	b2da      	uxtb	r2, r3
 8004e98:	9b00      	ldr	r3, [sp, #0]
 8004e9a:	76da      	strb	r2, [r3, #27]
  csd20->file_format_grp     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_FILE_FORMAT_GRP_SLICE);
 8004e9c:	9803      	ldr	r0, [sp, #12]
 8004e9e:	210f      	movs	r1, #15
 8004ea0:	220f      	movs	r2, #15
 8004ea2:	f7ff fbed 	bl	8004680 <_mmcsd_get_slice>
 8004ea6:	4603      	mov	r3, r0
 8004ea8:	b2da      	uxtb	r2, r3
 8004eaa:	9b00      	ldr	r3, [sp, #0]
 8004eac:	75da      	strb	r2, [r3, #23]
  csd20->nsac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_NSAC_SLICE);
 8004eae:	9803      	ldr	r0, [sp, #12]
 8004eb0:	216f      	movs	r1, #111	; 0x6f
 8004eb2:	2268      	movs	r2, #104	; 0x68
 8004eb4:	f7ff fbe4 	bl	8004680 <_mmcsd_get_slice>
 8004eb8:	4603      	mov	r3, r0
 8004eba:	b2da      	uxtb	r2, r3
 8004ebc:	9b00      	ldr	r3, [sp, #0]
 8004ebe:	709a      	strb	r2, [r3, #2]
  csd20->perm_write_protect  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_PERM_WRITE_PROTECT_SLICE);
 8004ec0:	9803      	ldr	r0, [sp, #12]
 8004ec2:	210d      	movs	r1, #13
 8004ec4:	220d      	movs	r2, #13
 8004ec6:	f7ff fbdb 	bl	8004680 <_mmcsd_get_slice>
 8004eca:	4603      	mov	r3, r0
 8004ecc:	b2da      	uxtb	r2, r3
 8004ece:	9b00      	ldr	r3, [sp, #0]
 8004ed0:	765a      	strb	r2, [r3, #25]
  csd20->r2w_factor          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_R2W_FACTOR_SLICE);
 8004ed2:	9803      	ldr	r0, [sp, #12]
 8004ed4:	211c      	movs	r1, #28
 8004ed6:	221a      	movs	r2, #26
 8004ed8:	f7ff fbd2 	bl	8004680 <_mmcsd_get_slice>
 8004edc:	4603      	mov	r3, r0
 8004ede:	b2da      	uxtb	r2, r3
 8004ee0:	9b00      	ldr	r3, [sp, #0]
 8004ee2:	751a      	strb	r2, [r3, #20]
  csd20->read_bl_len         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_LEN_SLICE);
 8004ee4:	9803      	ldr	r0, [sp, #12]
 8004ee6:	2153      	movs	r1, #83	; 0x53
 8004ee8:	2250      	movs	r2, #80	; 0x50
 8004eea:	f7ff fbc9 	bl	8004680 <_mmcsd_get_slice>
 8004eee:	4603      	mov	r3, r0
 8004ef0:	b2da      	uxtb	r2, r3
 8004ef2:	9b00      	ldr	r3, [sp, #0]
 8004ef4:	719a      	strb	r2, [r3, #6]
  csd20->read_bl_partial     = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BL_PARTIAL_SLICE);
 8004ef6:	9803      	ldr	r0, [sp, #12]
 8004ef8:	214f      	movs	r1, #79	; 0x4f
 8004efa:	224f      	movs	r2, #79	; 0x4f
 8004efc:	f7ff fbc0 	bl	8004680 <_mmcsd_get_slice>
 8004f00:	4603      	mov	r3, r0
 8004f02:	b2da      	uxtb	r2, r3
 8004f04:	9b00      	ldr	r3, [sp, #0]
 8004f06:	71da      	strb	r2, [r3, #7]
  csd20->read_blk_misalign   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_READ_BLK_MISALIGN_SLICE);
 8004f08:	9803      	ldr	r0, [sp, #12]
 8004f0a:	214d      	movs	r1, #77	; 0x4d
 8004f0c:	224d      	movs	r2, #77	; 0x4d
 8004f0e:	f7ff fbb7 	bl	8004680 <_mmcsd_get_slice>
 8004f12:	4603      	mov	r3, r0
 8004f14:	b2da      	uxtb	r2, r3
 8004f16:	9b00      	ldr	r3, [sp, #0]
 8004f18:	725a      	strb	r2, [r3, #9]
  csd20->erase_sector_size   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_ERASE_SECTOR_SIZE_SLICE);
 8004f1a:	9803      	ldr	r0, [sp, #12]
 8004f1c:	212d      	movs	r1, #45	; 0x2d
 8004f1e:	2227      	movs	r2, #39	; 0x27
 8004f20:	f7ff fbae 	bl	8004680 <_mmcsd_get_slice>
 8004f24:	4603      	mov	r3, r0
 8004f26:	b2da      	uxtb	r2, r3
 8004f28:	9b00      	ldr	r3, [sp, #0]
 8004f2a:	745a      	strb	r2, [r3, #17]
  csd20->taac                = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TAAC_SLICE);
 8004f2c:	9803      	ldr	r0, [sp, #12]
 8004f2e:	2177      	movs	r1, #119	; 0x77
 8004f30:	2270      	movs	r2, #112	; 0x70
 8004f32:	f7ff fba5 	bl	8004680 <_mmcsd_get_slice>
 8004f36:	4603      	mov	r3, r0
 8004f38:	b2da      	uxtb	r2, r3
 8004f3a:	9b00      	ldr	r3, [sp, #0]
 8004f3c:	705a      	strb	r2, [r3, #1]
  csd20->tmp_write_protect   = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TMP_WRITE_PROTECT_SLICE);
 8004f3e:	9803      	ldr	r0, [sp, #12]
 8004f40:	210c      	movs	r1, #12
 8004f42:	220c      	movs	r2, #12
 8004f44:	f7ff fb9c 	bl	8004680 <_mmcsd_get_slice>
 8004f48:	4603      	mov	r3, r0
 8004f4a:	b2da      	uxtb	r2, r3
 8004f4c:	9b00      	ldr	r3, [sp, #0]
 8004f4e:	769a      	strb	r2, [r3, #26]
  csd20->tran_speed          = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_TRANS_SPEED_SLICE);
 8004f50:	9803      	ldr	r0, [sp, #12]
 8004f52:	2167      	movs	r1, #103	; 0x67
 8004f54:	2260      	movs	r2, #96	; 0x60
 8004f56:	f7ff fb93 	bl	8004680 <_mmcsd_get_slice>
 8004f5a:	4603      	mov	r3, r0
 8004f5c:	b2da      	uxtb	r2, r3
 8004f5e:	9b00      	ldr	r3, [sp, #0]
 8004f60:	70da      	strb	r2, [r3, #3]
  csd20->wp_grp_enable       = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_ENABLE_SLICE);
 8004f62:	9803      	ldr	r0, [sp, #12]
 8004f64:	211f      	movs	r1, #31
 8004f66:	221f      	movs	r2, #31
 8004f68:	f7ff fb8a 	bl	8004680 <_mmcsd_get_slice>
 8004f6c:	4603      	mov	r3, r0
 8004f6e:	b2da      	uxtb	r2, r3
 8004f70:	9b00      	ldr	r3, [sp, #0]
 8004f72:	74da      	strb	r2, [r3, #19]
  csd20->wp_grp_size         = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WP_GRP_SIZE_SLICE);
 8004f74:	9803      	ldr	r0, [sp, #12]
 8004f76:	2126      	movs	r1, #38	; 0x26
 8004f78:	2220      	movs	r2, #32
 8004f7a:	f7ff fb81 	bl	8004680 <_mmcsd_get_slice>
 8004f7e:	4603      	mov	r3, r0
 8004f80:	b2da      	uxtb	r2, r3
 8004f82:	9b00      	ldr	r3, [sp, #0]
 8004f84:	749a      	strb	r2, [r3, #18]
  csd20->write_bl_len        = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_LEN_SLICE);
 8004f86:	9803      	ldr	r0, [sp, #12]
 8004f88:	2119      	movs	r1, #25
 8004f8a:	220c      	movs	r2, #12
 8004f8c:	f7ff fb78 	bl	8004680 <_mmcsd_get_slice>
 8004f90:	4603      	mov	r3, r0
 8004f92:	b2da      	uxtb	r2, r3
 8004f94:	9b00      	ldr	r3, [sp, #0]
 8004f96:	755a      	strb	r2, [r3, #21]
  csd20->write_bl_partial    = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BL_PARTIAL_SLICE);
 8004f98:	9803      	ldr	r0, [sp, #12]
 8004f9a:	2115      	movs	r1, #21
 8004f9c:	2215      	movs	r2, #21
 8004f9e:	f7ff fb6f 	bl	8004680 <_mmcsd_get_slice>
 8004fa2:	4603      	mov	r3, r0
 8004fa4:	b2da      	uxtb	r2, r3
 8004fa6:	9b00      	ldr	r3, [sp, #0]
 8004fa8:	759a      	strb	r2, [r3, #22]
  csd20->write_blk_misalign  = (uint8_t) _mmcsd_get_slice(csd, MMCSD_CSD_20_WRITE_BLK_MISALIGN_SLICE);
 8004faa:	9803      	ldr	r0, [sp, #12]
 8004fac:	214e      	movs	r1, #78	; 0x4e
 8004fae:	224e      	movs	r2, #78	; 0x4e
 8004fb0:	f7ff fb66 	bl	8004680 <_mmcsd_get_slice>
 8004fb4:	4603      	mov	r3, r0
 8004fb6:	b2da      	uxtb	r2, r3
 8004fb8:	9b00      	ldr	r3, [sp, #0]
 8004fba:	721a      	strb	r2, [r3, #8]
}
 8004fbc:	b005      	add	sp, #20
 8004fbe:	f85d fb04 	ldr.w	pc, [sp], #4
 8004fc2:	bf00      	nop
 8004fc4:	f3af 8000 	nop.w
 8004fc8:	f3af 8000 	nop.w
 8004fcc:	f3af 8000 	nop.w

08004fd0 <palReadBus>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @return              The bus logical states.
 *
 * @special
 */
ioportmask_t palReadBus(IOBus *bus) {
 8004fd0:	b082      	sub	sp, #8
 8004fd2:	9001      	str	r0, [sp, #4]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  return palReadGroup(bus->portid, bus->mask, bus->offset);
 8004fd4:	9b01      	ldr	r3, [sp, #4]
 8004fd6:	681b      	ldr	r3, [r3, #0]
 8004fd8:	691a      	ldr	r2, [r3, #16]
 8004fda:	9b01      	ldr	r3, [sp, #4]
 8004fdc:	689b      	ldr	r3, [r3, #8]
 8004fde:	40da      	lsrs	r2, r3
 8004fe0:	9b01      	ldr	r3, [sp, #4]
 8004fe2:	685b      	ldr	r3, [r3, #4]
 8004fe4:	4013      	ands	r3, r2
}
 8004fe6:	4618      	mov	r0, r3
 8004fe8:	b002      	add	sp, #8
 8004fea:	4770      	bx	lr
 8004fec:	f3af 8000 	nop.w

08004ff0 <palWriteBus>:
 *                      the bus width are masked so most significant bits are
 *                      lost.
 *
 * @special
 */
void palWriteBus(IOBus *bus, ioportmask_t bits) {
 8004ff0:	b082      	sub	sp, #8
 8004ff2:	9001      	str	r0, [sp, #4]
 8004ff4:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palWriteGroup(bus->portid, bus->mask, bus->offset, bits);
 8004ff6:	9b01      	ldr	r3, [sp, #4]
 8004ff8:	681b      	ldr	r3, [r3, #0]
 8004ffa:	9a00      	ldr	r2, [sp, #0]
 8004ffc:	43d1      	mvns	r1, r2
 8004ffe:	9a01      	ldr	r2, [sp, #4]
 8005000:	6852      	ldr	r2, [r2, #4]
 8005002:	4011      	ands	r1, r2
 8005004:	9a01      	ldr	r2, [sp, #4]
 8005006:	6892      	ldr	r2, [r2, #8]
 8005008:	3210      	adds	r2, #16
 800500a:	4091      	lsls	r1, r2
 800500c:	9a01      	ldr	r2, [sp, #4]
 800500e:	6850      	ldr	r0, [r2, #4]
 8005010:	9a00      	ldr	r2, [sp, #0]
 8005012:	4010      	ands	r0, r2
 8005014:	9a01      	ldr	r2, [sp, #4]
 8005016:	6892      	ldr	r2, [r2, #8]
 8005018:	fa00 f202 	lsl.w	r2, r0, r2
 800501c:	430a      	orrs	r2, r1
 800501e:	619a      	str	r2, [r3, #24]
}
 8005020:	b002      	add	sp, #8
 8005022:	4770      	bx	lr
 8005024:	f3af 8000 	nop.w
 8005028:	f3af 8000 	nop.w
 800502c:	f3af 8000 	nop.w

08005030 <palSetBusMode>:
 * @param[in] bus       the I/O bus, pointer to a @p IOBus structure
 * @param[in] mode      the mode
 *
 * @special
 */
void palSetBusMode(IOBus *bus, iomode_t mode) {
 8005030:	b500      	push	{lr}
 8005032:	b083      	sub	sp, #12
 8005034:	9001      	str	r0, [sp, #4]
 8005036:	9100      	str	r1, [sp, #0]

  osalDbgCheck((bus != NULL) && (bus->offset < PAL_IOPORTS_WIDTH));

  palSetGroupMode(bus->portid, bus->mask, bus->offset, mode);
 8005038:	9b01      	ldr	r3, [sp, #4]
 800503a:	681a      	ldr	r2, [r3, #0]
 800503c:	9b01      	ldr	r3, [sp, #4]
 800503e:	6859      	ldr	r1, [r3, #4]
 8005040:	9b01      	ldr	r3, [sp, #4]
 8005042:	689b      	ldr	r3, [r3, #8]
 8005044:	fa01 f303 	lsl.w	r3, r1, r3
 8005048:	4610      	mov	r0, r2
 800504a:	4619      	mov	r1, r3
 800504c:	9a00      	ldr	r2, [sp, #0]
 800504e:	f003 f83f 	bl	80080d0 <_pal_lld_setgroupmode>
}
 8005052:	b003      	add	sp, #12
 8005054:	f85d fb04 	ldr.w	pc, [sp], #4
 8005058:	f3af 8000 	nop.w
 800505c:	f3af 8000 	nop.w

08005060 <rtcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void rtcInit(void) {
 8005060:	b508      	push	{r3, lr}

  rtc_lld_init();
 8005062:	f004 fe9d 	bl	8009da0 <rtc_lld_init>
}
 8005066:	bd08      	pop	{r3, pc}
 8005068:	f3af 8000 	nop.w
 800506c:	f3af 8000 	nop.w

08005070 <rtcObjectInit>:
 *
 * @param[out] rtcp     pointer to RTC driver structure
 *
 * @init
 */
void rtcObjectInit(RTCDriver *rtcp) {
 8005070:	b082      	sub	sp, #8
 8005072:	9001      	str	r0, [sp, #4]
#if RTC_HAS_STORAGE == TRUE
  rtcp->vmt = &_rtc_lld_vmt;
#else
  (void)rtcp;
#endif
}
 8005074:	b002      	add	sp, #8
 8005076:	4770      	bx	lr
 8005078:	f3af 8000 	nop.w
 800507c:	f3af 8000 	nop.w

08005080 <rtcSetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcSetTime(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8005080:	b500      	push	{lr}
 8005082:	b083      	sub	sp, #12
 8005084:	9001      	str	r0, [sp, #4]
 8005086:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_set_time(rtcp, timespec);
 8005088:	9801      	ldr	r0, [sp, #4]
 800508a:	9900      	ldr	r1, [sp, #0]
 800508c:	f004 fec8 	bl	8009e20 <rtc_lld_set_time>
}
 8005090:	b003      	add	sp, #12
 8005092:	f85d fb04 	ldr.w	pc, [sp], #4
 8005096:	bf00      	nop
 8005098:	f3af 8000 	nop.w
 800509c:	f3af 8000 	nop.w

080050a0 <rtcGetTime>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @special
 */
void rtcGetTime(RTCDriver *rtcp, RTCDateTime *timespec) {
 80050a0:	b500      	push	{lr}
 80050a2:	b083      	sub	sp, #12
 80050a4:	9001      	str	r0, [sp, #4]
 80050a6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((rtcp != NULL) && (timespec != NULL));

  rtc_lld_get_time(rtcp, timespec);
 80050a8:	9801      	ldr	r0, [sp, #4]
 80050aa:	9900      	ldr	r1, [sp, #0]
 80050ac:	f004 fee8 	bl	8009e80 <rtc_lld_get_time>
}
 80050b0:	b003      	add	sp, #12
 80050b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80050b6:	bf00      	nop
 80050b8:	f3af 8000 	nop.w
 80050bc:	f3af 8000 	nop.w

080050c0 <rtcSetAlarm>:
 *
 * @special
 */
void rtcSetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 const RTCAlarm *alarmspec) {
 80050c0:	b500      	push	{lr}
 80050c2:	b085      	sub	sp, #20
 80050c4:	9003      	str	r0, [sp, #12]
 80050c6:	9102      	str	r1, [sp, #8]
 80050c8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) && (alarm < (rtcalarm_t)RTC_ALARMS));

  rtc_lld_set_alarm(rtcp, alarm, alarmspec);
 80050ca:	9803      	ldr	r0, [sp, #12]
 80050cc:	9902      	ldr	r1, [sp, #8]
 80050ce:	9a01      	ldr	r2, [sp, #4]
 80050d0:	f004 ff36 	bl	8009f40 <rtc_lld_set_alarm>
}
 80050d4:	b005      	add	sp, #20
 80050d6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050da:	bf00      	nop
 80050dc:	f3af 8000 	nop.w

080050e0 <rtcGetAlarm>:
 *
 * @special
 */
void rtcGetAlarm(RTCDriver *rtcp,
                 rtcalarm_t alarm,
                 RTCAlarm *alarmspec) {
 80050e0:	b500      	push	{lr}
 80050e2:	b085      	sub	sp, #20
 80050e4:	9003      	str	r0, [sp, #12]
 80050e6:	9102      	str	r1, [sp, #8]
 80050e8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((rtcp != NULL) &&
               (alarm < (rtcalarm_t)RTC_ALARMS) &&
               (alarmspec != NULL));

  rtc_lld_get_alarm(rtcp, alarm, alarmspec);
 80050ea:	9803      	ldr	r0, [sp, #12]
 80050ec:	9902      	ldr	r1, [sp, #8]
 80050ee:	9a01      	ldr	r2, [sp, #4]
 80050f0:	f004 ffae 	bl	800a050 <rtc_lld_get_alarm>
}
 80050f4:	b005      	add	sp, #20
 80050f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80050fa:	bf00      	nop
 80050fc:	f3af 8000 	nop.w

08005100 <rtcConvertDateTimeToStructTm>:
 *
 * @api
 */
void rtcConvertDateTimeToStructTm(const RTCDateTime *timespec,
                                  struct tm *timp,
                                  uint32_t *tv_msec) {
 8005100:	b086      	sub	sp, #24
 8005102:	9003      	str	r0, [sp, #12]
 8005104:	9102      	str	r1, [sp, #8]
 8005106:	9201      	str	r2, [sp, #4]
  int sec;

  timp->tm_year  = (int)timespec->year + (1980 - 1900);
 8005108:	9b03      	ldr	r3, [sp, #12]
 800510a:	781b      	ldrb	r3, [r3, #0]
 800510c:	f103 0250 	add.w	r2, r3, #80	; 0x50
 8005110:	9b02      	ldr	r3, [sp, #8]
 8005112:	615a      	str	r2, [r3, #20]
  timp->tm_mon   = (int)timespec->month - 1;
 8005114:	9b03      	ldr	r3, [sp, #12]
 8005116:	785b      	ldrb	r3, [r3, #1]
 8005118:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800511c:	b2db      	uxtb	r3, r3
 800511e:	1e5a      	subs	r2, r3, #1
 8005120:	9b02      	ldr	r3, [sp, #8]
 8005122:	611a      	str	r2, [r3, #16]
  timp->tm_mday  = (int)timespec->day;
 8005124:	9b03      	ldr	r3, [sp, #12]
 8005126:	789b      	ldrb	r3, [r3, #2]
 8005128:	f3c3 0304 	ubfx	r3, r3, #0, #5
 800512c:	b2db      	uxtb	r3, r3
 800512e:	461a      	mov	r2, r3
 8005130:	9b02      	ldr	r3, [sp, #8]
 8005132:	60da      	str	r2, [r3, #12]
  timp->tm_isdst = (int)timespec->dstflag;
 8005134:	9b03      	ldr	r3, [sp, #12]
 8005136:	785b      	ldrb	r3, [r3, #1]
 8005138:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800513c:	b2db      	uxtb	r3, r3
 800513e:	461a      	mov	r2, r3
 8005140:	9b02      	ldr	r3, [sp, #8]
 8005142:	621a      	str	r2, [r3, #32]
  timp->tm_wday  = (int)timespec->dayofweek - 1;
 8005144:	9b03      	ldr	r3, [sp, #12]
 8005146:	785b      	ldrb	r3, [r3, #1]
 8005148:	f3c3 1342 	ubfx	r3, r3, #5, #3
 800514c:	b2db      	uxtb	r3, r3
 800514e:	1e5a      	subs	r2, r3, #1
 8005150:	9b02      	ldr	r3, [sp, #8]
 8005152:	619a      	str	r2, [r3, #24]

  sec = (int)timespec->millisecond / 1000;
 8005154:	9b03      	ldr	r3, [sp, #12]
 8005156:	685b      	ldr	r3, [r3, #4]
 8005158:	f3c3 031a 	ubfx	r3, r3, #0, #27
 800515c:	4a26      	ldr	r2, [pc, #152]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 800515e:	fb82 1203 	smull	r1, r2, r2, r3
 8005162:	1192      	asrs	r2, r2, #6
 8005164:	17db      	asrs	r3, r3, #31
 8005166:	1ad3      	subs	r3, r2, r3
 8005168:	9305      	str	r3, [sp, #20]
  timp->tm_hour = sec / 3600;
 800516a:	9b05      	ldr	r3, [sp, #20]
 800516c:	4a23      	ldr	r2, [pc, #140]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 800516e:	fb82 1203 	smull	r1, r2, r2, r3
 8005172:	441a      	add	r2, r3
 8005174:	12d2      	asrs	r2, r2, #11
 8005176:	17db      	asrs	r3, r3, #31
 8005178:	1ad2      	subs	r2, r2, r3
 800517a:	9b02      	ldr	r3, [sp, #8]
 800517c:	609a      	str	r2, [r3, #8]
  sec %= 3600;
 800517e:	9b05      	ldr	r3, [sp, #20]
 8005180:	4a1e      	ldr	r2, [pc, #120]	; (80051fc <rtcConvertDateTimeToStructTm+0xfc>)
 8005182:	fb82 1203 	smull	r1, r2, r2, r3
 8005186:	441a      	add	r2, r3
 8005188:	12d1      	asrs	r1, r2, #11
 800518a:	17da      	asrs	r2, r3, #31
 800518c:	1a8a      	subs	r2, r1, r2
 800518e:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005192:	fb01 f202 	mul.w	r2, r1, r2
 8005196:	1a9b      	subs	r3, r3, r2
 8005198:	9305      	str	r3, [sp, #20]
  timp->tm_min = sec / 60;
 800519a:	9b05      	ldr	r3, [sp, #20]
 800519c:	4a18      	ldr	r2, [pc, #96]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 800519e:	fb82 1203 	smull	r1, r2, r2, r3
 80051a2:	441a      	add	r2, r3
 80051a4:	1152      	asrs	r2, r2, #5
 80051a6:	17db      	asrs	r3, r3, #31
 80051a8:	1ad2      	subs	r2, r2, r3
 80051aa:	9b02      	ldr	r3, [sp, #8]
 80051ac:	605a      	str	r2, [r3, #4]
  timp->tm_sec = sec % 60;
 80051ae:	9905      	ldr	r1, [sp, #20]
 80051b0:	4b13      	ldr	r3, [pc, #76]	; (8005200 <rtcConvertDateTimeToStructTm+0x100>)
 80051b2:	fb83 2301 	smull	r2, r3, r3, r1
 80051b6:	440b      	add	r3, r1
 80051b8:	115a      	asrs	r2, r3, #5
 80051ba:	17cb      	asrs	r3, r1, #31
 80051bc:	1ad2      	subs	r2, r2, r3
 80051be:	4613      	mov	r3, r2
 80051c0:	011b      	lsls	r3, r3, #4
 80051c2:	1a9b      	subs	r3, r3, r2
 80051c4:	009b      	lsls	r3, r3, #2
 80051c6:	1aca      	subs	r2, r1, r3
 80051c8:	9b02      	ldr	r3, [sp, #8]
 80051ca:	601a      	str	r2, [r3, #0]

  if (NULL != tv_msec) {
 80051cc:	9b01      	ldr	r3, [sp, #4]
 80051ce:	2b00      	cmp	r3, #0
 80051d0:	d00f      	beq.n	80051f2 <rtcConvertDateTimeToStructTm+0xf2>
    *tv_msec = (uint32_t)timespec->millisecond % 1000U;
 80051d2:	9b03      	ldr	r3, [sp, #12]
 80051d4:	685b      	ldr	r3, [r3, #4]
 80051d6:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80051da:	4b07      	ldr	r3, [pc, #28]	; (80051f8 <rtcConvertDateTimeToStructTm+0xf8>)
 80051dc:	fba3 1302 	umull	r1, r3, r3, r2
 80051e0:	099b      	lsrs	r3, r3, #6
 80051e2:	f44f 717a 	mov.w	r1, #1000	; 0x3e8
 80051e6:	fb01 f303 	mul.w	r3, r1, r3
 80051ea:	1ad3      	subs	r3, r2, r3
 80051ec:	461a      	mov	r2, r3
 80051ee:	9b01      	ldr	r3, [sp, #4]
 80051f0:	601a      	str	r2, [r3, #0]
  }
}
 80051f2:	b006      	add	sp, #24
 80051f4:	4770      	bx	lr
 80051f6:	bf00      	nop
 80051f8:	10624dd3 	.word	0x10624dd3
 80051fc:	91a2b3c5 	.word	0x91a2b3c5
 8005200:	88888889 	.word	0x88888889
 8005204:	f3af 8000 	nop.w
 8005208:	f3af 8000 	nop.w
 800520c:	f3af 8000 	nop.w

08005210 <rtcConvertStructTmToDateTime>:
 *
 * @api
 */
void rtcConvertStructTmToDateTime(const struct tm *timp,
                                  uint32_t tv_msec,
                                  RTCDateTime *timespec) {
 8005210:	b084      	sub	sp, #16
 8005212:	9003      	str	r0, [sp, #12]
 8005214:	9102      	str	r1, [sp, #8]
 8005216:	9201      	str	r2, [sp, #4]

  /*lint -save -e9034 [10.4] Verified assignments to bit fields.*/
  timespec->year      = (uint32_t)timp->tm_year - (1980U - 1900U);
 8005218:	9b03      	ldr	r3, [sp, #12]
 800521a:	695b      	ldr	r3, [r3, #20]
 800521c:	b2db      	uxtb	r3, r3
 800521e:	3b50      	subs	r3, #80	; 0x50
 8005220:	b2d9      	uxtb	r1, r3
 8005222:	9a01      	ldr	r2, [sp, #4]
 8005224:	7813      	ldrb	r3, [r2, #0]
 8005226:	f361 0307 	bfi	r3, r1, #0, #8
 800522a:	7013      	strb	r3, [r2, #0]
  timespec->month     = (uint32_t)timp->tm_mon + 1U;
 800522c:	9b03      	ldr	r3, [sp, #12]
 800522e:	691b      	ldr	r3, [r3, #16]
 8005230:	b2db      	uxtb	r3, r3
 8005232:	3301      	adds	r3, #1
 8005234:	b2db      	uxtb	r3, r3
 8005236:	f003 030f 	and.w	r3, r3, #15
 800523a:	b2d9      	uxtb	r1, r3
 800523c:	9a01      	ldr	r2, [sp, #4]
 800523e:	7853      	ldrb	r3, [r2, #1]
 8005240:	f361 0303 	bfi	r3, r1, #0, #4
 8005244:	7053      	strb	r3, [r2, #1]
  timespec->day       = (uint32_t)timp->tm_mday;
 8005246:	9b03      	ldr	r3, [sp, #12]
 8005248:	68db      	ldr	r3, [r3, #12]
 800524a:	b2db      	uxtb	r3, r3
 800524c:	f003 031f 	and.w	r3, r3, #31
 8005250:	b2d9      	uxtb	r1, r3
 8005252:	9a01      	ldr	r2, [sp, #4]
 8005254:	7893      	ldrb	r3, [r2, #2]
 8005256:	f361 0304 	bfi	r3, r1, #0, #5
 800525a:	7093      	strb	r3, [r2, #2]
  timespec->dayofweek = (uint32_t)timp->tm_wday + 1U;
 800525c:	9b03      	ldr	r3, [sp, #12]
 800525e:	699b      	ldr	r3, [r3, #24]
 8005260:	b2db      	uxtb	r3, r3
 8005262:	3301      	adds	r3, #1
 8005264:	b2db      	uxtb	r3, r3
 8005266:	f003 0307 	and.w	r3, r3, #7
 800526a:	b2d9      	uxtb	r1, r3
 800526c:	9a01      	ldr	r2, [sp, #4]
 800526e:	7853      	ldrb	r3, [r2, #1]
 8005270:	f361 1347 	bfi	r3, r1, #5, #3
 8005274:	7053      	strb	r3, [r2, #1]
  if (-1 == timp->tm_isdst) {
 8005276:	9b03      	ldr	r3, [sp, #12]
 8005278:	6a1b      	ldr	r3, [r3, #32]
 800527a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800527e:	d105      	bne.n	800528c <rtcConvertStructTmToDateTime+0x7c>
    timespec->dstflag = 0U;  /* set zero if dst is unknown */
 8005280:	9a01      	ldr	r2, [sp, #4]
 8005282:	7853      	ldrb	r3, [r2, #1]
 8005284:	f36f 1304 	bfc	r3, #4, #1
 8005288:	7053      	strb	r3, [r2, #1]
 800528a:	e00a      	b.n	80052a2 <rtcConvertStructTmToDateTime+0x92>
  }
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
 800528c:	9b03      	ldr	r3, [sp, #12]
 800528e:	6a1b      	ldr	r3, [r3, #32]
 8005290:	b2db      	uxtb	r3, r3
 8005292:	f003 0301 	and.w	r3, r3, #1
 8005296:	b2d9      	uxtb	r1, r3
 8005298:	9a01      	ldr	r2, [sp, #4]
 800529a:	7853      	ldrb	r3, [r2, #1]
 800529c:	f361 1304 	bfi	r3, r1, #4, #1
 80052a0:	7053      	strb	r3, [r2, #1]
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052a2:	9b03      	ldr	r3, [sp, #12]
 80052a4:	689b      	ldr	r3, [r3, #8]
 80052a6:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 80052aa:	fb02 f103 	mul.w	r1, r2, r3
                                                (timp->tm_min * 60) +
 80052ae:	9b03      	ldr	r3, [sp, #12]
 80052b0:	685a      	ldr	r2, [r3, #4]
 80052b2:	4613      	mov	r3, r2
 80052b4:	011b      	lsls	r3, r3, #4
 80052b6:	1a9b      	subs	r3, r3, r2
 80052b8:	009b      	lsls	r3, r3, #2
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ba:	18ca      	adds	r2, r1, r3
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
 80052bc:	9b03      	ldr	r3, [sp, #12]
 80052be:	681b      	ldr	r3, [r3, #0]
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
                                                (timp->tm_min * 60) +
 80052c0:	4413      	add	r3, r2
                                                 timp->tm_sec) * 1000);
 80052c2:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80052c6:	fb02 f303 	mul.w	r3, r2, r3
  else {
    timespec->dstflag = (uint32_t)timp->tm_isdst;
  }
  /*lint -restore*/
  /*lint -save -e9033 [10.8] Verified assignments to bit fields.*/
  timespec->millisecond = tv_msec + (uint32_t)(((timp->tm_hour * 3600) +
 80052ca:	461a      	mov	r2, r3
 80052cc:	9b02      	ldr	r3, [sp, #8]
 80052ce:	4413      	add	r3, r2
 80052d0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 80052d4:	9a01      	ldr	r2, [sp, #4]
 80052d6:	6853      	ldr	r3, [r2, #4]
 80052d8:	f361 031a 	bfi	r3, r1, #0, #27
 80052dc:	6053      	str	r3, [r2, #4]
                                                (timp->tm_min * 60) +
                                                 timp->tm_sec) * 1000);
  /*lint -restore*/
}
 80052de:	b004      	add	sp, #16
 80052e0:	4770      	bx	lr
 80052e2:	bf00      	nop
 80052e4:	f3af 8000 	nop.w
 80052e8:	f3af 8000 	nop.w
 80052ec:	f3af 8000 	nop.w

080052f0 <rtcConvertDateTimeToFAT>:
 * @param[out] timespec pointer to a @p RTCDateTime structure
 * @return              FAT date/time value.
 *
 * @api
 */
uint32_t rtcConvertDateTimeToFAT(const RTCDateTime *timespec) {
 80052f0:	b088      	sub	sp, #32
 80052f2:	9001      	str	r0, [sp, #4]
  uint32_t fattime;
  uint32_t sec, min, hour, day, month;

  sec   = timespec->millisecond / 1000U;
 80052f4:	9b01      	ldr	r3, [sp, #4]
 80052f6:	685b      	ldr	r3, [r3, #4]
 80052f8:	f3c3 021a 	ubfx	r2, r3, #0, #27
 80052fc:	4b39      	ldr	r3, [pc, #228]	; (80053e4 <rtcConvertDateTimeToFAT+0xf4>)
 80052fe:	fba3 1302 	umull	r1, r3, r3, r2
 8005302:	099b      	lsrs	r3, r3, #6
 8005304:	9304      	str	r3, [sp, #16]
  hour  = sec / 3600U;
 8005306:	9a04      	ldr	r2, [sp, #16]
 8005308:	4b37      	ldr	r3, [pc, #220]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 800530a:	fba3 1302 	umull	r1, r3, r3, r2
 800530e:	0adb      	lsrs	r3, r3, #11
 8005310:	9307      	str	r3, [sp, #28]
  sec  %= 3600U;
 8005312:	9b04      	ldr	r3, [sp, #16]
 8005314:	4a34      	ldr	r2, [pc, #208]	; (80053e8 <rtcConvertDateTimeToFAT+0xf8>)
 8005316:	fba2 1203 	umull	r1, r2, r2, r3
 800531a:	0ad2      	lsrs	r2, r2, #11
 800531c:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 8005320:	fb01 f202 	mul.w	r2, r1, r2
 8005324:	1a9b      	subs	r3, r3, r2
 8005326:	9304      	str	r3, [sp, #16]
  min   = sec / 60U;
 8005328:	9a04      	ldr	r2, [sp, #16]
 800532a:	4b30      	ldr	r3, [pc, #192]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 800532c:	fba3 1302 	umull	r1, r3, r3, r2
 8005330:	095b      	lsrs	r3, r3, #5
 8005332:	9303      	str	r3, [sp, #12]
  sec  %= 60U;
 8005334:	9a04      	ldr	r2, [sp, #16]
 8005336:	4b2d      	ldr	r3, [pc, #180]	; (80053ec <rtcConvertDateTimeToFAT+0xfc>)
 8005338:	fba3 1302 	umull	r1, r3, r3, r2
 800533c:	0959      	lsrs	r1, r3, #5
 800533e:	460b      	mov	r3, r1
 8005340:	011b      	lsls	r3, r3, #4
 8005342:	1a5b      	subs	r3, r3, r1
 8005344:	009b      	lsls	r3, r3, #2
 8005346:	1ad3      	subs	r3, r2, r3
 8005348:	9304      	str	r3, [sp, #16]
  day   = timespec->day;
 800534a:	9b01      	ldr	r3, [sp, #4]
 800534c:	789b      	ldrb	r3, [r3, #2]
 800534e:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8005352:	b2db      	uxtb	r3, r3
 8005354:	9306      	str	r3, [sp, #24]
  month = timespec->month;
 8005356:	9b01      	ldr	r3, [sp, #4]
 8005358:	785b      	ldrb	r3, [r3, #1]
 800535a:	f3c3 0303 	ubfx	r3, r3, #0, #4
 800535e:	b2db      	uxtb	r3, r3
 8005360:	9305      	str	r3, [sp, #20]

  /* handle DST flag */
  if (1U == timespec->dstflag) {
 8005362:	9b01      	ldr	r3, [sp, #4]
 8005364:	785b      	ldrb	r3, [r3, #1]
 8005366:	f3c3 1300 	ubfx	r3, r3, #4, #1
 800536a:	b2db      	uxtb	r3, r3
 800536c:	2b01      	cmp	r3, #1
 800536e:	d117      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
    hour += 1U;
 8005370:	9b07      	ldr	r3, [sp, #28]
 8005372:	3301      	adds	r3, #1
 8005374:	9307      	str	r3, [sp, #28]
    if (hour == 24U) {
 8005376:	9b07      	ldr	r3, [sp, #28]
 8005378:	2b18      	cmp	r3, #24
 800537a:	d111      	bne.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
      hour = 0U;
 800537c:	2300      	movs	r3, #0
 800537e:	9307      	str	r3, [sp, #28]
      day += 1U;
 8005380:	9b06      	ldr	r3, [sp, #24]
 8005382:	3301      	adds	r3, #1
 8005384:	9306      	str	r3, [sp, #24]
      if (day > month_len[month - 1U]) {
 8005386:	9b05      	ldr	r3, [sp, #20]
 8005388:	3b01      	subs	r3, #1
 800538a:	4a19      	ldr	r2, [pc, #100]	; (80053f0 <rtcConvertDateTimeToFAT+0x100>)
 800538c:	5cd3      	ldrb	r3, [r2, r3]
 800538e:	461a      	mov	r2, r3
 8005390:	9b06      	ldr	r3, [sp, #24]
 8005392:	429a      	cmp	r2, r3
 8005394:	d204      	bcs.n	80053a0 <rtcConvertDateTimeToFAT+0xb0>
        day = 1U;
 8005396:	2301      	movs	r3, #1
 8005398:	9306      	str	r3, [sp, #24]
        month += 1U;
 800539a:	9b05      	ldr	r3, [sp, #20]
 800539c:	3301      	adds	r3, #1
 800539e:	9305      	str	r3, [sp, #20]
      }
    }
  }

  fattime  = sec   >> 1U;
 80053a0:	9b04      	ldr	r3, [sp, #16]
 80053a2:	085b      	lsrs	r3, r3, #1
 80053a4:	9302      	str	r3, [sp, #8]
  fattime |= min   << 5U;
 80053a6:	9b03      	ldr	r3, [sp, #12]
 80053a8:	015b      	lsls	r3, r3, #5
 80053aa:	9a02      	ldr	r2, [sp, #8]
 80053ac:	4313      	orrs	r3, r2
 80053ae:	9302      	str	r3, [sp, #8]
  fattime |= hour  << 11U;
 80053b0:	9b07      	ldr	r3, [sp, #28]
 80053b2:	02db      	lsls	r3, r3, #11
 80053b4:	9a02      	ldr	r2, [sp, #8]
 80053b6:	4313      	orrs	r3, r2
 80053b8:	9302      	str	r3, [sp, #8]
  fattime |= day   << 16U;
 80053ba:	9b06      	ldr	r3, [sp, #24]
 80053bc:	041b      	lsls	r3, r3, #16
 80053be:	9a02      	ldr	r2, [sp, #8]
 80053c0:	4313      	orrs	r3, r2
 80053c2:	9302      	str	r3, [sp, #8]
  fattime |= month << 21U;
 80053c4:	9b05      	ldr	r3, [sp, #20]
 80053c6:	055b      	lsls	r3, r3, #21
 80053c8:	9a02      	ldr	r2, [sp, #8]
 80053ca:	4313      	orrs	r3, r2
 80053cc:	9302      	str	r3, [sp, #8]
  fattime |= (uint32_t)timespec->year << 25U;
 80053ce:	9b01      	ldr	r3, [sp, #4]
 80053d0:	781b      	ldrb	r3, [r3, #0]
 80053d2:	065b      	lsls	r3, r3, #25
 80053d4:	9a02      	ldr	r2, [sp, #8]
 80053d6:	4313      	orrs	r3, r2
 80053d8:	9302      	str	r3, [sp, #8]

  return fattime;
 80053da:	9b02      	ldr	r3, [sp, #8]
}
 80053dc:	4618      	mov	r0, r3
 80053de:	b008      	add	sp, #32
 80053e0:	4770      	bx	lr
 80053e2:	bf00      	nop
 80053e4:	10624dd3 	.word	0x10624dd3
 80053e8:	91a2b3c5 	.word	0x91a2b3c5
 80053ec:	88888889 	.word	0x88888889
 80053f0:	08019440 	.word	0x08019440
 80053f4:	f3af 8000 	nop.w
 80053f8:	f3af 8000 	nop.w
 80053fc:	f3af 8000 	nop.w

08005400 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005400:	b082      	sub	sp, #8
 8005402:	2320      	movs	r3, #32
 8005404:	9301      	str	r3, [sp, #4]
 8005406:	9b01      	ldr	r3, [sp, #4]
 8005408:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800540c:	b002      	add	sp, #8
 800540e:	4770      	bx	lr

08005410 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005410:	b082      	sub	sp, #8
 8005412:	2300      	movs	r3, #0
 8005414:	9301      	str	r3, [sp, #4]
 8005416:	9b01      	ldr	r3, [sp, #4]
 8005418:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800541c:	b002      	add	sp, #8
 800541e:	4770      	bx	lr

08005420 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005420:	b508      	push	{r3, lr}

  port_lock();
 8005422:	f7ff ffed 	bl	8005400 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005426:	bd08      	pop	{r3, pc}
 8005428:	f3af 8000 	nop.w
 800542c:	f3af 8000 	nop.w

08005430 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005430:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005432:	f7ff ffed 	bl	8005410 <port_unlock>
}
 8005436:	bd08      	pop	{r3, pc}
 8005438:	f3af 8000 	nop.w
 800543c:	f3af 8000 	nop.w

08005440 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005440:	b508      	push	{r3, lr}

  chSysLock();
 8005442:	f7ff ffed 	bl	8005420 <chSysLock>
}
 8005446:	bd08      	pop	{r3, pc}
 8005448:	f3af 8000 	nop.w
 800544c:	f3af 8000 	nop.w

08005450 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005450:	b508      	push	{r3, lr}

  chSysUnlock();
 8005452:	f7ff ffed 	bl	8005430 <chSysUnlock>
}
 8005456:	bd08      	pop	{r3, pc}
 8005458:	f3af 8000 	nop.w
 800545c:	f3af 8000 	nop.w

08005460 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 8005460:	b500      	push	{lr}
 8005462:	b083      	sub	sp, #12
 8005464:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 8005466:	9801      	ldr	r0, [sp, #4]
 8005468:	f7fb ff32 	bl	80012d0 <chThdSleep>
}
 800546c:	b003      	add	sp, #12
 800546e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005472:	bf00      	nop
 8005474:	f3af 8000 	nop.w
 8005478:	f3af 8000 	nop.w
 800547c:	f3af 8000 	nop.w

08005480 <mode_detect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mode_detect(SDCDriver *sdcp) {
 8005480:	b500      	push	{lr}
 8005482:	b085      	sub	sp, #20
 8005484:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  /* V2.0 cards detection.*/
  if (!sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_IF_COND,
 8005486:	ab03      	add	r3, sp, #12
 8005488:	9801      	ldr	r0, [sp, #4]
 800548a:	2108      	movs	r1, #8
 800548c:	f44f 72d5 	mov.w	r2, #426	; 0x1aa
 8005490:	f005 fa36 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005494:	4603      	mov	r3, r0
 8005496:	f083 0301 	eor.w	r3, r3, #1
 800549a:	b2db      	uxtb	r3, r3
 800549c:	2b00      	cmp	r3, #0
 800549e:	d01a      	beq.n	80054d6 <mode_detect+0x56>
                                  MMCSD_CMD8_PATTERN, resp)) {
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
 80054a0:	9b01      	ldr	r3, [sp, #4]
 80054a2:	2201      	movs	r2, #1
 80054a4:	631a      	str	r2, [r3, #48]	; 0x30
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
 80054a6:	9b03      	ldr	r3, [sp, #12]
 80054a8:	0a1b      	lsrs	r3, r3, #8
 80054aa:	f003 030f 	and.w	r3, r3, #15
 80054ae:	2b01      	cmp	r3, #1
 80054b0:	d001      	beq.n	80054b6 <mode_detect+0x36>
      return HAL_FAILED;
 80054b2:	2301      	movs	r3, #1
 80054b4:	e02a      	b.n	800550c <mode_detect+0x8c>
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054b6:	ab03      	add	r3, sp, #12
 80054b8:	9801      	ldr	r0, [sp, #4]
 80054ba:	2137      	movs	r1, #55	; 0x37
 80054bc:	2200      	movs	r2, #0
 80054be:	f005 fa1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054c2:	4603      	mov	r3, r0
 80054c4:	2b00      	cmp	r3, #0
 80054c6:	d104      	bne.n	80054d2 <mode_detect+0x52>
        MMCSD_R1_ERROR(resp[0])) {
 80054c8:	9a03      	ldr	r2, [sp, #12]
 80054ca:	4b12      	ldr	r3, [pc, #72]	; (8005514 <mode_detect+0x94>)
 80054cc:	4013      	ands	r3, r2
    sdcp->cardmode = SDC_MODE_CARDTYPE_SDV20;
    /* Voltage verification.*/
    if (((resp[0] >> 8U) & 0xFU) != 1U) {
      return HAL_FAILED;
    }
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ce:	2b00      	cmp	r3, #0
 80054d0:	d01b      	beq.n	800550a <mode_detect+0x8a>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80054d2:	2301      	movs	r3, #1
 80054d4:	e01a      	b.n	800550c <mode_detect+0x8c>
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054d6:	ab03      	add	r3, sp, #12
 80054d8:	9801      	ldr	r0, [sp, #4]
 80054da:	2137      	movs	r1, #55	; 0x37
 80054dc:	2200      	movs	r2, #0
 80054de:	f005 fa0f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80054e2:	4603      	mov	r3, r0
 80054e4:	2b00      	cmp	r3, #0
 80054e6:	d104      	bne.n	80054f2 <mode_detect+0x72>
        MMCSD_R1_ERROR(resp[0])) {
 80054e8:	9a03      	ldr	r2, [sp, #12]
 80054ea:	4b0a      	ldr	r3, [pc, #40]	; (8005514 <mode_detect+0x94>)
 80054ec:	4013      	ands	r3, r2
      return HAL_FAILED;
    }
  }
  else {
    /* MMC or SD V1.1 detection.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80054ee:	2b00      	cmp	r3, #0
 80054f0:	d003      	beq.n	80054fa <mode_detect+0x7a>
        MMCSD_R1_ERROR(resp[0])) {
      sdcp->cardmode = SDC_MODE_CARDTYPE_MMC;
 80054f2:	9b01      	ldr	r3, [sp, #4]
 80054f4:	2202      	movs	r2, #2
 80054f6:	631a      	str	r2, [r3, #48]	; 0x30
 80054f8:	e007      	b.n	800550a <mode_detect+0x8a>
    }
    else {
      sdcp->cardmode = SDC_MODE_CARDTYPE_SDV11;
 80054fa:	9b01      	ldr	r3, [sp, #4]
 80054fc:	2200      	movs	r2, #0
 80054fe:	631a      	str	r2, [r3, #48]	; 0x30
    
      /* Reset error flag illegal command.*/
      sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005500:	9801      	ldr	r0, [sp, #4]
 8005502:	2100      	movs	r1, #0
 8005504:	2200      	movs	r2, #0
 8005506:	f005 f99b 	bl	800a840 <sdc_lld_send_cmd_none>
    }
  }

  return HAL_SUCCESS;
 800550a:	2300      	movs	r3, #0
}
 800550c:	4618      	mov	r0, r3
 800550e:	b005      	add	sp, #20
 8005510:	f85d fb04 	ldr.w	pc, [sp], #4
 8005514:	fdffe008 	.word	0xfdffe008
 8005518:	f3af 8000 	nop.w
 800551c:	f3af 8000 	nop.w

08005520 <mmc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_init(SDCDriver *sdcp) {
 8005520:	b500      	push	{lr}
 8005522:	b087      	sub	sp, #28
 8005524:	9001      	str	r0, [sp, #4]
  uint32_t ocr;
  unsigned i;
  uint32_t resp[1];

  ocr = 0xC0FF8000U;
 8005526:	4b18      	ldr	r3, [pc, #96]	; (8005588 <mmc_init+0x68>)
 8005528:	9304      	str	r3, [sp, #16]
  i = 0;
 800552a:	2300      	movs	r3, #0
 800552c:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_INIT, ocr, resp)) {
 800552e:	ab03      	add	r3, sp, #12
 8005530:	9801      	ldr	r0, [sp, #4]
 8005532:	2101      	movs	r1, #1
 8005534:	9a04      	ldr	r2, [sp, #16]
 8005536:	f005 f9a3 	bl	800a880 <sdc_lld_send_cmd_short>
 800553a:	4603      	mov	r3, r0
 800553c:	2b00      	cmp	r3, #0
 800553e:	d001      	beq.n	8005544 <mmc_init+0x24>
      return HAL_FAILED;
 8005540:	2301      	movs	r3, #1
 8005542:	e01c      	b.n	800557e <mmc_init+0x5e>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 8005544:	9b03      	ldr	r3, [sp, #12]
 8005546:	2b00      	cmp	r3, #0
 8005548:	da0c      	bge.n	8005564 <mmc_init+0x44>
      if ((resp[0] & 0x40000000U) != 0U) {
 800554a:	9b03      	ldr	r3, [sp, #12]
 800554c:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 8005550:	2b00      	cmp	r3, #0
 8005552:	d006      	beq.n	8005562 <mmc_init+0x42>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 8005554:	9b01      	ldr	r3, [sp, #4]
 8005556:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005558:	f043 0210 	orr.w	r2, r3, #16
 800555c:	9b01      	ldr	r3, [sp, #4]
 800555e:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005560:	e00c      	b.n	800557c <mmc_init+0x5c>
 8005562:	e00b      	b.n	800557c <mmc_init+0x5c>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005564:	9b05      	ldr	r3, [sp, #20]
 8005566:	3301      	adds	r3, #1
 8005568:	9305      	str	r3, [sp, #20]
 800556a:	9b05      	ldr	r3, [sp, #20]
 800556c:	2b63      	cmp	r3, #99	; 0x63
 800556e:	d901      	bls.n	8005574 <mmc_init+0x54>
      return HAL_FAILED;
 8005570:	2301      	movs	r3, #1
 8005572:	e004      	b.n	800557e <mmc_init+0x5e>
    }
    osalThreadSleepMilliseconds(10);
 8005574:	200a      	movs	r0, #10
 8005576:	f7ff ff73 	bl	8005460 <osalThreadSleep>
  }
 800557a:	e7d8      	b.n	800552e <mmc_init+0xe>

  return HAL_SUCCESS;
 800557c:	2300      	movs	r3, #0
}
 800557e:	4618      	mov	r0, r3
 8005580:	b007      	add	sp, #28
 8005582:	f85d fb04 	ldr.w	pc, [sp], #4
 8005586:	bf00      	nop
 8005588:	c0ff8000 	.word	0xc0ff8000
 800558c:	f3af 8000 	nop.w

08005590 <sdc_init>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_init(SDCDriver *sdcp) {
 8005590:	b500      	push	{lr}
 8005592:	b087      	sub	sp, #28
 8005594:	9001      	str	r0, [sp, #4]
  unsigned i;
  uint32_t ocr;
  uint32_t resp[1];

  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_SDV20) {
 8005596:	9b01      	ldr	r3, [sp, #4]
 8005598:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800559a:	f003 030f 	and.w	r3, r3, #15
 800559e:	2b01      	cmp	r3, #1
 80055a0:	d102      	bne.n	80055a8 <sdc_init+0x18>
    ocr = 0xC0100000U;
 80055a2:	4b21      	ldr	r3, [pc, #132]	; (8005628 <sdc_init+0x98>)
 80055a4:	9304      	str	r3, [sp, #16]
 80055a6:	e001      	b.n	80055ac <sdc_init+0x1c>
  }
  else {
    ocr = 0x80100000U;
 80055a8:	4b20      	ldr	r3, [pc, #128]	; (800562c <sdc_init+0x9c>)
 80055aa:	9304      	str	r3, [sp, #16]
  }

  i = 0;
 80055ac:	2300      	movs	r3, #0
 80055ae:	9305      	str	r3, [sp, #20]
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055b0:	ab03      	add	r3, sp, #12
 80055b2:	9801      	ldr	r0, [sp, #4]
 80055b4:	2137      	movs	r1, #55	; 0x37
 80055b6:	2200      	movs	r2, #0
 80055b8:	f005 f9a2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80055bc:	4603      	mov	r3, r0
 80055be:	2b00      	cmp	r3, #0
 80055c0:	d104      	bne.n	80055cc <sdc_init+0x3c>
        MMCSD_R1_ERROR(resp[0])) {
 80055c2:	9a03      	ldr	r2, [sp, #12]
 80055c4:	4b1a      	ldr	r3, [pc, #104]	; (8005630 <sdc_init+0xa0>)
 80055c6:	4013      	ands	r3, r2
    ocr = 0x80100000U;
  }

  i = 0;
  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, 0, resp) ||
 80055c8:	2b00      	cmp	r3, #0
 80055ca:	d001      	beq.n	80055d0 <sdc_init+0x40>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 80055cc:	2301      	movs	r3, #1
 80055ce:	e027      	b.n	8005620 <sdc_init+0x90>
    }
    if (sdc_lld_send_cmd_short(sdcp, MMCSD_CMD_APP_OP_COND, ocr, resp)) {
 80055d0:	ab03      	add	r3, sp, #12
 80055d2:	9801      	ldr	r0, [sp, #4]
 80055d4:	2129      	movs	r1, #41	; 0x29
 80055d6:	9a04      	ldr	r2, [sp, #16]
 80055d8:	f005 f952 	bl	800a880 <sdc_lld_send_cmd_short>
 80055dc:	4603      	mov	r3, r0
 80055de:	2b00      	cmp	r3, #0
 80055e0:	d001      	beq.n	80055e6 <sdc_init+0x56>
      return HAL_FAILED;
 80055e2:	2301      	movs	r3, #1
 80055e4:	e01c      	b.n	8005620 <sdc_init+0x90>
    }
    if ((resp[0] & 0x80000000U) != 0U) {
 80055e6:	9b03      	ldr	r3, [sp, #12]
 80055e8:	2b00      	cmp	r3, #0
 80055ea:	da0c      	bge.n	8005606 <sdc_init+0x76>
      if ((resp[0] & 0x40000000U) != 0U) {
 80055ec:	9b03      	ldr	r3, [sp, #12]
 80055ee:	f003 4380 	and.w	r3, r3, #1073741824	; 0x40000000
 80055f2:	2b00      	cmp	r3, #0
 80055f4:	d006      	beq.n	8005604 <sdc_init+0x74>
        sdcp->cardmode |= SDC_MODE_HIGH_CAPACITY;
 80055f6:	9b01      	ldr	r3, [sp, #4]
 80055f8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80055fa:	f043 0210 	orr.w	r2, r3, #16
 80055fe:	9b01      	ldr	r3, [sp, #4]
 8005600:	631a      	str	r2, [r3, #48]	; 0x30
      }
      break;
 8005602:	e00c      	b.n	800561e <sdc_init+0x8e>
 8005604:	e00b      	b.n	800561e <sdc_init+0x8e>
    }
    if (++i >= (unsigned)SDC_INIT_RETRY) {
 8005606:	9b05      	ldr	r3, [sp, #20]
 8005608:	3301      	adds	r3, #1
 800560a:	9305      	str	r3, [sp, #20]
 800560c:	9b05      	ldr	r3, [sp, #20]
 800560e:	2b63      	cmp	r3, #99	; 0x63
 8005610:	d901      	bls.n	8005616 <sdc_init+0x86>
      return HAL_FAILED;
 8005612:	2301      	movs	r3, #1
 8005614:	e004      	b.n	8005620 <sdc_init+0x90>
    }
    osalThreadSleepMilliseconds(10);
 8005616:	200a      	movs	r0, #10
 8005618:	f7ff ff22 	bl	8005460 <osalThreadSleep>
  }
 800561c:	e7c8      	b.n	80055b0 <sdc_init+0x20>

  return HAL_SUCCESS;
 800561e:	2300      	movs	r3, #0
}
 8005620:	4618      	mov	r0, r3
 8005622:	b007      	add	sp, #28
 8005624:	f85d fb04 	ldr.w	pc, [sp], #4
 8005628:	c0100000 	.word	0xc0100000
 800562c:	80100000 	.word	0x80100000
 8005630:	fdffe008 	.word	0xfdffe008
 8005634:	f3af 8000 	nop.w
 8005638:	f3af 8000 	nop.w
 800563c:	f3af 8000 	nop.w

08005640 <mmc_cmd6_construct>:
 * @return              CMD6 argument.
 *
 * @notapi
 */
static uint32_t mmc_cmd6_construct(mmc_switch_t access, uint32_t idx,
                                   uint32_t value, uint32_t cmd_set) {
 8005640:	b084      	sub	sp, #16
 8005642:	9102      	str	r1, [sp, #8]
 8005644:	9201      	str	r2, [sp, #4]
 8005646:	9300      	str	r3, [sp, #0]
 8005648:	4603      	mov	r3, r0
 800564a:	f88d 300f 	strb.w	r3, [sp, #15]

  osalDbgAssert(idx <= 191U, "This field is not writable");
  osalDbgAssert(cmd_set < 8U, "This field has only 3 bits");

  return ((uint32_t)access << 24U) | (idx << 16U) | (value << 8U) | cmd_set;
 800564e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8005652:	061a      	lsls	r2, r3, #24
 8005654:	9b02      	ldr	r3, [sp, #8]
 8005656:	041b      	lsls	r3, r3, #16
 8005658:	431a      	orrs	r2, r3
 800565a:	9b01      	ldr	r3, [sp, #4]
 800565c:	021b      	lsls	r3, r3, #8
 800565e:	431a      	orrs	r2, r3
 8005660:	9b00      	ldr	r3, [sp, #0]
 8005662:	4313      	orrs	r3, r2
}
 8005664:	4618      	mov	r0, r3
 8005666:	b004      	add	sp, #16
 8005668:	4770      	bx	lr
 800566a:	bf00      	nop
 800566c:	f3af 8000 	nop.w

08005670 <sdc_cmd6_construct>:
 *
 * @notapi
 */
static uint32_t sdc_cmd6_construct(sd_switch_t mode,
                                   sd_switch_function_t function,
                                   uint32_t value) {
 8005670:	b084      	sub	sp, #16
 8005672:	460b      	mov	r3, r1
 8005674:	9200      	str	r2, [sp, #0]
 8005676:	4602      	mov	r2, r0
 8005678:	f88d 2007 	strb.w	r2, [sp, #7]
 800567c:	f88d 3006 	strb.w	r3, [sp, #6]
  uint32_t ret = 0xFFFFFF;
 8005680:	f06f 437f 	mvn.w	r3, #4278190080	; 0xff000000
 8005684:	9303      	str	r3, [sp, #12]

  osalDbgAssert((value < 16U), "This field has only 4 bits");

  ret &= ~((uint32_t)0xFU << ((uint32_t)function * 4U));
 8005686:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800568a:	009b      	lsls	r3, r3, #2
 800568c:	220f      	movs	r2, #15
 800568e:	fa02 f303 	lsl.w	r3, r2, r3
 8005692:	43db      	mvns	r3, r3
 8005694:	9a03      	ldr	r2, [sp, #12]
 8005696:	4013      	ands	r3, r2
 8005698:	9303      	str	r3, [sp, #12]
  ret |= value << ((uint32_t)function * 4U);
 800569a:	f89d 3006 	ldrb.w	r3, [sp, #6]
 800569e:	009b      	lsls	r3, r3, #2
 80056a0:	9a00      	ldr	r2, [sp, #0]
 80056a2:	fa02 f303 	lsl.w	r3, r2, r3
 80056a6:	9a03      	ldr	r2, [sp, #12]
 80056a8:	4313      	orrs	r3, r2
 80056aa:	9303      	str	r3, [sp, #12]
  return ret | ((uint32_t)mode << 31U);
 80056ac:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80056b0:	07da      	lsls	r2, r3, #31
 80056b2:	9b03      	ldr	r3, [sp, #12]
 80056b4:	4313      	orrs	r3, r2
}
 80056b6:	4618      	mov	r0, r3
 80056b8:	b004      	add	sp, #16
 80056ba:	4770      	bx	lr
 80056bc:	f3af 8000 	nop.w

080056c0 <sdc_cmd6_extract_info>:
 * @return              extracted answer.
 *
 * @notapi
 */
static uint16_t sdc_cmd6_extract_info(sd_switch_function_t function,
                                      const uint8_t *buf) {
 80056c0:	b084      	sub	sp, #16
 80056c2:	4603      	mov	r3, r0
 80056c4:	9100      	str	r1, [sp, #0]
 80056c6:	f88d 3007 	strb.w	r3, [sp, #7]

  unsigned start = 12U - ((unsigned)function * 2U);
 80056ca:	f89d 2007 	ldrb.w	r2, [sp, #7]
 80056ce:	4613      	mov	r3, r2
 80056d0:	07db      	lsls	r3, r3, #31
 80056d2:	1a9b      	subs	r3, r3, r2
 80056d4:	005b      	lsls	r3, r3, #1
 80056d6:	330c      	adds	r3, #12
 80056d8:	9303      	str	r3, [sp, #12]

  return ((uint16_t)buf[start] << 8U) | (uint16_t)buf[start + 1U];
 80056da:	9a00      	ldr	r2, [sp, #0]
 80056dc:	9b03      	ldr	r3, [sp, #12]
 80056de:	4413      	add	r3, r2
 80056e0:	781b      	ldrb	r3, [r3, #0]
 80056e2:	021b      	lsls	r3, r3, #8
 80056e4:	b29a      	uxth	r2, r3
 80056e6:	9b03      	ldr	r3, [sp, #12]
 80056e8:	3301      	adds	r3, #1
 80056ea:	9900      	ldr	r1, [sp, #0]
 80056ec:	440b      	add	r3, r1
 80056ee:	781b      	ldrb	r3, [r3, #0]
 80056f0:	4313      	orrs	r3, r2
 80056f2:	b29b      	uxth	r3, r3
 80056f4:	b29b      	uxth	r3, r3
}
 80056f6:	4618      	mov	r0, r3
 80056f8:	b004      	add	sp, #16
 80056fa:	4770      	bx	lr
 80056fc:	f3af 8000 	nop.w

08005700 <sdc_cmd6_check_status>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_cmd6_check_status(sd_switch_function_t function,
                                 const uint8_t *buf) {
 8005700:	b084      	sub	sp, #16
 8005702:	4603      	mov	r3, r0
 8005704:	9100      	str	r1, [sp, #0]
 8005706:	f88d 3007 	strb.w	r3, [sp, #7]

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800570a:	9b00      	ldr	r3, [sp, #0]
 800570c:	330e      	adds	r3, #14
 800570e:	781b      	ldrb	r3, [r3, #0]
 8005710:	041a      	lsls	r2, r3, #16
        ((uint32_t)buf[15] << 8U) |
 8005712:	9b00      	ldr	r3, [sp, #0]
 8005714:	330f      	adds	r3, #15
 8005716:	781b      	ldrb	r3, [r3, #0]
 8005718:	021b      	lsls	r3, r3, #8
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 800571a:	431a      	orrs	r2, r3
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
 800571c:	9b00      	ldr	r3, [sp, #0]
 800571e:	3310      	adds	r3, #16
 8005720:	781b      	ldrb	r3, [r3, #0]
                                 const uint8_t *buf) {

  uint32_t tmp;
  uint32_t status;

  tmp = ((uint32_t)buf[14] << 16U) |
 8005722:	4313      	orrs	r3, r2
 8005724:	9303      	str	r3, [sp, #12]
        ((uint32_t)buf[15] << 8U) |
        (uint32_t)buf[16];
  status = (tmp >> ((uint32_t)function * 4U)) & 0xFU;
 8005726:	f89d 3007 	ldrb.w	r3, [sp, #7]
 800572a:	009b      	lsls	r3, r3, #2
 800572c:	9a03      	ldr	r2, [sp, #12]
 800572e:	fa22 f303 	lsr.w	r3, r2, r3
 8005732:	f003 030f 	and.w	r3, r3, #15
 8005736:	9302      	str	r3, [sp, #8]
  if (0xFU != status) {
 8005738:	9b02      	ldr	r3, [sp, #8]
 800573a:	2b0f      	cmp	r3, #15
 800573c:	d001      	beq.n	8005742 <sdc_cmd6_check_status+0x42>
    return HAL_SUCCESS;
 800573e:	2300      	movs	r3, #0
 8005740:	e000      	b.n	8005744 <sdc_cmd6_check_status+0x44>
  }
  return HAL_FAILED;
 8005742:	2301      	movs	r3, #1
}
 8005744:	4618      	mov	r0, r3
 8005746:	b004      	add	sp, #16
 8005748:	4770      	bx	lr
 800574a:	bf00      	nop
 800574c:	f3af 8000 	nop.w

08005750 <sdc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005750:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005752:	b089      	sub	sp, #36	; 0x24
 8005754:	af02      	add	r7, sp, #8
 8005756:	6078      	str	r0, [r7, #4]
 8005758:	6039      	str	r1, [r7, #0]
 800575a:	4669      	mov	r1, sp
 800575c:	460e      	mov	r6, r1
  uint32_t cmdarg;
  const size_t N = 64;
 800575e:	2140      	movs	r1, #64	; 0x40
 8005760:	6179      	str	r1, [r7, #20]
  uint8_t tmp[N];
 8005762:	6979      	ldr	r1, [r7, #20]
 8005764:	3901      	subs	r1, #1
 8005766:	6139      	str	r1, [r7, #16]
 8005768:	6979      	ldr	r1, [r7, #20]
 800576a:	4608      	mov	r0, r1
 800576c:	f04f 0100 	mov.w	r1, #0
 8005770:	00cd      	lsls	r5, r1, #3
 8005772:	ea45 7550 	orr.w	r5, r5, r0, lsr #29
 8005776:	00c4      	lsls	r4, r0, #3
 8005778:	6979      	ldr	r1, [r7, #20]
 800577a:	4608      	mov	r0, r1
 800577c:	f04f 0100 	mov.w	r1, #0
 8005780:	00cb      	lsls	r3, r1, #3
 8005782:	ea43 7350 	orr.w	r3, r3, r0, lsr #29
 8005786:	00c2      	lsls	r2, r0, #3
 8005788:	697b      	ldr	r3, [r7, #20]
 800578a:	3307      	adds	r3, #7
 800578c:	08db      	lsrs	r3, r3, #3
 800578e:	00db      	lsls	r3, r3, #3
 8005790:	ebad 0d03 	sub.w	sp, sp, r3
 8005794:	ab02      	add	r3, sp, #8
 8005796:	3300      	adds	r3, #0
 8005798:	60fb      	str	r3, [r7, #12]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 800579a:	683b      	ldr	r3, [r7, #0]
 800579c:	2200      	movs	r2, #0
 800579e:	701a      	strb	r2, [r3, #0]

  /* Looks like only "high capacity" cards produce meaningful results during
     this clock detection procedure.*/
  if (0U == _mmcsd_get_slice(sdcp->csd, MMCSD_CSD_10_CSD_STRUCTURE_SLICE)) {
 80057a0:	687b      	ldr	r3, [r7, #4]
 80057a2:	3318      	adds	r3, #24
 80057a4:	4618      	mov	r0, r3
 80057a6:	217f      	movs	r1, #127	; 0x7f
 80057a8:	227e      	movs	r2, #126	; 0x7e
 80057aa:	f7fe ff69 	bl	8004680 <_mmcsd_get_slice>
 80057ae:	4603      	mov	r3, r0
 80057b0:	2b00      	cmp	r3, #0
 80057b2:	d104      	bne.n	80057be <sdc_detect_bus_clk+0x6e>
    *clk = SDC_CLK_25MHz;
 80057b4:	683b      	ldr	r3, [r7, #0]
 80057b6:	2200      	movs	r2, #0
 80057b8:	701a      	strb	r2, [r3, #0]
    return HAL_SUCCESS;
 80057ba:	2300      	movs	r3, #0
 80057bc:	e03e      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Read switch functions' register.*/
  if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, 0)) {
 80057be:	68fb      	ldr	r3, [r7, #12]
 80057c0:	2200      	movs	r2, #0
 80057c2:	9200      	str	r2, [sp, #0]
 80057c4:	6878      	ldr	r0, [r7, #4]
 80057c6:	4619      	mov	r1, r3
 80057c8:	697a      	ldr	r2, [r7, #20]
 80057ca:	2306      	movs	r3, #6
 80057cc:	f005 f928 	bl	800aa20 <sdc_lld_read_special>
 80057d0:	4603      	mov	r3, r0
 80057d2:	2b00      	cmp	r3, #0
 80057d4:	d001      	beq.n	80057da <sdc_detect_bus_clk+0x8a>
    return HAL_FAILED;
 80057d6:	2301      	movs	r3, #1
 80057d8:	e030      	b.n	800583c <sdc_detect_bus_clk+0xec>
  }

  /* Check card capabilities parsing acquired data.*/
  if ((sdc_cmd6_extract_info(SD_SWITCH_FUNCTION_SPEED, tmp) & 2U) == 2U) {
 80057da:	68fb      	ldr	r3, [r7, #12]
 80057dc:	2000      	movs	r0, #0
 80057de:	4619      	mov	r1, r3
 80057e0:	f7ff ff6e 	bl	80056c0 <sdc_cmd6_extract_info>
 80057e4:	4603      	mov	r3, r0
 80057e6:	f003 0302 	and.w	r3, r3, #2
 80057ea:	2b00      	cmp	r3, #0
 80057ec:	d025      	beq.n	800583a <sdc_detect_bus_clk+0xea>
    /* Construct command to set the bus speed.*/
    cmdarg = sdc_cmd6_construct(SD_SWITCH_SET, SD_SWITCH_FUNCTION_SPEED, 1);
 80057ee:	2001      	movs	r0, #1
 80057f0:	2100      	movs	r1, #0
 80057f2:	2201      	movs	r2, #1
 80057f4:	f7ff ff3c 	bl	8005670 <sdc_cmd6_construct>
 80057f8:	60b8      	str	r0, [r7, #8]

    /* Write constructed command and read operation status in single call.*/
    if (sdc_lld_read_special(sdcp, tmp, N, MMCSD_CMD_SWITCH, cmdarg)) {
 80057fa:	68fb      	ldr	r3, [r7, #12]
 80057fc:	68ba      	ldr	r2, [r7, #8]
 80057fe:	9200      	str	r2, [sp, #0]
 8005800:	6878      	ldr	r0, [r7, #4]
 8005802:	4619      	mov	r1, r3
 8005804:	697a      	ldr	r2, [r7, #20]
 8005806:	2306      	movs	r3, #6
 8005808:	f005 f90a 	bl	800aa20 <sdc_lld_read_special>
 800580c:	4603      	mov	r3, r0
 800580e:	2b00      	cmp	r3, #0
 8005810:	d001      	beq.n	8005816 <sdc_detect_bus_clk+0xc6>
      return HAL_FAILED;
 8005812:	2301      	movs	r3, #1
 8005814:	e012      	b.n	800583c <sdc_detect_bus_clk+0xec>
    }

    /* Check card answer for success status bits.*/
    if (HAL_SUCCESS == sdc_cmd6_check_status(SD_SWITCH_FUNCTION_SPEED, tmp)) {
 8005816:	68fb      	ldr	r3, [r7, #12]
 8005818:	2000      	movs	r0, #0
 800581a:	4619      	mov	r1, r3
 800581c:	f7ff ff70 	bl	8005700 <sdc_cmd6_check_status>
 8005820:	4603      	mov	r3, r0
 8005822:	f083 0301 	eor.w	r3, r3, #1
 8005826:	b2db      	uxtb	r3, r3
 8005828:	2b00      	cmp	r3, #0
 800582a:	d003      	beq.n	8005834 <sdc_detect_bus_clk+0xe4>
      *clk = SDC_CLK_50MHz;
 800582c:	683b      	ldr	r3, [r7, #0]
 800582e:	2201      	movs	r2, #1
 8005830:	701a      	strb	r2, [r3, #0]
 8005832:	e002      	b.n	800583a <sdc_detect_bus_clk+0xea>
    }
    else {
      *clk = SDC_CLK_25MHz;
 8005834:	683b      	ldr	r3, [r7, #0]
 8005836:	2200      	movs	r2, #0
 8005838:	701a      	strb	r2, [r3, #0]
    }
  }

  return HAL_SUCCESS;
 800583a:	2300      	movs	r3, #0
 800583c:	46b5      	mov	sp, r6
}
 800583e:	4618      	mov	r0, r3
 8005840:	371c      	adds	r7, #28
 8005842:	46bd      	mov	sp, r7
 8005844:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005846:	bf00      	nop
 8005848:	f3af 8000 	nop.w
 800584c:	f3af 8000 	nop.w

08005850 <mmc_detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 8005850:	b500      	push	{lr}
 8005852:	b087      	sub	sp, #28
 8005854:	9001      	str	r0, [sp, #4]
 8005856:	9100      	str	r1, [sp, #0]
  uint32_t cmdarg;
  uint32_t resp[1];
  uint8_t *scratchpad = sdcp->config->scratchpad;
 8005858:	9b01      	ldr	r3, [sp, #4]
 800585a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800585c:	681b      	ldr	r3, [r3, #0]
 800585e:	9305      	str	r3, [sp, #20]

  /* Safe default.*/
  *clk = SDC_CLK_25MHz;
 8005860:	9b00      	ldr	r3, [sp, #0]
 8005862:	2200      	movs	r2, #0
 8005864:	701a      	strb	r2, [r3, #0]

  /* Use safe default when there is no space for data.*/
  if (NULL == scratchpad) {
 8005866:	9b05      	ldr	r3, [sp, #20]
 8005868:	2b00      	cmp	r3, #0
 800586a:	d101      	bne.n	8005870 <mmc_detect_bus_clk+0x20>
    return HAL_SUCCESS;
 800586c:	2300      	movs	r3, #0
 800586e:	e01b      	b.n	80058a8 <mmc_detect_bus_clk+0x58>
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
 8005870:	2003      	movs	r0, #3
 8005872:	21b9      	movs	r1, #185	; 0xb9
 8005874:	2201      	movs	r2, #1
 8005876:	2300      	movs	r3, #0
 8005878:	f7ff fee2 	bl	8005640 <mmc_cmd6_construct>
 800587c:	9004      	str	r0, [sp, #16]
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800587e:	ab03      	add	r3, sp, #12
 8005880:	9801      	ldr	r0, [sp, #4]
 8005882:	2106      	movs	r1, #6
 8005884:	9a04      	ldr	r2, [sp, #16]
 8005886:	f005 f83b 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800588a:	4603      	mov	r3, r0
 800588c:	f083 0301 	eor.w	r3, r3, #1
 8005890:	b2db      	uxtb	r3, r3
 8005892:	2b00      	cmp	r3, #0
 8005894:	d007      	beq.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
 8005896:	9a03      	ldr	r2, [sp, #12]
 8005898:	4b05      	ldr	r3, [pc, #20]	; (80058b0 <mmc_detect_bus_clk+0x60>)
 800589a:	4013      	ands	r3, r2
  if (NULL == scratchpad) {
    return HAL_SUCCESS;
  }

  cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 185, 1, 0);
  if (!(sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 800589c:	2b00      	cmp	r3, #0
 800589e:	d102      	bne.n	80058a6 <mmc_detect_bus_clk+0x56>
                                   MMCSD_R1_ERROR(resp[0]))) {
    *clk = SDC_CLK_50MHz;
 80058a0:	9b00      	ldr	r3, [sp, #0]
 80058a2:	2201      	movs	r2, #1
 80058a4:	701a      	strb	r2, [r3, #0]
  }

  return HAL_SUCCESS;
 80058a6:	2300      	movs	r3, #0
}
 80058a8:	4618      	mov	r0, r3
 80058aa:	b007      	add	sp, #28
 80058ac:	f85d fb04 	ldr.w	pc, [sp], #4
 80058b0:	fdffe008 	.word	0xfdffe008
 80058b4:	f3af 8000 	nop.w
 80058b8:	f3af 8000 	nop.w
 80058bc:	f3af 8000 	nop.w

080058c0 <detect_bus_clk>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool detect_bus_clk(SDCDriver *sdcp, sdcbusclk_t *clk) {
 80058c0:	b500      	push	{lr}
 80058c2:	b083      	sub	sp, #12
 80058c4:	9001      	str	r0, [sp, #4]
 80058c6:	9100      	str	r1, [sp, #0]

  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 80058c8:	9b01      	ldr	r3, [sp, #4]
 80058ca:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80058cc:	f003 030f 	and.w	r3, r3, #15
 80058d0:	2b02      	cmp	r3, #2
 80058d2:	d105      	bne.n	80058e0 <detect_bus_clk+0x20>
    return mmc_detect_bus_clk(sdcp, clk);
 80058d4:	9801      	ldr	r0, [sp, #4]
 80058d6:	9900      	ldr	r1, [sp, #0]
 80058d8:	f7ff ffba 	bl	8005850 <mmc_detect_bus_clk>
 80058dc:	4603      	mov	r3, r0
 80058de:	e004      	b.n	80058ea <detect_bus_clk+0x2a>
  }
  return sdc_detect_bus_clk(sdcp, clk);
 80058e0:	9801      	ldr	r0, [sp, #4]
 80058e2:	9900      	ldr	r1, [sp, #0]
 80058e4:	f7ff ff34 	bl	8005750 <sdc_detect_bus_clk>
 80058e8:	4603      	mov	r3, r0
}
 80058ea:	4618      	mov	r0, r3
 80058ec:	b003      	add	sp, #12
 80058ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80058f2:	bf00      	nop
 80058f4:	f3af 8000 	nop.w
 80058f8:	f3af 8000 	nop.w
 80058fc:	f3af 8000 	nop.w

08005900 <sdc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_set_bus_width(SDCDriver *sdcp) {
 8005900:	b500      	push	{lr}
 8005902:	b085      	sub	sp, #20
 8005904:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  if (SDC_MODE_1BIT == sdcp->config->bus_width) {
 8005906:	9b01      	ldr	r3, [sp, #4]
 8005908:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800590a:	791b      	ldrb	r3, [r3, #4]
 800590c:	2b00      	cmp	r3, #0
 800590e:	d101      	bne.n	8005914 <sdc_set_bus_width+0x14>
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 8005910:	2300      	movs	r3, #0
 8005912:	e02c      	b.n	800596e <sdc_set_bus_width+0x6e>
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
 8005914:	9b01      	ldr	r3, [sp, #4]
 8005916:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005918:	791b      	ldrb	r3, [r3, #4]
 800591a:	2b01      	cmp	r3, #1
 800591c:	d124      	bne.n	8005968 <sdc_set_bus_width+0x68>
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
 800591e:	9801      	ldr	r0, [sp, #4]
 8005920:	2101      	movs	r1, #1
 8005922:	f004 ff65 	bl	800a7f0 <sdc_lld_set_bus_mode>
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005926:	9b01      	ldr	r3, [sp, #4]
 8005928:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 800592a:	ab03      	add	r3, sp, #12
 800592c:	9801      	ldr	r0, [sp, #4]
 800592e:	2137      	movs	r1, #55	; 0x37
 8005930:	f004 ffe6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005934:	4603      	mov	r3, r0
 8005936:	2b00      	cmp	r3, #0
 8005938:	d104      	bne.n	8005944 <sdc_set_bus_width+0x44>
        MMCSD_R1_ERROR(resp[0])) {
 800593a:	9a03      	ldr	r2, [sp, #12]
 800593c:	4b0e      	ldr	r3, [pc, #56]	; (8005978 <sdc_set_bus_width+0x78>)
 800593e:	4013      	ands	r3, r2
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
  }
  else if (SDC_MODE_4BIT == sdcp->config->bus_width) {
    sdc_lld_set_bus_mode(sdcp, SDC_MODE_4BIT);
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
 8005940:	2b00      	cmp	r3, #0
 8005942:	d001      	beq.n	8005948 <sdc_set_bus_width+0x48>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005944:	2301      	movs	r3, #1
 8005946:	e012      	b.n	800596e <sdc_set_bus_width+0x6e>
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005948:	ab03      	add	r3, sp, #12
 800594a:	9801      	ldr	r0, [sp, #4]
 800594c:	2106      	movs	r1, #6
 800594e:	2202      	movs	r2, #2
 8005950:	f004 ffd6 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005954:	4603      	mov	r3, r0
 8005956:	2b00      	cmp	r3, #0
 8005958:	d104      	bne.n	8005964 <sdc_set_bus_width+0x64>
        MMCSD_R1_ERROR(resp[0])) {
 800595a:	9a03      	ldr	r2, [sp, #12]
 800595c:	4b06      	ldr	r3, [pc, #24]	; (8005978 <sdc_set_bus_width+0x78>)
 800595e:	4013      	ands	r3, r2
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_APP_CMD, sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
    }

    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BUS_WIDTH, 2, resp) ||
 8005960:	2b00      	cmp	r3, #0
 8005962:	d003      	beq.n	800596c <sdc_set_bus_width+0x6c>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005964:	2301      	movs	r3, #1
 8005966:	e002      	b.n	800596e <sdc_set_bus_width+0x6e>
    }
  }
  else {
    /* SD card does not support 8bit bus.*/
    return HAL_FAILED;
 8005968:	2301      	movs	r3, #1
 800596a:	e000      	b.n	800596e <sdc_set_bus_width+0x6e>
  }

  return HAL_SUCCESS;
 800596c:	2300      	movs	r3, #0
}
 800596e:	4618      	mov	r0, r3
 8005970:	b005      	add	sp, #20
 8005972:	f85d fb04 	ldr.w	pc, [sp], #4
 8005976:	bf00      	nop
 8005978:	fdffe008 	.word	0xfdffe008
 800597c:	f3af 8000 	nop.w

08005980 <mmc_set_bus_width>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool mmc_set_bus_width(SDCDriver *sdcp) {
 8005980:	b500      	push	{lr}
 8005982:	b085      	sub	sp, #20
 8005984:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);
 8005986:	2003      	movs	r0, #3
 8005988:	21b7      	movs	r1, #183	; 0xb7
 800598a:	2200      	movs	r2, #0
 800598c:	2300      	movs	r3, #0
 800598e:	f7ff fe57 	bl	8005640 <mmc_cmd6_construct>
 8005992:	9003      	str	r0, [sp, #12]

  switch(sdcp->config->bus_width){
 8005994:	9b01      	ldr	r3, [sp, #4]
 8005996:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005998:	791b      	ldrb	r3, [r3, #4]
 800599a:	2b01      	cmp	r3, #1
 800599c:	d006      	beq.n	80059ac <mmc_set_bus_width+0x2c>
 800599e:	2b02      	cmp	r3, #2
 80059a0:	d00c      	beq.n	80059bc <mmc_set_bus_width+0x3c>
 80059a2:	2b00      	cmp	r3, #0
 80059a4:	d000      	beq.n	80059a8 <mmc_set_bus_width+0x28>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
    break;
  default:
    osalDbgAssert(false, "unexpected case");
    break;
 80059a6:	e011      	b.n	80059cc <mmc_set_bus_width+0x4c>
  uint32_t cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 0, 0);

  switch(sdcp->config->bus_width){
  case SDC_MODE_1BIT:
    /* Nothing to do. Bus is already in 1bit mode.*/
    return HAL_SUCCESS;
 80059a8:	2300      	movs	r3, #0
 80059aa:	e027      	b.n	80059fc <mmc_set_bus_width+0x7c>
  case SDC_MODE_4BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 1, 0);
 80059ac:	2003      	movs	r0, #3
 80059ae:	21b7      	movs	r1, #183	; 0xb7
 80059b0:	2201      	movs	r2, #1
 80059b2:	2300      	movs	r3, #0
 80059b4:	f7ff fe44 	bl	8005640 <mmc_cmd6_construct>
 80059b8:	9003      	str	r0, [sp, #12]
    break;
 80059ba:	e007      	b.n	80059cc <mmc_set_bus_width+0x4c>
  case SDC_MODE_8BIT:
    cmdarg = mmc_cmd6_construct(MMC_SWITCH_WRITE_BYTE, 183, 2, 0);
 80059bc:	2003      	movs	r0, #3
 80059be:	21b7      	movs	r1, #183	; 0xb7
 80059c0:	2202      	movs	r2, #2
 80059c2:	2300      	movs	r3, #0
 80059c4:	f7ff fe3c 	bl	8005640 <mmc_cmd6_construct>
 80059c8:	9003      	str	r0, [sp, #12]
    break;
 80059ca:	bf00      	nop
  default:
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
 80059cc:	9b01      	ldr	r3, [sp, #4]
 80059ce:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80059d0:	791b      	ldrb	r3, [r3, #4]
 80059d2:	9801      	ldr	r0, [sp, #4]
 80059d4:	4619      	mov	r1, r3
 80059d6:	f004 ff0b 	bl	800a7f0 <sdc_lld_set_bus_mode>
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059da:	ab02      	add	r3, sp, #8
 80059dc:	9801      	ldr	r0, [sp, #4]
 80059de:	2106      	movs	r1, #6
 80059e0:	9a03      	ldr	r2, [sp, #12]
 80059e2:	f004 ff8d 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 80059e6:	4603      	mov	r3, r0
 80059e8:	2b00      	cmp	r3, #0
 80059ea:	d104      	bne.n	80059f6 <mmc_set_bus_width+0x76>
      MMCSD_R1_ERROR(resp[0])) {
 80059ec:	9a02      	ldr	r2, [sp, #8]
 80059ee:	4b05      	ldr	r3, [pc, #20]	; (8005a04 <mmc_set_bus_width+0x84>)
 80059f0:	4013      	ands	r3, r2
    osalDbgAssert(false, "unexpected case");
    break;
  }

  sdc_lld_set_bus_mode(sdcp, sdcp->config->bus_width);
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SWITCH, cmdarg, resp) ||
 80059f2:	2b00      	cmp	r3, #0
 80059f4:	d001      	beq.n	80059fa <mmc_set_bus_width+0x7a>
      MMCSD_R1_ERROR(resp[0])) {
    return HAL_FAILED;
 80059f6:	2301      	movs	r3, #1
 80059f8:	e000      	b.n	80059fc <mmc_set_bus_width+0x7c>
  }

  return HAL_SUCCESS;
 80059fa:	2300      	movs	r3, #0
}
 80059fc:	4618      	mov	r0, r3
 80059fe:	b005      	add	sp, #20
 8005a00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a04:	fdffe008 	.word	0xfdffe008
 8005a08:	f3af 8000 	nop.w
 8005a0c:	f3af 8000 	nop.w

08005a10 <_sdc_wait_for_transfer_state>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
 8005a10:	b500      	push	{lr}
 8005a12:	b085      	sub	sp, #20
 8005a14:	9001      	str	r0, [sp, #4]
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
 8005a16:	9b01      	ldr	r3, [sp, #4]
 8005a18:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005a1a:	ab03      	add	r3, sp, #12
 8005a1c:	9801      	ldr	r0, [sp, #4]
 8005a1e:	210d      	movs	r1, #13
 8005a20:	f004 ff6e 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005a24:	4603      	mov	r3, r0
 8005a26:	2b00      	cmp	r3, #0
 8005a28:	d104      	bne.n	8005a34 <_sdc_wait_for_transfer_state+0x24>
                                   sdcp->rca, resp) ||
        MMCSD_R1_ERROR(resp[0])) {
 8005a2a:	9a03      	ldr	r2, [sp, #12]
 8005a2c:	4b0d      	ldr	r3, [pc, #52]	; (8005a64 <_sdc_wait_for_transfer_state+0x54>)
 8005a2e:	4013      	ands	r3, r2
bool _sdc_wait_for_transfer_state(SDCDriver *sdcp) {
  uint32_t resp[1];

  while (true) {
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_STATUS,
                                   sdcp->rca, resp) ||
 8005a30:	2b00      	cmp	r3, #0
 8005a32:	d001      	beq.n	8005a38 <_sdc_wait_for_transfer_state+0x28>
        MMCSD_R1_ERROR(resp[0])) {
      return HAL_FAILED;
 8005a34:	2301      	movs	r3, #1
 8005a36:	e011      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    }

    switch (MMCSD_R1_STS(resp[0])) {
 8005a38:	9b03      	ldr	r3, [sp, #12]
 8005a3a:	0a5b      	lsrs	r3, r3, #9
 8005a3c:	f003 030f 	and.w	r3, r3, #15
 8005a40:	2b04      	cmp	r3, #4
 8005a42:	d004      	beq.n	8005a4e <_sdc_wait_for_transfer_state+0x3e>
 8005a44:	2b04      	cmp	r3, #4
 8005a46:	d308      	bcc.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a48:	2b07      	cmp	r3, #7
 8005a4a:	d806      	bhi.n	8005a5a <_sdc_wait_for_transfer_state+0x4a>
 8005a4c:	e001      	b.n	8005a52 <_sdc_wait_for_transfer_state+0x42>
    case MMCSD_STS_TRAN:
      return HAL_SUCCESS;
 8005a4e:	2300      	movs	r3, #0
 8005a50:	e004      	b.n	8005a5c <_sdc_wait_for_transfer_state+0x4c>
    case MMCSD_STS_DATA:
    case MMCSD_STS_RCV:
    case MMCSD_STS_PRG:
#if SDC_NICE_WAITING == TRUE
      osalThreadSleepMilliseconds(1);
 8005a52:	2001      	movs	r0, #1
 8005a54:	f7ff fd04 	bl	8005460 <osalThreadSleep>
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
    }
  }
 8005a58:	e7dd      	b.n	8005a16 <_sdc_wait_for_transfer_state+0x6>
#endif
      continue;
    default:
      /* The card should have been initialized so any other state is not
         valid and is reported as an error.*/
      return HAL_FAILED;
 8005a5a:	2301      	movs	r3, #1
    }
  }
}
 8005a5c:	4618      	mov	r0, r3
 8005a5e:	b005      	add	sp, #20
 8005a60:	f85d fb04 	ldr.w	pc, [sp], #4
 8005a64:	fdffe008 	.word	0xfdffe008
 8005a68:	f3af 8000 	nop.w
 8005a6c:	f3af 8000 	nop.w

08005a70 <sdcInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdcInit(void) {
 8005a70:	b508      	push	{r3, lr}

  sdc_lld_init();
 8005a72:	f004 fded 	bl	800a650 <sdc_lld_init>
}
 8005a76:	bd08      	pop	{r3, pc}
 8005a78:	f3af 8000 	nop.w
 8005a7c:	f3af 8000 	nop.w

08005a80 <sdcObjectInit>:
 *
 * @param[out] sdcp     pointer to the @p SDCDriver object
 *
 * @init
 */
void sdcObjectInit(SDCDriver *sdcp) {
 8005a80:	b082      	sub	sp, #8
 8005a82:	9001      	str	r0, [sp, #4]

  sdcp->vmt      = &sdc_vmt;
 8005a84:	9b01      	ldr	r3, [sp, #4]
 8005a86:	4a08      	ldr	r2, [pc, #32]	; (8005aa8 <sdcObjectInit+0x28>)
 8005a88:	601a      	str	r2, [r3, #0]
  sdcp->state    = BLK_STOP;
 8005a8a:	9b01      	ldr	r3, [sp, #4]
 8005a8c:	2201      	movs	r2, #1
 8005a8e:	711a      	strb	r2, [r3, #4]
  sdcp->errors   = SDC_NO_ERROR;
 8005a90:	9b01      	ldr	r3, [sp, #4]
 8005a92:	2200      	movs	r2, #0
 8005a94:	635a      	str	r2, [r3, #52]	; 0x34
  sdcp->config   = NULL;
 8005a96:	9b01      	ldr	r3, [sp, #4]
 8005a98:	2200      	movs	r2, #0
 8005a9a:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->capacity = 0;
 8005a9c:	9b01      	ldr	r3, [sp, #4]
 8005a9e:	2200      	movs	r2, #0
 8005aa0:	629a      	str	r2, [r3, #40]	; 0x28
}
 8005aa2:	b002      	add	sp, #8
 8005aa4:	4770      	bx	lr
 8005aa6:	bf00      	nop
 8005aa8:	08019450 	.word	0x08019450
 8005aac:	f3af 8000 	nop.w

08005ab0 <sdcStart>:
 *                      the driver supports a default configuration or
 *                      requires no configuration
 *
 * @api
 */
void sdcStart(SDCDriver *sdcp, const SDCConfig *config) {
 8005ab0:	b500      	push	{lr}
 8005ab2:	b083      	sub	sp, #12
 8005ab4:	9001      	str	r0, [sp, #4]
 8005ab6:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ab8:	f7ff fcc2 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdcp->config = config;
 8005abc:	9b01      	ldr	r3, [sp, #4]
 8005abe:	9a00      	ldr	r2, [sp, #0]
 8005ac0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_start(sdcp);
 8005ac2:	9801      	ldr	r0, [sp, #4]
 8005ac4:	f004 fddc 	bl	800a680 <sdc_lld_start>
  sdcp->state = BLK_ACTIVE;
 8005ac8:	9b01      	ldr	r3, [sp, #4]
 8005aca:	2202      	movs	r2, #2
 8005acc:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ace:	f7ff fcbf 	bl	8005450 <osalSysUnlock>
}
 8005ad2:	b003      	add	sp, #12
 8005ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8005ad8:	f3af 8000 	nop.w
 8005adc:	f3af 8000 	nop.w

08005ae0 <sdcStop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @api
 */
void sdcStop(SDCDriver *sdcp) {
 8005ae0:	b500      	push	{lr}
 8005ae2:	b083      	sub	sp, #12
 8005ae4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005ae6:	f7ff fcab 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_STOP) || (sdcp->state == BLK_ACTIVE),
                "invalid state");
  sdc_lld_stop(sdcp);
 8005aea:	9801      	ldr	r0, [sp, #4]
 8005aec:	f004 fe10 	bl	800a710 <sdc_lld_stop>
  sdcp->state = BLK_STOP;
 8005af0:	9b01      	ldr	r3, [sp, #4]
 8005af2:	2201      	movs	r2, #1
 8005af4:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005af6:	f7ff fcab 	bl	8005450 <osalSysUnlock>
}
 8005afa:	b003      	add	sp, #12
 8005afc:	f85d fb04 	ldr.w	pc, [sp], #4

08005b00 <sdcConnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcConnect(SDCDriver *sdcp) {
 8005b00:	b500      	push	{lr}
 8005b02:	b089      	sub	sp, #36	; 0x24
 8005b04:	9003      	str	r0, [sp, #12]
  uint32_t resp[1];
  sdcbusclk_t clk = SDC_CLK_25MHz;
 8005b06:	2300      	movs	r3, #0
 8005b08:	f88d 3017 	strb.w	r3, [sp, #23]
  osalDbgCheck(sdcp != NULL);
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");

  /* Connection procedure in progress.*/
  sdcp->state = BLK_CONNECTING;
 8005b0c:	9b03      	ldr	r3, [sp, #12]
 8005b0e:	2203      	movs	r2, #3
 8005b10:	711a      	strb	r2, [r3, #4]

  /* Card clock initialization.*/
  sdc_lld_start_clk(sdcp);
 8005b12:	9803      	ldr	r0, [sp, #12]
 8005b14:	f004 fe2c 	bl	800a770 <sdc_lld_start_clk>

  /* Enforces the initial card state.*/
  sdc_lld_send_cmd_none(sdcp, MMCSD_CMD_GO_IDLE_STATE, 0);
 8005b18:	9803      	ldr	r0, [sp, #12]
 8005b1a:	2100      	movs	r1, #0
 8005b1c:	2200      	movs	r2, #0
 8005b1e:	f004 fe8f 	bl	800a840 <sdc_lld_send_cmd_none>

  /* Detect card type.*/
  if (HAL_FAILED == mode_detect(sdcp)) {
 8005b22:	9803      	ldr	r0, [sp, #12]
 8005b24:	f7ff fcac 	bl	8005480 <mode_detect>
 8005b28:	4603      	mov	r3, r0
 8005b2a:	2b00      	cmp	r3, #0
 8005b2c:	d000      	beq.n	8005b30 <sdcConnect+0x30>
    goto failed;
 8005b2e:	e0ba      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Perform specific initialization procedure.*/
  if ((sdcp->cardmode &  SDC_MODE_CARDTYPE_MASK) == SDC_MODE_CARDTYPE_MMC) {
 8005b30:	9b03      	ldr	r3, [sp, #12]
 8005b32:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005b34:	f003 030f 	and.w	r3, r3, #15
 8005b38:	2b02      	cmp	r3, #2
 8005b3a:	d106      	bne.n	8005b4a <sdcConnect+0x4a>
    if (HAL_FAILED == mmc_init(sdcp)) {
 8005b3c:	9803      	ldr	r0, [sp, #12]
 8005b3e:	f7ff fcef 	bl	8005520 <mmc_init>
 8005b42:	4603      	mov	r3, r0
 8005b44:	2b00      	cmp	r3, #0
 8005b46:	d007      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b48:	e0ad      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }
  else {
    if (HAL_FAILED == sdc_init(sdcp)) {
 8005b4a:	9803      	ldr	r0, [sp, #12]
 8005b4c:	f7ff fd20 	bl	8005590 <sdc_init>
 8005b50:	4603      	mov	r3, r0
 8005b52:	2b00      	cmp	r3, #0
 8005b54:	d000      	beq.n	8005b58 <sdcConnect+0x58>
      goto failed;
 8005b56:	e0a6      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
  }

  /* Reads CID.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_ALL_SEND_CID, 0, sdcp->cid)) {
 8005b58:	9b03      	ldr	r3, [sp, #12]
 8005b5a:	3308      	adds	r3, #8
 8005b5c:	9803      	ldr	r0, [sp, #12]
 8005b5e:	2102      	movs	r1, #2
 8005b60:	2200      	movs	r2, #0
 8005b62:	f004 ff0d 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b66:	4603      	mov	r3, r0
 8005b68:	2b00      	cmp	r3, #0
 8005b6a:	d000      	beq.n	8005b6e <sdcConnect+0x6e>
    goto failed;
 8005b6c:	e09b      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Asks for the RCA.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEND_RELATIVE_ADDR,
 8005b6e:	9b03      	ldr	r3, [sp, #12]
 8005b70:	3338      	adds	r3, #56	; 0x38
 8005b72:	9803      	ldr	r0, [sp, #12]
 8005b74:	2103      	movs	r1, #3
 8005b76:	2200      	movs	r2, #0
 8005b78:	f004 fec2 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005b7c:	4603      	mov	r3, r0
 8005b7e:	2b00      	cmp	r3, #0
 8005b80:	d000      	beq.n	8005b84 <sdcConnect+0x84>
                                 0, &sdcp->rca)) {
    goto failed;
 8005b82:	e090      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b84:	9b03      	ldr	r3, [sp, #12]
 8005b86:	6b9a      	ldr	r2, [r3, #56]	; 0x38
                                sdcp->rca, sdcp->csd)) {
 8005b88:	9b03      	ldr	r3, [sp, #12]
 8005b8a:	3318      	adds	r3, #24
                                 0, &sdcp->rca)) {
    goto failed;
  }

  /* Reads CSD.*/
  if (sdc_lld_send_cmd_long_crc(sdcp, MMCSD_CMD_SEND_CSD,
 8005b8c:	9803      	ldr	r0, [sp, #12]
 8005b8e:	2109      	movs	r1, #9
 8005b90:	f004 fef6 	bl	800a980 <sdc_lld_send_cmd_long_crc>
 8005b94:	4603      	mov	r3, r0
 8005b96:	2b00      	cmp	r3, #0
 8005b98:	d000      	beq.n	8005b9c <sdcConnect+0x9c>
                                sdcp->rca, sdcp->csd)) {
    goto failed;
 8005b9a:	e084      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Selects the card for operations.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SEL_DESEL_CARD,
 8005b9c:	9b03      	ldr	r3, [sp, #12]
 8005b9e:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 8005ba0:	ab06      	add	r3, sp, #24
 8005ba2:	9803      	ldr	r0, [sp, #12]
 8005ba4:	2107      	movs	r1, #7
 8005ba6:	f004 feab 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005baa:	4603      	mov	r3, r0
 8005bac:	2b00      	cmp	r3, #0
 8005bae:	d000      	beq.n	8005bb2 <sdcConnect+0xb2>
                                 sdcp->rca, resp)) {
    goto failed;
 8005bb0:	e079      	b.n	8005ca6 <sdcConnect+0x1a6>
  }

  /* Switches to high speed.*/
  if (HAL_SUCCESS != detect_bus_clk(sdcp, &clk)) {
 8005bb2:	f10d 0317 	add.w	r3, sp, #23
 8005bb6:	9803      	ldr	r0, [sp, #12]
 8005bb8:	4619      	mov	r1, r3
 8005bba:	f7ff fe81 	bl	80058c0 <detect_bus_clk>
 8005bbe:	4603      	mov	r3, r0
 8005bc0:	2b00      	cmp	r3, #0
 8005bc2:	d000      	beq.n	8005bc6 <sdcConnect+0xc6>
    goto failed;
 8005bc4:	e06f      	b.n	8005ca6 <sdcConnect+0x1a6>
  }
  sdc_lld_set_data_clk(sdcp, clk);
 8005bc6:	f89d 3017 	ldrb.w	r3, [sp, #23]
 8005bca:	9803      	ldr	r0, [sp, #12]
 8005bcc:	4619      	mov	r1, r3
 8005bce:	f004 fdef 	bl	800a7b0 <sdc_lld_set_data_clk>

  /* Reads extended CSD if needed and possible.*/
  if (SDC_MODE_CARDTYPE_MMC == (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK)) {
 8005bd2:	9b03      	ldr	r3, [sp, #12]
 8005bd4:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005bd6:	f003 030f 	and.w	r3, r3, #15
 8005bda:	2b02      	cmp	r3, #2
 8005bdc:	d12e      	bne.n	8005c3c <sdcConnect+0x13c>

    /* The card is a MMC, checking if it is a large device.*/
    if (_mmcsd_get_slice(sdcp->csd, MMCSD_CSD_MMC_CSD_STRUCTURE_SLICE) > 1U) {
 8005bde:	9b03      	ldr	r3, [sp, #12]
 8005be0:	3318      	adds	r3, #24
 8005be2:	4618      	mov	r0, r3
 8005be4:	217f      	movs	r1, #127	; 0x7f
 8005be6:	227e      	movs	r2, #126	; 0x7e
 8005be8:	f7fe fd4a 	bl	8004680 <_mmcsd_get_slice>
 8005bec:	4603      	mov	r3, r0
 8005bee:	2b01      	cmp	r3, #1
 8005bf0:	d91b      	bls.n	8005c2a <sdcConnect+0x12a>
      uint8_t *ext_csd = sdcp->config->scratchpad;
 8005bf2:	9b03      	ldr	r3, [sp, #12]
 8005bf4:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8005bf6:	681b      	ldr	r3, [r3, #0]
 8005bf8:	9307      	str	r3, [sp, #28]

      /* Size detection requires the buffer.*/
      if (NULL == ext_csd) {
 8005bfa:	9b07      	ldr	r3, [sp, #28]
 8005bfc:	2b00      	cmp	r3, #0
 8005bfe:	d100      	bne.n	8005c02 <sdcConnect+0x102>
        goto failed;
 8005c00:	e051      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      if(sdc_lld_read_special(sdcp, ext_csd, 512, MMCSD_CMD_SEND_EXT_CSD, 0)) {
 8005c02:	2300      	movs	r3, #0
 8005c04:	9300      	str	r3, [sp, #0]
 8005c06:	9803      	ldr	r0, [sp, #12]
 8005c08:	9907      	ldr	r1, [sp, #28]
 8005c0a:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c0e:	2308      	movs	r3, #8
 8005c10:	f004 ff06 	bl	800aa20 <sdc_lld_read_special>
 8005c14:	4603      	mov	r3, r0
 8005c16:	2b00      	cmp	r3, #0
 8005c18:	d000      	beq.n	8005c1c <sdcConnect+0x11c>
        goto failed;
 8005c1a:	e044      	b.n	8005ca6 <sdcConnect+0x1a6>
      }

      /* Capacity from the EXT_CSD.*/
      sdcp->capacity = _mmcsd_get_capacity_ext(ext_csd);
 8005c1c:	9807      	ldr	r0, [sp, #28]
 8005c1e:	f7fe fda7 	bl	8004770 <_mmcsd_get_capacity_ext>
 8005c22:	4602      	mov	r2, r0
 8005c24:	9b03      	ldr	r3, [sp, #12]
 8005c26:	629a      	str	r2, [r3, #40]	; 0x28
 8005c28:	e010      	b.n	8005c4c <sdcConnect+0x14c>
    }
    else {
      /* Capacity from the normal CSD.*/
      sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c2a:	9b03      	ldr	r3, [sp, #12]
 8005c2c:	3318      	adds	r3, #24
 8005c2e:	4618      	mov	r0, r3
 8005c30:	f7fe fd66 	bl	8004700 <_mmcsd_get_capacity>
 8005c34:	4602      	mov	r2, r0
 8005c36:	9b03      	ldr	r3, [sp, #12]
 8005c38:	629a      	str	r2, [r3, #40]	; 0x28
 8005c3a:	e007      	b.n	8005c4c <sdcConnect+0x14c>
    }
  }
  else {
    /* The card is an SDC, capacity from the normal CSD.*/
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
 8005c3c:	9b03      	ldr	r3, [sp, #12]
 8005c3e:	3318      	adds	r3, #24
 8005c40:	4618      	mov	r0, r3
 8005c42:	f7fe fd5d 	bl	8004700 <_mmcsd_get_capacity>
 8005c46:	4602      	mov	r2, r0
 8005c48:	9b03      	ldr	r3, [sp, #12]
 8005c4a:	629a      	str	r2, [r3, #40]	; 0x28
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
 8005c4c:	ab06      	add	r3, sp, #24
 8005c4e:	9803      	ldr	r0, [sp, #12]
 8005c50:	2110      	movs	r1, #16
 8005c52:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005c56:	f004 fe53 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005c5a:	4603      	mov	r3, r0
 8005c5c:	2b00      	cmp	r3, #0
 8005c5e:	d122      	bne.n	8005ca6 <sdcConnect+0x1a6>
                                 MMCSD_BLOCK_SIZE, resp) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005c60:	9a06      	ldr	r2, [sp, #24]
 8005c62:	4b16      	ldr	r3, [pc, #88]	; (8005cbc <sdcConnect+0x1bc>)
 8005c64:	4013      	ands	r3, r2
    sdcp->capacity = _mmcsd_get_capacity(sdcp->csd);
  }

  /* Block length fixed at 512 bytes.*/
  if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_SET_BLOCKLEN,
                                 MMCSD_BLOCK_SIZE, resp) ||
 8005c66:	2b00      	cmp	r3, #0
 8005c68:	d11d      	bne.n	8005ca6 <sdcConnect+0x1a6>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
 8005c6a:	9b03      	ldr	r3, [sp, #12]
 8005c6c:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005c6e:	f003 030f 	and.w	r3, r3, #15
 8005c72:	2b01      	cmp	r3, #1
 8005c74:	d902      	bls.n	8005c7c <sdcConnect+0x17c>
 8005c76:	2b02      	cmp	r3, #2
 8005c78:	d008      	beq.n	8005c8c <sdcConnect+0x18c>
      goto failed;
    }
    break;
  default:
    /* Unknown type.*/
    goto failed;
 8005c7a:	e014      	b.n	8005ca6 <sdcConnect+0x1a6>

  /* Switches to wide bus mode.*/
  switch (sdcp->cardmode & SDC_MODE_CARDTYPE_MASK) {
  case SDC_MODE_CARDTYPE_SDV11:
  case SDC_MODE_CARDTYPE_SDV20:
    if (HAL_FAILED == sdc_set_bus_width(sdcp)) {
 8005c7c:	9803      	ldr	r0, [sp, #12]
 8005c7e:	f7ff fe3f 	bl	8005900 <sdc_set_bus_width>
 8005c82:	4603      	mov	r3, r0
 8005c84:	2b00      	cmp	r3, #0
 8005c86:	d000      	beq.n	8005c8a <sdcConnect+0x18a>
      goto failed;
 8005c88:	e00d      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c8a:	e007      	b.n	8005c9c <sdcConnect+0x19c>
  case SDC_MODE_CARDTYPE_MMC:
    if (HAL_FAILED == mmc_set_bus_width(sdcp)) {
 8005c8c:	9803      	ldr	r0, [sp, #12]
 8005c8e:	f7ff fe77 	bl	8005980 <mmc_set_bus_width>
 8005c92:	4603      	mov	r3, r0
 8005c94:	2b00      	cmp	r3, #0
 8005c96:	d000      	beq.n	8005c9a <sdcConnect+0x19a>
      goto failed;
 8005c98:	e005      	b.n	8005ca6 <sdcConnect+0x1a6>
    }
    break;
 8005c9a:	bf00      	nop
    /* Unknown type.*/
    goto failed;
  }

  /* Initialization complete.*/
  sdcp->state = BLK_READY;
 8005c9c:	9b03      	ldr	r3, [sp, #12]
 8005c9e:	2205      	movs	r2, #5
 8005ca0:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005ca2:	2300      	movs	r3, #0
 8005ca4:	e006      	b.n	8005cb4 <sdcConnect+0x1b4>

  /* Connection failed, state reset to BLK_ACTIVE.*/
failed:
  sdc_lld_stop_clk(sdcp);
 8005ca6:	9803      	ldr	r0, [sp, #12]
 8005ca8:	f004 fd92 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005cac:	9b03      	ldr	r3, [sp, #12]
 8005cae:	2202      	movs	r2, #2
 8005cb0:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005cb2:	2301      	movs	r3, #1
}
 8005cb4:	4618      	mov	r0, r3
 8005cb6:	b009      	add	sp, #36	; 0x24
 8005cb8:	f85d fb04 	ldr.w	pc, [sp], #4
 8005cbc:	fdffe008 	.word	0xfdffe008

08005cc0 <sdcDisconnect>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcDisconnect(SDCDriver *sdcp) {
 8005cc0:	b500      	push	{lr}
 8005cc2:	b083      	sub	sp, #12
 8005cc4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdcp != NULL);

  osalSysLock();
 8005cc6:	f7ff fbbb 	bl	8005440 <osalSysLock>
  osalDbgAssert((sdcp->state == BLK_ACTIVE) || (sdcp->state == BLK_READY),
                "invalid state");
  if (sdcp->state == BLK_ACTIVE) {
 8005cca:	9b01      	ldr	r3, [sp, #4]
 8005ccc:	791b      	ldrb	r3, [r3, #4]
 8005cce:	2b02      	cmp	r3, #2
 8005cd0:	d103      	bne.n	8005cda <sdcDisconnect+0x1a>
    osalSysUnlock();
 8005cd2:	f7ff fbbd 	bl	8005450 <osalSysUnlock>
    return HAL_SUCCESS;
 8005cd6:	2300      	movs	r3, #0
 8005cd8:	e019      	b.n	8005d0e <sdcDisconnect+0x4e>
  }
  sdcp->state = BLK_DISCONNECTING;
 8005cda:	9b01      	ldr	r3, [sp, #4]
 8005cdc:	2204      	movs	r2, #4
 8005cde:	711a      	strb	r2, [r3, #4]
  osalSysUnlock();
 8005ce0:	f7ff fbb6 	bl	8005450 <osalSysUnlock>

  /* Waits for eventual pending operations completion.*/
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ce4:	9801      	ldr	r0, [sp, #4]
 8005ce6:	f7ff fe93 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005cea:	4603      	mov	r3, r0
 8005cec:	2b00      	cmp	r3, #0
 8005cee:	d007      	beq.n	8005d00 <sdcDisconnect+0x40>
    sdc_lld_stop_clk(sdcp);
 8005cf0:	9801      	ldr	r0, [sp, #4]
 8005cf2:	f004 fd6d 	bl	800a7d0 <sdc_lld_stop_clk>
    sdcp->state = BLK_ACTIVE;
 8005cf6:	9b01      	ldr	r3, [sp, #4]
 8005cf8:	2202      	movs	r2, #2
 8005cfa:	711a      	strb	r2, [r3, #4]
    return HAL_FAILED;
 8005cfc:	2301      	movs	r3, #1
 8005cfe:	e006      	b.n	8005d0e <sdcDisconnect+0x4e>
  }

  /* Card clock stopped.*/
  sdc_lld_stop_clk(sdcp);
 8005d00:	9801      	ldr	r0, [sp, #4]
 8005d02:	f004 fd65 	bl	800a7d0 <sdc_lld_stop_clk>
  sdcp->state = BLK_ACTIVE;
 8005d06:	9b01      	ldr	r3, [sp, #4]
 8005d08:	2202      	movs	r2, #2
 8005d0a:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005d0c:	2300      	movs	r3, #0
}
 8005d0e:	4618      	mov	r0, r3
 8005d10:	b003      	add	sp, #12
 8005d12:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d16:	bf00      	nop
 8005d18:	f3af 8000 	nop.w
 8005d1c:	f3af 8000 	nop.w

08005d20 <sdcRead>:
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcRead(SDCDriver *sdcp, uint32_t startblk, uint8_t *buf, uint32_t n) {
 8005d20:	b500      	push	{lr}
 8005d22:	b087      	sub	sp, #28
 8005d24:	9003      	str	r0, [sp, #12]
 8005d26:	9102      	str	r1, [sp, #8]
 8005d28:	9201      	str	r2, [sp, #4]
 8005d2a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d2c:	9a02      	ldr	r2, [sp, #8]
 8005d2e:	9b00      	ldr	r3, [sp, #0]
 8005d30:	4413      	add	r3, r2
 8005d32:	1e5a      	subs	r2, r3, #1
 8005d34:	9b03      	ldr	r3, [sp, #12]
 8005d36:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d38:	429a      	cmp	r2, r3
 8005d3a:	d907      	bls.n	8005d4c <sdcRead+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d3c:	9b03      	ldr	r3, [sp, #12]
 8005d3e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005d40:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005d44:	9b03      	ldr	r3, [sp, #12]
 8005d46:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005d48:	2301      	movs	r3, #1
 8005d4a:	e010      	b.n	8005d6e <sdcRead+0x4e>
  }

  /* Read operation in progress.*/
  sdcp->state = BLK_READING;
 8005d4c:	9b03      	ldr	r3, [sp, #12]
 8005d4e:	2206      	movs	r2, #6
 8005d50:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_read(sdcp, startblk, buf, n);
 8005d52:	9803      	ldr	r0, [sp, #12]
 8005d54:	9902      	ldr	r1, [sp, #8]
 8005d56:	9a01      	ldr	r2, [sp, #4]
 8005d58:	9b00      	ldr	r3, [sp, #0]
 8005d5a:	f004 ffb1 	bl	800acc0 <sdc_lld_read>
 8005d5e:	4603      	mov	r3, r0
 8005d60:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Read operation finished.*/
  sdcp->state = BLK_READY;
 8005d64:	9b03      	ldr	r3, [sp, #12]
 8005d66:	2205      	movs	r2, #5
 8005d68:	711a      	strb	r2, [r3, #4]
  return status;
 8005d6a:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005d6e:	4618      	mov	r0, r3
 8005d70:	b007      	add	sp, #28
 8005d72:	f85d fb04 	ldr.w	pc, [sp], #4
 8005d76:	bf00      	nop
 8005d78:	f3af 8000 	nop.w
 8005d7c:	f3af 8000 	nop.w

08005d80 <sdcWrite>:
 * @retval HAL_FAILED   operation failed.
 *
 * @api
 */
bool sdcWrite(SDCDriver *sdcp, uint32_t startblk,
              const uint8_t *buf, uint32_t n) {
 8005d80:	b500      	push	{lr}
 8005d82:	b087      	sub	sp, #28
 8005d84:	9003      	str	r0, [sp, #12]
 8005d86:	9102      	str	r1, [sp, #8]
 8005d88:	9201      	str	r2, [sp, #4]
 8005d8a:	9300      	str	r3, [sp, #0]
  bool status;

  osalDbgCheck((sdcp != NULL) && (buf != NULL) && (n > 0U));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  if ((startblk + n - 1U) > sdcp->capacity){
 8005d8c:	9a02      	ldr	r2, [sp, #8]
 8005d8e:	9b00      	ldr	r3, [sp, #0]
 8005d90:	4413      	add	r3, r2
 8005d92:	1e5a      	subs	r2, r3, #1
 8005d94:	9b03      	ldr	r3, [sp, #12]
 8005d96:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8005d98:	429a      	cmp	r2, r3
 8005d9a:	d907      	bls.n	8005dac <sdcWrite+0x2c>
    sdcp->errors |= SDC_OVERFLOW_ERROR;
 8005d9c:	9b03      	ldr	r3, [sp, #12]
 8005d9e:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005da0:	f043 0280 	orr.w	r2, r3, #128	; 0x80
 8005da4:	9b03      	ldr	r3, [sp, #12]
 8005da6:	635a      	str	r2, [r3, #52]	; 0x34
    return HAL_FAILED;
 8005da8:	2301      	movs	r3, #1
 8005daa:	e010      	b.n	8005dce <sdcWrite+0x4e>
  }

  /* Write operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005dac:	9b03      	ldr	r3, [sp, #12]
 8005dae:	2207      	movs	r2, #7
 8005db0:	711a      	strb	r2, [r3, #4]

  status = sdc_lld_write(sdcp, startblk, buf, n);
 8005db2:	9803      	ldr	r0, [sp, #12]
 8005db4:	9902      	ldr	r1, [sp, #8]
 8005db6:	9a01      	ldr	r2, [sp, #4]
 8005db8:	9b00      	ldr	r3, [sp, #0]
 8005dba:	f004 ffc9 	bl	800ad50 <sdc_lld_write>
 8005dbe:	4603      	mov	r3, r0
 8005dc0:	f88d 3017 	strb.w	r3, [sp, #23]

  /* Write operation finished.*/
  sdcp->state = BLK_READY;
 8005dc4:	9b03      	ldr	r3, [sp, #12]
 8005dc6:	2205      	movs	r2, #5
 8005dc8:	711a      	strb	r2, [r3, #4]
  return status;
 8005dca:	f89d 3017 	ldrb.w	r3, [sp, #23]
}
 8005dce:	4618      	mov	r0, r3
 8005dd0:	b007      	add	sp, #28
 8005dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8005dd6:	bf00      	nop
 8005dd8:	f3af 8000 	nop.w
 8005ddc:	f3af 8000 	nop.w

08005de0 <sdcGetAndClearErrors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @return              The errors mask.
 *
 * @api
 */
sdcflags_t sdcGetAndClearErrors(SDCDriver *sdcp) {
 8005de0:	b500      	push	{lr}
 8005de2:	b085      	sub	sp, #20
 8005de4:	9001      	str	r0, [sp, #4]
  sdcflags_t flags;

  osalDbgCheck(sdcp != NULL);
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  osalSysLock();
 8005de6:	f7ff fb2b 	bl	8005440 <osalSysLock>
  flags = sdcp->errors;
 8005dea:	9b01      	ldr	r3, [sp, #4]
 8005dec:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8005dee:	9303      	str	r3, [sp, #12]
  sdcp->errors = SDC_NO_ERROR;
 8005df0:	9b01      	ldr	r3, [sp, #4]
 8005df2:	2200      	movs	r2, #0
 8005df4:	635a      	str	r2, [r3, #52]	; 0x34
  osalSysUnlock();
 8005df6:	f7ff fb2b 	bl	8005450 <osalSysUnlock>
  return flags;
 8005dfa:	9b03      	ldr	r3, [sp, #12]
}
 8005dfc:	4618      	mov	r0, r3
 8005dfe:	b005      	add	sp, #20
 8005e00:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e04:	f3af 8000 	nop.w
 8005e08:	f3af 8000 	nop.w
 8005e0c:	f3af 8000 	nop.w

08005e10 <sdcSync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcSync(SDCDriver *sdcp) {
 8005e10:	b500      	push	{lr}
 8005e12:	b085      	sub	sp, #20
 8005e14:	9001      	str	r0, [sp, #4]
  bool result;

  osalDbgCheck(sdcp != NULL);

  if (sdcp->state != BLK_READY) {
 8005e16:	9b01      	ldr	r3, [sp, #4]
 8005e18:	791b      	ldrb	r3, [r3, #4]
 8005e1a:	2b05      	cmp	r3, #5
 8005e1c:	d001      	beq.n	8005e22 <sdcSync+0x12>
    return HAL_FAILED;
 8005e1e:	2301      	movs	r3, #1
 8005e20:	e00d      	b.n	8005e3e <sdcSync+0x2e>
  }

  /* Synchronization operation in progress.*/
  sdcp->state = BLK_SYNCING;
 8005e22:	9b01      	ldr	r3, [sp, #4]
 8005e24:	2208      	movs	r2, #8
 8005e26:	711a      	strb	r2, [r3, #4]

  result = sdc_lld_sync(sdcp);
 8005e28:	9801      	ldr	r0, [sp, #4]
 8005e2a:	f004 ffd9 	bl	800ade0 <sdc_lld_sync>
 8005e2e:	4603      	mov	r3, r0
 8005e30:	f88d 300f 	strb.w	r3, [sp, #15]

  /* Synchronization operation finished.*/
  sdcp->state = BLK_READY;
 8005e34:	9b01      	ldr	r3, [sp, #4]
 8005e36:	2205      	movs	r2, #5
 8005e38:	711a      	strb	r2, [r3, #4]
  return result;
 8005e3a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8005e3e:	4618      	mov	r0, r3
 8005e40:	b005      	add	sp, #20
 8005e42:	f85d fb04 	ldr.w	pc, [sp], #4
 8005e46:	bf00      	nop
 8005e48:	f3af 8000 	nop.w
 8005e4c:	f3af 8000 	nop.w

08005e50 <sdcGetInfo>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcGetInfo(SDCDriver *sdcp, BlockDeviceInfo *bdip) {
 8005e50:	b082      	sub	sp, #8
 8005e52:	9001      	str	r0, [sp, #4]
 8005e54:	9100      	str	r1, [sp, #0]

  osalDbgCheck((sdcp != NULL) && (bdip != NULL));

  if (sdcp->state != BLK_READY) {
 8005e56:	9b01      	ldr	r3, [sp, #4]
 8005e58:	791b      	ldrb	r3, [r3, #4]
 8005e5a:	2b05      	cmp	r3, #5
 8005e5c:	d001      	beq.n	8005e62 <sdcGetInfo+0x12>
    return HAL_FAILED;
 8005e5e:	2301      	movs	r3, #1
 8005e60:	e008      	b.n	8005e74 <sdcGetInfo+0x24>
  }

  bdip->blk_num = sdcp->capacity;
 8005e62:	9b01      	ldr	r3, [sp, #4]
 8005e64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8005e66:	9b00      	ldr	r3, [sp, #0]
 8005e68:	605a      	str	r2, [r3, #4]
  bdip->blk_size = MMCSD_BLOCK_SIZE;
 8005e6a:	9b00      	ldr	r3, [sp, #0]
 8005e6c:	f44f 7200 	mov.w	r2, #512	; 0x200
 8005e70:	601a      	str	r2, [r3, #0]

  return HAL_SUCCESS;
 8005e72:	2300      	movs	r3, #0
}
 8005e74:	4618      	mov	r0, r3
 8005e76:	b002      	add	sp, #8
 8005e78:	4770      	bx	lr
 8005e7a:	bf00      	nop
 8005e7c:	f3af 8000 	nop.w

08005e80 <sdcErase>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdcErase(SDCDriver *sdcp, uint32_t startblk, uint32_t endblk) {
 8005e80:	b500      	push	{lr}
 8005e82:	b087      	sub	sp, #28
 8005e84:	9003      	str	r0, [sp, #12]
 8005e86:	9102      	str	r1, [sp, #8]
 8005e88:	9201      	str	r2, [sp, #4]

  osalDbgCheck((sdcp != NULL));
  osalDbgAssert(sdcp->state == BLK_READY, "invalid state");

  /* Erase operation in progress.*/
  sdcp->state = BLK_WRITING;
 8005e8a:	9b03      	ldr	r3, [sp, #12]
 8005e8c:	2207      	movs	r2, #7
 8005e8e:	711a      	strb	r2, [r3, #4]

  /* Handling command differences between HC and normal cards.*/
  if ((sdcp->cardmode & SDC_MODE_HIGH_CAPACITY) != 0U) {
 8005e90:	9b03      	ldr	r3, [sp, #12]
 8005e92:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 8005e94:	f003 0310 	and.w	r3, r3, #16
 8005e98:	2b00      	cmp	r3, #0
 8005e9a:	d005      	beq.n	8005ea8 <sdcErase+0x28>
    startblk *= MMCSD_BLOCK_SIZE;
 8005e9c:	9b02      	ldr	r3, [sp, #8]
 8005e9e:	025b      	lsls	r3, r3, #9
 8005ea0:	9302      	str	r3, [sp, #8]
    endblk *= MMCSD_BLOCK_SIZE;
 8005ea2:	9b01      	ldr	r3, [sp, #4]
 8005ea4:	025b      	lsls	r3, r3, #9
 8005ea6:	9301      	str	r3, [sp, #4]
  }

  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005ea8:	9803      	ldr	r0, [sp, #12]
 8005eaa:	f7ff fdb1 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005eae:	4603      	mov	r3, r0
 8005eb0:	2b00      	cmp	r3, #0
 8005eb2:	d000      	beq.n	8005eb6 <sdcErase+0x36>
    goto failed;
 8005eb4:	e035      	b.n	8005f22 <sdcErase+0xa2>
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
 8005eb6:	ab05      	add	r3, sp, #20
 8005eb8:	9803      	ldr	r0, [sp, #12]
 8005eba:	2120      	movs	r1, #32
 8005ebc:	9a02      	ldr	r2, [sp, #8]
 8005ebe:	f004 fd1f 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ec2:	4603      	mov	r3, r0
 8005ec4:	2b00      	cmp	r3, #0
 8005ec6:	d12c      	bne.n	8005f22 <sdcErase+0xa2>
                                  startblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ec8:	9a05      	ldr	r2, [sp, #20]
 8005eca:	4b1a      	ldr	r3, [pc, #104]	; (8005f34 <sdcErase+0xb4>)
 8005ecc:	4013      	ands	r3, r2
  if (_sdc_wait_for_transfer_state(sdcp)) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_START,
                                  startblk, resp) != HAL_SUCCESS) ||
 8005ece:	2b00      	cmp	r3, #0
 8005ed0:	d127      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
 8005ed2:	ab05      	add	r3, sp, #20
 8005ed4:	9803      	ldr	r0, [sp, #12]
 8005ed6:	2121      	movs	r1, #33	; 0x21
 8005ed8:	9a01      	ldr	r2, [sp, #4]
 8005eda:	f004 fd11 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005ede:	4603      	mov	r3, r0
 8005ee0:	2b00      	cmp	r3, #0
 8005ee2:	d11e      	bne.n	8005f22 <sdcErase+0xa2>
                                  endblk, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005ee4:	9a05      	ldr	r2, [sp, #20]
 8005ee6:	4b13      	ldr	r3, [pc, #76]	; (8005f34 <sdcErase+0xb4>)
 8005ee8:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE_RW_BLK_END,
                                  endblk, resp) != HAL_SUCCESS) ||
 8005eea:	2b00      	cmp	r3, #0
 8005eec:	d119      	bne.n	8005f22 <sdcErase+0xa2>
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
 8005eee:	ab05      	add	r3, sp, #20
 8005ef0:	9803      	ldr	r0, [sp, #12]
 8005ef2:	2126      	movs	r1, #38	; 0x26
 8005ef4:	2200      	movs	r2, #0
 8005ef6:	f004 fd03 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 8005efa:	4603      	mov	r3, r0
 8005efc:	2b00      	cmp	r3, #0
 8005efe:	d110      	bne.n	8005f22 <sdcErase+0xa2>
                                  0, resp) != HAL_SUCCESS) ||
      MMCSD_R1_ERROR(resp[0])) {
 8005f00:	9a05      	ldr	r2, [sp, #20]
 8005f02:	4b0c      	ldr	r3, [pc, #48]	; (8005f34 <sdcErase+0xb4>)
 8005f04:	4013      	ands	r3, r2
      MMCSD_R1_ERROR(resp[0])) {
    goto failed;
  }

  if ((sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_ERASE,
                                  0, resp) != HAL_SUCCESS) ||
 8005f06:	2b00      	cmp	r3, #0
 8005f08:	d10b      	bne.n	8005f22 <sdcErase+0xa2>

  /* Quick sleep to allow it to transition to programming or receiving state */
  /* TODO: ??????????????????????????? */

  /* Wait for it to return to transfer state to indicate it has finished erasing */
  if (_sdc_wait_for_transfer_state(sdcp)) {
 8005f0a:	9803      	ldr	r0, [sp, #12]
 8005f0c:	f7ff fd80 	bl	8005a10 <_sdc_wait_for_transfer_state>
 8005f10:	4603      	mov	r3, r0
 8005f12:	2b00      	cmp	r3, #0
 8005f14:	d000      	beq.n	8005f18 <sdcErase+0x98>
    goto failed;
 8005f16:	e004      	b.n	8005f22 <sdcErase+0xa2>
  }

  sdcp->state = BLK_READY;
 8005f18:	9b03      	ldr	r3, [sp, #12]
 8005f1a:	2205      	movs	r2, #5
 8005f1c:	711a      	strb	r2, [r3, #4]
  return HAL_SUCCESS;
 8005f1e:	2300      	movs	r3, #0
 8005f20:	e003      	b.n	8005f2a <sdcErase+0xaa>

failed:
  sdcp->state = BLK_READY;
 8005f22:	9b03      	ldr	r3, [sp, #12]
 8005f24:	2205      	movs	r2, #5
 8005f26:	711a      	strb	r2, [r3, #4]
  return HAL_FAILED;
 8005f28:	2301      	movs	r3, #1
}
 8005f2a:	4618      	mov	r0, r3
 8005f2c:	b007      	add	sp, #28
 8005f2e:	f85d fb04 	ldr.w	pc, [sp], #4
 8005f32:	bf00      	nop
 8005f34:	fdffe008 	.word	0xfdffe008
 8005f38:	f3af 8000 	nop.w
 8005f3c:	f3af 8000 	nop.w

08005f40 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8005f40:	b082      	sub	sp, #8
 8005f42:	2320      	movs	r3, #32
 8005f44:	9301      	str	r3, [sp, #4]
 8005f46:	9b01      	ldr	r3, [sp, #4]
 8005f48:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f4c:	b002      	add	sp, #8
 8005f4e:	4770      	bx	lr

08005f50 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8005f50:	b082      	sub	sp, #8
 8005f52:	2300      	movs	r3, #0
 8005f54:	9301      	str	r3, [sp, #4]
 8005f56:	9b01      	ldr	r3, [sp, #4]
 8005f58:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8005f5c:	b002      	add	sp, #8
 8005f5e:	4770      	bx	lr

08005f60 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8005f60:	b508      	push	{r3, lr}

  port_lock();
 8005f62:	f7ff ffed 	bl	8005f40 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8005f66:	bd08      	pop	{r3, pc}
 8005f68:	f3af 8000 	nop.w
 8005f6c:	f3af 8000 	nop.w

08005f70 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8005f70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8005f72:	f7ff ffed 	bl	8005f50 <port_unlock>
}
 8005f76:	bd08      	pop	{r3, pc}
 8005f78:	f3af 8000 	nop.w
 8005f7c:	f3af 8000 	nop.w

08005f80 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8005f80:	b082      	sub	sp, #8
 8005f82:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8005f84:	9b01      	ldr	r3, [sp, #4]
 8005f86:	9a01      	ldr	r2, [sp, #4]
 8005f88:	601a      	str	r2, [r3, #0]
}
 8005f8a:	b002      	add	sp, #8
 8005f8c:	4770      	bx	lr
 8005f8e:	bf00      	nop

08005f90 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 8005f90:	b082      	sub	sp, #8
 8005f92:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8005f94:	9b01      	ldr	r3, [sp, #4]
 8005f96:	689b      	ldr	r3, [r3, #8]
 8005f98:	2b00      	cmp	r3, #0
 8005f9a:	bf14      	ite	ne
 8005f9c:	2300      	movne	r3, #0
 8005f9e:	2301      	moveq	r3, #1
 8005fa0:	b2db      	uxtb	r3, r3
}
 8005fa2:	4618      	mov	r0, r3
 8005fa4:	b002      	add	sp, #8
 8005fa6:	4770      	bx	lr
 8005fa8:	f3af 8000 	nop.w
 8005fac:	f3af 8000 	nop.w

08005fb0 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 8005fb0:	b082      	sub	sp, #8
 8005fb2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8005fb4:	9b01      	ldr	r3, [sp, #4]
 8005fb6:	689b      	ldr	r3, [r3, #8]
 8005fb8:	2b00      	cmp	r3, #0
 8005fba:	bf14      	ite	ne
 8005fbc:	2300      	movne	r3, #0
 8005fbe:	2301      	moveq	r3, #1
 8005fc0:	b2db      	uxtb	r3, r3
}
 8005fc2:	4618      	mov	r0, r3
 8005fc4:	b002      	add	sp, #8
 8005fc6:	4770      	bx	lr
 8005fc8:	f3af 8000 	nop.w
 8005fcc:	f3af 8000 	nop.w

08005fd0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8005fd0:	b508      	push	{r3, lr}

  chSysLock();
 8005fd2:	f7ff ffc5 	bl	8005f60 <chSysLock>
}
 8005fd6:	bd08      	pop	{r3, pc}
 8005fd8:	f3af 8000 	nop.w
 8005fdc:	f3af 8000 	nop.w

08005fe0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8005fe0:	b508      	push	{r3, lr}

  chSysUnlock();
 8005fe2:	f7ff ffc5 	bl	8005f70 <chSysUnlock>
}
 8005fe6:	bd08      	pop	{r3, pc}
 8005fe8:	f3af 8000 	nop.w
 8005fec:	f3af 8000 	nop.w

08005ff0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 8005ff0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 8005ff2:	f7fa fec5 	bl	8000d80 <chSchRescheduleS>
}
 8005ff6:	bd08      	pop	{r3, pc}
 8005ff8:	f3af 8000 	nop.w
 8005ffc:	f3af 8000 	nop.w

08006000 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
 8006000:	b500      	push	{lr}
 8006002:	b083      	sub	sp, #12
 8006004:	9001      	str	r0, [sp, #4]

  chEvtObjectInit(esp);
 8006006:	9801      	ldr	r0, [sp, #4]
 8006008:	f7ff ffba 	bl	8005f80 <chEvtObjectInit>
}
 800600c:	b003      	add	sp, #12
 800600e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006012:	bf00      	nop
 8006014:	f3af 8000 	nop.w
 8006018:	f3af 8000 	nop.w
 800601c:	f3af 8000 	nop.w

08006020 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 8006020:	b500      	push	{lr}
 8006022:	b083      	sub	sp, #12
 8006024:	9001      	str	r0, [sp, #4]
 8006026:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 8006028:	9801      	ldr	r0, [sp, #4]
 800602a:	9900      	ldr	r1, [sp, #0]
 800602c:	f7fc fb28 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8006030:	b003      	add	sp, #12
 8006032:	f85d fb04 	ldr.w	pc, [sp], #4
 8006036:	bf00      	nop
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
 8006040:	b500      	push	{lr}
 8006042:	b085      	sub	sp, #20
 8006044:	9003      	str	r0, [sp, #12]
 8006046:	9102      	str	r1, [sp, #8]
 8006048:	9201      	str	r2, [sp, #4]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 800604a:	9b03      	ldr	r3, [sp, #12]
 800604c:	3330      	adds	r3, #48	; 0x30
 800604e:	4618      	mov	r0, r3
 8006050:	9902      	ldr	r1, [sp, #8]
 8006052:	9a01      	ldr	r2, [sp, #4]
 8006054:	f04f 33ff 	mov.w	r3, #4294967295
 8006058:	f7fd fa72 	bl	8003540 <chOQWriteTimeout>
 800605c:	4603      	mov	r3, r0
                        n, TIME_INFINITE);
}
 800605e:	4618      	mov	r0, r3
 8006060:	b005      	add	sp, #20
 8006062:	f85d fb04 	ldr.w	pc, [sp], #4
 8006066:	bf00      	nop
 8006068:	f3af 8000 	nop.w
 800606c:	f3af 8000 	nop.w

08006070 <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
 8006070:	b500      	push	{lr}
 8006072:	b085      	sub	sp, #20
 8006074:	9003      	str	r0, [sp, #12]
 8006076:	9102      	str	r1, [sp, #8]
 8006078:	9201      	str	r2, [sp, #4]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 800607a:	9b03      	ldr	r3, [sp, #12]
 800607c:	330c      	adds	r3, #12
 800607e:	4618      	mov	r0, r3
 8006080:	9902      	ldr	r1, [sp, #8]
 8006082:	9a01      	ldr	r2, [sp, #4]
 8006084:	f04f 33ff 	mov.w	r3, #4294967295
 8006088:	f7fd f942 	bl	8003310 <chIQReadTimeout>
 800608c:	4603      	mov	r3, r0
                       n, TIME_INFINITE);
}
 800608e:	4618      	mov	r0, r3
 8006090:	b005      	add	sp, #20
 8006092:	f85d fb04 	ldr.w	pc, [sp], #4
 8006096:	bf00      	nop
 8006098:	f3af 8000 	nop.w
 800609c:	f3af 8000 	nop.w

080060a0 <put>:

static msg_t put(void *ip, uint8_t b) {
 80060a0:	b500      	push	{lr}
 80060a2:	b083      	sub	sp, #12
 80060a4:	9001      	str	r0, [sp, #4]
 80060a6:	460b      	mov	r3, r1
 80060a8:	f88d 3003 	strb.w	r3, [sp, #3]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 80060ac:	9b01      	ldr	r3, [sp, #4]
 80060ae:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80060b2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80060b6:	4610      	mov	r0, r2
 80060b8:	4619      	mov	r1, r3
 80060ba:	f04f 32ff 	mov.w	r2, #4294967295
 80060be:	f7fd f9c7 	bl	8003450 <chOQPutTimeout>
 80060c2:	4603      	mov	r3, r0
}
 80060c4:	4618      	mov	r0, r3
 80060c6:	b003      	add	sp, #12
 80060c8:	f85d fb04 	ldr.w	pc, [sp], #4
 80060cc:	f3af 8000 	nop.w

080060d0 <get>:

static msg_t get(void *ip) {
 80060d0:	b500      	push	{lr}
 80060d2:	b083      	sub	sp, #12
 80060d4:	9001      	str	r0, [sp, #4]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 80060d6:	9b01      	ldr	r3, [sp, #4]
 80060d8:	330c      	adds	r3, #12
 80060da:	4618      	mov	r0, r3
 80060dc:	f04f 31ff 	mov.w	r1, #4294967295
 80060e0:	f7fd f8ce 	bl	8003280 <chIQGetTimeout>
 80060e4:	4603      	mov	r3, r0
}
 80060e6:	4618      	mov	r0, r3
 80060e8:	b003      	add	sp, #12
 80060ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80060ee:	bf00      	nop

080060f0 <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
 80060f0:	b500      	push	{lr}
 80060f2:	b085      	sub	sp, #20
 80060f4:	9003      	str	r0, [sp, #12]
 80060f6:	460b      	mov	r3, r1
 80060f8:	9201      	str	r2, [sp, #4]
 80060fa:	f88d 300b 	strb.w	r3, [sp, #11]

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 80060fe:	9b03      	ldr	r3, [sp, #12]
 8006100:	f103 0230 	add.w	r2, r3, #48	; 0x30
 8006104:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006108:	4610      	mov	r0, r2
 800610a:	4619      	mov	r1, r3
 800610c:	9a01      	ldr	r2, [sp, #4]
 800610e:	f7fd f99f 	bl	8003450 <chOQPutTimeout>
 8006112:	4603      	mov	r3, r0
}
 8006114:	4618      	mov	r0, r3
 8006116:	b005      	add	sp, #20
 8006118:	f85d fb04 	ldr.w	pc, [sp], #4
 800611c:	f3af 8000 	nop.w

08006120 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
 8006120:	b500      	push	{lr}
 8006122:	b083      	sub	sp, #12
 8006124:	9001      	str	r0, [sp, #4]
 8006126:	9100      	str	r1, [sp, #0]

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8006128:	9b01      	ldr	r3, [sp, #4]
 800612a:	330c      	adds	r3, #12
 800612c:	4618      	mov	r0, r3
 800612e:	9900      	ldr	r1, [sp, #0]
 8006130:	f7fd f8a6 	bl	8003280 <chIQGetTimeout>
 8006134:	4603      	mov	r3, r0
}
 8006136:	4618      	mov	r0, r3
 8006138:	b003      	add	sp, #12
 800613a:	f85d fb04 	ldr.w	pc, [sp], #4
 800613e:	bf00      	nop

08006140 <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
 8006140:	b500      	push	{lr}
 8006142:	b085      	sub	sp, #20
 8006144:	9003      	str	r0, [sp, #12]
 8006146:	9102      	str	r1, [sp, #8]
 8006148:	9201      	str	r2, [sp, #4]
 800614a:	9300      	str	r3, [sp, #0]

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 800614c:	9b03      	ldr	r3, [sp, #12]
 800614e:	3330      	adds	r3, #48	; 0x30
 8006150:	4618      	mov	r0, r3
 8006152:	9902      	ldr	r1, [sp, #8]
 8006154:	9a01      	ldr	r2, [sp, #4]
 8006156:	9b00      	ldr	r3, [sp, #0]
 8006158:	f7fd f9f2 	bl	8003540 <chOQWriteTimeout>
 800615c:	4603      	mov	r3, r0
}
 800615e:	4618      	mov	r0, r3
 8006160:	b005      	add	sp, #20
 8006162:	f85d fb04 	ldr.w	pc, [sp], #4
 8006166:	bf00      	nop
 8006168:	f3af 8000 	nop.w
 800616c:	f3af 8000 	nop.w

08006170 <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
 8006170:	b500      	push	{lr}
 8006172:	b085      	sub	sp, #20
 8006174:	9003      	str	r0, [sp, #12]
 8006176:	9102      	str	r1, [sp, #8]
 8006178:	9201      	str	r2, [sp, #4]
 800617a:	9300      	str	r3, [sp, #0]

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 800617c:	9b03      	ldr	r3, [sp, #12]
 800617e:	330c      	adds	r3, #12
 8006180:	4618      	mov	r0, r3
 8006182:	9902      	ldr	r1, [sp, #8]
 8006184:	9a01      	ldr	r2, [sp, #4]
 8006186:	9b00      	ldr	r3, [sp, #0]
 8006188:	f7fd f8c2 	bl	8003310 <chIQReadTimeout>
 800618c:	4603      	mov	r3, r0
}
 800618e:	4618      	mov	r0, r3
 8006190:	b005      	add	sp, #20
 8006192:	f85d fb04 	ldr.w	pc, [sp], #4
 8006196:	bf00      	nop
 8006198:	f3af 8000 	nop.w
 800619c:	f3af 8000 	nop.w

080061a0 <sdInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void sdInit(void) {
 80061a0:	b508      	push	{r3, lr}

  sd_lld_init();
 80061a2:	f005 fc3d 	bl	800ba20 <sd_lld_init>
}
 80061a6:	bd08      	pop	{r3, pc}
 80061a8:	f3af 8000 	nop.w
 80061ac:	f3af 8000 	nop.w

080061b0 <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
 80061b0:	b500      	push	{lr}
 80061b2:	b087      	sub	sp, #28
 80061b4:	9005      	str	r0, [sp, #20]
 80061b6:	9104      	str	r1, [sp, #16]
 80061b8:	9203      	str	r2, [sp, #12]

  sdp->vmt = &vmt;
 80061ba:	9b05      	ldr	r3, [sp, #20]
 80061bc:	4a13      	ldr	r2, [pc, #76]	; (800620c <sdObjectInit+0x5c>)
 80061be:	601a      	str	r2, [r3, #0]
  osalEventObjectInit(&sdp->event);
 80061c0:	9b05      	ldr	r3, [sp, #20]
 80061c2:	3304      	adds	r3, #4
 80061c4:	4618      	mov	r0, r3
 80061c6:	f7ff ff1b 	bl	8006000 <osalEventObjectInit>
  sdp->state = SD_STOP;
 80061ca:	9b05      	ldr	r3, [sp, #20]
 80061cc:	2201      	movs	r2, #1
 80061ce:	721a      	strb	r2, [r3, #8]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80061d0:	9b05      	ldr	r3, [sp, #20]
 80061d2:	f103 020c 	add.w	r2, r3, #12
 80061d6:	9b05      	ldr	r3, [sp, #20]
 80061d8:	3354      	adds	r3, #84	; 0x54
 80061da:	9905      	ldr	r1, [sp, #20]
 80061dc:	9100      	str	r1, [sp, #0]
 80061de:	4610      	mov	r0, r2
 80061e0:	4619      	mov	r1, r3
 80061e2:	2210      	movs	r2, #16
 80061e4:	9b04      	ldr	r3, [sp, #16]
 80061e6:	f7fc ffdb 	bl	80031a0 <chIQObjectInit>
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
 80061ea:	9b05      	ldr	r3, [sp, #20]
 80061ec:	f103 0230 	add.w	r2, r3, #48	; 0x30
 80061f0:	9b05      	ldr	r3, [sp, #20]
 80061f2:	3364      	adds	r3, #100	; 0x64
 80061f4:	9905      	ldr	r1, [sp, #20]
 80061f6:	9100      	str	r1, [sp, #0]
 80061f8:	4610      	mov	r0, r2
 80061fa:	4619      	mov	r1, r3
 80061fc:	2210      	movs	r2, #16
 80061fe:	9b03      	ldr	r3, [sp, #12]
 8006200:	f7fd f8de 	bl	80033c0 <chOQObjectInit>
}
 8006204:	b007      	add	sp, #28
 8006206:	f85d fb04 	ldr.w	pc, [sp], #4
 800620a:	bf00      	nop
 800620c:	08019470 	.word	0x08019470

08006210 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 8006210:	b500      	push	{lr}
 8006212:	b083      	sub	sp, #12
 8006214:	9001      	str	r0, [sp, #4]
 8006216:	9100      	str	r1, [sp, #0]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006218:	f7ff feda 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
 800621c:	9801      	ldr	r0, [sp, #4]
 800621e:	9900      	ldr	r1, [sp, #0]
 8006220:	f005 fc1e 	bl	800ba60 <sd_lld_start>
  sdp->state = SD_READY;
 8006224:	9b01      	ldr	r3, [sp, #4]
 8006226:	2202      	movs	r2, #2
 8006228:	721a      	strb	r2, [r3, #8]
  osalSysUnlock();
 800622a:	f7ff fed9 	bl	8005fe0 <osalSysUnlock>
}
 800622e:	b003      	add	sp, #12
 8006230:	f85d fb04 	ldr.w	pc, [sp], #4
 8006234:	f3af 8000 	nop.w
 8006238:	f3af 8000 	nop.w
 800623c:	f3af 8000 	nop.w

08006240 <sdStop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @api
 */
void sdStop(SerialDriver *sdp) {
 8006240:	b500      	push	{lr}
 8006242:	b083      	sub	sp, #12
 8006244:	9001      	str	r0, [sp, #4]

  osalDbgCheck(sdp != NULL);

  osalSysLock();
 8006246:	f7ff fec3 	bl	8005fd0 <osalSysLock>
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_stop(sdp);
 800624a:	9801      	ldr	r0, [sp, #4]
 800624c:	f005 fc30 	bl	800bab0 <sd_lld_stop>
  sdp->state = SD_STOP;
 8006250:	9b01      	ldr	r3, [sp, #4]
 8006252:	2201      	movs	r2, #1
 8006254:	721a      	strb	r2, [r3, #8]
  oqResetI(&sdp->oqueue);
 8006256:	9b01      	ldr	r3, [sp, #4]
 8006258:	3330      	adds	r3, #48	; 0x30
 800625a:	4618      	mov	r0, r3
 800625c:	f7fd f8d8 	bl	8003410 <chOQResetI>
  iqResetI(&sdp->iqueue);
 8006260:	9b01      	ldr	r3, [sp, #4]
 8006262:	330c      	adds	r3, #12
 8006264:	4618      	mov	r0, r3
 8006266:	f7fc ffc3 	bl	80031f0 <chIQResetI>
  osalOsRescheduleS();
 800626a:	f7ff fec1 	bl	8005ff0 <osalOsRescheduleS>
  osalSysUnlock();
 800626e:	f7ff feb7 	bl	8005fe0 <osalSysUnlock>
}
 8006272:	b003      	add	sp, #12
 8006274:	f85d fb04 	ldr.w	pc, [sp], #4
 8006278:	f3af 8000 	nop.w
 800627c:	f3af 8000 	nop.w

08006280 <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
 8006280:	b500      	push	{lr}
 8006282:	b083      	sub	sp, #12
 8006284:	9001      	str	r0, [sp, #4]
 8006286:	460b      	mov	r3, r1
 8006288:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 800628c:	9b01      	ldr	r3, [sp, #4]
 800628e:	330c      	adds	r3, #12
 8006290:	4618      	mov	r0, r3
 8006292:	f7ff fe7d 	bl	8005f90 <chIQIsEmptyI>
 8006296:	4603      	mov	r3, r0
 8006298:	2b00      	cmp	r3, #0
 800629a:	d005      	beq.n	80062a8 <sdIncomingDataI+0x28>
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
 800629c:	9b01      	ldr	r3, [sp, #4]
 800629e:	3304      	adds	r3, #4
 80062a0:	4618      	mov	r0, r3
 80062a2:	2104      	movs	r1, #4
 80062a4:	f7ff febc 	bl	8006020 <osalEventBroadcastFlagsI>
  if (iqPutI(&sdp->iqueue, b) < Q_OK)
 80062a8:	9b01      	ldr	r3, [sp, #4]
 80062aa:	f103 020c 	add.w	r2, r3, #12
 80062ae:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80062b2:	4610      	mov	r0, r2
 80062b4:	4619      	mov	r1, r3
 80062b6:	f7fc ffb3 	bl	8003220 <chIQPutI>
 80062ba:	4603      	mov	r3, r0
 80062bc:	2b00      	cmp	r3, #0
 80062be:	da05      	bge.n	80062cc <sdIncomingDataI+0x4c>
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
 80062c0:	9b01      	ldr	r3, [sp, #4]
 80062c2:	3304      	adds	r3, #4
 80062c4:	4618      	mov	r0, r3
 80062c6:	2180      	movs	r1, #128	; 0x80
 80062c8:	f7ff feaa 	bl	8006020 <osalEventBroadcastFlagsI>
}
 80062cc:	b003      	add	sp, #12
 80062ce:	f85d fb04 	ldr.w	pc, [sp], #4
 80062d2:	bf00      	nop
 80062d4:	f3af 8000 	nop.w
 80062d8:	f3af 8000 	nop.w
 80062dc:	f3af 8000 	nop.w

080062e0 <sdRequestDataI>:
 * @retval Q_EMPTY      if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
 80062e0:	b500      	push	{lr}
 80062e2:	b085      	sub	sp, #20
 80062e4:	9001      	str	r0, [sp, #4]
  msg_t  b;

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
 80062e6:	9b01      	ldr	r3, [sp, #4]
 80062e8:	3330      	adds	r3, #48	; 0x30
 80062ea:	4618      	mov	r0, r3
 80062ec:	f7fd f8f8 	bl	80034e0 <chOQGetI>
 80062f0:	9003      	str	r0, [sp, #12]
  if (b < Q_OK)
 80062f2:	9b03      	ldr	r3, [sp, #12]
 80062f4:	2b00      	cmp	r3, #0
 80062f6:	da05      	bge.n	8006304 <sdRequestDataI+0x24>
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 80062f8:	9b01      	ldr	r3, [sp, #4]
 80062fa:	3304      	adds	r3, #4
 80062fc:	4618      	mov	r0, r3
 80062fe:	2108      	movs	r1, #8
 8006300:	f7ff fe8e 	bl	8006020 <osalEventBroadcastFlagsI>
  return b;
 8006304:	9b03      	ldr	r3, [sp, #12]
}
 8006306:	4618      	mov	r0, r3
 8006308:	b005      	add	sp, #20
 800630a:	f85d fb04 	ldr.w	pc, [sp], #4
 800630e:	bf00      	nop

08006310 <sdPutWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdPutWouldBlock(SerialDriver *sdp) {
 8006310:	b500      	push	{lr}
 8006312:	b085      	sub	sp, #20
 8006314:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006316:	f7ff fe5b 	bl	8005fd0 <osalSysLock>
  b = oqIsFullI(&sdp->oqueue);
 800631a:	9b01      	ldr	r3, [sp, #4]
 800631c:	3330      	adds	r3, #48	; 0x30
 800631e:	4618      	mov	r0, r3
 8006320:	f7ff fe46 	bl	8005fb0 <chOQIsFullI>
 8006324:	4603      	mov	r3, r0
 8006326:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800632a:	f7ff fe59 	bl	8005fe0 <osalSysUnlock>

  return b;
 800632e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006332:	4618      	mov	r0, r3
 8006334:	b005      	add	sp, #20
 8006336:	f85d fb04 	ldr.w	pc, [sp], #4
 800633a:	bf00      	nop
 800633c:	f3af 8000 	nop.w

08006340 <sdGetWouldBlock>:
 *
 * @deprecated
 *
 * @api
 */
bool sdGetWouldBlock(SerialDriver *sdp) {
 8006340:	b500      	push	{lr}
 8006342:	b085      	sub	sp, #20
 8006344:	9001      	str	r0, [sp, #4]
  bool b;

  osalSysLock();
 8006346:	f7ff fe43 	bl	8005fd0 <osalSysLock>
  b = iqIsEmptyI(&sdp->iqueue);
 800634a:	9b01      	ldr	r3, [sp, #4]
 800634c:	330c      	adds	r3, #12
 800634e:	4618      	mov	r0, r3
 8006350:	f7ff fe1e 	bl	8005f90 <chIQIsEmptyI>
 8006354:	4603      	mov	r3, r0
 8006356:	f88d 300f 	strb.w	r3, [sp, #15]
  osalSysUnlock();
 800635a:	f7ff fe41 	bl	8005fe0 <osalSysUnlock>

  return b;
 800635e:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 8006362:	4618      	mov	r0, r3
 8006364:	b005      	add	sp, #20
 8006366:	f85d fb04 	ldr.w	pc, [sp], #4
 800636a:	bf00      	nop
 800636c:	f3af 8000 	nop.w

08006370 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006370:	b082      	sub	sp, #8
 8006372:	2320      	movs	r3, #32
 8006374:	9301      	str	r3, [sp, #4]
 8006376:	9b01      	ldr	r3, [sp, #4]
 8006378:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800637c:	b002      	add	sp, #8
 800637e:	4770      	bx	lr

08006380 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006380:	b082      	sub	sp, #8
 8006382:	2300      	movs	r3, #0
 8006384:	9301      	str	r3, [sp, #4]
 8006386:	9b01      	ldr	r3, [sp, #4]
 8006388:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800638c:	b002      	add	sp, #8
 800638e:	4770      	bx	lr

08006390 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006390:	b508      	push	{r3, lr}

  port_lock();
 8006392:	f7ff ffed 	bl	8006370 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006396:	bd08      	pop	{r3, pc}
 8006398:	f3af 8000 	nop.w
 800639c:	f3af 8000 	nop.w

080063a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80063a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80063a2:	f7ff ffed 	bl	8006380 <port_unlock>
}
 80063a6:	bd08      	pop	{r3, pc}
 80063a8:	f3af 8000 	nop.w
 80063ac:	f3af 8000 	nop.w

080063b0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 80063b0:	b508      	push	{r3, lr}

  chSysLock();
 80063b2:	f7ff ffed 	bl	8006390 <chSysLock>
}
 80063b6:	bd08      	pop	{r3, pc}
 80063b8:	f3af 8000 	nop.w
 80063bc:	f3af 8000 	nop.w

080063c0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80063c0:	b508      	push	{r3, lr}

  chSysUnlock();
 80063c2:	f7ff ffed 	bl	80063a0 <chSysUnlock>
}
 80063c6:	bd08      	pop	{r3, pc}
 80063c8:	f3af 8000 	nop.w
 80063cc:	f3af 8000 	nop.w

080063d0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80063d0:	b500      	push	{lr}
 80063d2:	b083      	sub	sp, #12
 80063d4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80063d6:	9801      	ldr	r0, [sp, #4]
 80063d8:	f7fb f83a 	bl	8001450 <chThdSuspendS>
 80063dc:	4603      	mov	r3, r0
}
 80063de:	4618      	mov	r0, r3
 80063e0:	b003      	add	sp, #12
 80063e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80063e6:	bf00      	nop
 80063e8:	f3af 8000 	nop.w
 80063ec:	f3af 8000 	nop.w

080063f0 <osalMutexObjectInit>:
 *
 * @param[out] mp       pointer to the @p mutex_t object
 *
 * @init
 */
static inline void osalMutexObjectInit(mutex_t *mp) {
 80063f0:	b500      	push	{lr}
 80063f2:	b083      	sub	sp, #12
 80063f4:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxObjectInit(mp);
 80063f6:	9801      	ldr	r0, [sp, #4]
 80063f8:	f7fb fd7a 	bl	8001ef0 <chMtxObjectInit>
#elif CH_CFG_USE_SEMAPHORES
  chSemObjectInit((semaphore_t *)mp, 1);
#else
 *mp = 0;
#endif
}
 80063fc:	b003      	add	sp, #12
 80063fe:	f85d fb04 	ldr.w	pc, [sp], #4
 8006402:	bf00      	nop
 8006404:	f3af 8000 	nop.w
 8006408:	f3af 8000 	nop.w
 800640c:	f3af 8000 	nop.w

08006410 <osalMutexLock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {
 8006410:	b500      	push	{lr}
 8006412:	b083      	sub	sp, #12
 8006414:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8006416:	9801      	ldr	r0, [sp, #4]
 8006418:	f7fb fd7a 	bl	8001f10 <chMtxLock>
#elif CH_CFG_USE_SEMAPHORES
  chSemWait((semaphore_t *)mp);
#else
  *mp = 1;
#endif
}
 800641c:	b003      	add	sp, #12
 800641e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006422:	bf00      	nop
 8006424:	f3af 8000 	nop.w
 8006428:	f3af 8000 	nop.w
 800642c:	f3af 8000 	nop.w

08006430 <osalMutexUnlock>:
 *
 * @param[in,out] mp    pointer to the @p mutex_t object
 *
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {
 8006430:	b500      	push	{lr}
 8006432:	b083      	sub	sp, #12
 8006434:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8006436:	9801      	ldr	r0, [sp, #4]
 8006438:	f7fb fe12 	bl	8002060 <chMtxUnlock>
#elif CH_CFG_USE_SEMAPHORES
  chSemSignal((semaphore_t *)mp);
#else
  *mp = 0;
#endif
}
 800643c:	b003      	add	sp, #12
 800643e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006442:	bf00      	nop
 8006444:	f3af 8000 	nop.w
 8006448:	f3af 8000 	nop.w
 800644c:	f3af 8000 	nop.w

08006450 <spiInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void spiInit(void) {
 8006450:	b508      	push	{r3, lr}

  spi_lld_init();
 8006452:	f004 fdb5 	bl	800afc0 <spi_lld_init>
}
 8006456:	bd08      	pop	{r3, pc}
 8006458:	f3af 8000 	nop.w
 800645c:	f3af 8000 	nop.w

08006460 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
 8006460:	b500      	push	{lr}
 8006462:	b083      	sub	sp, #12
 8006464:	9001      	str	r0, [sp, #4]

  spip->state = SPI_STOP;
 8006466:	9b01      	ldr	r3, [sp, #4]
 8006468:	2201      	movs	r2, #1
 800646a:	701a      	strb	r2, [r3, #0]
  spip->config = NULL;
 800646c:	9b01      	ldr	r3, [sp, #4]
 800646e:	2200      	movs	r2, #0
 8006470:	605a      	str	r2, [r3, #4]
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
 8006472:	9b01      	ldr	r3, [sp, #4]
 8006474:	2200      	movs	r2, #0
 8006476:	609a      	str	r2, [r3, #8]
#endif
#if SPI_USE_MUTUAL_EXCLUSION == TRUE
  osalMutexObjectInit(&spip->mutex);
 8006478:	9b01      	ldr	r3, [sp, #4]
 800647a:	330c      	adds	r3, #12
 800647c:	4618      	mov	r0, r3
 800647e:	f7ff ffb7 	bl	80063f0 <osalMutexObjectInit>
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
 8006482:	b003      	add	sp, #12
 8006484:	f85d fb04 	ldr.w	pc, [sp], #4
 8006488:	f3af 8000 	nop.w
 800648c:	f3af 8000 	nop.w

08006490 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
 8006490:	b500      	push	{lr}
 8006492:	b083      	sub	sp, #12
 8006494:	9001      	str	r0, [sp, #4]
 8006496:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
 8006498:	f7ff ff8a 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
 800649c:	9b01      	ldr	r3, [sp, #4]
 800649e:	9a00      	ldr	r2, [sp, #0]
 80064a0:	605a      	str	r2, [r3, #4]
  spi_lld_start(spip);
 80064a2:	9801      	ldr	r0, [sp, #4]
 80064a4:	f004 fdac 	bl	800b000 <spi_lld_start>
  spip->state = SPI_READY;
 80064a8:	9b01      	ldr	r3, [sp, #4]
 80064aa:	2202      	movs	r2, #2
 80064ac:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064ae:	f7ff ff87 	bl	80063c0 <osalSysUnlock>
}
 80064b2:	b003      	add	sp, #12
 80064b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80064b8:	f3af 8000 	nop.w
 80064bc:	f3af 8000 	nop.w

080064c0 <spiStop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiStop(SPIDriver *spip) {
 80064c0:	b500      	push	{lr}
 80064c2:	b083      	sub	sp, #12
 80064c4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064c6:	f7ff ff73 	bl	80063b0 <osalSysLock>
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spi_lld_stop(spip);
 80064ca:	9801      	ldr	r0, [sp, #4]
 80064cc:	f004 fe28 	bl	800b120 <spi_lld_stop>
  spip->state = SPI_STOP;
 80064d0:	9b01      	ldr	r3, [sp, #4]
 80064d2:	2201      	movs	r2, #1
 80064d4:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 80064d6:	f7ff ff73 	bl	80063c0 <osalSysUnlock>
}
 80064da:	b003      	add	sp, #12
 80064dc:	f85d fb04 	ldr.w	pc, [sp], #4

080064e0 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
 80064e0:	b500      	push	{lr}
 80064e2:	b083      	sub	sp, #12
 80064e4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 80064e6:	f7ff ff63 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
 80064ea:	9801      	ldr	r0, [sp, #4]
 80064ec:	f004 fe48 	bl	800b180 <spi_lld_select>
  osalSysUnlock();
 80064f0:	f7ff ff66 	bl	80063c0 <osalSysUnlock>
}
 80064f4:	b003      	add	sp, #12
 80064f6:	f85d fb04 	ldr.w	pc, [sp], #4
 80064fa:	bf00      	nop
 80064fc:	f3af 8000 	nop.w

08006500 <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
 8006500:	b500      	push	{lr}
 8006502:	b083      	sub	sp, #12
 8006504:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalSysLock();
 8006506:	f7ff ff53 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
 800650a:	9801      	ldr	r0, [sp, #4]
 800650c:	f004 fe48 	bl	800b1a0 <spi_lld_unselect>
  osalSysUnlock();
 8006510:	f7ff ff56 	bl	80063c0 <osalSysUnlock>
}
 8006514:	b003      	add	sp, #12
 8006516:	f85d fb04 	ldr.w	pc, [sp], #4
 800651a:	bf00      	nop
 800651c:	f3af 8000 	nop.w

08006520 <spiStartIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiStartIgnore(SPIDriver *spip, size_t n) {
 8006520:	b500      	push	{lr}
 8006522:	b083      	sub	sp, #12
 8006524:	9001      	str	r0, [sp, #4]
 8006526:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 8006528:	f7ff ff42 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartIgnoreI(spip, n);
 800652c:	9b01      	ldr	r3, [sp, #4]
 800652e:	2203      	movs	r2, #3
 8006530:	701a      	strb	r2, [r3, #0]
 8006532:	9801      	ldr	r0, [sp, #4]
 8006534:	9900      	ldr	r1, [sp, #0]
 8006536:	f004 fe43 	bl	800b1c0 <spi_lld_ignore>
  osalSysUnlock();
 800653a:	f7ff ff41 	bl	80063c0 <osalSysUnlock>
}
 800653e:	b003      	add	sp, #12
 8006540:	f85d fb04 	ldr.w	pc, [sp], #4
 8006544:	f3af 8000 	nop.w
 8006548:	f3af 8000 	nop.w
 800654c:	f3af 8000 	nop.w

08006550 <spiStartExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartExchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 8006550:	b500      	push	{lr}
 8006552:	b085      	sub	sp, #20
 8006554:	9003      	str	r0, [sp, #12]
 8006556:	9102      	str	r1, [sp, #8]
 8006558:	9201      	str	r2, [sp, #4]
 800655a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800655c:	f7ff ff28 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006560:	9b03      	ldr	r3, [sp, #12]
 8006562:	2203      	movs	r2, #3
 8006564:	701a      	strb	r2, [r3, #0]
 8006566:	9803      	ldr	r0, [sp, #12]
 8006568:	9902      	ldr	r1, [sp, #8]
 800656a:	9a01      	ldr	r2, [sp, #4]
 800656c:	9b00      	ldr	r3, [sp, #0]
 800656e:	f004 fea7 	bl	800b2c0 <spi_lld_exchange>
  osalSysUnlock();
 8006572:	f7ff ff25 	bl	80063c0 <osalSysUnlock>
}
 8006576:	b005      	add	sp, #20
 8006578:	f85d fb04 	ldr.w	pc, [sp], #4
 800657c:	f3af 8000 	nop.w

08006580 <spiStartSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiStartSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006580:	b500      	push	{lr}
 8006582:	b085      	sub	sp, #20
 8006584:	9003      	str	r0, [sp, #12]
 8006586:	9102      	str	r1, [sp, #8]
 8006588:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800658a:	f7ff ff11 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartSendI(spip, n, txbuf);
 800658e:	9b03      	ldr	r3, [sp, #12]
 8006590:	2203      	movs	r2, #3
 8006592:	701a      	strb	r2, [r3, #0]
 8006594:	9803      	ldr	r0, [sp, #12]
 8006596:	9902      	ldr	r1, [sp, #8]
 8006598:	9a01      	ldr	r2, [sp, #4]
 800659a:	f004 ff19 	bl	800b3d0 <spi_lld_send>
  osalSysUnlock();
 800659e:	f7ff ff0f 	bl	80063c0 <osalSysUnlock>
}
 80065a2:	b005      	add	sp, #20
 80065a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065a8:	f3af 8000 	nop.w
 80065ac:	f3af 8000 	nop.w

080065b0 <spiStartReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiStartReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 80065b0:	b500      	push	{lr}
 80065b2:	b085      	sub	sp, #20
 80065b4:	9003      	str	r0, [sp, #12]
 80065b6:	9102      	str	r1, [sp, #8]
 80065b8:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 80065ba:	f7ff fef9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiStartReceiveI(spip, n, rxbuf);
 80065be:	9b03      	ldr	r3, [sp, #12]
 80065c0:	2203      	movs	r2, #3
 80065c2:	701a      	strb	r2, [r3, #0]
 80065c4:	9803      	ldr	r0, [sp, #12]
 80065c6:	9902      	ldr	r1, [sp, #8]
 80065c8:	9a01      	ldr	r2, [sp, #4]
 80065ca:	f004 ff81 	bl	800b4d0 <spi_lld_receive>
  osalSysUnlock();
 80065ce:	f7ff fef7 	bl	80063c0 <osalSysUnlock>
}
 80065d2:	b005      	add	sp, #20
 80065d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80065d8:	f3af 8000 	nop.w
 80065dc:	f3af 8000 	nop.w

080065e0 <spiIgnore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @api
 */
void spiIgnore(SPIDriver *spip, size_t n) {
 80065e0:	b500      	push	{lr}
 80065e2:	b083      	sub	sp, #12
 80065e4:	9001      	str	r0, [sp, #4]
 80065e6:	9100      	str	r1, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U));

  osalSysLock();
 80065e8:	f7ff fee2 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartIgnoreI(spip, n);
 80065ec:	9b01      	ldr	r3, [sp, #4]
 80065ee:	2203      	movs	r2, #3
 80065f0:	701a      	strb	r2, [r3, #0]
 80065f2:	9801      	ldr	r0, [sp, #4]
 80065f4:	9900      	ldr	r1, [sp, #0]
 80065f6:	f004 fde3 	bl	800b1c0 <spi_lld_ignore>
  (void) osalThreadSuspendS(&spip->thread);
 80065fa:	9b01      	ldr	r3, [sp, #4]
 80065fc:	3308      	adds	r3, #8
 80065fe:	4618      	mov	r0, r3
 8006600:	f7ff fee6 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006604:	f7ff fedc 	bl	80063c0 <osalSysUnlock>
}
 8006608:	b003      	add	sp, #12
 800660a:	f85d fb04 	ldr.w	pc, [sp], #4
 800660e:	bf00      	nop

08006610 <spiExchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiExchange(SPIDriver *spip, size_t n,
                 const void *txbuf, void *rxbuf) {
 8006610:	b500      	push	{lr}
 8006612:	b085      	sub	sp, #20
 8006614:	9003      	str	r0, [sp, #12]
 8006616:	9102      	str	r1, [sp, #8]
 8006618:	9201      	str	r2, [sp, #4]
 800661a:	9300      	str	r3, [sp, #0]

  osalDbgCheck((spip != NULL) && (n > 0U) &&
               (rxbuf != NULL) && (txbuf != NULL));

  osalSysLock();
 800661c:	f7ff fec8 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartExchangeI(spip, n, txbuf, rxbuf);
 8006620:	9b03      	ldr	r3, [sp, #12]
 8006622:	2203      	movs	r2, #3
 8006624:	701a      	strb	r2, [r3, #0]
 8006626:	9803      	ldr	r0, [sp, #12]
 8006628:	9902      	ldr	r1, [sp, #8]
 800662a:	9a01      	ldr	r2, [sp, #4]
 800662c:	9b00      	ldr	r3, [sp, #0]
 800662e:	f004 fe47 	bl	800b2c0 <spi_lld_exchange>
  (void) osalThreadSuspendS(&spip->thread);
 8006632:	9b03      	ldr	r3, [sp, #12]
 8006634:	3308      	adds	r3, #8
 8006636:	4618      	mov	r0, r3
 8006638:	f7ff feca 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 800663c:	f7ff fec0 	bl	80063c0 <osalSysUnlock>
}
 8006640:	b005      	add	sp, #20
 8006642:	f85d fb04 	ldr.w	pc, [sp], #4
 8006646:	bf00      	nop
 8006648:	f3af 8000 	nop.w
 800664c:	f3af 8000 	nop.w

08006650 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
 8006650:	b500      	push	{lr}
 8006652:	b085      	sub	sp, #20
 8006654:	9003      	str	r0, [sp, #12]
 8006656:	9102      	str	r1, [sp, #8]
 8006658:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
 800665a:	f7ff fea9 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
 800665e:	9b03      	ldr	r3, [sp, #12]
 8006660:	2203      	movs	r2, #3
 8006662:	701a      	strb	r2, [r3, #0]
 8006664:	9803      	ldr	r0, [sp, #12]
 8006666:	9902      	ldr	r1, [sp, #8]
 8006668:	9a01      	ldr	r2, [sp, #4]
 800666a:	f004 feb1 	bl	800b3d0 <spi_lld_send>
  (void) osalThreadSuspendS(&spip->thread);
 800666e:	9b03      	ldr	r3, [sp, #12]
 8006670:	3308      	adds	r3, #8
 8006672:	4618      	mov	r0, r3
 8006674:	f7ff feac 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 8006678:	f7ff fea2 	bl	80063c0 <osalSysUnlock>
}
 800667c:	b005      	add	sp, #20
 800667e:	f85d fb04 	ldr.w	pc, [sp], #4
 8006682:	bf00      	nop
 8006684:	f3af 8000 	nop.w
 8006688:	f3af 8000 	nop.w
 800668c:	f3af 8000 	nop.w

08006690 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
 8006690:	b500      	push	{lr}
 8006692:	b085      	sub	sp, #20
 8006694:	9003      	str	r0, [sp, #12]
 8006696:	9102      	str	r1, [sp, #8]
 8006698:	9201      	str	r2, [sp, #4]

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
 800669a:	f7ff fe89 	bl	80063b0 <osalSysLock>
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
 800669e:	9b03      	ldr	r3, [sp, #12]
 80066a0:	2203      	movs	r2, #3
 80066a2:	701a      	strb	r2, [r3, #0]
 80066a4:	9803      	ldr	r0, [sp, #12]
 80066a6:	9902      	ldr	r1, [sp, #8]
 80066a8:	9a01      	ldr	r2, [sp, #4]
 80066aa:	f004 ff11 	bl	800b4d0 <spi_lld_receive>
  (void) osalThreadSuspendS(&spip->thread);
 80066ae:	9b03      	ldr	r3, [sp, #12]
 80066b0:	3308      	adds	r3, #8
 80066b2:	4618      	mov	r0, r3
 80066b4:	f7ff fe8c 	bl	80063d0 <osalThreadSuspendS>
  osalSysUnlock();
 80066b8:	f7ff fe82 	bl	80063c0 <osalSysUnlock>
}
 80066bc:	b005      	add	sp, #20
 80066be:	f85d fb04 	ldr.w	pc, [sp], #4
 80066c2:	bf00      	nop
 80066c4:	f3af 8000 	nop.w
 80066c8:	f3af 8000 	nop.w
 80066cc:	f3af 8000 	nop.w

080066d0 <spiAcquireBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiAcquireBus(SPIDriver *spip) {
 80066d0:	b500      	push	{lr}
 80066d2:	b083      	sub	sp, #12
 80066d4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexLock(&spip->mutex);
 80066d6:	9b01      	ldr	r3, [sp, #4]
 80066d8:	330c      	adds	r3, #12
 80066da:	4618      	mov	r0, r3
 80066dc:	f7ff fe98 	bl	8006410 <osalMutexLock>
}
 80066e0:	b003      	add	sp, #12
 80066e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80066e6:	bf00      	nop
 80066e8:	f3af 8000 	nop.w
 80066ec:	f3af 8000 	nop.w

080066f0 <spiReleaseBus>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiReleaseBus(SPIDriver *spip) {
 80066f0:	b500      	push	{lr}
 80066f2:	b083      	sub	sp, #12
 80066f4:	9001      	str	r0, [sp, #4]

  osalDbgCheck(spip != NULL);

  osalMutexUnlock(&spip->mutex);
 80066f6:	9b01      	ldr	r3, [sp, #4]
 80066f8:	330c      	adds	r3, #12
 80066fa:	4618      	mov	r0, r3
 80066fc:	f7ff fe98 	bl	8006430 <osalMutexUnlock>
}
 8006700:	b003      	add	sp, #12
 8006702:	f85d fb04 	ldr.w	pc, [sp], #4
 8006706:	bf00      	nop
 8006708:	f3af 8000 	nop.w
 800670c:	f3af 8000 	nop.w

08006710 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8006710:	b082      	sub	sp, #8
 8006712:	2320      	movs	r3, #32
 8006714:	9301      	str	r3, [sp, #4]
 8006716:	9b01      	ldr	r3, [sp, #4]
 8006718:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800671c:	b002      	add	sp, #8
 800671e:	4770      	bx	lr

08006720 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8006720:	b082      	sub	sp, #8
 8006722:	2300      	movs	r3, #0
 8006724:	9301      	str	r3, [sp, #4]
 8006726:	9b01      	ldr	r3, [sp, #4]
 8006728:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800672c:	b002      	add	sp, #8
 800672e:	4770      	bx	lr

08006730 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8006730:	b508      	push	{r3, lr}

  port_lock();
 8006732:	f7ff ffed 	bl	8006710 <port_lock>
}
 8006736:	bd08      	pop	{r3, pc}
 8006738:	f3af 8000 	nop.w
 800673c:	f3af 8000 	nop.w

08006740 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8006740:	b508      	push	{r3, lr}

  port_unlock();
 8006742:	f7ff ffed 	bl	8006720 <port_unlock>
}
 8006746:	bd08      	pop	{r3, pc}
 8006748:	f3af 8000 	nop.w
 800674c:	f3af 8000 	nop.w

08006750 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8006750:	b508      	push	{r3, lr}

  port_lock();
 8006752:	f7ff ffdd 	bl	8006710 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8006756:	bd08      	pop	{r3, pc}
 8006758:	f3af 8000 	nop.w
 800675c:	f3af 8000 	nop.w

08006760 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8006760:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8006762:	f7ff ffdd 	bl	8006720 <port_unlock>
}
 8006766:	bd08      	pop	{r3, pc}
 8006768:	f3af 8000 	nop.w
 800676c:	f3af 8000 	nop.w

08006770 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8006770:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8006772:	f7ff ffdd 	bl	8006730 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8006776:	bd08      	pop	{r3, pc}
 8006778:	f3af 8000 	nop.w
 800677c:	f3af 8000 	nop.w

08006780 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8006780:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8006782:	f7ff ffdd 	bl	8006740 <port_unlock_from_isr>
}
 8006786:	bd08      	pop	{r3, pc}
 8006788:	f3af 8000 	nop.w
 800678c:	f3af 8000 	nop.w

08006790 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8006790:	b508      	push	{r3, lr}

  chSysLock();
 8006792:	f7ff ffdd 	bl	8006750 <chSysLock>
}
 8006796:	bd08      	pop	{r3, pc}
 8006798:	f3af 8000 	nop.w
 800679c:	f3af 8000 	nop.w

080067a0 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 80067a0:	b508      	push	{r3, lr}

  chSysUnlock();
 80067a2:	f7ff ffdd 	bl	8006760 <chSysUnlock>
}
 80067a6:	bd08      	pop	{r3, pc}
 80067a8:	f3af 8000 	nop.w
 80067ac:	f3af 8000 	nop.w

080067b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 80067b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 80067b2:	f7ff ffdd 	bl	8006770 <chSysLockFromISR>
}
 80067b6:	bd08      	pop	{r3, pc}
 80067b8:	f3af 8000 	nop.w
 80067bc:	f3af 8000 	nop.w

080067c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 80067c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 80067c2:	f7ff ffdd 	bl	8006780 <chSysUnlockFromISR>
}
 80067c6:	bd08      	pop	{r3, pc}
 80067c8:	f3af 8000 	nop.w
 80067cc:	f3af 8000 	nop.w

080067d0 <osalOsRescheduleS>:
 *          required in this scenario.
 * @note    Not implemented in this simplified OSAL.
 *
 * @sclass
 */
static inline void osalOsRescheduleS(void) {
 80067d0:	b508      	push	{r3, lr}

  chSchRescheduleS();
 80067d2:	f7fa fad5 	bl	8000d80 <chSchRescheduleS>
}
 80067d6:	bd08      	pop	{r3, pc}
 80067d8:	f3af 8000 	nop.w
 80067dc:	f3af 8000 	nop.w

080067e0 <get_hword>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static uint16_t get_hword(uint8_t *p) {
 80067e0:	b084      	sub	sp, #16
 80067e2:	9001      	str	r0, [sp, #4]
  uint16_t hw;

  hw  = (uint16_t)*p++;
 80067e4:	9b01      	ldr	r3, [sp, #4]
 80067e6:	1c5a      	adds	r2, r3, #1
 80067e8:	9201      	str	r2, [sp, #4]
 80067ea:	781b      	ldrb	r3, [r3, #0]
 80067ec:	f8ad 300e 	strh.w	r3, [sp, #14]
  hw |= (uint16_t)*p << 8U;
 80067f0:	9b01      	ldr	r3, [sp, #4]
 80067f2:	781b      	ldrb	r3, [r3, #0]
 80067f4:	021b      	lsls	r3, r3, #8
 80067f6:	b29a      	uxth	r2, r3
 80067f8:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 80067fc:	4313      	orrs	r3, r2
 80067fe:	b29b      	uxth	r3, r3
 8006800:	f8ad 300e 	strh.w	r3, [sp, #14]
  return hw;
 8006804:	f8bd 300e 	ldrh.w	r3, [sp, #14]
}
 8006808:	4618      	mov	r0, r3
 800680a:	b004      	add	sp, #16
 800680c:	4770      	bx	lr
 800680e:	bf00      	nop

08006810 <set_address>:
/**
 * @brief  SET ADDRESS transaction callback.
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 */
static void set_address(USBDriver *usbp) {
 8006810:	b500      	push	{lr}
 8006812:	b083      	sub	sp, #12
 8006814:	9001      	str	r0, [sp, #4]

  usbp->address = usbp->setup[2];
 8006816:	9b01      	ldr	r3, [sp, #4]
 8006818:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 800681c:	9b01      	ldr	r3, [sp, #4]
 800681e:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usb_lld_set_address(usbp);
 8006822:	9801      	ldr	r0, [sp, #4]
 8006824:	f002 fcb4 	bl	8009190 <usb_lld_set_address>
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_ADDRESS);
 8006828:	9b01      	ldr	r3, [sp, #4]
 800682a:	685b      	ldr	r3, [r3, #4]
 800682c:	681b      	ldr	r3, [r3, #0]
 800682e:	2b00      	cmp	r3, #0
 8006830:	d005      	beq.n	800683e <set_address+0x2e>
 8006832:	9b01      	ldr	r3, [sp, #4]
 8006834:	685b      	ldr	r3, [r3, #4]
 8006836:	681b      	ldr	r3, [r3, #0]
 8006838:	9801      	ldr	r0, [sp, #4]
 800683a:	2101      	movs	r1, #1
 800683c:	4798      	blx	r3
  usbp->state = USB_SELECTED;
 800683e:	9b01      	ldr	r3, [sp, #4]
 8006840:	2203      	movs	r2, #3
 8006842:	701a      	strb	r2, [r3, #0]
}
 8006844:	b003      	add	sp, #12
 8006846:	f85d fb04 	ldr.w	pc, [sp], #4
 800684a:	bf00      	nop
 800684c:	f3af 8000 	nop.w

08006850 <default_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @return              The request handling exit code.
 * @retval false        Request not recognized by the handler or error.
 * @retval true         Request handled.
 */
static bool default_handler(USBDriver *usbp) {
 8006850:	b570      	push	{r4, r5, r6, lr}
 8006852:	b084      	sub	sp, #16
 8006854:	9001      	str	r0, [sp, #4]
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 8006856:	9b01      	ldr	r3, [sp, #4]
 8006858:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800685c:	f003 027f 	and.w	r2, r3, #127	; 0x7f
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
 8006860:	9b01      	ldr	r3, [sp, #4]
 8006862:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
 8006866:	021b      	lsls	r3, r3, #8
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
                                        USB_RTYPE_TYPE_MASK)) |
 8006868:	4313      	orrs	r3, r2
 */
static bool default_handler(USBDriver *usbp) {
  const USBDescriptor *dp;

  /* Decoding the request.*/
  switch ((((uint32_t)usbp->setup[0] & (USB_RTYPE_RECIPIENT_MASK |
 800686a:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 800686e:	d05a      	beq.n	8006926 <default_handler+0xd6>
 8006870:	f5b3 7f40 	cmp.w	r3, #768	; 0x300
 8006874:	d812      	bhi.n	800689c <default_handler+0x4c>
 8006876:	2b02      	cmp	r3, #2
 8006878:	f000 810f 	beq.w	8006a9a <default_handler+0x24a>
 800687c:	2b02      	cmp	r3, #2
 800687e:	d805      	bhi.n	800688c <default_handler+0x3c>
 8006880:	2b00      	cmp	r3, #0
 8006882:	d028      	beq.n	80068d6 <default_handler+0x86>
 8006884:	2b01      	cmp	r3, #1
 8006886:	f000 80fd 	beq.w	8006a84 <default_handler+0x234>
 800688a:	e1c7      	b.n	8006c1c <default_handler+0x3cc>
 800688c:	f5b3 7f80 	cmp.w	r3, #256	; 0x100
 8006890:	d02e      	beq.n	80068f0 <default_handler+0xa0>
 8006892:	f5b3 7f81 	cmp.w	r3, #258	; 0x102
 8006896:	f000 8157 	beq.w	8006b48 <default_handler+0x2f8>
 800689a:	e1bf      	b.n	8006c1c <default_handler+0x3cc>
 800689c:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a0:	d074      	beq.n	800698c <default_handler+0x13c>
 80068a2:	f5b3 6fc0 	cmp.w	r3, #1536	; 0x600
 80068a6:	d808      	bhi.n	80068ba <default_handler+0x6a>
 80068a8:	f240 3202 	movw	r2, #770	; 0x302
 80068ac:	4293      	cmp	r3, r2
 80068ae:	f000 8180 	beq.w	8006bb2 <default_handler+0x362>
 80068b2:	f5b3 6fa0 	cmp.w	r3, #1280	; 0x500
 80068b6:	d051      	beq.n	800695c <default_handler+0x10c>
 80068b8:	e1b0      	b.n	8006c1c <default_handler+0x3cc>
 80068ba:	f5b3 6f10 	cmp.w	r3, #2304	; 0x900
 80068be:	f000 8098 	beq.w	80069f2 <default_handler+0x1a2>
 80068c2:	f640 4202 	movw	r2, #3074	; 0xc02
 80068c6:	4293      	cmp	r3, r2
 80068c8:	f000 80dc 	beq.w	8006a84 <default_handler+0x234>
 80068cc:	f5b3 6f00 	cmp.w	r3, #2048	; 0x800
 80068d0:	f000 8082 	beq.w	80069d8 <default_handler+0x188>
 80068d4:	e1a2      	b.n	8006c1c <default_handler+0x3cc>
                                        USB_RTYPE_TYPE_MASK)) |
           ((uint32_t)usbp->setup[1] << 8U))) {
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Just returns the current status word.*/
    usbSetupTransfer(usbp, (uint8_t *)&usbp->status, 2, NULL);
 80068d6:	9b01      	ldr	r3, [sp, #4]
 80068d8:	f103 0264 	add.w	r2, r3, #100	; 0x64
 80068dc:	9b01      	ldr	r3, [sp, #4]
 80068de:	651a      	str	r2, [r3, #80]	; 0x50
 80068e0:	9b01      	ldr	r3, [sp, #4]
 80068e2:	2202      	movs	r2, #2
 80068e4:	655a      	str	r2, [r3, #84]	; 0x54
 80068e6:	9b01      	ldr	r3, [sp, #4]
 80068e8:	2200      	movs	r2, #0
 80068ea:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80068ec:	2301      	movs	r3, #1
 80068ee:	e196      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 80068f0:	9b01      	ldr	r3, [sp, #4]
 80068f2:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80068f6:	2b01      	cmp	r3, #1
 80068f8:	d113      	bne.n	8006922 <default_handler+0xd2>
      usbp->status &= ~2U;
 80068fa:	9b01      	ldr	r3, [sp, #4]
 80068fc:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006900:	f023 0302 	bic.w	r3, r3, #2
 8006904:	b29a      	uxth	r2, r3
 8006906:	9b01      	ldr	r3, [sp, #4]
 8006908:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 800690c:	9b01      	ldr	r3, [sp, #4]
 800690e:	2200      	movs	r2, #0
 8006910:	651a      	str	r2, [r3, #80]	; 0x50
 8006912:	9b01      	ldr	r3, [sp, #4]
 8006914:	2200      	movs	r2, #0
 8006916:	655a      	str	r2, [r3, #84]	; 0x54
 8006918:	9b01      	ldr	r3, [sp, #4]
 800691a:	2200      	movs	r2, #0
 800691c:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 800691e:	2301      	movs	r3, #1
 8006920:	e17d      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006922:	2300      	movs	r3, #0
 8006924:	e17b      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only the DEVICE_REMOTE_WAKEUP is handled here, any other feature
       number is handled as an error.*/
    if (usbp->setup[2] == USB_FEATURE_DEVICE_REMOTE_WAKEUP) {
 8006926:	9b01      	ldr	r3, [sp, #4]
 8006928:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 800692c:	2b01      	cmp	r3, #1
 800692e:	d113      	bne.n	8006958 <default_handler+0x108>
      usbp->status |= 2U;
 8006930:	9b01      	ldr	r3, [sp, #4]
 8006932:	f8b3 3064 	ldrh.w	r3, [r3, #100]	; 0x64
 8006936:	f043 0302 	orr.w	r3, r3, #2
 800693a:	b29a      	uxth	r2, r3
 800693c:	9b01      	ldr	r3, [sp, #4]
 800693e:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
      usbSetupTransfer(usbp, NULL, 0, NULL);
 8006942:	9b01      	ldr	r3, [sp, #4]
 8006944:	2200      	movs	r2, #0
 8006946:	651a      	str	r2, [r3, #80]	; 0x50
 8006948:	9b01      	ldr	r3, [sp, #4]
 800694a:	2200      	movs	r2, #0
 800694c:	655a      	str	r2, [r3, #84]	; 0x54
 800694e:	9b01      	ldr	r3, [sp, #4]
 8006950:	2200      	movs	r2, #0
 8006952:	659a      	str	r2, [r3, #88]	; 0x58
      return true;
 8006954:	2301      	movs	r3, #1
 8006956:	e162      	b.n	8006c1e <default_handler+0x3ce>
    }
    return false;
 8006958:	2300      	movs	r3, #0
 800695a:	e160      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800695c:	9b01      	ldr	r3, [sp, #4]
 800695e:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 8006962:	2b00      	cmp	r3, #0
 8006964:	d107      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
 8006966:	9b01      	ldr	r3, [sp, #4]
 8006968:	f893 305d 	ldrb.w	r3, [r3, #93]	; 0x5d
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_ADDRESS << 8):
    /* The SET_ADDRESS handling can be performed here or postponed after
       the status packed depending on the USB_SET_ADDRESS_MODE low
       driver setting.*/
#if USB_SET_ADDRESS_MODE == USB_EARLY_SET_ADDRESS
    if ((usbp->setup[0] == USB_RTYPE_RECIPIENT_DEVICE) &&
 800696c:	2b05      	cmp	r3, #5
 800696e:	d102      	bne.n	8006976 <default_handler+0x126>
        (usbp->setup[1] == USB_REQ_SET_ADDRESS)) {
      set_address(usbp);
 8006970:	9801      	ldr	r0, [sp, #4]
 8006972:	f7ff ff4d 	bl	8006810 <set_address>
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006976:	9b01      	ldr	r3, [sp, #4]
 8006978:	2200      	movs	r2, #0
 800697a:	651a      	str	r2, [r3, #80]	; 0x50
 800697c:	9b01      	ldr	r3, [sp, #4]
 800697e:	2200      	movs	r2, #0
 8006980:	655a      	str	r2, [r3, #84]	; 0x54
 8006982:	9b01      	ldr	r3, [sp, #4]
 8006984:	2200      	movs	r2, #0
 8006986:	659a      	str	r2, [r3, #88]	; 0x58
#else
    usbSetupTransfer(usbp, NULL, 0, set_address);
#endif
    return true;
 8006988:	2301      	movs	r3, #1
 800698a:	e148      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_DESCRIPTOR << 8):
    /* Handling descriptor requests from the host.*/
    dp = usbp->config->get_descriptor_cb(usbp, usbp->setup[3],
 800698c:	9b01      	ldr	r3, [sp, #4]
 800698e:	685b      	ldr	r3, [r3, #4]
 8006990:	685c      	ldr	r4, [r3, #4]
 8006992:	9b01      	ldr	r3, [sp, #4]
 8006994:	f893 605f 	ldrb.w	r6, [r3, #95]	; 0x5f
 8006998:	9b01      	ldr	r3, [sp, #4]
 800699a:	f893 505e 	ldrb.w	r5, [r3, #94]	; 0x5e
 800699e:	9b01      	ldr	r3, [sp, #4]
 80069a0:	3360      	adds	r3, #96	; 0x60
 80069a2:	4618      	mov	r0, r3
 80069a4:	f7ff ff1c 	bl	80067e0 <get_hword>
 80069a8:	4603      	mov	r3, r0
 80069aa:	9801      	ldr	r0, [sp, #4]
 80069ac:	4631      	mov	r1, r6
 80069ae:	462a      	mov	r2, r5
 80069b0:	47a0      	blx	r4
 80069b2:	9003      	str	r0, [sp, #12]
                                         usbp->setup[2],
                                         get_hword(&usbp->setup[4]));
    if (dp == NULL) {
 80069b4:	9b03      	ldr	r3, [sp, #12]
 80069b6:	2b00      	cmp	r3, #0
 80069b8:	d101      	bne.n	80069be <default_handler+0x16e>
      return false;
 80069ba:	2300      	movs	r3, #0
 80069bc:	e12f      	b.n	8006c1e <default_handler+0x3ce>
    }
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)dp->ud_string, dp->ud_size, NULL);
 80069be:	9b03      	ldr	r3, [sp, #12]
 80069c0:	685a      	ldr	r2, [r3, #4]
 80069c2:	9b01      	ldr	r3, [sp, #4]
 80069c4:	651a      	str	r2, [r3, #80]	; 0x50
 80069c6:	9b03      	ldr	r3, [sp, #12]
 80069c8:	681a      	ldr	r2, [r3, #0]
 80069ca:	9b01      	ldr	r3, [sp, #4]
 80069cc:	655a      	str	r2, [r3, #84]	; 0x54
 80069ce:	9b01      	ldr	r3, [sp, #4]
 80069d0:	2200      	movs	r2, #0
 80069d2:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 80069d4:	2301      	movs	r3, #1
 80069d6:	e122      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_GET_CONFIGURATION << 8):
    /* Returning the last selected configuration.*/
    usbSetupTransfer(usbp, &usbp->configuration, 1, NULL);
 80069d8:	9b01      	ldr	r3, [sp, #4]
 80069da:	f103 0267 	add.w	r2, r3, #103	; 0x67
 80069de:	9b01      	ldr	r3, [sp, #4]
 80069e0:	651a      	str	r2, [r3, #80]	; 0x50
 80069e2:	9b01      	ldr	r3, [sp, #4]
 80069e4:	2201      	movs	r2, #1
 80069e6:	655a      	str	r2, [r3, #84]	; 0x54
 80069e8:	9b01      	ldr	r3, [sp, #4]
 80069ea:	2200      	movs	r2, #0
 80069ec:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 80069ee:	2301      	movs	r3, #1
 80069f0:	e115      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_DEVICE | ((uint32_t)USB_REQ_SET_CONFIGURATION << 8):
    /* Handling configuration selection from the host only if it is different
       from the current configuration.*/
    if (usbp->configuration != usbp->setup[2]) {
 80069f2:	9b01      	ldr	r3, [sp, #4]
 80069f4:	f893 2067 	ldrb.w	r2, [r3, #103]	; 0x67
 80069f8:	9b01      	ldr	r3, [sp, #4]
 80069fa:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 80069fe:	429a      	cmp	r2, r3
 8006a00:	d035      	beq.n	8006a6e <default_handler+0x21e>
      /* If the USB device is already active then we have to perform the clear
         procedure on the current configuration.*/
      if (usbp->state == USB_ACTIVE) {
 8006a02:	9b01      	ldr	r3, [sp, #4]
 8006a04:	781b      	ldrb	r3, [r3, #0]
 8006a06:	2b04      	cmp	r3, #4
 8006a08:	d118      	bne.n	8006a3c <default_handler+0x1ec>
        /* Current configuration cleared.*/
        osalSysLockFromISR ();
 8006a0a:	f7ff fed1 	bl	80067b0 <osalSysLockFromISR>
        usbDisableEndpointsI(usbp);
 8006a0e:	9801      	ldr	r0, [sp, #4]
 8006a10:	f000 f9be 	bl	8006d90 <usbDisableEndpointsI>
        osalSysUnlockFromISR ();
 8006a14:	f7ff fed4 	bl	80067c0 <osalSysUnlockFromISR>
        usbp->configuration = 0U;
 8006a18:	9b01      	ldr	r3, [sp, #4]
 8006a1a:	2200      	movs	r2, #0
 8006a1c:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_SELECTED;
 8006a20:	9b01      	ldr	r3, [sp, #4]
 8006a22:	2203      	movs	r2, #3
 8006a24:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_UNCONFIGURED);
 8006a26:	9b01      	ldr	r3, [sp, #4]
 8006a28:	685b      	ldr	r3, [r3, #4]
 8006a2a:	681b      	ldr	r3, [r3, #0]
 8006a2c:	2b00      	cmp	r3, #0
 8006a2e:	d005      	beq.n	8006a3c <default_handler+0x1ec>
 8006a30:	9b01      	ldr	r3, [sp, #4]
 8006a32:	685b      	ldr	r3, [r3, #4]
 8006a34:	681b      	ldr	r3, [r3, #0]
 8006a36:	9801      	ldr	r0, [sp, #4]
 8006a38:	2103      	movs	r1, #3
 8006a3a:	4798      	blx	r3
      }
      if (usbp->setup[2] != 0U) {
 8006a3c:	9b01      	ldr	r3, [sp, #4]
 8006a3e:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006a42:	2b00      	cmp	r3, #0
 8006a44:	d013      	beq.n	8006a6e <default_handler+0x21e>
        /* New configuration.*/
        usbp->configuration = usbp->setup[2];
 8006a46:	9b01      	ldr	r3, [sp, #4]
 8006a48:	f893 205e 	ldrb.w	r2, [r3, #94]	; 0x5e
 8006a4c:	9b01      	ldr	r3, [sp, #4]
 8006a4e:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
        usbp->state = USB_ACTIVE;
 8006a52:	9b01      	ldr	r3, [sp, #4]
 8006a54:	2204      	movs	r2, #4
 8006a56:	701a      	strb	r2, [r3, #0]
        _usb_isr_invoke_event_cb(usbp, USB_EVENT_CONFIGURED);
 8006a58:	9b01      	ldr	r3, [sp, #4]
 8006a5a:	685b      	ldr	r3, [r3, #4]
 8006a5c:	681b      	ldr	r3, [r3, #0]
 8006a5e:	2b00      	cmp	r3, #0
 8006a60:	d005      	beq.n	8006a6e <default_handler+0x21e>
 8006a62:	9b01      	ldr	r3, [sp, #4]
 8006a64:	685b      	ldr	r3, [r3, #4]
 8006a66:	681b      	ldr	r3, [r3, #0]
 8006a68:	9801      	ldr	r0, [sp, #4]
 8006a6a:	2102      	movs	r1, #2
 8006a6c:	4798      	blx	r3
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006a6e:	9b01      	ldr	r3, [sp, #4]
 8006a70:	2200      	movs	r2, #0
 8006a72:	651a      	str	r2, [r3, #80]	; 0x50
 8006a74:	9b01      	ldr	r3, [sp, #4]
 8006a76:	2200      	movs	r2, #0
 8006a78:	655a      	str	r2, [r3, #84]	; 0x54
 8006a7a:	9b01      	ldr	r3, [sp, #4]
 8006a7c:	2200      	movs	r2, #0
 8006a7e:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006a80:	2301      	movs	r3, #1
 8006a82:	e0cc      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_STATUS << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SYNCH_FRAME << 8):
    /* Just sending two zero bytes, the application can change the behavior
       using a hook..*/
    /*lint -save -e9005 [11.8] Removing const is fine.*/
    usbSetupTransfer(usbp, (uint8_t *)zero_status, 2, NULL);
 8006a84:	9b01      	ldr	r3, [sp, #4]
 8006a86:	4a67      	ldr	r2, [pc, #412]	; (8006c24 <default_handler+0x3d4>)
 8006a88:	651a      	str	r2, [r3, #80]	; 0x50
 8006a8a:	9b01      	ldr	r3, [sp, #4]
 8006a8c:	2202      	movs	r2, #2
 8006a8e:	655a      	str	r2, [r3, #84]	; 0x54
 8006a90:	9b01      	ldr	r3, [sp, #4]
 8006a92:	2200      	movs	r2, #0
 8006a94:	659a      	str	r2, [r3, #88]	; 0x58
    /*lint -restore*/
    return true;
 8006a96:	2301      	movs	r3, #1
 8006a98:	e0c1      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_GET_STATUS << 8):
    /* Sending the EP status.*/
    if ((usbp->setup[4] & 0x80U) != 0U) {
 8006a9a:	9b01      	ldr	r3, [sp, #4]
 8006a9c:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aa0:	b2db      	uxtb	r3, r3
 8006aa2:	b25b      	sxtb	r3, r3
 8006aa4:	2b00      	cmp	r3, #0
 8006aa6:	da27      	bge.n	8006af8 <default_handler+0x2a8>
      switch (usb_lld_get_status_in(usbp, usbp->setup[4] & 0x0FU)) {
 8006aa8:	9b01      	ldr	r3, [sp, #4]
 8006aaa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006aae:	f003 030f 	and.w	r3, r3, #15
 8006ab2:	b2db      	uxtb	r3, r3
 8006ab4:	9801      	ldr	r0, [sp, #4]
 8006ab6:	4619      	mov	r1, r3
 8006ab8:	f002 fce2 	bl	8009480 <usb_lld_get_status_in>
 8006abc:	4603      	mov	r3, r0
 8006abe:	2b01      	cmp	r3, #1
 8006ac0:	d002      	beq.n	8006ac8 <default_handler+0x278>
 8006ac2:	2b02      	cmp	r3, #2
 8006ac4:	d00b      	beq.n	8006ade <default_handler+0x28e>
 8006ac6:	e015      	b.n	8006af4 <default_handler+0x2a4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006ac8:	9b01      	ldr	r3, [sp, #4]
 8006aca:	4a57      	ldr	r2, [pc, #348]	; (8006c28 <default_handler+0x3d8>)
 8006acc:	651a      	str	r2, [r3, #80]	; 0x50
 8006ace:	9b01      	ldr	r3, [sp, #4]
 8006ad0:	2202      	movs	r2, #2
 8006ad2:	655a      	str	r2, [r3, #84]	; 0x54
 8006ad4:	9b01      	ldr	r3, [sp, #4]
 8006ad6:	2200      	movs	r2, #0
 8006ad8:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006ada:	2301      	movs	r3, #1
 8006adc:	e09f      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006ade:	9b01      	ldr	r3, [sp, #4]
 8006ae0:	4a52      	ldr	r2, [pc, #328]	; (8006c2c <default_handler+0x3dc>)
 8006ae2:	651a      	str	r2, [r3, #80]	; 0x50
 8006ae4:	9b01      	ldr	r3, [sp, #4]
 8006ae6:	2202      	movs	r2, #2
 8006ae8:	655a      	str	r2, [r3, #84]	; 0x54
 8006aea:	9b01      	ldr	r3, [sp, #4]
 8006aec:	2200      	movs	r2, #0
 8006aee:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006af0:	2301      	movs	r3, #1
 8006af2:	e094      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006af4:	2300      	movs	r3, #0
 8006af6:	e092      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
    else {
      switch (usb_lld_get_status_out(usbp, usbp->setup[4] & 0x0FU)) {
 8006af8:	9b01      	ldr	r3, [sp, #4]
 8006afa:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006afe:	f003 030f 	and.w	r3, r3, #15
 8006b02:	b2db      	uxtb	r3, r3
 8006b04:	9801      	ldr	r0, [sp, #4]
 8006b06:	4619      	mov	r1, r3
 8006b08:	f002 fc9a 	bl	8009440 <usb_lld_get_status_out>
 8006b0c:	4603      	mov	r3, r0
 8006b0e:	2b01      	cmp	r3, #1
 8006b10:	d002      	beq.n	8006b18 <default_handler+0x2c8>
 8006b12:	2b02      	cmp	r3, #2
 8006b14:	d00b      	beq.n	8006b2e <default_handler+0x2de>
 8006b16:	e015      	b.n	8006b44 <default_handler+0x2f4>
      case EP_STATUS_STALLED:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)halted_status, 2, NULL);
 8006b18:	9b01      	ldr	r3, [sp, #4]
 8006b1a:	4a43      	ldr	r2, [pc, #268]	; (8006c28 <default_handler+0x3d8>)
 8006b1c:	651a      	str	r2, [r3, #80]	; 0x50
 8006b1e:	9b01      	ldr	r3, [sp, #4]
 8006b20:	2202      	movs	r2, #2
 8006b22:	655a      	str	r2, [r3, #84]	; 0x54
 8006b24:	9b01      	ldr	r3, [sp, #4]
 8006b26:	2200      	movs	r2, #0
 8006b28:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b2a:	2301      	movs	r3, #1
 8006b2c:	e077      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_ACTIVE:
        /*lint -save -e9005 [11.8] Removing const is fine.*/
        usbSetupTransfer(usbp, (uint8_t *)active_status, 2, NULL);
 8006b2e:	9b01      	ldr	r3, [sp, #4]
 8006b30:	4a3e      	ldr	r2, [pc, #248]	; (8006c2c <default_handler+0x3dc>)
 8006b32:	651a      	str	r2, [r3, #80]	; 0x50
 8006b34:	9b01      	ldr	r3, [sp, #4]
 8006b36:	2202      	movs	r2, #2
 8006b38:	655a      	str	r2, [r3, #84]	; 0x54
 8006b3a:	9b01      	ldr	r3, [sp, #4]
 8006b3c:	2200      	movs	r2, #0
 8006b3e:	659a      	str	r2, [r3, #88]	; 0x58
        /*lint -restore*/
        return true;
 8006b40:	2301      	movs	r3, #1
 8006b42:	e06c      	b.n	8006c1e <default_handler+0x3ce>
      case EP_STATUS_DISABLED:
      default:
        return false;
 8006b44:	2300      	movs	r3, #0
 8006b46:	e06a      	b.n	8006c1e <default_handler+0x3ce>
      }
    }
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_CLEAR_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006b48:	9b01      	ldr	r3, [sp, #4]
 8006b4a:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006b4e:	2b00      	cmp	r3, #0
 8006b50:	d001      	beq.n	8006b56 <default_handler+0x306>
      return false;
 8006b52:	2300      	movs	r3, #0
 8006b54:	e063      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Clearing the EP status, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006b56:	9b01      	ldr	r3, [sp, #4]
 8006b58:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b5c:	f003 030f 	and.w	r3, r3, #15
 8006b60:	2b00      	cmp	r3, #0
 8006b62:	d01b      	beq.n	8006b9c <default_handler+0x34c>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006b64:	9b01      	ldr	r3, [sp, #4]
 8006b66:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b6a:	b2db      	uxtb	r3, r3
 8006b6c:	b25b      	sxtb	r3, r3
 8006b6e:	2b00      	cmp	r3, #0
 8006b70:	da0a      	bge.n	8006b88 <default_handler+0x338>
        usb_lld_clear_in(usbp, usbp->setup[4] & 0x0FU);
 8006b72:	9b01      	ldr	r3, [sp, #4]
 8006b74:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b78:	f003 030f 	and.w	r3, r3, #15
 8006b7c:	b2db      	uxtb	r3, r3
 8006b7e:	9801      	ldr	r0, [sp, #4]
 8006b80:	4619      	mov	r1, r3
 8006b82:	f002 fe65 	bl	8009850 <usb_lld_clear_in>
 8006b86:	e009      	b.n	8006b9c <default_handler+0x34c>
      }
      else {
        usb_lld_clear_out(usbp, usbp->setup[4] & 0x0FU);
 8006b88:	9b01      	ldr	r3, [sp, #4]
 8006b8a:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006b8e:	f003 030f 	and.w	r3, r3, #15
 8006b92:	b2db      	uxtb	r3, r3
 8006b94:	9801      	ldr	r0, [sp, #4]
 8006b96:	4619      	mov	r1, r3
 8006b98:	f002 fe3a 	bl	8009810 <usb_lld_clear_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006b9c:	9b01      	ldr	r3, [sp, #4]
 8006b9e:	2200      	movs	r2, #0
 8006ba0:	651a      	str	r2, [r3, #80]	; 0x50
 8006ba2:	9b01      	ldr	r3, [sp, #4]
 8006ba4:	2200      	movs	r2, #0
 8006ba6:	655a      	str	r2, [r3, #84]	; 0x54
 8006ba8:	9b01      	ldr	r3, [sp, #4]
 8006baa:	2200      	movs	r2, #0
 8006bac:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006bae:	2301      	movs	r3, #1
 8006bb0:	e035      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_ENDPOINT | ((uint32_t)USB_REQ_SET_FEATURE << 8):
    /* Only ENDPOINT_HALT is handled as feature.*/
    if (usbp->setup[2] != USB_FEATURE_ENDPOINT_HALT) {
 8006bb2:	9b01      	ldr	r3, [sp, #4]
 8006bb4:	f893 305e 	ldrb.w	r3, [r3, #94]	; 0x5e
 8006bb8:	2b00      	cmp	r3, #0
 8006bba:	d001      	beq.n	8006bc0 <default_handler+0x370>
      return false;
 8006bbc:	2300      	movs	r3, #0
 8006bbe:	e02e      	b.n	8006c1e <default_handler+0x3ce>
    }
    /* Stalling the EP, not valid for EP0, it is ignored in that case.*/
    if ((usbp->setup[4] & 0x0FU) != 0U) {
 8006bc0:	9b01      	ldr	r3, [sp, #4]
 8006bc2:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bc6:	f003 030f 	and.w	r3, r3, #15
 8006bca:	2b00      	cmp	r3, #0
 8006bcc:	d01b      	beq.n	8006c06 <default_handler+0x3b6>
      if ((usbp->setup[4] & 0x80U) != 0U) {
 8006bce:	9b01      	ldr	r3, [sp, #4]
 8006bd0:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bd4:	b2db      	uxtb	r3, r3
 8006bd6:	b25b      	sxtb	r3, r3
 8006bd8:	2b00      	cmp	r3, #0
 8006bda:	da0a      	bge.n	8006bf2 <default_handler+0x3a2>
        usb_lld_stall_in(usbp, usbp->setup[4] & 0x0FU);
 8006bdc:	9b01      	ldr	r3, [sp, #4]
 8006bde:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006be2:	f003 030f 	and.w	r3, r3, #15
 8006be6:	b2db      	uxtb	r3, r3
 8006be8:	9801      	ldr	r0, [sp, #4]
 8006bea:	4619      	mov	r1, r3
 8006bec:	f002 fdf0 	bl	80097d0 <usb_lld_stall_in>
 8006bf0:	e009      	b.n	8006c06 <default_handler+0x3b6>
      }
      else {
        usb_lld_stall_out(usbp, usbp->setup[4] & 0x0FU);
 8006bf2:	9b01      	ldr	r3, [sp, #4]
 8006bf4:	f893 3060 	ldrb.w	r3, [r3, #96]	; 0x60
 8006bf8:	f003 030f 	and.w	r3, r3, #15
 8006bfc:	b2db      	uxtb	r3, r3
 8006bfe:	9801      	ldr	r0, [sp, #4]
 8006c00:	4619      	mov	r1, r3
 8006c02:	f002 fdc5 	bl	8009790 <usb_lld_stall_out>
      }
    }
    usbSetupTransfer(usbp, NULL, 0, NULL);
 8006c06:	9b01      	ldr	r3, [sp, #4]
 8006c08:	2200      	movs	r2, #0
 8006c0a:	651a      	str	r2, [r3, #80]	; 0x50
 8006c0c:	9b01      	ldr	r3, [sp, #4]
 8006c0e:	2200      	movs	r2, #0
 8006c10:	655a      	str	r2, [r3, #84]	; 0x54
 8006c12:	9b01      	ldr	r3, [sp, #4]
 8006c14:	2200      	movs	r2, #0
 8006c16:	659a      	str	r2, [r3, #88]	; 0x58
    return true;
 8006c18:	2301      	movs	r3, #1
 8006c1a:	e000      	b.n	8006c1e <default_handler+0x3ce>
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_GET_INTERFACE << 8):
  case (uint32_t)USB_RTYPE_RECIPIENT_INTERFACE | ((uint32_t)USB_REQ_SET_INTERFACE << 8):
    /* All the above requests are not handled here, if you need them then
       use the hook mechanism and provide handling.*/
  default:
    return false;
 8006c1c:	2300      	movs	r3, #0
  }
}
 8006c1e:	4618      	mov	r0, r3
 8006c20:	b004      	add	sp, #16
 8006c22:	bd70      	pop	{r4, r5, r6, pc}
 8006c24:	08019490 	.word	0x08019490
 8006c28:	08019498 	.word	0x08019498
 8006c2c:	08019494 	.word	0x08019494

08006c30 <usbInit>:
 * @note    This function is implicitly invoked by @p halInit(), there is
 *          no need to explicitly initialize the driver.
 *
 * @init
 */
void usbInit(void) {
 8006c30:	b508      	push	{r3, lr}

  usb_lld_init();
 8006c32:	f002 f93d 	bl	8008eb0 <usb_lld_init>
}
 8006c36:	bd08      	pop	{r3, pc}
 8006c38:	f3af 8000 	nop.w
 8006c3c:	f3af 8000 	nop.w

08006c40 <usbObjectInit>:
 *
 * @param[out] usbp     pointer to the @p USBDriver object
 *
 * @init
 */
void usbObjectInit(USBDriver *usbp) {
 8006c40:	b084      	sub	sp, #16
 8006c42:	9001      	str	r0, [sp, #4]
  unsigned i;

  usbp->state        = USB_STOP;
 8006c44:	9b01      	ldr	r3, [sp, #4]
 8006c46:	2201      	movs	r2, #1
 8006c48:	701a      	strb	r2, [r3, #0]
  usbp->config       = NULL;
 8006c4a:	9b01      	ldr	r3, [sp, #4]
 8006c4c:	2200      	movs	r2, #0
 8006c4e:	605a      	str	r2, [r3, #4]
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c50:	2300      	movs	r3, #0
 8006c52:	9303      	str	r3, [sp, #12]
 8006c54:	e00f      	b.n	8006c76 <usbObjectInit+0x36>
    usbp->in_params[i]  = NULL;
 8006c56:	9a01      	ldr	r2, [sp, #4]
 8006c58:	9b03      	ldr	r3, [sp, #12]
 8006c5a:	3308      	adds	r3, #8
 8006c5c:	009b      	lsls	r3, r3, #2
 8006c5e:	4413      	add	r3, r2
 8006c60:	2200      	movs	r2, #0
 8006c62:	605a      	str	r2, [r3, #4]
    usbp->out_params[i] = NULL;
 8006c64:	9b01      	ldr	r3, [sp, #4]
 8006c66:	9a03      	ldr	r2, [sp, #12]
 8006c68:	320e      	adds	r2, #14
 8006c6a:	2100      	movs	r1, #0
 8006c6c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
void usbObjectInit(USBDriver *usbp) {
  unsigned i;

  usbp->state        = USB_STOP;
  usbp->config       = NULL;
  for (i = 0; i < (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006c70:	9b03      	ldr	r3, [sp, #12]
 8006c72:	3301      	adds	r3, #1
 8006c74:	9303      	str	r3, [sp, #12]
 8006c76:	9b03      	ldr	r3, [sp, #12]
 8006c78:	2b04      	cmp	r3, #4
 8006c7a:	d9ec      	bls.n	8006c56 <usbObjectInit+0x16>
    usbp->in_params[i]  = NULL;
    usbp->out_params[i] = NULL;
  }
  usbp->transmitting = 0;
 8006c7c:	9b01      	ldr	r3, [sp, #4]
 8006c7e:	2200      	movs	r2, #0
 8006c80:	811a      	strh	r2, [r3, #8]
  usbp->receiving    = 0;
 8006c82:	9b01      	ldr	r3, [sp, #4]
 8006c84:	2200      	movs	r2, #0
 8006c86:	815a      	strh	r2, [r3, #10]
}
 8006c88:	b004      	add	sp, #16
 8006c8a:	4770      	bx	lr
 8006c8c:	f3af 8000 	nop.w

08006c90 <usbStart>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] config    pointer to the @p USBConfig object
 *
 * @api
 */
void usbStart(USBDriver *usbp, const USBConfig *config) {
 8006c90:	b500      	push	{lr}
 8006c92:	b085      	sub	sp, #20
 8006c94:	9001      	str	r0, [sp, #4]
 8006c96:	9100      	str	r1, [sp, #0]
  unsigned i;

  osalDbgCheck((usbp != NULL) && (config != NULL));

  osalSysLock();
 8006c98:	f7ff fd7a 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
 8006c9c:	9b01      	ldr	r3, [sp, #4]
 8006c9e:	9a00      	ldr	r2, [sp, #0]
 8006ca0:	605a      	str	r2, [r3, #4]
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006ca2:	2300      	movs	r3, #0
 8006ca4:	9303      	str	r3, [sp, #12]
 8006ca6:	e009      	b.n	8006cbc <usbStart+0x2c>
    usbp->epc[i] = NULL;
 8006ca8:	9a01      	ldr	r2, [sp, #4]
 8006caa:	9b03      	ldr	r3, [sp, #12]
 8006cac:	3302      	adds	r3, #2
 8006cae:	009b      	lsls	r3, r3, #2
 8006cb0:	4413      	add	r3, r2
 8006cb2:	2200      	movs	r2, #0
 8006cb4:	605a      	str	r2, [r3, #4]

  osalSysLock();
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY),
                "invalid state");
  usbp->config = config;
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cb6:	9b03      	ldr	r3, [sp, #12]
 8006cb8:	3301      	adds	r3, #1
 8006cba:	9303      	str	r3, [sp, #12]
 8006cbc:	9b03      	ldr	r3, [sp, #12]
 8006cbe:	2b05      	cmp	r3, #5
 8006cc0:	d9f2      	bls.n	8006ca8 <usbStart+0x18>
    usbp->epc[i] = NULL;
  }
  usb_lld_start(usbp);
 8006cc2:	9801      	ldr	r0, [sp, #4]
 8006cc4:	f002 f90c 	bl	8008ee0 <usb_lld_start>
  usbp->state = USB_READY;
 8006cc8:	9b01      	ldr	r3, [sp, #4]
 8006cca:	2202      	movs	r2, #2
 8006ccc:	701a      	strb	r2, [r3, #0]
  osalSysUnlock();
 8006cce:	f7ff fd67 	bl	80067a0 <osalSysUnlock>
}
 8006cd2:	b005      	add	sp, #20
 8006cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8006cd8:	f3af 8000 	nop.w
 8006cdc:	f3af 8000 	nop.w

08006ce0 <usbStop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @api
 */
void usbStop(USBDriver *usbp) {
 8006ce0:	b500      	push	{lr}
 8006ce2:	b085      	sub	sp, #20
 8006ce4:	9001      	str	r0, [sp, #4]
  unsigned i;

  osalDbgCheck(usbp != NULL);

  osalSysLock();
 8006ce6:	f7ff fd53 	bl	8006790 <osalSysLock>
  osalDbgAssert((usbp->state == USB_STOP) || (usbp->state == USB_READY) ||
                (usbp->state == USB_SELECTED) || (usbp->state == USB_ACTIVE) ||
                (usbp->state == USB_SUSPENDED),
                "invalid state");

  usb_lld_stop(usbp);
 8006cea:	9801      	ldr	r0, [sp, #4]
 8006cec:	f002 f988 	bl	8009000 <usb_lld_stop>
  usbp->state = USB_STOP;
 8006cf0:	9b01      	ldr	r3, [sp, #4]
 8006cf2:	2201      	movs	r2, #1
 8006cf4:	701a      	strb	r2, [r3, #0]

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006cf6:	2300      	movs	r3, #0
 8006cf8:	9303      	str	r3, [sp, #12]
 8006cfa:	e009      	b.n	8006d10 <usbStop+0x30>
      if (usbp->epc[i]->out_state != NULL) {
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
    }
#endif
    usbp->epc[i] = NULL;
 8006cfc:	9a01      	ldr	r2, [sp, #4]
 8006cfe:	9b03      	ldr	r3, [sp, #12]
 8006d00:	3302      	adds	r3, #2
 8006d02:	009b      	lsls	r3, r3, #2
 8006d04:	4413      	add	r3, r2
 8006d06:	2200      	movs	r2, #0
 8006d08:	605a      	str	r2, [r3, #4]

  usb_lld_stop(usbp);
  usbp->state = USB_STOP;

  /* Resetting all ongoing synchronous operations.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006d0a:	9b03      	ldr	r3, [sp, #12]
 8006d0c:	3301      	adds	r3, #1
 8006d0e:	9303      	str	r3, [sp, #12]
 8006d10:	9b03      	ldr	r3, [sp, #12]
 8006d12:	2b05      	cmp	r3, #5
 8006d14:	d9f2      	bls.n	8006cfc <usbStop+0x1c>
      }
    }
#endif
    usbp->epc[i] = NULL;
  }
  osalOsRescheduleS();
 8006d16:	f7ff fd5b 	bl	80067d0 <osalOsRescheduleS>

  osalSysUnlock();
 8006d1a:	f7ff fd41 	bl	80067a0 <osalSysUnlock>
}
 8006d1e:	b005      	add	sp, #20
 8006d20:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d24:	f3af 8000 	nop.w
 8006d28:	f3af 8000 	nop.w
 8006d2c:	f3af 8000 	nop.w

08006d30 <usbInitEndpointI>:
 * @param[in] epcp      the endpoint configuration
 *
 * @iclass
 */
void usbInitEndpointI(USBDriver *usbp, usbep_t ep,
                      const USBEndpointConfig *epcp) {
 8006d30:	b500      	push	{lr}
 8006d32:	b085      	sub	sp, #20
 8006d34:	9003      	str	r0, [sp, #12]
 8006d36:	460b      	mov	r3, r1
 8006d38:	9201      	str	r2, [sp, #4]
 8006d3a:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgAssert(usbp->state == USB_ACTIVE,
                "invalid state");
  osalDbgAssert(usbp->epc[ep] == NULL, "already initialized");

  /* Logically enabling the endpoint in the USBDriver structure.*/
  usbp->epc[ep] = epcp;
 8006d3e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d42:	9a03      	ldr	r2, [sp, #12]
 8006d44:	3302      	adds	r3, #2
 8006d46:	009b      	lsls	r3, r3, #2
 8006d48:	4413      	add	r3, r2
 8006d4a:	9a01      	ldr	r2, [sp, #4]
 8006d4c:	605a      	str	r2, [r3, #4]

  /* Clearing the state structures, custom fields as well.*/
  if (epcp->in_state != NULL) {
 8006d4e:	9b01      	ldr	r3, [sp, #4]
 8006d50:	695b      	ldr	r3, [r3, #20]
 8006d52:	2b00      	cmp	r3, #0
 8006d54:	d006      	beq.n	8006d64 <usbInitEndpointI+0x34>
    memset(epcp->in_state, 0, sizeof(USBInEndpointState));
 8006d56:	9b01      	ldr	r3, [sp, #4]
 8006d58:	695b      	ldr	r3, [r3, #20]
 8006d5a:	4618      	mov	r0, r3
 8006d5c:	2100      	movs	r1, #0
 8006d5e:	2210      	movs	r2, #16
 8006d60:	f00f ffd6 	bl	8016d10 <memset>
  }
  if (epcp->out_state != NULL) {
 8006d64:	9b01      	ldr	r3, [sp, #4]
 8006d66:	699b      	ldr	r3, [r3, #24]
 8006d68:	2b00      	cmp	r3, #0
 8006d6a:	d006      	beq.n	8006d7a <usbInitEndpointI+0x4a>
    memset(epcp->out_state, 0, sizeof(USBOutEndpointState));
 8006d6c:	9b01      	ldr	r3, [sp, #4]
 8006d6e:	699b      	ldr	r3, [r3, #24]
 8006d70:	4618      	mov	r0, r3
 8006d72:	2100      	movs	r1, #0
 8006d74:	2210      	movs	r2, #16
 8006d76:	f00f ffcb 	bl	8016d10 <memset>
  }

  /* Low level endpoint activation.*/
  usb_lld_init_endpoint(usbp, ep);
 8006d7a:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006d7e:	9803      	ldr	r0, [sp, #12]
 8006d80:	4619      	mov	r1, r3
 8006d82:	f002 fa1d 	bl	80091c0 <usb_lld_init_endpoint>
}
 8006d86:	b005      	add	sp, #20
 8006d88:	f85d fb04 	ldr.w	pc, [sp], #4
 8006d8c:	f3af 8000 	nop.w

08006d90 <usbDisableEndpointsI>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @iclass
 */
void usbDisableEndpointsI(USBDriver *usbp) {
 8006d90:	b500      	push	{lr}
 8006d92:	b085      	sub	sp, #20
 8006d94:	9001      	str	r0, [sp, #4]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
 8006d96:	9b01      	ldr	r3, [sp, #4]
 8006d98:	891b      	ldrh	r3, [r3, #8]
 8006d9a:	f003 0301 	and.w	r3, r3, #1
 8006d9e:	b29a      	uxth	r2, r3
 8006da0:	9b01      	ldr	r3, [sp, #4]
 8006da2:	811a      	strh	r2, [r3, #8]
  usbp->receiving    &= 1U;
 8006da4:	9b01      	ldr	r3, [sp, #4]
 8006da6:	895b      	ldrh	r3, [r3, #10]
 8006da8:	f003 0301 	and.w	r3, r3, #1
 8006dac:	b29a      	uxth	r2, r3
 8006dae:	9b01      	ldr	r3, [sp, #4]
 8006db0:	815a      	strh	r2, [r3, #10]

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006db2:	2301      	movs	r3, #1
 8006db4:	9303      	str	r3, [sp, #12]
 8006db6:	e009      	b.n	8006dcc <usbDisableEndpointsI+0x3c>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006db8:	9a01      	ldr	r2, [sp, #4]
 8006dba:	9b03      	ldr	r3, [sp, #12]
 8006dbc:	3302      	adds	r3, #2
 8006dbe:	009b      	lsls	r3, r3, #2
 8006dc0:	4413      	add	r3, r2
 8006dc2:	2200      	movs	r2, #0
 8006dc4:	605a      	str	r2, [r3, #4]
  osalDbgAssert(usbp->state == USB_ACTIVE, "invalid state");

  usbp->transmitting &= 1U;
  usbp->receiving    &= 1U;

  for (i = 1; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006dc6:	9b03      	ldr	r3, [sp, #12]
 8006dc8:	3301      	adds	r3, #1
 8006dca:	9303      	str	r3, [sp, #12]
 8006dcc:	9b03      	ldr	r3, [sp, #12]
 8006dce:	2b05      	cmp	r3, #5
 8006dd0:	d9f2      	bls.n	8006db8 <usbDisableEndpointsI+0x28>
#endif
    usbp->epc[i] = NULL;
  }

  /* Low level endpoints deactivation.*/
  usb_lld_disable_endpoints(usbp);
 8006dd2:	9801      	ldr	r0, [sp, #4]
 8006dd4:	f002 fb24 	bl	8009420 <usb_lld_disable_endpoints>
}
 8006dd8:	b005      	add	sp, #20
 8006dda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006dde:	bf00      	nop

08006de0 <usbStartReceiveI>:
 *                      the packet size because the excess is discarded.
 *
 * @iclass
 */
void usbStartReceiveI(USBDriver *usbp, usbep_t ep,
                      uint8_t *buf, size_t n) {
 8006de0:	b500      	push	{lr}
 8006de2:	b087      	sub	sp, #28
 8006de4:	9003      	str	r0, [sp, #12]
 8006de6:	9201      	str	r2, [sp, #4]
 8006de8:	9300      	str	r3, [sp, #0]
 8006dea:	460b      	mov	r3, r1
 8006dec:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetReceiveStatusI(usbp, ep), "already receiving");

  /* Marking the endpoint as active.*/
  usbp->receiving |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006df0:	9b03      	ldr	r3, [sp, #12]
 8006df2:	895a      	ldrh	r2, [r3, #10]
 8006df4:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006df8:	2101      	movs	r1, #1
 8006dfa:	fa01 f303 	lsl.w	r3, r1, r3
 8006dfe:	b29b      	uxth	r3, r3
 8006e00:	4313      	orrs	r3, r2
 8006e02:	b29a      	uxth	r2, r3
 8006e04:	9b03      	ldr	r3, [sp, #12]
 8006e06:	815a      	strh	r2, [r3, #10]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  osp = usbp->epc[ep]->out_state;
 8006e08:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e0c:	9a03      	ldr	r2, [sp, #12]
 8006e0e:	3302      	adds	r3, #2
 8006e10:	009b      	lsls	r3, r3, #2
 8006e12:	4413      	add	r3, r2
 8006e14:	685b      	ldr	r3, [r3, #4]
 8006e16:	699b      	ldr	r3, [r3, #24]
 8006e18:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  osp->rxbuf  = buf;
 8006e1a:	9b05      	ldr	r3, [sp, #20]
 8006e1c:	9a01      	ldr	r2, [sp, #4]
 8006e1e:	609a      	str	r2, [r3, #8]
  osp->rxsize = n;
 8006e20:	9b05      	ldr	r3, [sp, #20]
 8006e22:	9a00      	ldr	r2, [sp, #0]
 8006e24:	601a      	str	r2, [r3, #0]
  osp->rxcnt  = 0;
 8006e26:	9b05      	ldr	r3, [sp, #20]
 8006e28:	2200      	movs	r2, #0
 8006e2a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  osp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_out(usbp, ep);
 8006e2c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e30:	9803      	ldr	r0, [sp, #12]
 8006e32:	4619      	mov	r1, r3
 8006e34:	f002 fb5c 	bl	80094f0 <usb_lld_start_out>
}
 8006e38:	b007      	add	sp, #28
 8006e3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e3e:	bf00      	nop

08006e40 <usbStartTransmitI>:
 * @param[in] n         transaction size
 *
 * @iclass
 */
void usbStartTransmitI(USBDriver *usbp, usbep_t ep,
                       const uint8_t *buf, size_t n) {
 8006e40:	b500      	push	{lr}
 8006e42:	b087      	sub	sp, #28
 8006e44:	9003      	str	r0, [sp, #12]
 8006e46:	9201      	str	r2, [sp, #4]
 8006e48:	9300      	str	r3, [sp, #0]
 8006e4a:	460b      	mov	r3, r1
 8006e4c:	f88d 300b 	strb.w	r3, [sp, #11]
  osalDbgCheckClassI();
  osalDbgCheck((usbp != NULL) && (ep <= (usbep_t)USB_MAX_ENDPOINTS));
  osalDbgAssert(!usbGetTransmitStatusI(usbp, ep), "already transmitting");

  /* Marking the endpoint as active.*/
  usbp->transmitting |= (uint16_t)((unsigned)1U << (unsigned)ep);
 8006e50:	9b03      	ldr	r3, [sp, #12]
 8006e52:	891a      	ldrh	r2, [r3, #8]
 8006e54:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e58:	2101      	movs	r1, #1
 8006e5a:	fa01 f303 	lsl.w	r3, r1, r3
 8006e5e:	b29b      	uxth	r3, r3
 8006e60:	4313      	orrs	r3, r2
 8006e62:	b29a      	uxth	r2, r3
 8006e64:	9b03      	ldr	r3, [sp, #12]
 8006e66:	811a      	strh	r2, [r3, #8]

  /* Setting up the transfer.*/
  /*lint -save -e661 [18.1] pclint is confused by the check on ep.*/
  isp = usbp->epc[ep]->in_state;
 8006e68:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e6c:	9a03      	ldr	r2, [sp, #12]
 8006e6e:	3302      	adds	r3, #2
 8006e70:	009b      	lsls	r3, r3, #2
 8006e72:	4413      	add	r3, r2
 8006e74:	685b      	ldr	r3, [r3, #4]
 8006e76:	695b      	ldr	r3, [r3, #20]
 8006e78:	9305      	str	r3, [sp, #20]
  /*lint -restore*/
  isp->txbuf  = buf;
 8006e7a:	9b05      	ldr	r3, [sp, #20]
 8006e7c:	9a01      	ldr	r2, [sp, #4]
 8006e7e:	609a      	str	r2, [r3, #8]
  isp->txsize = n;
 8006e80:	9b05      	ldr	r3, [sp, #20]
 8006e82:	9a00      	ldr	r2, [sp, #0]
 8006e84:	601a      	str	r2, [r3, #0]
  isp->txcnt  = 0;
 8006e86:	9b05      	ldr	r3, [sp, #20]
 8006e88:	2200      	movs	r2, #0
 8006e8a:	605a      	str	r2, [r3, #4]
#if USB_USE_WAIT == TRUE
  isp->thread = NULL;
#endif

  /* Starting transfer.*/
  usb_lld_start_in(usbp, ep);
 8006e8c:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8006e90:	9803      	ldr	r0, [sp, #12]
 8006e92:	4619      	mov	r1, r3
 8006e94:	f002 fbcc 	bl	8009630 <usb_lld_start_in>
}
 8006e98:	b007      	add	sp, #28
 8006e9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006e9e:	bf00      	nop

08006ea0 <usbStallReceiveI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallReceiveI(USBDriver *usbp, usbep_t ep) {
 8006ea0:	b500      	push	{lr}
 8006ea2:	b083      	sub	sp, #12
 8006ea4:	9001      	str	r0, [sp, #4]
 8006ea6:	460b      	mov	r3, r1
 8006ea8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetReceiveStatusI(usbp, ep)) {
 8006eac:	9b01      	ldr	r3, [sp, #4]
 8006eae:	895a      	ldrh	r2, [r3, #10]
 8006eb0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006eb4:	2101      	movs	r1, #1
 8006eb6:	fa01 f303 	lsl.w	r3, r1, r3
 8006eba:	b29b      	uxth	r3, r3
 8006ebc:	4013      	ands	r3, r2
 8006ebe:	b29b      	uxth	r3, r3
 8006ec0:	2b00      	cmp	r3, #0
 8006ec2:	d001      	beq.n	8006ec8 <usbStallReceiveI+0x28>
    return true;
 8006ec4:	2301      	movs	r3, #1
 8006ec6:	e006      	b.n	8006ed6 <usbStallReceiveI+0x36>
  }

  usb_lld_stall_out(usbp, ep);
 8006ec8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ecc:	9801      	ldr	r0, [sp, #4]
 8006ece:	4619      	mov	r1, r3
 8006ed0:	f002 fc5e 	bl	8009790 <usb_lld_stall_out>
  return false;
 8006ed4:	2300      	movs	r3, #0
}
 8006ed6:	4618      	mov	r0, r3
 8006ed8:	b003      	add	sp, #12
 8006eda:	f85d fb04 	ldr.w	pc, [sp], #4
 8006ede:	bf00      	nop

08006ee0 <usbStallTransmitI>:
 * @retval false        Endpoint stalled.
 * @retval true         Endpoint busy, not stalled.
 *
 * @iclass
 */
bool usbStallTransmitI(USBDriver *usbp, usbep_t ep) {
 8006ee0:	b500      	push	{lr}
 8006ee2:	b083      	sub	sp, #12
 8006ee4:	9001      	str	r0, [sp, #4]
 8006ee6:	460b      	mov	r3, r1
 8006ee8:	f88d 3003 	strb.w	r3, [sp, #3]

  osalDbgCheckClassI();
  osalDbgCheck(usbp != NULL);

  if (usbGetTransmitStatusI(usbp, ep)) {
 8006eec:	9b01      	ldr	r3, [sp, #4]
 8006eee:	891a      	ldrh	r2, [r3, #8]
 8006ef0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006ef4:	2101      	movs	r1, #1
 8006ef6:	fa01 f303 	lsl.w	r3, r1, r3
 8006efa:	b29b      	uxth	r3, r3
 8006efc:	4013      	ands	r3, r2
 8006efe:	b29b      	uxth	r3, r3
 8006f00:	2b00      	cmp	r3, #0
 8006f02:	d001      	beq.n	8006f08 <usbStallTransmitI+0x28>
    return true;
 8006f04:	2301      	movs	r3, #1
 8006f06:	e006      	b.n	8006f16 <usbStallTransmitI+0x36>
  }

  usb_lld_stall_in(usbp, ep);
 8006f08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8006f0c:	9801      	ldr	r0, [sp, #4]
 8006f0e:	4619      	mov	r1, r3
 8006f10:	f002 fc5e 	bl	80097d0 <usb_lld_stall_in>
  return false;
 8006f14:	2300      	movs	r3, #0
}
 8006f16:	4618      	mov	r0, r3
 8006f18:	b003      	add	sp, #12
 8006f1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f1e:	bf00      	nop

08006f20 <_usb_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_reset(USBDriver *usbp) {
 8006f20:	b500      	push	{lr}
 8006f22:	b085      	sub	sp, #20
 8006f24:	9001      	str	r0, [sp, #4]
  unsigned i;

  /* State transition.*/
  usbp->state         = USB_READY;
 8006f26:	9b01      	ldr	r3, [sp, #4]
 8006f28:	2202      	movs	r2, #2
 8006f2a:	701a      	strb	r2, [r3, #0]

  /* Resetting internal state.*/
  usbp->status        = 0;
 8006f2c:	9b01      	ldr	r3, [sp, #4]
 8006f2e:	2200      	movs	r2, #0
 8006f30:	f8a3 2064 	strh.w	r2, [r3, #100]	; 0x64
  usbp->address       = 0;
 8006f34:	9b01      	ldr	r3, [sp, #4]
 8006f36:	2200      	movs	r2, #0
 8006f38:	f883 2066 	strb.w	r2, [r3, #102]	; 0x66
  usbp->configuration = 0;
 8006f3c:	9b01      	ldr	r3, [sp, #4]
 8006f3e:	2200      	movs	r2, #0
 8006f40:	f883 2067 	strb.w	r2, [r3, #103]	; 0x67
  usbp->transmitting  = 0;
 8006f44:	9b01      	ldr	r3, [sp, #4]
 8006f46:	2200      	movs	r2, #0
 8006f48:	811a      	strh	r2, [r3, #8]
  usbp->receiving     = 0;
 8006f4a:	9b01      	ldr	r3, [sp, #4]
 8006f4c:	2200      	movs	r2, #0
 8006f4e:	815a      	strh	r2, [r3, #10]

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f50:	2300      	movs	r3, #0
 8006f52:	9303      	str	r3, [sp, #12]
 8006f54:	e009      	b.n	8006f6a <_usb_reset+0x4a>
        osalThreadResumeI(&usbp->epc[i]->out_state->thread, MSG_RESET);
      }
      osalSysUnlockFromISR();
    }
#endif
    usbp->epc[i] = NULL;
 8006f56:	9a01      	ldr	r2, [sp, #4]
 8006f58:	9b03      	ldr	r3, [sp, #12]
 8006f5a:	3302      	adds	r3, #2
 8006f5c:	009b      	lsls	r3, r3, #2
 8006f5e:	4413      	add	r3, r2
 8006f60:	2200      	movs	r2, #0
 8006f62:	605a      	str	r2, [r3, #4]
  usbp->configuration = 0;
  usbp->transmitting  = 0;
  usbp->receiving     = 0;

  /* Invalidates all endpoints into the USBDriver structure.*/
  for (i = 0; i <= (unsigned)USB_MAX_ENDPOINTS; i++) {
 8006f64:	9b03      	ldr	r3, [sp, #12]
 8006f66:	3301      	adds	r3, #1
 8006f68:	9303      	str	r3, [sp, #12]
 8006f6a:	9b03      	ldr	r3, [sp, #12]
 8006f6c:	2b05      	cmp	r3, #5
 8006f6e:	d9f2      	bls.n	8006f56 <_usb_reset+0x36>
#endif
    usbp->epc[i] = NULL;
  }

  /* EP0 state machine initialization.*/
  usbp->ep0state = USB_EP0_WAITING_SETUP;
 8006f70:	9b01      	ldr	r3, [sp, #4]
 8006f72:	2200      	movs	r2, #0
 8006f74:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c

  /* Low level reset.*/
  usb_lld_reset(usbp);
 8006f78:	9801      	ldr	r0, [sp, #4]
 8006f7a:	f002 f871 	bl	8009060 <usb_lld_reset>

  /* Notification of reset event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_RESET);
 8006f7e:	9b01      	ldr	r3, [sp, #4]
 8006f80:	685b      	ldr	r3, [r3, #4]
 8006f82:	681b      	ldr	r3, [r3, #0]
 8006f84:	2b00      	cmp	r3, #0
 8006f86:	d005      	beq.n	8006f94 <_usb_reset+0x74>
 8006f88:	9b01      	ldr	r3, [sp, #4]
 8006f8a:	685b      	ldr	r3, [r3, #4]
 8006f8c:	681b      	ldr	r3, [r3, #0]
 8006f8e:	9801      	ldr	r0, [sp, #4]
 8006f90:	2100      	movs	r1, #0
 8006f92:	4798      	blx	r3
}
 8006f94:	b005      	add	sp, #20
 8006f96:	f85d fb04 	ldr.w	pc, [sp], #4
 8006f9a:	bf00      	nop
 8006f9c:	f3af 8000 	nop.w

08006fa0 <_usb_suspend>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_suspend(USBDriver *usbp) {
 8006fa0:	b500      	push	{lr}
 8006fa2:	b083      	sub	sp, #12
 8006fa4:	9001      	str	r0, [sp, #4]
  /* No state change, suspend always returns to previous state. */

  /* State transition.*/
  usbp->saved_state = usbp->state;
 8006fa6:	9b01      	ldr	r3, [sp, #4]
 8006fa8:	781a      	ldrb	r2, [r3, #0]
 8006faa:	9b01      	ldr	r3, [sp, #4]
 8006fac:	f883 2068 	strb.w	r2, [r3, #104]	; 0x68
  usbp->state       = USB_SUSPENDED;
 8006fb0:	9b01      	ldr	r3, [sp, #4]
 8006fb2:	2205      	movs	r2, #5
 8006fb4:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_SUSPEND);
 8006fb6:	9b01      	ldr	r3, [sp, #4]
 8006fb8:	685b      	ldr	r3, [r3, #4]
 8006fba:	681b      	ldr	r3, [r3, #0]
 8006fbc:	2b00      	cmp	r3, #0
 8006fbe:	d005      	beq.n	8006fcc <_usb_suspend+0x2c>
 8006fc0:	9b01      	ldr	r3, [sp, #4]
 8006fc2:	685b      	ldr	r3, [r3, #4]
 8006fc4:	681b      	ldr	r3, [r3, #0]
 8006fc6:	9801      	ldr	r0, [sp, #4]
 8006fc8:	2104      	movs	r1, #4
 8006fca:	4798      	blx	r3
        osalSysUnlockFromISR();
      }
    }
  }
#endif
}
 8006fcc:	b003      	add	sp, #12
 8006fce:	f85d fb04 	ldr.w	pc, [sp], #4
 8006fd2:	bf00      	nop
 8006fd4:	f3af 8000 	nop.w
 8006fd8:	f3af 8000 	nop.w
 8006fdc:	f3af 8000 	nop.w

08006fe0 <_usb_wakeup>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void _usb_wakeup(USBDriver *usbp) {
 8006fe0:	b500      	push	{lr}
 8006fe2:	b083      	sub	sp, #12
 8006fe4:	9001      	str	r0, [sp, #4]

  /* State transition, returning to the previous state.*/
  usbp->state = usbp->saved_state;
 8006fe6:	9b01      	ldr	r3, [sp, #4]
 8006fe8:	f893 2068 	ldrb.w	r2, [r3, #104]	; 0x68
 8006fec:	9b01      	ldr	r3, [sp, #4]
 8006fee:	701a      	strb	r2, [r3, #0]

  /* Notification of suspend event.*/
  _usb_isr_invoke_event_cb(usbp, USB_EVENT_WAKEUP);
 8006ff0:	9b01      	ldr	r3, [sp, #4]
 8006ff2:	685b      	ldr	r3, [r3, #4]
 8006ff4:	681b      	ldr	r3, [r3, #0]
 8006ff6:	2b00      	cmp	r3, #0
 8006ff8:	d005      	beq.n	8007006 <_usb_wakeup+0x26>
 8006ffa:	9b01      	ldr	r3, [sp, #4]
 8006ffc:	685b      	ldr	r3, [r3, #4]
 8006ffe:	681b      	ldr	r3, [r3, #0]
 8007000:	9801      	ldr	r0, [sp, #4]
 8007002:	2105      	movs	r1, #5
 8007004:	4798      	blx	r3
}
 8007006:	b003      	add	sp, #12
 8007008:	f85d fb04 	ldr.w	pc, [sp], #4
 800700c:	f3af 8000 	nop.w

08007010 <_usb_ep0setup>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0setup(USBDriver *usbp, usbep_t ep) {
 8007010:	b500      	push	{lr}
 8007012:	b085      	sub	sp, #20
 8007014:	9001      	str	r0, [sp, #4]
 8007016:	460b      	mov	r3, r1
 8007018:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  usbp->ep0state = USB_EP0_WAITING_SETUP;
 800701c:	9b01      	ldr	r3, [sp, #4]
 800701e:	2200      	movs	r2, #0
 8007020:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
  usbReadSetup(usbp, ep, usbp->setup);
 8007024:	9b01      	ldr	r3, [sp, #4]
 8007026:	335c      	adds	r3, #92	; 0x5c
 8007028:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800702c:	9801      	ldr	r0, [sp, #4]
 800702e:	4611      	mov	r1, r2
 8007030:	461a      	mov	r2, r3
 8007032:	f002 fa45 	bl	80094c0 <usb_lld_read_setup>

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007036:	9b01      	ldr	r3, [sp, #4]
 8007038:	685b      	ldr	r3, [r3, #4]
 800703a:	689b      	ldr	r3, [r3, #8]
 800703c:	2b00      	cmp	r3, #0
 800703e:	d00a      	beq.n	8007056 <_usb_ep0setup+0x46>
      !(usbp->config->requests_hook_cb(usbp))) {
 8007040:	9b01      	ldr	r3, [sp, #4]
 8007042:	685b      	ldr	r3, [r3, #4]
 8007044:	689b      	ldr	r3, [r3, #8]
 8007046:	9801      	ldr	r0, [sp, #4]
 8007048:	4798      	blx	r3
 800704a:	4603      	mov	r3, r0
 800704c:	f083 0301 	eor.w	r3, r3, #1
 8007050:	b2db      	uxtb	r3, r3
  usbReadSetup(usbp, ep, usbp->setup);

  /* First verify if the application has an handler installed for this
     request.*/
  /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
  if ((usbp->config->requests_hook_cb == NULL) ||
 8007052:	2b00      	cmp	r3, #0
 8007054:	d027      	beq.n	80070a6 <_usb_ep0setup+0x96>
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007056:	9b01      	ldr	r3, [sp, #4]
 8007058:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 800705c:	f003 0360 	and.w	r3, r3, #96	; 0x60
 8007060:	2b00      	cmp	r3, #0
 8007062:	d108      	bne.n	8007076 <_usb_ep0setup+0x66>
        !default_handler(usbp)) {
 8007064:	9801      	ldr	r0, [sp, #4]
 8007066:	f7ff fbf3 	bl	8006850 <default_handler>
 800706a:	4603      	mov	r3, r0
 800706c:	f083 0301 	eor.w	r3, r3, #1
 8007070:	b2db      	uxtb	r3, r3
      !(usbp->config->requests_hook_cb(usbp))) {
  /*lint -restore*/
    /* Invoking the default handler, if this fails then stalls the
       endpoint zero as error.*/
    /*lint -save -e9007 [13.5] No side effects, it is intentional.*/
    if (((usbp->setup[0] & USB_RTYPE_TYPE_MASK) != USB_RTYPE_TYPE_STD) ||
 8007072:	2b00      	cmp	r3, #0
 8007074:	d017      	beq.n	80070a6 <_usb_ep0setup+0x96>
        !default_handler(usbp)) {
    /*lint -restore*/
      /* Error response, the state machine goes into an error state, the low
         level layer will have to reset it to USB_EP0_WAITING_SETUP after
         receiving a SETUP packet.*/
      usb_lld_stall_in(usbp, 0);
 8007076:	9801      	ldr	r0, [sp, #4]
 8007078:	2100      	movs	r1, #0
 800707a:	f002 fba9 	bl	80097d0 <usb_lld_stall_in>
      usb_lld_stall_out(usbp, 0);
 800707e:	9801      	ldr	r0, [sp, #4]
 8007080:	2100      	movs	r1, #0
 8007082:	f002 fb85 	bl	8009790 <usb_lld_stall_out>
      _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 8007086:	9b01      	ldr	r3, [sp, #4]
 8007088:	685b      	ldr	r3, [r3, #4]
 800708a:	681b      	ldr	r3, [r3, #0]
 800708c:	2b00      	cmp	r3, #0
 800708e:	d005      	beq.n	800709c <_usb_ep0setup+0x8c>
 8007090:	9b01      	ldr	r3, [sp, #4]
 8007092:	685b      	ldr	r3, [r3, #4]
 8007094:	681b      	ldr	r3, [r3, #0]
 8007096:	9801      	ldr	r0, [sp, #4]
 8007098:	2106      	movs	r1, #6
 800709a:	4798      	blx	r3
      usbp->ep0state = USB_EP0_ERROR;
 800709c:	9b01      	ldr	r3, [sp, #4]
 800709e:	2206      	movs	r2, #6
 80070a0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80070a4:	e05c      	b.n	8007160 <_usb_ep0setup+0x150>
  }
#endif
  /* Transfer preparation. The request handler must have populated
     correctly the fields ep0next, ep0n and ep0endcb using the macro
     usbSetupTransfer().*/
  max = (size_t)get_hword(&usbp->setup[6]);
 80070a6:	9b01      	ldr	r3, [sp, #4]
 80070a8:	3362      	adds	r3, #98	; 0x62
 80070aa:	4618      	mov	r0, r3
 80070ac:	f7ff fb98 	bl	80067e0 <get_hword>
 80070b0:	4603      	mov	r3, r0
 80070b2:	9303      	str	r3, [sp, #12]
  /* The transfer size cannot exceed the specified amount.*/
  if (usbp->ep0n > max) {
 80070b4:	9b01      	ldr	r3, [sp, #4]
 80070b6:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80070b8:	9b03      	ldr	r3, [sp, #12]
 80070ba:	429a      	cmp	r2, r3
 80070bc:	d902      	bls.n	80070c4 <_usb_ep0setup+0xb4>
    usbp->ep0n = max;
 80070be:	9b01      	ldr	r3, [sp, #4]
 80070c0:	9a03      	ldr	r2, [sp, #12]
 80070c2:	655a      	str	r2, [r3, #84]	; 0x54
  }
  if ((usbp->setup[0] & USB_RTYPE_DIR_MASK) == USB_RTYPE_DIR_DEV2HOST) {
 80070c4:	9b01      	ldr	r3, [sp, #4]
 80070c6:	f893 305c 	ldrb.w	r3, [r3, #92]	; 0x5c
 80070ca:	b2db      	uxtb	r3, r3
 80070cc:	b25b      	sxtb	r3, r3
 80070ce:	2b00      	cmp	r3, #0
 80070d0:	da23      	bge.n	800711a <_usb_ep0setup+0x10a>
    /* IN phase.*/
    if (usbp->ep0n != 0U) {
 80070d2:	9b01      	ldr	r3, [sp, #4]
 80070d4:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070d6:	2b00      	cmp	r3, #0
 80070d8:	d010      	beq.n	80070fc <_usb_ep0setup+0xec>
      /* Starts the transmit phase.*/
      usbp->ep0state = USB_EP0_TX;
 80070da:	9b01      	ldr	r3, [sp, #4]
 80070dc:	2201      	movs	r2, #1
 80070de:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 80070e2:	f7ff fb65 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, usbp->ep0next, usbp->ep0n);
 80070e6:	9b01      	ldr	r3, [sp, #4]
 80070e8:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 80070ea:	9b01      	ldr	r3, [sp, #4]
 80070ec:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80070ee:	9801      	ldr	r0, [sp, #4]
 80070f0:	2100      	movs	r1, #0
 80070f2:	f7ff fea5 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80070f6:	f7ff fb63 	bl	80067c0 <osalSysUnlockFromISR>
 80070fa:	e031      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No transmission phase, directly receiving the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_WAITING_STS;
 80070fc:	9b01      	ldr	r3, [sp, #4]
 80070fe:	2203      	movs	r2, #3
 8007100:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 8007104:	f7ff fb54 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, NULL, 0);
 8007108:	9801      	ldr	r0, [sp, #4]
 800710a:	2100      	movs	r1, #0
 800710c:	2200      	movs	r2, #0
 800710e:	2300      	movs	r3, #0
 8007110:	f7ff fe66 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 8007114:	f7ff fb54 	bl	80067c0 <osalSysUnlockFromISR>
 8007118:	e022      	b.n	8007160 <_usb_ep0setup+0x150>
#endif
    }
  }
  else {
    /* OUT phase.*/
    if (usbp->ep0n != 0U) {
 800711a:	9b01      	ldr	r3, [sp, #4]
 800711c:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 800711e:	2b00      	cmp	r3, #0
 8007120:	d010      	beq.n	8007144 <_usb_ep0setup+0x134>
      /* Starts the receive phase.*/
      usbp->ep0state = USB_EP0_RX;
 8007122:	9b01      	ldr	r3, [sp, #4]
 8007124:	2204      	movs	r2, #4
 8007126:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      osalSysLockFromISR();
 800712a:	f7ff fb41 	bl	80067b0 <osalSysLockFromISR>
      usbStartReceiveI(usbp, 0, usbp->ep0next, usbp->ep0n);
 800712e:	9b01      	ldr	r3, [sp, #4]
 8007130:	6d1a      	ldr	r2, [r3, #80]	; 0x50
 8007132:	9b01      	ldr	r3, [sp, #4]
 8007134:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 8007136:	9801      	ldr	r0, [sp, #4]
 8007138:	2100      	movs	r1, #0
 800713a:	f7ff fe51 	bl	8006de0 <usbStartReceiveI>
      osalSysUnlockFromISR();
 800713e:	f7ff fb3f 	bl	80067c0 <osalSysUnlockFromISR>
 8007142:	e00d      	b.n	8007160 <_usb_ep0setup+0x150>
    }
    else {
      /* No receive phase, directly sending the zero sized status
         packet.*/
      usbp->ep0state = USB_EP0_SENDING_STS;
 8007144:	9b01      	ldr	r3, [sp, #4]
 8007146:	2205      	movs	r2, #5
 8007148:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
      osalSysLockFromISR();
 800714c:	f7ff fb30 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 8007150:	9801      	ldr	r0, [sp, #4]
 8007152:	2100      	movs	r1, #0
 8007154:	2200      	movs	r2, #0
 8007156:	2300      	movs	r3, #0
 8007158:	f7ff fe72 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 800715c:	f7ff fb30 	bl	80067c0 <osalSysUnlockFromISR>
#else
      usb_lld_end_setup(usbp, ep);
#endif
    }
  }
}
 8007160:	b005      	add	sp, #20
 8007162:	f85d fb04 	ldr.w	pc, [sp], #4
 8007166:	bf00      	nop
 8007168:	f3af 8000 	nop.w
 800716c:	f3af 8000 	nop.w

08007170 <_usb_ep0in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0in(USBDriver *usbp, usbep_t ep) {
 8007170:	b500      	push	{lr}
 8007172:	b085      	sub	sp, #20
 8007174:	9001      	str	r0, [sp, #4]
 8007176:	460b      	mov	r3, r1
 8007178:	f88d 3003 	strb.w	r3, [sp, #3]
  size_t max;

  (void)ep;
  switch (usbp->ep0state) {
 800717c:	9b01      	ldr	r3, [sp, #4]
 800717e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007182:	2b06      	cmp	r3, #6
 8007184:	d86b      	bhi.n	800725e <_usb_ep0in+0xee>
 8007186:	a201      	add	r2, pc, #4	; (adr r2, 800718c <_usb_ep0in+0x1c>)
 8007188:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800718c:	0800722f 	.word	0x0800722f
 8007190:	080071a9 	.word	0x080071a9
 8007194:	080071f7 	.word	0x080071f7
 8007198:	0800722f 	.word	0x0800722f
 800719c:	0800722f 	.word	0x0800722f
 80071a0:	08007215 	.word	0x08007215
 80071a4:	0800722f 	.word	0x0800722f
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
 80071a8:	9b01      	ldr	r3, [sp, #4]
 80071aa:	3362      	adds	r3, #98	; 0x62
 80071ac:	4618      	mov	r0, r3
 80071ae:	f7ff fb17 	bl	80067e0 <get_hword>
 80071b2:	4603      	mov	r3, r0
 80071b4:	9303      	str	r3, [sp, #12]
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071b6:	9b01      	ldr	r3, [sp, #4]
 80071b8:	6d5a      	ldr	r2, [r3, #84]	; 0x54
 80071ba:	9b03      	ldr	r3, [sp, #12]
 80071bc:	429a      	cmp	r2, r3
 80071be:	d21a      	bcs.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
 80071c0:	9b01      	ldr	r3, [sp, #4]
 80071c2:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80071c4:	9a01      	ldr	r2, [sp, #4]
 80071c6:	68d2      	ldr	r2, [r2, #12]
 80071c8:	8a12      	ldrh	r2, [r2, #16]
 80071ca:	fbb3 f1f2 	udiv	r1, r3, r2
 80071ce:	fb02 f201 	mul.w	r2, r2, r1
 80071d2:	1a9b      	subs	r3, r3, r2
  case USB_EP0_TX:
    max = (size_t)get_hword(&usbp->setup[6]);
    /* If the transmitted size is less than the requested size and it is a
       multiple of the maximum packet size then a zero size packet must be
       transmitted.*/
    if ((usbp->ep0n < max) &&
 80071d4:	2b00      	cmp	r3, #0
 80071d6:	d10e      	bne.n	80071f6 <_usb_ep0in+0x86>
        ((usbp->ep0n % usbp->epc[0]->in_maxsize) == 0U)) {
      osalSysLockFromISR();
 80071d8:	f7ff faea 	bl	80067b0 <osalSysLockFromISR>
      usbStartTransmitI(usbp, 0, NULL, 0);
 80071dc:	9801      	ldr	r0, [sp, #4]
 80071de:	2100      	movs	r1, #0
 80071e0:	2200      	movs	r2, #0
 80071e2:	2300      	movs	r3, #0
 80071e4:	f7ff fe2c 	bl	8006e40 <usbStartTransmitI>
      osalSysUnlockFromISR();
 80071e8:	f7ff faea 	bl	80067c0 <osalSysUnlockFromISR>
      usbp->ep0state = USB_EP0_WAITING_TX0;
 80071ec:	9b01      	ldr	r3, [sp, #4]
 80071ee:	2202      	movs	r2, #2
 80071f0:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
      return;
 80071f4:	e033      	b.n	800725e <_usb_ep0in+0xee>
    }
    /* Falls into, it is intentional.*/
  case USB_EP0_WAITING_TX0:
    /* Transmit phase over, receiving the zero sized status packet.*/
    usbp->ep0state = USB_EP0_WAITING_STS;
 80071f6:	9b01      	ldr	r3, [sp, #4]
 80071f8:	2203      	movs	r2, #3
 80071fa:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80071fe:	f7ff fad7 	bl	80067b0 <osalSysLockFromISR>
    usbStartReceiveI(usbp, 0, NULL, 0);
 8007202:	9801      	ldr	r0, [sp, #4]
 8007204:	2100      	movs	r1, #0
 8007206:	2200      	movs	r2, #0
 8007208:	2300      	movs	r3, #0
 800720a:	f7ff fde9 	bl	8006de0 <usbStartReceiveI>
    osalSysUnlockFromISR();
 800720e:	f7ff fad7 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 8007212:	e024      	b.n	800725e <_usb_ep0in+0xee>
  case USB_EP0_SENDING_STS:
    /* Status packet sent, invoking the callback if defined.*/
    if (usbp->ep0endcb != NULL) {
 8007214:	9b01      	ldr	r3, [sp, #4]
 8007216:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007218:	2b00      	cmp	r3, #0
 800721a:	d003      	beq.n	8007224 <_usb_ep0in+0xb4>
      usbp->ep0endcb(usbp);
 800721c:	9b01      	ldr	r3, [sp, #4]
 800721e:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8007220:	9801      	ldr	r0, [sp, #4]
 8007222:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 8007224:	9b01      	ldr	r3, [sp, #4]
 8007226:	2200      	movs	r2, #0
 8007228:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800722c:	e017      	b.n	800725e <_usb_ep0in+0xee>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 800722e:	9801      	ldr	r0, [sp, #4]
 8007230:	2100      	movs	r1, #0
 8007232:	f002 facd 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 8007236:	9801      	ldr	r0, [sp, #4]
 8007238:	2100      	movs	r1, #0
 800723a:	f002 faa9 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 800723e:	9b01      	ldr	r3, [sp, #4]
 8007240:	685b      	ldr	r3, [r3, #4]
 8007242:	681b      	ldr	r3, [r3, #0]
 8007244:	2b00      	cmp	r3, #0
 8007246:	d005      	beq.n	8007254 <_usb_ep0in+0xe4>
 8007248:	9b01      	ldr	r3, [sp, #4]
 800724a:	685b      	ldr	r3, [r3, #4]
 800724c:	681b      	ldr	r3, [r3, #0]
 800724e:	9801      	ldr	r0, [sp, #4]
 8007250:	2106      	movs	r1, #6
 8007252:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007254:	9b01      	ldr	r3, [sp, #4]
 8007256:	2206      	movs	r2, #6
 8007258:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800725c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800725e:	b005      	add	sp, #20
 8007260:	f85d fb04 	ldr.w	pc, [sp], #4
 8007264:	f3af 8000 	nop.w
 8007268:	f3af 8000 	nop.w
 800726c:	f3af 8000 	nop.w

08007270 <_usb_ep0out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number, always zero
 *
 * @notapi
 */
void _usb_ep0out(USBDriver *usbp, usbep_t ep) {
 8007270:	b500      	push	{lr}
 8007272:	b083      	sub	sp, #12
 8007274:	9001      	str	r0, [sp, #4]
 8007276:	460b      	mov	r3, r1
 8007278:	f88d 3003 	strb.w	r3, [sp, #3]

  (void)ep;
  switch (usbp->ep0state) {
 800727c:	9b01      	ldr	r3, [sp, #4]
 800727e:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 8007282:	2b06      	cmp	r3, #6
 8007284:	d84b      	bhi.n	800731e <_usb_ep0out+0xae>
 8007286:	a201      	add	r2, pc, #4	; (adr r2, 800728c <_usb_ep0out+0x1c>)
 8007288:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 800728c:	080072ef 	.word	0x080072ef
 8007290:	080072ef 	.word	0x080072ef
 8007294:	080072ef 	.word	0x080072ef
 8007298:	080072c7 	.word	0x080072c7
 800729c:	080072a9 	.word	0x080072a9
 80072a0:	080072ef 	.word	0x080072ef
 80072a4:	080072ef 	.word	0x080072ef
  case USB_EP0_RX:
    /* Receive phase over, sending the zero sized status packet.*/
    usbp->ep0state = USB_EP0_SENDING_STS;
 80072a8:	9b01      	ldr	r3, [sp, #4]
 80072aa:	2205      	movs	r2, #5
 80072ac:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    osalSysLockFromISR();
 80072b0:	f7ff fa7e 	bl	80067b0 <osalSysLockFromISR>
    usbStartTransmitI(usbp, 0, NULL, 0);
 80072b4:	9801      	ldr	r0, [sp, #4]
 80072b6:	2100      	movs	r1, #0
 80072b8:	2200      	movs	r2, #0
 80072ba:	2300      	movs	r3, #0
 80072bc:	f7ff fdc0 	bl	8006e40 <usbStartTransmitI>
    osalSysUnlockFromISR();
 80072c0:	f7ff fa7e 	bl	80067c0 <osalSysUnlockFromISR>
#else
    usb_lld_end_setup(usbp, ep);
#endif
    return;
 80072c4:	e02b      	b.n	800731e <_usb_ep0out+0xae>
  case USB_EP0_WAITING_STS:
    /* Status packet received, it must be zero sized, invoking the callback
       if defined.*/
#if (USB_EP0_STATUS_STAGE == USB_EP0_STATUS_STAGE_SW)
    if (usbGetReceiveTransactionSizeX(usbp, 0) != 0U) {
 80072c6:	9b01      	ldr	r3, [sp, #4]
 80072c8:	68db      	ldr	r3, [r3, #12]
 80072ca:	699b      	ldr	r3, [r3, #24]
 80072cc:	685b      	ldr	r3, [r3, #4]
 80072ce:	2b00      	cmp	r3, #0
 80072d0:	d000      	beq.n	80072d4 <_usb_ep0out+0x64>
      break;
 80072d2:	e024      	b.n	800731e <_usb_ep0out+0xae>
    }
#endif
    if (usbp->ep0endcb != NULL) {
 80072d4:	9b01      	ldr	r3, [sp, #4]
 80072d6:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072d8:	2b00      	cmp	r3, #0
 80072da:	d003      	beq.n	80072e4 <_usb_ep0out+0x74>
      usbp->ep0endcb(usbp);
 80072dc:	9b01      	ldr	r3, [sp, #4]
 80072de:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 80072e0:	9801      	ldr	r0, [sp, #4]
 80072e2:	4798      	blx	r3
    }
    usbp->ep0state = USB_EP0_WAITING_SETUP;
 80072e4:	9b01      	ldr	r3, [sp, #4]
 80072e6:	2200      	movs	r2, #0
 80072e8:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 80072ec:	e017      	b.n	800731e <_usb_ep0out+0xae>
    /* Falling through is intentional.*/
  case USB_EP0_ERROR:
    /* Error response, the state machine goes into an error state, the low
       level layer will have to reset it to USB_EP0_WAITING_SETUP after
       receiving a SETUP packet.*/
    usb_lld_stall_in(usbp, 0);
 80072ee:	9801      	ldr	r0, [sp, #4]
 80072f0:	2100      	movs	r1, #0
 80072f2:	f002 fa6d 	bl	80097d0 <usb_lld_stall_in>
    usb_lld_stall_out(usbp, 0);
 80072f6:	9801      	ldr	r0, [sp, #4]
 80072f8:	2100      	movs	r1, #0
 80072fa:	f002 fa49 	bl	8009790 <usb_lld_stall_out>
    _usb_isr_invoke_event_cb(usbp, USB_EVENT_STALLED);
 80072fe:	9b01      	ldr	r3, [sp, #4]
 8007300:	685b      	ldr	r3, [r3, #4]
 8007302:	681b      	ldr	r3, [r3, #0]
 8007304:	2b00      	cmp	r3, #0
 8007306:	d005      	beq.n	8007314 <_usb_ep0out+0xa4>
 8007308:	9b01      	ldr	r3, [sp, #4]
 800730a:	685b      	ldr	r3, [r3, #4]
 800730c:	681b      	ldr	r3, [r3, #0]
 800730e:	9801      	ldr	r0, [sp, #4]
 8007310:	2106      	movs	r1, #6
 8007312:	4798      	blx	r3
    usbp->ep0state = USB_EP0_ERROR;
 8007314:	9b01      	ldr	r3, [sp, #4]
 8007316:	2206      	movs	r2, #6
 8007318:	f883 204c 	strb.w	r2, [r3, #76]	; 0x4c
    return;
 800731c:	bf00      	nop
  default:
    osalDbgAssert(false, "EP0 state machine invalid state");
  }
}
 800731e:	b003      	add	sp, #12
 8007320:	f85d fb04 	ldr.w	pc, [sp], #4
 8007324:	f3af 8000 	nop.w
 8007328:	f3af 8000 	nop.w
 800732c:	f3af 8000 	nop.w

08007330 <nvicEnableVector>:
 * @brief   Sets the priority of an interrupt handler and enables it.
 *
 * @param[in] n         the interrupt number
 * @param[in] prio      the interrupt priority
 */
void nvicEnableVector(uint32_t n, uint32_t prio) {
 8007330:	b082      	sub	sp, #8
 8007332:	9001      	str	r0, [sp, #4]
 8007334:	9100      	str	r1, [sp, #0]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8007336:	4911      	ldr	r1, [pc, #68]	; (800737c <nvicEnableVector+0x4c>)
 8007338:	9b00      	ldr	r3, [sp, #0]
 800733a:	b2db      	uxtb	r3, r3
 800733c:	011b      	lsls	r3, r3, #4
 800733e:	b2da      	uxtb	r2, r3
 8007340:	9b01      	ldr	r3, [sp, #4]
 8007342:	440b      	add	r3, r1
 8007344:	f503 7340 	add.w	r3, r3, #768	; 0x300
 8007348:	701a      	strb	r2, [r3, #0]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800734a:	4b0c      	ldr	r3, [pc, #48]	; (800737c <nvicEnableVector+0x4c>)
 800734c:	9a01      	ldr	r2, [sp, #4]
 800734e:	0952      	lsrs	r2, r2, #5
 8007350:	9901      	ldr	r1, [sp, #4]
 8007352:	f001 011f 	and.w	r1, r1, #31
 8007356:	2001      	movs	r0, #1
 8007358:	fa00 f101 	lsl.w	r1, r0, r1
 800735c:	3260      	adds	r2, #96	; 0x60
 800735e:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8007362:	4b06      	ldr	r3, [pc, #24]	; (800737c <nvicEnableVector+0x4c>)
 8007364:	9a01      	ldr	r2, [sp, #4]
 8007366:	0952      	lsrs	r2, r2, #5
 8007368:	9901      	ldr	r1, [sp, #4]
 800736a:	f001 011f 	and.w	r1, r1, #31
 800736e:	2001      	movs	r0, #1
 8007370:	fa00 f101 	lsl.w	r1, r0, r1
 8007374:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 8007378:	b002      	add	sp, #8
 800737a:	4770      	bx	lr
 800737c:	e000e100 	.word	0xe000e100

08007380 <nvicDisableVector>:
/**
 * @brief   Disables an interrupt handler.
 *
 * @param[in] n         the interrupt number
 */
void nvicDisableVector(uint32_t n) {
 8007380:	b082      	sub	sp, #8
 8007382:	9001      	str	r0, [sp, #4]

  NVIC->ICER[n >> 5U] = 1U << (n & 0x1FU);
 8007384:	4b0a      	ldr	r3, [pc, #40]	; (80073b0 <nvicDisableVector+0x30>)
 8007386:	9a01      	ldr	r2, [sp, #4]
 8007388:	0952      	lsrs	r2, r2, #5
 800738a:	9901      	ldr	r1, [sp, #4]
 800738c:	f001 011f 	and.w	r1, r1, #31
 8007390:	2001      	movs	r0, #1
 8007392:	fa00 f101 	lsl.w	r1, r0, r1
 8007396:	3220      	adds	r2, #32
 8007398:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = 0U;
 800739c:	4a04      	ldr	r2, [pc, #16]	; (80073b0 <nvicDisableVector+0x30>)
 800739e:	9b01      	ldr	r3, [sp, #4]
 80073a0:	4413      	add	r3, r2
 80073a2:	f503 7340 	add.w	r3, r3, #768	; 0x300
 80073a6:	2200      	movs	r2, #0
 80073a8:	701a      	strb	r2, [r3, #0]
#endif
}
 80073aa:	b002      	add	sp, #8
 80073ac:	4770      	bx	lr
 80073ae:	bf00      	nop
 80073b0:	e000e100 	.word	0xe000e100
 80073b4:	f3af 8000 	nop.w
 80073b8:	f3af 8000 	nop.w
 80073bc:	f3af 8000 	nop.w

080073c0 <nvicSetSystemHandlerPriority>:
 * @brief   Changes the priority of a system handler.
 *
 * @param[in] handler   the system handler number
 * @param[in] prio      the system handler priority
 */
void nvicSetSystemHandlerPriority(uint32_t handler, uint32_t prio) {
 80073c0:	b082      	sub	sp, #8
 80073c2:	9001      	str	r0, [sp, #4]
 80073c4:	9100      	str	r1, [sp, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80073c6:	4905      	ldr	r1, [pc, #20]	; (80073dc <nvicSetSystemHandlerPriority+0x1c>)
 80073c8:	9b00      	ldr	r3, [sp, #0]
 80073ca:	b2db      	uxtb	r3, r3
 80073cc:	011b      	lsls	r3, r3, #4
 80073ce:	b2da      	uxtb	r2, r3
 80073d0:	9b01      	ldr	r3, [sp, #4]
 80073d2:	440b      	add	r3, r1
 80073d4:	3318      	adds	r3, #24
 80073d6:	701a      	strb	r2, [r3, #0]
#endif
}
 80073d8:	b002      	add	sp, #8
 80073da:	4770      	bx	lr
 80073dc:	e000ed00 	.word	0xe000ed00

080073e0 <nvicClearPending>:
/**
 * @brief   Clears a pending interrupt source.
 *
 * @param[in] n         the interrupt number
 */
void nvicClearPending(uint32_t n) {
 80073e0:	b082      	sub	sp, #8
 80073e2:	9001      	str	r0, [sp, #4]

  NVIC->ICPR[n >> 5] = 1 << (n & 0x1F);
 80073e4:	4b06      	ldr	r3, [pc, #24]	; (8007400 <nvicClearPending+0x20>)
 80073e6:	9a01      	ldr	r2, [sp, #4]
 80073e8:	0952      	lsrs	r2, r2, #5
 80073ea:	9901      	ldr	r1, [sp, #4]
 80073ec:	f001 011f 	and.w	r1, r1, #31
 80073f0:	2001      	movs	r0, #1
 80073f2:	fa00 f101 	lsl.w	r1, r0, r1
 80073f6:	3260      	adds	r2, #96	; 0x60
 80073f8:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
}
 80073fc:	b002      	add	sp, #8
 80073fe:	4770      	bx	lr
 8007400:	e000e100 	.word	0xe000e100
 8007404:	f3af 8000 	nop.w
 8007408:	f3af 8000 	nop.w
 800740c:	f3af 8000 	nop.w

08007410 <hal_lld_backup_domain_init>:
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL) {
 8007410:	4b22      	ldr	r3, [pc, #136]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007412:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007416:	f403 7340 	and.w	r3, r3, #768	; 0x300
 800741a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 800741e:	d008      	beq.n	8007432 <hal_lld_backup_domain_init+0x22>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8007420:	4b1e      	ldr	r3, [pc, #120]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007422:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 8007426:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    RCC->BDCR = 0;
 800742a:	4b1c      	ldr	r3, [pc, #112]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800742c:	2200      	movs	r2, #0
 800742e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 8007432:	4b1a      	ldr	r3, [pc, #104]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007434:	4a19      	ldr	r2, [pc, #100]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007436:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 800743a:	f042 0219 	orr.w	r2, r2, #25
 800743e:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 8007442:	bf00      	nop
 8007444:	4b15      	ldr	r3, [pc, #84]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007446:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 800744a:	f003 0302 	and.w	r3, r3, #2
 800744e:	2b00      	cmp	r3, #0
 8007450:	d0f8      	beq.n	8007444 <hal_lld_backup_domain_init+0x34>
#endif

#if STM32_MSIPLL_ENABLED
  /* MSI PLL activation depends on LSE. Reactivating and checking for
     MSI stability.*/
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007452:	4b12      	ldr	r3, [pc, #72]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007454:	4a11      	ldr	r2, [pc, #68]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007456:	6812      	ldr	r2, [r2, #0]
 8007458:	f042 0204 	orr.w	r2, r2, #4
 800745c:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 800745e:	bf00      	nop
 8007460:	4b0e      	ldr	r3, [pc, #56]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 8007462:	681b      	ldr	r3, [r3, #0]
 8007464:	f003 0302 	and.w	r3, r3, #2
 8007468:	2b00      	cmp	r3, #0
 800746a:	d0f9      	beq.n	8007460 <hal_lld_backup_domain_init+0x50>
#endif

#if HAL_USE_RTC
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 800746c:	4b0b      	ldr	r3, [pc, #44]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800746e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 8007472:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8007476:	2b00      	cmp	r3, #0
 8007478:	d10f      	bne.n	800749a <hal_lld_backup_domain_init+0x8a>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800747a:	4b08      	ldr	r3, [pc, #32]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747c:	4a07      	ldr	r2, [pc, #28]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800747e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007482:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8007486:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 800748a:	4b04      	ldr	r3, [pc, #16]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748c:	4a03      	ldr	r2, [pc, #12]	; (800749c <hal_lld_backup_domain_init+0x8c>)
 800748e:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 8007492:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8007496:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
  }
#endif /* HAL_USE_RTC */
}
 800749a:	4770      	bx	lr
 800749c:	40021000 	.word	0x40021000

080074a0 <hal_lld_init>:
/**
 * @brief   Low level HAL driver initialization.
 *
 * @notapi
 */
void hal_lld_init(void) {
 80074a0:	b508      	push	{r3, lr}

  /* Reset of all peripherals.*/
  rccResetAHB1(~0);
 80074a2:	4b28      	ldr	r3, [pc, #160]	; (8007544 <hal_lld_init+0xa4>)
 80074a4:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80074a6:	4b27      	ldr	r3, [pc, #156]	; (8007544 <hal_lld_init+0xa4>)
 80074a8:	f04f 32ff 	mov.w	r2, #4294967295
 80074ac:	629a      	str	r2, [r3, #40]	; 0x28
 80074ae:	4b25      	ldr	r3, [pc, #148]	; (8007544 <hal_lld_init+0xa4>)
 80074b0:	2200      	movs	r2, #0
 80074b2:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAHB2(~0);
 80074b4:	4b23      	ldr	r3, [pc, #140]	; (8007544 <hal_lld_init+0xa4>)
 80074b6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80074b8:	4b22      	ldr	r3, [pc, #136]	; (8007544 <hal_lld_init+0xa4>)
 80074ba:	f04f 32ff 	mov.w	r2, #4294967295
 80074be:	62da      	str	r2, [r3, #44]	; 0x2c
 80074c0:	4b20      	ldr	r3, [pc, #128]	; (8007544 <hal_lld_init+0xa4>)
 80074c2:	2200      	movs	r2, #0
 80074c4:	62da      	str	r2, [r3, #44]	; 0x2c
  rccResetAHB3(~0);
 80074c6:	4b1f      	ldr	r3, [pc, #124]	; (8007544 <hal_lld_init+0xa4>)
 80074c8:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80074ca:	4b1e      	ldr	r3, [pc, #120]	; (8007544 <hal_lld_init+0xa4>)
 80074cc:	f04f 32ff 	mov.w	r2, #4294967295
 80074d0:	631a      	str	r2, [r3, #48]	; 0x30
 80074d2:	4b1c      	ldr	r3, [pc, #112]	; (8007544 <hal_lld_init+0xa4>)
 80074d4:	2200      	movs	r2, #0
 80074d6:	631a      	str	r2, [r3, #48]	; 0x30
  rccResetAPB1R1(~RCC_APB1RSTR1_PWRRST);
 80074d8:	4b1a      	ldr	r3, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074da:	4a1a      	ldr	r2, [pc, #104]	; (8007544 <hal_lld_init+0xa4>)
 80074dc:	6b92      	ldr	r2, [r2, #56]	; 0x38
 80074de:	f062 5280 	orn	r2, r2, #268435456	; 0x10000000
 80074e2:	639a      	str	r2, [r3, #56]	; 0x38
 80074e4:	4b17      	ldr	r3, [pc, #92]	; (8007544 <hal_lld_init+0xa4>)
 80074e6:	2200      	movs	r2, #0
 80074e8:	639a      	str	r2, [r3, #56]	; 0x38
  rccResetAPB1R2(~0);
 80074ea:	4b16      	ldr	r3, [pc, #88]	; (8007544 <hal_lld_init+0xa4>)
 80074ec:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80074ee:	4b15      	ldr	r3, [pc, #84]	; (8007544 <hal_lld_init+0xa4>)
 80074f0:	f04f 32ff 	mov.w	r2, #4294967295
 80074f4:	63da      	str	r2, [r3, #60]	; 0x3c
 80074f6:	4b13      	ldr	r3, [pc, #76]	; (8007544 <hal_lld_init+0xa4>)
 80074f8:	2200      	movs	r2, #0
 80074fa:	63da      	str	r2, [r3, #60]	; 0x3c
  rccResetAPB2(~0);
 80074fc:	4b11      	ldr	r3, [pc, #68]	; (8007544 <hal_lld_init+0xa4>)
 80074fe:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 8007500:	4b10      	ldr	r3, [pc, #64]	; (8007544 <hal_lld_init+0xa4>)
 8007502:	f04f 32ff 	mov.w	r2, #4294967295
 8007506:	641a      	str	r2, [r3, #64]	; 0x40
 8007508:	4b0e      	ldr	r3, [pc, #56]	; (8007544 <hal_lld_init+0xa4>)
 800750a:	2200      	movs	r2, #0
 800750c:	641a      	str	r2, [r3, #64]	; 0x40

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800750e:	4b0d      	ldr	r3, [pc, #52]	; (8007544 <hal_lld_init+0xa4>)
 8007510:	4a0c      	ldr	r2, [pc, #48]	; (8007544 <hal_lld_init+0xa4>)
 8007512:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007514:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8007518:	659a      	str	r2, [r3, #88]	; 0x58

  /* Initializes the backup domain.*/
  hal_lld_backup_domain_init();
 800751a:	f7ff ff79 	bl	8007410 <hal_lld_backup_domain_init>

#if defined(STM32_DMA_REQUIRED)
  dmaInit();
 800751e:	f000 fbf7 	bl	8007d10 <dmaInit>

  /* Programmable voltage detector enable.*/
#if STM32_PVD_ENABLE
  PWR->CR2 = PWR_CR2_PVDE | (STM32_PLS & STM32_PLS_MASK);
#else
  PWR->CR2 = 0;
 8007522:	4b09      	ldr	r3, [pc, #36]	; (8007548 <hal_lld_init+0xa8>)
 8007524:	2200      	movs	r2, #0
 8007526:	605a      	str	r2, [r3, #4]
#endif /* STM32_PVD_ENABLE */

  /* Enabling independent VDDUSB.*/
#if HAL_USE_USB
  PWR->CR2 |= PWR_CR2_USV;
 8007528:	4b07      	ldr	r3, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752a:	4a07      	ldr	r2, [pc, #28]	; (8007548 <hal_lld_init+0xa8>)
 800752c:	6852      	ldr	r2, [r2, #4]
 800752e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8007532:	605a      	str	r2, [r3, #4]
#endif /* HAL_USE_USB */

  /* Enabling independent VDDIO2 required by GPIOG.*/
#if STM32_HAS_GPIOG
  PWR->CR2 |= PWR_CR2_IOSV;
 8007534:	4b04      	ldr	r3, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007536:	4a04      	ldr	r2, [pc, #16]	; (8007548 <hal_lld_init+0xa8>)
 8007538:	6852      	ldr	r2, [r2, #4]
 800753a:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800753e:	605a      	str	r2, [r3, #4]
#endif /* STM32_HAS_GPIOG */
}
 8007540:	bd08      	pop	{r3, pc}
 8007542:	bf00      	nop
 8007544:	40021000 	.word	0x40021000
 8007548:	40007000 	.word	0x40007000
 800754c:	f3af 8000 	nop.w

08007550 <stm32_clock_init>:
 * @note    All the involved constants come from the file @p board.h.
 * @note    This function should be invoked just after the system reset.
 *
 * @special
 */
void stm32_clock_init(void) {
 8007550:	b082      	sub	sp, #8

#if !STM32_NO_INIT
  /* PWR clock enable.*/
  RCC->APB1ENR1 |= RCC_APB1ENR1_PWREN;
 8007552:	4b5e      	ldr	r3, [pc, #376]	; (80076cc <stm32_clock_init+0x17c>)
 8007554:	4a5d      	ldr	r2, [pc, #372]	; (80076cc <stm32_clock_init+0x17c>)
 8007556:	6d92      	ldr	r2, [r2, #88]	; 0x58
 8007558:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800755c:	659a      	str	r2, [r3, #88]	; 0x58
  /* Initial clocks setup and wait for MSI stabilization, the MSI clock is
     always enabled because it is the fall back clock when PLL the fails.
     Trim fields are not altered from reset values.*/

  /* MSIRANGE can be set only when MSI is OFF or READY.*/
  RCC->CR = RCC_CR_MSION;
 800755e:	4b5b      	ldr	r3, [pc, #364]	; (80076cc <stm32_clock_init+0x17c>)
 8007560:	2201      	movs	r2, #1
 8007562:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007564:	bf00      	nop
 8007566:	4b59      	ldr	r3, [pc, #356]	; (80076cc <stm32_clock_init+0x17c>)
 8007568:	681b      	ldr	r3, [r3, #0]
 800756a:	f003 0302 	and.w	r3, r3, #2
 800756e:	2b00      	cmp	r3, #0
 8007570:	d0f9      	beq.n	8007566 <stm32_clock_init+0x16>
    ;                                       /* Wait until MSI is stable.    */

  /* Clocking from MSI, in case MSI was not the default source.*/
  RCC->CFGR = 0;
 8007572:	4b56      	ldr	r3, [pc, #344]	; (80076cc <stm32_clock_init+0x17c>)
 8007574:	2200      	movs	r2, #0
 8007576:	609a      	str	r2, [r3, #8]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007578:	bf00      	nop
 800757a:	4b54      	ldr	r3, [pc, #336]	; (80076cc <stm32_clock_init+0x17c>)
 800757c:	689b      	ldr	r3, [r3, #8]
 800757e:	f003 030c 	and.w	r3, r3, #12
 8007582:	2b00      	cmp	r3, #0
 8007584:	d1f9      	bne.n	800757a <stm32_clock_init+0x2a>
    ;                                       /* Wait until MSI is selected.  */

  /* Core voltage setup.*/
  PWR->CR1 = STM32_VOS;
 8007586:	4b52      	ldr	r3, [pc, #328]	; (80076d0 <stm32_clock_init+0x180>)
 8007588:	f44f 7200 	mov.w	r2, #512	; 0x200
 800758c:	601a      	str	r2, [r3, #0]
  while ((PWR->SR2 & PWR_SR2_VOSF) != 0)    /* Wait until regulator is      */
 800758e:	bf00      	nop
 8007590:	4b4f      	ldr	r3, [pc, #316]	; (80076d0 <stm32_clock_init+0x180>)
 8007592:	695b      	ldr	r3, [r3, #20]
 8007594:	f403 6380 	and.w	r3, r3, #1024	; 0x400
 8007598:	2b00      	cmp	r3, #0
 800759a:	d1f9      	bne.n	8007590 <stm32_clock_init+0x40>
    ;                                       /* Wait until HSE is stable.    */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 800759c:	4b4b      	ldr	r3, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 800759e:	4a4b      	ldr	r2, [pc, #300]	; (80076cc <stm32_clock_init+0x17c>)
 80075a0:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 80075a4:	f042 0201 	orr.w	r2, r2, #1
 80075a8:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80075ac:	bf00      	nop
 80075ae:	4b47      	ldr	r3, [pc, #284]	; (80076cc <stm32_clock_init+0x17c>)
 80075b0:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 80075b4:	f003 0302 	and.w	r3, r3, #2
 80075b8:	2b00      	cmp	r3, #0
 80075ba:	d0f8      	beq.n	80075ae <stm32_clock_init+0x5e>
    ;                                       /* Wait until LSI is stable.    */
#endif

  /* Backup domain access enabled and left open.*/
  PWR->CR1 |= PWR_CR1_DBP;
 80075bc:	4b44      	ldr	r3, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075be:	4a44      	ldr	r2, [pc, #272]	; (80076d0 <stm32_clock_init+0x180>)
 80075c0:	6812      	ldr	r2, [r2, #0]
 80075c2:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 80075c6:	601a      	str	r2, [r3, #0]
#if defined(STM32_LSE_BYPASS)
  /* LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON | RCC_BDCR_LSEBYP;
#else
  /* No LSE Bypass.*/
  RCC->BDCR |= STM32_LSEDRV | RCC_BDCR_LSEON;
 80075c8:	4b40      	ldr	r3, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075ca:	4a40      	ldr	r2, [pc, #256]	; (80076cc <stm32_clock_init+0x17c>)
 80075cc:	f8d2 2090 	ldr.w	r2, [r2, #144]	; 0x90
 80075d0:	f042 0219 	orr.w	r2, r2, #25
 80075d4:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
#endif
  while ((RCC->BDCR & RCC_BDCR_LSERDY) == 0)
 80075d8:	bf00      	nop
 80075da:	4b3c      	ldr	r3, [pc, #240]	; (80076cc <stm32_clock_init+0x17c>)
 80075dc:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80075e0:	f003 0302 	and.w	r3, r3, #2
 80075e4:	2b00      	cmp	r3, #0
 80075e6:	d0f8      	beq.n	80075da <stm32_clock_init+0x8a>
    ;                                       /* Wait until LSE is stable.    */
#endif

  /* Flash setup for selected MSI speed setting.*/
  FLASH->ACR = FLASH_ACR_DCEN | FLASH_ACR_ICEN | FLASH_ACR_PRFTEN |
 80075e8:	4b3a      	ldr	r3, [pc, #232]	; (80076d4 <stm32_clock_init+0x184>)
 80075ea:	f44f 62e0 	mov.w	r2, #1792	; 0x700
 80075ee:	601a      	str	r2, [r3, #0]
               STM32_MSI_FLASHBITS;

  /* Changing MSIRANGE to configured value.*/
  RCC->CR |= STM32_MSIRANGE;
 80075f0:	4b36      	ldr	r3, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f2:	4a36      	ldr	r2, [pc, #216]	; (80076cc <stm32_clock_init+0x17c>)
 80075f4:	6812      	ldr	r2, [r2, #0]
 80075f6:	f042 0260 	orr.w	r2, r2, #96	; 0x60
 80075fa:	601a      	str	r2, [r3, #0]

  /* Switching from MSISRANGE to MSIRANGE.*/
  RCC->CR |= RCC_CR_MSIRGSEL;
 80075fc:	4b33      	ldr	r3, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 80075fe:	4a33      	ldr	r2, [pc, #204]	; (80076cc <stm32_clock_init+0x17c>)
 8007600:	6812      	ldr	r2, [r2, #0]
 8007602:	f042 0208 	orr.w	r2, r2, #8
 8007606:	601a      	str	r2, [r3, #0]
  while ((RCC->CR & RCC_CR_MSIRDY) == 0)
 8007608:	bf00      	nop
 800760a:	4b30      	ldr	r3, [pc, #192]	; (80076cc <stm32_clock_init+0x17c>)
 800760c:	681b      	ldr	r3, [r3, #0]
 800760e:	f003 0302 	and.w	r3, r3, #2
 8007612:	2b00      	cmp	r3, #0
 8007614:	d0f9      	beq.n	800760a <stm32_clock_init+0xba>
    ;

  /* MSI is configured SYSCLK source so wait for it to be stable as well.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_MSI)
 8007616:	bf00      	nop
 8007618:	4b2c      	ldr	r3, [pc, #176]	; (80076cc <stm32_clock_init+0x17c>)
 800761a:	689b      	ldr	r3, [r3, #8]
 800761c:	f003 030c 	and.w	r3, r3, #12
 8007620:	2b00      	cmp	r3, #0
 8007622:	d1f9      	bne.n	8007618 <stm32_clock_init+0xc8>
    ;

#if STM32_MSIPLL_ENABLED
  /* MSI PLL (to LSE) activation */
  RCC->CR |= RCC_CR_MSIPLLEN;
 8007624:	4b29      	ldr	r3, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007626:	4a29      	ldr	r2, [pc, #164]	; (80076cc <stm32_clock_init+0x17c>)
 8007628:	6812      	ldr	r2, [r2, #0]
 800762a:	f042 0204 	orr.w	r2, r2, #4
 800762e:	601a      	str	r2, [r3, #0]
#endif

  /* Updating MSISRANGE value. MSISRANGE can be set only when MSIRGSEL is high.
     This range is used exiting the Standby mode until MSIRGSEL is set.*/
  RCC->CSR |= STM32_MSISRANGE;
 8007630:	4b26      	ldr	r3, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007632:	4a26      	ldr	r2, [pc, #152]	; (80076cc <stm32_clock_init+0x17c>)
 8007634:	f8d2 2094 	ldr.w	r2, [r2, #148]	; 0x94
 8007638:	f442 62c0 	orr.w	r2, r2, #1536	; 0x600
 800763c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94

#if STM32_ACTIVATE_PLL || STM32_ACTIVATE_PLLSAI1 || STM32_ACTIVATE_PLLSAI2
  /* PLLM and PLLSRC are common to all PLLs.*/
  RCC->PLLCFGR = STM32_PLLR   | STM32_PLLREN |
 8007640:	4b22      	ldr	r3, [pc, #136]	; (80076cc <stm32_clock_init+0x17c>)
 8007642:	4a25      	ldr	r2, [pc, #148]	; (80076d8 <stm32_clock_init+0x188>)
 8007644:	60da      	str	r2, [r3, #12]
                 STM32_PLLSRC;
#endif

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR |= RCC_CR_PLLON;
 8007646:	4b21      	ldr	r3, [pc, #132]	; (80076cc <stm32_clock_init+0x17c>)
 8007648:	4a20      	ldr	r2, [pc, #128]	; (80076cc <stm32_clock_init+0x17c>)
 800764a:	6812      	ldr	r2, [r2, #0]
 800764c:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 8007650:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLRDY) == 0)
 8007652:	bf00      	nop
 8007654:	4b1d      	ldr	r3, [pc, #116]	; (80076cc <stm32_clock_init+0x17c>)
 8007656:	681b      	ldr	r3, [r3, #0]
 8007658:	f003 7300 	and.w	r3, r3, #33554432	; 0x2000000
 800765c:	2b00      	cmp	r3, #0
 800765e:	d0f9      	beq.n	8007654 <stm32_clock_init+0x104>
    ;
#endif

#if STM32_ACTIVATE_PLLSAI1
  /* PLLSAI1 activation.*/
  RCC->PLLSAI1CFGR = STM32_PLLSAI1R | STM32_PLLSAI1REN |
 8007660:	4b1a      	ldr	r3, [pc, #104]	; (80076cc <stm32_clock_init+0x17c>)
 8007662:	4a1e      	ldr	r2, [pc, #120]	; (80076dc <stm32_clock_init+0x18c>)
 8007664:	611a      	str	r2, [r3, #16]
                     STM32_PLLSAI1Q | STM32_PLLSAI1QEN |
                     STM32_PLLSAI1P | STM32_PLLSAI1PEN |
                     STM32_PLLSAI1N;
  RCC->CR |= RCC_CR_PLLSAI1ON;
 8007666:	4b19      	ldr	r3, [pc, #100]	; (80076cc <stm32_clock_init+0x17c>)
 8007668:	4a18      	ldr	r2, [pc, #96]	; (80076cc <stm32_clock_init+0x17c>)
 800766a:	6812      	ldr	r2, [r2, #0]
 800766c:	f042 6280 	orr.w	r2, r2, #67108864	; 0x4000000
 8007670:	601a      	str	r2, [r3, #0]

  /* Waiting for PLL lock.*/
  while ((RCC->CR & RCC_CR_PLLSAI1RDY) == 0)
 8007672:	bf00      	nop
 8007674:	4b15      	ldr	r3, [pc, #84]	; (80076cc <stm32_clock_init+0x17c>)
 8007676:	681b      	ldr	r3, [r3, #0]
 8007678:	f003 6300 	and.w	r3, r3, #134217728	; 0x8000000
 800767c:	2b00      	cmp	r3, #0
 800767e:	d0f9      	beq.n	8007674 <stm32_clock_init+0x124>
  while ((RCC->CR & RCC_CR_PLLSAI2RDY) == 0)
    ;
#endif

  /* Other clock-related settings (dividers, MCO etc).*/
  RCC->CFGR = STM32_MCOPRE | STM32_MCOSEL | STM32_STOPWUCK |
 8007680:	4b12      	ldr	r3, [pc, #72]	; (80076cc <stm32_clock_init+0x17c>)
 8007682:	2200      	movs	r2, #0
 8007684:	609a      	str	r2, [r3, #8]
              STM32_PPRE2  | STM32_PPRE1  | STM32_HPRE;

  /* CCIPR register initialization, note, must take care of the _OFF
     pseudo settings.*/
  {
    uint32_t ccipr = STM32_DFSDMSEL  | STM32_SWPMI1SEL | STM32_ADCSEL    |
 8007686:	4b16      	ldr	r3, [pc, #88]	; (80076e0 <stm32_clock_init+0x190>)
 8007688:	9301      	str	r3, [sp, #4]
    ccipr |= STM32_SAI2SEL;
#endif
#if STM32_SAI1SEL != STM32_SAI1SEL_OFF
    ccipr |= STM32_SAI1SEL;
#endif
    RCC->CCIPR = ccipr;
 800768a:	4b10      	ldr	r3, [pc, #64]	; (80076cc <stm32_clock_init+0x17c>)
 800768c:	9a01      	ldr	r2, [sp, #4]
 800768e:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
  }

  /* Set flash WS's for SYSCLK source */
  if (STM32_FLASHBITS > STM32_MSI_FLASHBITS)
    FLASH->ACR = (FLASH->ACR & ~FLASH_ACR_LATENCY_Msk) | STM32_FLASHBITS;
 8007692:	4b10      	ldr	r3, [pc, #64]	; (80076d4 <stm32_clock_init+0x184>)
 8007694:	4a0f      	ldr	r2, [pc, #60]	; (80076d4 <stm32_clock_init+0x184>)
 8007696:	6812      	ldr	r2, [r2, #0]
 8007698:	f022 0207 	bic.w	r2, r2, #7
 800769c:	f042 0204 	orr.w	r2, r2, #4
 80076a0:	601a      	str	r2, [r3, #0]

  /* Switching to the configured SYSCLK source if it is different from MSI.*/
#if (STM32_SW != STM32_SW_MSI)
  RCC->CFGR |= STM32_SW;        /* Switches on the selected clock source.   */
 80076a2:	4b0a      	ldr	r3, [pc, #40]	; (80076cc <stm32_clock_init+0x17c>)
 80076a4:	4a09      	ldr	r2, [pc, #36]	; (80076cc <stm32_clock_init+0x17c>)
 80076a6:	6892      	ldr	r2, [r2, #8]
 80076a8:	f042 0203 	orr.w	r2, r2, #3
 80076ac:	609a      	str	r2, [r3, #8]
  /* Wait until SYSCLK is stable.*/
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 80076ae:	bf00      	nop
 80076b0:	4b06      	ldr	r3, [pc, #24]	; (80076cc <stm32_clock_init+0x17c>)
 80076b2:	689b      	ldr	r3, [r3, #8]
 80076b4:	f003 030c 	and.w	r3, r3, #12
 80076b8:	2b0c      	cmp	r3, #12
 80076ba:	d1f9      	bne.n	80076b0 <stm32_clock_init+0x160>

#endif /* STM32_NO_INIT */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 80076bc:	4b03      	ldr	r3, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076be:	4a03      	ldr	r2, [pc, #12]	; (80076cc <stm32_clock_init+0x17c>)
 80076c0:	6e12      	ldr	r2, [r2, #96]	; 0x60
 80076c2:	f042 0201 	orr.w	r2, r2, #1
 80076c6:	661a      	str	r2, [r3, #96]	; 0x60
}
 80076c8:	b002      	add	sp, #8
 80076ca:	4770      	bx	lr
 80076cc:	40021000 	.word	0x40021000
 80076d0:	40007000 	.word	0x40007000
 80076d4:	40022000 	.word	0x40022000
 80076d8:	03405001 	.word	0x03405001
 80076dc:	04504800 	.word	0x04504800
 80076e0:	34015555 	.word	0x34015555
 80076e4:	f3af 8000 	nop.w
 80076e8:	f3af 8000 	nop.w
 80076ec:	f3af 8000 	nop.w

080076f0 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH1_HANDLER) {
 80076f0:	b500      	push	{lr}
 80076f2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM1);
 80076f4:	2300      	movs	r3, #0
 80076f6:	9301      	str	r3, [sp, #4]
 80076f8:	4b14      	ldr	r3, [pc, #80]	; (800774c <Vector6C+0x5c>)
 80076fa:	681a      	ldr	r2, [r3, #0]
 80076fc:	2300      	movs	r3, #0
 80076fe:	fa22 f303 	lsr.w	r3, r2, r3
 8007702:	f003 030f 	and.w	r3, r3, #15
 8007706:	9300      	str	r3, [sp, #0]
 8007708:	9b00      	ldr	r3, [sp, #0]
 800770a:	f003 030f 	and.w	r3, r3, #15
 800770e:	2b00      	cmp	r3, #0
 8007710:	d017      	beq.n	8007742 <Vector6C+0x52>
 8007712:	4b0e      	ldr	r3, [pc, #56]	; (800774c <Vector6C+0x5c>)
 8007714:	2200      	movs	r2, #0
 8007716:	9900      	ldr	r1, [sp, #0]
 8007718:	fa01 f202 	lsl.w	r2, r1, r2
 800771c:	605a      	str	r2, [r3, #4]
 800771e:	4b0c      	ldr	r3, [pc, #48]	; (8007750 <Vector6C+0x60>)
 8007720:	9a01      	ldr	r2, [sp, #4]
 8007722:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007726:	2b00      	cmp	r3, #0
 8007728:	d00b      	beq.n	8007742 <Vector6C+0x52>
 800772a:	4b09      	ldr	r3, [pc, #36]	; (8007750 <Vector6C+0x60>)
 800772c:	9a01      	ldr	r2, [sp, #4]
 800772e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007732:	4907      	ldr	r1, [pc, #28]	; (8007750 <Vector6C+0x60>)
 8007734:	9b01      	ldr	r3, [sp, #4]
 8007736:	00db      	lsls	r3, r3, #3
 8007738:	440b      	add	r3, r1
 800773a:	685b      	ldr	r3, [r3, #4]
 800773c:	4618      	mov	r0, r3
 800773e:	9900      	ldr	r1, [sp, #0]
 8007740:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007742:	f7fc fa05 	bl	8003b50 <_port_irq_epilogue>
}
 8007746:	b003      	add	sp, #12
 8007748:	f85d fb04 	ldr.w	pc, [sp], #4
 800774c:	40020000 	.word	0x40020000
 8007750:	20001d18 	.word	0x20001d18
 8007754:	f3af 8000 	nop.w
 8007758:	f3af 8000 	nop.w
 800775c:	f3af 8000 	nop.w

08007760 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH2_HANDLER) {
 8007760:	b500      	push	{lr}
 8007762:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM2);
 8007764:	2301      	movs	r3, #1
 8007766:	9301      	str	r3, [sp, #4]
 8007768:	4b14      	ldr	r3, [pc, #80]	; (80077bc <Vector70+0x5c>)
 800776a:	681a      	ldr	r2, [r3, #0]
 800776c:	2304      	movs	r3, #4
 800776e:	fa22 f303 	lsr.w	r3, r2, r3
 8007772:	f003 030f 	and.w	r3, r3, #15
 8007776:	9300      	str	r3, [sp, #0]
 8007778:	9b00      	ldr	r3, [sp, #0]
 800777a:	f003 030f 	and.w	r3, r3, #15
 800777e:	2b00      	cmp	r3, #0
 8007780:	d017      	beq.n	80077b2 <Vector70+0x52>
 8007782:	4b0e      	ldr	r3, [pc, #56]	; (80077bc <Vector70+0x5c>)
 8007784:	2204      	movs	r2, #4
 8007786:	9900      	ldr	r1, [sp, #0]
 8007788:	fa01 f202 	lsl.w	r2, r1, r2
 800778c:	605a      	str	r2, [r3, #4]
 800778e:	4b0c      	ldr	r3, [pc, #48]	; (80077c0 <Vector70+0x60>)
 8007790:	9a01      	ldr	r2, [sp, #4]
 8007792:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007796:	2b00      	cmp	r3, #0
 8007798:	d00b      	beq.n	80077b2 <Vector70+0x52>
 800779a:	4b09      	ldr	r3, [pc, #36]	; (80077c0 <Vector70+0x60>)
 800779c:	9a01      	ldr	r2, [sp, #4]
 800779e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80077a2:	4907      	ldr	r1, [pc, #28]	; (80077c0 <Vector70+0x60>)
 80077a4:	9b01      	ldr	r3, [sp, #4]
 80077a6:	00db      	lsls	r3, r3, #3
 80077a8:	440b      	add	r3, r1
 80077aa:	685b      	ldr	r3, [r3, #4]
 80077ac:	4618      	mov	r0, r3
 80077ae:	9900      	ldr	r1, [sp, #0]
 80077b0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80077b2:	f7fc f9cd 	bl	8003b50 <_port_irq_epilogue>
}
 80077b6:	b003      	add	sp, #12
 80077b8:	f85d fb04 	ldr.w	pc, [sp], #4
 80077bc:	40020000 	.word	0x40020000
 80077c0:	20001d18 	.word	0x20001d18
 80077c4:	f3af 8000 	nop.w
 80077c8:	f3af 8000 	nop.w
 80077cc:	f3af 8000 	nop.w

080077d0 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH3_HANDLER) {
 80077d0:	b500      	push	{lr}
 80077d2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM3);
 80077d4:	2302      	movs	r3, #2
 80077d6:	9301      	str	r3, [sp, #4]
 80077d8:	4b14      	ldr	r3, [pc, #80]	; (800782c <Vector74+0x5c>)
 80077da:	681a      	ldr	r2, [r3, #0]
 80077dc:	2308      	movs	r3, #8
 80077de:	fa22 f303 	lsr.w	r3, r2, r3
 80077e2:	f003 030f 	and.w	r3, r3, #15
 80077e6:	9300      	str	r3, [sp, #0]
 80077e8:	9b00      	ldr	r3, [sp, #0]
 80077ea:	f003 030f 	and.w	r3, r3, #15
 80077ee:	2b00      	cmp	r3, #0
 80077f0:	d017      	beq.n	8007822 <Vector74+0x52>
 80077f2:	4b0e      	ldr	r3, [pc, #56]	; (800782c <Vector74+0x5c>)
 80077f4:	2208      	movs	r2, #8
 80077f6:	9900      	ldr	r1, [sp, #0]
 80077f8:	fa01 f202 	lsl.w	r2, r1, r2
 80077fc:	605a      	str	r2, [r3, #4]
 80077fe:	4b0c      	ldr	r3, [pc, #48]	; (8007830 <Vector74+0x60>)
 8007800:	9a01      	ldr	r2, [sp, #4]
 8007802:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007806:	2b00      	cmp	r3, #0
 8007808:	d00b      	beq.n	8007822 <Vector74+0x52>
 800780a:	4b09      	ldr	r3, [pc, #36]	; (8007830 <Vector74+0x60>)
 800780c:	9a01      	ldr	r2, [sp, #4]
 800780e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007812:	4907      	ldr	r1, [pc, #28]	; (8007830 <Vector74+0x60>)
 8007814:	9b01      	ldr	r3, [sp, #4]
 8007816:	00db      	lsls	r3, r3, #3
 8007818:	440b      	add	r3, r1
 800781a:	685b      	ldr	r3, [r3, #4]
 800781c:	4618      	mov	r0, r3
 800781e:	9900      	ldr	r1, [sp, #0]
 8007820:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007822:	f7fc f995 	bl	8003b50 <_port_irq_epilogue>
}
 8007826:	b003      	add	sp, #12
 8007828:	f85d fb04 	ldr.w	pc, [sp], #4
 800782c:	40020000 	.word	0x40020000
 8007830:	20001d18 	.word	0x20001d18
 8007834:	f3af 8000 	nop.w
 8007838:	f3af 8000 	nop.w
 800783c:	f3af 8000 	nop.w

08007840 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH4_HANDLER) {
 8007840:	b500      	push	{lr}
 8007842:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM4);
 8007844:	2303      	movs	r3, #3
 8007846:	9301      	str	r3, [sp, #4]
 8007848:	4b14      	ldr	r3, [pc, #80]	; (800789c <Vector78+0x5c>)
 800784a:	681a      	ldr	r2, [r3, #0]
 800784c:	230c      	movs	r3, #12
 800784e:	fa22 f303 	lsr.w	r3, r2, r3
 8007852:	f003 030f 	and.w	r3, r3, #15
 8007856:	9300      	str	r3, [sp, #0]
 8007858:	9b00      	ldr	r3, [sp, #0]
 800785a:	f003 030f 	and.w	r3, r3, #15
 800785e:	2b00      	cmp	r3, #0
 8007860:	d017      	beq.n	8007892 <Vector78+0x52>
 8007862:	4b0e      	ldr	r3, [pc, #56]	; (800789c <Vector78+0x5c>)
 8007864:	220c      	movs	r2, #12
 8007866:	9900      	ldr	r1, [sp, #0]
 8007868:	fa01 f202 	lsl.w	r2, r1, r2
 800786c:	605a      	str	r2, [r3, #4]
 800786e:	4b0c      	ldr	r3, [pc, #48]	; (80078a0 <Vector78+0x60>)
 8007870:	9a01      	ldr	r2, [sp, #4]
 8007872:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007876:	2b00      	cmp	r3, #0
 8007878:	d00b      	beq.n	8007892 <Vector78+0x52>
 800787a:	4b09      	ldr	r3, [pc, #36]	; (80078a0 <Vector78+0x60>)
 800787c:	9a01      	ldr	r2, [sp, #4]
 800787e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007882:	4907      	ldr	r1, [pc, #28]	; (80078a0 <Vector78+0x60>)
 8007884:	9b01      	ldr	r3, [sp, #4]
 8007886:	00db      	lsls	r3, r3, #3
 8007888:	440b      	add	r3, r1
 800788a:	685b      	ldr	r3, [r3, #4]
 800788c:	4618      	mov	r0, r3
 800788e:	9900      	ldr	r1, [sp, #0]
 8007890:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007892:	f7fc f95d 	bl	8003b50 <_port_irq_epilogue>
}
 8007896:	b003      	add	sp, #12
 8007898:	f85d fb04 	ldr.w	pc, [sp], #4
 800789c:	40020000 	.word	0x40020000
 80078a0:	20001d18 	.word	0x20001d18
 80078a4:	f3af 8000 	nop.w
 80078a8:	f3af 8000 	nop.w
 80078ac:	f3af 8000 	nop.w

080078b0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH5_HANDLER) {
 80078b0:	b500      	push	{lr}
 80078b2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM5);
 80078b4:	2304      	movs	r3, #4
 80078b6:	9301      	str	r3, [sp, #4]
 80078b8:	4b14      	ldr	r3, [pc, #80]	; (800790c <Vector7C+0x5c>)
 80078ba:	681a      	ldr	r2, [r3, #0]
 80078bc:	2310      	movs	r3, #16
 80078be:	fa22 f303 	lsr.w	r3, r2, r3
 80078c2:	f003 030f 	and.w	r3, r3, #15
 80078c6:	9300      	str	r3, [sp, #0]
 80078c8:	9b00      	ldr	r3, [sp, #0]
 80078ca:	f003 030f 	and.w	r3, r3, #15
 80078ce:	2b00      	cmp	r3, #0
 80078d0:	d017      	beq.n	8007902 <Vector7C+0x52>
 80078d2:	4b0e      	ldr	r3, [pc, #56]	; (800790c <Vector7C+0x5c>)
 80078d4:	2210      	movs	r2, #16
 80078d6:	9900      	ldr	r1, [sp, #0]
 80078d8:	fa01 f202 	lsl.w	r2, r1, r2
 80078dc:	605a      	str	r2, [r3, #4]
 80078de:	4b0c      	ldr	r3, [pc, #48]	; (8007910 <Vector7C+0x60>)
 80078e0:	9a01      	ldr	r2, [sp, #4]
 80078e2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80078e6:	2b00      	cmp	r3, #0
 80078e8:	d00b      	beq.n	8007902 <Vector7C+0x52>
 80078ea:	4b09      	ldr	r3, [pc, #36]	; (8007910 <Vector7C+0x60>)
 80078ec:	9a01      	ldr	r2, [sp, #4]
 80078ee:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80078f2:	4907      	ldr	r1, [pc, #28]	; (8007910 <Vector7C+0x60>)
 80078f4:	9b01      	ldr	r3, [sp, #4]
 80078f6:	00db      	lsls	r3, r3, #3
 80078f8:	440b      	add	r3, r1
 80078fa:	685b      	ldr	r3, [r3, #4]
 80078fc:	4618      	mov	r0, r3
 80078fe:	9900      	ldr	r1, [sp, #0]
 8007900:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007902:	f7fc f925 	bl	8003b50 <_port_irq_epilogue>
}
 8007906:	b003      	add	sp, #12
 8007908:	f85d fb04 	ldr.w	pc, [sp], #4
 800790c:	40020000 	.word	0x40020000
 8007910:	20001d18 	.word	0x20001d18
 8007914:	f3af 8000 	nop.w
 8007918:	f3af 8000 	nop.w
 800791c:	f3af 8000 	nop.w

08007920 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH6_HANDLER) {
 8007920:	b500      	push	{lr}
 8007922:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM6);
 8007924:	2305      	movs	r3, #5
 8007926:	9301      	str	r3, [sp, #4]
 8007928:	4b14      	ldr	r3, [pc, #80]	; (800797c <Vector80+0x5c>)
 800792a:	681a      	ldr	r2, [r3, #0]
 800792c:	2314      	movs	r3, #20
 800792e:	fa22 f303 	lsr.w	r3, r2, r3
 8007932:	f003 030f 	and.w	r3, r3, #15
 8007936:	9300      	str	r3, [sp, #0]
 8007938:	9b00      	ldr	r3, [sp, #0]
 800793a:	f003 030f 	and.w	r3, r3, #15
 800793e:	2b00      	cmp	r3, #0
 8007940:	d017      	beq.n	8007972 <Vector80+0x52>
 8007942:	4b0e      	ldr	r3, [pc, #56]	; (800797c <Vector80+0x5c>)
 8007944:	2214      	movs	r2, #20
 8007946:	9900      	ldr	r1, [sp, #0]
 8007948:	fa01 f202 	lsl.w	r2, r1, r2
 800794c:	605a      	str	r2, [r3, #4]
 800794e:	4b0c      	ldr	r3, [pc, #48]	; (8007980 <Vector80+0x60>)
 8007950:	9a01      	ldr	r2, [sp, #4]
 8007952:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007956:	2b00      	cmp	r3, #0
 8007958:	d00b      	beq.n	8007972 <Vector80+0x52>
 800795a:	4b09      	ldr	r3, [pc, #36]	; (8007980 <Vector80+0x60>)
 800795c:	9a01      	ldr	r2, [sp, #4]
 800795e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007962:	4907      	ldr	r1, [pc, #28]	; (8007980 <Vector80+0x60>)
 8007964:	9b01      	ldr	r3, [sp, #4]
 8007966:	00db      	lsls	r3, r3, #3
 8007968:	440b      	add	r3, r1
 800796a:	685b      	ldr	r3, [r3, #4]
 800796c:	4618      	mov	r0, r3
 800796e:	9900      	ldr	r1, [sp, #0]
 8007970:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007972:	f7fc f8ed 	bl	8003b50 <_port_irq_epilogue>
}
 8007976:	b003      	add	sp, #12
 8007978:	f85d fb04 	ldr.w	pc, [sp], #4
 800797c:	40020000 	.word	0x40020000
 8007980:	20001d18 	.word	0x20001d18
 8007984:	f3af 8000 	nop.w
 8007988:	f3af 8000 	nop.w
 800798c:	f3af 8000 	nop.w

08007990 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA1_CH7_HANDLER) {
 8007990:	b500      	push	{lr}
 8007992:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA1_STREAM7);
 8007994:	2306      	movs	r3, #6
 8007996:	9301      	str	r3, [sp, #4]
 8007998:	4b14      	ldr	r3, [pc, #80]	; (80079ec <Vector84+0x5c>)
 800799a:	681a      	ldr	r2, [r3, #0]
 800799c:	2318      	movs	r3, #24
 800799e:	fa22 f303 	lsr.w	r3, r2, r3
 80079a2:	f003 030f 	and.w	r3, r3, #15
 80079a6:	9300      	str	r3, [sp, #0]
 80079a8:	9b00      	ldr	r3, [sp, #0]
 80079aa:	f003 030f 	and.w	r3, r3, #15
 80079ae:	2b00      	cmp	r3, #0
 80079b0:	d017      	beq.n	80079e2 <Vector84+0x52>
 80079b2:	4b0e      	ldr	r3, [pc, #56]	; (80079ec <Vector84+0x5c>)
 80079b4:	2218      	movs	r2, #24
 80079b6:	9900      	ldr	r1, [sp, #0]
 80079b8:	fa01 f202 	lsl.w	r2, r1, r2
 80079bc:	605a      	str	r2, [r3, #4]
 80079be:	4b0c      	ldr	r3, [pc, #48]	; (80079f0 <Vector84+0x60>)
 80079c0:	9a01      	ldr	r2, [sp, #4]
 80079c2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 80079c6:	2b00      	cmp	r3, #0
 80079c8:	d00b      	beq.n	80079e2 <Vector84+0x52>
 80079ca:	4b09      	ldr	r3, [pc, #36]	; (80079f0 <Vector84+0x60>)
 80079cc:	9a01      	ldr	r2, [sp, #4]
 80079ce:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 80079d2:	4907      	ldr	r1, [pc, #28]	; (80079f0 <Vector84+0x60>)
 80079d4:	9b01      	ldr	r3, [sp, #4]
 80079d6:	00db      	lsls	r3, r3, #3
 80079d8:	440b      	add	r3, r1
 80079da:	685b      	ldr	r3, [r3, #4]
 80079dc:	4618      	mov	r0, r3
 80079de:	9900      	ldr	r1, [sp, #0]
 80079e0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 80079e2:	f7fc f8b5 	bl	8003b50 <_port_irq_epilogue>
}
 80079e6:	b003      	add	sp, #12
 80079e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80079ec:	40020000 	.word	0x40020000
 80079f0:	20001d18 	.word	0x20001d18
 80079f4:	f3af 8000 	nop.w
 80079f8:	f3af 8000 	nop.w
 80079fc:	f3af 8000 	nop.w

08007a00 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH1_HANDLER) {
 8007a00:	b500      	push	{lr}
 8007a02:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM1);
 8007a04:	2307      	movs	r3, #7
 8007a06:	9301      	str	r3, [sp, #4]
 8007a08:	4b14      	ldr	r3, [pc, #80]	; (8007a5c <Vector120+0x5c>)
 8007a0a:	681a      	ldr	r2, [r3, #0]
 8007a0c:	2300      	movs	r3, #0
 8007a0e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a12:	f003 030f 	and.w	r3, r3, #15
 8007a16:	9300      	str	r3, [sp, #0]
 8007a18:	9b00      	ldr	r3, [sp, #0]
 8007a1a:	f003 030f 	and.w	r3, r3, #15
 8007a1e:	2b00      	cmp	r3, #0
 8007a20:	d017      	beq.n	8007a52 <Vector120+0x52>
 8007a22:	4b0e      	ldr	r3, [pc, #56]	; (8007a5c <Vector120+0x5c>)
 8007a24:	2200      	movs	r2, #0
 8007a26:	9900      	ldr	r1, [sp, #0]
 8007a28:	fa01 f202 	lsl.w	r2, r1, r2
 8007a2c:	605a      	str	r2, [r3, #4]
 8007a2e:	4b0c      	ldr	r3, [pc, #48]	; (8007a60 <Vector120+0x60>)
 8007a30:	9a01      	ldr	r2, [sp, #4]
 8007a32:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007a36:	2b00      	cmp	r3, #0
 8007a38:	d00b      	beq.n	8007a52 <Vector120+0x52>
 8007a3a:	4b09      	ldr	r3, [pc, #36]	; (8007a60 <Vector120+0x60>)
 8007a3c:	9a01      	ldr	r2, [sp, #4]
 8007a3e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007a42:	4907      	ldr	r1, [pc, #28]	; (8007a60 <Vector120+0x60>)
 8007a44:	9b01      	ldr	r3, [sp, #4]
 8007a46:	00db      	lsls	r3, r3, #3
 8007a48:	440b      	add	r3, r1
 8007a4a:	685b      	ldr	r3, [r3, #4]
 8007a4c:	4618      	mov	r0, r3
 8007a4e:	9900      	ldr	r1, [sp, #0]
 8007a50:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007a52:	f7fc f87d 	bl	8003b50 <_port_irq_epilogue>
}
 8007a56:	b003      	add	sp, #12
 8007a58:	f85d fb04 	ldr.w	pc, [sp], #4
 8007a5c:	40020400 	.word	0x40020400
 8007a60:	20001d18 	.word	0x20001d18
 8007a64:	f3af 8000 	nop.w
 8007a68:	f3af 8000 	nop.w
 8007a6c:	f3af 8000 	nop.w

08007a70 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH2_HANDLER) {
 8007a70:	b500      	push	{lr}
 8007a72:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM2);
 8007a74:	2308      	movs	r3, #8
 8007a76:	9301      	str	r3, [sp, #4]
 8007a78:	4b14      	ldr	r3, [pc, #80]	; (8007acc <Vector124+0x5c>)
 8007a7a:	681a      	ldr	r2, [r3, #0]
 8007a7c:	2304      	movs	r3, #4
 8007a7e:	fa22 f303 	lsr.w	r3, r2, r3
 8007a82:	f003 030f 	and.w	r3, r3, #15
 8007a86:	9300      	str	r3, [sp, #0]
 8007a88:	9b00      	ldr	r3, [sp, #0]
 8007a8a:	f003 030f 	and.w	r3, r3, #15
 8007a8e:	2b00      	cmp	r3, #0
 8007a90:	d017      	beq.n	8007ac2 <Vector124+0x52>
 8007a92:	4b0e      	ldr	r3, [pc, #56]	; (8007acc <Vector124+0x5c>)
 8007a94:	2204      	movs	r2, #4
 8007a96:	9900      	ldr	r1, [sp, #0]
 8007a98:	fa01 f202 	lsl.w	r2, r1, r2
 8007a9c:	605a      	str	r2, [r3, #4]
 8007a9e:	4b0c      	ldr	r3, [pc, #48]	; (8007ad0 <Vector124+0x60>)
 8007aa0:	9a01      	ldr	r2, [sp, #4]
 8007aa2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007aa6:	2b00      	cmp	r3, #0
 8007aa8:	d00b      	beq.n	8007ac2 <Vector124+0x52>
 8007aaa:	4b09      	ldr	r3, [pc, #36]	; (8007ad0 <Vector124+0x60>)
 8007aac:	9a01      	ldr	r2, [sp, #4]
 8007aae:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ab2:	4907      	ldr	r1, [pc, #28]	; (8007ad0 <Vector124+0x60>)
 8007ab4:	9b01      	ldr	r3, [sp, #4]
 8007ab6:	00db      	lsls	r3, r3, #3
 8007ab8:	440b      	add	r3, r1
 8007aba:	685b      	ldr	r3, [r3, #4]
 8007abc:	4618      	mov	r0, r3
 8007abe:	9900      	ldr	r1, [sp, #0]
 8007ac0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ac2:	f7fc f845 	bl	8003b50 <_port_irq_epilogue>
}
 8007ac6:	b003      	add	sp, #12
 8007ac8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007acc:	40020400 	.word	0x40020400
 8007ad0:	20001d18 	.word	0x20001d18
 8007ad4:	f3af 8000 	nop.w
 8007ad8:	f3af 8000 	nop.w
 8007adc:	f3af 8000 	nop.w

08007ae0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH3_HANDLER) {
 8007ae0:	b500      	push	{lr}
 8007ae2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM3);
 8007ae4:	2309      	movs	r3, #9
 8007ae6:	9301      	str	r3, [sp, #4]
 8007ae8:	4b14      	ldr	r3, [pc, #80]	; (8007b3c <Vector128+0x5c>)
 8007aea:	681a      	ldr	r2, [r3, #0]
 8007aec:	2308      	movs	r3, #8
 8007aee:	fa22 f303 	lsr.w	r3, r2, r3
 8007af2:	f003 030f 	and.w	r3, r3, #15
 8007af6:	9300      	str	r3, [sp, #0]
 8007af8:	9b00      	ldr	r3, [sp, #0]
 8007afa:	f003 030f 	and.w	r3, r3, #15
 8007afe:	2b00      	cmp	r3, #0
 8007b00:	d017      	beq.n	8007b32 <Vector128+0x52>
 8007b02:	4b0e      	ldr	r3, [pc, #56]	; (8007b3c <Vector128+0x5c>)
 8007b04:	2208      	movs	r2, #8
 8007b06:	9900      	ldr	r1, [sp, #0]
 8007b08:	fa01 f202 	lsl.w	r2, r1, r2
 8007b0c:	605a      	str	r2, [r3, #4]
 8007b0e:	4b0c      	ldr	r3, [pc, #48]	; (8007b40 <Vector128+0x60>)
 8007b10:	9a01      	ldr	r2, [sp, #4]
 8007b12:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b16:	2b00      	cmp	r3, #0
 8007b18:	d00b      	beq.n	8007b32 <Vector128+0x52>
 8007b1a:	4b09      	ldr	r3, [pc, #36]	; (8007b40 <Vector128+0x60>)
 8007b1c:	9a01      	ldr	r2, [sp, #4]
 8007b1e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b22:	4907      	ldr	r1, [pc, #28]	; (8007b40 <Vector128+0x60>)
 8007b24:	9b01      	ldr	r3, [sp, #4]
 8007b26:	00db      	lsls	r3, r3, #3
 8007b28:	440b      	add	r3, r1
 8007b2a:	685b      	ldr	r3, [r3, #4]
 8007b2c:	4618      	mov	r0, r3
 8007b2e:	9900      	ldr	r1, [sp, #0]
 8007b30:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007b32:	f7fc f80d 	bl	8003b50 <_port_irq_epilogue>
}
 8007b36:	b003      	add	sp, #12
 8007b38:	f85d fb04 	ldr.w	pc, [sp], #4
 8007b3c:	40020400 	.word	0x40020400
 8007b40:	20001d18 	.word	0x20001d18
 8007b44:	f3af 8000 	nop.w
 8007b48:	f3af 8000 	nop.w
 8007b4c:	f3af 8000 	nop.w

08007b50 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH4_HANDLER) {
 8007b50:	b500      	push	{lr}
 8007b52:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM4);
 8007b54:	230a      	movs	r3, #10
 8007b56:	9301      	str	r3, [sp, #4]
 8007b58:	4b14      	ldr	r3, [pc, #80]	; (8007bac <Vector12C+0x5c>)
 8007b5a:	681a      	ldr	r2, [r3, #0]
 8007b5c:	230c      	movs	r3, #12
 8007b5e:	fa22 f303 	lsr.w	r3, r2, r3
 8007b62:	f003 030f 	and.w	r3, r3, #15
 8007b66:	9300      	str	r3, [sp, #0]
 8007b68:	9b00      	ldr	r3, [sp, #0]
 8007b6a:	f003 030f 	and.w	r3, r3, #15
 8007b6e:	2b00      	cmp	r3, #0
 8007b70:	d017      	beq.n	8007ba2 <Vector12C+0x52>
 8007b72:	4b0e      	ldr	r3, [pc, #56]	; (8007bac <Vector12C+0x5c>)
 8007b74:	220c      	movs	r2, #12
 8007b76:	9900      	ldr	r1, [sp, #0]
 8007b78:	fa01 f202 	lsl.w	r2, r1, r2
 8007b7c:	605a      	str	r2, [r3, #4]
 8007b7e:	4b0c      	ldr	r3, [pc, #48]	; (8007bb0 <Vector12C+0x60>)
 8007b80:	9a01      	ldr	r2, [sp, #4]
 8007b82:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007b86:	2b00      	cmp	r3, #0
 8007b88:	d00b      	beq.n	8007ba2 <Vector12C+0x52>
 8007b8a:	4b09      	ldr	r3, [pc, #36]	; (8007bb0 <Vector12C+0x60>)
 8007b8c:	9a01      	ldr	r2, [sp, #4]
 8007b8e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007b92:	4907      	ldr	r1, [pc, #28]	; (8007bb0 <Vector12C+0x60>)
 8007b94:	9b01      	ldr	r3, [sp, #4]
 8007b96:	00db      	lsls	r3, r3, #3
 8007b98:	440b      	add	r3, r1
 8007b9a:	685b      	ldr	r3, [r3, #4]
 8007b9c:	4618      	mov	r0, r3
 8007b9e:	9900      	ldr	r1, [sp, #0]
 8007ba0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007ba2:	f7fb ffd5 	bl	8003b50 <_port_irq_epilogue>
}
 8007ba6:	b003      	add	sp, #12
 8007ba8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007bac:	40020400 	.word	0x40020400
 8007bb0:	20001d18 	.word	0x20001d18
 8007bb4:	f3af 8000 	nop.w
 8007bb8:	f3af 8000 	nop.w
 8007bbc:	f3af 8000 	nop.w

08007bc0 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH5_HANDLER) {
 8007bc0:	b500      	push	{lr}
 8007bc2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM5);
 8007bc4:	230b      	movs	r3, #11
 8007bc6:	9301      	str	r3, [sp, #4]
 8007bc8:	4b14      	ldr	r3, [pc, #80]	; (8007c1c <Vector130+0x5c>)
 8007bca:	681a      	ldr	r2, [r3, #0]
 8007bcc:	2310      	movs	r3, #16
 8007bce:	fa22 f303 	lsr.w	r3, r2, r3
 8007bd2:	f003 030f 	and.w	r3, r3, #15
 8007bd6:	9300      	str	r3, [sp, #0]
 8007bd8:	9b00      	ldr	r3, [sp, #0]
 8007bda:	f003 030f 	and.w	r3, r3, #15
 8007bde:	2b00      	cmp	r3, #0
 8007be0:	d017      	beq.n	8007c12 <Vector130+0x52>
 8007be2:	4b0e      	ldr	r3, [pc, #56]	; (8007c1c <Vector130+0x5c>)
 8007be4:	2210      	movs	r2, #16
 8007be6:	9900      	ldr	r1, [sp, #0]
 8007be8:	fa01 f202 	lsl.w	r2, r1, r2
 8007bec:	605a      	str	r2, [r3, #4]
 8007bee:	4b0c      	ldr	r3, [pc, #48]	; (8007c20 <Vector130+0x60>)
 8007bf0:	9a01      	ldr	r2, [sp, #4]
 8007bf2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007bf6:	2b00      	cmp	r3, #0
 8007bf8:	d00b      	beq.n	8007c12 <Vector130+0x52>
 8007bfa:	4b09      	ldr	r3, [pc, #36]	; (8007c20 <Vector130+0x60>)
 8007bfc:	9a01      	ldr	r2, [sp, #4]
 8007bfe:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c02:	4907      	ldr	r1, [pc, #28]	; (8007c20 <Vector130+0x60>)
 8007c04:	9b01      	ldr	r3, [sp, #4]
 8007c06:	00db      	lsls	r3, r3, #3
 8007c08:	440b      	add	r3, r1
 8007c0a:	685b      	ldr	r3, [r3, #4]
 8007c0c:	4618      	mov	r0, r3
 8007c0e:	9900      	ldr	r1, [sp, #0]
 8007c10:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c12:	f7fb ff9d 	bl	8003b50 <_port_irq_epilogue>
}
 8007c16:	b003      	add	sp, #12
 8007c18:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c1c:	40020400 	.word	0x40020400
 8007c20:	20001d18 	.word	0x20001d18
 8007c24:	f3af 8000 	nop.w
 8007c28:	f3af 8000 	nop.w
 8007c2c:	f3af 8000 	nop.w

08007c30 <Vector150>:
/**
 * @brief   DMA2 stream 6 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH6_HANDLER) {
 8007c30:	b500      	push	{lr}
 8007c32:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM6);
 8007c34:	230c      	movs	r3, #12
 8007c36:	9301      	str	r3, [sp, #4]
 8007c38:	4b14      	ldr	r3, [pc, #80]	; (8007c8c <Vector150+0x5c>)
 8007c3a:	681a      	ldr	r2, [r3, #0]
 8007c3c:	2314      	movs	r3, #20
 8007c3e:	fa22 f303 	lsr.w	r3, r2, r3
 8007c42:	f003 030f 	and.w	r3, r3, #15
 8007c46:	9300      	str	r3, [sp, #0]
 8007c48:	9b00      	ldr	r3, [sp, #0]
 8007c4a:	f003 030f 	and.w	r3, r3, #15
 8007c4e:	2b00      	cmp	r3, #0
 8007c50:	d017      	beq.n	8007c82 <Vector150+0x52>
 8007c52:	4b0e      	ldr	r3, [pc, #56]	; (8007c8c <Vector150+0x5c>)
 8007c54:	2214      	movs	r2, #20
 8007c56:	9900      	ldr	r1, [sp, #0]
 8007c58:	fa01 f202 	lsl.w	r2, r1, r2
 8007c5c:	605a      	str	r2, [r3, #4]
 8007c5e:	4b0c      	ldr	r3, [pc, #48]	; (8007c90 <Vector150+0x60>)
 8007c60:	9a01      	ldr	r2, [sp, #4]
 8007c62:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007c66:	2b00      	cmp	r3, #0
 8007c68:	d00b      	beq.n	8007c82 <Vector150+0x52>
 8007c6a:	4b09      	ldr	r3, [pc, #36]	; (8007c90 <Vector150+0x60>)
 8007c6c:	9a01      	ldr	r2, [sp, #4]
 8007c6e:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007c72:	4907      	ldr	r1, [pc, #28]	; (8007c90 <Vector150+0x60>)
 8007c74:	9b01      	ldr	r3, [sp, #4]
 8007c76:	00db      	lsls	r3, r3, #3
 8007c78:	440b      	add	r3, r1
 8007c7a:	685b      	ldr	r3, [r3, #4]
 8007c7c:	4618      	mov	r0, r3
 8007c7e:	9900      	ldr	r1, [sp, #0]
 8007c80:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007c82:	f7fb ff65 	bl	8003b50 <_port_irq_epilogue>
}
 8007c86:	b003      	add	sp, #12
 8007c88:	f85d fb04 	ldr.w	pc, [sp], #4
 8007c8c:	40020400 	.word	0x40020400
 8007c90:	20001d18 	.word	0x20001d18
 8007c94:	f3af 8000 	nop.w
 8007c98:	f3af 8000 	nop.w
 8007c9c:	f3af 8000 	nop.w

08007ca0 <Vector154>:
/**
 * @brief   DMA2 stream 7 shared ISR.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_DMA2_CH7_HANDLER) {
 8007ca0:	b500      	push	{lr}
 8007ca2:	b083      	sub	sp, #12

  OSAL_IRQ_PROLOGUE();

  dmaServeInterrupt(STM32_DMA2_STREAM7);
 8007ca4:	230d      	movs	r3, #13
 8007ca6:	9301      	str	r3, [sp, #4]
 8007ca8:	4b14      	ldr	r3, [pc, #80]	; (8007cfc <Vector154+0x5c>)
 8007caa:	681a      	ldr	r2, [r3, #0]
 8007cac:	2318      	movs	r3, #24
 8007cae:	fa22 f303 	lsr.w	r3, r2, r3
 8007cb2:	f003 030f 	and.w	r3, r3, #15
 8007cb6:	9300      	str	r3, [sp, #0]
 8007cb8:	9b00      	ldr	r3, [sp, #0]
 8007cba:	f003 030f 	and.w	r3, r3, #15
 8007cbe:	2b00      	cmp	r3, #0
 8007cc0:	d017      	beq.n	8007cf2 <Vector154+0x52>
 8007cc2:	4b0e      	ldr	r3, [pc, #56]	; (8007cfc <Vector154+0x5c>)
 8007cc4:	2218      	movs	r2, #24
 8007cc6:	9900      	ldr	r1, [sp, #0]
 8007cc8:	fa01 f202 	lsl.w	r2, r1, r2
 8007ccc:	605a      	str	r2, [r3, #4]
 8007cce:	4b0c      	ldr	r3, [pc, #48]	; (8007d00 <Vector154+0x60>)
 8007cd0:	9a01      	ldr	r2, [sp, #4]
 8007cd2:	f853 3032 	ldr.w	r3, [r3, r2, lsl #3]
 8007cd6:	2b00      	cmp	r3, #0
 8007cd8:	d00b      	beq.n	8007cf2 <Vector154+0x52>
 8007cda:	4b09      	ldr	r3, [pc, #36]	; (8007d00 <Vector154+0x60>)
 8007cdc:	9a01      	ldr	r2, [sp, #4]
 8007cde:	f853 2032 	ldr.w	r2, [r3, r2, lsl #3]
 8007ce2:	4907      	ldr	r1, [pc, #28]	; (8007d00 <Vector154+0x60>)
 8007ce4:	9b01      	ldr	r3, [sp, #4]
 8007ce6:	00db      	lsls	r3, r3, #3
 8007ce8:	440b      	add	r3, r1
 8007cea:	685b      	ldr	r3, [r3, #4]
 8007cec:	4618      	mov	r0, r3
 8007cee:	9900      	ldr	r1, [sp, #0]
 8007cf0:	4790      	blx	r2

  OSAL_IRQ_EPILOGUE();
 8007cf2:	f7fb ff2d 	bl	8003b50 <_port_irq_epilogue>
}
 8007cf6:	b003      	add	sp, #12
 8007cf8:	f85d fb04 	ldr.w	pc, [sp], #4
 8007cfc:	40020400 	.word	0x40020400
 8007d00:	20001d18 	.word	0x20001d18
 8007d04:	f3af 8000 	nop.w
 8007d08:	f3af 8000 	nop.w
 8007d0c:	f3af 8000 	nop.w

08007d10 <dmaInit>:
/**
 * @brief   STM32 DMA helper initialization.
 *
 * @init
 */
void dmaInit(void) {
 8007d10:	b082      	sub	sp, #8
  int i;

  dma_streams_mask = 0U;
 8007d12:	4b12      	ldr	r3, [pc, #72]	; (8007d5c <dmaInit+0x4c>)
 8007d14:	2200      	movs	r2, #0
 8007d16:	601a      	str	r2, [r3, #0]
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d18:	2300      	movs	r3, #0
 8007d1a:	9301      	str	r3, [sp, #4]
 8007d1c:	e011      	b.n	8007d42 <dmaInit+0x32>
    _stm32_dma_streams[i].channel->CCR = 0U;
 8007d1e:	4910      	ldr	r1, [pc, #64]	; (8007d60 <dmaInit+0x50>)
 8007d20:	9a01      	ldr	r2, [sp, #4]
 8007d22:	4613      	mov	r3, r2
 8007d24:	009b      	lsls	r3, r3, #2
 8007d26:	4413      	add	r3, r2
 8007d28:	009b      	lsls	r3, r3, #2
 8007d2a:	440b      	add	r3, r1
 8007d2c:	685b      	ldr	r3, [r3, #4]
 8007d2e:	2200      	movs	r2, #0
 8007d30:	601a      	str	r2, [r3, #0]
    _stm32_dma_isr_redir[i].dma_func = NULL;
 8007d32:	4b0c      	ldr	r3, [pc, #48]	; (8007d64 <dmaInit+0x54>)
 8007d34:	9a01      	ldr	r2, [sp, #4]
 8007d36:	2100      	movs	r1, #0
 8007d38:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0U;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8007d3c:	9b01      	ldr	r3, [sp, #4]
 8007d3e:	3301      	adds	r3, #1
 8007d40:	9301      	str	r3, [sp, #4]
 8007d42:	9b01      	ldr	r3, [sp, #4]
 8007d44:	2b0d      	cmp	r3, #13
 8007d46:	ddea      	ble.n	8007d1e <dmaInit+0xe>
    _stm32_dma_streams[i].channel->CCR = 0U;
    _stm32_dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFFU;
 8007d48:	4b07      	ldr	r3, [pc, #28]	; (8007d68 <dmaInit+0x58>)
 8007d4a:	f04f 32ff 	mov.w	r2, #4294967295
 8007d4e:	605a      	str	r2, [r3, #4]
#if STM32_DMA2_NUM_CHANNELS > 0
  DMA2->IFCR = 0xFFFFFFFFU;
 8007d50:	4b06      	ldr	r3, [pc, #24]	; (8007d6c <dmaInit+0x5c>)
 8007d52:	f04f 32ff 	mov.w	r2, #4294967295
 8007d56:	605a      	str	r2, [r3, #4]
#endif
}
 8007d58:	b002      	add	sp, #8
 8007d5a:	4770      	bx	lr
 8007d5c:	200011b0 	.word	0x200011b0
 8007d60:	080194a0 	.word	0x080194a0
 8007d64:	20001d18 	.word	0x20001d18
 8007d68:	40020000 	.word	0x40020000
 8007d6c:	40020400 	.word	0x40020400

08007d70 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8007d70:	b500      	push	{lr}
 8007d72:	b085      	sub	sp, #20
 8007d74:	9003      	str	r0, [sp, #12]
 8007d76:	9102      	str	r1, [sp, #8]
 8007d78:	9201      	str	r2, [sp, #4]
 8007d7a:	9300      	str	r3, [sp, #0]

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1U << dmastp->selfindex)) != 0U)
 8007d7c:	9b03      	ldr	r3, [sp, #12]
 8007d7e:	7c5b      	ldrb	r3, [r3, #17]
 8007d80:	2201      	movs	r2, #1
 8007d82:	409a      	lsls	r2, r3
 8007d84:	4b2f      	ldr	r3, [pc, #188]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007d86:	681b      	ldr	r3, [r3, #0]
 8007d88:	4013      	ands	r3, r2
 8007d8a:	2b00      	cmp	r3, #0
 8007d8c:	d001      	beq.n	8007d92 <dmaStreamAllocate+0x22>
    return true;
 8007d8e:	2301      	movs	r3, #1
 8007d90:	e053      	b.n	8007e3a <dmaStreamAllocate+0xca>

  /* Installs the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8007d92:	9b03      	ldr	r3, [sp, #12]
 8007d94:	7c5b      	ldrb	r3, [r3, #17]
 8007d96:	461a      	mov	r2, r3
 8007d98:	4b2b      	ldr	r3, [pc, #172]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007d9a:	9901      	ldr	r1, [sp, #4]
 8007d9c:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = param;
 8007da0:	9b03      	ldr	r3, [sp, #12]
 8007da2:	7c5b      	ldrb	r3, [r3, #17]
 8007da4:	4a28      	ldr	r2, [pc, #160]	; (8007e48 <dmaStreamAllocate+0xd8>)
 8007da6:	00db      	lsls	r3, r3, #3
 8007da8:	4413      	add	r3, r2
 8007daa:	9a00      	ldr	r2, [sp, #0]
 8007dac:	605a      	str	r2, [r3, #4]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007dae:	4b25      	ldr	r3, [pc, #148]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007db0:	681b      	ldr	r3, [r3, #0]
 8007db2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007db6:	2b00      	cmp	r3, #0
 8007db8:	d105      	bne.n	8007dc6 <dmaStreamAllocate+0x56>
    rccEnableDMA1(false);
 8007dba:	4b24      	ldr	r3, [pc, #144]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbc:	4a23      	ldr	r2, [pc, #140]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dbe:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dc0:	f042 0201 	orr.w	r2, r2, #1
 8007dc4:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007dc6:	4b1f      	ldr	r3, [pc, #124]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007dc8:	681b      	ldr	r3, [r3, #0]
 8007dca:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007dce:	2b00      	cmp	r3, #0
 8007dd0:	d105      	bne.n	8007dde <dmaStreamAllocate+0x6e>
    rccEnableDMA2(false);
 8007dd2:	4b1e      	ldr	r3, [pc, #120]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd4:	4a1d      	ldr	r2, [pc, #116]	; (8007e4c <dmaStreamAllocate+0xdc>)
 8007dd6:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007dd8:	f042 0202 	orr.w	r2, r2, #2
 8007ddc:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8007dde:	9b03      	ldr	r3, [sp, #12]
 8007de0:	685b      	ldr	r3, [r3, #4]
 8007de2:	9a03      	ldr	r2, [sp, #12]
 8007de4:	6852      	ldr	r2, [r2, #4]
 8007de6:	6812      	ldr	r2, [r2, #0]
 8007de8:	f022 020f 	bic.w	r2, r2, #15
 8007dec:	601a      	str	r2, [r3, #0]
 8007dee:	9b03      	ldr	r3, [sp, #12]
 8007df0:	681b      	ldr	r3, [r3, #0]
 8007df2:	9a03      	ldr	r2, [sp, #12]
 8007df4:	7c12      	ldrb	r2, [r2, #16]
 8007df6:	210f      	movs	r1, #15
 8007df8:	fa01 f202 	lsl.w	r2, r1, r2
 8007dfc:	605a      	str	r2, [r3, #4]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 8007dfe:	9b03      	ldr	r3, [sp, #12]
 8007e00:	685b      	ldr	r3, [r3, #4]
 8007e02:	2200      	movs	r2, #0
 8007e04:	601a      	str	r2, [r3, #0]

  /* Enables the associated IRQ vector if not alread enabled and if a
     callback is defined.*/
  if (((dma_streams_mask & dmastp->cmask) == 0U) &&
 8007e06:	9b03      	ldr	r3, [sp, #12]
 8007e08:	689a      	ldr	r2, [r3, #8]
 8007e0a:	4b0e      	ldr	r3, [pc, #56]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e0c:	681b      	ldr	r3, [r3, #0]
 8007e0e:	4013      	ands	r3, r2
 8007e10:	2b00      	cmp	r3, #0
 8007e12:	d108      	bne.n	8007e26 <dmaStreamAllocate+0xb6>
 8007e14:	9b01      	ldr	r3, [sp, #4]
 8007e16:	2b00      	cmp	r3, #0
 8007e18:	d005      	beq.n	8007e26 <dmaStreamAllocate+0xb6>
      (func != NULL)) {
    nvicEnableVector(dmastp->vector, priority);
 8007e1a:	9b03      	ldr	r3, [sp, #12]
 8007e1c:	7c9b      	ldrb	r3, [r3, #18]
 8007e1e:	4618      	mov	r0, r3
 8007e20:	9902      	ldr	r1, [sp, #8]
 8007e22:	f7ff fa85 	bl	8007330 <nvicEnableVector>
  }

  /* Marks the stream as allocated.*/
  dma_streams_mask |= (1U << dmastp->selfindex);
 8007e26:	9b03      	ldr	r3, [sp, #12]
 8007e28:	7c5b      	ldrb	r3, [r3, #17]
 8007e2a:	2201      	movs	r2, #1
 8007e2c:	409a      	lsls	r2, r3
 8007e2e:	4b05      	ldr	r3, [pc, #20]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e30:	681b      	ldr	r3, [r3, #0]
 8007e32:	431a      	orrs	r2, r3
 8007e34:	4b03      	ldr	r3, [pc, #12]	; (8007e44 <dmaStreamAllocate+0xd4>)
 8007e36:	601a      	str	r2, [r3, #0]

  return false;
 8007e38:	2300      	movs	r3, #0
}
 8007e3a:	4618      	mov	r0, r3
 8007e3c:	b005      	add	sp, #20
 8007e3e:	f85d fb04 	ldr.w	pc, [sp], #4
 8007e42:	bf00      	nop
 8007e44:	200011b0 	.word	0x200011b0
 8007e48:	20001d18 	.word	0x20001d18
 8007e4c:	40021000 	.word	0x40021000

08007e50 <dmaStreamRelease>:
 *
 * @param[in] dmastp    pointer to a stm32_dma_stream_t structure
 *
 * @special
 */
void dmaStreamRelease(const stm32_dma_stream_t *dmastp) {
 8007e50:	b500      	push	{lr}
 8007e52:	b083      	sub	sp, #12
 8007e54:	9001      	str	r0, [sp, #4]
  /* Check if the streams is not taken.*/
  osalDbgAssert((dma_streams_mask & (1 << dmastp->selfindex)) != 0U,
                "not allocated");

  /* Marks the stream as not allocated.*/
  dma_streams_mask &= ~(1U << dmastp->selfindex);
 8007e56:	9b01      	ldr	r3, [sp, #4]
 8007e58:	7c5b      	ldrb	r3, [r3, #17]
 8007e5a:	2201      	movs	r2, #1
 8007e5c:	fa02 f303 	lsl.w	r3, r2, r3
 8007e60:	43da      	mvns	r2, r3
 8007e62:	4b1d      	ldr	r3, [pc, #116]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e64:	681b      	ldr	r3, [r3, #0]
 8007e66:	401a      	ands	r2, r3
 8007e68:	4b1b      	ldr	r3, [pc, #108]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e6a:	601a      	str	r2, [r3, #0]

  /* Disables the associated IRQ vector if it is no more in use.*/
  if ((dma_streams_mask & dmastp->cmask) == 0U) {
 8007e6c:	9b01      	ldr	r3, [sp, #4]
 8007e6e:	689a      	ldr	r2, [r3, #8]
 8007e70:	4b19      	ldr	r3, [pc, #100]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007e72:	681b      	ldr	r3, [r3, #0]
 8007e74:	4013      	ands	r3, r2
 8007e76:	2b00      	cmp	r3, #0
 8007e78:	d104      	bne.n	8007e84 <dmaStreamRelease+0x34>
    nvicDisableVector(dmastp->vector);
 8007e7a:	9b01      	ldr	r3, [sp, #4]
 8007e7c:	7c9b      	ldrb	r3, [r3, #18]
 8007e7e:	4618      	mov	r0, r3
 8007e80:	f7ff fa7e 	bl	8007380 <nvicDisableVector>
  }

  /* Removes the DMA handler.*/
  _stm32_dma_isr_redir[dmastp->selfindex].dma_func  = NULL;
 8007e84:	9b01      	ldr	r3, [sp, #4]
 8007e86:	7c5b      	ldrb	r3, [r3, #17]
 8007e88:	461a      	mov	r2, r3
 8007e8a:	4b14      	ldr	r3, [pc, #80]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e8c:	2100      	movs	r1, #0
 8007e8e:	f843 1032 	str.w	r1, [r3, r2, lsl #3]
  _stm32_dma_isr_redir[dmastp->selfindex].dma_param = NULL;
 8007e92:	9b01      	ldr	r3, [sp, #4]
 8007e94:	7c5b      	ldrb	r3, [r3, #17]
 8007e96:	4a11      	ldr	r2, [pc, #68]	; (8007edc <dmaStreamRelease+0x8c>)
 8007e98:	00db      	lsls	r3, r3, #3
 8007e9a:	4413      	add	r3, r2
 8007e9c:	2200      	movs	r2, #0
 8007e9e:	605a      	str	r2, [r3, #4]

  /* Shutting down clocks that are no more required, if any.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) == 0U) {
 8007ea0:	4b0d      	ldr	r3, [pc, #52]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007ea2:	681b      	ldr	r3, [r3, #0]
 8007ea4:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8007ea8:	2b00      	cmp	r3, #0
 8007eaa:	d105      	bne.n	8007eb8 <dmaStreamRelease+0x68>
    rccDisableDMA1(false);
 8007eac:	4b0c      	ldr	r3, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eae:	4a0c      	ldr	r2, [pc, #48]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007eb0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eb2:	f022 0201 	bic.w	r2, r2, #1
 8007eb6:	649a      	str	r2, [r3, #72]	; 0x48
  }
#if STM32_DMA2_NUM_CHANNELS > 0
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) == 0U) {
 8007eb8:	4b07      	ldr	r3, [pc, #28]	; (8007ed8 <dmaStreamRelease+0x88>)
 8007eba:	681b      	ldr	r3, [r3, #0]
 8007ebc:	f403 537e 	and.w	r3, r3, #16256	; 0x3f80
 8007ec0:	2b00      	cmp	r3, #0
 8007ec2:	d105      	bne.n	8007ed0 <dmaStreamRelease+0x80>
    rccDisableDMA2(false);
 8007ec4:	4b06      	ldr	r3, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec6:	4a06      	ldr	r2, [pc, #24]	; (8007ee0 <dmaStreamRelease+0x90>)
 8007ec8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 8007eca:	f022 0202 	bic.w	r2, r2, #2
 8007ece:	649a      	str	r2, [r3, #72]	; 0x48
  }
#endif
}
 8007ed0:	b003      	add	sp, #12
 8007ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8007ed6:	bf00      	nop
 8007ed8:	200011b0 	.word	0x200011b0
 8007edc:	20001d18 	.word	0x20001d18
 8007ee0:	40021000 	.word	0x40021000
 8007ee4:	f3af 8000 	nop.w
 8007ee8:	f3af 8000 	nop.w
 8007eec:	f3af 8000 	nop.w

08007ef0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8007ef0:	b082      	sub	sp, #8
 8007ef2:	2320      	movs	r3, #32
 8007ef4:	9301      	str	r3, [sp, #4]
 8007ef6:	9b01      	ldr	r3, [sp, #4]
 8007ef8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007efc:	b002      	add	sp, #8
 8007efe:	4770      	bx	lr

08007f00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8007f00:	b082      	sub	sp, #8
 8007f02:	2300      	movs	r3, #0
 8007f04:	9301      	str	r3, [sp, #4]
 8007f06:	9b01      	ldr	r3, [sp, #4]
 8007f08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8007f0c:	b002      	add	sp, #8
 8007f0e:	4770      	bx	lr

08007f10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8007f10:	b508      	push	{r3, lr}

  port_lock();
 8007f12:	f7ff ffed 	bl	8007ef0 <port_lock>
}
 8007f16:	bd08      	pop	{r3, pc}
 8007f18:	f3af 8000 	nop.w
 8007f1c:	f3af 8000 	nop.w

08007f20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8007f20:	b508      	push	{r3, lr}

  port_unlock();
 8007f22:	f7ff ffed 	bl	8007f00 <port_unlock>
}
 8007f26:	bd08      	pop	{r3, pc}
 8007f28:	f3af 8000 	nop.w
 8007f2c:	f3af 8000 	nop.w

08007f30 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8007f30:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8007f32:	f7ff ffed 	bl	8007f10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8007f36:	bd08      	pop	{r3, pc}
 8007f38:	f3af 8000 	nop.w
 8007f3c:	f3af 8000 	nop.w

08007f40 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8007f40:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8007f42:	f7ff ffed 	bl	8007f20 <port_unlock_from_isr>
}
 8007f46:	bd08      	pop	{r3, pc}
 8007f48:	f3af 8000 	nop.w
 8007f4c:	f3af 8000 	nop.w

08007f50 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8007f50:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8007f52:	f7ff ffed 	bl	8007f30 <chSysLockFromISR>
}
 8007f56:	bd08      	pop	{r3, pc}
 8007f58:	f3af 8000 	nop.w
 8007f5c:	f3af 8000 	nop.w

08007f60 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8007f60:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8007f62:	f7ff ffed 	bl	8007f40 <chSysUnlockFromISR>
}
 8007f66:	bd08      	pop	{r3, pc}
 8007f68:	f3af 8000 	nop.w
 8007f6c:	f3af 8000 	nop.w

08007f70 <osalOsTimerHandlerI>:
 * @brief   Systick callback for the underlying OS.
 * @note    This callback is only defined if the OSAL requires such a
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {
 8007f70:	b508      	push	{r3, lr}

  chSysTimerHandlerI();
 8007f72:	f7f8 fc6d 	bl	8000850 <chSysTimerHandlerI>
}
 8007f76:	bd08      	pop	{r3, pc}
 8007f78:	f3af 8000 	nop.w
 8007f7c:	f3af 8000 	nop.w

08007f80 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 8007f80:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 8007f82:	f7ff ffe5 	bl	8007f50 <osalSysLockFromISR>
  osalOsTimerHandlerI();
 8007f86:	f7ff fff3 	bl	8007f70 <osalOsTimerHandlerI>
  osalSysUnlockFromISR();
 8007f8a:	f7ff ffe9 	bl	8007f60 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 8007f8e:	f7fb fddf 	bl	8003b50 <_port_irq_epilogue>
}
 8007f92:	bd08      	pop	{r3, pc}
 8007f94:	f3af 8000 	nop.w
 8007f98:	f3af 8000 	nop.w
 8007f9c:	f3af 8000 	nop.w

08007fa0 <st_lld_init>:
/**
 * @brief   Low level ST driver initialization.
 *
 * @notapi
 */
void st_lld_init(void) {
 8007fa0:	b508      	push	{r3, lr}
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 8007fa2:	4b07      	ldr	r3, [pc, #28]	; (8007fc0 <st_lld_init+0x20>)
 8007fa4:	4a07      	ldr	r2, [pc, #28]	; (8007fc4 <st_lld_init+0x24>)
 8007fa6:	605a      	str	r2, [r3, #4]
  SysTick->VAL = 0;
 8007fa8:	4b05      	ldr	r3, [pc, #20]	; (8007fc0 <st_lld_init+0x20>)
 8007faa:	2200      	movs	r2, #0
 8007fac:	609a      	str	r2, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 8007fae:	4b04      	ldr	r3, [pc, #16]	; (8007fc0 <st_lld_init+0x20>)
 8007fb0:	2207      	movs	r2, #7
 8007fb2:	601a      	str	r2, [r3, #0]
                  SysTick_CTRL_ENABLE_Msk |
                  SysTick_CTRL_TICKINT_Msk;

  /* IRQ enabled.*/
  nvicSetSystemHandlerPriority(HANDLER_SYSTICK, STM32_ST_IRQ_PRIORITY);
 8007fb4:	200b      	movs	r0, #11
 8007fb6:	2108      	movs	r1, #8
 8007fb8:	f7ff fa02 	bl	80073c0 <nvicSetSystemHandlerPriority>
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
 8007fbc:	bd08      	pop	{r3, pc}
 8007fbe:	bf00      	nop
 8007fc0:	e000e010 	.word	0xe000e010
 8007fc4:	0001387f 	.word	0x0001387f
 8007fc8:	f3af 8000 	nop.w
 8007fcc:	f3af 8000 	nop.w

08007fd0 <initgpio>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {
 8007fd0:	b082      	sub	sp, #8
 8007fd2:	9001      	str	r0, [sp, #4]
 8007fd4:	9100      	str	r1, [sp, #0]

  gpiop->OTYPER  = config->otyper;
 8007fd6:	9b00      	ldr	r3, [sp, #0]
 8007fd8:	685a      	ldr	r2, [r3, #4]
 8007fda:	9b01      	ldr	r3, [sp, #4]
 8007fdc:	605a      	str	r2, [r3, #4]
  gpiop->ASCR    = config->ascr;
 8007fde:	9b00      	ldr	r3, [sp, #0]
 8007fe0:	69da      	ldr	r2, [r3, #28]
 8007fe2:	9b01      	ldr	r3, [sp, #4]
 8007fe4:	62da      	str	r2, [r3, #44]	; 0x2c
  gpiop->OSPEEDR = config->ospeedr;
 8007fe6:	9b00      	ldr	r3, [sp, #0]
 8007fe8:	689a      	ldr	r2, [r3, #8]
 8007fea:	9b01      	ldr	r3, [sp, #4]
 8007fec:	609a      	str	r2, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8007fee:	9b00      	ldr	r3, [sp, #0]
 8007ff0:	68da      	ldr	r2, [r3, #12]
 8007ff2:	9b01      	ldr	r3, [sp, #4]
 8007ff4:	60da      	str	r2, [r3, #12]
  gpiop->ODR     = config->odr;
 8007ff6:	9b00      	ldr	r3, [sp, #0]
 8007ff8:	691a      	ldr	r2, [r3, #16]
 8007ffa:	9b01      	ldr	r3, [sp, #4]
 8007ffc:	615a      	str	r2, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8007ffe:	9b00      	ldr	r3, [sp, #0]
 8008000:	695a      	ldr	r2, [r3, #20]
 8008002:	9b01      	ldr	r3, [sp, #4]
 8008004:	621a      	str	r2, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8008006:	9b00      	ldr	r3, [sp, #0]
 8008008:	699a      	ldr	r2, [r3, #24]
 800800a:	9b01      	ldr	r3, [sp, #4]
 800800c:	625a      	str	r2, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 800800e:	9b00      	ldr	r3, [sp, #0]
 8008010:	681a      	ldr	r2, [r3, #0]
 8008012:	9b01      	ldr	r3, [sp, #4]
 8008014:	601a      	str	r2, [r3, #0]
  gpiop->LOCKR   = config->lockr;
 8008016:	9b00      	ldr	r3, [sp, #0]
 8008018:	6a1a      	ldr	r2, [r3, #32]
 800801a:	9b01      	ldr	r3, [sp, #4]
 800801c:	61da      	str	r2, [r3, #28]
}
 800801e:	b002      	add	sp, #8
 8008020:	4770      	bx	lr
 8008022:	bf00      	nop
 8008024:	f3af 8000 	nop.w
 8008028:	f3af 8000 	nop.w
 800802c:	f3af 8000 	nop.w

08008030 <_pal_lld_init>:
 *
 * @param[in] config    the STM32 ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
 8008030:	b500      	push	{lr}
 8008032:	b083      	sub	sp, #12
 8008034:	9001      	str	r0, [sp, #4]

  /*
   * Enables the GPIO related clocks.
   */
#if defined(STM32L4XX)
  RCC->AHB2ENR   |= AHB1_EN_MASK;
 8008036:	4b1c      	ldr	r3, [pc, #112]	; (80080a8 <_pal_lld_init+0x78>)
 8008038:	4a1b      	ldr	r2, [pc, #108]	; (80080a8 <_pal_lld_init+0x78>)
 800803a:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 800803c:	f042 02ff 	orr.w	r2, r2, #255	; 0xff
 8008040:	64da      	str	r2, [r3, #76]	; 0x4c

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8008042:	9b01      	ldr	r3, [sp, #4]
 8008044:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 8008048:	4619      	mov	r1, r3
 800804a:	f7ff ffc1 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 800804e:	9b01      	ldr	r3, [sp, #4]
 8008050:	3324      	adds	r3, #36	; 0x24
 8008052:	4816      	ldr	r0, [pc, #88]	; (80080ac <_pal_lld_init+0x7c>)
 8008054:	4619      	mov	r1, r3
 8008056:	f7ff ffbb 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 800805a:	9b01      	ldr	r3, [sp, #4]
 800805c:	3348      	adds	r3, #72	; 0x48
 800805e:	4814      	ldr	r0, [pc, #80]	; (80080b0 <_pal_lld_init+0x80>)
 8008060:	4619      	mov	r1, r3
 8008062:	f7ff ffb5 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 8008066:	9b01      	ldr	r3, [sp, #4]
 8008068:	336c      	adds	r3, #108	; 0x6c
 800806a:	4812      	ldr	r0, [pc, #72]	; (80080b4 <_pal_lld_init+0x84>)
 800806c:	4619      	mov	r1, r3
 800806e:	f7ff ffaf 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 8008072:	9b01      	ldr	r3, [sp, #4]
 8008074:	3390      	adds	r3, #144	; 0x90
 8008076:	4810      	ldr	r0, [pc, #64]	; (80080b8 <_pal_lld_init+0x88>)
 8008078:	4619      	mov	r1, r3
 800807a:	f7ff ffa9 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 800807e:	9b01      	ldr	r3, [sp, #4]
 8008080:	33b4      	adds	r3, #180	; 0xb4
 8008082:	480e      	ldr	r0, [pc, #56]	; (80080bc <_pal_lld_init+0x8c>)
 8008084:	4619      	mov	r1, r3
 8008086:	f7ff ffa3 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOG
  initgpio(GPIOG, &config->PGData);
 800808a:	9b01      	ldr	r3, [sp, #4]
 800808c:	33d8      	adds	r3, #216	; 0xd8
 800808e:	480c      	ldr	r0, [pc, #48]	; (80080c0 <_pal_lld_init+0x90>)
 8008090:	4619      	mov	r1, r3
 8008092:	f7ff ff9d 	bl	8007fd0 <initgpio>
#endif
#if STM32_HAS_GPIOH
  initgpio(GPIOH, &config->PHData);
 8008096:	9b01      	ldr	r3, [sp, #4]
 8008098:	33fc      	adds	r3, #252	; 0xfc
 800809a:	480a      	ldr	r0, [pc, #40]	; (80080c4 <_pal_lld_init+0x94>)
 800809c:	4619      	mov	r1, r3
 800809e:	f7ff ff97 	bl	8007fd0 <initgpio>
  initgpio(GPIOJ, &config->PJData);
#endif
#if STM32_HAS_GPIOK
  initgpio(GPIOK, &config->PKData);
#endif
}
 80080a2:	b003      	add	sp, #12
 80080a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80080a8:	40021000 	.word	0x40021000
 80080ac:	48000400 	.word	0x48000400
 80080b0:	48000800 	.word	0x48000800
 80080b4:	48000c00 	.word	0x48000c00
 80080b8:	48001000 	.word	0x48001000
 80080bc:	48001400 	.word	0x48001400
 80080c0:	48001800 	.word	0x48001800
 80080c4:	48001c00 	.word	0x48001c00
 80080c8:	f3af 8000 	nop.w
 80080cc:	f3af 8000 	nop.w

080080d0 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
 80080d0:	b090      	sub	sp, #64	; 0x40
 80080d2:	9003      	str	r0, [sp, #12]
 80080d4:	9102      	str	r1, [sp, #8]
 80080d6:	9201      	str	r2, [sp, #4]

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 80080d8:	9b01      	ldr	r3, [sp, #4]
 80080da:	f003 0303 	and.w	r3, r3, #3
 80080de:	930f      	str	r3, [sp, #60]	; 0x3c
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
 80080e0:	9b01      	ldr	r3, [sp, #4]
 80080e2:	f003 0304 	and.w	r3, r3, #4
 80080e6:	089b      	lsrs	r3, r3, #2
 80080e8:	930e      	str	r3, [sp, #56]	; 0x38
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
 80080ea:	9b01      	ldr	r3, [sp, #4]
 80080ec:	f003 0318 	and.w	r3, r3, #24
 80080f0:	08db      	lsrs	r3, r3, #3
 80080f2:	930d      	str	r3, [sp, #52]	; 0x34
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
 80080f4:	9b01      	ldr	r3, [sp, #4]
 80080f6:	f003 0360 	and.w	r3, r3, #96	; 0x60
 80080fa:	095b      	lsrs	r3, r3, #5
 80080fc:	930c      	str	r3, [sp, #48]	; 0x30
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
 80080fe:	9b01      	ldr	r3, [sp, #4]
 8008100:	f403 63f0 	and.w	r3, r3, #1920	; 0x780
 8008104:	09db      	lsrs	r3, r3, #7
 8008106:	930a      	str	r3, [sp, #40]	; 0x28
  uint32_t ascr    = (mode & PAL_STM32_ASCR_MASK) >> 11;
 8008108:	9b01      	ldr	r3, [sp, #4]
 800810a:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 800810e:	0adb      	lsrs	r3, r3, #11
 8008110:	9309      	str	r3, [sp, #36]	; 0x24
  uint32_t lockr   = (mode & PAL_STM32_LOCKR_MASK) >> 12;
 8008112:	9b01      	ldr	r3, [sp, #4]
 8008114:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008118:	0b1b      	lsrs	r3, r3, #12
 800811a:	9308      	str	r3, [sp, #32]
  uint32_t bit     = 0;
 800811c:	2300      	movs	r3, #0
 800811e:	930b      	str	r3, [sp, #44]	; 0x2c
  while (true) {
    if ((mask & 1) != 0) {
 8008120:	9b02      	ldr	r3, [sp, #8]
 8008122:	f003 0301 	and.w	r3, r3, #1
 8008126:	2b00      	cmp	r3, #0
 8008128:	f000 808a 	beq.w	8008240 <_pal_lld_setgroupmode+0x170>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800812c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800812e:	f003 0307 	and.w	r3, r3, #7
 8008132:	009b      	lsls	r3, r3, #2
 8008134:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8008136:	fa02 f303 	lsl.w	r3, r2, r3
 800813a:	9307      	str	r3, [sp, #28]
      m1 = 1 << bit;
 800813c:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800813e:	2201      	movs	r2, #1
 8008140:	fa02 f303 	lsl.w	r3, r2, r3
 8008144:	9306      	str	r3, [sp, #24]
      m2 = 3 << (bit * 2);
 8008146:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008148:	005b      	lsls	r3, r3, #1
 800814a:	2203      	movs	r2, #3
 800814c:	fa02 f303 	lsl.w	r3, r2, r3
 8008150:	9305      	str	r3, [sp, #20]
      m4 = 15 << ((bit & 7) * 4);
 8008152:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008154:	f003 0307 	and.w	r3, r3, #7
 8008158:	009b      	lsls	r3, r3, #2
 800815a:	220f      	movs	r2, #15
 800815c:	fa02 f303 	lsl.w	r3, r2, r3
 8008160:	9304      	str	r3, [sp, #16]
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8008162:	9b03      	ldr	r3, [sp, #12]
 8008164:	685a      	ldr	r2, [r3, #4]
 8008166:	9b06      	ldr	r3, [sp, #24]
 8008168:	43db      	mvns	r3, r3
 800816a:	401a      	ands	r2, r3
 800816c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 800816e:	431a      	orrs	r2, r3
 8008170:	9b03      	ldr	r3, [sp, #12]
 8008172:	605a      	str	r2, [r3, #4]
      port->ASCR    = (port->ASCR & ~m1) | ascr;
 8008174:	9b03      	ldr	r3, [sp, #12]
 8008176:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8008178:	9b06      	ldr	r3, [sp, #24]
 800817a:	43db      	mvns	r3, r3
 800817c:	401a      	ands	r2, r3
 800817e:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8008180:	431a      	orrs	r2, r3
 8008182:	9b03      	ldr	r3, [sp, #12]
 8008184:	62da      	str	r2, [r3, #44]	; 0x2c
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8008186:	9b03      	ldr	r3, [sp, #12]
 8008188:	689a      	ldr	r2, [r3, #8]
 800818a:	9b05      	ldr	r3, [sp, #20]
 800818c:	43db      	mvns	r3, r3
 800818e:	401a      	ands	r2, r3
 8008190:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008192:	431a      	orrs	r2, r3
 8008194:	9b03      	ldr	r3, [sp, #12]
 8008196:	609a      	str	r2, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8008198:	9b03      	ldr	r3, [sp, #12]
 800819a:	68da      	ldr	r2, [r3, #12]
 800819c:	9b05      	ldr	r3, [sp, #20]
 800819e:	43db      	mvns	r3, r3
 80081a0:	401a      	ands	r2, r3
 80081a2:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80081a4:	431a      	orrs	r2, r3
 80081a6:	9b03      	ldr	r3, [sp, #12]
 80081a8:	60da      	str	r2, [r3, #12]
       if (moder == PAL_STM32_MODE_ALTERNATE) {
 80081aa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081ac:	2b02      	cmp	r3, #2
 80081ae:	d11f      	bne.n	80081f0 <_pal_lld_setgroupmode+0x120>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80081b0:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 80081b2:	2b07      	cmp	r3, #7
 80081b4:	d809      	bhi.n	80081ca <_pal_lld_setgroupmode+0xfa>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80081b6:	9b03      	ldr	r3, [sp, #12]
 80081b8:	6a1a      	ldr	r2, [r3, #32]
 80081ba:	9b04      	ldr	r3, [sp, #16]
 80081bc:	43db      	mvns	r3, r3
 80081be:	401a      	ands	r2, r3
 80081c0:	9b07      	ldr	r3, [sp, #28]
 80081c2:	431a      	orrs	r2, r3
 80081c4:	9b03      	ldr	r3, [sp, #12]
 80081c6:	621a      	str	r2, [r3, #32]
 80081c8:	e008      	b.n	80081dc <_pal_lld_setgroupmode+0x10c>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80081ca:	9b03      	ldr	r3, [sp, #12]
 80081cc:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80081ce:	9b04      	ldr	r3, [sp, #16]
 80081d0:	43db      	mvns	r3, r3
 80081d2:	401a      	ands	r2, r3
 80081d4:	9b07      	ldr	r3, [sp, #28]
 80081d6:	431a      	orrs	r2, r3
 80081d8:	9b03      	ldr	r3, [sp, #12]
 80081da:	625a      	str	r2, [r3, #36]	; 0x24
        port->MODER   = (port->MODER & ~m2) | moder;
 80081dc:	9b03      	ldr	r3, [sp, #12]
 80081de:	681a      	ldr	r2, [r3, #0]
 80081e0:	9b05      	ldr	r3, [sp, #20]
 80081e2:	43db      	mvns	r3, r3
 80081e4:	401a      	ands	r2, r3
 80081e6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081e8:	431a      	orrs	r2, r3
 80081ea:	9b03      	ldr	r3, [sp, #12]
 80081ec:	601a      	str	r2, [r3, #0]
 80081ee:	e01e      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80081f0:	9b03      	ldr	r3, [sp, #12]
 80081f2:	681a      	ldr	r2, [r3, #0]
 80081f4:	9b05      	ldr	r3, [sp, #20]
 80081f6:	43db      	mvns	r3, r3
 80081f8:	401a      	ands	r2, r3
 80081fa:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80081fc:	431a      	orrs	r2, r3
 80081fe:	9b03      	ldr	r3, [sp, #12]
 8008200:	601a      	str	r2, [r3, #0]
        if (bit < 8)
 8008202:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008204:	2b07      	cmp	r3, #7
 8008206:	d809      	bhi.n	800821c <_pal_lld_setgroupmode+0x14c>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 8008208:	9b03      	ldr	r3, [sp, #12]
 800820a:	6a1a      	ldr	r2, [r3, #32]
 800820c:	9b04      	ldr	r3, [sp, #16]
 800820e:	43db      	mvns	r3, r3
 8008210:	401a      	ands	r2, r3
 8008212:	9b07      	ldr	r3, [sp, #28]
 8008214:	431a      	orrs	r2, r3
 8008216:	9b03      	ldr	r3, [sp, #12]
 8008218:	621a      	str	r2, [r3, #32]
 800821a:	e008      	b.n	800822e <_pal_lld_setgroupmode+0x15e>
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 800821c:	9b03      	ldr	r3, [sp, #12]
 800821e:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8008220:	9b04      	ldr	r3, [sp, #16]
 8008222:	43db      	mvns	r3, r3
 8008224:	401a      	ands	r2, r3
 8008226:	9b07      	ldr	r3, [sp, #28]
 8008228:	431a      	orrs	r2, r3
 800822a:	9b03      	ldr	r3, [sp, #12]
 800822c:	625a      	str	r2, [r3, #36]	; 0x24
      }
      port->LOCKR   = (port->LOCKR & ~m1) | lockr;
 800822e:	9b03      	ldr	r3, [sp, #12]
 8008230:	69da      	ldr	r2, [r3, #28]
 8008232:	9b06      	ldr	r3, [sp, #24]
 8008234:	43db      	mvns	r3, r3
 8008236:	401a      	ands	r2, r3
 8008238:	9b08      	ldr	r3, [sp, #32]
 800823a:	431a      	orrs	r2, r3
 800823c:	9b03      	ldr	r3, [sp, #12]
 800823e:	61da      	str	r2, [r3, #28]
    }
    mask >>= 1;
 8008240:	9b02      	ldr	r3, [sp, #8]
 8008242:	085b      	lsrs	r3, r3, #1
 8008244:	9302      	str	r3, [sp, #8]
    if (!mask)
 8008246:	9b02      	ldr	r3, [sp, #8]
 8008248:	2b00      	cmp	r3, #0
 800824a:	d100      	bne.n	800824e <_pal_lld_setgroupmode+0x17e>
      return;
 800824c:	e00f      	b.n	800826e <_pal_lld_setgroupmode+0x19e>
    otyper <<= 1;
 800824e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8008250:	005b      	lsls	r3, r3, #1
 8008252:	930e      	str	r3, [sp, #56]	; 0x38
    ospeedr <<= 2;
 8008254:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 8008256:	009b      	lsls	r3, r3, #2
 8008258:	930d      	str	r3, [sp, #52]	; 0x34
    pupdr <<= 2;
 800825a:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800825c:	009b      	lsls	r3, r3, #2
 800825e:	930c      	str	r3, [sp, #48]	; 0x30
    moder <<= 2;
 8008260:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8008262:	009b      	lsls	r3, r3, #2
 8008264:	930f      	str	r3, [sp, #60]	; 0x3c
    bit++;
 8008266:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8008268:	3301      	adds	r3, #1
 800826a:	930b      	str	r3, [sp, #44]	; 0x2c
  }
 800826c:	e758      	b.n	8008120 <_pal_lld_setgroupmode+0x50>
}
 800826e:	b010      	add	sp, #64	; 0x40
 8008270:	4770      	bx	lr
 8008272:	bf00      	nop
 8008274:	f3af 8000 	nop.w
 8008278:	f3af 8000 	nop.w
 800827c:	f3af 8000 	nop.w

08008280 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8008280:	b082      	sub	sp, #8
 8008282:	2320      	movs	r3, #32
 8008284:	9301      	str	r3, [sp, #4]
 8008286:	9b01      	ldr	r3, [sp, #4]
 8008288:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800828c:	b002      	add	sp, #8
 800828e:	4770      	bx	lr

08008290 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8008290:	b082      	sub	sp, #8
 8008292:	2300      	movs	r3, #0
 8008294:	9301      	str	r3, [sp, #4]
 8008296:	9b01      	ldr	r3, [sp, #4]
 8008298:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800829c:	b002      	add	sp, #8
 800829e:	4770      	bx	lr

080082a0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 80082a0:	b508      	push	{r3, lr}

  port_lock();
 80082a2:	f7ff ffed 	bl	8008280 <port_lock>
}
 80082a6:	bd08      	pop	{r3, pc}
 80082a8:	f3af 8000 	nop.w
 80082ac:	f3af 8000 	nop.w

080082b0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 80082b0:	b508      	push	{r3, lr}

  port_unlock();
 80082b2:	f7ff ffed 	bl	8008290 <port_unlock>
}
 80082b6:	bd08      	pop	{r3, pc}
 80082b8:	f3af 8000 	nop.w
 80082bc:	f3af 8000 	nop.w

080082c0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80082c0:	b508      	push	{r3, lr}

  port_lock();
 80082c2:	f7ff ffdd 	bl	8008280 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80082c6:	bd08      	pop	{r3, pc}
 80082c8:	f3af 8000 	nop.w
 80082cc:	f3af 8000 	nop.w

080082d0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80082d0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80082d2:	f7ff ffdd 	bl	8008290 <port_unlock>
}
 80082d6:	bd08      	pop	{r3, pc}
 80082d8:	f3af 8000 	nop.w
 80082dc:	f3af 8000 	nop.w

080082e0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 80082e0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 80082e2:	f7ff ffdd 	bl	80082a0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 80082e6:	bd08      	pop	{r3, pc}
 80082e8:	f3af 8000 	nop.w
 80082ec:	f3af 8000 	nop.w

080082f0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 80082f0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 80082f2:	f7ff ffdd 	bl	80082b0 <port_unlock_from_isr>
}
 80082f6:	bd08      	pop	{r3, pc}
 80082f8:	f3af 8000 	nop.w
 80082fc:	f3af 8000 	nop.w

08008300 <chThdStartI>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
static inline thread_t *chThdStartI(thread_t *tp) {
 8008300:	b500      	push	{lr}
 8008302:	b083      	sub	sp, #12
 8008304:	9001      	str	r0, [sp, #4]

  chDbgAssert(tp->p_state == CH_STATE_WTSTART, "wrong state");

  return chSchReadyI(tp);
 8008306:	9801      	ldr	r0, [sp, #4]
 8008308:	f7f8 fc4a 	bl	8000ba0 <chSchReadyI>
 800830c:	4603      	mov	r3, r0
}
 800830e:	4618      	mov	r0, r3
 8008310:	b003      	add	sp, #12
 8008312:	f85d fb04 	ldr.w	pc, [sp], #4
 8008316:	bf00      	nop
 8008318:	f3af 8000 	nop.w
 800831c:	f3af 8000 	nop.w

08008320 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8008320:	b082      	sub	sp, #8
 8008322:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8008324:	4b02      	ldr	r3, [pc, #8]	; (8008330 <chRegSetThreadName+0x10>)
 8008326:	699b      	ldr	r3, [r3, #24]
 8008328:	9a01      	ldr	r2, [sp, #4]
 800832a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 800832c:	b002      	add	sp, #8
 800832e:	4770      	bx	lr
 8008330:	20001bc8 	.word	0x20001bc8
 8008334:	f3af 8000 	nop.w
 8008338:	f3af 8000 	nop.w
 800833c:	f3af 8000 	nop.w

08008340 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 8008340:	b508      	push	{r3, lr}

  chSysLock();
 8008342:	f7ff ffbd 	bl	80082c0 <chSysLock>
}
 8008346:	bd08      	pop	{r3, pc}
 8008348:	f3af 8000 	nop.w
 800834c:	f3af 8000 	nop.w

08008350 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 8008350:	b508      	push	{r3, lr}

  chSysUnlock();
 8008352:	f7ff ffbd 	bl	80082d0 <chSysUnlock>
}
 8008356:	bd08      	pop	{r3, pc}
 8008358:	f3af 8000 	nop.w
 800835c:	f3af 8000 	nop.w

08008360 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 8008360:	b508      	push	{r3, lr}

  chSysLockFromISR();
 8008362:	f7ff ffbd 	bl	80082e0 <chSysLockFromISR>
}
 8008366:	bd08      	pop	{r3, pc}
 8008368:	f3af 8000 	nop.w
 800836c:	f3af 8000 	nop.w

08008370 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 8008370:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 8008372:	f7ff ffbd 	bl	80082f0 <chSysUnlockFromISR>
}
 8008376:	bd08      	pop	{r3, pc}
 8008378:	f3af 8000 	nop.w
 800837c:	f3af 8000 	nop.w

08008380 <osalSysPolledDelayX>:
 * @param[in] cycles    number of cycles
 *
 * @xclass
 */
#if PORT_SUPPORTS_RT || defined(__DOXYGEN__)
static inline void osalSysPolledDelayX(rtcnt_t cycles) {
 8008380:	b500      	push	{lr}
 8008382:	b083      	sub	sp, #12
 8008384:	9001      	str	r0, [sp, #4]

  chSysPolledDelayX(cycles);
 8008386:	9801      	ldr	r0, [sp, #4]
 8008388:	f7f8 faca 	bl	8000920 <chSysPolledDelayX>
}
 800838c:	b003      	add	sp, #12
 800838e:	f85d fb04 	ldr.w	pc, [sp], #4
 8008392:	bf00      	nop
 8008394:	f3af 8000 	nop.w
 8008398:	f3af 8000 	nop.w
 800839c:	f3af 8000 	nop.w

080083a0 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 80083a0:	b500      	push	{lr}
 80083a2:	b083      	sub	sp, #12
 80083a4:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 80083a6:	9801      	ldr	r0, [sp, #4]
 80083a8:	f7f9 f852 	bl	8001450 <chThdSuspendS>
 80083ac:	4603      	mov	r3, r0
}
 80083ae:	4618      	mov	r0, r3
 80083b0:	b003      	add	sp, #12
 80083b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083b6:	bf00      	nop
 80083b8:	f3af 8000 	nop.w
 80083bc:	f3af 8000 	nop.w

080083c0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 80083c0:	b500      	push	{lr}
 80083c2:	b083      	sub	sp, #12
 80083c4:	9001      	str	r0, [sp, #4]
 80083c6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 80083c8:	9801      	ldr	r0, [sp, #4]
 80083ca:	9900      	ldr	r1, [sp, #0]
 80083cc:	f7f9 f878 	bl	80014c0 <chThdResumeI>
}
 80083d0:	b003      	add	sp, #12
 80083d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80083d6:	bf00      	nop
 80083d8:	f3af 8000 	nop.w
 80083dc:	f3af 8000 	nop.w

080083e0 <otg_core_reset>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void otg_core_reset(USBDriver *usbp) {
 80083e0:	b500      	push	{lr}
 80083e2:	b085      	sub	sp, #20
 80083e4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80083e6:	9b01      	ldr	r3, [sp, #4]
 80083e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80083ea:	9303      	str	r3, [sp, #12]

  osalSysPolledDelayX(32);
 80083ec:	2020      	movs	r0, #32
 80083ee:	f7ff ffc7 	bl	8008380 <osalSysPolledDelayX>

  /* Core reset and delay of at least 3 PHY cycles.*/
  otgp->GRSTCTL = GRSTCTL_CSRST;
 80083f2:	9b03      	ldr	r3, [sp, #12]
 80083f4:	2201      	movs	r2, #1
 80083f6:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_CSRST) != 0)
 80083f8:	bf00      	nop
 80083fa:	9b03      	ldr	r3, [sp, #12]
 80083fc:	691b      	ldr	r3, [r3, #16]
 80083fe:	f003 0301 	and.w	r3, r3, #1
 8008402:	2b00      	cmp	r3, #0
 8008404:	d1f9      	bne.n	80083fa <otg_core_reset+0x1a>
    ;

  osalSysPolledDelayX(18);
 8008406:	2012      	movs	r0, #18
 8008408:	f7ff ffba 	bl	8008380 <osalSysPolledDelayX>

  /* Wait AHB idle condition.*/
  while ((otgp->GRSTCTL & GRSTCTL_AHBIDL) == 0)
 800840c:	bf00      	nop
 800840e:	9b03      	ldr	r3, [sp, #12]
 8008410:	691b      	ldr	r3, [r3, #16]
 8008412:	2b00      	cmp	r3, #0
 8008414:	dafb      	bge.n	800840e <otg_core_reset+0x2e>
    ;
}
 8008416:	b005      	add	sp, #20
 8008418:	f85d fb04 	ldr.w	pc, [sp], #4
 800841c:	f3af 8000 	nop.w

08008420 <otg_disable_ep>:

static void otg_disable_ep(USBDriver *usbp) {
 8008420:	b084      	sub	sp, #16
 8008422:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008424:	9b01      	ldr	r3, [sp, #4]
 8008426:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008428:	9302      	str	r3, [sp, #8]
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 800842a:	2300      	movs	r3, #0
 800842c:	9303      	str	r3, [sp, #12]
 800842e:	e032      	b.n	8008496 <otg_disable_ep+0x76>
    otgp->ie[i].DIEPCTL = 0;
 8008430:	9a02      	ldr	r2, [sp, #8]
 8008432:	9b03      	ldr	r3, [sp, #12]
 8008434:	3348      	adds	r3, #72	; 0x48
 8008436:	015b      	lsls	r3, r3, #5
 8008438:	4413      	add	r3, r2
 800843a:	2200      	movs	r2, #0
 800843c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPTSIZ = 0;
 800843e:	9a02      	ldr	r2, [sp, #8]
 8008440:	9b03      	ldr	r3, [sp, #12]
 8008442:	015b      	lsls	r3, r3, #5
 8008444:	4413      	add	r3, r2
 8008446:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800844a:	2200      	movs	r2, #0
 800844c:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 800844e:	9a02      	ldr	r2, [sp, #8]
 8008450:	9b03      	ldr	r3, [sp, #12]
 8008452:	015b      	lsls	r3, r3, #5
 8008454:	4413      	add	r3, r2
 8008456:	f603 1308 	addw	r3, r3, #2312	; 0x908
 800845a:	f04f 32ff 	mov.w	r2, #4294967295
 800845e:	601a      	str	r2, [r3, #0]

    otgp->oe[i].DOEPCTL = 0;
 8008460:	9a02      	ldr	r2, [sp, #8]
 8008462:	9b03      	ldr	r3, [sp, #12]
 8008464:	3358      	adds	r3, #88	; 0x58
 8008466:	015b      	lsls	r3, r3, #5
 8008468:	4413      	add	r3, r2
 800846a:	2200      	movs	r2, #0
 800846c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPTSIZ = 0;
 800846e:	9a02      	ldr	r2, [sp, #8]
 8008470:	9b03      	ldr	r3, [sp, #12]
 8008472:	015b      	lsls	r3, r3, #5
 8008474:	4413      	add	r3, r2
 8008476:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800847a:	2200      	movs	r2, #0
 800847c:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 800847e:	9a02      	ldr	r2, [sp, #8]
 8008480:	9b03      	ldr	r3, [sp, #12]
 8008482:	015b      	lsls	r3, r3, #5
 8008484:	4413      	add	r3, r2
 8008486:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 800848a:	f04f 32ff 	mov.w	r2, #4294967295
 800848e:	601a      	str	r2, [r3, #0]

static void otg_disable_ep(USBDriver *usbp) {
  stm32_otg_t *otgp = usbp->otg;
  unsigned i;

  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8008490:	9b03      	ldr	r3, [sp, #12]
 8008492:	3301      	adds	r3, #1
 8008494:	9303      	str	r3, [sp, #12]
 8008496:	9b01      	ldr	r3, [sp, #4]
 8008498:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800849a:	689a      	ldr	r2, [r3, #8]
 800849c:	9b03      	ldr	r3, [sp, #12]
 800849e:	429a      	cmp	r2, r3
 80084a0:	d2c6      	bcs.n	8008430 <otg_disable_ep+0x10>

    otgp->oe[i].DOEPCTL = 0;
    otgp->oe[i].DOEPTSIZ = 0;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }
  otgp->DAINTMSK = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 80084a2:	9b02      	ldr	r3, [sp, #8]
 80084a4:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 80084a8:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
}
 80084ac:	b004      	add	sp, #16
 80084ae:	4770      	bx	lr

080084b0 <otg_rxfifo_flush>:

static void otg_rxfifo_flush(USBDriver *usbp) {
 80084b0:	b500      	push	{lr}
 80084b2:	b085      	sub	sp, #20
 80084b4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 80084b6:	9b01      	ldr	r3, [sp, #4]
 80084b8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ba:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_RXFFLSH;
 80084bc:	9b03      	ldr	r3, [sp, #12]
 80084be:	2210      	movs	r2, #16
 80084c0:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_RXFFLSH) != 0)
 80084c2:	bf00      	nop
 80084c4:	9b03      	ldr	r3, [sp, #12]
 80084c6:	691b      	ldr	r3, [r3, #16]
 80084c8:	f003 0310 	and.w	r3, r3, #16
 80084cc:	2b00      	cmp	r3, #0
 80084ce:	d1f9      	bne.n	80084c4 <otg_rxfifo_flush+0x14>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 80084d0:	2012      	movs	r0, #18
 80084d2:	f7ff ff55 	bl	8008380 <osalSysPolledDelayX>
}
 80084d6:	b005      	add	sp, #20
 80084d8:	f85d fb04 	ldr.w	pc, [sp], #4
 80084dc:	f3af 8000 	nop.w

080084e0 <otg_txfifo_flush>:

static void otg_txfifo_flush(USBDriver *usbp, uint32_t fifo) {
 80084e0:	b500      	push	{lr}
 80084e2:	b085      	sub	sp, #20
 80084e4:	9001      	str	r0, [sp, #4]
 80084e6:	9100      	str	r1, [sp, #0]
  stm32_otg_t *otgp = usbp->otg;
 80084e8:	9b01      	ldr	r3, [sp, #4]
 80084ea:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80084ec:	9303      	str	r3, [sp, #12]

  otgp->GRSTCTL = GRSTCTL_TXFNUM(fifo) | GRSTCTL_TXFFLSH;
 80084ee:	9b00      	ldr	r3, [sp, #0]
 80084f0:	019b      	lsls	r3, r3, #6
 80084f2:	f043 0220 	orr.w	r2, r3, #32
 80084f6:	9b03      	ldr	r3, [sp, #12]
 80084f8:	611a      	str	r2, [r3, #16]
  while ((otgp->GRSTCTL & GRSTCTL_TXFFLSH) != 0)
 80084fa:	bf00      	nop
 80084fc:	9b03      	ldr	r3, [sp, #12]
 80084fe:	691b      	ldr	r3, [r3, #16]
 8008500:	f003 0320 	and.w	r3, r3, #32
 8008504:	2b00      	cmp	r3, #0
 8008506:	d1f9      	bne.n	80084fc <otg_txfifo_flush+0x1c>
    ;
  /* Wait for 3 PHY Clocks.*/
  osalSysPolledDelayX(18);
 8008508:	2012      	movs	r0, #18
 800850a:	f7ff ff39 	bl	8008380 <osalSysPolledDelayX>
}
 800850e:	b005      	add	sp, #20
 8008510:	f85d fb04 	ldr.w	pc, [sp], #4
 8008514:	f3af 8000 	nop.w
 8008518:	f3af 8000 	nop.w
 800851c:	f3af 8000 	nop.w

08008520 <otg_ram_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_ram_reset(USBDriver *usbp) {
 8008520:	b082      	sub	sp, #8
 8008522:	9001      	str	r0, [sp, #4]

  usbp->pmnext = usbp->otgparams->rx_fifo_size;
 8008524:	9b01      	ldr	r3, [sp, #4]
 8008526:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008528:	681a      	ldr	r2, [r3, #0]
 800852a:	9b01      	ldr	r3, [sp, #4]
 800852c:	675a      	str	r2, [r3, #116]	; 0x74
}
 800852e:	b002      	add	sp, #8
 8008530:	4770      	bx	lr
 8008532:	bf00      	nop
 8008534:	f3af 8000 	nop.w
 8008538:	f3af 8000 	nop.w
 800853c:	f3af 8000 	nop.w

08008540 <otg_ram_alloc>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] size      size of the packet buffer to allocate in words
 *
 * @notapi
 */
static uint32_t otg_ram_alloc(USBDriver *usbp, size_t size) {
 8008540:	b084      	sub	sp, #16
 8008542:	9001      	str	r0, [sp, #4]
 8008544:	9100      	str	r1, [sp, #0]
  uint32_t next;

  next = usbp->pmnext;
 8008546:	9b01      	ldr	r3, [sp, #4]
 8008548:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800854a:	9303      	str	r3, [sp, #12]
  usbp->pmnext += size;
 800854c:	9b01      	ldr	r3, [sp, #4]
 800854e:	6f5a      	ldr	r2, [r3, #116]	; 0x74
 8008550:	9b00      	ldr	r3, [sp, #0]
 8008552:	441a      	add	r2, r3
 8008554:	9b01      	ldr	r3, [sp, #4]
 8008556:	675a      	str	r2, [r3, #116]	; 0x74
  osalDbgAssert(usbp->pmnext <= usbp->otgparams->otg_ram_size,
                "OTG FIFO memory overflow");
  return next;
 8008558:	9b03      	ldr	r3, [sp, #12]
}
 800855a:	4618      	mov	r0, r3
 800855c:	b004      	add	sp, #16
 800855e:	4770      	bx	lr

08008560 <otg_fifo_write_from_buffer>:
 *
 * @notapi
 */
static void otg_fifo_write_from_buffer(volatile uint32_t *fifop,
                                       const uint8_t *buf,
                                       size_t n) {
 8008560:	b084      	sub	sp, #16
 8008562:	9003      	str	r0, [sp, #12]
 8008564:	9102      	str	r1, [sp, #8]
 8008566:	9201      	str	r2, [sp, #4]

  osalDbgAssert(n > 0, "is zero");

  while (true) {
    *fifop = *((uint32_t *)buf);
 8008568:	9b02      	ldr	r3, [sp, #8]
 800856a:	681a      	ldr	r2, [r3, #0]
 800856c:	9b03      	ldr	r3, [sp, #12]
 800856e:	601a      	str	r2, [r3, #0]
    if (n <= 4) {
 8008570:	9b01      	ldr	r3, [sp, #4]
 8008572:	2b04      	cmp	r3, #4
 8008574:	d800      	bhi.n	8008578 <otg_fifo_write_from_buffer+0x18>
      break;
 8008576:	e006      	b.n	8008586 <otg_fifo_write_from_buffer+0x26>
    }
    n -= 4;
 8008578:	9b01      	ldr	r3, [sp, #4]
 800857a:	3b04      	subs	r3, #4
 800857c:	9301      	str	r3, [sp, #4]
    buf += 4;
 800857e:	9b02      	ldr	r3, [sp, #8]
 8008580:	3304      	adds	r3, #4
 8008582:	9302      	str	r3, [sp, #8]
  }
 8008584:	e7f0      	b.n	8008568 <otg_fifo_write_from_buffer+0x8>
}
 8008586:	b004      	add	sp, #16
 8008588:	4770      	bx	lr
 800858a:	bf00      	nop
 800858c:	f3af 8000 	nop.w

08008590 <otg_fifo_read_to_buffer>:
 * @notapi
 */
static void otg_fifo_read_to_buffer(volatile uint32_t *fifop,
                                    uint8_t *buf,
                                    size_t n,
                                    size_t max) {
 8008590:	b086      	sub	sp, #24
 8008592:	9003      	str	r0, [sp, #12]
 8008594:	9102      	str	r1, [sp, #8]
 8008596:	9201      	str	r2, [sp, #4]
 8008598:	9300      	str	r3, [sp, #0]
  uint32_t w = 0;
 800859a:	2300      	movs	r3, #0
 800859c:	9305      	str	r3, [sp, #20]
  size_t i = 0;
 800859e:	2300      	movs	r3, #0
 80085a0:	9304      	str	r3, [sp, #16]

  while (i < n) {
 80085a2:	e017      	b.n	80085d4 <otg_fifo_read_to_buffer+0x44>
    if ((i & 3) == 0){
 80085a4:	9b04      	ldr	r3, [sp, #16]
 80085a6:	f003 0303 	and.w	r3, r3, #3
 80085aa:	2b00      	cmp	r3, #0
 80085ac:	d102      	bne.n	80085b4 <otg_fifo_read_to_buffer+0x24>
      w = *fifop;
 80085ae:	9b03      	ldr	r3, [sp, #12]
 80085b0:	681b      	ldr	r3, [r3, #0]
 80085b2:	9305      	str	r3, [sp, #20]
    }
    if (i < max) {
 80085b4:	9a04      	ldr	r2, [sp, #16]
 80085b6:	9b00      	ldr	r3, [sp, #0]
 80085b8:	429a      	cmp	r2, r3
 80085ba:	d208      	bcs.n	80085ce <otg_fifo_read_to_buffer+0x3e>
      *buf++ = (uint8_t)w;
 80085bc:	9b02      	ldr	r3, [sp, #8]
 80085be:	1c5a      	adds	r2, r3, #1
 80085c0:	9202      	str	r2, [sp, #8]
 80085c2:	9a05      	ldr	r2, [sp, #20]
 80085c4:	b2d2      	uxtb	r2, r2
 80085c6:	701a      	strb	r2, [r3, #0]
      w >>= 8;
 80085c8:	9b05      	ldr	r3, [sp, #20]
 80085ca:	0a1b      	lsrs	r3, r3, #8
 80085cc:	9305      	str	r3, [sp, #20]
    }
    i++;
 80085ce:	9b04      	ldr	r3, [sp, #16]
 80085d0:	3301      	adds	r3, #1
 80085d2:	9304      	str	r3, [sp, #16]
                                    size_t n,
                                    size_t max) {
  uint32_t w = 0;
  size_t i = 0;

  while (i < n) {
 80085d4:	9a04      	ldr	r2, [sp, #16]
 80085d6:	9b01      	ldr	r3, [sp, #4]
 80085d8:	429a      	cmp	r2, r3
 80085da:	d3e3      	bcc.n	80085a4 <otg_fifo_read_to_buffer+0x14>
      *buf++ = (uint8_t)w;
      w >>= 8;
    }
    i++;
  }
}
 80085dc:	b006      	add	sp, #24
 80085de:	4770      	bx	lr

080085e0 <otg_rxfifo_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_rxfifo_handler(USBDriver *usbp) {
 80085e0:	b510      	push	{r4, lr}
 80085e2:	b086      	sub	sp, #24
 80085e4:	9001      	str	r0, [sp, #4]
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
 80085e6:	9b01      	ldr	r3, [sp, #4]
 80085e8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80085ea:	6a1b      	ldr	r3, [r3, #32]
 80085ec:	9305      	str	r3, [sp, #20]
  switch (sts & GRXSTSP_PKTSTS_MASK) {
 80085ee:	9b05      	ldr	r3, [sp, #20]
 80085f0:	f403 13f0 	and.w	r3, r3, #1966080	; 0x1e0000
 80085f4:	f5b3 2f00 	cmp.w	r3, #524288	; 0x80000
 80085f8:	d074      	beq.n	80086e4 <otg_rxfifo_handler+0x104>
 80085fa:	f5b3 2f40 	cmp.w	r3, #786432	; 0xc0000
 80085fe:	d003      	beq.n	8008608 <otg_rxfifo_handler+0x28>
 8008600:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008604:	d01c      	beq.n	8008640 <otg_rxfifo_handler+0x60>
 8008606:	e06e      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_SETUP_COMP:
    break;
  case GRXSTSP_SETUP_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008608:	9a05      	ldr	r2, [sp, #20]
 800860a:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 800860e:	4013      	ands	r3, r2
 8008610:	091b      	lsrs	r3, r3, #4
 8008612:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 8008614:	9b05      	ldr	r3, [sp, #20]
 8008616:	f003 030f 	and.w	r3, r3, #15
 800861a:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0], usbp->epc[ep]->setup_buf,
 800861c:	9b01      	ldr	r3, [sp, #4]
 800861e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008620:	f503 5280 	add.w	r2, r3, #4096	; 0x1000
 8008624:	9901      	ldr	r1, [sp, #4]
 8008626:	9b03      	ldr	r3, [sp, #12]
 8008628:	3302      	adds	r3, #2
 800862a:	009b      	lsls	r3, r3, #2
 800862c:	440b      	add	r3, r1
 800862e:	685b      	ldr	r3, [r3, #4]
 8008630:	6a1b      	ldr	r3, [r3, #32]
 8008632:	4610      	mov	r0, r2
 8008634:	4619      	mov	r1, r3
 8008636:	9a04      	ldr	r2, [sp, #16]
 8008638:	2308      	movs	r3, #8
 800863a:	f7ff ffa9 	bl	8008590 <otg_fifo_read_to_buffer>
                            cnt, 8);
    break;
 800863e:	e052      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
 8008640:	9a05      	ldr	r2, [sp, #20]
 8008642:	f647 73f0 	movw	r3, #32752	; 0x7ff0
 8008646:	4013      	ands	r3, r2
 8008648:	091b      	lsrs	r3, r3, #4
 800864a:	9304      	str	r3, [sp, #16]
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
 800864c:	9b05      	ldr	r3, [sp, #20]
 800864e:	f003 030f 	and.w	r3, r3, #15
 8008652:	9303      	str	r3, [sp, #12]
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 8008654:	9b01      	ldr	r3, [sp, #4]
 8008656:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008658:	f503 5180 	add.w	r1, r3, #4096	; 0x1000
                            usbp->epc[ep]->out_state->rxbuf,
 800865c:	9a01      	ldr	r2, [sp, #4]
 800865e:	9b03      	ldr	r3, [sp, #12]
 8008660:	3302      	adds	r3, #2
 8008662:	009b      	lsls	r3, r3, #2
 8008664:	4413      	add	r3, r2
 8008666:	685b      	ldr	r3, [r3, #4]
 8008668:	699b      	ldr	r3, [r3, #24]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800866a:	689a      	ldr	r2, [r3, #8]
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
 800866c:	9801      	ldr	r0, [sp, #4]
 800866e:	9b03      	ldr	r3, [sp, #12]
 8008670:	3302      	adds	r3, #2
 8008672:	009b      	lsls	r3, r3, #2
 8008674:	4403      	add	r3, r0
 8008676:	685b      	ldr	r3, [r3, #4]
 8008678:	699b      	ldr	r3, [r3, #24]
 800867a:	6818      	ldr	r0, [r3, #0]
                            usbp->epc[ep]->out_state->rxcnt);
 800867c:	9c01      	ldr	r4, [sp, #4]
 800867e:	9b03      	ldr	r3, [sp, #12]
 8008680:	3302      	adds	r3, #2
 8008682:	009b      	lsls	r3, r3, #2
 8008684:	4423      	add	r3, r4
 8008686:	685b      	ldr	r3, [r3, #4]
 8008688:	699b      	ldr	r3, [r3, #24]
 800868a:	685b      	ldr	r3, [r3, #4]
                            cnt, 8);
    break;
  case GRXSTSP_OUT_DATA:
    cnt = (sts & GRXSTSP_BCNT_MASK) >> GRXSTSP_BCNT_OFF;
    ep  = (sts & GRXSTSP_EPNUM_MASK) >> GRXSTSP_EPNUM_OFF;
    otg_fifo_read_to_buffer(usbp->otg->FIFO[0],
 800868c:	1ac3      	subs	r3, r0, r3
 800868e:	4608      	mov	r0, r1
 8008690:	4611      	mov	r1, r2
 8008692:	9a04      	ldr	r2, [sp, #16]
 8008694:	f7ff ff7c 	bl	8008590 <otg_fifo_read_to_buffer>
                            usbp->epc[ep]->out_state->rxbuf,
                            cnt,
                            usbp->epc[ep]->out_state->rxsize -
                            usbp->epc[ep]->out_state->rxcnt);
    usbp->epc[ep]->out_state->rxbuf += cnt;
 8008698:	9a01      	ldr	r2, [sp, #4]
 800869a:	9b03      	ldr	r3, [sp, #12]
 800869c:	3302      	adds	r3, #2
 800869e:	009b      	lsls	r3, r3, #2
 80086a0:	4413      	add	r3, r2
 80086a2:	685b      	ldr	r3, [r3, #4]
 80086a4:	699a      	ldr	r2, [r3, #24]
 80086a6:	9901      	ldr	r1, [sp, #4]
 80086a8:	9b03      	ldr	r3, [sp, #12]
 80086aa:	3302      	adds	r3, #2
 80086ac:	009b      	lsls	r3, r3, #2
 80086ae:	440b      	add	r3, r1
 80086b0:	685b      	ldr	r3, [r3, #4]
 80086b2:	699b      	ldr	r3, [r3, #24]
 80086b4:	6899      	ldr	r1, [r3, #8]
 80086b6:	9b04      	ldr	r3, [sp, #16]
 80086b8:	440b      	add	r3, r1
 80086ba:	6093      	str	r3, [r2, #8]
    usbp->epc[ep]->out_state->rxcnt += cnt;
 80086bc:	9a01      	ldr	r2, [sp, #4]
 80086be:	9b03      	ldr	r3, [sp, #12]
 80086c0:	3302      	adds	r3, #2
 80086c2:	009b      	lsls	r3, r3, #2
 80086c4:	4413      	add	r3, r2
 80086c6:	685b      	ldr	r3, [r3, #4]
 80086c8:	699a      	ldr	r2, [r3, #24]
 80086ca:	9901      	ldr	r1, [sp, #4]
 80086cc:	9b03      	ldr	r3, [sp, #12]
 80086ce:	3302      	adds	r3, #2
 80086d0:	009b      	lsls	r3, r3, #2
 80086d2:	440b      	add	r3, r1
 80086d4:	685b      	ldr	r3, [r3, #4]
 80086d6:	699b      	ldr	r3, [r3, #24]
 80086d8:	6859      	ldr	r1, [r3, #4]
 80086da:	9b04      	ldr	r3, [sp, #16]
 80086dc:	440b      	add	r3, r1
 80086de:	6053      	str	r3, [r2, #4]
    break;
 80086e0:	bf00      	nop
 80086e2:	e000      	b.n	80086e6 <otg_rxfifo_handler+0x106>
  uint32_t sts, cnt, ep;

  sts = usbp->otg->GRXSTSP;
  switch (sts & GRXSTSP_PKTSTS_MASK) {
  case GRXSTSP_SETUP_COMP:
    break;
 80086e4:	bf00      	nop
  case GRXSTSP_OUT_GLOBAL_NAK:
  case GRXSTSP_OUT_COMP:
  default:
    ;
  }
}
 80086e6:	b006      	add	sp, #24
 80086e8:	bd10      	pop	{r4, pc}
 80086ea:	bf00      	nop
 80086ec:	f3af 8000 	nop.w

080086f0 <otg_txfifo_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static bool otg_txfifo_handler(USBDriver *usbp, usbep_t ep) {
 80086f0:	b500      	push	{lr}
 80086f2:	b085      	sub	sp, #20
 80086f4:	9001      	str	r0, [sp, #4]
 80086f6:	460b      	mov	r3, r1
 80086f8:	f88d 3003 	strb.w	r3, [sp, #3]
  /* The TXFIFO is filled until there is space and data to be transmitted.*/
  while (true) {
    uint32_t n;

    /* Transaction end condition.*/
    if (usbp->epc[ep]->in_state->txcnt >= usbp->epc[ep]->in_state->txsize)
 80086fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008700:	9a01      	ldr	r2, [sp, #4]
 8008702:	3302      	adds	r3, #2
 8008704:	009b      	lsls	r3, r3, #2
 8008706:	4413      	add	r3, r2
 8008708:	685b      	ldr	r3, [r3, #4]
 800870a:	695b      	ldr	r3, [r3, #20]
 800870c:	685a      	ldr	r2, [r3, #4]
 800870e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008712:	9901      	ldr	r1, [sp, #4]
 8008714:	3302      	adds	r3, #2
 8008716:	009b      	lsls	r3, r3, #2
 8008718:	440b      	add	r3, r1
 800871a:	685b      	ldr	r3, [r3, #4]
 800871c:	695b      	ldr	r3, [r3, #20]
 800871e:	681b      	ldr	r3, [r3, #0]
 8008720:	429a      	cmp	r2, r3
 8008722:	d301      	bcc.n	8008728 <otg_txfifo_handler+0x38>
      return true;
 8008724:	2301      	movs	r3, #1
 8008726:	e076      	b.n	8008816 <otg_txfifo_handler+0x126>

    /* Number of bytes remaining in current transaction.*/
    n = usbp->epc[ep]->in_state->txsize - usbp->epc[ep]->in_state->txcnt;
 8008728:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800872c:	9a01      	ldr	r2, [sp, #4]
 800872e:	3302      	adds	r3, #2
 8008730:	009b      	lsls	r3, r3, #2
 8008732:	4413      	add	r3, r2
 8008734:	685b      	ldr	r3, [r3, #4]
 8008736:	695b      	ldr	r3, [r3, #20]
 8008738:	681a      	ldr	r2, [r3, #0]
 800873a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800873e:	9901      	ldr	r1, [sp, #4]
 8008740:	3302      	adds	r3, #2
 8008742:	009b      	lsls	r3, r3, #2
 8008744:	440b      	add	r3, r1
 8008746:	685b      	ldr	r3, [r3, #4]
 8008748:	695b      	ldr	r3, [r3, #20]
 800874a:	685b      	ldr	r3, [r3, #4]
 800874c:	1ad3      	subs	r3, r2, r3
 800874e:	9303      	str	r3, [sp, #12]
    if (n > usbp->epc[ep]->in_maxsize)
 8008750:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008754:	9a01      	ldr	r2, [sp, #4]
 8008756:	3302      	adds	r3, #2
 8008758:	009b      	lsls	r3, r3, #2
 800875a:	4413      	add	r3, r2
 800875c:	685b      	ldr	r3, [r3, #4]
 800875e:	8a1b      	ldrh	r3, [r3, #16]
 8008760:	461a      	mov	r2, r3
 8008762:	9b03      	ldr	r3, [sp, #12]
 8008764:	429a      	cmp	r2, r3
 8008766:	d208      	bcs.n	800877a <otg_txfifo_handler+0x8a>
      n = usbp->epc[ep]->in_maxsize;
 8008768:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800876c:	9a01      	ldr	r2, [sp, #4]
 800876e:	3302      	adds	r3, #2
 8008770:	009b      	lsls	r3, r3, #2
 8008772:	4413      	add	r3, r2
 8008774:	685b      	ldr	r3, [r3, #4]
 8008776:	8a1b      	ldrh	r3, [r3, #16]
 8008778:	9303      	str	r3, [sp, #12]

    /* Checks if in the TXFIFO there is enough space to accommodate the
       next packet.*/
    if (((usbp->otg->ie[ep].DTXFSTS & DTXFSTS_INEPTFSAV_MASK) * 4) < n)
 800877a:	9b01      	ldr	r3, [sp, #4]
 800877c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800877e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008782:	015b      	lsls	r3, r3, #5
 8008784:	4413      	add	r3, r2
 8008786:	f603 1318 	addw	r3, r3, #2328	; 0x918
 800878a:	681b      	ldr	r3, [r3, #0]
 800878c:	b29b      	uxth	r3, r3
 800878e:	009a      	lsls	r2, r3, #2
 8008790:	9b03      	ldr	r3, [sp, #12]
 8008792:	429a      	cmp	r2, r3
 8008794:	d201      	bcs.n	800879a <otg_txfifo_handler+0xaa>
      return false;
 8008796:	2300      	movs	r3, #0
 8008798:	e03d      	b.n	8008816 <otg_txfifo_handler+0x126>

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 800879a:	9b01      	ldr	r3, [sp, #4]
 800879c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800879e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087a2:	3301      	adds	r3, #1
 80087a4:	031b      	lsls	r3, r3, #12
 80087a6:	441a      	add	r2, r3
                               usbp->epc[ep]->in_state->txbuf,
 80087a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087ac:	9901      	ldr	r1, [sp, #4]
 80087ae:	3302      	adds	r3, #2
 80087b0:	009b      	lsls	r3, r3, #2
 80087b2:	440b      	add	r3, r1
 80087b4:	685b      	ldr	r3, [r3, #4]
 80087b6:	695b      	ldr	r3, [r3, #20]
      return false;

#if STM32_USB_OTGFIFO_FILL_BASEPRI
    __set_BASEPRI(CORTEX_PRIO_MASK(STM32_USB_OTGFIFO_FILL_BASEPRI));
#endif
    otg_fifo_write_from_buffer(usbp->otg->FIFO[ep],
 80087b8:	689b      	ldr	r3, [r3, #8]
 80087ba:	4610      	mov	r0, r2
 80087bc:	4619      	mov	r1, r3
 80087be:	9a03      	ldr	r2, [sp, #12]
 80087c0:	f7ff fece 	bl	8008560 <otg_fifo_write_from_buffer>
                               usbp->epc[ep]->in_state->txbuf,
                               n);
    usbp->epc[ep]->in_state->txbuf += n;
 80087c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087c8:	9a01      	ldr	r2, [sp, #4]
 80087ca:	3302      	adds	r3, #2
 80087cc:	009b      	lsls	r3, r3, #2
 80087ce:	4413      	add	r3, r2
 80087d0:	685b      	ldr	r3, [r3, #4]
 80087d2:	695a      	ldr	r2, [r3, #20]
 80087d4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087d8:	9901      	ldr	r1, [sp, #4]
 80087da:	3302      	adds	r3, #2
 80087dc:	009b      	lsls	r3, r3, #2
 80087de:	440b      	add	r3, r1
 80087e0:	685b      	ldr	r3, [r3, #4]
 80087e2:	695b      	ldr	r3, [r3, #20]
 80087e4:	6899      	ldr	r1, [r3, #8]
 80087e6:	9b03      	ldr	r3, [sp, #12]
 80087e8:	440b      	add	r3, r1
 80087ea:	6093      	str	r3, [r2, #8]
#if STM32_USB_OTGFIFO_FILL_BASEPRI
  __set_BASEPRI(0);
#endif
    usbp->epc[ep]->in_state->txcnt += n;
 80087ec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80087f0:	9a01      	ldr	r2, [sp, #4]
 80087f2:	3302      	adds	r3, #2
 80087f4:	009b      	lsls	r3, r3, #2
 80087f6:	4413      	add	r3, r2
 80087f8:	685b      	ldr	r3, [r3, #4]
 80087fa:	695a      	ldr	r2, [r3, #20]
 80087fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008800:	9901      	ldr	r1, [sp, #4]
 8008802:	3302      	adds	r3, #2
 8008804:	009b      	lsls	r3, r3, #2
 8008806:	440b      	add	r3, r1
 8008808:	685b      	ldr	r3, [r3, #4]
 800880a:	695b      	ldr	r3, [r3, #20]
 800880c:	6859      	ldr	r1, [r3, #4]
 800880e:	9b03      	ldr	r3, [sp, #12]
 8008810:	440b      	add	r3, r1
 8008812:	6053      	str	r3, [r2, #4]
  }
 8008814:	e772      	b.n	80086fc <otg_txfifo_handler+0xc>
}
 8008816:	4618      	mov	r0, r3
 8008818:	b005      	add	sp, #20
 800881a:	f85d fb04 	ldr.w	pc, [sp], #4
 800881e:	bf00      	nop

08008820 <otg_epin_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epin_handler(USBDriver *usbp, usbep_t ep) {
 8008820:	b500      	push	{lr}
 8008822:	b087      	sub	sp, #28
 8008824:	9001      	str	r0, [sp, #4]
 8008826:	460b      	mov	r3, r1
 8008828:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800882c:	9b01      	ldr	r3, [sp, #4]
 800882e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008830:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->ie[ep].DIEPINT;
 8008832:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008836:	9a05      	ldr	r2, [sp, #20]
 8008838:	015b      	lsls	r3, r3, #5
 800883a:	4413      	add	r3, r2
 800883c:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008840:	681b      	ldr	r3, [r3, #0]
 8008842:	9304      	str	r3, [sp, #16]

  otgp->ie[ep].DIEPINT = epint;
 8008844:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008848:	9a05      	ldr	r2, [sp, #20]
 800884a:	015b      	lsls	r3, r3, #5
 800884c:	4413      	add	r3, r2
 800884e:	f603 1308 	addw	r3, r3, #2312	; 0x908
 8008852:	9a04      	ldr	r2, [sp, #16]
 8008854:	601a      	str	r2, [r3, #0]

  if (epint & DIEPINT_TOC) {
    /* Timeouts not handled yet, not sure how to handle.*/
  }
  if ((epint & DIEPINT_XFRC) && (otgp->DIEPMSK & DIEPMSK_XFRCM)) {
 8008856:	9b04      	ldr	r3, [sp, #16]
 8008858:	f003 0301 	and.w	r3, r3, #1
 800885c:	2b00      	cmp	r3, #0
 800885e:	d051      	beq.n	8008904 <otg_epin_handler+0xe4>
 8008860:	9b05      	ldr	r3, [sp, #20]
 8008862:	f8d3 3810 	ldr.w	r3, [r3, #2064]	; 0x810
 8008866:	f003 0301 	and.w	r3, r3, #1
 800886a:	2b00      	cmp	r3, #0
 800886c:	d04a      	beq.n	8008904 <otg_epin_handler+0xe4>
    /* Transmit transfer complete.*/
    USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800886e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008872:	9a01      	ldr	r2, [sp, #4]
 8008874:	3302      	adds	r3, #2
 8008876:	009b      	lsls	r3, r3, #2
 8008878:	4413      	add	r3, r2
 800887a:	685b      	ldr	r3, [r3, #4]
 800887c:	695b      	ldr	r3, [r3, #20]
 800887e:	9303      	str	r3, [sp, #12]

    if (isp->txsize < isp->totsize) {
 8008880:	9b03      	ldr	r3, [sp, #12]
 8008882:	681a      	ldr	r2, [r3, #0]
 8008884:	9b03      	ldr	r3, [sp, #12]
 8008886:	68db      	ldr	r3, [r3, #12]
 8008888:	429a      	cmp	r2, r3
 800888a:	d214      	bcs.n	80088b6 <otg_epin_handler+0x96>
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      isp->txsize = isp->totsize - isp->txsize;
 800888c:	9b03      	ldr	r3, [sp, #12]
 800888e:	68da      	ldr	r2, [r3, #12]
 8008890:	9b03      	ldr	r3, [sp, #12]
 8008892:	681b      	ldr	r3, [r3, #0]
 8008894:	1ad2      	subs	r2, r2, r3
 8008896:	9b03      	ldr	r3, [sp, #12]
 8008898:	601a      	str	r2, [r3, #0]
      isp->txcnt  = 0;
 800889a:	9b03      	ldr	r3, [sp, #12]
 800889c:	2200      	movs	r2, #0
 800889e:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 80088a0:	f7ff fd5e 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_in(usbp, ep);
 80088a4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088a8:	9801      	ldr	r0, [sp, #4]
 80088aa:	4619      	mov	r1, r3
 80088ac:	f000 fec0 	bl	8009630 <usb_lld_start_in>
      osalSysUnlockFromISR();
 80088b0:	f7ff fd5e 	bl	8008370 <osalSysUnlockFromISR>
 80088b4:	e026      	b.n	8008904 <otg_epin_handler+0xe4>
    }
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
 80088b6:	9b01      	ldr	r3, [sp, #4]
 80088b8:	891b      	ldrh	r3, [r3, #8]
 80088ba:	b29a      	uxth	r2, r3
 80088bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088c0:	2101      	movs	r1, #1
 80088c2:	fa01 f303 	lsl.w	r3, r1, r3
 80088c6:	b29b      	uxth	r3, r3
 80088c8:	43db      	mvns	r3, r3
 80088ca:	b29b      	uxth	r3, r3
 80088cc:	4013      	ands	r3, r2
 80088ce:	b29b      	uxth	r3, r3
 80088d0:	b29a      	uxth	r2, r3
 80088d2:	9b01      	ldr	r3, [sp, #4]
 80088d4:	811a      	strh	r2, [r3, #8]
 80088d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088da:	9a01      	ldr	r2, [sp, #4]
 80088dc:	3302      	adds	r3, #2
 80088de:	009b      	lsls	r3, r3, #2
 80088e0:	4413      	add	r3, r2
 80088e2:	685b      	ldr	r3, [r3, #4]
 80088e4:	689b      	ldr	r3, [r3, #8]
 80088e6:	2b00      	cmp	r3, #0
 80088e8:	d00c      	beq.n	8008904 <otg_epin_handler+0xe4>
 80088ea:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80088ee:	9a01      	ldr	r2, [sp, #4]
 80088f0:	3302      	adds	r3, #2
 80088f2:	009b      	lsls	r3, r3, #2
 80088f4:	4413      	add	r3, r2
 80088f6:	685b      	ldr	r3, [r3, #4]
 80088f8:	689b      	ldr	r3, [r3, #8]
 80088fa:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80088fe:	9801      	ldr	r0, [sp, #4]
 8008900:	4611      	mov	r1, r2
 8008902:	4798      	blx	r3
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008904:	9b04      	ldr	r3, [sp, #16]
 8008906:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800890a:	2b00      	cmp	r3, #0
 800890c:	d02b      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
 800890e:	9b05      	ldr	r3, [sp, #20]
 8008910:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008914:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008918:	2101      	movs	r1, #1
 800891a:	fa01 f303 	lsl.w	r3, r1, r3
 800891e:	4013      	ands	r3, r2
    else {
      /* End on IN transfer.*/
      _usb_isr_invoke_in_cb(usbp, ep);
    }
  }
  if ((epint & DIEPINT_TXFE) &&
 8008920:	2b00      	cmp	r3, #0
 8008922:	d020      	beq.n	8008966 <otg_epin_handler+0x146>
      (otgp->DIEPEMPMSK & DIEPEMPMSK_INEPTXFEM(ep))) {
    /* The thread is made ready, it will be scheduled on ISR exit.*/
    osalSysLockFromISR();
 8008924:	f7ff fd1c 	bl	8008360 <osalSysLockFromISR>
    usbp->txpending |= (1 << ep);
 8008928:	9b01      	ldr	r3, [sp, #4]
 800892a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800892c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008930:	2101      	movs	r1, #1
 8008932:	fa01 f303 	lsl.w	r3, r1, r3
 8008936:	431a      	orrs	r2, r3
 8008938:	9b01      	ldr	r3, [sp, #4]
 800893a:	679a      	str	r2, [r3, #120]	; 0x78
    otgp->DIEPEMPMSK &= ~(1 << ep);
 800893c:	9b05      	ldr	r3, [sp, #20]
 800893e:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008942:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008946:	2101      	movs	r1, #1
 8008948:	fa01 f303 	lsl.w	r3, r1, r3
 800894c:	43db      	mvns	r3, r3
 800894e:	401a      	ands	r2, r3
 8008950:	9b05      	ldr	r3, [sp, #20]
 8008952:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008956:	9b01      	ldr	r3, [sp, #4]
 8008958:	337c      	adds	r3, #124	; 0x7c
 800895a:	4618      	mov	r0, r3
 800895c:	2100      	movs	r1, #0
 800895e:	f7ff fd2f 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008962:	f7ff fd05 	bl	8008370 <osalSysUnlockFromISR>
  }
}
 8008966:	b007      	add	sp, #28
 8008968:	f85d fb04 	ldr.w	pc, [sp], #4
 800896c:	f3af 8000 	nop.w

08008970 <otg_epout_handler>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
static void otg_epout_handler(USBDriver *usbp, usbep_t ep) {
 8008970:	b500      	push	{lr}
 8008972:	b087      	sub	sp, #28
 8008974:	9001      	str	r0, [sp, #4]
 8008976:	460b      	mov	r3, r1
 8008978:	f88d 3003 	strb.w	r3, [sp, #3]
  stm32_otg_t *otgp = usbp->otg;
 800897c:	9b01      	ldr	r3, [sp, #4]
 800897e:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008980:	9305      	str	r3, [sp, #20]
  uint32_t epint = otgp->oe[ep].DOEPINT;
 8008982:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008986:	9a05      	ldr	r2, [sp, #20]
 8008988:	015b      	lsls	r3, r3, #5
 800898a:	4413      	add	r3, r2
 800898c:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 8008990:	681b      	ldr	r3, [r3, #0]
 8008992:	9304      	str	r3, [sp, #16]

  /* Resets all EP IRQ sources.*/
  otgp->oe[ep].DOEPINT = epint;
 8008994:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008998:	9a05      	ldr	r2, [sp, #20]
 800899a:	015b      	lsls	r3, r3, #5
 800899c:	4413      	add	r3, r2
 800899e:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80089a2:	9a04      	ldr	r2, [sp, #16]
 80089a4:	601a      	str	r2, [r3, #0]

  if ((epint & DOEPINT_STUP) && (otgp->DOEPMSK & DOEPMSK_STUPM)) {
 80089a6:	9b04      	ldr	r3, [sp, #16]
 80089a8:	f003 0308 	and.w	r3, r3, #8
 80089ac:	2b00      	cmp	r3, #0
 80089ae:	d013      	beq.n	80089d8 <otg_epout_handler+0x68>
 80089b0:	9b05      	ldr	r3, [sp, #20]
 80089b2:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089b6:	f003 0308 	and.w	r3, r3, #8
 80089ba:	2b00      	cmp	r3, #0
 80089bc:	d00c      	beq.n	80089d8 <otg_epout_handler+0x68>
    /* Setup packets handling, setup packets are handled using a
       specific callback.*/
    _usb_isr_invoke_setup_cb(usbp, ep);
 80089be:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089c2:	9a01      	ldr	r2, [sp, #4]
 80089c4:	3302      	adds	r3, #2
 80089c6:	009b      	lsls	r3, r3, #2
 80089c8:	4413      	add	r3, r2
 80089ca:	685b      	ldr	r3, [r3, #4]
 80089cc:	685b      	ldr	r3, [r3, #4]
 80089ce:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80089d2:	9801      	ldr	r0, [sp, #4]
 80089d4:	4611      	mov	r1, r2
 80089d6:	4798      	blx	r3
  }
  if ((epint & DOEPINT_XFRC) && (otgp->DOEPMSK & DOEPMSK_XFRCM)) {
 80089d8:	9b04      	ldr	r3, [sp, #16]
 80089da:	f003 0301 	and.w	r3, r3, #1
 80089de:	2b00      	cmp	r3, #0
 80089e0:	d06c      	beq.n	8008abc <otg_epout_handler+0x14c>
 80089e2:	9b05      	ldr	r3, [sp, #20]
 80089e4:	f8d3 3814 	ldr.w	r3, [r3, #2068]	; 0x814
 80089e8:	f003 0301 	and.w	r3, r3, #1
 80089ec:	2b00      	cmp	r3, #0
 80089ee:	d065      	beq.n	8008abc <otg_epout_handler+0x14c>
    USBOutEndpointState *osp;

    /* Receive transfer complete, checking if it is a SETUP transfer on EP0,
       that it must be ignored, the STUPM handler will take care of it.*/
    if ((ep == 0) && (usbp->ep0state == USB_EP0_WAITING_SETUP))
 80089f0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80089f4:	2b00      	cmp	r3, #0
 80089f6:	d105      	bne.n	8008a04 <otg_epout_handler+0x94>
 80089f8:	9b01      	ldr	r3, [sp, #4]
 80089fa:	f893 304c 	ldrb.w	r3, [r3, #76]	; 0x4c
 80089fe:	2b00      	cmp	r3, #0
 8008a00:	d100      	bne.n	8008a04 <otg_epout_handler+0x94>
      return;
 8008a02:	e05b      	b.n	8008abc <otg_epout_handler+0x14c>

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;
 8008a04:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a08:	9a01      	ldr	r2, [sp, #4]
 8008a0a:	3302      	adds	r3, #2
 8008a0c:	009b      	lsls	r3, r3, #2
 8008a0e:	4413      	add	r3, r2
 8008a10:	685b      	ldr	r3, [r3, #4]
 8008a12:	699b      	ldr	r3, [r3, #24]
 8008a14:	9303      	str	r3, [sp, #12]

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a16:	9b03      	ldr	r3, [sp, #12]
 8008a18:	685a      	ldr	r2, [r3, #4]
 8008a1a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a1e:	9901      	ldr	r1, [sp, #4]
 8008a20:	3302      	adds	r3, #2
 8008a22:	009b      	lsls	r3, r3, #2
 8008a24:	440b      	add	r3, r1
 8008a26:	685b      	ldr	r3, [r3, #4]
 8008a28:	8a5b      	ldrh	r3, [r3, #18]
 8008a2a:	fbb2 f1f3 	udiv	r1, r2, r3
 8008a2e:	fb03 f301 	mul.w	r3, r3, r1
 8008a32:	1ad3      	subs	r3, r2, r3
 8008a34:	2b00      	cmp	r3, #0
 8008a36:	d11a      	bne.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
 8008a38:	9b03      	ldr	r3, [sp, #12]
 8008a3a:	681a      	ldr	r2, [r3, #0]
 8008a3c:	9b03      	ldr	r3, [sp, #12]
 8008a3e:	68db      	ldr	r3, [r3, #12]

    /* OUT state structure pointer for this endpoint.*/
    osp = usbp->epc[ep]->out_state;

    /* A short packet always terminates a transaction.*/
    if (((osp->rxcnt % usbp->epc[ep]->out_maxsize) == 0) &&
 8008a40:	429a      	cmp	r2, r3
 8008a42:	d214      	bcs.n	8008a6e <otg_epout_handler+0xfe>
        (osp->rxsize < osp->totsize)) {
      /* In case the transaction covered only part of the total transfer
         then another transaction is immediately started in order to
         cover the remaining.*/
      osp->rxsize = osp->totsize - osp->rxsize;
 8008a44:	9b03      	ldr	r3, [sp, #12]
 8008a46:	68da      	ldr	r2, [r3, #12]
 8008a48:	9b03      	ldr	r3, [sp, #12]
 8008a4a:	681b      	ldr	r3, [r3, #0]
 8008a4c:	1ad2      	subs	r2, r2, r3
 8008a4e:	9b03      	ldr	r3, [sp, #12]
 8008a50:	601a      	str	r2, [r3, #0]
      osp->rxcnt  = 0;
 8008a52:	9b03      	ldr	r3, [sp, #12]
 8008a54:	2200      	movs	r2, #0
 8008a56:	605a      	str	r2, [r3, #4]
      osalSysLockFromISR();
 8008a58:	f7ff fc82 	bl	8008360 <osalSysLockFromISR>
      usb_lld_start_out(usbp, ep);
 8008a5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a60:	9801      	ldr	r0, [sp, #4]
 8008a62:	4619      	mov	r1, r3
 8008a64:	f000 fd44 	bl	80094f0 <usb_lld_start_out>
      osalSysUnlockFromISR();
 8008a68:	f7ff fc82 	bl	8008370 <osalSysUnlockFromISR>
 8008a6c:	e026      	b.n	8008abc <otg_epout_handler+0x14c>
    }
    else {
      /* End on OUT transfer.*/
      _usb_isr_invoke_out_cb(usbp, ep);
 8008a6e:	9b01      	ldr	r3, [sp, #4]
 8008a70:	895b      	ldrh	r3, [r3, #10]
 8008a72:	b29a      	uxth	r2, r3
 8008a74:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a78:	2101      	movs	r1, #1
 8008a7a:	fa01 f303 	lsl.w	r3, r1, r3
 8008a7e:	b29b      	uxth	r3, r3
 8008a80:	43db      	mvns	r3, r3
 8008a82:	b29b      	uxth	r3, r3
 8008a84:	4013      	ands	r3, r2
 8008a86:	b29b      	uxth	r3, r3
 8008a88:	b29a      	uxth	r2, r3
 8008a8a:	9b01      	ldr	r3, [sp, #4]
 8008a8c:	815a      	strh	r2, [r3, #10]
 8008a8e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008a92:	9a01      	ldr	r2, [sp, #4]
 8008a94:	3302      	adds	r3, #2
 8008a96:	009b      	lsls	r3, r3, #2
 8008a98:	4413      	add	r3, r2
 8008a9a:	685b      	ldr	r3, [r3, #4]
 8008a9c:	68db      	ldr	r3, [r3, #12]
 8008a9e:	2b00      	cmp	r3, #0
 8008aa0:	d00c      	beq.n	8008abc <otg_epout_handler+0x14c>
 8008aa2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8008aa6:	9a01      	ldr	r2, [sp, #4]
 8008aa8:	3302      	adds	r3, #2
 8008aaa:	009b      	lsls	r3, r3, #2
 8008aac:	4413      	add	r3, r2
 8008aae:	685b      	ldr	r3, [r3, #4]
 8008ab0:	68db      	ldr	r3, [r3, #12]
 8008ab2:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8008ab6:	9801      	ldr	r0, [sp, #4]
 8008ab8:	4611      	mov	r1, r2
 8008aba:	4798      	blx	r3
    }
  }
}
 8008abc:	b007      	add	sp, #28
 8008abe:	f85d fb04 	ldr.w	pc, [sp], #4
 8008ac2:	bf00      	nop
 8008ac4:	f3af 8000 	nop.w
 8008ac8:	f3af 8000 	nop.w
 8008acc:	f3af 8000 	nop.w

08008ad0 <otg_isoc_in_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
 8008ad0:	b500      	push	{lr}
 8008ad2:	b085      	sub	sp, #20
 8008ad4:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008ad6:	9b01      	ldr	r3, [sp, #4]
 8008ad8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008ada:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008adc:	2300      	movs	r3, #0
 8008ade:	f88d 300f 	strb.w	r3, [sp, #15]
 8008ae2:	e081      	b.n	8008be8 <otg_isoc_in_failed_handler+0x118>
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008ae4:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008ae8:	9a02      	ldr	r2, [sp, #8]
 8008aea:	3348      	adds	r3, #72	; 0x48
 8008aec:	015b      	lsls	r3, r3, #5
 8008aee:	4413      	add	r3, r2
 8008af0:	681b      	ldr	r3, [r3, #0]
 8008af2:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008af6:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008afa:	d170      	bne.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
 8008afc:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b00:	9a02      	ldr	r2, [sp, #8]
 8008b02:	3348      	adds	r3, #72	; 0x48
 8008b04:	015b      	lsls	r3, r3, #5
 8008b06:	4413      	add	r3, r2
 8008b08:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->ie[ep].DIEPCTL & DIEPCTL_EPTYP_MASK) == DIEPCTL_EPTYP_ISO) &&
 8008b0a:	2b00      	cmp	r3, #0
 8008b0c:	da67      	bge.n	8008bde <otg_isoc_in_failed_handler+0x10e>
        ((otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA) != 0)) {
      /* Endpoint enabled -> ISOC IN transfer failed */
      /* Disable endpoint */
      otgp->ie[ep].DIEPCTL |= (DIEPCTL_EPDIS | DIEPCTL_SNAK);
 8008b0e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b12:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b16:	9902      	ldr	r1, [sp, #8]
 8008b18:	3248      	adds	r2, #72	; 0x48
 8008b1a:	0152      	lsls	r2, r2, #5
 8008b1c:	440a      	add	r2, r1
 8008b1e:	6812      	ldr	r2, [r2, #0]
 8008b20:	f042 4290 	orr.w	r2, r2, #1207959552	; 0x48000000
 8008b24:	9902      	ldr	r1, [sp, #8]
 8008b26:	3348      	adds	r3, #72	; 0x48
 8008b28:	015b      	lsls	r3, r3, #5
 8008b2a:	440b      	add	r3, r1
 8008b2c:	601a      	str	r2, [r3, #0]
      while (otgp->ie[ep].DIEPCTL & DIEPCTL_EPENA)
 8008b2e:	bf00      	nop
 8008b30:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b34:	9a02      	ldr	r2, [sp, #8]
 8008b36:	3348      	adds	r3, #72	; 0x48
 8008b38:	015b      	lsls	r3, r3, #5
 8008b3a:	4413      	add	r3, r2
 8008b3c:	681b      	ldr	r3, [r3, #0]
 8008b3e:	2b00      	cmp	r3, #0
 8008b40:	dbf6      	blt.n	8008b30 <otg_isoc_in_failed_handler+0x60>
        ;

      /* Flush FIFO */
      otg_txfifo_flush(usbp, ep);
 8008b42:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b46:	9801      	ldr	r0, [sp, #4]
 8008b48:	4619      	mov	r1, r3
 8008b4a:	f7ff fcc9 	bl	80084e0 <otg_txfifo_flush>

      /* Prepare data for next frame */
      _usb_isr_invoke_in_cb(usbp, ep);
 8008b4e:	9b01      	ldr	r3, [sp, #4]
 8008b50:	891b      	ldrh	r3, [r3, #8]
 8008b52:	b29a      	uxth	r2, r3
 8008b54:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b58:	2101      	movs	r1, #1
 8008b5a:	fa01 f303 	lsl.w	r3, r1, r3
 8008b5e:	b29b      	uxth	r3, r3
 8008b60:	43db      	mvns	r3, r3
 8008b62:	b29b      	uxth	r3, r3
 8008b64:	4013      	ands	r3, r2
 8008b66:	b29b      	uxth	r3, r3
 8008b68:	b29a      	uxth	r2, r3
 8008b6a:	9b01      	ldr	r3, [sp, #4]
 8008b6c:	811a      	strh	r2, [r3, #8]
 8008b6e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b72:	9a01      	ldr	r2, [sp, #4]
 8008b74:	3302      	adds	r3, #2
 8008b76:	009b      	lsls	r3, r3, #2
 8008b78:	4413      	add	r3, r2
 8008b7a:	685b      	ldr	r3, [r3, #4]
 8008b7c:	689b      	ldr	r3, [r3, #8]
 8008b7e:	2b00      	cmp	r3, #0
 8008b80:	d00c      	beq.n	8008b9c <otg_isoc_in_failed_handler+0xcc>
 8008b82:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008b86:	9a01      	ldr	r2, [sp, #4]
 8008b88:	3302      	adds	r3, #2
 8008b8a:	009b      	lsls	r3, r3, #2
 8008b8c:	4413      	add	r3, r2
 8008b8e:	685b      	ldr	r3, [r3, #4]
 8008b90:	689b      	ldr	r3, [r3, #8]
 8008b92:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008b96:	9801      	ldr	r0, [sp, #4]
 8008b98:	4611      	mov	r1, r2
 8008b9a:	4798      	blx	r3

      /* Pump out data for next frame */
      osalSysLockFromISR();
 8008b9c:	f7ff fbe0 	bl	8008360 <osalSysLockFromISR>
      otgp->DIEPEMPMSK &= ~(1 << ep);
 8008ba0:	9b02      	ldr	r3, [sp, #8]
 8008ba2:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 8008ba6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008baa:	2101      	movs	r1, #1
 8008bac:	fa01 f303 	lsl.w	r3, r1, r3
 8008bb0:	43db      	mvns	r3, r3
 8008bb2:	401a      	ands	r2, r3
 8008bb4:	9b02      	ldr	r3, [sp, #8]
 8008bb6:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
      usbp->txpending |= (1 << ep);
 8008bba:	9b01      	ldr	r3, [sp, #4]
 8008bbc:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8008bbe:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008bc2:	2101      	movs	r1, #1
 8008bc4:	fa01 f303 	lsl.w	r3, r1, r3
 8008bc8:	431a      	orrs	r2, r3
 8008bca:	9b01      	ldr	r3, [sp, #4]
 8008bcc:	679a      	str	r2, [r3, #120]	; 0x78
      osalThreadResumeI(&usbp->wait, MSG_OK);
 8008bce:	9b01      	ldr	r3, [sp, #4]
 8008bd0:	337c      	adds	r3, #124	; 0x7c
 8008bd2:	4618      	mov	r0, r3
 8008bd4:	2100      	movs	r1, #0
 8008bd6:	f7ff fbf3 	bl	80083c0 <osalThreadResumeI>
      osalSysUnlockFromISR();
 8008bda:	f7ff fbc9 	bl	8008370 <osalSysUnlockFromISR>
 */
static void otg_isoc_in_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008bde:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008be2:	3301      	adds	r3, #1
 8008be4:	f88d 300f 	strb.w	r3, [sp, #15]
 8008be8:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008bec:	9b01      	ldr	r3, [sp, #4]
 8008bee:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008bf0:	689b      	ldr	r3, [r3, #8]
 8008bf2:	429a      	cmp	r2, r3
 8008bf4:	f67f af76 	bls.w	8008ae4 <otg_isoc_in_failed_handler+0x14>
      usbp->txpending |= (1 << ep);
      osalThreadResumeI(&usbp->wait, MSG_OK);
      osalSysUnlockFromISR();
    }
  }
}
 8008bf8:	b005      	add	sp, #20
 8008bfa:	f85d fb04 	ldr.w	pc, [sp], #4
 8008bfe:	bf00      	nop

08008c00 <otg_isoc_out_failed_handler>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
 8008c00:	b500      	push	{lr}
 8008c02:	b085      	sub	sp, #20
 8008c04:	9001      	str	r0, [sp, #4]
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;
 8008c06:	9b01      	ldr	r3, [sp, #4]
 8008c08:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008c0a:	9302      	str	r3, [sp, #8]

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c0c:	2300      	movs	r3, #0
 8008c0e:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c12:	e040      	b.n	8008c96 <otg_isoc_out_failed_handler+0x96>
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c14:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c18:	9a02      	ldr	r2, [sp, #8]
 8008c1a:	3358      	adds	r3, #88	; 0x58
 8008c1c:	015b      	lsls	r3, r3, #5
 8008c1e:	4413      	add	r3, r2
 8008c20:	681b      	ldr	r3, [r3, #0]
 8008c22:	f403 2340 	and.w	r3, r3, #786432	; 0xc0000
 8008c26:	f5b3 2f80 	cmp.w	r3, #262144	; 0x40000
 8008c2a:	d12f      	bne.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
        ((otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA) != 0)) {
 8008c2c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c30:	9a02      	ldr	r2, [sp, #8]
 8008c32:	3358      	adds	r3, #88	; 0x58
 8008c34:	015b      	lsls	r3, r3, #5
 8008c36:	4413      	add	r3, r2
 8008c38:	681b      	ldr	r3, [r3, #0]
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
    if (((otgp->oe[ep].DOEPCTL & DOEPCTL_EPTYP_MASK) == DOEPCTL_EPTYP_ISO) &&
 8008c3a:	2b00      	cmp	r3, #0
 8008c3c:	da26      	bge.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
      /* FIXME: Core stucks here */
      /*otgp->oe[ep].DOEPCTL |= (DOEPCTL_EPDIS | DOEPCTL_SNAK);
      while (otgp->oe[ep].DOEPCTL & DOEPCTL_EPENA)
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
 8008c3e:	9b01      	ldr	r3, [sp, #4]
 8008c40:	895b      	ldrh	r3, [r3, #10]
 8008c42:	b29a      	uxth	r2, r3
 8008c44:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c48:	2101      	movs	r1, #1
 8008c4a:	fa01 f303 	lsl.w	r3, r1, r3
 8008c4e:	b29b      	uxth	r3, r3
 8008c50:	43db      	mvns	r3, r3
 8008c52:	b29b      	uxth	r3, r3
 8008c54:	4013      	ands	r3, r2
 8008c56:	b29b      	uxth	r3, r3
 8008c58:	b29a      	uxth	r2, r3
 8008c5a:	9b01      	ldr	r3, [sp, #4]
 8008c5c:	815a      	strh	r2, [r3, #10]
 8008c5e:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c62:	9a01      	ldr	r2, [sp, #4]
 8008c64:	3302      	adds	r3, #2
 8008c66:	009b      	lsls	r3, r3, #2
 8008c68:	4413      	add	r3, r2
 8008c6a:	685b      	ldr	r3, [r3, #4]
 8008c6c:	68db      	ldr	r3, [r3, #12]
 8008c6e:	2b00      	cmp	r3, #0
 8008c70:	d00c      	beq.n	8008c8c <otg_isoc_out_failed_handler+0x8c>
 8008c72:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c76:	9a01      	ldr	r2, [sp, #4]
 8008c78:	3302      	adds	r3, #2
 8008c7a:	009b      	lsls	r3, r3, #2
 8008c7c:	4413      	add	r3, r2
 8008c7e:	685b      	ldr	r3, [r3, #4]
 8008c80:	68db      	ldr	r3, [r3, #12]
 8008c82:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c86:	9801      	ldr	r0, [sp, #4]
 8008c88:	4611      	mov	r1, r2
 8008c8a:	4798      	blx	r3
 */
static void otg_isoc_out_failed_handler(USBDriver *usbp) {
  usbep_t ep;
  stm32_otg_t *otgp = usbp->otg;

  for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 8008c8c:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8008c90:	3301      	adds	r3, #1
 8008c92:	f88d 300f 	strb.w	r3, [sp, #15]
 8008c96:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8008c9a:	9b01      	ldr	r3, [sp, #4]
 8008c9c:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 8008c9e:	689b      	ldr	r3, [r3, #8]
 8008ca0:	429a      	cmp	r2, r3
 8008ca2:	d9b7      	bls.n	8008c14 <otg_isoc_out_failed_handler+0x14>
        ;*/
      /* Prepare transfer for next frame */
      _usb_isr_invoke_out_cb(usbp, ep);
    }
  }
}
 8008ca4:	b005      	add	sp, #20
 8008ca6:	f85d fb04 	ldr.w	pc, [sp], #4
 8008caa:	bf00      	nop
 8008cac:	f3af 8000 	nop.w

08008cb0 <usb_lld_serve_interrupt>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
static void usb_lld_serve_interrupt(USBDriver *usbp) {
 8008cb0:	b500      	push	{lr}
 8008cb2:	b087      	sub	sp, #28
 8008cb4:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8008cb6:	9b01      	ldr	r3, [sp, #4]
 8008cb8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008cba:	9305      	str	r3, [sp, #20]
  uint32_t sts, src;

  sts  = otgp->GINTSTS;
 8008cbc:	9b05      	ldr	r3, [sp, #20]
 8008cbe:	695b      	ldr	r3, [r3, #20]
 8008cc0:	9304      	str	r3, [sp, #16]
  sts &= otgp->GINTMSK;
 8008cc2:	9b05      	ldr	r3, [sp, #20]
 8008cc4:	699b      	ldr	r3, [r3, #24]
 8008cc6:	9a04      	ldr	r2, [sp, #16]
 8008cc8:	4013      	ands	r3, r2
 8008cca:	9304      	str	r3, [sp, #16]
  otgp->GINTSTS = sts;
 8008ccc:	9b05      	ldr	r3, [sp, #20]
 8008cce:	9a04      	ldr	r2, [sp, #16]
 8008cd0:	615a      	str	r2, [r3, #20]

  /* Reset interrupt handling.*/
  if (sts & GINTSTS_USBRST) {
 8008cd2:	9b04      	ldr	r3, [sp, #16]
 8008cd4:	f403 5380 	and.w	r3, r3, #4096	; 0x1000
 8008cd8:	2b00      	cmp	r3, #0
 8008cda:	d006      	beq.n	8008cea <usb_lld_serve_interrupt+0x3a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008cdc:	9b01      	ldr	r3, [sp, #4]
 8008cde:	2200      	movs	r2, #0
 8008ce0:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default reset action.*/
    _usb_reset(usbp);
 8008ce2:	9801      	ldr	r0, [sp, #4]
 8008ce4:	f7fe f91c 	bl	8006f20 <_usb_reset>

    /* Preventing execution of more handlers, the core has been reset.*/
    return;
 8008ce8:	e0ce      	b.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
  }

  /* Wake-up handling.*/
  if (sts & GINTSTS_WKUPINT) {
 8008cea:	9b04      	ldr	r3, [sp, #16]
 8008cec:	2b00      	cmp	r3, #0
 8008cee:	da19      	bge.n	8008d24 <usb_lld_serve_interrupt+0x74>
    /* If clocks are gated off, turn them back on (may be the case if
       coming out of suspend mode).*/
    if (otgp->PCGCCTL & (PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK)) {
 8008cf0:	9b05      	ldr	r3, [sp, #20]
 8008cf2:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008cf6:	f003 0303 	and.w	r3, r3, #3
 8008cfa:	2b00      	cmp	r3, #0
 8008cfc:	d007      	beq.n	8008d0e <usb_lld_serve_interrupt+0x5e>
      /* Set to zero to un-gate the USB core clocks.*/
      otgp->PCGCCTL &= ~(PCGCCTL_STPPCLK | PCGCCTL_GATEHCLK);
 8008cfe:	9b05      	ldr	r3, [sp, #20]
 8008d00:	f8d3 3e00 	ldr.w	r3, [r3, #3584]	; 0xe00
 8008d04:	f023 0203 	bic.w	r2, r3, #3
 8008d08:	9b05      	ldr	r3, [sp, #20]
 8008d0a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00
    }

    /* Clear the Remote Wake-up Signaling.*/
    otgp->DCTL |= DCTL_RWUSIG;
 8008d0e:	9b05      	ldr	r3, [sp, #20]
 8008d10:	f8d3 3804 	ldr.w	r3, [r3, #2052]	; 0x804
 8008d14:	f043 0201 	orr.w	r2, r3, #1
 8008d18:	9b05      	ldr	r3, [sp, #20]
 8008d1a:	f8c3 2804 	str.w	r2, [r3, #2052]	; 0x804

    _usb_wakeup(usbp);
 8008d1e:	9801      	ldr	r0, [sp, #4]
 8008d20:	f7fe f95e 	bl	8006fe0 <_usb_wakeup>
  }

  /* Suspend handling.*/
  if (sts & GINTSTS_USBSUSP) {
 8008d24:	9b04      	ldr	r3, [sp, #16]
 8008d26:	f403 6300 	and.w	r3, r3, #2048	; 0x800
 8008d2a:	2b00      	cmp	r3, #0
 8008d2c:	d005      	beq.n	8008d3a <usb_lld_serve_interrupt+0x8a>

    /* Resetting pending operations.*/
    usbp->txpending = 0;
 8008d2e:	9b01      	ldr	r3, [sp, #4]
 8008d30:	2200      	movs	r2, #0
 8008d32:	679a      	str	r2, [r3, #120]	; 0x78

    /* Default suspend action.*/
    _usb_suspend(usbp);
 8008d34:	9801      	ldr	r0, [sp, #4]
 8008d36:	f7fe f933 	bl	8006fa0 <_usb_suspend>
  }

  /* Enumeration done.*/
  if (sts & GINTSTS_ENUMDNE) {
 8008d3a:	9b04      	ldr	r3, [sp, #16]
 8008d3c:	f403 5300 	and.w	r3, r3, #8192	; 0x2000
 8008d40:	2b00      	cmp	r3, #0
 8008d42:	d017      	beq.n	8008d74 <usb_lld_serve_interrupt+0xc4>
    /* Full or High speed timing selection.*/
    if ((otgp->DSTS & DSTS_ENUMSPD_MASK) == DSTS_ENUMSPD_HS_480) {
 8008d44:	9b05      	ldr	r3, [sp, #20]
 8008d46:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 8008d4a:	f003 0306 	and.w	r3, r3, #6
 8008d4e:	2b00      	cmp	r3, #0
 8008d50:	d108      	bne.n	8008d64 <usb_lld_serve_interrupt+0xb4>
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d52:	9b05      	ldr	r3, [sp, #20]
 8008d54:	68db      	ldr	r3, [r3, #12]
 8008d56:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d5a:	f443 5210 	orr.w	r2, r3, #9216	; 0x2400
 8008d5e:	9b05      	ldr	r3, [sp, #20]
 8008d60:	60da      	str	r2, [r3, #12]
 8008d62:	e007      	b.n	8008d74 <usb_lld_serve_interrupt+0xc4>
                      GUSBCFG_TRDT(TRDT_VALUE_HS);
    }
    else {
      otgp->GUSBCFG = (otgp->GUSBCFG & ~(GUSBCFG_TRDT_MASK)) |
 8008d64:	9b05      	ldr	r3, [sp, #20]
 8008d66:	68db      	ldr	r3, [r3, #12]
 8008d68:	f423 5370 	bic.w	r3, r3, #15360	; 0x3c00
 8008d6c:	f443 52a0 	orr.w	r2, r3, #5120	; 0x1400
 8008d70:	9b05      	ldr	r3, [sp, #20]
 8008d72:	60da      	str	r2, [r3, #12]
                      GUSBCFG_TRDT(TRDT_VALUE_FS);
    }
  }

  /* SOF interrupt handling.*/
  if (sts & GINTSTS_SOF) {
 8008d74:	9b04      	ldr	r3, [sp, #16]
 8008d76:	f003 0308 	and.w	r3, r3, #8
 8008d7a:	2b00      	cmp	r3, #0
 8008d7c:	d009      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
    _usb_isr_invoke_sof_cb(usbp);
 8008d7e:	9b01      	ldr	r3, [sp, #4]
 8008d80:	685b      	ldr	r3, [r3, #4]
 8008d82:	68db      	ldr	r3, [r3, #12]
 8008d84:	2b00      	cmp	r3, #0
 8008d86:	d004      	beq.n	8008d92 <usb_lld_serve_interrupt+0xe2>
 8008d88:	9b01      	ldr	r3, [sp, #4]
 8008d8a:	685b      	ldr	r3, [r3, #4]
 8008d8c:	68db      	ldr	r3, [r3, #12]
 8008d8e:	9801      	ldr	r0, [sp, #4]
 8008d90:	4798      	blx	r3
  }

  /* Isochronous IN failed handling */
  if (sts & GINTSTS_IISOIXFR) {
 8008d92:	9b04      	ldr	r3, [sp, #16]
 8008d94:	f403 1380 	and.w	r3, r3, #1048576	; 0x100000
 8008d98:	2b00      	cmp	r3, #0
 8008d9a:	d002      	beq.n	8008da2 <usb_lld_serve_interrupt+0xf2>
    otg_isoc_in_failed_handler(usbp);
 8008d9c:	9801      	ldr	r0, [sp, #4]
 8008d9e:	f7ff fe97 	bl	8008ad0 <otg_isoc_in_failed_handler>
  }

  /* Isochronous OUT failed handling */
  if (sts & GINTSTS_IISOOXFR) {
 8008da2:	9b04      	ldr	r3, [sp, #16]
 8008da4:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8008da8:	2b00      	cmp	r3, #0
 8008daa:	d002      	beq.n	8008db2 <usb_lld_serve_interrupt+0x102>
    otg_isoc_out_failed_handler(usbp);
 8008dac:	9801      	ldr	r0, [sp, #4]
 8008dae:	f7ff ff27 	bl	8008c00 <otg_isoc_out_failed_handler>
  }

  /* RX FIFO not empty handling.*/
  if (sts & GINTSTS_RXFLVL) {
 8008db2:	9b04      	ldr	r3, [sp, #16]
 8008db4:	f003 0310 	and.w	r3, r3, #16
 8008db8:	2b00      	cmp	r3, #0
 8008dba:	d00f      	beq.n	8008ddc <usb_lld_serve_interrupt+0x12c>
    /* The interrupt is masked while the thread has control or it would
       be triggered again.*/
    osalSysLockFromISR();
 8008dbc:	f7ff fad0 	bl	8008360 <osalSysLockFromISR>
    otgp->GINTMSK &= ~GINTMSK_RXFLVLM;
 8008dc0:	9b05      	ldr	r3, [sp, #20]
 8008dc2:	699b      	ldr	r3, [r3, #24]
 8008dc4:	f023 0210 	bic.w	r2, r3, #16
 8008dc8:	9b05      	ldr	r3, [sp, #20]
 8008dca:	619a      	str	r2, [r3, #24]
    osalThreadResumeI(&usbp->wait, MSG_OK);
 8008dcc:	9b01      	ldr	r3, [sp, #4]
 8008dce:	337c      	adds	r3, #124	; 0x7c
 8008dd0:	4618      	mov	r0, r3
 8008dd2:	2100      	movs	r1, #0
 8008dd4:	f7ff faf4 	bl	80083c0 <osalThreadResumeI>
    osalSysUnlockFromISR();
 8008dd8:	f7ff faca 	bl	8008370 <osalSysUnlockFromISR>
  }

  /* IN/OUT endpoints event handling.*/
  src = otgp->DAINT;
 8008ddc:	9b05      	ldr	r3, [sp, #20]
 8008dde:	f8d3 3818 	ldr.w	r3, [r3, #2072]	; 0x818
 8008de2:	9303      	str	r3, [sp, #12]
  if (sts & GINTSTS_IEPINT) {
 8008de4:	9b04      	ldr	r3, [sp, #16]
 8008de6:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008dea:	2b00      	cmp	r3, #0
 8008dec:	d023      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
    if (src & (1 << 0))
 8008dee:	9b03      	ldr	r3, [sp, #12]
 8008df0:	f003 0301 	and.w	r3, r3, #1
 8008df4:	2b00      	cmp	r3, #0
 8008df6:	d003      	beq.n	8008e00 <usb_lld_serve_interrupt+0x150>
      otg_epin_handler(usbp, 0);
 8008df8:	9801      	ldr	r0, [sp, #4]
 8008dfa:	2100      	movs	r1, #0
 8008dfc:	f7ff fd10 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 1))
 8008e00:	9b03      	ldr	r3, [sp, #12]
 8008e02:	f003 0302 	and.w	r3, r3, #2
 8008e06:	2b00      	cmp	r3, #0
 8008e08:	d003      	beq.n	8008e12 <usb_lld_serve_interrupt+0x162>
      otg_epin_handler(usbp, 1);
 8008e0a:	9801      	ldr	r0, [sp, #4]
 8008e0c:	2101      	movs	r1, #1
 8008e0e:	f7ff fd07 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 2))
 8008e12:	9b03      	ldr	r3, [sp, #12]
 8008e14:	f003 0304 	and.w	r3, r3, #4
 8008e18:	2b00      	cmp	r3, #0
 8008e1a:	d003      	beq.n	8008e24 <usb_lld_serve_interrupt+0x174>
      otg_epin_handler(usbp, 2);
 8008e1c:	9801      	ldr	r0, [sp, #4]
 8008e1e:	2102      	movs	r1, #2
 8008e20:	f7ff fcfe 	bl	8008820 <otg_epin_handler>
    if (src & (1 << 3))
 8008e24:	9b03      	ldr	r3, [sp, #12]
 8008e26:	f003 0308 	and.w	r3, r3, #8
 8008e2a:	2b00      	cmp	r3, #0
 8008e2c:	d003      	beq.n	8008e36 <usb_lld_serve_interrupt+0x186>
      otg_epin_handler(usbp, 3);
 8008e2e:	9801      	ldr	r0, [sp, #4]
 8008e30:	2103      	movs	r1, #3
 8008e32:	f7ff fcf5 	bl	8008820 <otg_epin_handler>
      otg_epin_handler(usbp, 4);
    if (src & (1 << 5))
      otg_epin_handler(usbp, 5);
#endif
  }
  if (sts & GINTSTS_OEPINT) {
 8008e36:	9b04      	ldr	r3, [sp, #16]
 8008e38:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e3c:	2b00      	cmp	r3, #0
 8008e3e:	d023      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
    if (src & (1 << 16))
 8008e40:	9b03      	ldr	r3, [sp, #12]
 8008e42:	f403 3380 	and.w	r3, r3, #65536	; 0x10000
 8008e46:	2b00      	cmp	r3, #0
 8008e48:	d003      	beq.n	8008e52 <usb_lld_serve_interrupt+0x1a2>
      otg_epout_handler(usbp, 0);
 8008e4a:	9801      	ldr	r0, [sp, #4]
 8008e4c:	2100      	movs	r1, #0
 8008e4e:	f7ff fd8f 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 17))
 8008e52:	9b03      	ldr	r3, [sp, #12]
 8008e54:	f403 3300 	and.w	r3, r3, #131072	; 0x20000
 8008e58:	2b00      	cmp	r3, #0
 8008e5a:	d003      	beq.n	8008e64 <usb_lld_serve_interrupt+0x1b4>
      otg_epout_handler(usbp, 1);
 8008e5c:	9801      	ldr	r0, [sp, #4]
 8008e5e:	2101      	movs	r1, #1
 8008e60:	f7ff fd86 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 18))
 8008e64:	9b03      	ldr	r3, [sp, #12]
 8008e66:	f403 2380 	and.w	r3, r3, #262144	; 0x40000
 8008e6a:	2b00      	cmp	r3, #0
 8008e6c:	d003      	beq.n	8008e76 <usb_lld_serve_interrupt+0x1c6>
      otg_epout_handler(usbp, 2);
 8008e6e:	9801      	ldr	r0, [sp, #4]
 8008e70:	2102      	movs	r1, #2
 8008e72:	f7ff fd7d 	bl	8008970 <otg_epout_handler>
    if (src & (1 << 19))
 8008e76:	9b03      	ldr	r3, [sp, #12]
 8008e78:	f403 2300 	and.w	r3, r3, #524288	; 0x80000
 8008e7c:	2b00      	cmp	r3, #0
 8008e7e:	d003      	beq.n	8008e88 <usb_lld_serve_interrupt+0x1d8>
      otg_epout_handler(usbp, 3);
 8008e80:	9801      	ldr	r0, [sp, #4]
 8008e82:	2103      	movs	r1, #3
 8008e84:	f7ff fd74 	bl	8008970 <otg_epout_handler>
      otg_epout_handler(usbp, 4);
    if (src & (1 << 21))
      otg_epout_handler(usbp, 5);
#endif
  }
}
 8008e88:	b007      	add	sp, #28
 8008e8a:	f85d fb04 	ldr.w	pc, [sp], #4
 8008e8e:	bf00      	nop

08008e90 <Vector14C>:
/**
 * @brief   OTG1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_OTG1_HANDLER) {
 8008e90:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  usb_lld_serve_interrupt(&USBD1);
 8008e92:	4803      	ldr	r0, [pc, #12]	; (8008ea0 <Vector14C+0x10>)
 8008e94:	f7ff ff0c 	bl	8008cb0 <usb_lld_serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 8008e98:	f7fa fe5a 	bl	8003b50 <_port_irq_epilogue>
}
 8008e9c:	bd08      	pop	{r3, pc}
 8008e9e:	bf00      	nop
 8008ea0:	20001d88 	.word	0x20001d88
 8008ea4:	f3af 8000 	nop.w
 8008ea8:	f3af 8000 	nop.w
 8008eac:	f3af 8000 	nop.w

08008eb0 <usb_lld_init>:
/**
 * @brief   Low level USB driver initialization.
 *
 * @notapi
 */
void usb_lld_init(void) {
 8008eb0:	b508      	push	{r3, lr}

  /* Driver initialization.*/
#if STM32_USB_USE_OTG1
  usbObjectInit(&USBD1);
 8008eb2:	4809      	ldr	r0, [pc, #36]	; (8008ed8 <usb_lld_init+0x28>)
 8008eb4:	f7fd fec4 	bl	8006c40 <usbObjectInit>
  USBD1.wait      = NULL;
 8008eb8:	4b07      	ldr	r3, [pc, #28]	; (8008ed8 <usb_lld_init+0x28>)
 8008eba:	2200      	movs	r2, #0
 8008ebc:	67da      	str	r2, [r3, #124]	; 0x7c
  USBD1.otg       = OTG_FS;
 8008ebe:	4b06      	ldr	r3, [pc, #24]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec0:	f04f 42a0 	mov.w	r2, #1342177280	; 0x50000000
 8008ec4:	66da      	str	r2, [r3, #108]	; 0x6c
  USBD1.otgparams = &fsparams;
 8008ec6:	4b04      	ldr	r3, [pc, #16]	; (8008ed8 <usb_lld_init+0x28>)
 8008ec8:	4a04      	ldr	r2, [pc, #16]	; (8008edc <usb_lld_init+0x2c>)
 8008eca:	671a      	str	r2, [r3, #112]	; 0x70

#if defined(_CHIBIOS_RT_)
  USBD1.tr = NULL;
 8008ecc:	4b02      	ldr	r3, [pc, #8]	; (8008ed8 <usb_lld_init+0x28>)
 8008ece:	2200      	movs	r2, #0
 8008ed0:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                    CH_DBG_STACK_FILL_VALUE);
  }
#endif /* CH_DBG_FILL_THREADS */
#endif /* defined(_CHIBIOS_RT_) */
#endif
}
 8008ed4:	bd08      	pop	{r3, pc}
 8008ed6:	bf00      	nop
 8008ed8:	20001d88 	.word	0x20001d88
 8008edc:	080195e4 	.word	0x080195e4

08008ee0 <usb_lld_start>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_start(USBDriver *usbp) {
 8008ee0:	b500      	push	{lr}
 8008ee2:	b087      	sub	sp, #28
 8008ee4:	9003      	str	r0, [sp, #12]
  stm32_otg_t *otgp = usbp->otg;
 8008ee6:	9b03      	ldr	r3, [sp, #12]
 8008ee8:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8008eea:	9305      	str	r3, [sp, #20]

  if (usbp->state == USB_STOP) {
 8008eec:	9b03      	ldr	r3, [sp, #12]
 8008eee:	781b      	ldrb	r3, [r3, #0]
 8008ef0:	2b01      	cmp	r3, #1
 8008ef2:	d172      	bne.n	8008fda <usb_lld_start+0xfa>
    /* Clock activation.*/

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8008ef4:	9a03      	ldr	r2, [sp, #12]
 8008ef6:	4b3a      	ldr	r3, [pc, #232]	; (8008fe0 <usb_lld_start+0x100>)
 8008ef8:	429a      	cmp	r2, r3
 8008efa:	d119      	bne.n	8008f30 <usb_lld_start+0x50>
      /* OTG FS clock enable and reset.*/
      rccEnableOTG_FS(false);
 8008efc:	4b39      	ldr	r3, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008efe:	4a39      	ldr	r2, [pc, #228]	; (8008fe4 <usb_lld_start+0x104>)
 8008f00:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8008f02:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f06:	64da      	str	r2, [r3, #76]	; 0x4c
      rccResetOTG_FS();
 8008f08:	4b36      	ldr	r3, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0a:	4a36      	ldr	r2, [pc, #216]	; (8008fe4 <usb_lld_start+0x104>)
 8008f0c:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 8008f0e:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8008f12:	62da      	str	r2, [r3, #44]	; 0x2c
 8008f14:	4b33      	ldr	r3, [pc, #204]	; (8008fe4 <usb_lld_start+0x104>)
 8008f16:	2200      	movs	r2, #0
 8008f18:	62da      	str	r2, [r3, #44]	; 0x2c

      /* Enables IRQ vector.*/
      nvicEnableVector(STM32_OTG1_NUMBER, STM32_USB_OTG1_IRQ_PRIORITY);
 8008f1a:	2043      	movs	r0, #67	; 0x43
 8008f1c:	210e      	movs	r1, #14
 8008f1e:	f7fe fa07 	bl	8007330 <nvicEnableVector>

      /* - Forced device mode.
         - USB turn-around time = TRDT_VALUE_FS.
         - Full Speed 1.1 PHY.*/
      otgp->GUSBCFG = GUSBCFG_FDMOD | GUSBCFG_TRDT(TRDT_VALUE_FS) |
 8008f22:	9b05      	ldr	r3, [sp, #20]
 8008f24:	4a30      	ldr	r2, [pc, #192]	; (8008fe8 <usb_lld_start+0x108>)
 8008f26:	60da      	str	r2, [r3, #12]
                      GUSBCFG_PHYSEL;

      /* 48MHz 1.1 PHY.*/
      otgp->DCFG = 0x02200000 | DCFG_DSPD_FS11;
 8008f28:	9b05      	ldr	r3, [sp, #20]
 8008f2a:	4a30      	ldr	r2, [pc, #192]	; (8008fec <usb_lld_start+0x10c>)
 8008f2c:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
#endif
    }
#endif

    /* Clearing mask of TXFIFOs to be filled.*/
    usbp->txpending = 0;
 8008f30:	9b03      	ldr	r3, [sp, #12]
 8008f32:	2200      	movs	r2, #0
 8008f34:	679a      	str	r2, [r3, #120]	; 0x78

    /* PHY enabled.*/
    otgp->PCGCCTL = 0;
 8008f36:	9b05      	ldr	r3, [sp, #20]
 8008f38:	2200      	movs	r2, #0
 8008f3a:	f8c3 2e00 	str.w	r2, [r3, #3584]	; 0xe00

    /* VBUS sensing and transceiver enabled.*/
    otgp->GOTGCTL = GOTGCTL_BVALOEN | GOTGCTL_BVALOVAL;
 8008f3e:	9b05      	ldr	r3, [sp, #20]
 8008f40:	22c0      	movs	r2, #192	; 0xc0
 8008f42:	601a      	str	r2, [r3, #0]
    if (&USBD2 == usbp) {
      otgp->GCCFG = 0;
    }
#endif
#else
    otgp->GCCFG = GCCFG_INIT_VALUE;
 8008f44:	9b05      	ldr	r3, [sp, #20]
 8008f46:	f44f 1204 	mov.w	r2, #2162688	; 0x210000
 8008f4a:	639a      	str	r2, [r3, #56]	; 0x38
#endif

    /* Soft core reset.*/
    otg_core_reset(usbp);
 8008f4c:	9803      	ldr	r0, [sp, #12]
 8008f4e:	f7ff fa47 	bl	80083e0 <otg_core_reset>

    /* Interrupts on TXFIFOs half empty.*/
    otgp->GAHBCFG = 0;
 8008f52:	9b05      	ldr	r3, [sp, #20]
 8008f54:	2200      	movs	r2, #0
 8008f56:	609a      	str	r2, [r3, #8]

    /* Endpoints re-initialization.*/
    otg_disable_ep(usbp);
 8008f58:	9803      	ldr	r0, [sp, #12]
 8008f5a:	f7ff fa61 	bl	8008420 <otg_disable_ep>

    /* Clear all pending Device Interrupts, only the USB Reset interrupt
       is required initially.*/
    otgp->DIEPMSK  = 0;
 8008f5e:	9b05      	ldr	r3, [sp, #20]
 8008f60:	2200      	movs	r2, #0
 8008f62:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
    otgp->DOEPMSK  = 0;
 8008f66:	9b05      	ldr	r3, [sp, #20]
 8008f68:	2200      	movs	r2, #0
 8008f6a:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814
    otgp->DAINTMSK = 0;
 8008f6e:	9b05      	ldr	r3, [sp, #20]
 8008f70:	2200      	movs	r2, #0
 8008f72:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    if (usbp->config->sof_cb == NULL)
 8008f76:	9b03      	ldr	r3, [sp, #12]
 8008f78:	685b      	ldr	r3, [r3, #4]
 8008f7a:	68db      	ldr	r3, [r3, #12]
 8008f7c:	2b00      	cmp	r3, #0
 8008f7e:	d103      	bne.n	8008f88 <usb_lld_start+0xa8>
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f80:	9b05      	ldr	r3, [sp, #20]
 8008f82:	4a1b      	ldr	r2, [pc, #108]	; (8008ff0 <usb_lld_start+0x110>)
 8008f84:	619a      	str	r2, [r3, #24]
 8008f86:	e002      	b.n	8008f8e <usb_lld_start+0xae>
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM;
    else
      otgp->GINTMSK  = GINTMSK_ENUMDNEM | GINTMSK_USBRSTM | GINTMSK_USBSUSPM |
 8008f88:	9b05      	ldr	r3, [sp, #20]
 8008f8a:	4a1a      	ldr	r2, [pc, #104]	; (8008ff4 <usb_lld_start+0x114>)
 8008f8c:	619a      	str	r2, [r3, #24]
                       GINTMSK_ESUSPM | GINTMSK_SRQM | GINTMSK_WKUM |
                       GINTMSK_IISOIXFRM | GINTMSK_IISOOXFRM |
                       GINTMSK_SOFM;

    /* Clears all pending IRQs, if any. */
    otgp->GINTSTS  = 0xFFFFFFFF;
 8008f8e:	9b05      	ldr	r3, [sp, #20]
 8008f90:	f04f 32ff 	mov.w	r2, #4294967295
 8008f94:	615a      	str	r2, [r3, #20]

#if defined(_CHIBIOS_RT_)
    /* Creates the data pump thread. Note, it is created only once.*/
    if (usbp->tr == NULL) {
 8008f96:	9b03      	ldr	r3, [sp, #12]
 8008f98:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008f9c:	2b00      	cmp	r3, #0
 8008f9e:	d116      	bne.n	8008fce <usb_lld_start+0xee>
      usbp->tr = chThdCreateI(usbp->wa_pump, sizeof usbp->wa_pump,
 8008fa0:	9b03      	ldr	r3, [sp, #12]
 8008fa2:	3388      	adds	r3, #136	; 0x88
 8008fa4:	9a03      	ldr	r2, [sp, #12]
 8008fa6:	9200      	str	r2, [sp, #0]
 8008fa8:	4618      	mov	r0, r3
 8008faa:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8008fae:	2202      	movs	r2, #2
 8008fb0:	4b11      	ldr	r3, [pc, #68]	; (8008ff8 <usb_lld_start+0x118>)
 8008fb2:	f7f8 f8ed 	bl	8001190 <chThdCreateI>
 8008fb6:	4602      	mov	r2, r0
 8008fb8:	9b03      	ldr	r3, [sp, #12]
 8008fba:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
                              STM32_USB_OTG_THREAD_PRIO,
                              usb_lld_pump, usbp);
      chThdStartI(usbp->tr);
 8008fbe:	9b03      	ldr	r3, [sp, #12]
 8008fc0:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8008fc4:	4618      	mov	r0, r3
 8008fc6:	f7ff f99b 	bl	8008300 <chThdStartI>
      chSchRescheduleS();
 8008fca:	f7f7 fed9 	bl	8000d80 <chSchRescheduleS>
  }
#endif

    /* Global interrupts enable.*/
    otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 8008fce:	9b05      	ldr	r3, [sp, #20]
 8008fd0:	689b      	ldr	r3, [r3, #8]
 8008fd2:	f043 0201 	orr.w	r2, r3, #1
 8008fd6:	9b05      	ldr	r3, [sp, #20]
 8008fd8:	609a      	str	r2, [r3, #8]
  }
}
 8008fda:	b007      	add	sp, #28
 8008fdc:	f85d fb04 	ldr.w	pc, [sp], #4
 8008fe0:	20001d88 	.word	0x20001d88
 8008fe4:	40021000 	.word	0x40021000
 8008fe8:	40001440 	.word	0x40001440
 8008fec:	02200003 	.word	0x02200003
 8008ff0:	c0303c00 	.word	0xc0303c00
 8008ff4:	c0303c08 	.word	0xc0303c08
 8008ff8:	08009891 	.word	0x08009891
 8008ffc:	f3af 8000 	nop.w

08009000 <usb_lld_stop>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_stop(USBDriver *usbp) {
 8009000:	b500      	push	{lr}
 8009002:	b085      	sub	sp, #20
 8009004:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009006:	9b01      	ldr	r3, [sp, #4]
 8009008:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800900a:	9303      	str	r3, [sp, #12]

  /* If in ready state then disables the USB clock.*/
  if (usbp->state != USB_STOP) {
 800900c:	9b01      	ldr	r3, [sp, #4]
 800900e:	781b      	ldrb	r3, [r3, #0]
 8009010:	2b01      	cmp	r3, #1
 8009012:	d01c      	beq.n	800904e <usb_lld_stop+0x4e>

    /* Disabling all endpoints in case the driver has been stopped while
       active.*/
    otg_disable_ep(usbp);
 8009014:	9801      	ldr	r0, [sp, #4]
 8009016:	f7ff fa03 	bl	8008420 <otg_disable_ep>

    usbp->txpending = 0;
 800901a:	9b01      	ldr	r3, [sp, #4]
 800901c:	2200      	movs	r2, #0
 800901e:	679a      	str	r2, [r3, #120]	; 0x78

    otgp->DAINTMSK   = 0;
 8009020:	9b03      	ldr	r3, [sp, #12]
 8009022:	2200      	movs	r2, #0
 8009024:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
    otgp->GAHBCFG    = 0;
 8009028:	9b03      	ldr	r3, [sp, #12]
 800902a:	2200      	movs	r2, #0
 800902c:	609a      	str	r2, [r3, #8]
    otgp->GCCFG      = 0;
 800902e:	9b03      	ldr	r3, [sp, #12]
 8009030:	2200      	movs	r2, #0
 8009032:	639a      	str	r2, [r3, #56]	; 0x38

#if STM32_USB_USE_OTG1
    if (&USBD1 == usbp) {
 8009034:	9a01      	ldr	r2, [sp, #4]
 8009036:	4b07      	ldr	r3, [pc, #28]	; (8009054 <usb_lld_stop+0x54>)
 8009038:	429a      	cmp	r2, r3
 800903a:	d108      	bne.n	800904e <usb_lld_stop+0x4e>
      nvicDisableVector(STM32_OTG1_NUMBER);
 800903c:	2043      	movs	r0, #67	; 0x43
 800903e:	f7fe f99f 	bl	8007380 <nvicDisableVector>
      rccDisableOTG_FS(false);
 8009042:	4b05      	ldr	r3, [pc, #20]	; (8009058 <usb_lld_stop+0x58>)
 8009044:	4a04      	ldr	r2, [pc, #16]	; (8009058 <usb_lld_stop+0x58>)
 8009046:	6cd2      	ldr	r2, [r2, #76]	; 0x4c
 8009048:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 800904c:	64da      	str	r2, [r3, #76]	; 0x4c
      rccDisableOTG_HSULPI(true)
#endif
    }
#endif
  }
}
 800904e:	b005      	add	sp, #20
 8009050:	f85d fb04 	ldr.w	pc, [sp], #4
 8009054:	20001d88 	.word	0x20001d88
 8009058:	40021000 	.word	0x40021000
 800905c:	f3af 8000 	nop.w

08009060 <usb_lld_reset>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_reset(USBDriver *usbp) {
 8009060:	b510      	push	{r4, lr}
 8009062:	b084      	sub	sp, #16
 8009064:	9001      	str	r0, [sp, #4]
  unsigned i;
  stm32_otg_t *otgp = usbp->otg;
 8009066:	9b01      	ldr	r3, [sp, #4]
 8009068:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800906a:	9302      	str	r3, [sp, #8]

  /* Flush the Tx FIFO.*/
  otg_txfifo_flush(usbp, 0);
 800906c:	9801      	ldr	r0, [sp, #4]
 800906e:	2100      	movs	r1, #0
 8009070:	f7ff fa36 	bl	80084e0 <otg_txfifo_flush>

  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
 8009074:	9b02      	ldr	r3, [sp, #8]
 8009076:	2200      	movs	r2, #0
 8009078:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);
 800907c:	9b02      	ldr	r3, [sp, #8]
 800907e:	f04f 1201 	mov.w	r2, #65537	; 0x10001
 8009082:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 8009086:	2300      	movs	r3, #0
 8009088:	9303      	str	r3, [sp, #12]
 800908a:	e024      	b.n	80090d6 <usb_lld_reset+0x76>
    otgp->ie[i].DIEPCTL = DIEPCTL_SNAK;
 800908c:	9a02      	ldr	r2, [sp, #8]
 800908e:	9b03      	ldr	r3, [sp, #12]
 8009090:	3348      	adds	r3, #72	; 0x48
 8009092:	015b      	lsls	r3, r3, #5
 8009094:	4413      	add	r3, r2
 8009096:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 800909a:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPCTL = DOEPCTL_SNAK;
 800909c:	9a02      	ldr	r2, [sp, #8]
 800909e:	9b03      	ldr	r3, [sp, #12]
 80090a0:	3358      	adds	r3, #88	; 0x58
 80090a2:	015b      	lsls	r3, r3, #5
 80090a4:	4413      	add	r3, r2
 80090a6:	f04f 6200 	mov.w	r2, #134217728	; 0x8000000
 80090aa:	601a      	str	r2, [r3, #0]
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
 80090ac:	9a02      	ldr	r2, [sp, #8]
 80090ae:	9b03      	ldr	r3, [sp, #12]
 80090b0:	015b      	lsls	r3, r3, #5
 80090b2:	4413      	add	r3, r2
 80090b4:	f603 1308 	addw	r3, r3, #2312	; 0x908
 80090b8:	f04f 32ff 	mov.w	r2, #4294967295
 80090bc:	601a      	str	r2, [r3, #0]
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
 80090be:	9a02      	ldr	r2, [sp, #8]
 80090c0:	9b03      	ldr	r3, [sp, #12]
 80090c2:	015b      	lsls	r3, r3, #5
 80090c4:	4413      	add	r3, r2
 80090c6:	f603 3308 	addw	r3, r3, #2824	; 0xb08
 80090ca:	f04f 32ff 	mov.w	r2, #4294967295
 80090ce:	601a      	str	r2, [r3, #0]
  /* Endpoint interrupts all disabled and cleared.*/
  otgp->DIEPEMPMSK = 0;
  otgp->DAINTMSK   = DAINTMSK_OEPM(0) | DAINTMSK_IEPM(0);

  /* All endpoints in NAK mode, interrupts cleared.*/
  for (i = 0; i <= usbp->otgparams->num_endpoints; i++) {
 80090d0:	9b03      	ldr	r3, [sp, #12]
 80090d2:	3301      	adds	r3, #1
 80090d4:	9303      	str	r3, [sp, #12]
 80090d6:	9b01      	ldr	r3, [sp, #4]
 80090d8:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090da:	689a      	ldr	r2, [r3, #8]
 80090dc:	9b03      	ldr	r3, [sp, #12]
 80090de:	429a      	cmp	r2, r3
 80090e0:	d2d4      	bcs.n	800908c <usb_lld_reset+0x2c>
    otgp->ie[i].DIEPINT = 0xFFFFFFFF;
    otgp->oe[i].DOEPINT = 0xFFFFFFFF;
  }

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 80090e2:	9801      	ldr	r0, [sp, #4]
 80090e4:	f7ff fa1c 	bl	8008520 <otg_ram_reset>

  /* Receive FIFO size initialization, the address is always zero.*/
  otgp->GRXFSIZ = usbp->otgparams->rx_fifo_size;
 80090e8:	9b01      	ldr	r3, [sp, #4]
 80090ea:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80090ec:	681a      	ldr	r2, [r3, #0]
 80090ee:	9b02      	ldr	r3, [sp, #8]
 80090f0:	625a      	str	r2, [r3, #36]	; 0x24
  otg_rxfifo_flush(usbp);
 80090f2:	9801      	ldr	r0, [sp, #4]
 80090f4:	f7ff f9dc 	bl	80084b0 <otg_rxfifo_flush>

  /* Resets the device address to zero.*/
  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(0);
 80090f8:	9b02      	ldr	r3, [sp, #8]
 80090fa:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80090fe:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 8009102:	9b02      	ldr	r3, [sp, #8]
 8009104:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800

  /* Enables also EP-related interrupt sources.*/
  otgp->GINTMSK  |= GINTMSK_RXFLVLM | GINTMSK_OEPM  | GINTMSK_IEPM;
 8009108:	9b02      	ldr	r3, [sp, #8]
 800910a:	699b      	ldr	r3, [r3, #24]
 800910c:	f443 2340 	orr.w	r3, r3, #786432	; 0xc0000
 8009110:	f043 0310 	orr.w	r3, r3, #16
 8009114:	9a02      	ldr	r2, [sp, #8]
 8009116:	6193      	str	r3, [r2, #24]
  otgp->DIEPMSK   = DIEPMSK_TOCM    | DIEPMSK_XFRCM;
 8009118:	9b02      	ldr	r3, [sp, #8]
 800911a:	2209      	movs	r2, #9
 800911c:	f8c3 2810 	str.w	r2, [r3, #2064]	; 0x810
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;
 8009120:	9b02      	ldr	r3, [sp, #8]
 8009122:	2209      	movs	r2, #9
 8009124:	f8c3 2814 	str.w	r2, [r3, #2068]	; 0x814

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
 8009128:	9b01      	ldr	r3, [sp, #4]
 800912a:	4a16      	ldr	r2, [pc, #88]	; (8009184 <usb_lld_reset+0x124>)
 800912c:	60da      	str	r2, [r3, #12]
  otgp->oe[0].DOEPTSIZ = 0;
 800912e:	9b02      	ldr	r3, [sp, #8]
 8009130:	2200      	movs	r2, #0
 8009132:	f8c3 2b10 	str.w	r2, [r3, #2832]	; 0xb10
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
 8009136:	2340      	movs	r3, #64	; 0x40
  otgp->DOEPMSK   = DOEPMSK_STUPM   | DOEPMSK_XFRCM;

  /* EP0 initialization, it is a special case.*/
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
 8009138:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800913c:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8009140:	9a02      	ldr	r2, [sp, #8]
 8009142:	f8c2 3b00 	str.w	r3, [r2, #2816]	; 0xb00
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
 8009146:	9b02      	ldr	r3, [sp, #8]
 8009148:	2200      	movs	r2, #0
 800914a:	f8c3 2910 	str.w	r2, [r3, #2320]	; 0x910
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
 800914e:	2340      	movs	r3, #64	; 0x40
 8009150:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8009154:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
  usbp->epc[0] = &ep0config;
  otgp->oe[0].DOEPTSIZ = 0;
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
 8009158:	9a02      	ldr	r2, [sp, #8]
 800915a:	f8c2 3900 	str.w	r3, [r2, #2304]	; 0x900
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 800915e:	2340      	movs	r3, #64	; 0x40
 8009160:	089b      	lsrs	r3, r3, #2
 8009162:	b29b      	uxth	r3, r3
 8009164:	041b      	lsls	r3, r3, #16
 8009166:	461c      	mov	r4, r3
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
 8009168:	2340      	movs	r3, #64	; 0x40
 800916a:	089b      	lsrs	r3, r3, #2
 800916c:	b29b      	uxth	r3, r3
 800916e:	9801      	ldr	r0, [sp, #4]
 8009170:	4619      	mov	r1, r3
 8009172:	f7ff f9e5 	bl	8008540 <otg_ram_alloc>
 8009176:	4603      	mov	r3, r0
  otgp->oe[0].DOEPCTL = DOEPCTL_SD0PID | DOEPCTL_USBAEP | DOEPCTL_EPTYP_CTRL |
                        DOEPCTL_MPSIZ(ep0config.out_maxsize);
  otgp->ie[0].DIEPTSIZ = 0;
  otgp->ie[0].DIEPCTL = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL |
                        DIEPCTL_TXFNUM(0) | DIEPCTL_MPSIZ(ep0config.in_maxsize);
  otgp->DIEPTXF0 = DIEPTXF_INEPTXFD(ep0config.in_maxsize / 4) |
 8009178:	ea44 0203 	orr.w	r2, r4, r3
 800917c:	9b02      	ldr	r3, [sp, #8]
 800917e:	629a      	str	r2, [r3, #40]	; 0x28
                   DIEPTXF_INEPTXSA(otg_ram_alloc(usbp,
                                                  ep0config.in_maxsize / 4));
}
 8009180:	b004      	add	sp, #16
 8009182:	bd10      	pop	{r4, pc}
 8009184:	080195c0 	.word	0x080195c0
 8009188:	f3af 8000 	nop.w
 800918c:	f3af 8000 	nop.w

08009190 <usb_lld_set_address>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_set_address(USBDriver *usbp) {
 8009190:	b084      	sub	sp, #16
 8009192:	9001      	str	r0, [sp, #4]
  stm32_otg_t *otgp = usbp->otg;
 8009194:	9b01      	ldr	r3, [sp, #4]
 8009196:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009198:	9303      	str	r3, [sp, #12]

  otgp->DCFG = (otgp->DCFG & ~DCFG_DAD_MASK) | DCFG_DAD(usbp->address);
 800919a:	9b03      	ldr	r3, [sp, #12]
 800919c:	f8d3 3800 	ldr.w	r3, [r3, #2048]	; 0x800
 80091a0:	f423 62fe 	bic.w	r2, r3, #2032	; 0x7f0
 80091a4:	9b01      	ldr	r3, [sp, #4]
 80091a6:	f893 3066 	ldrb.w	r3, [r3, #102]	; 0x66
 80091aa:	011b      	lsls	r3, r3, #4
 80091ac:	431a      	orrs	r2, r3
 80091ae:	9b03      	ldr	r3, [sp, #12]
 80091b0:	f8c3 2800 	str.w	r2, [r3, #2048]	; 0x800
}
 80091b4:	b004      	add	sp, #16
 80091b6:	4770      	bx	lr
 80091b8:	f3af 8000 	nop.w
 80091bc:	f3af 8000 	nop.w

080091c0 <usb_lld_init_endpoint>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_init_endpoint(USBDriver *usbp, usbep_t ep) {
 80091c0:	b530      	push	{r4, r5, lr}
 80091c2:	b087      	sub	sp, #28
 80091c4:	9001      	str	r0, [sp, #4]
 80091c6:	460b      	mov	r3, r1
 80091c8:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl, fsize;
  stm32_otg_t *otgp = usbp->otg;
 80091cc:	9b01      	ldr	r3, [sp, #4]
 80091ce:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80091d0:	9303      	str	r3, [sp, #12]

  /* IN and OUT common parameters.*/
  switch (usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) {
 80091d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80091d6:	9a01      	ldr	r2, [sp, #4]
 80091d8:	3302      	adds	r3, #2
 80091da:	009b      	lsls	r3, r3, #2
 80091dc:	4413      	add	r3, r2
 80091de:	685b      	ldr	r3, [r3, #4]
 80091e0:	681b      	ldr	r3, [r3, #0]
 80091e2:	f003 0303 	and.w	r3, r3, #3
 80091e6:	2b03      	cmp	r3, #3
 80091e8:	f200 8108 	bhi.w	80093fc <usb_lld_init_endpoint+0x23c>
 80091ec:	a201      	add	r2, pc, #4	; (adr r2, 80091f4 <usb_lld_init_endpoint+0x34>)
 80091ee:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80091f2:	bf00      	nop
 80091f4:	08009205 	.word	0x08009205
 80091f8:	0800920b 	.word	0x0800920b
 80091fc:	08009211 	.word	0x08009211
 8009200:	08009217 	.word	0x08009217
  case USB_EP_MODE_TYPE_CTRL:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_CTRL;
 8009204:	4b7f      	ldr	r3, [pc, #508]	; (8009404 <usb_lld_init_endpoint+0x244>)
 8009206:	9305      	str	r3, [sp, #20]
    break;
 8009208:	e008      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_ISOC:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_ISO;
 800920a:	4b7f      	ldr	r3, [pc, #508]	; (8009408 <usb_lld_init_endpoint+0x248>)
 800920c:	9305      	str	r3, [sp, #20]
    break;
 800920e:	e005      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_BULK:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_BULK;
 8009210:	4b7e      	ldr	r3, [pc, #504]	; (800940c <usb_lld_init_endpoint+0x24c>)
 8009212:	9305      	str	r3, [sp, #20]
    break;
 8009214:	e002      	b.n	800921c <usb_lld_init_endpoint+0x5c>
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
 8009216:	4b7e      	ldr	r3, [pc, #504]	; (8009410 <usb_lld_init_endpoint+0x250>)
 8009218:	9305      	str	r3, [sp, #20]
    break;
 800921a:	bf00      	nop
  default:
    return;
  }

  /* OUT endpoint activation or deactivation.*/
  otgp->oe[ep].DOEPTSIZ = 0;
 800921c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009220:	9a03      	ldr	r2, [sp, #12]
 8009222:	015b      	lsls	r3, r3, #5
 8009224:	4413      	add	r3, r2
 8009226:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 800922a:	2200      	movs	r2, #0
 800922c:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->out_state != NULL) {
 800922e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009232:	9a01      	ldr	r2, [sp, #4]
 8009234:	3302      	adds	r3, #2
 8009236:	009b      	lsls	r3, r3, #2
 8009238:	4413      	add	r3, r2
 800923a:	685b      	ldr	r3, [r3, #4]
 800923c:	699b      	ldr	r3, [r3, #24]
 800923e:	2b00      	cmp	r3, #0
 8009240:	d020      	beq.n	8009284 <usb_lld_init_endpoint+0xc4>
    otgp->oe[ep].DOEPCTL = ctl | DOEPCTL_MPSIZ(usbp->epc[ep]->out_maxsize);
 8009242:	f89d 0003 	ldrb.w	r0, [sp, #3]
 8009246:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800924a:	9a01      	ldr	r2, [sp, #4]
 800924c:	3302      	adds	r3, #2
 800924e:	009b      	lsls	r3, r3, #2
 8009250:	4413      	add	r3, r2
 8009252:	685b      	ldr	r3, [r3, #4]
 8009254:	8a5b      	ldrh	r3, [r3, #18]
 8009256:	461a      	mov	r2, r3
 8009258:	9b05      	ldr	r3, [sp, #20]
 800925a:	431a      	orrs	r2, r3
 800925c:	9903      	ldr	r1, [sp, #12]
 800925e:	f100 0358 	add.w	r3, r0, #88	; 0x58
 8009262:	015b      	lsls	r3, r3, #5
 8009264:	440b      	add	r3, r1
 8009266:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK |= DAINTMSK_OEPM(ep);
 8009268:	9b03      	ldr	r3, [sp, #12]
 800926a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800926e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009272:	3310      	adds	r3, #16
 8009274:	2101      	movs	r1, #1
 8009276:	fa01 f303 	lsl.w	r3, r1, r3
 800927a:	431a      	orrs	r2, r3
 800927c:	9b03      	ldr	r3, [sp, #12]
 800927e:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 8009282:	e01d      	b.n	80092c0 <usb_lld_init_endpoint+0x100>
  }
  else {
    otgp->oe[ep].DOEPCTL &= ~DOEPCTL_USBAEP;
 8009284:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009288:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800928c:	9903      	ldr	r1, [sp, #12]
 800928e:	3258      	adds	r2, #88	; 0x58
 8009290:	0152      	lsls	r2, r2, #5
 8009292:	440a      	add	r2, r1
 8009294:	6812      	ldr	r2, [r2, #0]
 8009296:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 800929a:	9903      	ldr	r1, [sp, #12]
 800929c:	3358      	adds	r3, #88	; 0x58
 800929e:	015b      	lsls	r3, r3, #5
 80092a0:	440b      	add	r3, r1
 80092a2:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_OEPM(ep);
 80092a4:	9b03      	ldr	r3, [sp, #12]
 80092a6:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80092aa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ae:	3310      	adds	r3, #16
 80092b0:	2101      	movs	r1, #1
 80092b2:	fa01 f303 	lsl.w	r3, r1, r3
 80092b6:	43db      	mvns	r3, r3
 80092b8:	401a      	ands	r2, r3
 80092ba:	9b03      	ldr	r3, [sp, #12]
 80092bc:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
  }

  /* IN endpoint activation or deactivation.*/
  otgp->ie[ep].DIEPTSIZ = 0;
 80092c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092c4:	9a03      	ldr	r2, [sp, #12]
 80092c6:	015b      	lsls	r3, r3, #5
 80092c8:	4413      	add	r3, r2
 80092ca:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80092ce:	2200      	movs	r2, #0
 80092d0:	601a      	str	r2, [r3, #0]
  if (usbp->epc[ep]->in_state != NULL) {
 80092d2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092d6:	9a01      	ldr	r2, [sp, #4]
 80092d8:	3302      	adds	r3, #2
 80092da:	009b      	lsls	r3, r3, #2
 80092dc:	4413      	add	r3, r2
 80092de:	685b      	ldr	r3, [r3, #4]
 80092e0:	695b      	ldr	r3, [r3, #20]
 80092e2:	2b00      	cmp	r3, #0
 80092e4:	d05d      	beq.n	80093a2 <usb_lld_init_endpoint+0x1e2>
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
 80092e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80092ea:	9a01      	ldr	r2, [sp, #4]
 80092ec:	3302      	adds	r3, #2
 80092ee:	009b      	lsls	r3, r3, #2
 80092f0:	4413      	add	r3, r2
 80092f2:	685b      	ldr	r3, [r3, #4]
 80092f4:	8a1b      	ldrh	r3, [r3, #16]
 80092f6:	089b      	lsrs	r3, r3, #2
 80092f8:	b29b      	uxth	r3, r3
 80092fa:	9304      	str	r3, [sp, #16]
    if (usbp->epc[ep]->in_multiplier > 1)
 80092fc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009300:	9a01      	ldr	r2, [sp, #4]
 8009302:	3302      	adds	r3, #2
 8009304:	009b      	lsls	r3, r3, #2
 8009306:	4413      	add	r3, r2
 8009308:	685b      	ldr	r3, [r3, #4]
 800930a:	8b9b      	ldrh	r3, [r3, #28]
 800930c:	2b01      	cmp	r3, #1
 800930e:	d90c      	bls.n	800932a <usb_lld_init_endpoint+0x16a>
      fsize *= usbp->epc[ep]->in_multiplier;
 8009310:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009314:	9a01      	ldr	r2, [sp, #4]
 8009316:	3302      	adds	r3, #2
 8009318:	009b      	lsls	r3, r3, #2
 800931a:	4413      	add	r3, r2
 800931c:	685b      	ldr	r3, [r3, #4]
 800931e:	8b9b      	ldrh	r3, [r3, #28]
 8009320:	461a      	mov	r2, r3
 8009322:	9b04      	ldr	r3, [sp, #16]
 8009324:	fb02 f303 	mul.w	r3, r2, r3
 8009328:	9304      	str	r3, [sp, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800932a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800932e:	1e5c      	subs	r4, r3, #1
 8009330:	9b04      	ldr	r3, [sp, #16]
 8009332:	041d      	lsls	r5, r3, #16
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
 8009334:	9801      	ldr	r0, [sp, #4]
 8009336:	9904      	ldr	r1, [sp, #16]
 8009338:	f7ff f902 	bl	8008540 <otg_ram_alloc>
 800933c:	4603      	mov	r3, r0
  if (usbp->epc[ep]->in_state != NULL) {
    /* FIFO allocation for the IN endpoint.*/
    fsize = usbp->epc[ep]->in_maxsize / 4;
    if (usbp->epc[ep]->in_multiplier > 1)
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
 800933e:	ea45 0203 	orr.w	r2, r5, r3
 8009342:	9903      	ldr	r1, [sp, #12]
 8009344:	f104 0340 	add.w	r3, r4, #64	; 0x40
 8009348:	009b      	lsls	r3, r3, #2
 800934a:	440b      	add	r3, r1
 800934c:	605a      	str	r2, [r3, #4]
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);
 800934e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009352:	9801      	ldr	r0, [sp, #4]
 8009354:	4619      	mov	r1, r3
 8009356:	f7ff f8c3 	bl	80084e0 <otg_txfifo_flush>

    otgp->ie[ep].DIEPCTL = ctl |
 800935a:	f89d 0003 	ldrb.w	r0, [sp, #3]
                           DIEPCTL_TXFNUM(ep) |
 800935e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009362:	059b      	lsls	r3, r3, #22
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 8009364:	461a      	mov	r2, r3
 8009366:	9b05      	ldr	r3, [sp, #20]
 8009368:	431a      	orrs	r2, r3
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
 800936a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800936e:	9901      	ldr	r1, [sp, #4]
 8009370:	3302      	adds	r3, #2
 8009372:	009b      	lsls	r3, r3, #2
 8009374:	440b      	add	r3, r1
 8009376:	685b      	ldr	r3, [r3, #4]
 8009378:	8a1b      	ldrh	r3, [r3, #16]
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
                           DIEPCTL_TXFNUM(ep) |
 800937a:	431a      	orrs	r2, r3
      fsize *= usbp->epc[ep]->in_multiplier;
    otgp->DIEPTXF[ep - 1] = DIEPTXF_INEPTXFD(fsize) |
                            DIEPTXF_INEPTXSA(otg_ram_alloc(usbp, fsize));
    otg_txfifo_flush(usbp, ep);

    otgp->ie[ep].DIEPCTL = ctl |
 800937c:	9903      	ldr	r1, [sp, #12]
 800937e:	f100 0348 	add.w	r3, r0, #72	; 0x48
 8009382:	015b      	lsls	r3, r3, #5
 8009384:	440b      	add	r3, r1
 8009386:	601a      	str	r2, [r3, #0]
                           DIEPCTL_TXFNUM(ep) |
                           DIEPCTL_MPSIZ(usbp->epc[ep]->in_maxsize);
    otgp->DAINTMSK |= DAINTMSK_IEPM(ep);
 8009388:	9b03      	ldr	r3, [sp, #12]
 800938a:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 800938e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009392:	2101      	movs	r1, #1
 8009394:	fa01 f303 	lsl.w	r3, r1, r3
 8009398:	431a      	orrs	r2, r3
 800939a:	9b03      	ldr	r3, [sp, #12]
 800939c:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093a0:	e02d      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
  }
  else {
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
 80093a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093a6:	3b01      	subs	r3, #1
 80093a8:	9a03      	ldr	r2, [sp, #12]
 80093aa:	3340      	adds	r3, #64	; 0x40
 80093ac:	009b      	lsls	r3, r3, #2
 80093ae:	4413      	add	r3, r2
 80093b0:	4a18      	ldr	r2, [pc, #96]	; (8009414 <usb_lld_init_endpoint+0x254>)
 80093b2:	605a      	str	r2, [r3, #4]
    otg_txfifo_flush(usbp, ep);
 80093b4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093b8:	9801      	ldr	r0, [sp, #4]
 80093ba:	4619      	mov	r1, r3
 80093bc:	f7ff f890 	bl	80084e0 <otg_txfifo_flush>
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
 80093c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093c4:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80093c8:	9903      	ldr	r1, [sp, #12]
 80093ca:	3248      	adds	r2, #72	; 0x48
 80093cc:	0152      	lsls	r2, r2, #5
 80093ce:	440a      	add	r2, r1
 80093d0:	6812      	ldr	r2, [r2, #0]
 80093d2:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 80093d6:	9903      	ldr	r1, [sp, #12]
 80093d8:	3348      	adds	r3, #72	; 0x48
 80093da:	015b      	lsls	r3, r3, #5
 80093dc:	440b      	add	r3, r1
 80093de:	601a      	str	r2, [r3, #0]
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
 80093e0:	9b03      	ldr	r3, [sp, #12]
 80093e2:	f8d3 281c 	ldr.w	r2, [r3, #2076]	; 0x81c
 80093e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80093ea:	2101      	movs	r1, #1
 80093ec:	fa01 f303 	lsl.w	r3, r1, r3
 80093f0:	43db      	mvns	r3, r3
 80093f2:	401a      	ands	r2, r3
 80093f4:	9b03      	ldr	r3, [sp, #12]
 80093f6:	f8c3 281c 	str.w	r2, [r3, #2076]	; 0x81c
 80093fa:	e000      	b.n	80093fe <usb_lld_init_endpoint+0x23e>
    break;
  case USB_EP_MODE_TYPE_INTR:
    ctl = DIEPCTL_SD0PID | DIEPCTL_USBAEP | DIEPCTL_EPTYP_INTR;
    break;
  default:
    return;
 80093fc:	bf00      	nop
    otgp->DIEPTXF[ep - 1] = 0x02000400; /* Reset value.*/
    otg_txfifo_flush(usbp, ep);
    otgp->ie[ep].DIEPCTL &= ~DIEPCTL_USBAEP;
    otgp->DAINTMSK &= ~DAINTMSK_IEPM(ep);
  }
}
 80093fe:	b007      	add	sp, #28
 8009400:	bd30      	pop	{r4, r5, pc}
 8009402:	bf00      	nop
 8009404:	10008000 	.word	0x10008000
 8009408:	10048000 	.word	0x10048000
 800940c:	10088000 	.word	0x10088000
 8009410:	100c8000 	.word	0x100c8000
 8009414:	02000400 	.word	0x02000400
 8009418:	f3af 8000 	nop.w
 800941c:	f3af 8000 	nop.w

08009420 <usb_lld_disable_endpoints>:
 *
 * @param[in] usbp      pointer to the @p USBDriver object
 *
 * @notapi
 */
void usb_lld_disable_endpoints(USBDriver *usbp) {
 8009420:	b500      	push	{lr}
 8009422:	b083      	sub	sp, #12
 8009424:	9001      	str	r0, [sp, #4]

  /* Resets the FIFO memory allocator.*/
  otg_ram_reset(usbp);
 8009426:	9801      	ldr	r0, [sp, #4]
 8009428:	f7ff f87a 	bl	8008520 <otg_ram_reset>

  /* Disabling all endpoints.*/
  otg_disable_ep(usbp);
 800942c:	9801      	ldr	r0, [sp, #4]
 800942e:	f7fe fff7 	bl	8008420 <otg_disable_ep>
}
 8009432:	b003      	add	sp, #12
 8009434:	f85d fb04 	ldr.w	pc, [sp], #4
 8009438:	f3af 8000 	nop.w
 800943c:	f3af 8000 	nop.w

08009440 <usb_lld_get_status_out>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_out(USBDriver *usbp, usbep_t ep) {
 8009440:	b084      	sub	sp, #16
 8009442:	9001      	str	r0, [sp, #4]
 8009444:	460b      	mov	r3, r1
 8009446:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->oe[ep].DOEPCTL;
 800944a:	9b01      	ldr	r3, [sp, #4]
 800944c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800944e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009452:	3358      	adds	r3, #88	; 0x58
 8009454:	015b      	lsls	r3, r3, #5
 8009456:	4413      	add	r3, r2
 8009458:	681b      	ldr	r3, [r3, #0]
 800945a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DOEPCTL_USBAEP))
 800945c:	9b03      	ldr	r3, [sp, #12]
 800945e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 8009462:	2b00      	cmp	r3, #0
 8009464:	d101      	bne.n	800946a <usb_lld_get_status_out+0x2a>
    return EP_STATUS_DISABLED;
 8009466:	2300      	movs	r3, #0
 8009468:	e007      	b.n	800947a <usb_lld_get_status_out+0x3a>
  if (ctl & DOEPCTL_STALL)
 800946a:	9b03      	ldr	r3, [sp, #12]
 800946c:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 8009470:	2b00      	cmp	r3, #0
 8009472:	d001      	beq.n	8009478 <usb_lld_get_status_out+0x38>
    return EP_STATUS_STALLED;
 8009474:	2301      	movs	r3, #1
 8009476:	e000      	b.n	800947a <usb_lld_get_status_out+0x3a>
  return EP_STATUS_ACTIVE;
 8009478:	2302      	movs	r3, #2
}
 800947a:	4618      	mov	r0, r3
 800947c:	b004      	add	sp, #16
 800947e:	4770      	bx	lr

08009480 <usb_lld_get_status_in>:
 * @retval EP_STATUS_STALLED  The endpoint is stalled.
 * @retval EP_STATUS_ACTIVE   The endpoint is active.
 *
 * @notapi
 */
usbepstatus_t usb_lld_get_status_in(USBDriver *usbp, usbep_t ep) {
 8009480:	b084      	sub	sp, #16
 8009482:	9001      	str	r0, [sp, #4]
 8009484:	460b      	mov	r3, r1
 8009486:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t ctl;

  (void)usbp;

  ctl = usbp->otg->ie[ep].DIEPCTL;
 800948a:	9b01      	ldr	r3, [sp, #4]
 800948c:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 800948e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009492:	3348      	adds	r3, #72	; 0x48
 8009494:	015b      	lsls	r3, r3, #5
 8009496:	4413      	add	r3, r2
 8009498:	681b      	ldr	r3, [r3, #0]
 800949a:	9303      	str	r3, [sp, #12]
  if (!(ctl & DIEPCTL_USBAEP))
 800949c:	9b03      	ldr	r3, [sp, #12]
 800949e:	f403 4300 	and.w	r3, r3, #32768	; 0x8000
 80094a2:	2b00      	cmp	r3, #0
 80094a4:	d101      	bne.n	80094aa <usb_lld_get_status_in+0x2a>
    return EP_STATUS_DISABLED;
 80094a6:	2300      	movs	r3, #0
 80094a8:	e007      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  if (ctl & DIEPCTL_STALL)
 80094aa:	9b03      	ldr	r3, [sp, #12]
 80094ac:	f403 1300 	and.w	r3, r3, #2097152	; 0x200000
 80094b0:	2b00      	cmp	r3, #0
 80094b2:	d001      	beq.n	80094b8 <usb_lld_get_status_in+0x38>
    return EP_STATUS_STALLED;
 80094b4:	2301      	movs	r3, #1
 80094b6:	e000      	b.n	80094ba <usb_lld_get_status_in+0x3a>
  return EP_STATUS_ACTIVE;
 80094b8:	2302      	movs	r3, #2
}
 80094ba:	4618      	mov	r0, r3
 80094bc:	b004      	add	sp, #16
 80094be:	4770      	bx	lr

080094c0 <usb_lld_read_setup>:
 * @param[in] ep        endpoint number
 * @param[out] buf      buffer where to copy the packet data
 *
 * @notapi
 */
void usb_lld_read_setup(USBDriver *usbp, usbep_t ep, uint8_t *buf) {
 80094c0:	b500      	push	{lr}
 80094c2:	b085      	sub	sp, #20
 80094c4:	9003      	str	r0, [sp, #12]
 80094c6:	460b      	mov	r3, r1
 80094c8:	9201      	str	r2, [sp, #4]
 80094ca:	f88d 300b 	strb.w	r3, [sp, #11]

  memcpy(buf, usbp->epc[ep]->setup_buf, 8);
 80094ce:	f89d 300b 	ldrb.w	r3, [sp, #11]
 80094d2:	9a03      	ldr	r2, [sp, #12]
 80094d4:	3302      	adds	r3, #2
 80094d6:	009b      	lsls	r3, r3, #2
 80094d8:	4413      	add	r3, r2
 80094da:	685b      	ldr	r3, [r3, #4]
 80094dc:	6a1b      	ldr	r3, [r3, #32]
 80094de:	9801      	ldr	r0, [sp, #4]
 80094e0:	4619      	mov	r1, r3
 80094e2:	2208      	movs	r2, #8
 80094e4:	f00d fa34 	bl	8016950 <memcpy>
}
 80094e8:	b005      	add	sp, #20
 80094ea:	f85d fb04 	ldr.w	pc, [sp], #4
 80094ee:	bf00      	nop

080094f0 <usb_lld_start_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_out(USBDriver *usbp, usbep_t ep) {
 80094f0:	b086      	sub	sp, #24
 80094f2:	9001      	str	r0, [sp, #4]
 80094f4:	460b      	mov	r3, r1
 80094f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t pcnt, rxsize;
  USBOutEndpointState *osp = usbp->epc[ep]->out_state;
 80094fa:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80094fe:	9a01      	ldr	r2, [sp, #4]
 8009500:	3302      	adds	r3, #2
 8009502:	009b      	lsls	r3, r3, #2
 8009504:	4413      	add	r3, r2
 8009506:	685b      	ldr	r3, [r3, #4]
 8009508:	699b      	ldr	r3, [r3, #24]
 800950a:	9305      	str	r3, [sp, #20]

  /* Transfer initialization.*/
  osp->totsize = osp->rxsize;
 800950c:	9b05      	ldr	r3, [sp, #20]
 800950e:	681a      	ldr	r2, [r3, #0]
 8009510:	9b05      	ldr	r3, [sp, #20]
 8009512:	60da      	str	r2, [r3, #12]
  if ((ep == 0) && (osp->rxsize > EP0_MAX_OUTSIZE))
 8009514:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009518:	2b00      	cmp	r3, #0
 800951a:	d106      	bne.n	800952a <usb_lld_start_out+0x3a>
 800951c:	9b05      	ldr	r3, [sp, #20]
 800951e:	681b      	ldr	r3, [r3, #0]
 8009520:	2b40      	cmp	r3, #64	; 0x40
 8009522:	d902      	bls.n	800952a <usb_lld_start_out+0x3a>
      osp->rxsize = EP0_MAX_OUTSIZE;
 8009524:	9b05      	ldr	r3, [sp, #20]
 8009526:	2240      	movs	r2, #64	; 0x40
 8009528:	601a      	str	r2, [r3, #0]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 800952a:	9b05      	ldr	r3, [sp, #20]
 800952c:	681a      	ldr	r2, [r3, #0]
 800952e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009532:	9901      	ldr	r1, [sp, #4]
 8009534:	3302      	adds	r3, #2
 8009536:	009b      	lsls	r3, r3, #2
 8009538:	440b      	add	r3, r1
 800953a:	685b      	ldr	r3, [r3, #4]
 800953c:	8a5b      	ldrh	r3, [r3, #18]
 800953e:	4413      	add	r3, r2
 8009540:	1e5a      	subs	r2, r3, #1
           usbp->epc[ep]->out_maxsize;
 8009542:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009546:	9901      	ldr	r1, [sp, #4]
 8009548:	3302      	adds	r3, #2
 800954a:	009b      	lsls	r3, r3, #2
 800954c:	440b      	add	r3, r1
 800954e:	685b      	ldr	r3, [r3, #4]
 8009550:	8a5b      	ldrh	r3, [r3, #18]
  /* Transaction size is rounded to a multiple of packet size because the
     following requirement in the RM:
     "For OUT transfers, the transfer size field in the endpoint's transfer
     size register must be a multiple of the maximum packet size of the
     endpoint, adjusted to the Word boundary".*/
  pcnt   = (osp->rxsize + usbp->epc[ep]->out_maxsize - 1U) /
 8009552:	fbb2 f3f3 	udiv	r3, r2, r3
 8009556:	9304      	str	r3, [sp, #16]
           usbp->epc[ep]->out_maxsize;
  rxsize = (pcnt * usbp->epc[ep]->out_maxsize + 3U) & 0xFFFFFFFCU;
 8009558:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800955c:	9a01      	ldr	r2, [sp, #4]
 800955e:	3302      	adds	r3, #2
 8009560:	009b      	lsls	r3, r3, #2
 8009562:	4413      	add	r3, r2
 8009564:	685b      	ldr	r3, [r3, #4]
 8009566:	8a5b      	ldrh	r3, [r3, #18]
 8009568:	9a04      	ldr	r2, [sp, #16]
 800956a:	fb02 f303 	mul.w	r3, r2, r3
 800956e:	3303      	adds	r3, #3
 8009570:	f023 0303 	bic.w	r3, r3, #3
 8009574:	9303      	str	r3, [sp, #12]

  /*Setting up transaction parameters in DOEPTSIZ.*/
  usbp->otg->oe[ep].DOEPTSIZ = DOEPTSIZ_STUPCNT(3) | DOEPTSIZ_PKTCNT(pcnt) |
 8009576:	9b01      	ldr	r3, [sp, #4]
 8009578:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800957a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800957e:	9a04      	ldr	r2, [sp, #16]
 8009580:	04d0      	lsls	r0, r2, #19
 8009582:	9a03      	ldr	r2, [sp, #12]
 8009584:	4302      	orrs	r2, r0
 8009586:	f042 42c0 	orr.w	r2, r2, #1610612736	; 0x60000000
 800958a:	015b      	lsls	r3, r3, #5
 800958c:	440b      	add	r3, r1
 800958e:	f503 6331 	add.w	r3, r3, #2832	; 0xb10
 8009592:	601a      	str	r2, [r3, #0]
                               DOEPTSIZ_XFRSIZ(rxsize);

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 8009594:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009598:	9a01      	ldr	r2, [sp, #4]
 800959a:	3302      	adds	r3, #2
 800959c:	009b      	lsls	r3, r3, #2
 800959e:	4413      	add	r3, r2
 80095a0:	685b      	ldr	r3, [r3, #4]
 80095a2:	681b      	ldr	r3, [r3, #0]
 80095a4:	f003 0303 	and.w	r3, r3, #3
 80095a8:	2b01      	cmp	r3, #1
 80095aa:	d12c      	bne.n	8009606 <usb_lld_start_out+0x116>
    /* Odd/even bit toggling for isochronous endpoint.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80095ac:	9b01      	ldr	r3, [sp, #4]
 80095ae:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80095b0:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80095b4:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80095b8:	2b00      	cmp	r3, #0
 80095ba:	d012      	beq.n	80095e2 <usb_lld_start_out+0xf2>
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SEVNFRM;
 80095bc:	9b01      	ldr	r3, [sp, #4]
 80095be:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095c0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095c4:	9a01      	ldr	r2, [sp, #4]
 80095c6:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095c8:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095cc:	3258      	adds	r2, #88	; 0x58
 80095ce:	0152      	lsls	r2, r2, #5
 80095d0:	4402      	add	r2, r0
 80095d2:	6812      	ldr	r2, [r2, #0]
 80095d4:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 80095d8:	3358      	adds	r3, #88	; 0x58
 80095da:	015b      	lsls	r3, r3, #5
 80095dc:	440b      	add	r3, r1
 80095de:	601a      	str	r2, [r3, #0]
 80095e0:	e011      	b.n	8009606 <usb_lld_start_out+0x116>
    else
      usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_SODDFRM;
 80095e2:	9b01      	ldr	r3, [sp, #4]
 80095e4:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80095e6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80095ea:	9a01      	ldr	r2, [sp, #4]
 80095ec:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80095ee:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80095f2:	3258      	adds	r2, #88	; 0x58
 80095f4:	0152      	lsls	r2, r2, #5
 80095f6:	4402      	add	r2, r0
 80095f8:	6812      	ldr	r2, [r2, #0]
 80095fa:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80095fe:	3358      	adds	r3, #88	; 0x58
 8009600:	015b      	lsls	r3, r3, #5
 8009602:	440b      	add	r3, r1
 8009604:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_EPENA | DOEPCTL_CNAK;
 8009606:	9b01      	ldr	r3, [sp, #4]
 8009608:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800960a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800960e:	9a01      	ldr	r2, [sp, #4]
 8009610:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009612:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009616:	3258      	adds	r2, #88	; 0x58
 8009618:	0152      	lsls	r2, r2, #5
 800961a:	4402      	add	r2, r0
 800961c:	6812      	ldr	r2, [r2, #0]
 800961e:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009622:	3358      	adds	r3, #88	; 0x58
 8009624:	015b      	lsls	r3, r3, #5
 8009626:	440b      	add	r3, r1
 8009628:	601a      	str	r2, [r3, #0]
}
 800962a:	b006      	add	sp, #24
 800962c:	4770      	bx	lr
 800962e:	bf00      	nop

08009630 <usb_lld_start_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_start_in(USBDriver *usbp, usbep_t ep) {
 8009630:	b084      	sub	sp, #16
 8009632:	9001      	str	r0, [sp, #4]
 8009634:	460b      	mov	r3, r1
 8009636:	f88d 3003 	strb.w	r3, [sp, #3]
  USBInEndpointState *isp = usbp->epc[ep]->in_state;
 800963a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800963e:	9a01      	ldr	r2, [sp, #4]
 8009640:	3302      	adds	r3, #2
 8009642:	009b      	lsls	r3, r3, #2
 8009644:	4413      	add	r3, r2
 8009646:	685b      	ldr	r3, [r3, #4]
 8009648:	695b      	ldr	r3, [r3, #20]
 800964a:	9303      	str	r3, [sp, #12]

  /* Transfer initialization.*/
  isp->totsize = isp->txsize;
 800964c:	9b03      	ldr	r3, [sp, #12]
 800964e:	681a      	ldr	r2, [r3, #0]
 8009650:	9b03      	ldr	r3, [sp, #12]
 8009652:	60da      	str	r2, [r3, #12]
  if (isp->txsize == 0) {
 8009654:	9b03      	ldr	r3, [sp, #12]
 8009656:	681b      	ldr	r3, [r3, #0]
 8009658:	2b00      	cmp	r3, #0
 800965a:	d10b      	bne.n	8009674 <usb_lld_start_in+0x44>
    /* Special case, sending zero size packet.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_PKTCNT(1) | DIEPTSIZ_XFRSIZ(0);
 800965c:	9b01      	ldr	r3, [sp, #4]
 800965e:	6eda      	ldr	r2, [r3, #108]	; 0x6c
 8009660:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009664:	015b      	lsls	r3, r3, #5
 8009666:	4413      	add	r3, r2
 8009668:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 800966c:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 8009670:	601a      	str	r2, [r3, #0]
 8009672:	e031      	b.n	80096d8 <usb_lld_start_in+0xa8>
  }
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
 8009674:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009678:	2b00      	cmp	r3, #0
 800967a:	d106      	bne.n	800968a <usb_lld_start_in+0x5a>
 800967c:	9b03      	ldr	r3, [sp, #12]
 800967e:	681b      	ldr	r3, [r3, #0]
 8009680:	2b40      	cmp	r3, #64	; 0x40
 8009682:	d902      	bls.n	800968a <usb_lld_start_in+0x5a>
      isp->txsize = EP0_MAX_INSIZE;
 8009684:	9b03      	ldr	r3, [sp, #12]
 8009686:	2240      	movs	r2, #64	; 0x40
 8009688:	601a      	str	r2, [r3, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 800968a:	9b03      	ldr	r3, [sp, #12]
 800968c:	681a      	ldr	r2, [r3, #0]
 800968e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009692:	9901      	ldr	r1, [sp, #4]
 8009694:	3302      	adds	r3, #2
 8009696:	009b      	lsls	r3, r3, #2
 8009698:	440b      	add	r3, r1
 800969a:	685b      	ldr	r3, [r3, #4]
 800969c:	8a1b      	ldrh	r3, [r3, #16]
 800969e:	4413      	add	r3, r2
 80096a0:	1e5a      	subs	r2, r3, #1
                    usbp->epc[ep]->in_maxsize;
 80096a2:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096a6:	9901      	ldr	r1, [sp, #4]
 80096a8:	3302      	adds	r3, #2
 80096aa:	009b      	lsls	r3, r3, #2
 80096ac:	440b      	add	r3, r1
 80096ae:	685b      	ldr	r3, [r3, #4]
 80096b0:	8a1b      	ldrh	r3, [r3, #16]
  else {
    if ((ep == 0) && (isp->txsize > EP0_MAX_INSIZE))
      isp->txsize = EP0_MAX_INSIZE;

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
 80096b2:	fbb2 f3f3 	udiv	r3, r2, r3
 80096b6:	9302      	str	r3, [sp, #8]
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096b8:	9b01      	ldr	r3, [sp, #4]
 80096ba:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80096bc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096c0:	9a02      	ldr	r2, [sp, #8]
 80096c2:	04d0      	lsls	r0, r2, #19
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
 80096c4:	9a03      	ldr	r2, [sp, #12]
 80096c6:	6812      	ldr	r2, [r2, #0]

    /* Normal case.*/
    uint32_t pcnt = (isp->txsize + usbp->epc[ep]->in_maxsize - 1) /
                    usbp->epc[ep]->in_maxsize;
    /* TODO: Support more than one packet per frame for isochronous transfers.*/
    usbp->otg->ie[ep].DIEPTSIZ = DIEPTSIZ_MCNT(1) | DIEPTSIZ_PKTCNT(pcnt) |
 80096c8:	4302      	orrs	r2, r0
 80096ca:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 80096ce:	015b      	lsls	r3, r3, #5
 80096d0:	440b      	add	r3, r1
 80096d2:	f503 6311 	add.w	r3, r3, #2320	; 0x910
 80096d6:	601a      	str	r2, [r3, #0]
                                 DIEPTSIZ_XFRSIZ(isp->txsize);
  }

  /* Special case of isochronous endpoint.*/
  if ((usbp->epc[ep]->ep_mode & USB_EP_MODE_TYPE) == USB_EP_MODE_TYPE_ISOC) {
 80096d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80096dc:	9a01      	ldr	r2, [sp, #4]
 80096de:	3302      	adds	r3, #2
 80096e0:	009b      	lsls	r3, r3, #2
 80096e2:	4413      	add	r3, r2
 80096e4:	685b      	ldr	r3, [r3, #4]
 80096e6:	681b      	ldr	r3, [r3, #0]
 80096e8:	f003 0303 	and.w	r3, r3, #3
 80096ec:	2b01      	cmp	r3, #1
 80096ee:	d12c      	bne.n	800974a <usb_lld_start_in+0x11a>
    /* Odd/even bit toggling.*/
    if (usbp->otg->DSTS & DSTS_FNSOF_ODD)
 80096f0:	9b01      	ldr	r3, [sp, #4]
 80096f2:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80096f4:	f8d3 3808 	ldr.w	r3, [r3, #2056]	; 0x808
 80096f8:	f403 7380 	and.w	r3, r3, #256	; 0x100
 80096fc:	2b00      	cmp	r3, #0
 80096fe:	d012      	beq.n	8009726 <usb_lld_start_in+0xf6>
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SEVNFRM;
 8009700:	9b01      	ldr	r3, [sp, #4]
 8009702:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 8009704:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009708:	9a01      	ldr	r2, [sp, #4]
 800970a:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 800970c:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009710:	3248      	adds	r2, #72	; 0x48
 8009712:	0152      	lsls	r2, r2, #5
 8009714:	4402      	add	r2, r0
 8009716:	6812      	ldr	r2, [r2, #0]
 8009718:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 800971c:	3348      	adds	r3, #72	; 0x48
 800971e:	015b      	lsls	r3, r3, #5
 8009720:	440b      	add	r3, r1
 8009722:	601a      	str	r2, [r3, #0]
 8009724:	e011      	b.n	800974a <usb_lld_start_in+0x11a>
    else
      usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_SODDFRM;
 8009726:	9b01      	ldr	r3, [sp, #4]
 8009728:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800972a:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800972e:	9a01      	ldr	r2, [sp, #4]
 8009730:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009732:	f89d 2003 	ldrb.w	r2, [sp, #3]
 8009736:	3248      	adds	r2, #72	; 0x48
 8009738:	0152      	lsls	r2, r2, #5
 800973a:	4402      	add	r2, r0
 800973c:	6812      	ldr	r2, [r2, #0]
 800973e:	f042 5200 	orr.w	r2, r2, #536870912	; 0x20000000
 8009742:	3348      	adds	r3, #72	; 0x48
 8009744:	015b      	lsls	r3, r3, #5
 8009746:	440b      	add	r3, r1
 8009748:	601a      	str	r2, [r3, #0]
  }

  /* Starting operation.*/
  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_EPENA | DIEPCTL_CNAK;
 800974a:	9b01      	ldr	r3, [sp, #4]
 800974c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800974e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009752:	9a01      	ldr	r2, [sp, #4]
 8009754:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009756:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800975a:	3248      	adds	r2, #72	; 0x48
 800975c:	0152      	lsls	r2, r2, #5
 800975e:	4402      	add	r2, r0
 8009760:	6812      	ldr	r2, [r2, #0]
 8009762:	f042 4204 	orr.w	r2, r2, #2214592512	; 0x84000000
 8009766:	3348      	adds	r3, #72	; 0x48
 8009768:	015b      	lsls	r3, r3, #5
 800976a:	440b      	add	r3, r1
 800976c:	601a      	str	r2, [r3, #0]
  usbp->otg->DIEPEMPMSK |= DIEPEMPMSK_INEPTXFEM(ep);
 800976e:	9b01      	ldr	r3, [sp, #4]
 8009770:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8009772:	9a01      	ldr	r2, [sp, #4]
 8009774:	6ed2      	ldr	r2, [r2, #108]	; 0x6c
 8009776:	f8d2 1834 	ldr.w	r1, [r2, #2100]	; 0x834
 800977a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800977e:	2001      	movs	r0, #1
 8009780:	fa00 f202 	lsl.w	r2, r0, r2
 8009784:	430a      	orrs	r2, r1
 8009786:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
}
 800978a:	b004      	add	sp, #16
 800978c:	4770      	bx	lr
 800978e:	bf00      	nop

08009790 <usb_lld_stall_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_out(USBDriver *usbp, usbep_t ep) {
 8009790:	b082      	sub	sp, #8
 8009792:	9001      	str	r0, [sp, #4]
 8009794:	460b      	mov	r3, r1
 8009796:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL |= DOEPCTL_STALL;
 800979a:	9b01      	ldr	r3, [sp, #4]
 800979c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800979e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097a2:	9a01      	ldr	r2, [sp, #4]
 80097a4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097a6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097aa:	3258      	adds	r2, #88	; 0x58
 80097ac:	0152      	lsls	r2, r2, #5
 80097ae:	4402      	add	r2, r0
 80097b0:	6812      	ldr	r2, [r2, #0]
 80097b2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097b6:	3358      	adds	r3, #88	; 0x58
 80097b8:	015b      	lsls	r3, r3, #5
 80097ba:	440b      	add	r3, r1
 80097bc:	601a      	str	r2, [r3, #0]
}
 80097be:	b002      	add	sp, #8
 80097c0:	4770      	bx	lr
 80097c2:	bf00      	nop
 80097c4:	f3af 8000 	nop.w
 80097c8:	f3af 8000 	nop.w
 80097cc:	f3af 8000 	nop.w

080097d0 <usb_lld_stall_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_stall_in(USBDriver *usbp, usbep_t ep) {
 80097d0:	b082      	sub	sp, #8
 80097d2:	9001      	str	r0, [sp, #4]
 80097d4:	460b      	mov	r3, r1
 80097d6:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL |= DIEPCTL_STALL;
 80097da:	9b01      	ldr	r3, [sp, #4]
 80097dc:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 80097de:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80097e2:	9a01      	ldr	r2, [sp, #4]
 80097e4:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 80097e6:	f89d 2003 	ldrb.w	r2, [sp, #3]
 80097ea:	3248      	adds	r2, #72	; 0x48
 80097ec:	0152      	lsls	r2, r2, #5
 80097ee:	4402      	add	r2, r0
 80097f0:	6812      	ldr	r2, [r2, #0]
 80097f2:	f442 1200 	orr.w	r2, r2, #2097152	; 0x200000
 80097f6:	3348      	adds	r3, #72	; 0x48
 80097f8:	015b      	lsls	r3, r3, #5
 80097fa:	440b      	add	r3, r1
 80097fc:	601a      	str	r2, [r3, #0]
}
 80097fe:	b002      	add	sp, #8
 8009800:	4770      	bx	lr
 8009802:	bf00      	nop
 8009804:	f3af 8000 	nop.w
 8009808:	f3af 8000 	nop.w
 800980c:	f3af 8000 	nop.w

08009810 <usb_lld_clear_out>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_out(USBDriver *usbp, usbep_t ep) {
 8009810:	b082      	sub	sp, #8
 8009812:	9001      	str	r0, [sp, #4]
 8009814:	460b      	mov	r3, r1
 8009816:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->oe[ep].DOEPCTL &= ~DOEPCTL_STALL;
 800981a:	9b01      	ldr	r3, [sp, #4]
 800981c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800981e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009822:	9a01      	ldr	r2, [sp, #4]
 8009824:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009826:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800982a:	3258      	adds	r2, #88	; 0x58
 800982c:	0152      	lsls	r2, r2, #5
 800982e:	4402      	add	r2, r0
 8009830:	6812      	ldr	r2, [r2, #0]
 8009832:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009836:	3358      	adds	r3, #88	; 0x58
 8009838:	015b      	lsls	r3, r3, #5
 800983a:	440b      	add	r3, r1
 800983c:	601a      	str	r2, [r3, #0]
}
 800983e:	b002      	add	sp, #8
 8009840:	4770      	bx	lr
 8009842:	bf00      	nop
 8009844:	f3af 8000 	nop.w
 8009848:	f3af 8000 	nop.w
 800984c:	f3af 8000 	nop.w

08009850 <usb_lld_clear_in>:
 * @param[in] usbp      pointer to the @p USBDriver object
 * @param[in] ep        endpoint number
 *
 * @notapi
 */
void usb_lld_clear_in(USBDriver *usbp, usbep_t ep) {
 8009850:	b082      	sub	sp, #8
 8009852:	9001      	str	r0, [sp, #4]
 8009854:	460b      	mov	r3, r1
 8009856:	f88d 3003 	strb.w	r3, [sp, #3]

  usbp->otg->ie[ep].DIEPCTL &= ~DIEPCTL_STALL;
 800985a:	9b01      	ldr	r3, [sp, #4]
 800985c:	6ed9      	ldr	r1, [r3, #108]	; 0x6c
 800985e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8009862:	9a01      	ldr	r2, [sp, #4]
 8009864:	6ed0      	ldr	r0, [r2, #108]	; 0x6c
 8009866:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800986a:	3248      	adds	r2, #72	; 0x48
 800986c:	0152      	lsls	r2, r2, #5
 800986e:	4402      	add	r2, r0
 8009870:	6812      	ldr	r2, [r2, #0]
 8009872:	f422 1200 	bic.w	r2, r2, #2097152	; 0x200000
 8009876:	3348      	adds	r3, #72	; 0x48
 8009878:	015b      	lsls	r3, r3, #5
 800987a:	440b      	add	r3, r1
 800987c:	601a      	str	r2, [r3, #0]
}
 800987e:	b002      	add	sp, #8
 8009880:	4770      	bx	lr
 8009882:	bf00      	nop
 8009884:	f3af 8000 	nop.w
 8009888:	f3af 8000 	nop.w
 800988c:	f3af 8000 	nop.w

08009890 <usb_lld_pump>:
 *
 * @param[in] p         pointer to the @p USBDriver object
 *
 * @special
 */
void usb_lld_pump(void *p) {
 8009890:	b500      	push	{lr}
 8009892:	b089      	sub	sp, #36	; 0x24
 8009894:	9001      	str	r0, [sp, #4]
  USBDriver *usbp = (USBDriver *)p;
 8009896:	9b01      	ldr	r3, [sp, #4]
 8009898:	9306      	str	r3, [sp, #24]
  stm32_otg_t *otgp = usbp->otg;
 800989a:	9b06      	ldr	r3, [sp, #24]
 800989c:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 800989e:	9305      	str	r3, [sp, #20]

#if defined(_CHIBIOS_RT_)
  chRegSetThreadName("usb_lld_pump");
 80098a0:	483d      	ldr	r0, [pc, #244]	; (8009998 <usb_lld_pump+0x108>)
 80098a2:	f7fe fd3d 	bl	8008320 <chRegSetThreadName>
#endif
  osalSysLock();
 80098a6:	f7fe fd4b 	bl	8008340 <osalSysLock>
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098aa:	9b06      	ldr	r3, [sp, #24]
 80098ac:	781b      	ldrb	r3, [r3, #0]
 80098ae:	2b01      	cmp	r3, #1
 80098b0:	d009      	beq.n	80098c6 <usb_lld_pump+0x36>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098b2:	9b06      	ldr	r3, [sp, #24]
 80098b4:	6f9b      	ldr	r3, [r3, #120]	; 0x78
  while (true) {
    usbep_t ep;
    uint32_t epmask;

    /* Nothing to do, going to sleep.*/
    if ((usbp->state == USB_STOP) ||
 80098b6:	2b00      	cmp	r3, #0
 80098b8:	d110      	bne.n	80098dc <usb_lld_pump+0x4c>
        ((usbp->txpending == 0) && !(otgp->GINTSTS & GINTSTS_RXFLVL))) {
 80098ba:	9b05      	ldr	r3, [sp, #20]
 80098bc:	695b      	ldr	r3, [r3, #20]
 80098be:	f003 0310 	and.w	r3, r3, #16
 80098c2:	2b00      	cmp	r3, #0
 80098c4:	d10a      	bne.n	80098dc <usb_lld_pump+0x4c>
      otgp->GINTMSK |= GINTMSK_RXFLVLM;
 80098c6:	9b05      	ldr	r3, [sp, #20]
 80098c8:	699b      	ldr	r3, [r3, #24]
 80098ca:	f043 0210 	orr.w	r2, r3, #16
 80098ce:	9b05      	ldr	r3, [sp, #20]
 80098d0:	619a      	str	r2, [r3, #24]
      osalThreadSuspendS(&usbp->wait);
 80098d2:	9b06      	ldr	r3, [sp, #24]
 80098d4:	337c      	adds	r3, #124	; 0x7c
 80098d6:	4618      	mov	r0, r3
 80098d8:	f7fe fd62 	bl	80083a0 <osalThreadSuspendS>
    }
    osalSysUnlock();
 80098dc:	f7fe fd38 	bl	8008350 <osalSysUnlock>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 80098e0:	2300      	movs	r3, #0
 80098e2:	f88d 301f 	strb.w	r3, [sp, #31]
 80098e6:	e04d      	b.n	8009984 <usb_lld_pump+0xf4>

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098e8:	e002      	b.n	80098f0 <usb_lld_pump+0x60>
        otg_rxfifo_handler(usbp);
 80098ea:	9806      	ldr	r0, [sp, #24]
 80098ec:	f7fe fe78 	bl	80085e0 <otg_rxfifo_handler>

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {

      /* Empties the RX FIFO.*/
      while (otgp->GINTSTS & GINTSTS_RXFLVL) {
 80098f0:	9b05      	ldr	r3, [sp, #20]
 80098f2:	695b      	ldr	r3, [r3, #20]
 80098f4:	f003 0310 	and.w	r3, r3, #16
 80098f8:	2b00      	cmp	r3, #0
 80098fa:	d1f6      	bne.n	80098ea <usb_lld_pump+0x5a>
        otg_rxfifo_handler(usbp);
      }

      epmask = (1 << ep);
 80098fc:	f89d 301f 	ldrb.w	r3, [sp, #31]
 8009900:	2201      	movs	r2, #1
 8009902:	fa02 f303 	lsl.w	r3, r2, r3
 8009906:	9304      	str	r3, [sp, #16]
      if (usbp->txpending & epmask) {
 8009908:	9b06      	ldr	r3, [sp, #24]
 800990a:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800990c:	9b04      	ldr	r3, [sp, #16]
 800990e:	4013      	ands	r3, r2
 8009910:	2b00      	cmp	r3, #0
 8009912:	d032      	beq.n	800997a <usb_lld_pump+0xea>
        bool done;

        osalSysLock();
 8009914:	f7fe fd14 	bl	8008340 <osalSysLock>
           operation.
           Synopsys document: DesignWare Cores USB 2.0 Hi-Speed On-The-Go (OTG)
             "The application has to finish writing one complete packet before
              switching to a different channel/endpoint FIFO. Violating this
              rule results in an error.".*/
        otgp->GAHBCFG &= ~GAHBCFG_GINTMSK;
 8009918:	9b05      	ldr	r3, [sp, #20]
 800991a:	689b      	ldr	r3, [r3, #8]
 800991c:	f023 0201 	bic.w	r2, r3, #1
 8009920:	9b05      	ldr	r3, [sp, #20]
 8009922:	609a      	str	r2, [r3, #8]
        usbp->txpending &= ~epmask;
 8009924:	9b06      	ldr	r3, [sp, #24]
 8009926:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 8009928:	9b04      	ldr	r3, [sp, #16]
 800992a:	43db      	mvns	r3, r3
 800992c:	401a      	ands	r2, r3
 800992e:	9b06      	ldr	r3, [sp, #24]
 8009930:	679a      	str	r2, [r3, #120]	; 0x78
        osalSysUnlock();
 8009932:	f7fe fd0d 	bl	8008350 <osalSysUnlock>

        done = otg_txfifo_handler(usbp, ep);
 8009936:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800993a:	9806      	ldr	r0, [sp, #24]
 800993c:	4619      	mov	r1, r3
 800993e:	f7fe fed7 	bl	80086f0 <otg_txfifo_handler>
 8009942:	4603      	mov	r3, r0
 8009944:	f88d 300f 	strb.w	r3, [sp, #15]

        osalSysLock();
 8009948:	f7fe fcfa 	bl	8008340 <osalSysLock>
        otgp->GAHBCFG |= GAHBCFG_GINTMSK;
 800994c:	9b05      	ldr	r3, [sp, #20]
 800994e:	689b      	ldr	r3, [r3, #8]
 8009950:	f043 0201 	orr.w	r2, r3, #1
 8009954:	9b05      	ldr	r3, [sp, #20]
 8009956:	609a      	str	r2, [r3, #8]
        if (!done)
 8009958:	f89d 300f 	ldrb.w	r3, [sp, #15]
 800995c:	f083 0301 	eor.w	r3, r3, #1
 8009960:	b2db      	uxtb	r3, r3
 8009962:	2b00      	cmp	r3, #0
 8009964:	d007      	beq.n	8009976 <usb_lld_pump+0xe6>
          otgp->DIEPEMPMSK |= epmask;
 8009966:	9b05      	ldr	r3, [sp, #20]
 8009968:	f8d3 2834 	ldr.w	r2, [r3, #2100]	; 0x834
 800996c:	9b04      	ldr	r3, [sp, #16]
 800996e:	431a      	orrs	r2, r3
 8009970:	9b05      	ldr	r3, [sp, #20]
 8009972:	f8c3 2834 	str.w	r2, [r3, #2100]	; 0x834
        osalSysUnlock();
 8009976:	f7fe fceb 	bl	8008350 <osalSysUnlock>
      osalThreadSuspendS(&usbp->wait);
    }
    osalSysUnlock();

    /* Checks if there are TXFIFOs to be filled.*/
    for (ep = 0; ep <= usbp->otgparams->num_endpoints; ep++) {
 800997a:	f89d 301f 	ldrb.w	r3, [sp, #31]
 800997e:	3301      	adds	r3, #1
 8009980:	f88d 301f 	strb.w	r3, [sp, #31]
 8009984:	f89d 201f 	ldrb.w	r2, [sp, #31]
 8009988:	9b06      	ldr	r3, [sp, #24]
 800998a:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 800998c:	689b      	ldr	r3, [r3, #8]
 800998e:	429a      	cmp	r2, r3
 8009990:	d9aa      	bls.n	80098e8 <usb_lld_pump+0x58>
        if (!done)
          otgp->DIEPEMPMSK |= epmask;
        osalSysUnlock();
      }
    }
    osalSysLock();
 8009992:	f7fe fcd5 	bl	8008340 <osalSysLock>
  }
 8009996:	e788      	b.n	80098aa <usb_lld_pump+0x1a>
 8009998:	080195f0 	.word	0x080195f0
 800999c:	f3af 8000 	nop.w

080099a0 <osalSysGetStatusAndLockX>:
 * @return              The previous system status, the encoding of this
 *                      status word is architecture-dependent and opaque.
 *
 * @xclass
 */
static inline syssts_t osalSysGetStatusAndLockX(void) {
 80099a0:	b508      	push	{r3, lr}

  return chSysGetStatusAndLockX();
 80099a2:	f7f6 ff6d 	bl	8000880 <chSysGetStatusAndLockX>
 80099a6:	4603      	mov	r3, r0
}
 80099a8:	4618      	mov	r0, r3
 80099aa:	bd08      	pop	{r3, pc}
 80099ac:	f3af 8000 	nop.w

080099b0 <osalSysRestoreStatusX>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
static inline void osalSysRestoreStatusX(syssts_t sts) {
 80099b0:	b500      	push	{lr}
 80099b2:	b083      	sub	sp, #12
 80099b4:	9001      	str	r0, [sp, #4]

  chSysRestoreStatusX(sts);
 80099b6:	9801      	ldr	r0, [sp, #4]
 80099b8:	f7f6 ff82 	bl	80008c0 <chSysRestoreStatusX>
}
 80099bc:	b003      	add	sp, #12
 80099be:	f85d fb04 	ldr.w	pc, [sp], #4
 80099c2:	bf00      	nop
 80099c4:	f3af 8000 	nop.w
 80099c8:	f3af 8000 	nop.w
 80099cc:	f3af 8000 	nop.w

080099d0 <rtc_enter_init>:
 *
 * @notapi
 */
static void rtc_enter_init(void) {

  RTCD1.rtc->ISR |= RTC_ISR_INIT;
 80099d0:	4b08      	ldr	r3, [pc, #32]	; (80099f4 <rtc_enter_init+0x24>)
 80099d2:	681b      	ldr	r3, [r3, #0]
 80099d4:	4a07      	ldr	r2, [pc, #28]	; (80099f4 <rtc_enter_init+0x24>)
 80099d6:	6812      	ldr	r2, [r2, #0]
 80099d8:	68d2      	ldr	r2, [r2, #12]
 80099da:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80099de:	60da      	str	r2, [r3, #12]
  while ((RTCD1.rtc->ISR & RTC_ISR_INITF) == 0)
 80099e0:	bf00      	nop
 80099e2:	4b04      	ldr	r3, [pc, #16]	; (80099f4 <rtc_enter_init+0x24>)
 80099e4:	681b      	ldr	r3, [r3, #0]
 80099e6:	68db      	ldr	r3, [r3, #12]
 80099e8:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80099ec:	2b00      	cmp	r3, #0
 80099ee:	d0f8      	beq.n	80099e2 <rtc_enter_init+0x12>
    ;
}
 80099f0:	4770      	bx	lr
 80099f2:	bf00      	nop
 80099f4:	20001f58 	.word	0x20001f58
 80099f8:	f3af 8000 	nop.w
 80099fc:	f3af 8000 	nop.w

08009a00 <rtc_exit_init>:
 *
 * @notapi
 */
static inline void rtc_exit_init(void) {

  RTCD1.rtc->ISR &= ~RTC_ISR_INIT;
 8009a00:	4b04      	ldr	r3, [pc, #16]	; (8009a14 <rtc_exit_init+0x14>)
 8009a02:	681b      	ldr	r3, [r3, #0]
 8009a04:	4a03      	ldr	r2, [pc, #12]	; (8009a14 <rtc_exit_init+0x14>)
 8009a06:	6812      	ldr	r2, [r2, #0]
 8009a08:	68d2      	ldr	r2, [r2, #12]
 8009a0a:	f022 0280 	bic.w	r2, r2, #128	; 0x80
 8009a0e:	60da      	str	r2, [r3, #12]
}
 8009a10:	4770      	bx	lr
 8009a12:	bf00      	nop
 8009a14:	20001f58 	.word	0x20001f58
 8009a18:	f3af 8000 	nop.w
 8009a1c:	f3af 8000 	nop.w

08009a20 <rtc_decode_time>:
 * @param[in] tr        TR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_time(uint32_t tr, RTCDateTime *timespec) {
 8009a20:	b084      	sub	sp, #16
 8009a22:	9001      	str	r0, [sp, #4]
 8009a24:	9100      	str	r1, [sp, #0]
  uint32_t n;

  n  = ((tr >> RTC_TR_HT_OFFSET) & 3)   * 36000000;
 8009a26:	9b01      	ldr	r3, [sp, #4]
 8009a28:	0d1b      	lsrs	r3, r3, #20
 8009a2a:	f003 0303 	and.w	r3, r3, #3
 8009a2e:	4a21      	ldr	r2, [pc, #132]	; (8009ab4 <rtc_decode_time+0x94>)
 8009a30:	fb02 f303 	mul.w	r3, r2, r3
 8009a34:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_HU_OFFSET) & 15)  * 3600000;
 8009a36:	9b01      	ldr	r3, [sp, #4]
 8009a38:	0c1b      	lsrs	r3, r3, #16
 8009a3a:	f003 030f 	and.w	r3, r3, #15
 8009a3e:	4a1e      	ldr	r2, [pc, #120]	; (8009ab8 <rtc_decode_time+0x98>)
 8009a40:	fb02 f303 	mul.w	r3, r2, r3
 8009a44:	9a03      	ldr	r2, [sp, #12]
 8009a46:	4413      	add	r3, r2
 8009a48:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNT_OFFSET) & 7)  * 600000;
 8009a4a:	9b01      	ldr	r3, [sp, #4]
 8009a4c:	0b1b      	lsrs	r3, r3, #12
 8009a4e:	f003 0307 	and.w	r3, r3, #7
 8009a52:	4a1a      	ldr	r2, [pc, #104]	; (8009abc <rtc_decode_time+0x9c>)
 8009a54:	fb02 f303 	mul.w	r3, r2, r3
 8009a58:	9a03      	ldr	r2, [sp, #12]
 8009a5a:	4413      	add	r3, r2
 8009a5c:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_MNU_OFFSET) & 15) * 60000;
 8009a5e:	9b01      	ldr	r3, [sp, #4]
 8009a60:	0a1b      	lsrs	r3, r3, #8
 8009a62:	f003 030f 	and.w	r3, r3, #15
 8009a66:	f64e 2260 	movw	r2, #60000	; 0xea60
 8009a6a:	fb02 f303 	mul.w	r3, r2, r3
 8009a6e:	9a03      	ldr	r2, [sp, #12]
 8009a70:	4413      	add	r3, r2
 8009a72:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_ST_OFFSET) & 7)   * 10000;
 8009a74:	9b01      	ldr	r3, [sp, #4]
 8009a76:	091b      	lsrs	r3, r3, #4
 8009a78:	f003 0307 	and.w	r3, r3, #7
 8009a7c:	f242 7210 	movw	r2, #10000	; 0x2710
 8009a80:	fb02 f303 	mul.w	r3, r2, r3
 8009a84:	9a03      	ldr	r2, [sp, #12]
 8009a86:	4413      	add	r3, r2
 8009a88:	9303      	str	r3, [sp, #12]
  n += ((tr >> RTC_TR_SU_OFFSET) & 15)  * 1000;
 8009a8a:	9b01      	ldr	r3, [sp, #4]
 8009a8c:	f003 030f 	and.w	r3, r3, #15
 8009a90:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 8009a94:	fb02 f303 	mul.w	r3, r2, r3
 8009a98:	9a03      	ldr	r2, [sp, #12]
 8009a9a:	4413      	add	r3, r2
 8009a9c:	9303      	str	r3, [sp, #12]
  timespec->millisecond = n;
 8009a9e:	9b03      	ldr	r3, [sp, #12]
 8009aa0:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009aa4:	9a00      	ldr	r2, [sp, #0]
 8009aa6:	6853      	ldr	r3, [r2, #4]
 8009aa8:	f361 031a 	bfi	r3, r1, #0, #27
 8009aac:	6053      	str	r3, [r2, #4]
}
 8009aae:	b004      	add	sp, #16
 8009ab0:	4770      	bx	lr
 8009ab2:	bf00      	nop
 8009ab4:	02255100 	.word	0x02255100
 8009ab8:	0036ee80 	.word	0x0036ee80
 8009abc:	000927c0 	.word	0x000927c0

08009ac0 <rtc_decode_date>:
 * @param[in] dr        DR register value
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {
 8009ac0:	b082      	sub	sp, #8
 8009ac2:	9001      	str	r0, [sp, #4]
 8009ac4:	9100      	str	r1, [sp, #0]

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ac6:	9b01      	ldr	r3, [sp, #4]
 8009ac8:	0d1b      	lsrs	r3, r3, #20
 8009aca:	b2db      	uxtb	r3, r3
 8009acc:	f003 030f 	and.w	r3, r3, #15
 8009ad0:	b2db      	uxtb	r3, r3
 8009ad2:	461a      	mov	r2, r3
 8009ad4:	0092      	lsls	r2, r2, #2
 8009ad6:	4413      	add	r3, r2
 8009ad8:	005b      	lsls	r3, r3, #1
 8009ada:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
 8009adc:	9b01      	ldr	r3, [sp, #4]
 8009ade:	0c1b      	lsrs	r3, r3, #16
 *
 * @notapi
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
 8009ae0:	b2db      	uxtb	r3, r3
 8009ae2:	f003 030f 	and.w	r3, r3, #15
 8009ae6:	b2db      	uxtb	r3, r3
 8009ae8:	4413      	add	r3, r2
 8009aea:	b2d9      	uxtb	r1, r3
 8009aec:	9a00      	ldr	r2, [sp, #0]
 8009aee:	7813      	ldrb	r3, [r2, #0]
 8009af0:	f361 0307 	bfi	r3, r1, #0, #8
 8009af4:	7013      	strb	r3, [r2, #0]
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009af6:	9b01      	ldr	r3, [sp, #4]
 8009af8:	0b1b      	lsrs	r3, r3, #12
 8009afa:	b2db      	uxtb	r3, r3
 8009afc:	f003 0301 	and.w	r3, r3, #1
 8009b00:	b2db      	uxtb	r3, r3
 8009b02:	461a      	mov	r2, r3
 8009b04:	0092      	lsls	r2, r2, #2
 8009b06:	4413      	add	r3, r2
 8009b08:	005b      	lsls	r3, r3, #1
 8009b0a:	b2da      	uxtb	r2, r3
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
 8009b0c:	9b01      	ldr	r3, [sp, #4]
 8009b0e:	0a1b      	lsrs	r3, r3, #8
 */
static void rtc_decode_date(uint32_t dr, RTCDateTime *timespec) {

  timespec->year  = (((dr >> RTC_DR_YT_OFFSET) & 15) * 10) +
                     ((dr >> RTC_DR_YU_OFFSET) & 15);
  timespec->month = (((dr >> RTC_TR_MNT_OFFSET) & 1) * 10) +
 8009b10:	b2db      	uxtb	r3, r3
 8009b12:	f003 030f 	and.w	r3, r3, #15
 8009b16:	b2db      	uxtb	r3, r3
 8009b18:	4413      	add	r3, r2
 8009b1a:	b2db      	uxtb	r3, r3
 8009b1c:	f003 030f 	and.w	r3, r3, #15
 8009b20:	b2d9      	uxtb	r1, r3
 8009b22:	9a00      	ldr	r2, [sp, #0]
 8009b24:	7853      	ldrb	r3, [r2, #1]
 8009b26:	f361 0303 	bfi	r3, r1, #0, #4
 8009b2a:	7053      	strb	r3, [r2, #1]
                     ((dr >> RTC_TR_MNU_OFFSET) & 15);
  timespec->day   = (((dr >> RTC_DR_DT_OFFSET) & 3) * 10) +
 8009b2c:	9b01      	ldr	r3, [sp, #4]
 8009b2e:	091b      	lsrs	r3, r3, #4
 8009b30:	b2db      	uxtb	r3, r3
 8009b32:	f003 0303 	and.w	r3, r3, #3
 8009b36:	b2db      	uxtb	r3, r3
 8009b38:	461a      	mov	r2, r3
 8009b3a:	0092      	lsls	r2, r2, #2
 8009b3c:	4413      	add	r3, r2
 8009b3e:	005b      	lsls	r3, r3, #1
 8009b40:	b2da      	uxtb	r2, r3
 8009b42:	9b01      	ldr	r3, [sp, #4]
 8009b44:	b2db      	uxtb	r3, r3
 8009b46:	f003 030f 	and.w	r3, r3, #15
 8009b4a:	b2db      	uxtb	r3, r3
 8009b4c:	4413      	add	r3, r2
 8009b4e:	b2db      	uxtb	r3, r3
 8009b50:	f003 031f 	and.w	r3, r3, #31
 8009b54:	b2d9      	uxtb	r1, r3
 8009b56:	9a00      	ldr	r2, [sp, #0]
 8009b58:	7893      	ldrb	r3, [r2, #2]
 8009b5a:	f361 0304 	bfi	r3, r1, #0, #5
 8009b5e:	7093      	strb	r3, [r2, #2]
                     ((dr >> RTC_DR_DU_OFFSET) & 15);
  timespec->dayofweek = (dr >> RTC_DR_WDU_OFFSET) & 7;
 8009b60:	9b01      	ldr	r3, [sp, #4]
 8009b62:	0b5b      	lsrs	r3, r3, #13
 8009b64:	b2db      	uxtb	r3, r3
 8009b66:	f003 0307 	and.w	r3, r3, #7
 8009b6a:	b2d9      	uxtb	r1, r3
 8009b6c:	9a00      	ldr	r2, [sp, #0]
 8009b6e:	7853      	ldrb	r3, [r2, #1]
 8009b70:	f361 1347 	bfi	r3, r1, #5, #3
 8009b74:	7053      	strb	r3, [r2, #1]
}
 8009b76:	b002      	add	sp, #8
 8009b78:	4770      	bx	lr
 8009b7a:	bf00      	nop
 8009b7c:	f3af 8000 	nop.w

08009b80 <rtc_encode_time>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the TR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_time(const RTCDateTime *timespec) {
 8009b80:	b084      	sub	sp, #16
 8009b82:	9001      	str	r0, [sp, #4]
  uint32_t n, tr = 0;
 8009b84:	2300      	movs	r3, #0
 8009b86:	9303      	str	r3, [sp, #12]

  /* Subseconds cannot be set.*/
  n = timespec->millisecond / 1000;
 8009b88:	9b01      	ldr	r3, [sp, #4]
 8009b8a:	685b      	ldr	r3, [r3, #4]
 8009b8c:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009b90:	4a39      	ldr	r2, [pc, #228]	; (8009c78 <rtc_encode_time+0xf8>)
 8009b92:	fb82 1203 	smull	r1, r2, r2, r3
 8009b96:	1192      	asrs	r2, r2, #6
 8009b98:	17db      	asrs	r3, r3, #31
 8009b9a:	1ad3      	subs	r3, r2, r3
 8009b9c:	9302      	str	r3, [sp, #8]

  /* Seconds conversion.*/
  tr = tr | ((n % 10) << RTC_TR_SU_OFFSET);
 8009b9e:	9902      	ldr	r1, [sp, #8]
 8009ba0:	4b36      	ldr	r3, [pc, #216]	; (8009c7c <rtc_encode_time+0xfc>)
 8009ba2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ba6:	08da      	lsrs	r2, r3, #3
 8009ba8:	4613      	mov	r3, r2
 8009baa:	009b      	lsls	r3, r3, #2
 8009bac:	4413      	add	r3, r2
 8009bae:	005b      	lsls	r3, r3, #1
 8009bb0:	1aca      	subs	r2, r1, r3
 8009bb2:	9b03      	ldr	r3, [sp, #12]
 8009bb4:	4313      	orrs	r3, r2
 8009bb6:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009bb8:	9a02      	ldr	r2, [sp, #8]
 8009bba:	4b30      	ldr	r3, [pc, #192]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bbc:	fba3 1302 	umull	r1, r3, r3, r2
 8009bc0:	08db      	lsrs	r3, r3, #3
 8009bc2:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_ST_OFFSET);
 8009bc4:	9902      	ldr	r1, [sp, #8]
 8009bc6:	4b2e      	ldr	r3, [pc, #184]	; (8009c80 <rtc_encode_time+0x100>)
 8009bc8:	fba3 2301 	umull	r2, r3, r3, r1
 8009bcc:	089a      	lsrs	r2, r3, #2
 8009bce:	4613      	mov	r3, r2
 8009bd0:	005b      	lsls	r3, r3, #1
 8009bd2:	4413      	add	r3, r2
 8009bd4:	005b      	lsls	r3, r3, #1
 8009bd6:	1aca      	subs	r2, r1, r3
 8009bd8:	0113      	lsls	r3, r2, #4
 8009bda:	9a03      	ldr	r2, [sp, #12]
 8009bdc:	4313      	orrs	r3, r2
 8009bde:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009be0:	9a02      	ldr	r2, [sp, #8]
 8009be2:	4b27      	ldr	r3, [pc, #156]	; (8009c80 <rtc_encode_time+0x100>)
 8009be4:	fba3 1302 	umull	r1, r3, r3, r2
 8009be8:	089b      	lsrs	r3, r3, #2
 8009bea:	9302      	str	r3, [sp, #8]

  /* Minutes conversion.*/
  tr = tr | ((n % 10) << RTC_TR_MNU_OFFSET);
 8009bec:	9902      	ldr	r1, [sp, #8]
 8009bee:	4b23      	ldr	r3, [pc, #140]	; (8009c7c <rtc_encode_time+0xfc>)
 8009bf0:	fba3 2301 	umull	r2, r3, r3, r1
 8009bf4:	08da      	lsrs	r2, r3, #3
 8009bf6:	4613      	mov	r3, r2
 8009bf8:	009b      	lsls	r3, r3, #2
 8009bfa:	4413      	add	r3, r2
 8009bfc:	005b      	lsls	r3, r3, #1
 8009bfe:	1aca      	subs	r2, r1, r3
 8009c00:	0213      	lsls	r3, r2, #8
 8009c02:	9a03      	ldr	r2, [sp, #12]
 8009c04:	4313      	orrs	r3, r2
 8009c06:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c08:	9a02      	ldr	r2, [sp, #8]
 8009c0a:	4b1c      	ldr	r3, [pc, #112]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c0c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c10:	08db      	lsrs	r3, r3, #3
 8009c12:	9302      	str	r3, [sp, #8]
  tr = tr | ((n % 6) << RTC_TR_MNT_OFFSET);
 8009c14:	9902      	ldr	r1, [sp, #8]
 8009c16:	4b1a      	ldr	r3, [pc, #104]	; (8009c80 <rtc_encode_time+0x100>)
 8009c18:	fba3 2301 	umull	r2, r3, r3, r1
 8009c1c:	089a      	lsrs	r2, r3, #2
 8009c1e:	4613      	mov	r3, r2
 8009c20:	005b      	lsls	r3, r3, #1
 8009c22:	4413      	add	r3, r2
 8009c24:	005b      	lsls	r3, r3, #1
 8009c26:	1aca      	subs	r2, r1, r3
 8009c28:	0313      	lsls	r3, r2, #12
 8009c2a:	9a03      	ldr	r2, [sp, #12]
 8009c2c:	4313      	orrs	r3, r2
 8009c2e:	9303      	str	r3, [sp, #12]
  n /= 6;
 8009c30:	9a02      	ldr	r2, [sp, #8]
 8009c32:	4b13      	ldr	r3, [pc, #76]	; (8009c80 <rtc_encode_time+0x100>)
 8009c34:	fba3 1302 	umull	r1, r3, r3, r2
 8009c38:	089b      	lsrs	r3, r3, #2
 8009c3a:	9302      	str	r3, [sp, #8]

  /* Hours conversion.*/
  tr = tr | ((n % 10) << RTC_TR_HU_OFFSET);
 8009c3c:	9902      	ldr	r1, [sp, #8]
 8009c3e:	4b0f      	ldr	r3, [pc, #60]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c40:	fba3 2301 	umull	r2, r3, r3, r1
 8009c44:	08da      	lsrs	r2, r3, #3
 8009c46:	4613      	mov	r3, r2
 8009c48:	009b      	lsls	r3, r3, #2
 8009c4a:	4413      	add	r3, r2
 8009c4c:	005b      	lsls	r3, r3, #1
 8009c4e:	1aca      	subs	r2, r1, r3
 8009c50:	0413      	lsls	r3, r2, #16
 8009c52:	9a03      	ldr	r2, [sp, #12]
 8009c54:	4313      	orrs	r3, r2
 8009c56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009c58:	9a02      	ldr	r2, [sp, #8]
 8009c5a:	4b08      	ldr	r3, [pc, #32]	; (8009c7c <rtc_encode_time+0xfc>)
 8009c5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009c60:	08db      	lsrs	r3, r3, #3
 8009c62:	9302      	str	r3, [sp, #8]
  tr = tr | (n << RTC_TR_HT_OFFSET);
 8009c64:	9b02      	ldr	r3, [sp, #8]
 8009c66:	051b      	lsls	r3, r3, #20
 8009c68:	9a03      	ldr	r2, [sp, #12]
 8009c6a:	4313      	orrs	r3, r2
 8009c6c:	9303      	str	r3, [sp, #12]

  return tr;
 8009c6e:	9b03      	ldr	r3, [sp, #12]
}
 8009c70:	4618      	mov	r0, r3
 8009c72:	b004      	add	sp, #16
 8009c74:	4770      	bx	lr
 8009c76:	bf00      	nop
 8009c78:	10624dd3 	.word	0x10624dd3
 8009c7c:	cccccccd 	.word	0xcccccccd
 8009c80:	aaaaaaab 	.word	0xaaaaaaab
 8009c84:	f3af 8000 	nop.w
 8009c88:	f3af 8000 	nop.w
 8009c8c:	f3af 8000 	nop.w

08009c90 <rtc_encode_date>:
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 * @return              the DR register encoding.
 *
 * @notapi
 */
static uint32_t rtc_encode_date(const RTCDateTime *timespec) {
 8009c90:	b084      	sub	sp, #16
 8009c92:	9001      	str	r0, [sp, #4]
  uint32_t n, dr = 0;
 8009c94:	2300      	movs	r3, #0
 8009c96:	9303      	str	r3, [sp, #12]

  /* Year conversion. Note, only years last two digits are considered.*/
  n = timespec->year;
 8009c98:	9b01      	ldr	r3, [sp, #4]
 8009c9a:	781b      	ldrb	r3, [r3, #0]
 8009c9c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YU_OFFSET);
 8009c9e:	9902      	ldr	r1, [sp, #8]
 8009ca0:	4b3e      	ldr	r3, [pc, #248]	; (8009d9c <rtc_encode_date+0x10c>)
 8009ca2:	fba3 2301 	umull	r2, r3, r3, r1
 8009ca6:	08da      	lsrs	r2, r3, #3
 8009ca8:	4613      	mov	r3, r2
 8009caa:	009b      	lsls	r3, r3, #2
 8009cac:	4413      	add	r3, r2
 8009cae:	005b      	lsls	r3, r3, #1
 8009cb0:	1aca      	subs	r2, r1, r3
 8009cb2:	0413      	lsls	r3, r2, #16
 8009cb4:	9a03      	ldr	r2, [sp, #12]
 8009cb6:	4313      	orrs	r3, r2
 8009cb8:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009cba:	9a02      	ldr	r2, [sp, #8]
 8009cbc:	4b37      	ldr	r3, [pc, #220]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cbe:	fba3 1302 	umull	r1, r3, r3, r2
 8009cc2:	08db      	lsrs	r3, r3, #3
 8009cc4:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_YT_OFFSET);
 8009cc6:	9902      	ldr	r1, [sp, #8]
 8009cc8:	4b34      	ldr	r3, [pc, #208]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cca:	fba3 2301 	umull	r2, r3, r3, r1
 8009cce:	08da      	lsrs	r2, r3, #3
 8009cd0:	4613      	mov	r3, r2
 8009cd2:	009b      	lsls	r3, r3, #2
 8009cd4:	4413      	add	r3, r2
 8009cd6:	005b      	lsls	r3, r3, #1
 8009cd8:	1aca      	subs	r2, r1, r3
 8009cda:	0513      	lsls	r3, r2, #20
 8009cdc:	9a03      	ldr	r2, [sp, #12]
 8009cde:	4313      	orrs	r3, r2
 8009ce0:	9303      	str	r3, [sp, #12]

  /* Months conversion.*/
  n = timespec->month;
 8009ce2:	9b01      	ldr	r3, [sp, #4]
 8009ce4:	785b      	ldrb	r3, [r3, #1]
 8009ce6:	f3c3 0303 	ubfx	r3, r3, #0, #4
 8009cea:	b2db      	uxtb	r3, r3
 8009cec:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MU_OFFSET);
 8009cee:	9902      	ldr	r1, [sp, #8]
 8009cf0:	4b2a      	ldr	r3, [pc, #168]	; (8009d9c <rtc_encode_date+0x10c>)
 8009cf2:	fba3 2301 	umull	r2, r3, r3, r1
 8009cf6:	08da      	lsrs	r2, r3, #3
 8009cf8:	4613      	mov	r3, r2
 8009cfa:	009b      	lsls	r3, r3, #2
 8009cfc:	4413      	add	r3, r2
 8009cfe:	005b      	lsls	r3, r3, #1
 8009d00:	1aca      	subs	r2, r1, r3
 8009d02:	0213      	lsls	r3, r2, #8
 8009d04:	9a03      	ldr	r2, [sp, #12]
 8009d06:	4313      	orrs	r3, r2
 8009d08:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d0a:	9a02      	ldr	r2, [sp, #8]
 8009d0c:	4b23      	ldr	r3, [pc, #140]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d0e:	fba3 1302 	umull	r1, r3, r3, r2
 8009d12:	08db      	lsrs	r3, r3, #3
 8009d14:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_MT_OFFSET);
 8009d16:	9902      	ldr	r1, [sp, #8]
 8009d18:	4b20      	ldr	r3, [pc, #128]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d1a:	fba3 2301 	umull	r2, r3, r3, r1
 8009d1e:	08da      	lsrs	r2, r3, #3
 8009d20:	4613      	mov	r3, r2
 8009d22:	009b      	lsls	r3, r3, #2
 8009d24:	4413      	add	r3, r2
 8009d26:	005b      	lsls	r3, r3, #1
 8009d28:	1aca      	subs	r2, r1, r3
 8009d2a:	0313      	lsls	r3, r2, #12
 8009d2c:	9a03      	ldr	r2, [sp, #12]
 8009d2e:	4313      	orrs	r3, r2
 8009d30:	9303      	str	r3, [sp, #12]

  /* Days conversion.*/
  n = timespec->day;
 8009d32:	9b01      	ldr	r3, [sp, #4]
 8009d34:	789b      	ldrb	r3, [r3, #2]
 8009d36:	f3c3 0304 	ubfx	r3, r3, #0, #5
 8009d3a:	b2db      	uxtb	r3, r3
 8009d3c:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DU_OFFSET);
 8009d3e:	9902      	ldr	r1, [sp, #8]
 8009d40:	4b16      	ldr	r3, [pc, #88]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d42:	fba3 2301 	umull	r2, r3, r3, r1
 8009d46:	08da      	lsrs	r2, r3, #3
 8009d48:	4613      	mov	r3, r2
 8009d4a:	009b      	lsls	r3, r3, #2
 8009d4c:	4413      	add	r3, r2
 8009d4e:	005b      	lsls	r3, r3, #1
 8009d50:	1aca      	subs	r2, r1, r3
 8009d52:	9b03      	ldr	r3, [sp, #12]
 8009d54:	4313      	orrs	r3, r2
 8009d56:	9303      	str	r3, [sp, #12]
  n /= 10;
 8009d58:	9a02      	ldr	r2, [sp, #8]
 8009d5a:	4b10      	ldr	r3, [pc, #64]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d5c:	fba3 1302 	umull	r1, r3, r3, r2
 8009d60:	08db      	lsrs	r3, r3, #3
 8009d62:	9302      	str	r3, [sp, #8]
  dr = dr | ((n % 10) << RTC_DR_DT_OFFSET);
 8009d64:	9902      	ldr	r1, [sp, #8]
 8009d66:	4b0d      	ldr	r3, [pc, #52]	; (8009d9c <rtc_encode_date+0x10c>)
 8009d68:	fba3 2301 	umull	r2, r3, r3, r1
 8009d6c:	08da      	lsrs	r2, r3, #3
 8009d6e:	4613      	mov	r3, r2
 8009d70:	009b      	lsls	r3, r3, #2
 8009d72:	4413      	add	r3, r2
 8009d74:	005b      	lsls	r3, r3, #1
 8009d76:	1aca      	subs	r2, r1, r3
 8009d78:	0113      	lsls	r3, r2, #4
 8009d7a:	9a03      	ldr	r2, [sp, #12]
 8009d7c:	4313      	orrs	r3, r2
 8009d7e:	9303      	str	r3, [sp, #12]

  /* Days of week conversion.*/
  dr = dr | (timespec->dayofweek << RTC_DR_WDU_OFFSET);
 8009d80:	9b01      	ldr	r3, [sp, #4]
 8009d82:	785b      	ldrb	r3, [r3, #1]
 8009d84:	f3c3 1342 	ubfx	r3, r3, #5, #3
 8009d88:	b2db      	uxtb	r3, r3
 8009d8a:	035b      	lsls	r3, r3, #13
 8009d8c:	9a03      	ldr	r2, [sp, #12]
 8009d8e:	4313      	orrs	r3, r2
 8009d90:	9303      	str	r3, [sp, #12]

  return dr;
 8009d92:	9b03      	ldr	r3, [sp, #12]
}
 8009d94:	4618      	mov	r0, r3
 8009d96:	b004      	add	sp, #16
 8009d98:	4770      	bx	lr
 8009d9a:	bf00      	nop
 8009d9c:	cccccccd 	.word	0xcccccccd

08009da0 <rtc_lld_init>:
/**
 * @brief   Enable access to registers.
 *
 * @notapi
 */
void rtc_lld_init(void) {
 8009da0:	b508      	push	{r3, lr}

  /* RTC object initialization.*/
  rtcObjectInit(&RTCD1);
 8009da2:	4819      	ldr	r0, [pc, #100]	; (8009e08 <rtc_lld_init+0x68>)
 8009da4:	f7fb f964 	bl	8005070 <rtcObjectInit>

  /* RTC pointer initialization.*/
  RTCD1.rtc = RTC;
 8009da8:	4b17      	ldr	r3, [pc, #92]	; (8009e08 <rtc_lld_init+0x68>)
 8009daa:	4a18      	ldr	r2, [pc, #96]	; (8009e0c <rtc_lld_init+0x6c>)
 8009dac:	601a      	str	r2, [r3, #0]

  /* Disable write protection. */
  RTCD1.rtc->WPR = 0xCA;
 8009dae:	4b16      	ldr	r3, [pc, #88]	; (8009e08 <rtc_lld_init+0x68>)
 8009db0:	681b      	ldr	r3, [r3, #0]
 8009db2:	22ca      	movs	r2, #202	; 0xca
 8009db4:	625a      	str	r2, [r3, #36]	; 0x24
  RTCD1.rtc->WPR = 0x53;
 8009db6:	4b14      	ldr	r3, [pc, #80]	; (8009e08 <rtc_lld_init+0x68>)
 8009db8:	681b      	ldr	r3, [r3, #0]
 8009dba:	2253      	movs	r2, #83	; 0x53
 8009dbc:	625a      	str	r2, [r3, #36]	; 0x24

  /* If calendar has not been initialized yet then proceed with the
     initial setup.*/
  if (!(RTCD1.rtc->ISR & RTC_ISR_INITS)) {
 8009dbe:	4b12      	ldr	r3, [pc, #72]	; (8009e08 <rtc_lld_init+0x68>)
 8009dc0:	681b      	ldr	r3, [r3, #0]
 8009dc2:	68db      	ldr	r3, [r3, #12]
 8009dc4:	f003 0310 	and.w	r3, r3, #16
 8009dc8:	2b00      	cmp	r3, #0
 8009dca:	d114      	bne.n	8009df6 <rtc_lld_init+0x56>

    rtc_enter_init();
 8009dcc:	f7ff fe00 	bl	80099d0 <rtc_enter_init>

    RTCD1.rtc->CR   = 0;
 8009dd0:	4b0d      	ldr	r3, [pc, #52]	; (8009e08 <rtc_lld_init+0x68>)
 8009dd2:	681b      	ldr	r3, [r3, #0]
 8009dd4:	2200      	movs	r2, #0
 8009dd6:	609a      	str	r2, [r3, #8]
    RTCD1.rtc->ISR  = RTC_ISR_INIT;     /* Clearing all but RTC_ISR_INIT.   */
 8009dd8:	4b0b      	ldr	r3, [pc, #44]	; (8009e08 <rtc_lld_init+0x68>)
 8009dda:	681b      	ldr	r3, [r3, #0]
 8009ddc:	2280      	movs	r2, #128	; 0x80
 8009dde:	60da      	str	r2, [r3, #12]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de0:	4b09      	ldr	r3, [pc, #36]	; (8009e08 <rtc_lld_init+0x68>)
 8009de2:	681b      	ldr	r3, [r3, #0]
 8009de4:	4a0a      	ldr	r2, [pc, #40]	; (8009e10 <rtc_lld_init+0x70>)
 8009de6:	611a      	str	r2, [r3, #16]
    RTCD1.rtc->PRER = STM32_RTC_PRER_BITS;
 8009de8:	4b07      	ldr	r3, [pc, #28]	; (8009e08 <rtc_lld_init+0x68>)
 8009dea:	681b      	ldr	r3, [r3, #0]
 8009dec:	4a08      	ldr	r2, [pc, #32]	; (8009e10 <rtc_lld_init+0x70>)
 8009dee:	611a      	str	r2, [r3, #16]

    rtc_exit_init();
 8009df0:	f7ff fe06 	bl	8009a00 <rtc_exit_init>
 8009df4:	e007      	b.n	8009e06 <rtc_lld_init+0x66>
  }
  else
    RTCD1.rtc->ISR &= ~RTC_ISR_RSF;
 8009df6:	4b04      	ldr	r3, [pc, #16]	; (8009e08 <rtc_lld_init+0x68>)
 8009df8:	681b      	ldr	r3, [r3, #0]
 8009dfa:	4a03      	ldr	r2, [pc, #12]	; (8009e08 <rtc_lld_init+0x68>)
 8009dfc:	6812      	ldr	r2, [r2, #0]
 8009dfe:	68d2      	ldr	r2, [r2, #12]
 8009e00:	f022 0220 	bic.w	r2, r2, #32
 8009e04:	60da      	str	r2, [r3, #12]
}
 8009e06:	bd08      	pop	{r3, pc}
 8009e08:	20001f58 	.word	0x20001f58
 8009e0c:	40002800 	.word	0x40002800
 8009e10:	001f03ff 	.word	0x001f03ff
 8009e14:	f3af 8000 	nop.w
 8009e18:	f3af 8000 	nop.w
 8009e1c:	f3af 8000 	nop.w

08009e20 <rtc_lld_set_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[in] timespec  pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_set_time(RTCDriver *rtcp, const RTCDateTime *timespec) {
 8009e20:	b500      	push	{lr}
 8009e22:	b087      	sub	sp, #28
 8009e24:	9001      	str	r0, [sp, #4]
 8009e26:	9100      	str	r1, [sp, #0]
  uint32_t dr, tr;
  syssts_t sts;

  tr = rtc_encode_time(timespec);
 8009e28:	9800      	ldr	r0, [sp, #0]
 8009e2a:	f7ff fea9 	bl	8009b80 <rtc_encode_time>
 8009e2e:	9005      	str	r0, [sp, #20]
  dr = rtc_encode_date(timespec);
 8009e30:	9800      	ldr	r0, [sp, #0]
 8009e32:	f7ff ff2d 	bl	8009c90 <rtc_encode_date>
 8009e36:	9004      	str	r0, [sp, #16]

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e38:	f7ff fdb2 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e3c:	9003      	str	r0, [sp, #12]

  /* Writing the registers.*/
  rtc_enter_init();
 8009e3e:	f7ff fdc7 	bl	80099d0 <rtc_enter_init>
  rtcp->rtc->TR  = tr;
 8009e42:	9b01      	ldr	r3, [sp, #4]
 8009e44:	681b      	ldr	r3, [r3, #0]
 8009e46:	9a05      	ldr	r2, [sp, #20]
 8009e48:	601a      	str	r2, [r3, #0]
  rtcp->rtc->DR  = dr;
 8009e4a:	9b01      	ldr	r3, [sp, #4]
 8009e4c:	681b      	ldr	r3, [r3, #0]
 8009e4e:	9a04      	ldr	r2, [sp, #16]
 8009e50:	605a      	str	r2, [r3, #4]
  rtcp->rtc->CR |= timespec->dstflag << RTC_CR_BKP_OFFSET;
 8009e52:	9b01      	ldr	r3, [sp, #4]
 8009e54:	681b      	ldr	r3, [r3, #0]
 8009e56:	9a01      	ldr	r2, [sp, #4]
 8009e58:	6812      	ldr	r2, [r2, #0]
 8009e5a:	6891      	ldr	r1, [r2, #8]
 8009e5c:	9a00      	ldr	r2, [sp, #0]
 8009e5e:	7852      	ldrb	r2, [r2, #1]
 8009e60:	f3c2 1200 	ubfx	r2, r2, #4, #1
 8009e64:	b2d2      	uxtb	r2, r2
 8009e66:	0492      	lsls	r2, r2, #18
 8009e68:	430a      	orrs	r2, r1
 8009e6a:	609a      	str	r2, [r3, #8]
  rtc_exit_init();
 8009e6c:	f7ff fdc8 	bl	8009a00 <rtc_exit_init>

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009e70:	9803      	ldr	r0, [sp, #12]
 8009e72:	f7ff fd9d 	bl	80099b0 <osalSysRestoreStatusX>
}
 8009e76:	b007      	add	sp, #28
 8009e78:	f85d fb04 	ldr.w	pc, [sp], #4
 8009e7c:	f3af 8000 	nop.w

08009e80 <rtc_lld_get_time>:
 * @param[in] rtcp      pointer to RTC driver structure
 * @param[out] timespec pointer to a @p RTCDateTime structure
 *
 * @notapi
 */
void rtc_lld_get_time(RTCDriver *rtcp, RTCDateTime *timespec) {
 8009e80:	b500      	push	{lr}
 8009e82:	b089      	sub	sp, #36	; 0x24
 8009e84:	9001      	str	r0, [sp, #4]
 8009e86:	9100      	str	r1, [sp, #0]
  uint32_t ssr;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009e88:	f7ff fd8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009e8c:	9007      	str	r0, [sp, #28]

  /* Synchronization with the RTC and reading the registers, note
     DR must be read last.*/
  while ((rtcp->rtc->ISR & RTC_ISR_RSF) == 0)
 8009e8e:	bf00      	nop
 8009e90:	9b01      	ldr	r3, [sp, #4]
 8009e92:	681b      	ldr	r3, [r3, #0]
 8009e94:	68db      	ldr	r3, [r3, #12]
 8009e96:	f003 0320 	and.w	r3, r3, #32
 8009e9a:	2b00      	cmp	r3, #0
 8009e9c:	d0f8      	beq.n	8009e90 <rtc_lld_get_time+0x10>
    ;
#if STM32_RTC_HAS_SUBSECONDS
  ssr = rtcp->rtc->SSR;
 8009e9e:	9b01      	ldr	r3, [sp, #4]
 8009ea0:	681b      	ldr	r3, [r3, #0]
 8009ea2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 8009ea4:	9306      	str	r3, [sp, #24]
#endif /* STM32_RTC_HAS_SUBSECONDS */
  tr  = rtcp->rtc->TR;
 8009ea6:	9b01      	ldr	r3, [sp, #4]
 8009ea8:	681b      	ldr	r3, [r3, #0]
 8009eaa:	681b      	ldr	r3, [r3, #0]
 8009eac:	9305      	str	r3, [sp, #20]
  dr  = rtcp->rtc->DR;
 8009eae:	9b01      	ldr	r3, [sp, #4]
 8009eb0:	681b      	ldr	r3, [r3, #0]
 8009eb2:	685b      	ldr	r3, [r3, #4]
 8009eb4:	9304      	str	r3, [sp, #16]
  cr  = rtcp->rtc->CR;
 8009eb6:	9b01      	ldr	r3, [sp, #4]
 8009eb8:	681b      	ldr	r3, [r3, #0]
 8009eba:	689b      	ldr	r3, [r3, #8]
 8009ebc:	9303      	str	r3, [sp, #12]
  rtcp->rtc->ISR &= ~RTC_ISR_RSF;
 8009ebe:	9b01      	ldr	r3, [sp, #4]
 8009ec0:	681b      	ldr	r3, [r3, #0]
 8009ec2:	9a01      	ldr	r2, [sp, #4]
 8009ec4:	6812      	ldr	r2, [r2, #0]
 8009ec6:	68d2      	ldr	r2, [r2, #12]
 8009ec8:	f022 0220 	bic.w	r2, r2, #32
 8009ecc:	60da      	str	r2, [r3, #12]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 8009ece:	9807      	ldr	r0, [sp, #28]
 8009ed0:	f7ff fd6e 	bl	80099b0 <osalSysRestoreStatusX>

  /* Decoding day time, this starts the atomic read sequence, see "Reading
     the calendar" in the RTC documentation.*/
  rtc_decode_time(tr, timespec);
 8009ed4:	9805      	ldr	r0, [sp, #20]
 8009ed6:	9900      	ldr	r1, [sp, #0]
 8009ed8:	f7ff fda2 	bl	8009a20 <rtc_decode_time>

  /* If the RTC is capable of sub-second counting then the value is
     normalized in milliseconds and added to the time.*/
#if STM32_RTC_HAS_SUBSECONDS
  subs = (((STM32_RTC_PRESS_VALUE - 1U) - ssr) * 1000U) / STM32_RTC_PRESS_VALUE;
 8009edc:	9b06      	ldr	r3, [sp, #24]
 8009ede:	4a14      	ldr	r2, [pc, #80]	; (8009f30 <rtc_lld_get_time+0xb0>)
 8009ee0:	fb02 f303 	mul.w	r3, r2, r3
 8009ee4:	f503 2379 	add.w	r3, r3, #1019904	; 0xf9000
 8009ee8:	f603 4318 	addw	r3, r3, #3096	; 0xc18
 8009eec:	0a9b      	lsrs	r3, r3, #10
 8009eee:	9302      	str	r3, [sp, #8]
#else
  subs = 0;
#endif /* STM32_RTC_HAS_SUBSECONDS */
  timespec->millisecond += subs;
 8009ef0:	9b00      	ldr	r3, [sp, #0]
 8009ef2:	685b      	ldr	r3, [r3, #4]
 8009ef4:	f3c3 031a 	ubfx	r3, r3, #0, #27
 8009ef8:	461a      	mov	r2, r3
 8009efa:	9b02      	ldr	r3, [sp, #8]
 8009efc:	4413      	add	r3, r2
 8009efe:	f023 4178 	bic.w	r1, r3, #4160749568	; 0xf8000000
 8009f02:	9a00      	ldr	r2, [sp, #0]
 8009f04:	6853      	ldr	r3, [r2, #4]
 8009f06:	f361 031a 	bfi	r3, r1, #0, #27
 8009f0a:	6053      	str	r3, [r2, #4]

  /* Decoding date, this concludes the atomic read sequence.*/
  rtc_decode_date(dr, timespec);
 8009f0c:	9804      	ldr	r0, [sp, #16]
 8009f0e:	9900      	ldr	r1, [sp, #0]
 8009f10:	f7ff fdd6 	bl	8009ac0 <rtc_decode_date>

  /* Retrieving the DST bit.*/
  timespec->dstflag = (cr >> RTC_CR_BKP_OFFSET) & 1;
 8009f14:	9b03      	ldr	r3, [sp, #12]
 8009f16:	0c9b      	lsrs	r3, r3, #18
 8009f18:	b2db      	uxtb	r3, r3
 8009f1a:	f003 0301 	and.w	r3, r3, #1
 8009f1e:	b2d9      	uxtb	r1, r3
 8009f20:	9a00      	ldr	r2, [sp, #0]
 8009f22:	7853      	ldrb	r3, [r2, #1]
 8009f24:	f361 1304 	bfi	r3, r1, #4, #1
 8009f28:	7053      	strb	r3, [r2, #1]
}
 8009f2a:	b009      	add	sp, #36	; 0x24
 8009f2c:	f85d fb04 	ldr.w	pc, [sp], #4
 8009f30:	fffffc18 	.word	0xfffffc18
 8009f34:	f3af 8000 	nop.w
 8009f38:	f3af 8000 	nop.w
 8009f3c:	f3af 8000 	nop.w

08009f40 <rtc_lld_set_alarm>:
 *
 * @notapi
 */
void rtc_lld_set_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       const RTCAlarm *alarmspec) {
 8009f40:	b500      	push	{lr}
 8009f42:	b087      	sub	sp, #28
 8009f44:	9003      	str	r0, [sp, #12]
 8009f46:	9102      	str	r1, [sp, #8]
 8009f48:	9201      	str	r2, [sp, #4]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 8009f4a:	f7ff fd29 	bl	80099a0 <osalSysGetStatusAndLockX>
 8009f4e:	9005      	str	r0, [sp, #20]

  if (alarm == 0) {
 8009f50:	9b02      	ldr	r3, [sp, #8]
 8009f52:	2b00      	cmp	r3, #0
 8009f54:	d139      	bne.n	8009fca <rtc_lld_set_alarm+0x8a>
    if (alarmspec != NULL) {
 8009f56:	9b01      	ldr	r3, [sp, #4]
 8009f58:	2b00      	cmp	r3, #0
 8009f5a:	d025      	beq.n	8009fa8 <rtc_lld_set_alarm+0x68>
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009f5c:	9b03      	ldr	r3, [sp, #12]
 8009f5e:	681b      	ldr	r3, [r3, #0]
 8009f60:	9a03      	ldr	r2, [sp, #12]
 8009f62:	6812      	ldr	r2, [r2, #0]
 8009f64:	6892      	ldr	r2, [r2, #8]
 8009f66:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009f6a:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRAWF))
 8009f6c:	bf00      	nop
 8009f6e:	9b03      	ldr	r3, [sp, #12]
 8009f70:	681b      	ldr	r3, [r3, #0]
 8009f72:	68db      	ldr	r3, [r3, #12]
 8009f74:	f003 0301 	and.w	r3, r3, #1
 8009f78:	2b00      	cmp	r3, #0
 8009f7a:	d0f8      	beq.n	8009f6e <rtc_lld_set_alarm+0x2e>
        ;
      rtcp->rtc->ALRMAR = alarmspec->alrmr;
 8009f7c:	9b03      	ldr	r3, [sp, #12]
 8009f7e:	681b      	ldr	r3, [r3, #0]
 8009f80:	9a01      	ldr	r2, [sp, #4]
 8009f82:	6812      	ldr	r2, [r2, #0]
 8009f84:	61da      	str	r2, [r3, #28]
      rtcp->rtc->CR |= RTC_CR_ALRAE;
 8009f86:	9b03      	ldr	r3, [sp, #12]
 8009f88:	681b      	ldr	r3, [r3, #0]
 8009f8a:	9a03      	ldr	r2, [sp, #12]
 8009f8c:	6812      	ldr	r2, [r2, #0]
 8009f8e:	6892      	ldr	r2, [r2, #8]
 8009f90:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8009f94:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRAIE;
 8009f96:	9b03      	ldr	r3, [sp, #12]
 8009f98:	681b      	ldr	r3, [r3, #0]
 8009f9a:	9a03      	ldr	r2, [sp, #12]
 8009f9c:	6812      	ldr	r2, [r2, #0]
 8009f9e:	6892      	ldr	r2, [r2, #8]
 8009fa0:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 8009fa4:	609a      	str	r2, [r3, #8]
 8009fa6:	e049      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRAIE;
 8009fa8:	9b03      	ldr	r3, [sp, #12]
 8009faa:	681b      	ldr	r3, [r3, #0]
 8009fac:	9a03      	ldr	r2, [sp, #12]
 8009fae:	6812      	ldr	r2, [r2, #0]
 8009fb0:	6892      	ldr	r2, [r2, #8]
 8009fb2:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8009fb6:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRAE;
 8009fb8:	9b03      	ldr	r3, [sp, #12]
 8009fba:	681b      	ldr	r3, [r3, #0]
 8009fbc:	9a03      	ldr	r2, [sp, #12]
 8009fbe:	6812      	ldr	r2, [r2, #0]
 8009fc0:	6892      	ldr	r2, [r2, #8]
 8009fc2:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8009fc6:	609a      	str	r2, [r3, #8]
 8009fc8:	e038      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
  }
#if RTC_ALARMS > 1
  else {
    if (alarmspec != NULL) {
 8009fca:	9b01      	ldr	r3, [sp, #4]
 8009fcc:	2b00      	cmp	r3, #0
 8009fce:	d025      	beq.n	800a01c <rtc_lld_set_alarm+0xdc>
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 8009fd0:	9b03      	ldr	r3, [sp, #12]
 8009fd2:	681b      	ldr	r3, [r3, #0]
 8009fd4:	9a03      	ldr	r2, [sp, #12]
 8009fd6:	6812      	ldr	r2, [r2, #0]
 8009fd8:	6892      	ldr	r2, [r2, #8]
 8009fda:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 8009fde:	609a      	str	r2, [r3, #8]
      while (!(rtcp->rtc->ISR & RTC_ISR_ALRBWF))
 8009fe0:	bf00      	nop
 8009fe2:	9b03      	ldr	r3, [sp, #12]
 8009fe4:	681b      	ldr	r3, [r3, #0]
 8009fe6:	68db      	ldr	r3, [r3, #12]
 8009fe8:	f003 0302 	and.w	r3, r3, #2
 8009fec:	2b00      	cmp	r3, #0
 8009fee:	d0f8      	beq.n	8009fe2 <rtc_lld_set_alarm+0xa2>
        ;
      rtcp->rtc->ALRMBR = alarmspec->alrmr;
 8009ff0:	9b03      	ldr	r3, [sp, #12]
 8009ff2:	681b      	ldr	r3, [r3, #0]
 8009ff4:	9a01      	ldr	r2, [sp, #4]
 8009ff6:	6812      	ldr	r2, [r2, #0]
 8009ff8:	621a      	str	r2, [r3, #32]
      rtcp->rtc->CR |= RTC_CR_ALRBE;
 8009ffa:	9b03      	ldr	r3, [sp, #12]
 8009ffc:	681b      	ldr	r3, [r3, #0]
 8009ffe:	9a03      	ldr	r2, [sp, #12]
 800a000:	6812      	ldr	r2, [r2, #0]
 800a002:	6892      	ldr	r2, [r2, #8]
 800a004:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 800a008:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR |= RTC_CR_ALRBIE;
 800a00a:	9b03      	ldr	r3, [sp, #12]
 800a00c:	681b      	ldr	r3, [r3, #0]
 800a00e:	9a03      	ldr	r2, [sp, #12]
 800a010:	6812      	ldr	r2, [r2, #0]
 800a012:	6892      	ldr	r2, [r2, #8]
 800a014:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
 800a018:	609a      	str	r2, [r3, #8]
 800a01a:	e00f      	b.n	800a03c <rtc_lld_set_alarm+0xfc>
    }
    else {
      rtcp->rtc->CR &= ~RTC_CR_ALRBIE;
 800a01c:	9b03      	ldr	r3, [sp, #12]
 800a01e:	681b      	ldr	r3, [r3, #0]
 800a020:	9a03      	ldr	r2, [sp, #12]
 800a022:	6812      	ldr	r2, [r2, #0]
 800a024:	6892      	ldr	r2, [r2, #8]
 800a026:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 800a02a:	609a      	str	r2, [r3, #8]
      rtcp->rtc->CR &= ~RTC_CR_ALRBE;
 800a02c:	9b03      	ldr	r3, [sp, #12]
 800a02e:	681b      	ldr	r3, [r3, #0]
 800a030:	9a03      	ldr	r2, [sp, #12]
 800a032:	6812      	ldr	r2, [r2, #0]
 800a034:	6892      	ldr	r2, [r2, #8]
 800a036:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800a03a:	609a      	str	r2, [r3, #8]
    }
  }
#endif /* RTC_ALARMS > 1 */

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a03c:	9805      	ldr	r0, [sp, #20]
 800a03e:	f7ff fcb7 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a042:	b007      	add	sp, #28
 800a044:	f85d fb04 	ldr.w	pc, [sp], #4
 800a048:	f3af 8000 	nop.w
 800a04c:	f3af 8000 	nop.w

0800a050 <rtc_lld_get_alarm>:
 *
 * @notapi
 */
void rtc_lld_get_alarm(RTCDriver *rtcp,
                       rtcalarm_t alarm,
                       RTCAlarm *alarmspec) {
 800a050:	b084      	sub	sp, #16
 800a052:	9003      	str	r0, [sp, #12]
 800a054:	9102      	str	r1, [sp, #8]
 800a056:	9201      	str	r2, [sp, #4]

  if (alarm == 0)
 800a058:	9b02      	ldr	r3, [sp, #8]
 800a05a:	2b00      	cmp	r3, #0
 800a05c:	d105      	bne.n	800a06a <rtc_lld_get_alarm+0x1a>
    alarmspec->alrmr = rtcp->rtc->ALRMAR;
 800a05e:	9b03      	ldr	r3, [sp, #12]
 800a060:	681b      	ldr	r3, [r3, #0]
 800a062:	69da      	ldr	r2, [r3, #28]
 800a064:	9b01      	ldr	r3, [sp, #4]
 800a066:	601a      	str	r2, [r3, #0]
 800a068:	e004      	b.n	800a074 <rtc_lld_get_alarm+0x24>
#if RTC_ALARMS > 1
  else
    alarmspec->alrmr = rtcp->rtc->ALRMBR;
 800a06a:	9b03      	ldr	r3, [sp, #12]
 800a06c:	681b      	ldr	r3, [r3, #0]
 800a06e:	6a1a      	ldr	r2, [r3, #32]
 800a070:	9b01      	ldr	r3, [sp, #4]
 800a072:	601a      	str	r2, [r3, #0]
#endif /* RTC_ALARMS > 1 */
}
 800a074:	b004      	add	sp, #16
 800a076:	4770      	bx	lr
 800a078:	f3af 8000 	nop.w
 800a07c:	f3af 8000 	nop.w

0800a080 <rtcSTM32SetPeriodicWakeup>:
 * @param[in] rtcp       pointer to RTC driver structure
 * @param[in] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32SetPeriodicWakeup(RTCDriver *rtcp, const RTCWakeup *wakeupspec) {
 800a080:	b500      	push	{lr}
 800a082:	b085      	sub	sp, #20
 800a084:	9001      	str	r0, [sp, #4]
 800a086:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a088:	f7ff fc8a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a08c:	9003      	str	r0, [sp, #12]

  if (wakeupspec != NULL) {
 800a08e:	9b00      	ldr	r3, [sp, #0]
 800a090:	2b00      	cmp	r3, #0
 800a092:	d02e      	beq.n	800a0f2 <rtcSTM32SetPeriodicWakeup+0x72>
    osalDbgCheck(wakeupspec->wutr != 0x30000);

    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a094:	9b01      	ldr	r3, [sp, #4]
 800a096:	681b      	ldr	r3, [r3, #0]
 800a098:	9a01      	ldr	r2, [sp, #4]
 800a09a:	6812      	ldr	r2, [r2, #0]
 800a09c:	6892      	ldr	r2, [r2, #8]
 800a09e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a0a2:	609a      	str	r2, [r3, #8]
    while (!(rtcp->rtc->ISR & RTC_ISR_WUTWF))
 800a0a4:	bf00      	nop
 800a0a6:	9b01      	ldr	r3, [sp, #4]
 800a0a8:	681b      	ldr	r3, [r3, #0]
 800a0aa:	68db      	ldr	r3, [r3, #12]
 800a0ac:	f003 0304 	and.w	r3, r3, #4
 800a0b0:	2b00      	cmp	r3, #0
 800a0b2:	d0f8      	beq.n	800a0a6 <rtcSTM32SetPeriodicWakeup+0x26>
      ;
    rtcp->rtc->WUTR = wakeupspec->wutr & 0xFFFF;
 800a0b4:	9b01      	ldr	r3, [sp, #4]
 800a0b6:	681b      	ldr	r3, [r3, #0]
 800a0b8:	9a00      	ldr	r2, [sp, #0]
 800a0ba:	6812      	ldr	r2, [r2, #0]
 800a0bc:	b292      	uxth	r2, r2
 800a0be:	615a      	str	r2, [r3, #20]
    rtcp->rtc->CR   = (wakeupspec->wutr >> 16) & 0x7;
 800a0c0:	9b01      	ldr	r3, [sp, #4]
 800a0c2:	681b      	ldr	r3, [r3, #0]
 800a0c4:	9a00      	ldr	r2, [sp, #0]
 800a0c6:	6812      	ldr	r2, [r2, #0]
 800a0c8:	0c12      	lsrs	r2, r2, #16
 800a0ca:	f002 0207 	and.w	r2, r2, #7
 800a0ce:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTIE;
 800a0d0:	9b01      	ldr	r3, [sp, #4]
 800a0d2:	681b      	ldr	r3, [r3, #0]
 800a0d4:	9a01      	ldr	r2, [sp, #4]
 800a0d6:	6812      	ldr	r2, [r2, #0]
 800a0d8:	6892      	ldr	r2, [r2, #8]
 800a0da:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800a0de:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR |= RTC_CR_WUTE;
 800a0e0:	9b01      	ldr	r3, [sp, #4]
 800a0e2:	681b      	ldr	r3, [r3, #0]
 800a0e4:	9a01      	ldr	r2, [sp, #4]
 800a0e6:	6812      	ldr	r2, [r2, #0]
 800a0e8:	6892      	ldr	r2, [r2, #8]
 800a0ea:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a0ee:	609a      	str	r2, [r3, #8]
 800a0f0:	e00f      	b.n	800a112 <rtcSTM32SetPeriodicWakeup+0x92>
  }
  else {
    rtcp->rtc->CR &= ~RTC_CR_WUTIE;
 800a0f2:	9b01      	ldr	r3, [sp, #4]
 800a0f4:	681b      	ldr	r3, [r3, #0]
 800a0f6:	9a01      	ldr	r2, [sp, #4]
 800a0f8:	6812      	ldr	r2, [r2, #0]
 800a0fa:	6892      	ldr	r2, [r2, #8]
 800a0fc:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800a100:	609a      	str	r2, [r3, #8]
    rtcp->rtc->CR &= ~RTC_CR_WUTE;
 800a102:	9b01      	ldr	r3, [sp, #4]
 800a104:	681b      	ldr	r3, [r3, #0]
 800a106:	9a01      	ldr	r2, [sp, #4]
 800a108:	6812      	ldr	r2, [r2, #0]
 800a10a:	6892      	ldr	r2, [r2, #8]
 800a10c:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a110:	609a      	str	r2, [r3, #8]
  }

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a112:	9803      	ldr	r0, [sp, #12]
 800a114:	f7ff fc4c 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a118:	b005      	add	sp, #20
 800a11a:	f85d fb04 	ldr.w	pc, [sp], #4
 800a11e:	bf00      	nop

0800a120 <rtcSTM32GetPeriodicWakeup>:
 * @param[in] rtcp        pointer to RTC driver structure
 * @param[out] wakeupspec pointer to a @p RTCWakeup structure
 *
 * @api
 */
void rtcSTM32GetPeriodicWakeup(RTCDriver *rtcp, RTCWakeup *wakeupspec) {
 800a120:	b500      	push	{lr}
 800a122:	b085      	sub	sp, #20
 800a124:	9001      	str	r0, [sp, #4]
 800a126:	9100      	str	r1, [sp, #0]
  syssts_t sts;

  /* Entering a reentrant critical zone.*/
  sts = osalSysGetStatusAndLockX();
 800a128:	f7ff fc3a 	bl	80099a0 <osalSysGetStatusAndLockX>
 800a12c:	9003      	str	r0, [sp, #12]

  wakeupspec->wutr  = 0;
 800a12e:	9b00      	ldr	r3, [sp, #0]
 800a130:	2200      	movs	r2, #0
 800a132:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= rtcp->rtc->WUTR;
 800a134:	9b00      	ldr	r3, [sp, #0]
 800a136:	681a      	ldr	r2, [r3, #0]
 800a138:	9b01      	ldr	r3, [sp, #4]
 800a13a:	681b      	ldr	r3, [r3, #0]
 800a13c:	695b      	ldr	r3, [r3, #20]
 800a13e:	431a      	orrs	r2, r3
 800a140:	9b00      	ldr	r3, [sp, #0]
 800a142:	601a      	str	r2, [r3, #0]
  wakeupspec->wutr |= (((uint32_t)rtcp->rtc->CR) & 0x7) << 16;
 800a144:	9b00      	ldr	r3, [sp, #0]
 800a146:	681a      	ldr	r2, [r3, #0]
 800a148:	9b01      	ldr	r3, [sp, #4]
 800a14a:	681b      	ldr	r3, [r3, #0]
 800a14c:	689b      	ldr	r3, [r3, #8]
 800a14e:	f003 0307 	and.w	r3, r3, #7
 800a152:	041b      	lsls	r3, r3, #16
 800a154:	431a      	orrs	r2, r3
 800a156:	9b00      	ldr	r3, [sp, #0]
 800a158:	601a      	str	r2, [r3, #0]

  /* Leaving a reentrant critical zone.*/
  osalSysRestoreStatusX(sts);
 800a15a:	9803      	ldr	r0, [sp, #12]
 800a15c:	f7ff fc28 	bl	80099b0 <osalSysRestoreStatusX>
}
 800a160:	b005      	add	sp, #20
 800a162:	f85d fb04 	ldr.w	pc, [sp], #4
 800a166:	bf00      	nop
 800a168:	f3af 8000 	nop.w
 800a16c:	f3af 8000 	nop.w

0800a170 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800a170:	b082      	sub	sp, #8
 800a172:	2320      	movs	r3, #32
 800a174:	9301      	str	r3, [sp, #4]
 800a176:	9b01      	ldr	r3, [sp, #4]
 800a178:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a17c:	b002      	add	sp, #8
 800a17e:	4770      	bx	lr

0800a180 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800a180:	b082      	sub	sp, #8
 800a182:	2300      	movs	r3, #0
 800a184:	9301      	str	r3, [sp, #4]
 800a186:	9b01      	ldr	r3, [sp, #4]
 800a188:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800a18c:	b002      	add	sp, #8
 800a18e:	4770      	bx	lr

0800a190 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800a190:	b508      	push	{r3, lr}

  port_lock();
 800a192:	f7ff ffed 	bl	800a170 <port_lock>
}
 800a196:	bd08      	pop	{r3, pc}
 800a198:	f3af 8000 	nop.w
 800a19c:	f3af 8000 	nop.w

0800a1a0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800a1a0:	b508      	push	{r3, lr}

  port_unlock();
 800a1a2:	f7ff ffed 	bl	800a180 <port_unlock>
}
 800a1a6:	bd08      	pop	{r3, pc}
 800a1a8:	f3af 8000 	nop.w
 800a1ac:	f3af 8000 	nop.w

0800a1b0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800a1b0:	b508      	push	{r3, lr}

  port_lock();
 800a1b2:	f7ff ffdd 	bl	800a170 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800a1b6:	bd08      	pop	{r3, pc}
 800a1b8:	f3af 8000 	nop.w
 800a1bc:	f3af 8000 	nop.w

0800a1c0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800a1c0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800a1c2:	f7ff ffdd 	bl	800a180 <port_unlock>
}
 800a1c6:	bd08      	pop	{r3, pc}
 800a1c8:	f3af 8000 	nop.w
 800a1cc:	f3af 8000 	nop.w

0800a1d0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800a1d0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800a1d2:	f7ff ffdd 	bl	800a190 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800a1d6:	bd08      	pop	{r3, pc}
 800a1d8:	f3af 8000 	nop.w
 800a1dc:	f3af 8000 	nop.w

0800a1e0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800a1e0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800a1e2:	f7ff ffdd 	bl	800a1a0 <port_unlock_from_isr>
}
 800a1e6:	bd08      	pop	{r3, pc}
 800a1e8:	f3af 8000 	nop.w
 800a1ec:	f3af 8000 	nop.w

0800a1f0 <osalSysLock>:
 * @brief   Enters a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLock(void) {
 800a1f0:	b508      	push	{r3, lr}

  chSysLock();
 800a1f2:	f7ff ffdd 	bl	800a1b0 <chSysLock>
}
 800a1f6:	bd08      	pop	{r3, pc}
 800a1f8:	f3af 8000 	nop.w
 800a1fc:	f3af 8000 	nop.w

0800a200 <osalSysUnlock>:
 * @brief   Leaves a critical zone from thread context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlock(void) {
 800a200:	b508      	push	{r3, lr}

  chSysUnlock();
 800a202:	f7ff ffdd 	bl	800a1c0 <chSysUnlock>
}
 800a206:	bd08      	pop	{r3, pc}
 800a208:	f3af 8000 	nop.w
 800a20c:	f3af 8000 	nop.w

0800a210 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800a210:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800a212:	f7ff ffdd 	bl	800a1d0 <chSysLockFromISR>
}
 800a216:	bd08      	pop	{r3, pc}
 800a218:	f3af 8000 	nop.w
 800a21c:	f3af 8000 	nop.w

0800a220 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800a220:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800a222:	f7ff ffdd 	bl	800a1e0 <chSysUnlockFromISR>
}
 800a226:	bd08      	pop	{r3, pc}
 800a228:	f3af 8000 	nop.w
 800a22c:	f3af 8000 	nop.w

0800a230 <osalThreadSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {
 800a230:	b500      	push	{lr}
 800a232:	b083      	sub	sp, #12
 800a234:	9001      	str	r0, [sp, #4]

  chThdSleep(time);
 800a236:	9801      	ldr	r0, [sp, #4]
 800a238:	f7f7 f84a 	bl	80012d0 <chThdSleep>
}
 800a23c:	b003      	add	sp, #12
 800a23e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a242:	bf00      	nop
 800a244:	f3af 8000 	nop.w
 800a248:	f3af 8000 	nop.w
 800a24c:	f3af 8000 	nop.w

0800a250 <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
 800a250:	b500      	push	{lr}
 800a252:	b083      	sub	sp, #12
 800a254:	9001      	str	r0, [sp, #4]

  return chThdSuspendS(trp);
 800a256:	9801      	ldr	r0, [sp, #4]
 800a258:	f7f7 f8fa 	bl	8001450 <chThdSuspendS>
 800a25c:	4603      	mov	r3, r0
}
 800a25e:	4618      	mov	r0, r3
 800a260:	b003      	add	sp, #12
 800a262:	f85d fb04 	ldr.w	pc, [sp], #4
 800a266:	bf00      	nop
 800a268:	f3af 8000 	nop.w
 800a26c:	f3af 8000 	nop.w

0800a270 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800a270:	b500      	push	{lr}
 800a272:	b083      	sub	sp, #12
 800a274:	9001      	str	r0, [sp, #4]
 800a276:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800a278:	9801      	ldr	r0, [sp, #4]
 800a27a:	9900      	ldr	r1, [sp, #0]
 800a27c:	f7f7 f920 	bl	80014c0 <chThdResumeI>
}
 800a280:	b003      	add	sp, #12
 800a282:	f85d fb04 	ldr.w	pc, [sp], #4
 800a286:	bf00      	nop
 800a288:	f3af 8000 	nop.w
 800a28c:	f3af 8000 	nop.w

0800a290 <sdc_lld_prepare_read_bytes>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read_bytes(SDCDriver *sdcp,
                                       uint8_t *buf, uint32_t bytes) {
 800a290:	b500      	push	{lr}
 800a292:	b087      	sub	sp, #28
 800a294:	9003      	str	r0, [sp, #12]
 800a296:	9102      	str	r1, [sp, #8]
 800a298:	9201      	str	r2, [sp, #4]
  osalDbgCheck(bytes < 0x1000000);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800a29a:	9b03      	ldr	r3, [sp, #12]
 800a29c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a29e:	4a2d      	ldr	r2, [pc, #180]	; (800a354 <sdc_lld_prepare_read_bytes+0xc4>)
 800a2a0:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800a2a2:	9803      	ldr	r0, [sp, #12]
 800a2a4:	f7fb fbb4 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800a2a8:	4603      	mov	r3, r0
 800a2aa:	2b00      	cmp	r3, #0
 800a2ac:	d001      	beq.n	800a2b2 <sdc_lld_prepare_read_bytes+0x22>
    return HAL_FAILED;
 800a2ae:	2301      	movs	r3, #1
 800a2b0:	e04b      	b.n	800a34a <sdc_lld_prepare_read_bytes+0xba>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800a2b2:	9b03      	ldr	r3, [sp, #12]
 800a2b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2b6:	685b      	ldr	r3, [r3, #4]
 800a2b8:	9a02      	ldr	r2, [sp, #8]
 800a2ba:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma, bytes / sizeof (uint32_t));
 800a2bc:	9b03      	ldr	r3, [sp, #12]
 800a2be:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2c0:	685b      	ldr	r3, [r3, #4]
 800a2c2:	9a01      	ldr	r2, [sp, #4]
 800a2c4:	0892      	lsrs	r2, r2, #2
 800a2c6:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800a2c8:	9b03      	ldr	r3, [sp, #12]
 800a2ca:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2cc:	68db      	ldr	r3, [r3, #12]
 800a2ce:	681b      	ldr	r3, [r3, #0]
 800a2d0:	9305      	str	r3, [sp, #20]
 800a2d2:	9b03      	ldr	r3, [sp, #12]
 800a2d4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2d6:	7c1b      	ldrb	r3, [r3, #16]
 800a2d8:	220f      	movs	r2, #15
 800a2da:	fa02 f303 	lsl.w	r3, r2, r3
 800a2de:	43db      	mvns	r3, r3
 800a2e0:	9a05      	ldr	r2, [sp, #20]
 800a2e2:	4013      	ands	r3, r2
 800a2e4:	9305      	str	r3, [sp, #20]
 800a2e6:	9b03      	ldr	r3, [sp, #12]
 800a2e8:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800a2ea:	0c1a      	lsrs	r2, r3, #16
 800a2ec:	9b03      	ldr	r3, [sp, #12]
 800a2ee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a2f0:	7c1b      	ldrb	r3, [r3, #16]
 800a2f2:	fa02 f303 	lsl.w	r3, r2, r3
 800a2f6:	9a05      	ldr	r2, [sp, #20]
 800a2f8:	4313      	orrs	r3, r2
 800a2fa:	9305      	str	r3, [sp, #20]
 800a2fc:	9b03      	ldr	r3, [sp, #12]
 800a2fe:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a300:	68db      	ldr	r3, [r3, #12]
 800a302:	9a05      	ldr	r2, [sp, #20]
 800a304:	601a      	str	r2, [r3, #0]
 800a306:	9b03      	ldr	r3, [sp, #12]
 800a308:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a30a:	685b      	ldr	r3, [r3, #4]
 800a30c:	9a03      	ldr	r2, [sp, #12]
 800a30e:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800a310:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800a312:	9b03      	ldr	r3, [sp, #12]
 800a314:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a316:	685b      	ldr	r3, [r3, #4]
 800a318:	9a03      	ldr	r2, [sp, #12]
 800a31a:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a31c:	6852      	ldr	r2, [r2, #4]
 800a31e:	6812      	ldr	r2, [r2, #0]
 800a320:	f042 0201 	orr.w	r2, r2, #1
 800a324:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a326:	9b03      	ldr	r3, [sp, #12]
 800a328:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a32a:	4a0b      	ldr	r2, [pc, #44]	; (800a358 <sdc_lld_prepare_read_bytes+0xc8>)
 800a32c:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800a32e:	9b03      	ldr	r3, [sp, #12]
 800a330:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a332:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800a336:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = bytes;
 800a338:	9b03      	ldr	r3, [sp, #12]
 800a33a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a33c:	9a01      	ldr	r2, [sp, #4]
 800a33e:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800a340:	9b03      	ldr	r3, [sp, #12]
 800a342:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a344:	220f      	movs	r2, #15
 800a346:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DTMODE |   /* multibyte data transfer */
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  return HAL_SUCCESS;
 800a348:	2300      	movs	r3, #0
}
 800a34a:	4618      	mov	r0, r3
 800a34c:	b007      	add	sp, #28
 800a34e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a352:	bf00      	nop
 800a354:	000927c0 	.word	0x000927c0
 800a358:	004005ff 	.word	0x004005ff
 800a35c:	f3af 8000 	nop.w

0800a360 <sdc_lld_prepare_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_read(SDCDriver *sdcp, uint32_t startblk,
                                 uint32_t n, uint32_t *resp) {
 800a360:	b500      	push	{lr}
 800a362:	b085      	sub	sp, #20
 800a364:	9003      	str	r0, [sp, #12]
 800a366:	9102      	str	r1, [sp, #8]
 800a368:	9201      	str	r2, [sp, #4]
 800a36a:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a36c:	9b03      	ldr	r3, [sp, #12]
 800a36e:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a370:	f003 0310 	and.w	r3, r3, #16
 800a374:	2b00      	cmp	r3, #0
 800a376:	d102      	bne.n	800a37e <sdc_lld_prepare_read+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a378:	9b02      	ldr	r3, [sp, #8]
 800a37a:	025b      	lsls	r3, r3, #9
 800a37c:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a37e:	9b01      	ldr	r3, [sp, #4]
 800a380:	2b01      	cmp	r3, #1
 800a382:	d910      	bls.n	800a3a6 <sdc_lld_prepare_read+0x46>
    /* Send read multiple blocks command to card.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_MULTIPLE_BLOCK,
 800a384:	9803      	ldr	r0, [sp, #12]
 800a386:	2112      	movs	r1, #18
 800a388:	9a02      	ldr	r2, [sp, #8]
 800a38a:	9b00      	ldr	r3, [sp, #0]
 800a38c:	f000 fab8 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a390:	4603      	mov	r3, r0
 800a392:	2b00      	cmp	r3, #0
 800a394:	d105      	bne.n	800a3a2 <sdc_lld_prepare_read+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a396:	9b00      	ldr	r3, [sp, #0]
 800a398:	681a      	ldr	r2, [r3, #0]
 800a39a:	4b0e      	ldr	r3, [pc, #56]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a39c:	4013      	ands	r3, r2
 800a39e:	2b00      	cmp	r3, #0
 800a3a0:	d012      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3a2:	2301      	movs	r3, #1
 800a3a4:	e011      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }
  else{
    /* Send read single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_READ_SINGLE_BLOCK,
 800a3a6:	9803      	ldr	r0, [sp, #12]
 800a3a8:	2111      	movs	r1, #17
 800a3aa:	9a02      	ldr	r2, [sp, #8]
 800a3ac:	9b00      	ldr	r3, [sp, #0]
 800a3ae:	f000 faa7 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a3b2:	4603      	mov	r3, r0
 800a3b4:	2b00      	cmp	r3, #0
 800a3b6:	d105      	bne.n	800a3c4 <sdc_lld_prepare_read+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a3b8:	9b00      	ldr	r3, [sp, #0]
 800a3ba:	681a      	ldr	r2, [r3, #0]
 800a3bc:	4b05      	ldr	r3, [pc, #20]	; (800a3d4 <sdc_lld_prepare_read+0x74>)
 800a3be:	4013      	ands	r3, r2
 800a3c0:	2b00      	cmp	r3, #0
 800a3c2:	d001      	beq.n	800a3c8 <sdc_lld_prepare_read+0x68>
      return HAL_FAILED;
 800a3c4:	2301      	movs	r3, #1
 800a3c6:	e000      	b.n	800a3ca <sdc_lld_prepare_read+0x6a>
  }

  return HAL_SUCCESS;
 800a3c8:	2300      	movs	r3, #0
}
 800a3ca:	4618      	mov	r0, r3
 800a3cc:	b005      	add	sp, #20
 800a3ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800a3d2:	bf00      	nop
 800a3d4:	fdffe008 	.word	0xfdffe008
 800a3d8:	f3af 8000 	nop.w
 800a3dc:	f3af 8000 	nop.w

0800a3e0 <sdc_lld_prepare_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
static bool sdc_lld_prepare_write(SDCDriver *sdcp, uint32_t startblk,
                                  uint32_t n, uint32_t *resp) {
 800a3e0:	b500      	push	{lr}
 800a3e2:	b085      	sub	sp, #20
 800a3e4:	9003      	str	r0, [sp, #12]
 800a3e6:	9102      	str	r1, [sp, #8]
 800a3e8:	9201      	str	r2, [sp, #4]
 800a3ea:	9300      	str	r3, [sp, #0]

  /* Driver handles data in 512 bytes blocks (just like HC cards). But if we
     have not HC card than we must convert address from blocks to bytes.*/
  if (!(sdcp->cardmode & SDC_MODE_HIGH_CAPACITY))
 800a3ec:	9b03      	ldr	r3, [sp, #12]
 800a3ee:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 800a3f0:	f003 0310 	and.w	r3, r3, #16
 800a3f4:	2b00      	cmp	r3, #0
 800a3f6:	d102      	bne.n	800a3fe <sdc_lld_prepare_write+0x1e>
    startblk *= MMCSD_BLOCK_SIZE;
 800a3f8:	9b02      	ldr	r3, [sp, #8]
 800a3fa:	025b      	lsls	r3, r3, #9
 800a3fc:	9302      	str	r3, [sp, #8]

  if (n > 1) {
 800a3fe:	9b01      	ldr	r3, [sp, #4]
 800a400:	2b01      	cmp	r3, #1
 800a402:	d910      	bls.n	800a426 <sdc_lld_prepare_write+0x46>
    /* Write multiple blocks command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_MULTIPLE_BLOCK,
 800a404:	9803      	ldr	r0, [sp, #12]
 800a406:	2119      	movs	r1, #25
 800a408:	9a02      	ldr	r2, [sp, #8]
 800a40a:	9b00      	ldr	r3, [sp, #0]
 800a40c:	f000 fa78 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a410:	4603      	mov	r3, r0
 800a412:	2b00      	cmp	r3, #0
 800a414:	d105      	bne.n	800a422 <sdc_lld_prepare_write+0x42>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a416:	9b00      	ldr	r3, [sp, #0]
 800a418:	681a      	ldr	r2, [r3, #0]
 800a41a:	4b0e      	ldr	r3, [pc, #56]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a41c:	4013      	ands	r3, r2
 800a41e:	2b00      	cmp	r3, #0
 800a420:	d012      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a422:	2301      	movs	r3, #1
 800a424:	e011      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }
  else{
    /* Write single block command.*/
    if (sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_WRITE_BLOCK,
 800a426:	9803      	ldr	r0, [sp, #12]
 800a428:	2118      	movs	r1, #24
 800a42a:	9a02      	ldr	r2, [sp, #8]
 800a42c:	9b00      	ldr	r3, [sp, #0]
 800a42e:	f000 fa67 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a432:	4603      	mov	r3, r0
 800a434:	2b00      	cmp	r3, #0
 800a436:	d105      	bne.n	800a444 <sdc_lld_prepare_write+0x64>
                                   startblk, resp) || MMCSD_R1_ERROR(resp[0]))
 800a438:	9b00      	ldr	r3, [sp, #0]
 800a43a:	681a      	ldr	r2, [r3, #0]
 800a43c:	4b05      	ldr	r3, [pc, #20]	; (800a454 <sdc_lld_prepare_write+0x74>)
 800a43e:	4013      	ands	r3, r2
 800a440:	2b00      	cmp	r3, #0
 800a442:	d001      	beq.n	800a448 <sdc_lld_prepare_write+0x68>
      return HAL_FAILED;
 800a444:	2301      	movs	r3, #1
 800a446:	e000      	b.n	800a44a <sdc_lld_prepare_write+0x6a>
  }

  return HAL_SUCCESS;
 800a448:	2300      	movs	r3, #0
}
 800a44a:	4618      	mov	r0, r3
 800a44c:	b005      	add	sp, #20
 800a44e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a452:	bf00      	nop
 800a454:	fdffe008 	.word	0xfdffe008
 800a458:	f3af 8000 	nop.w
 800a45c:	f3af 8000 	nop.w

0800a460 <sdc_lld_wait_transaction_end>:
 * @return              The operation status.
 * @retval HAL_SUCCESS  operation succeeded.
 * @retval HAL_FAILED   operation failed.
 */
static bool sdc_lld_wait_transaction_end(SDCDriver *sdcp, uint32_t n,
                                         uint32_t *resp) {
 800a460:	b500      	push	{lr}
 800a462:	b085      	sub	sp, #20
 800a464:	9003      	str	r0, [sp, #12]
 800a466:	9102      	str	r1, [sp, #8]
 800a468:	9201      	str	r2, [sp, #4]

  /* Note the mask is checked before going to sleep because the interrupt
     may have occurred before reaching the critical zone.*/
  osalSysLock();
 800a46a:	f7ff fec1 	bl	800a1f0 <osalSysLock>
  if (sdcp->sdmmc->MASK != 0)
 800a46e:	9b03      	ldr	r3, [sp, #12]
 800a470:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a472:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 800a474:	2b00      	cmp	r3, #0
 800a476:	d004      	beq.n	800a482 <sdc_lld_wait_transaction_end+0x22>
    osalThreadSuspendS(&sdcp->thread);
 800a478:	9b03      	ldr	r3, [sp, #12]
 800a47a:	333c      	adds	r3, #60	; 0x3c
 800a47c:	4618      	mov	r0, r3
 800a47e:	f7ff fee7 	bl	800a250 <osalThreadSuspendS>
  if ((sdcp->sdmmc->STA & SDMMC_STA_DATAEND) == 0) {
 800a482:	9b03      	ldr	r3, [sp, #12]
 800a484:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a486:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a488:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800a48c:	2b00      	cmp	r3, #0
 800a48e:	d103      	bne.n	800a498 <sdc_lld_wait_transaction_end+0x38>
    osalSysUnlock();
 800a490:	f7ff feb6 	bl	800a200 <osalSysUnlock>
    return HAL_FAILED;
 800a494:	2301      	movs	r3, #1
 800a496:	e030      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>
  }

  /* Waits for transfer completion at DMA level, then the stream is
     disabled and cleared.*/
  dmaWaitCompletion(sdcp->dma);
 800a498:	bf00      	nop
 800a49a:	9b03      	ldr	r3, [sp, #12]
 800a49c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a49e:	685b      	ldr	r3, [r3, #4]
 800a4a0:	685b      	ldr	r3, [r3, #4]
 800a4a2:	2b00      	cmp	r3, #0
 800a4a4:	d1f9      	bne.n	800a49a <sdc_lld_wait_transaction_end+0x3a>
 800a4a6:	9b03      	ldr	r3, [sp, #12]
 800a4a8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4aa:	685b      	ldr	r3, [r3, #4]
 800a4ac:	9a03      	ldr	r2, [sp, #12]
 800a4ae:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4b0:	6852      	ldr	r2, [r2, #4]
 800a4b2:	6812      	ldr	r2, [r2, #0]
 800a4b4:	f022 020f 	bic.w	r2, r2, #15
 800a4b8:	601a      	str	r2, [r3, #0]
 800a4ba:	9b03      	ldr	r3, [sp, #12]
 800a4bc:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a4be:	681b      	ldr	r3, [r3, #0]
 800a4c0:	9a03      	ldr	r2, [sp, #12]
 800a4c2:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a4c4:	7c12      	ldrb	r2, [r2, #16]
 800a4c6:	210f      	movs	r1, #15
 800a4c8:	fa01 f202 	lsl.w	r2, r1, r2
 800a4cc:	605a      	str	r2, [r3, #4]

  sdcp->sdmmc->ICR = SDMMC_ICR_ALL_FLAGS;
 800a4ce:	9b03      	ldr	r3, [sp, #12]
 800a4d0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4d2:	4a0c      	ldr	r2, [pc, #48]	; (800a504 <sdc_lld_wait_transaction_end+0xa4>)
 800a4d4:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->DCTRL = 0;
 800a4d6:	9b03      	ldr	r3, [sp, #12]
 800a4d8:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a4da:	2200      	movs	r2, #0
 800a4dc:	62da      	str	r2, [r3, #44]	; 0x2c
  osalSysUnlock();
 800a4de:	f7ff fe8f 	bl	800a200 <osalSysUnlock>

  /* Finalize transaction.*/
  if (n > 1)
 800a4e2:	9b02      	ldr	r3, [sp, #8]
 800a4e4:	2b01      	cmp	r3, #1
 800a4e6:	d907      	bls.n	800a4f8 <sdc_lld_wait_transaction_end+0x98>
    return sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a4e8:	9803      	ldr	r0, [sp, #12]
 800a4ea:	210c      	movs	r1, #12
 800a4ec:	2200      	movs	r2, #0
 800a4ee:	9b01      	ldr	r3, [sp, #4]
 800a4f0:	f000 fa06 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800a4f4:	4603      	mov	r3, r0
 800a4f6:	e000      	b.n	800a4fa <sdc_lld_wait_transaction_end+0x9a>

  return HAL_SUCCESS;
 800a4f8:	2300      	movs	r3, #0
}
 800a4fa:	4618      	mov	r0, r3
 800a4fc:	b005      	add	sp, #20
 800a4fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800a502:	bf00      	nop
 800a504:	004005ff 	.word	0x004005ff
 800a508:	f3af 8000 	nop.w
 800a50c:	f3af 8000 	nop.w

0800a510 <sdc_lld_collect_errors>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] sta       value of the STA register
 *
 * @notapi
 */
static void sdc_lld_collect_errors(SDCDriver *sdcp, uint32_t sta) {
 800a510:	b084      	sub	sp, #16
 800a512:	9001      	str	r0, [sp, #4]
 800a514:	9100      	str	r1, [sp, #0]
  uint32_t errors = SDC_NO_ERROR;
 800a516:	2300      	movs	r3, #0
 800a518:	9303      	str	r3, [sp, #12]

  if (sta & SDMMC_STA_CCRCFAIL)
 800a51a:	9b00      	ldr	r3, [sp, #0]
 800a51c:	f003 0301 	and.w	r3, r3, #1
 800a520:	2b00      	cmp	r3, #0
 800a522:	d003      	beq.n	800a52c <sdc_lld_collect_errors+0x1c>
    errors |= SDC_CMD_CRC_ERROR;
 800a524:	9b03      	ldr	r3, [sp, #12]
 800a526:	f043 0301 	orr.w	r3, r3, #1
 800a52a:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DCRCFAIL)
 800a52c:	9b00      	ldr	r3, [sp, #0]
 800a52e:	f003 0302 	and.w	r3, r3, #2
 800a532:	2b00      	cmp	r3, #0
 800a534:	d003      	beq.n	800a53e <sdc_lld_collect_errors+0x2e>
    errors |= SDC_DATA_CRC_ERROR;
 800a536:	9b03      	ldr	r3, [sp, #12]
 800a538:	f043 0302 	orr.w	r3, r3, #2
 800a53c:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_CTIMEOUT)
 800a53e:	9b00      	ldr	r3, [sp, #0]
 800a540:	f003 0304 	and.w	r3, r3, #4
 800a544:	2b00      	cmp	r3, #0
 800a546:	d003      	beq.n	800a550 <sdc_lld_collect_errors+0x40>
    errors |= SDC_COMMAND_TIMEOUT;
 800a548:	9b03      	ldr	r3, [sp, #12]
 800a54a:	f043 0308 	orr.w	r3, r3, #8
 800a54e:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_DTIMEOUT)
 800a550:	9b00      	ldr	r3, [sp, #0]
 800a552:	f003 0308 	and.w	r3, r3, #8
 800a556:	2b00      	cmp	r3, #0
 800a558:	d003      	beq.n	800a562 <sdc_lld_collect_errors+0x52>
    errors |= SDC_DATA_TIMEOUT;
 800a55a:	9b03      	ldr	r3, [sp, #12]
 800a55c:	f043 0304 	orr.w	r3, r3, #4
 800a560:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_TXUNDERR)
 800a562:	9b00      	ldr	r3, [sp, #0]
 800a564:	f003 0310 	and.w	r3, r3, #16
 800a568:	2b00      	cmp	r3, #0
 800a56a:	d003      	beq.n	800a574 <sdc_lld_collect_errors+0x64>
    errors |= SDC_TX_UNDERRUN;
 800a56c:	9b03      	ldr	r3, [sp, #12]
 800a56e:	f043 0310 	orr.w	r3, r3, #16
 800a572:	9303      	str	r3, [sp, #12]
  if (sta & SDMMC_STA_RXOVERR)
 800a574:	9b00      	ldr	r3, [sp, #0]
 800a576:	f003 0320 	and.w	r3, r3, #32
 800a57a:	2b00      	cmp	r3, #0
 800a57c:	d003      	beq.n	800a586 <sdc_lld_collect_errors+0x76>
    errors |= SDC_RX_OVERRUN;
 800a57e:	9b03      	ldr	r3, [sp, #12]
 800a580:	f043 0320 	orr.w	r3, r3, #32
 800a584:	9303      	str	r3, [sp, #12]
/*  if (sta & SDMMC_STA_STBITERR)
    errors |= SDC_STARTBIT_ERROR;*/

  sdcp->errors |= errors;
 800a586:	9b01      	ldr	r3, [sp, #4]
 800a588:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800a58a:	9b03      	ldr	r3, [sp, #12]
 800a58c:	431a      	orrs	r2, r3
 800a58e:	9b01      	ldr	r3, [sp, #4]
 800a590:	635a      	str	r2, [r3, #52]	; 0x34
}
 800a592:	b004      	add	sp, #16
 800a594:	4770      	bx	lr
 800a596:	bf00      	nop
 800a598:	f3af 8000 	nop.w
 800a59c:	f3af 8000 	nop.w

0800a5a0 <sdc_lld_error_cleanup>:
 *
 * @notapi
 */
static void sdc_lld_error_cleanup(SDCDriver *sdcp,
                                  uint32_t n,
                                  uint32_t *resp) {
 800a5a0:	b500      	push	{lr}
 800a5a2:	b087      	sub	sp, #28
 800a5a4:	9003      	str	r0, [sp, #12]
 800a5a6:	9102      	str	r1, [sp, #8]
 800a5a8:	9201      	str	r2, [sp, #4]
  uint32_t sta = sdcp->sdmmc->STA;
 800a5aa:	9b03      	ldr	r3, [sp, #12]
 800a5ac:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ae:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a5b0:	9305      	str	r3, [sp, #20]

  dmaStreamDisable(sdcp->dma);
 800a5b2:	9b03      	ldr	r3, [sp, #12]
 800a5b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5b6:	685b      	ldr	r3, [r3, #4]
 800a5b8:	9a03      	ldr	r2, [sp, #12]
 800a5ba:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5bc:	6852      	ldr	r2, [r2, #4]
 800a5be:	6812      	ldr	r2, [r2, #0]
 800a5c0:	f022 020f 	bic.w	r2, r2, #15
 800a5c4:	601a      	str	r2, [r3, #0]
 800a5c6:	9b03      	ldr	r3, [sp, #12]
 800a5c8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a5ca:	681b      	ldr	r3, [r3, #0]
 800a5cc:	9a03      	ldr	r2, [sp, #12]
 800a5ce:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800a5d0:	7c12      	ldrb	r2, [r2, #16]
 800a5d2:	210f      	movs	r1, #15
 800a5d4:	fa01 f202 	lsl.w	r2, r1, r2
 800a5d8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800a5da:	9b03      	ldr	r3, [sp, #12]
 800a5dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5de:	4a0d      	ldr	r2, [pc, #52]	; (800a614 <sdc_lld_error_cleanup+0x74>)
 800a5e0:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = 0;
 800a5e2:	9b03      	ldr	r3, [sp, #12]
 800a5e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5e6:	2200      	movs	r2, #0
 800a5e8:	63da      	str	r2, [r3, #60]	; 0x3c
  sdcp->sdmmc->DCTRL = 0;
 800a5ea:	9b03      	ldr	r3, [sp, #12]
 800a5ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a5ee:	2200      	movs	r2, #0
 800a5f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdc_lld_collect_errors(sdcp, sta);
 800a5f2:	9803      	ldr	r0, [sp, #12]
 800a5f4:	9905      	ldr	r1, [sp, #20]
 800a5f6:	f7ff ff8b 	bl	800a510 <sdc_lld_collect_errors>

  if (n > 1)
 800a5fa:	9b02      	ldr	r3, [sp, #8]
 800a5fc:	2b01      	cmp	r3, #1
 800a5fe:	d905      	bls.n	800a60c <sdc_lld_error_cleanup+0x6c>
    sdc_lld_send_cmd_short_crc(sdcp, MMCSD_CMD_STOP_TRANSMISSION, 0, resp);
 800a600:	9803      	ldr	r0, [sp, #12]
 800a602:	210c      	movs	r1, #12
 800a604:	2200      	movs	r2, #0
 800a606:	9b01      	ldr	r3, [sp, #4]
 800a608:	f000 f97a 	bl	800a900 <sdc_lld_send_cmd_short_crc>
}
 800a60c:	b007      	add	sp, #28
 800a60e:	f85d fb04 	ldr.w	pc, [sp], #4
 800a612:	bf00      	nop
 800a614:	004005ff 	.word	0x004005ff
 800a618:	f3af 8000 	nop.w
 800a61c:	f3af 8000 	nop.w

0800a620 <Vector104>:
 * @details It just wakes transaction thread. All error  handling performs in
 *          that thread.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_SDMMC1_HANDLER) {
 800a620:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  osalSysLockFromISR();
 800a622:	f7ff fdf5 	bl	800a210 <osalSysLockFromISR>

  /* Disables the source but the status flags are not reset because the
     read/write functions needs to check them.*/
  SDMMC1->MASK = 0;
 800a626:	4b06      	ldr	r3, [pc, #24]	; (800a640 <Vector104+0x20>)
 800a628:	2200      	movs	r2, #0
 800a62a:	63da      	str	r2, [r3, #60]	; 0x3c

  osalThreadResumeI(&SDCD1.thread, MSG_OK);
 800a62c:	4805      	ldr	r0, [pc, #20]	; (800a644 <Vector104+0x24>)
 800a62e:	2100      	movs	r1, #0
 800a630:	f7ff fe1e 	bl	800a270 <osalThreadResumeI>

  osalSysUnlockFromISR();
 800a634:	f7ff fdf4 	bl	800a220 <osalSysUnlockFromISR>

  OSAL_IRQ_EPILOGUE();
 800a638:	f7f9 fa8a 	bl	8003b50 <_port_irq_epilogue>
}
 800a63c:	bd08      	pop	{r3, pc}
 800a63e:	bf00      	nop
 800a640:	40012800 	.word	0x40012800
 800a644:	20001f98 	.word	0x20001f98
 800a648:	f3af 8000 	nop.w
 800a64c:	f3af 8000 	nop.w

0800a650 <sdc_lld_init>:
/**
 * @brief   Low level SDC driver initialization.
 *
 * @notapi
 */
void sdc_lld_init(void) {
 800a650:	b508      	push	{r3, lr}

  sdcObjectInit(&SDCD1);
 800a652:	4806      	ldr	r0, [pc, #24]	; (800a66c <sdc_lld_init+0x1c>)
 800a654:	f7fb fa14 	bl	8005a80 <sdcObjectInit>
  SDCD1.thread = NULL;
 800a658:	4b04      	ldr	r3, [pc, #16]	; (800a66c <sdc_lld_init+0x1c>)
 800a65a:	2200      	movs	r2, #0
 800a65c:	63da      	str	r2, [r3, #60]	; 0x3c
  SDCD1.dma    = STM32_DMA_STREAM(STM32_SDC_SDMMC1_DMA_STREAM);
 800a65e:	4b03      	ldr	r3, [pc, #12]	; (800a66c <sdc_lld_init+0x1c>)
 800a660:	4a03      	ldr	r2, [pc, #12]	; (800a670 <sdc_lld_init+0x20>)
 800a662:	645a      	str	r2, [r3, #68]	; 0x44
  SDCD1.sdmmc  = SDMMC1;
 800a664:	4b01      	ldr	r3, [pc, #4]	; (800a66c <sdc_lld_init+0x1c>)
 800a666:	4a03      	ldr	r2, [pc, #12]	; (800a674 <sdc_lld_init+0x24>)
 800a668:	649a      	str	r2, [r3, #72]	; 0x48
}
 800a66a:	bd08      	pop	{r3, pc}
 800a66c:	20001f5c 	.word	0x20001f5c
 800a670:	08019568 	.word	0x08019568
 800a674:	40012800 	.word	0x40012800
 800a678:	f3af 8000 	nop.w
 800a67c:	f3af 8000 	nop.w

0800a680 <sdc_lld_start>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start(SDCDriver *sdcp) {
 800a680:	b500      	push	{lr}
 800a682:	b085      	sub	sp, #20
 800a684:	9001      	str	r0, [sp, #4]

  /* Checking configuration, using a default if NULL has been passed.*/
  if (sdcp->config == NULL) {
 800a686:	9b01      	ldr	r3, [sp, #4]
 800a688:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800a68a:	2b00      	cmp	r3, #0
 800a68c:	d102      	bne.n	800a694 <sdc_lld_start+0x14>
    sdcp->config = &sdc_default_cfg;
 800a68e:	9b01      	ldr	r3, [sp, #4]
 800a690:	4a1b      	ldr	r2, [pc, #108]	; (800a700 <sdc_lld_start+0x80>)
 800a692:	62da      	str	r2, [r3, #44]	; 0x2c
  }

  sdcp->dmamode = STM32_DMA_CR_CHSEL(DMA_CHANNEL) |
 800a694:	9b01      	ldr	r3, [sp, #4]
 800a696:	4a1b      	ldr	r2, [pc, #108]	; (800a704 <sdc_lld_start+0x84>)
 800a698:	641a      	str	r2, [r3, #64]	; 0x40
  sdcp->dmamode |= STM32_DMA_CR_PFCTRL |
                   STM32_DMA_CR_PBURST_INCR4 |
                   STM32_DMA_CR_MBURST_INCR4;
#endif

  if (sdcp->state == BLK_STOP) {
 800a69a:	9b01      	ldr	r3, [sp, #4]
 800a69c:	791b      	ldrb	r3, [r3, #4]
 800a69e:	2b01      	cmp	r3, #1
 800a6a0:	d11b      	bne.n	800a6da <sdc_lld_start+0x5a>
    /* Note, the DMA must be enabled before the IRQs.*/
    bool b;
    b = dmaStreamAllocate(sdcp->dma, STM32_SDC_SDMMC1_IRQ_PRIORITY, NULL, NULL);
 800a6a2:	9b01      	ldr	r3, [sp, #4]
 800a6a4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6a6:	4618      	mov	r0, r3
 800a6a8:	2109      	movs	r1, #9
 800a6aa:	2200      	movs	r2, #0
 800a6ac:	2300      	movs	r3, #0
 800a6ae:	f7fd fb5f 	bl	8007d70 <dmaStreamAllocate>
 800a6b2:	4603      	mov	r3, r0
 800a6b4:	f88d 300f 	strb.w	r3, [sp, #15]
    osalDbgAssert(!b, "stream already allocated");
    dmaStreamSetPeripheral(sdcp->dma, &sdcp->sdmmc->FIFO);
 800a6b8:	9b01      	ldr	r3, [sp, #4]
 800a6ba:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a6bc:	685b      	ldr	r3, [r3, #4]
 800a6be:	9a01      	ldr	r2, [sp, #4]
 800a6c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a6c2:	3280      	adds	r2, #128	; 0x80
 800a6c4:	609a      	str	r2, [r3, #8]
#if STM32_DMA_ADVANCED
    dmaStreamSetFIFO(sdcp->dma, STM32_DMA_FCR_DMDIS | STM32_DMA_FCR_FTH_FULL);
#endif
    nvicEnableVector(STM32_SDMMC1_NUMBER, STM32_SDC_SDMMC1_IRQ_PRIORITY);
 800a6c6:	2031      	movs	r0, #49	; 0x31
 800a6c8:	2109      	movs	r1, #9
 800a6ca:	f7fc fe31 	bl	8007330 <nvicEnableVector>
    rccEnableSDMMC1(FALSE);
 800a6ce:	4b0e      	ldr	r3, [pc, #56]	; (800a708 <sdc_lld_start+0x88>)
 800a6d0:	4a0d      	ldr	r2, [pc, #52]	; (800a708 <sdc_lld_start+0x88>)
 800a6d2:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a6d4:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a6d8:	661a      	str	r2, [r3, #96]	; 0x60
  }

  /* Configuration, card clock is initially stopped.*/
  sdcp->sdmmc->POWER  = 0;
 800a6da:	9b01      	ldr	r3, [sp, #4]
 800a6dc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6de:	2200      	movs	r2, #0
 800a6e0:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR  = 0;
 800a6e2:	9b01      	ldr	r3, [sp, #4]
 800a6e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6e6:	2200      	movs	r2, #0
 800a6e8:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->DCTRL  = 0;
 800a6ea:	9b01      	ldr	r3, [sp, #4]
 800a6ec:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6ee:	2200      	movs	r2, #0
 800a6f0:	62da      	str	r2, [r3, #44]	; 0x2c
  sdcp->sdmmc->DTIMER = 0;
 800a6f2:	9b01      	ldr	r3, [sp, #4]
 800a6f4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a6f6:	2200      	movs	r2, #0
 800a6f8:	625a      	str	r2, [r3, #36]	; 0x24
}
 800a6fa:	b005      	add	sp, #20
 800a6fc:	f85d fb04 	ldr.w	pc, [sp], #4
 800a700:	08019600 	.word	0x08019600
 800a704:	00073a80 	.word	0x00073a80
 800a708:	40021000 	.word	0x40021000
 800a70c:	f3af 8000 	nop.w

0800a710 <sdc_lld_stop>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop(SDCDriver *sdcp) {
 800a710:	b500      	push	{lr}
 800a712:	b083      	sub	sp, #12
 800a714:	9001      	str	r0, [sp, #4]

  if (sdcp->state != BLK_STOP) {
 800a716:	9b01      	ldr	r3, [sp, #4]
 800a718:	791b      	ldrb	r3, [r3, #4]
 800a71a:	2b01      	cmp	r3, #1
 800a71c:	d01d      	beq.n	800a75a <sdc_lld_stop+0x4a>

    /* SDIO deactivation.*/
    sdcp->sdmmc->POWER  = 0;
 800a71e:	9b01      	ldr	r3, [sp, #4]
 800a720:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a722:	2200      	movs	r2, #0
 800a724:	601a      	str	r2, [r3, #0]
    sdcp->sdmmc->CLKCR  = 0;
 800a726:	9b01      	ldr	r3, [sp, #4]
 800a728:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a72a:	2200      	movs	r2, #0
 800a72c:	605a      	str	r2, [r3, #4]
    sdcp->sdmmc->DCTRL  = 0;
 800a72e:	9b01      	ldr	r3, [sp, #4]
 800a730:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a732:	2200      	movs	r2, #0
 800a734:	62da      	str	r2, [r3, #44]	; 0x2c
    sdcp->sdmmc->DTIMER = 0;
 800a736:	9b01      	ldr	r3, [sp, #4]
 800a738:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a73a:	2200      	movs	r2, #0
 800a73c:	625a      	str	r2, [r3, #36]	; 0x24

    /* Clock deactivation.*/
    nvicDisableVector(STM32_SDMMC1_NUMBER);
 800a73e:	2031      	movs	r0, #49	; 0x31
 800a740:	f7fc fe1e 	bl	8007380 <nvicDisableVector>
    dmaStreamRelease(sdcp->dma);
 800a744:	9b01      	ldr	r3, [sp, #4]
 800a746:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800a748:	4618      	mov	r0, r3
 800a74a:	f7fd fb81 	bl	8007e50 <dmaStreamRelease>
    rccDisableSDMMC1(FALSE);
 800a74e:	4b04      	ldr	r3, [pc, #16]	; (800a760 <sdc_lld_stop+0x50>)
 800a750:	4a03      	ldr	r2, [pc, #12]	; (800a760 <sdc_lld_stop+0x50>)
 800a752:	6e12      	ldr	r2, [r2, #96]	; 0x60
 800a754:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800a758:	661a      	str	r2, [r3, #96]	; 0x60
  }
}
 800a75a:	b003      	add	sp, #12
 800a75c:	f85d fb04 	ldr.w	pc, [sp], #4
 800a760:	40021000 	.word	0x40021000
 800a764:	f3af 8000 	nop.w
 800a768:	f3af 8000 	nop.w
 800a76c:	f3af 8000 	nop.w

0800a770 <sdc_lld_start_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_start_clk(SDCDriver *sdcp) {
 800a770:	b500      	push	{lr}
 800a772:	b083      	sub	sp, #12
 800a774:	9001      	str	r0, [sp, #4]

  /* Initial clock setting: 400kHz, 1bit mode.*/
  sdcp->sdmmc->CLKCR  = SDMMC_CLKDIV_LS;
 800a776:	9b01      	ldr	r3, [sp, #4]
 800a778:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a77a:	2276      	movs	r2, #118	; 0x76
 800a77c:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER |= SDMMC_POWER_PWRCTRL_0 | SDMMC_POWER_PWRCTRL_1;
 800a77e:	9b01      	ldr	r3, [sp, #4]
 800a780:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a782:	9a01      	ldr	r2, [sp, #4]
 800a784:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a786:	6812      	ldr	r2, [r2, #0]
 800a788:	f042 0203 	orr.w	r2, r2, #3
 800a78c:	601a      	str	r2, [r3, #0]
  sdcp->sdmmc->CLKCR |= SDMMC_CLKCR_CLKEN;
 800a78e:	9b01      	ldr	r3, [sp, #4]
 800a790:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a792:	9a01      	ldr	r2, [sp, #4]
 800a794:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a796:	6852      	ldr	r2, [r2, #4]
 800a798:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800a79c:	605a      	str	r2, [r3, #4]

  /* Clock activation delay.*/
  osalThreadSleep(OSAL_MS2ST(STM32_SDC_SDMMC_CLOCK_DELAY));
 800a79e:	200a      	movs	r0, #10
 800a7a0:	f7ff fd46 	bl	800a230 <osalThreadSleep>
}
 800a7a4:	b003      	add	sp, #12
 800a7a6:	f85d fb04 	ldr.w	pc, [sp], #4
 800a7aa:	bf00      	nop
 800a7ac:	f3af 8000 	nop.w

0800a7b0 <sdc_lld_set_data_clk>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] clk       the clock mode
 *
 * @notapi
 */
void sdc_lld_set_data_clk(SDCDriver *sdcp, sdcbusclk_t clk) {
 800a7b0:	b082      	sub	sp, #8
 800a7b2:	9001      	str	r0, [sp, #4]
 800a7b4:	460b      	mov	r3, r1
 800a7b6:	f88d 3003 	strb.w	r3, [sp, #3]
  else
    sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
#else
  (void)clk;

  sdcp->sdmmc->CLKCR = (sdcp->sdmmc->CLKCR & 0xFFFFFF00U) | SDMMC_CLKDIV_HS;
 800a7ba:	9b01      	ldr	r3, [sp, #4]
 800a7bc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7be:	9a01      	ldr	r2, [sp, #4]
 800a7c0:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a7c2:	6852      	ldr	r2, [r2, #4]
 800a7c4:	f022 02ff 	bic.w	r2, r2, #255	; 0xff
 800a7c8:	605a      	str	r2, [r3, #4]
#endif
}
 800a7ca:	b002      	add	sp, #8
 800a7cc:	4770      	bx	lr
 800a7ce:	bf00      	nop

0800a7d0 <sdc_lld_stop_clk>:
 *
 * @param[in] sdcp      pointer to the @p SDCDriver object
 *
 * @notapi
 */
void sdc_lld_stop_clk(SDCDriver *sdcp) {
 800a7d0:	b082      	sub	sp, #8
 800a7d2:	9001      	str	r0, [sp, #4]

  sdcp->sdmmc->CLKCR = 0;
 800a7d4:	9b01      	ldr	r3, [sp, #4]
 800a7d6:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7d8:	2200      	movs	r2, #0
 800a7da:	605a      	str	r2, [r3, #4]
  sdcp->sdmmc->POWER = 0;
 800a7dc:	9b01      	ldr	r3, [sp, #4]
 800a7de:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7e0:	2200      	movs	r2, #0
 800a7e2:	601a      	str	r2, [r3, #0]
}
 800a7e4:	b002      	add	sp, #8
 800a7e6:	4770      	bx	lr
 800a7e8:	f3af 8000 	nop.w
 800a7ec:	f3af 8000 	nop.w

0800a7f0 <sdc_lld_set_bus_mode>:
 * @param[in] sdcp      pointer to the @p SDCDriver object
 * @param[in] mode      bus mode
 *
 * @notapi
 */
void sdc_lld_set_bus_mode(SDCDriver *sdcp, sdcbusmode_t mode) {
 800a7f0:	b084      	sub	sp, #16
 800a7f2:	9001      	str	r0, [sp, #4]
 800a7f4:	460b      	mov	r3, r1
 800a7f6:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t clk = sdcp->sdmmc->CLKCR & ~SDMMC_CLKCR_WIDBUS;
 800a7fa:	9b01      	ldr	r3, [sp, #4]
 800a7fc:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a7fe:	685b      	ldr	r3, [r3, #4]
 800a800:	f423 53c0 	bic.w	r3, r3, #6144	; 0x1800
 800a804:	9303      	str	r3, [sp, #12]

  switch (mode) {
 800a806:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800a80a:	2b01      	cmp	r3, #1
 800a80c:	d008      	beq.n	800a820 <sdc_lld_set_bus_mode+0x30>
 800a80e:	2b02      	cmp	r3, #2
 800a810:	d00d      	beq.n	800a82e <sdc_lld_set_bus_mode+0x3e>
 800a812:	2b00      	cmp	r3, #0
 800a814:	d112      	bne.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_1BIT:
    sdcp->sdmmc->CLKCR = clk;
 800a816:	9b01      	ldr	r3, [sp, #4]
 800a818:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a81a:	9a03      	ldr	r2, [sp, #12]
 800a81c:	605a      	str	r2, [r3, #4]
    break;
 800a81e:	e00d      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_4BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_0;
 800a820:	9b01      	ldr	r3, [sp, #4]
 800a822:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a824:	9a03      	ldr	r2, [sp, #12]
 800a826:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 800a82a:	605a      	str	r2, [r3, #4]
    break;
 800a82c:	e006      	b.n	800a83c <sdc_lld_set_bus_mode+0x4c>
  case SDC_MODE_8BIT:
    sdcp->sdmmc->CLKCR = clk | SDMMC_CLKCR_WIDBUS_1;
 800a82e:	9b01      	ldr	r3, [sp, #4]
 800a830:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a832:	9a03      	ldr	r2, [sp, #12]
 800a834:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 800a838:	605a      	str	r2, [r3, #4]
    break;
 800a83a:	bf00      	nop
  }
}
 800a83c:	b004      	add	sp, #16
 800a83e:	4770      	bx	lr

0800a840 <sdc_lld_send_cmd_none>:
 * @param[in] cmd       card command
 * @param[in] arg       command argument
 *
 * @notapi
 */
void sdc_lld_send_cmd_none(SDCDriver *sdcp, uint8_t cmd, uint32_t arg) {
 800a840:	b084      	sub	sp, #16
 800a842:	9003      	str	r0, [sp, #12]
 800a844:	460b      	mov	r3, r1
 800a846:	9201      	str	r2, [sp, #4]
 800a848:	f88d 300b 	strb.w	r3, [sp, #11]

  sdcp->sdmmc->ARG = arg;
 800a84c:	9b03      	ldr	r3, [sp, #12]
 800a84e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a850:	9a01      	ldr	r2, [sp, #4]
 800a852:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_CPSMEN;
 800a854:	9b03      	ldr	r3, [sp, #12]
 800a856:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a858:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a85c:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a860:	60da      	str	r2, [r3, #12]
  while ((sdcp->sdmmc->STA & SDMMC_STA_CMDSENT) == 0)
 800a862:	bf00      	nop
 800a864:	9b03      	ldr	r3, [sp, #12]
 800a866:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a868:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a86a:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800a86e:	2b00      	cmp	r3, #0
 800a870:	d0f8      	beq.n	800a864 <sdc_lld_send_cmd_none+0x24>
    ;
  sdcp->sdmmc->ICR = SDMMC_ICR_CMDSENTC;
 800a872:	9b03      	ldr	r3, [sp, #12]
 800a874:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a876:	2280      	movs	r2, #128	; 0x80
 800a878:	639a      	str	r2, [r3, #56]	; 0x38
}
 800a87a:	b004      	add	sp, #16
 800a87c:	4770      	bx	lr
 800a87e:	bf00      	nop

0800a880 <sdc_lld_send_cmd_short>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                            uint32_t *resp) {
 800a880:	b500      	push	{lr}
 800a882:	b087      	sub	sp, #28
 800a884:	9003      	str	r0, [sp, #12]
 800a886:	9201      	str	r2, [sp, #4]
 800a888:	9300      	str	r3, [sp, #0]
 800a88a:	460b      	mov	r3, r1
 800a88c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a890:	9b03      	ldr	r3, [sp, #12]
 800a892:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a894:	9a01      	ldr	r2, [sp, #4]
 800a896:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a898:	9b03      	ldr	r3, [sp, #12]
 800a89a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a89c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a8a0:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a8a4:	b2d2      	uxtb	r2, r2
 800a8a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a8aa:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8ac:	bf00      	nop
 800a8ae:	9b03      	ldr	r3, [sp, #12]
 800a8b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a8b4:	9305      	str	r3, [sp, #20]
 800a8b6:	9b05      	ldr	r3, [sp, #20]
 800a8b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a8bc:	2b00      	cmp	r3, #0
 800a8be:	d0f6      	beq.n	800a8ae <sdc_lld_send_cmd_short+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a8c0:	9b03      	ldr	r3, [sp, #12]
 800a8c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8c4:	9a05      	ldr	r2, [sp, #20]
 800a8c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a8ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_CTIMEOUT)) != 0) {
 800a8cc:	9b05      	ldr	r3, [sp, #20]
 800a8ce:	f003 0304 	and.w	r3, r3, #4
 800a8d2:	2b00      	cmp	r3, #0
 800a8d4:	d005      	beq.n	800a8e2 <sdc_lld_send_cmd_short+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a8d6:	9803      	ldr	r0, [sp, #12]
 800a8d8:	9905      	ldr	r1, [sp, #20]
 800a8da:	f7ff fe19 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a8de:	2301      	movs	r3, #1
 800a8e0:	e005      	b.n	800a8ee <sdc_lld_send_cmd_short+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a8e2:	9b03      	ldr	r3, [sp, #12]
 800a8e4:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a8e6:	695a      	ldr	r2, [r3, #20]
 800a8e8:	9b00      	ldr	r3, [sp, #0]
 800a8ea:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a8ec:	2300      	movs	r3, #0
}
 800a8ee:	4618      	mov	r0, r3
 800a8f0:	b007      	add	sp, #28
 800a8f2:	f85d fb04 	ldr.w	pc, [sp], #4
 800a8f6:	bf00      	nop
 800a8f8:	f3af 8000 	nop.w
 800a8fc:	f3af 8000 	nop.w

0800a900 <sdc_lld_send_cmd_short_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_short_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                                uint32_t *resp) {
 800a900:	b500      	push	{lr}
 800a902:	b087      	sub	sp, #28
 800a904:	9003      	str	r0, [sp, #12]
 800a906:	9201      	str	r2, [sp, #4]
 800a908:	9300      	str	r3, [sp, #0]
 800a90a:	460b      	mov	r3, r1
 800a90c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  sdcp->sdmmc->ARG = arg;
 800a910:	9b03      	ldr	r3, [sp, #12]
 800a912:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a914:	9a01      	ldr	r2, [sp, #4]
 800a916:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_CPSMEN;
 800a918:	9b03      	ldr	r3, [sp, #12]
 800a91a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a91c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a920:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800a924:	b2d2      	uxtb	r2, r2
 800a926:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a92a:	60da      	str	r2, [r3, #12]
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a92c:	bf00      	nop
 800a92e:	9b03      	ldr	r3, [sp, #12]
 800a930:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a932:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a934:	9305      	str	r3, [sp, #20]
 800a936:	9b05      	ldr	r3, [sp, #20]
 800a938:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a93c:	2b00      	cmp	r3, #0
 800a93e:	d0f6      	beq.n	800a92e <sdc_lld_send_cmd_short_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL);
 800a940:	9b03      	ldr	r3, [sp, #12]
 800a942:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a944:	9a05      	ldr	r2, [sp, #20]
 800a946:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a94a:	639a      	str	r2, [r3, #56]	; 0x38
  if ((sta & (SDMMC_STA_CTIMEOUT | SDMMC_STA_CCRCFAIL)) != 0) {
 800a94c:	9b05      	ldr	r3, [sp, #20]
 800a94e:	f003 0305 	and.w	r3, r3, #5
 800a952:	2b00      	cmp	r3, #0
 800a954:	d005      	beq.n	800a962 <sdc_lld_send_cmd_short_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a956:	9803      	ldr	r0, [sp, #12]
 800a958:	9905      	ldr	r1, [sp, #20]
 800a95a:	f7ff fdd9 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a95e:	2301      	movs	r3, #1
 800a960:	e005      	b.n	800a96e <sdc_lld_send_cmd_short_crc+0x6e>
  }
  *resp = sdcp->sdmmc->RESP1;
 800a962:	9b03      	ldr	r3, [sp, #12]
 800a964:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a966:	695a      	ldr	r2, [r3, #20]
 800a968:	9b00      	ldr	r3, [sp, #0]
 800a96a:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800a96c:	2300      	movs	r3, #0
}
 800a96e:	4618      	mov	r0, r3
 800a970:	b007      	add	sp, #28
 800a972:	f85d fb04 	ldr.w	pc, [sp], #4
 800a976:	bf00      	nop
 800a978:	f3af 8000 	nop.w
 800a97c:	f3af 8000 	nop.w

0800a980 <sdc_lld_send_cmd_long_crc>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_send_cmd_long_crc(SDCDriver *sdcp, uint8_t cmd, uint32_t arg,
                               uint32_t *resp) {
 800a980:	b500      	push	{lr}
 800a982:	b087      	sub	sp, #28
 800a984:	9003      	str	r0, [sp, #12]
 800a986:	9201      	str	r2, [sp, #4]
 800a988:	9300      	str	r3, [sp, #0]
 800a98a:	460b      	mov	r3, r1
 800a98c:	f88d 300b 	strb.w	r3, [sp, #11]
  uint32_t sta;

  (void)sdcp;

  sdcp->sdmmc->ARG = arg;
 800a990:	9b03      	ldr	r3, [sp, #12]
 800a992:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a994:	9a01      	ldr	r2, [sp, #4]
 800a996:	609a      	str	r2, [r3, #8]
  sdcp->sdmmc->CMD = (uint32_t)cmd | SDMMC_CMD_WAITRESP_0 | SDMMC_CMD_WAITRESP_1 |
 800a998:	9b03      	ldr	r3, [sp, #12]
 800a99a:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a99c:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800a9a0:	f062 023f 	orn	r2, r2, #63	; 0x3f
 800a9a4:	b2d2      	uxtb	r2, r2
 800a9a6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 800a9aa:	60da      	str	r2, [r3, #12]
                                    SDMMC_CMD_CPSMEN;
  while (((sta = sdcp->sdmmc->STA) & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9ac:	bf00      	nop
 800a9ae:	9b03      	ldr	r3, [sp, #12]
 800a9b0:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9b2:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 800a9b4:	9305      	str	r3, [sp, #20]
 800a9b6:	9b05      	ldr	r3, [sp, #20]
 800a9b8:	f003 0345 	and.w	r3, r3, #69	; 0x45
 800a9bc:	2b00      	cmp	r3, #0
 800a9be:	d0f6      	beq.n	800a9ae <sdc_lld_send_cmd_long_crc+0x2e>
                                     SDMMC_STA_CCRCFAIL)) == 0)
    ;
  sdcp->sdmmc->ICR = sta & (SDMMC_STA_CMDREND | SDMMC_STA_CTIMEOUT |
 800a9c0:	9b03      	ldr	r3, [sp, #12]
 800a9c2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800a9c4:	9a05      	ldr	r2, [sp, #20]
 800a9c6:	f002 0245 	and.w	r2, r2, #69	; 0x45
 800a9ca:	639a      	str	r2, [r3, #56]	; 0x38
                           SDMMC_STA_CCRCFAIL);
  if ((sta & (SDMMC_STA_ERROR_MASK)) != 0) {
 800a9cc:	9b05      	ldr	r3, [sp, #20]
 800a9ce:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 800a9d2:	2b00      	cmp	r3, #0
 800a9d4:	d005      	beq.n	800a9e2 <sdc_lld_send_cmd_long_crc+0x62>
    sdc_lld_collect_errors(sdcp, sta);
 800a9d6:	9803      	ldr	r0, [sp, #12]
 800a9d8:	9905      	ldr	r1, [sp, #20]
 800a9da:	f7ff fd99 	bl	800a510 <sdc_lld_collect_errors>
    return HAL_FAILED;
 800a9de:	2301      	movs	r3, #1
 800a9e0:	e01a      	b.n	800aa18 <sdc_lld_send_cmd_long_crc+0x98>
  }
  /* Save bytes in reverse order because MSB in response comes first.*/
  *resp++ = sdcp->sdmmc->RESP4;
 800a9e2:	9b00      	ldr	r3, [sp, #0]
 800a9e4:	1d1a      	adds	r2, r3, #4
 800a9e6:	9200      	str	r2, [sp, #0]
 800a9e8:	9a03      	ldr	r2, [sp, #12]
 800a9ea:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9ec:	6a12      	ldr	r2, [r2, #32]
 800a9ee:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP3;
 800a9f0:	9b00      	ldr	r3, [sp, #0]
 800a9f2:	1d1a      	adds	r2, r3, #4
 800a9f4:	9200      	str	r2, [sp, #0]
 800a9f6:	9a03      	ldr	r2, [sp, #12]
 800a9f8:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800a9fa:	69d2      	ldr	r2, [r2, #28]
 800a9fc:	601a      	str	r2, [r3, #0]
  *resp++ = sdcp->sdmmc->RESP2;
 800a9fe:	9b00      	ldr	r3, [sp, #0]
 800aa00:	1d1a      	adds	r2, r3, #4
 800aa02:	9200      	str	r2, [sp, #0]
 800aa04:	9a03      	ldr	r2, [sp, #12]
 800aa06:	6c92      	ldr	r2, [r2, #72]	; 0x48
 800aa08:	6992      	ldr	r2, [r2, #24]
 800aa0a:	601a      	str	r2, [r3, #0]
  *resp   = sdcp->sdmmc->RESP1;
 800aa0c:	9b03      	ldr	r3, [sp, #12]
 800aa0e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aa10:	695a      	ldr	r2, [r3, #20]
 800aa12:	9b00      	ldr	r3, [sp, #0]
 800aa14:	601a      	str	r2, [r3, #0]
  return HAL_SUCCESS;
 800aa16:	2300      	movs	r3, #0
}
 800aa18:	4618      	mov	r0, r3
 800aa1a:	b007      	add	sp, #28
 800aa1c:	f85d fb04 	ldr.w	pc, [sp], #4

0800aa20 <sdc_lld_read_special>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_special(SDCDriver *sdcp, uint8_t *buf, size_t bytes,
                          uint8_t cmd, uint32_t arg) {
 800aa20:	b500      	push	{lr}
 800aa22:	b087      	sub	sp, #28
 800aa24:	9003      	str	r0, [sp, #12]
 800aa26:	9102      	str	r1, [sp, #8]
 800aa28:	9201      	str	r2, [sp, #4]
 800aa2a:	f88d 3003 	strb.w	r3, [sp, #3]
  uint32_t resp[1];

  if(sdc_lld_prepare_read_bytes(sdcp, buf, bytes))
 800aa2e:	9803      	ldr	r0, [sp, #12]
 800aa30:	9902      	ldr	r1, [sp, #8]
 800aa32:	9a01      	ldr	r2, [sp, #4]
 800aa34:	f7ff fc2c 	bl	800a290 <sdc_lld_prepare_read_bytes>
 800aa38:	4603      	mov	r3, r0
 800aa3a:	2b00      	cmp	r3, #0
 800aa3c:	d000      	beq.n	800aa40 <sdc_lld_read_special+0x20>
    goto error;
 800aa3e:	e01b      	b.n	800aa78 <sdc_lld_read_special+0x58>

  if (sdc_lld_send_cmd_short_crc(sdcp, cmd, arg, resp)
 800aa40:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800aa44:	ab05      	add	r3, sp, #20
 800aa46:	9803      	ldr	r0, [sp, #12]
 800aa48:	4611      	mov	r1, r2
 800aa4a:	9a08      	ldr	r2, [sp, #32]
 800aa4c:	f7ff ff58 	bl	800a900 <sdc_lld_send_cmd_short_crc>
 800aa50:	4603      	mov	r3, r0
 800aa52:	2b00      	cmp	r3, #0
 800aa54:	d110      	bne.n	800aa78 <sdc_lld_read_special+0x58>
                                 || MMCSD_R1_ERROR(resp[0]))
 800aa56:	9a05      	ldr	r2, [sp, #20]
 800aa58:	4b0d      	ldr	r3, [pc, #52]	; (800aa90 <sdc_lld_read_special+0x70>)
 800aa5a:	4013      	ands	r3, r2
 800aa5c:	2b00      	cmp	r3, #0
 800aa5e:	d10b      	bne.n	800aa78 <sdc_lld_read_special+0x58>
    goto error;

  if (sdc_lld_wait_transaction_end(sdcp, 1, resp))
 800aa60:	ab05      	add	r3, sp, #20
 800aa62:	9803      	ldr	r0, [sp, #12]
 800aa64:	2101      	movs	r1, #1
 800aa66:	461a      	mov	r2, r3
 800aa68:	f7ff fcfa 	bl	800a460 <sdc_lld_wait_transaction_end>
 800aa6c:	4603      	mov	r3, r0
 800aa6e:	2b00      	cmp	r3, #0
 800aa70:	d000      	beq.n	800aa74 <sdc_lld_read_special+0x54>
    goto error;
 800aa72:	e001      	b.n	800aa78 <sdc_lld_read_special+0x58>

  return HAL_SUCCESS;
 800aa74:	2300      	movs	r3, #0
 800aa76:	e006      	b.n	800aa86 <sdc_lld_read_special+0x66>

error:
  sdc_lld_error_cleanup(sdcp, 1, resp);
 800aa78:	ab05      	add	r3, sp, #20
 800aa7a:	9803      	ldr	r0, [sp, #12]
 800aa7c:	2101      	movs	r1, #1
 800aa7e:	461a      	mov	r2, r3
 800aa80:	f7ff fd8e 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800aa84:	2301      	movs	r3, #1
}
 800aa86:	4618      	mov	r0, r3
 800aa88:	b007      	add	sp, #28
 800aa8a:	f85d fb04 	ldr.w	pc, [sp], #4
 800aa8e:	bf00      	nop
 800aa90:	fdffe008 	.word	0xfdffe008
 800aa94:	f3af 8000 	nop.w
 800aa98:	f3af 8000 	nop.w
 800aa9c:	f3af 8000 	nop.w

0800aaa0 <sdc_lld_read_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read_aligned(SDCDriver *sdcp, uint32_t startblk,
                          uint8_t *buf, uint32_t blocks) {
 800aaa0:	b500      	push	{lr}
 800aaa2:	b087      	sub	sp, #28
 800aaa4:	9003      	str	r0, [sp, #12]
 800aaa6:	9102      	str	r1, [sp, #8]
 800aaa8:	9201      	str	r2, [sp, #4]
 800aaaa:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_READ_TIMEOUT;
 800aaac:	9b03      	ldr	r3, [sp, #12]
 800aaae:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800aab0:	4a3b      	ldr	r2, [pc, #236]	; (800aba0 <sdc_lld_read_aligned+0x100>)
 800aab2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for reading.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800aab4:	9803      	ldr	r0, [sp, #12]
 800aab6:	f7fa ffab 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800aaba:	4603      	mov	r3, r0
 800aabc:	2b00      	cmp	r3, #0
 800aabe:	d001      	beq.n	800aac4 <sdc_lld_read_aligned+0x24>
    return HAL_FAILED;
 800aac0:	2301      	movs	r3, #1
 800aac2:	e069      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800aac4:	9b03      	ldr	r3, [sp, #12]
 800aac6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aac8:	685b      	ldr	r3, [r3, #4]
 800aaca:	9a01      	ldr	r2, [sp, #4]
 800aacc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800aace:	9b03      	ldr	r3, [sp, #12]
 800aad0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aad2:	685b      	ldr	r3, [r3, #4]
 800aad4:	9a00      	ldr	r2, [sp, #0]
 800aad6:	0252      	lsls	r2, r2, #9
 800aad8:	0892      	lsrs	r2, r2, #2
 800aada:	605a      	str	r2, [r3, #4]
                              (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_P2M);
 800aadc:	9b03      	ldr	r3, [sp, #12]
 800aade:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aae0:	68db      	ldr	r3, [r3, #12]
 800aae2:	681b      	ldr	r3, [r3, #0]
 800aae4:	9305      	str	r3, [sp, #20]
 800aae6:	9b03      	ldr	r3, [sp, #12]
 800aae8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800aaea:	7c1b      	ldrb	r3, [r3, #16]
 800aaec:	220f      	movs	r2, #15
 800aaee:	fa02 f303 	lsl.w	r3, r2, r3
 800aaf2:	43db      	mvns	r3, r3
 800aaf4:	9a05      	ldr	r2, [sp, #20]
 800aaf6:	4013      	ands	r3, r2
 800aaf8:	9305      	str	r3, [sp, #20]
 800aafa:	9b03      	ldr	r3, [sp, #12]
 800aafc:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800aafe:	0c1a      	lsrs	r2, r3, #16
 800ab00:	9b03      	ldr	r3, [sp, #12]
 800ab02:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab04:	7c1b      	ldrb	r3, [r3, #16]
 800ab06:	fa02 f303 	lsl.w	r3, r2, r3
 800ab0a:	9a05      	ldr	r2, [sp, #20]
 800ab0c:	4313      	orrs	r3, r2
 800ab0e:	9305      	str	r3, [sp, #20]
 800ab10:	9b03      	ldr	r3, [sp, #12]
 800ab12:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab14:	68db      	ldr	r3, [r3, #12]
 800ab16:	9a05      	ldr	r2, [sp, #20]
 800ab18:	601a      	str	r2, [r3, #0]
 800ab1a:	9b03      	ldr	r3, [sp, #12]
 800ab1c:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab1e:	685b      	ldr	r3, [r3, #4]
 800ab20:	9a03      	ldr	r2, [sp, #12]
 800ab22:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ab24:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ab26:	9b03      	ldr	r3, [sp, #12]
 800ab28:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ab2a:	685b      	ldr	r3, [r3, #4]
 800ab2c:	9a03      	ldr	r2, [sp, #12]
 800ab2e:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ab30:	6852      	ldr	r2, [r2, #4]
 800ab32:	6812      	ldr	r2, [r2, #0]
 800ab34:	f042 0201 	orr.w	r2, r2, #1
 800ab38:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ab3a:	9b03      	ldr	r3, [sp, #12]
 800ab3c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab3e:	4a19      	ldr	r2, [pc, #100]	; (800aba4 <sdc_lld_read_aligned+0x104>)
 800ab40:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ab42:	9b03      	ldr	r3, [sp, #12]
 800ab44:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab46:	f44f 7295 	mov.w	r2, #298	; 0x12a
 800ab4a:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_RXOVERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ab4c:	9b03      	ldr	r3, [sp, #12]
 800ab4e:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab50:	9a00      	ldr	r2, [sp, #0]
 800ab52:	0252      	lsls	r2, r2, #9
 800ab54:	629a      	str	r2, [r3, #40]	; 0x28

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DTDIR |
 800ab56:	9b03      	ldr	r3, [sp, #12]
 800ab58:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ab5a:	229b      	movs	r2, #155	; 0x9b
 800ab5c:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_3 |
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_prepare_read(sdcp, startblk, blocks, resp) == TRUE)
 800ab5e:	ab04      	add	r3, sp, #16
 800ab60:	9803      	ldr	r0, [sp, #12]
 800ab62:	9902      	ldr	r1, [sp, #8]
 800ab64:	9a00      	ldr	r2, [sp, #0]
 800ab66:	f7ff fbfb 	bl	800a360 <sdc_lld_prepare_read>
 800ab6a:	4603      	mov	r3, r0
 800ab6c:	2b00      	cmp	r3, #0
 800ab6e:	d000      	beq.n	800ab72 <sdc_lld_read_aligned+0xd2>
    goto error;
 800ab70:	e00b      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ab72:	ab04      	add	r3, sp, #16
 800ab74:	9803      	ldr	r0, [sp, #12]
 800ab76:	9900      	ldr	r1, [sp, #0]
 800ab78:	461a      	mov	r2, r3
 800ab7a:	f7ff fc71 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ab7e:	4603      	mov	r3, r0
 800ab80:	2b00      	cmp	r3, #0
 800ab82:	d000      	beq.n	800ab86 <sdc_lld_read_aligned+0xe6>
    goto error;
 800ab84:	e001      	b.n	800ab8a <sdc_lld_read_aligned+0xea>

  return HAL_SUCCESS;
 800ab86:	2300      	movs	r3, #0
 800ab88:	e006      	b.n	800ab98 <sdc_lld_read_aligned+0xf8>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800ab8a:	ab04      	add	r3, sp, #16
 800ab8c:	9803      	ldr	r0, [sp, #12]
 800ab8e:	9900      	ldr	r1, [sp, #0]
 800ab90:	461a      	mov	r2, r3
 800ab92:	f7ff fd05 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800ab96:	2301      	movs	r3, #1
}
 800ab98:	4618      	mov	r0, r3
 800ab9a:	b007      	add	sp, #28
 800ab9c:	f85d fb04 	ldr.w	pc, [sp], #4
 800aba0:	000927c0 	.word	0x000927c0
 800aba4:	004005ff 	.word	0x004005ff
 800aba8:	f3af 8000 	nop.w
 800abac:	f3af 8000 	nop.w

0800abb0 <sdc_lld_write_aligned>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write_aligned(SDCDriver *sdcp, uint32_t startblk,
                           const uint8_t *buf, uint32_t blocks) {
 800abb0:	b500      	push	{lr}
 800abb2:	b087      	sub	sp, #28
 800abb4:	9003      	str	r0, [sp, #12]
 800abb6:	9102      	str	r1, [sp, #8]
 800abb8:	9201      	str	r2, [sp, #4]
 800abba:	9300      	str	r3, [sp, #0]
  uint32_t resp[1];

  osalDbgCheck(blocks < 0x1000000 / MMCSD_BLOCK_SIZE);

  sdcp->sdmmc->DTIMER = SDMMC_WRITE_TIMEOUT;
 800abbc:	9b03      	ldr	r3, [sp, #12]
 800abbe:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800abc0:	4a3d      	ldr	r2, [pc, #244]	; (800acb8 <sdc_lld_write_aligned+0x108>)
 800abc2:	625a      	str	r2, [r3, #36]	; 0x24

  /* Checks for errors and waits for the card to be ready for writing.*/
  if (_sdc_wait_for_transfer_state(sdcp))
 800abc4:	9803      	ldr	r0, [sp, #12]
 800abc6:	f7fa ff23 	bl	8005a10 <_sdc_wait_for_transfer_state>
 800abca:	4603      	mov	r3, r0
 800abcc:	2b00      	cmp	r3, #0
 800abce:	d001      	beq.n	800abd4 <sdc_lld_write_aligned+0x24>
    return HAL_FAILED;
 800abd0:	2301      	movs	r3, #1
 800abd2:	e06d      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

  /* Prepares the DMA channel for writing.*/
  dmaStreamSetMemory0(sdcp->dma, buf);
 800abd4:	9b03      	ldr	r3, [sp, #12]
 800abd6:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abd8:	685b      	ldr	r3, [r3, #4]
 800abda:	9a01      	ldr	r2, [sp, #4]
 800abdc:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(sdcp->dma,
 800abde:	9b03      	ldr	r3, [sp, #12]
 800abe0:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abe2:	685b      	ldr	r3, [r3, #4]
 800abe4:	9a00      	ldr	r2, [sp, #0]
 800abe6:	0252      	lsls	r2, r2, #9
 800abe8:	0892      	lsrs	r2, r2, #2
 800abea:	605a      	str	r2, [r3, #4]
                             (blocks * MMCSD_BLOCK_SIZE) / sizeof (uint32_t));
  dmaStreamSetMode(sdcp->dma, sdcp->dmamode | STM32_DMA_CR_DIR_M2P);
 800abec:	9b03      	ldr	r3, [sp, #12]
 800abee:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abf0:	68db      	ldr	r3, [r3, #12]
 800abf2:	681b      	ldr	r3, [r3, #0]
 800abf4:	9305      	str	r3, [sp, #20]
 800abf6:	9b03      	ldr	r3, [sp, #12]
 800abf8:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800abfa:	7c1b      	ldrb	r3, [r3, #16]
 800abfc:	220f      	movs	r2, #15
 800abfe:	fa02 f303 	lsl.w	r3, r2, r3
 800ac02:	43db      	mvns	r3, r3
 800ac04:	9a05      	ldr	r2, [sp, #20]
 800ac06:	4013      	ands	r3, r2
 800ac08:	9305      	str	r3, [sp, #20]
 800ac0a:	9b03      	ldr	r3, [sp, #12]
 800ac0c:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 800ac0e:	f043 0310 	orr.w	r3, r3, #16
 800ac12:	0c1a      	lsrs	r2, r3, #16
 800ac14:	9b03      	ldr	r3, [sp, #12]
 800ac16:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac18:	7c1b      	ldrb	r3, [r3, #16]
 800ac1a:	fa02 f303 	lsl.w	r3, r2, r3
 800ac1e:	9a05      	ldr	r2, [sp, #20]
 800ac20:	4313      	orrs	r3, r2
 800ac22:	9305      	str	r3, [sp, #20]
 800ac24:	9b03      	ldr	r3, [sp, #12]
 800ac26:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac28:	68db      	ldr	r3, [r3, #12]
 800ac2a:	9a05      	ldr	r2, [sp, #20]
 800ac2c:	601a      	str	r2, [r3, #0]
 800ac2e:	9b03      	ldr	r3, [sp, #12]
 800ac30:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac32:	685b      	ldr	r3, [r3, #4]
 800ac34:	9a03      	ldr	r2, [sp, #12]
 800ac36:	6c12      	ldr	r2, [r2, #64]	; 0x40
 800ac38:	f042 0210 	orr.w	r2, r2, #16
 800ac3c:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(sdcp->dma);
 800ac3e:	9b03      	ldr	r3, [sp, #12]
 800ac40:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 800ac42:	685b      	ldr	r3, [r3, #4]
 800ac44:	9a03      	ldr	r2, [sp, #12]
 800ac46:	6c52      	ldr	r2, [r2, #68]	; 0x44
 800ac48:	6852      	ldr	r2, [r2, #4]
 800ac4a:	6812      	ldr	r2, [r2, #0]
 800ac4c:	f042 0201 	orr.w	r2, r2, #1
 800ac50:	601a      	str	r2, [r3, #0]

  /* Setting up data transfer.*/
  sdcp->sdmmc->ICR   = SDMMC_ICR_ALL_FLAGS;
 800ac52:	9b03      	ldr	r3, [sp, #12]
 800ac54:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac56:	4a19      	ldr	r2, [pc, #100]	; (800acbc <sdc_lld_write_aligned+0x10c>)
 800ac58:	639a      	str	r2, [r3, #56]	; 0x38
  sdcp->sdmmc->MASK  = SDMMC_MASK_DCRCFAILIE |
 800ac5a:	9b03      	ldr	r3, [sp, #12]
 800ac5c:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac5e:	f44f 728d 	mov.w	r2, #282	; 0x11a
 800ac62:	63da      	str	r2, [r3, #60]	; 0x3c
                       SDMMC_MASK_DTIMEOUTIE |
                       SDMMC_MASK_TXUNDERRIE |
                       SDMMC_MASK_DATAENDIE;
  sdcp->sdmmc->DLEN  = blocks * MMCSD_BLOCK_SIZE;
 800ac64:	9b03      	ldr	r3, [sp, #12]
 800ac66:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac68:	9a00      	ldr	r2, [sp, #0]
 800ac6a:	0252      	lsls	r2, r2, #9
 800ac6c:	629a      	str	r2, [r3, #40]	; 0x28

  /* Talk to card what we want from it.*/
  if (sdc_lld_prepare_write(sdcp, startblk, blocks, resp) == TRUE)
 800ac6e:	ab04      	add	r3, sp, #16
 800ac70:	9803      	ldr	r0, [sp, #12]
 800ac72:	9902      	ldr	r1, [sp, #8]
 800ac74:	9a00      	ldr	r2, [sp, #0]
 800ac76:	f7ff fbb3 	bl	800a3e0 <sdc_lld_prepare_write>
 800ac7a:	4603      	mov	r3, r0
 800ac7c:	2b00      	cmp	r3, #0
 800ac7e:	d000      	beq.n	800ac82 <sdc_lld_write_aligned+0xd2>
    goto error;
 800ac80:	e00f      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  /* Transaction starts just after DTEN bit setting.*/
  sdcp->sdmmc->DCTRL = SDMMC_DCTRL_DBLOCKSIZE_3 |
 800ac82:	9b03      	ldr	r3, [sp, #12]
 800ac84:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 800ac86:	2299      	movs	r2, #153	; 0x99
 800ac88:	62da      	str	r2, [r3, #44]	; 0x2c
                       SDMMC_DCTRL_DBLOCKSIZE_0 |
                       SDMMC_DCTRL_DMAEN |
                       SDMMC_DCTRL_DTEN;

  if (sdc_lld_wait_transaction_end(sdcp, blocks, resp) == TRUE)
 800ac8a:	ab04      	add	r3, sp, #16
 800ac8c:	9803      	ldr	r0, [sp, #12]
 800ac8e:	9900      	ldr	r1, [sp, #0]
 800ac90:	461a      	mov	r2, r3
 800ac92:	f7ff fbe5 	bl	800a460 <sdc_lld_wait_transaction_end>
 800ac96:	4603      	mov	r3, r0
 800ac98:	2b00      	cmp	r3, #0
 800ac9a:	d000      	beq.n	800ac9e <sdc_lld_write_aligned+0xee>
    goto error;
 800ac9c:	e001      	b.n	800aca2 <sdc_lld_write_aligned+0xf2>

  return HAL_SUCCESS;
 800ac9e:	2300      	movs	r3, #0
 800aca0:	e006      	b.n	800acb0 <sdc_lld_write_aligned+0x100>

error:
  sdc_lld_error_cleanup(sdcp, blocks, resp);
 800aca2:	ab04      	add	r3, sp, #16
 800aca4:	9803      	ldr	r0, [sp, #12]
 800aca6:	9900      	ldr	r1, [sp, #0]
 800aca8:	461a      	mov	r2, r3
 800acaa:	f7ff fc79 	bl	800a5a0 <sdc_lld_error_cleanup>
  return HAL_FAILED;
 800acae:	2301      	movs	r3, #1
}
 800acb0:	4618      	mov	r0, r3
 800acb2:	b007      	add	sp, #28
 800acb4:	f85d fb04 	ldr.w	pc, [sp], #4
 800acb8:	005b8d80 	.word	0x005b8d80
 800acbc:	004005ff 	.word	0x004005ff

0800acc0 <sdc_lld_read>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_read(SDCDriver *sdcp, uint32_t startblk,
                  uint8_t *buf, uint32_t blocks) {
 800acc0:	b500      	push	{lr}
 800acc2:	b087      	sub	sp, #28
 800acc4:	9003      	str	r0, [sp, #12]
 800acc6:	9102      	str	r1, [sp, #8]
 800acc8:	9201      	str	r2, [sp, #4]
 800acca:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800accc:	9b01      	ldr	r3, [sp, #4]
 800acce:	f003 0303 	and.w	r3, r3, #3
 800acd2:	2b00      	cmp	r3, #0
 800acd4:	d028      	beq.n	800ad28 <sdc_lld_read+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800acd6:	2300      	movs	r3, #0
 800acd8:	9305      	str	r3, [sp, #20]
 800acda:	e01f      	b.n	800ad1c <sdc_lld_read+0x5c>
      if (sdc_lld_read_aligned(sdcp, startblk, u.buf, 1))
 800acdc:	9803      	ldr	r0, [sp, #12]
 800acde:	9902      	ldr	r1, [sp, #8]
 800ace0:	4a17      	ldr	r2, [pc, #92]	; (800ad40 <sdc_lld_read+0x80>)
 800ace2:	2301      	movs	r3, #1
 800ace4:	f7ff fedc 	bl	800aaa0 <sdc_lld_read_aligned>
 800ace8:	4603      	mov	r3, r0
 800acea:	2b00      	cmp	r3, #0
 800acec:	d001      	beq.n	800acf2 <sdc_lld_read+0x32>
        return HAL_FAILED;
 800acee:	2301      	movs	r3, #1
 800acf0:	e021      	b.n	800ad36 <sdc_lld_read+0x76>
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
 800acf2:	9a01      	ldr	r2, [sp, #4]
 800acf4:	4b12      	ldr	r3, [pc, #72]	; (800ad40 <sdc_lld_read+0x80>)
 800acf6:	4611      	mov	r1, r2
 800acf8:	461a      	mov	r2, r3
 800acfa:	f44f 7300 	mov.w	r3, #512	; 0x200
 800acfe:	4608      	mov	r0, r1
 800ad00:	4611      	mov	r1, r2
 800ad02:	461a      	mov	r2, r3
 800ad04:	f00b fe24 	bl	8016950 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad08:	9b01      	ldr	r3, [sp, #4]
 800ad0a:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad0e:	9301      	str	r3, [sp, #4]
      startblk++;
 800ad10:	9b02      	ldr	r3, [sp, #8]
 800ad12:	3301      	adds	r3, #1
 800ad14:	9302      	str	r3, [sp, #8]
                  uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad16:	9b05      	ldr	r3, [sp, #20]
 800ad18:	3301      	adds	r3, #1
 800ad1a:	9305      	str	r3, [sp, #20]
 800ad1c:	9a05      	ldr	r2, [sp, #20]
 800ad1e:	9b00      	ldr	r3, [sp, #0]
 800ad20:	429a      	cmp	r2, r3
 800ad22:	d3db      	bcc.n	800acdc <sdc_lld_read+0x1c>
        return HAL_FAILED;
      memcpy(buf, u.buf, MMCSD_BLOCK_SIZE);
      buf += MMCSD_BLOCK_SIZE;
      startblk++;
    }
    return HAL_SUCCESS;
 800ad24:	2300      	movs	r3, #0
 800ad26:	e006      	b.n	800ad36 <sdc_lld_read+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_read_aligned(sdcp, startblk, buf, blocks);
 800ad28:	9803      	ldr	r0, [sp, #12]
 800ad2a:	9902      	ldr	r1, [sp, #8]
 800ad2c:	9a01      	ldr	r2, [sp, #4]
 800ad2e:	9b00      	ldr	r3, [sp, #0]
 800ad30:	f7ff feb6 	bl	800aaa0 <sdc_lld_read_aligned>
 800ad34:	4603      	mov	r3, r0
}
 800ad36:	4618      	mov	r0, r3
 800ad38:	b007      	add	sp, #28
 800ad3a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ad3e:	bf00      	nop
 800ad40:	200011cc 	.word	0x200011cc
 800ad44:	f3af 8000 	nop.w
 800ad48:	f3af 8000 	nop.w
 800ad4c:	f3af 8000 	nop.w

0800ad50 <sdc_lld_write>:
 * @retval HAL_FAILED   operation failed.
 *
 * @notapi
 */
bool sdc_lld_write(SDCDriver *sdcp, uint32_t startblk,
                   const uint8_t *buf, uint32_t blocks) {
 800ad50:	b500      	push	{lr}
 800ad52:	b087      	sub	sp, #28
 800ad54:	9003      	str	r0, [sp, #12]
 800ad56:	9102      	str	r1, [sp, #8]
 800ad58:	9201      	str	r2, [sp, #4]
 800ad5a:	9300      	str	r3, [sp, #0]

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
 800ad5c:	9b01      	ldr	r3, [sp, #4]
 800ad5e:	f003 0303 	and.w	r3, r3, #3
 800ad62:	2b00      	cmp	r3, #0
 800ad64:	d028      	beq.n	800adb8 <sdc_lld_write+0x68>
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ad66:	2300      	movs	r3, #0
 800ad68:	9305      	str	r3, [sp, #20]
 800ad6a:	e01f      	b.n	800adac <sdc_lld_write+0x5c>
      memcpy(u.buf, buf, MMCSD_BLOCK_SIZE);
 800ad6c:	4a18      	ldr	r2, [pc, #96]	; (800add0 <sdc_lld_write+0x80>)
 800ad6e:	9b01      	ldr	r3, [sp, #4]
 800ad70:	4611      	mov	r1, r2
 800ad72:	461a      	mov	r2, r3
 800ad74:	f44f 7300 	mov.w	r3, #512	; 0x200
 800ad78:	4608      	mov	r0, r1
 800ad7a:	4611      	mov	r1, r2
 800ad7c:	461a      	mov	r2, r3
 800ad7e:	f00b fde7 	bl	8016950 <memcpy>
      buf += MMCSD_BLOCK_SIZE;
 800ad82:	9b01      	ldr	r3, [sp, #4]
 800ad84:	f503 7300 	add.w	r3, r3, #512	; 0x200
 800ad88:	9301      	str	r3, [sp, #4]
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
 800ad8a:	9803      	ldr	r0, [sp, #12]
 800ad8c:	9902      	ldr	r1, [sp, #8]
 800ad8e:	4a10      	ldr	r2, [pc, #64]	; (800add0 <sdc_lld_write+0x80>)
 800ad90:	2301      	movs	r3, #1
 800ad92:	f7ff ff0d 	bl	800abb0 <sdc_lld_write_aligned>
 800ad96:	4603      	mov	r3, r0
 800ad98:	2b00      	cmp	r3, #0
 800ad9a:	d001      	beq.n	800ada0 <sdc_lld_write+0x50>
        return HAL_FAILED;
 800ad9c:	2301      	movs	r3, #1
 800ad9e:	e012      	b.n	800adc6 <sdc_lld_write+0x76>
      startblk++;
 800ada0:	9b02      	ldr	r3, [sp, #8]
 800ada2:	3301      	adds	r3, #1
 800ada4:	9302      	str	r3, [sp, #8]
                   const uint8_t *buf, uint32_t blocks) {

#if STM32_SDC_SDMMC_UNALIGNED_SUPPORT
  if (((unsigned)buf & 3) != 0) {
    uint32_t i;
    for (i = 0; i < blocks; i++) {
 800ada6:	9b05      	ldr	r3, [sp, #20]
 800ada8:	3301      	adds	r3, #1
 800adaa:	9305      	str	r3, [sp, #20]
 800adac:	9a05      	ldr	r2, [sp, #20]
 800adae:	9b00      	ldr	r3, [sp, #0]
 800adb0:	429a      	cmp	r2, r3
 800adb2:	d3db      	bcc.n	800ad6c <sdc_lld_write+0x1c>
      buf += MMCSD_BLOCK_SIZE;
      if (sdc_lld_write_aligned(sdcp, startblk, u.buf, 1))
        return HAL_FAILED;
      startblk++;
    }
    return HAL_SUCCESS;
 800adb4:	2300      	movs	r3, #0
 800adb6:	e006      	b.n	800adc6 <sdc_lld_write+0x76>
  }
#endif /* STM32_SDC_SDMMC_UNALIGNED_SUPPORT */
  return sdc_lld_write_aligned(sdcp, startblk, buf, blocks);
 800adb8:	9803      	ldr	r0, [sp, #12]
 800adba:	9902      	ldr	r1, [sp, #8]
 800adbc:	9a01      	ldr	r2, [sp, #4]
 800adbe:	9b00      	ldr	r3, [sp, #0]
 800adc0:	f7ff fef6 	bl	800abb0 <sdc_lld_write_aligned>
 800adc4:	4603      	mov	r3, r0
}
 800adc6:	4618      	mov	r0, r3
 800adc8:	b007      	add	sp, #28
 800adca:	f85d fb04 	ldr.w	pc, [sp], #4
 800adce:	bf00      	nop
 800add0:	200011cc 	.word	0x200011cc
 800add4:	f3af 8000 	nop.w
 800add8:	f3af 8000 	nop.w
 800addc:	f3af 8000 	nop.w

0800ade0 <sdc_lld_sync>:
 * @retval HAL_SUCCESS  the operation succeeded.
 * @retval HAL_FAILED   the operation failed.
 *
 * @api
 */
bool sdc_lld_sync(SDCDriver *sdcp) {
 800ade0:	b082      	sub	sp, #8
 800ade2:	9001      	str	r0, [sp, #4]

  /* TODO: Implement.*/
  (void)sdcp;
  return HAL_SUCCESS;
 800ade4:	2300      	movs	r3, #0
}
 800ade6:	4618      	mov	r0, r3
 800ade8:	b002      	add	sp, #8
 800adea:	4770      	bx	lr
 800adec:	f3af 8000 	nop.w

0800adf0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800adf0:	b082      	sub	sp, #8
 800adf2:	2320      	movs	r3, #32
 800adf4:	9301      	str	r3, [sp, #4]
 800adf6:	9b01      	ldr	r3, [sp, #4]
 800adf8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800adfc:	b002      	add	sp, #8
 800adfe:	4770      	bx	lr

0800ae00 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800ae00:	b082      	sub	sp, #8
 800ae02:	2300      	movs	r3, #0
 800ae04:	9301      	str	r3, [sp, #4]
 800ae06:	9b01      	ldr	r3, [sp, #4]
 800ae08:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800ae0c:	b002      	add	sp, #8
 800ae0e:	4770      	bx	lr

0800ae10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800ae10:	b508      	push	{r3, lr}

  port_lock();
 800ae12:	f7ff ffed 	bl	800adf0 <port_lock>
}
 800ae16:	bd08      	pop	{r3, pc}
 800ae18:	f3af 8000 	nop.w
 800ae1c:	f3af 8000 	nop.w

0800ae20 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800ae20:	b508      	push	{r3, lr}

  port_unlock();
 800ae22:	f7ff ffed 	bl	800ae00 <port_unlock>
}
 800ae26:	bd08      	pop	{r3, pc}
 800ae28:	f3af 8000 	nop.w
 800ae2c:	f3af 8000 	nop.w

0800ae30 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800ae30:	b508      	push	{r3, lr}

  port_lock();
 800ae32:	f7ff ffdd 	bl	800adf0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800ae36:	bd08      	pop	{r3, pc}
 800ae38:	f3af 8000 	nop.w
 800ae3c:	f3af 8000 	nop.w

0800ae40 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800ae40:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800ae42:	f7ff ffdd 	bl	800ae00 <port_unlock>
}
 800ae46:	bd08      	pop	{r3, pc}
 800ae48:	f3af 8000 	nop.w
 800ae4c:	f3af 8000 	nop.w

0800ae50 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800ae50:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800ae52:	f7ff ffdd 	bl	800ae10 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800ae56:	bd08      	pop	{r3, pc}
 800ae58:	f3af 8000 	nop.w
 800ae5c:	f3af 8000 	nop.w

0800ae60 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800ae60:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800ae62:	f7ff ffdd 	bl	800ae20 <port_unlock_from_isr>
}
 800ae66:	bd08      	pop	{r3, pc}
 800ae68:	f3af 8000 	nop.w
 800ae6c:	f3af 8000 	nop.w

0800ae70 <osalSysHalt>:
 *
 * @param[in] reason    the halt message pointer
 *
 * @api
 */
static inline void osalSysHalt(const char *reason) {
 800ae70:	b500      	push	{lr}
 800ae72:	b083      	sub	sp, #12
 800ae74:	9001      	str	r0, [sp, #4]

  chSysHalt(reason);
 800ae76:	9801      	ldr	r0, [sp, #4]
 800ae78:	f7f5 fc52 	bl	8000720 <chSysHalt>
}
 800ae7c:	b003      	add	sp, #12
 800ae7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800ae82:	bf00      	nop
 800ae84:	f3af 8000 	nop.w
 800ae88:	f3af 8000 	nop.w
 800ae8c:	f3af 8000 	nop.w

0800ae90 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800ae90:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800ae92:	f7ff ffdd 	bl	800ae50 <chSysLockFromISR>
}
 800ae96:	bd08      	pop	{r3, pc}
 800ae98:	f3af 8000 	nop.w
 800ae9c:	f3af 8000 	nop.w

0800aea0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800aea0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800aea2:	f7ff ffdd 	bl	800ae60 <chSysUnlockFromISR>
}
 800aea6:	bd08      	pop	{r3, pc}
 800aea8:	f3af 8000 	nop.w
 800aeac:	f3af 8000 	nop.w

0800aeb0 <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
 800aeb0:	b500      	push	{lr}
 800aeb2:	b083      	sub	sp, #12
 800aeb4:	9001      	str	r0, [sp, #4]
 800aeb6:	9100      	str	r1, [sp, #0]

  chThdResumeI(trp, msg);
 800aeb8:	9801      	ldr	r0, [sp, #4]
 800aeba:	9900      	ldr	r1, [sp, #0]
 800aebc:	f7f6 fb00 	bl	80014c0 <chThdResumeI>
}
 800aec0:	b003      	add	sp, #12
 800aec2:	f85d fb04 	ldr.w	pc, [sp], #4
 800aec6:	bf00      	nop
 800aec8:	f3af 8000 	nop.w
 800aecc:	f3af 8000 	nop.w

0800aed0 <spi_lld_serve_rx_interrupt>:
 * @brief   Shared end-of-rx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_rx_interrupt(SPIDriver *spip, uint32_t flags) {
 800aed0:	b500      	push	{lr}
 800aed2:	b083      	sub	sp, #12
 800aed4:	9001      	str	r0, [sp, #4]
 800aed6:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800aed8:	9b00      	ldr	r3, [sp, #0]
 800aeda:	f003 0308 	and.w	r3, r3, #8
 800aede:	2b00      	cmp	r3, #0
 800aee0:	d002      	beq.n	800aee8 <spi_lld_serve_rx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800aee2:	4828      	ldr	r0, [pc, #160]	; (800af84 <spi_lld_serve_rx_interrupt+0xb4>)
 800aee4:	f7ff ffc4 	bl	800ae70 <osalSysHalt>
#else
  (void)flags;
#endif

  /* Stop everything.*/
  dmaStreamDisable(spip->dmatx);
 800aee8:	9b01      	ldr	r3, [sp, #4]
 800aeea:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800aeec:	685b      	ldr	r3, [r3, #4]
 800aeee:	9a01      	ldr	r2, [sp, #4]
 800aef0:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800aef2:	6852      	ldr	r2, [r2, #4]
 800aef4:	6812      	ldr	r2, [r2, #0]
 800aef6:	f022 020f 	bic.w	r2, r2, #15
 800aefa:	601a      	str	r2, [r3, #0]
 800aefc:	9b01      	ldr	r3, [sp, #4]
 800aefe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800af00:	681b      	ldr	r3, [r3, #0]
 800af02:	9a01      	ldr	r2, [sp, #4]
 800af04:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800af06:	7c12      	ldrb	r2, [r2, #16]
 800af08:	210f      	movs	r1, #15
 800af0a:	fa01 f202 	lsl.w	r2, r1, r2
 800af0e:	605a      	str	r2, [r3, #4]
  dmaStreamDisable(spip->dmarx);
 800af10:	9b01      	ldr	r3, [sp, #4]
 800af12:	6a1b      	ldr	r3, [r3, #32]
 800af14:	685b      	ldr	r3, [r3, #4]
 800af16:	9a01      	ldr	r2, [sp, #4]
 800af18:	6a12      	ldr	r2, [r2, #32]
 800af1a:	6852      	ldr	r2, [r2, #4]
 800af1c:	6812      	ldr	r2, [r2, #0]
 800af1e:	f022 020f 	bic.w	r2, r2, #15
 800af22:	601a      	str	r2, [r3, #0]
 800af24:	9b01      	ldr	r3, [sp, #4]
 800af26:	6a1b      	ldr	r3, [r3, #32]
 800af28:	681b      	ldr	r3, [r3, #0]
 800af2a:	9a01      	ldr	r2, [sp, #4]
 800af2c:	6a12      	ldr	r2, [r2, #32]
 800af2e:	7c12      	ldrb	r2, [r2, #16]
 800af30:	210f      	movs	r1, #15
 800af32:	fa01 f202 	lsl.w	r2, r1, r2
 800af36:	605a      	str	r2, [r3, #4]

  /* Portable SPI ISR code defined in the high level driver, note, it is
     a macro.*/
  _spi_isr_code(spip);
 800af38:	9b01      	ldr	r3, [sp, #4]
 800af3a:	685b      	ldr	r3, [r3, #4]
 800af3c:	681b      	ldr	r3, [r3, #0]
 800af3e:	2b00      	cmp	r3, #0
 800af40:	d00f      	beq.n	800af62 <spi_lld_serve_rx_interrupt+0x92>
 800af42:	9b01      	ldr	r3, [sp, #4]
 800af44:	2204      	movs	r2, #4
 800af46:	701a      	strb	r2, [r3, #0]
 800af48:	9b01      	ldr	r3, [sp, #4]
 800af4a:	685b      	ldr	r3, [r3, #4]
 800af4c:	681b      	ldr	r3, [r3, #0]
 800af4e:	9801      	ldr	r0, [sp, #4]
 800af50:	4798      	blx	r3
 800af52:	9b01      	ldr	r3, [sp, #4]
 800af54:	781b      	ldrb	r3, [r3, #0]
 800af56:	2b04      	cmp	r3, #4
 800af58:	d106      	bne.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af5a:	9b01      	ldr	r3, [sp, #4]
 800af5c:	2202      	movs	r2, #2
 800af5e:	701a      	strb	r2, [r3, #0]
 800af60:	e002      	b.n	800af68 <spi_lld_serve_rx_interrupt+0x98>
 800af62:	9b01      	ldr	r3, [sp, #4]
 800af64:	2202      	movs	r2, #2
 800af66:	701a      	strb	r2, [r3, #0]
 800af68:	f7ff ff92 	bl	800ae90 <osalSysLockFromISR>
 800af6c:	9b01      	ldr	r3, [sp, #4]
 800af6e:	3308      	adds	r3, #8
 800af70:	4618      	mov	r0, r3
 800af72:	2100      	movs	r1, #0
 800af74:	f7ff ff9c 	bl	800aeb0 <osalThreadResumeI>
 800af78:	f7ff ff92 	bl	800aea0 <osalSysUnlockFromISR>
}
 800af7c:	b003      	add	sp, #12
 800af7e:	f85d fb04 	ldr.w	pc, [sp], #4
 800af82:	bf00      	nop
 800af84:	08019614 	.word	0x08019614
 800af88:	f3af 8000 	nop.w
 800af8c:	f3af 8000 	nop.w

0800af90 <spi_lld_serve_tx_interrupt>:
 * @brief   Shared end-of-tx service routine.
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void spi_lld_serve_tx_interrupt(SPIDriver *spip, uint32_t flags) {
 800af90:	b500      	push	{lr}
 800af92:	b083      	sub	sp, #12
 800af94:	9001      	str	r0, [sp, #4]
 800af96:	9100      	str	r1, [sp, #0]

  /* DMA errors handling.*/
#if defined(STM32_SPI_DMA_ERROR_HOOK)
  (void)spip;
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 800af98:	9b00      	ldr	r3, [sp, #0]
 800af9a:	f003 0308 	and.w	r3, r3, #8
 800af9e:	2b00      	cmp	r3, #0
 800afa0:	d002      	beq.n	800afa8 <spi_lld_serve_tx_interrupt+0x18>
    STM32_SPI_DMA_ERROR_HOOK(spip);
 800afa2:	4803      	ldr	r0, [pc, #12]	; (800afb0 <spi_lld_serve_tx_interrupt+0x20>)
 800afa4:	f7ff ff64 	bl	800ae70 <osalSysHalt>
  }
#else
  (void)spip;
  (void)flags;
#endif
}
 800afa8:	b003      	add	sp, #12
 800afaa:	f85d fb04 	ldr.w	pc, [sp], #4
 800afae:	bf00      	nop
 800afb0:	08019614 	.word	0x08019614
 800afb4:	f3af 8000 	nop.w
 800afb8:	f3af 8000 	nop.w
 800afbc:	f3af 8000 	nop.w

0800afc0 <spi_lld_init>:
/**
 * @brief   Low level SPI driver initialization.
 *
 * @notapi
 */
void spi_lld_init(void) {
 800afc0:	b508      	push	{r3, lr}
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif

#if STM32_SPI_USE_SPI2
  spiObjectInit(&SPID2);
 800afc2:	4809      	ldr	r0, [pc, #36]	; (800afe8 <spi_lld_init+0x28>)
 800afc4:	f7fb fa4c 	bl	8006460 <spiObjectInit>
  SPID2.spi       = SPI2;
 800afc8:	4b07      	ldr	r3, [pc, #28]	; (800afe8 <spi_lld_init+0x28>)
 800afca:	4a08      	ldr	r2, [pc, #32]	; (800afec <spi_lld_init+0x2c>)
 800afcc:	61da      	str	r2, [r3, #28]
  SPID2.dmarx     = STM32_DMA_STREAM(STM32_SPI_SPI2_RX_DMA_STREAM);
 800afce:	4b06      	ldr	r3, [pc, #24]	; (800afe8 <spi_lld_init+0x28>)
 800afd0:	4a07      	ldr	r2, [pc, #28]	; (800aff0 <spi_lld_init+0x30>)
 800afd2:	621a      	str	r2, [r3, #32]
  SPID2.dmatx     = STM32_DMA_STREAM(STM32_SPI_SPI2_TX_DMA_STREAM);
 800afd4:	4b04      	ldr	r3, [pc, #16]	; (800afe8 <spi_lld_init+0x28>)
 800afd6:	4a07      	ldr	r2, [pc, #28]	; (800aff4 <spi_lld_init+0x34>)
 800afd8:	625a      	str	r2, [r3, #36]	; 0x24
  SPID2.rxdmamode = STM32_DMA_CR_CHSEL(SPI2_RX_DMA_CHANNEL) |
 800afda:	4b03      	ldr	r3, [pc, #12]	; (800afe8 <spi_lld_init+0x28>)
 800afdc:	4a06      	ldr	r2, [pc, #24]	; (800aff8 <spi_lld_init+0x38>)
 800afde:	629a      	str	r2, [r3, #40]	; 0x28
                    STM32_DMA_CR_PL(STM32_SPI_SPI2_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_P2M |
                    STM32_DMA_CR_TCIE |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
  SPID2.txdmamode = STM32_DMA_CR_CHSEL(SPI2_TX_DMA_CHANNEL) |
 800afe0:	4b01      	ldr	r3, [pc, #4]	; (800afe8 <spi_lld_init+0x28>)
 800afe2:	4a06      	ldr	r2, [pc, #24]	; (800affc <spi_lld_init+0x3c>)
 800afe4:	62da      	str	r2, [r3, #44]	; 0x2c
                    STM32_DMA_CR_PL(STM32_SPI_SPI6_DMA_PRIORITY) |
                    STM32_DMA_CR_DIR_M2P |
                    STM32_DMA_CR_DMEIE |
                    STM32_DMA_CR_TEIE;
#endif
}
 800afe6:	bd08      	pop	{r3, pc}
 800afe8:	20001fa8 	.word	0x20001fa8
 800afec:	40003800 	.word	0x40003800
 800aff0:	080194dc 	.word	0x080194dc
 800aff4:	080194f0 	.word	0x080194f0
 800aff8:	0001100a 	.word	0x0001100a
 800affc:	00011018 	.word	0x00011018

0800b000 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver *spip) {
 800b000:	b500      	push	{lr}
 800b002:	b085      	sub	sp, #20
 800b004:	9001      	str	r0, [sp, #4]
  uint32_t ds;

  /* If in stopped state then enables the SPI and DMA clocks.*/
  if (spip->state == SPI_STOP) {
 800b006:	9b01      	ldr	r3, [sp, #4]
 800b008:	781b      	ldrb	r3, [r3, #0]
 800b00a:	2b01      	cmp	r3, #1
 800b00c:	d12d      	bne.n	800b06a <spi_lld_start+0x6a>
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI1(FALSE);
    }
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip) {
 800b00e:	9a01      	ldr	r2, [sp, #4]
 800b010:	4b3c      	ldr	r3, [pc, #240]	; (800b104 <spi_lld_start+0x104>)
 800b012:	429a      	cmp	r2, r3
 800b014:	d11b      	bne.n	800b04e <spi_lld_start+0x4e>
      bool b;
      b = dmaStreamAllocate(spip->dmarx,
 800b016:	9b01      	ldr	r3, [sp, #4]
 800b018:	6a1b      	ldr	r3, [r3, #32]
 800b01a:	4618      	mov	r0, r3
 800b01c:	210a      	movs	r1, #10
 800b01e:	4a3a      	ldr	r2, [pc, #232]	; (800b108 <spi_lld_start+0x108>)
 800b020:	9b01      	ldr	r3, [sp, #4]
 800b022:	f7fc fea5 	bl	8007d70 <dmaStreamAllocate>
 800b026:	4603      	mov	r3, r0
 800b028:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_rx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      b = dmaStreamAllocate(spip->dmatx,
 800b02c:	9b01      	ldr	r3, [sp, #4]
 800b02e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b030:	4618      	mov	r0, r3
 800b032:	210a      	movs	r1, #10
 800b034:	4a35      	ldr	r2, [pc, #212]	; (800b10c <spi_lld_start+0x10c>)
 800b036:	9b01      	ldr	r3, [sp, #4]
 800b038:	f7fc fe9a 	bl	8007d70 <dmaStreamAllocate>
 800b03c:	4603      	mov	r3, r0
 800b03e:	f88d 300f 	strb.w	r3, [sp, #15]
                            STM32_SPI_SPI2_IRQ_PRIORITY,
                            (stm32_dmaisr_t)spi_lld_serve_tx_interrupt,
                            (void *)spip);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableSPI2(FALSE);
 800b042:	4b33      	ldr	r3, [pc, #204]	; (800b110 <spi_lld_start+0x110>)
 800b044:	4a32      	ldr	r2, [pc, #200]	; (800b110 <spi_lld_start+0x110>)
 800b046:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b048:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 800b04c:	659a      	str	r2, [r3, #88]	; 0x58
      rccEnableSPI6(FALSE);
    }
#endif

    /* DMA setup.*/
    dmaStreamSetPeripheral(spip->dmarx, &spip->spi->DR);
 800b04e:	9b01      	ldr	r3, [sp, #4]
 800b050:	6a1b      	ldr	r3, [r3, #32]
 800b052:	685b      	ldr	r3, [r3, #4]
 800b054:	9a01      	ldr	r2, [sp, #4]
 800b056:	69d2      	ldr	r2, [r2, #28]
 800b058:	320c      	adds	r2, #12
 800b05a:	609a      	str	r2, [r3, #8]
    dmaStreamSetPeripheral(spip->dmatx, &spip->spi->DR);
 800b05c:	9b01      	ldr	r3, [sp, #4]
 800b05e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b060:	685b      	ldr	r3, [r3, #4]
 800b062:	9a01      	ldr	r2, [sp, #4]
 800b064:	69d2      	ldr	r2, [r2, #28]
 800b066:	320c      	adds	r2, #12
 800b068:	609a      	str	r2, [r3, #8]
  }

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
 800b06a:	9b01      	ldr	r3, [sp, #4]
 800b06c:	685b      	ldr	r3, [r3, #4]
 800b06e:	899b      	ldrh	r3, [r3, #12]
 800b070:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b074:	9302      	str	r3, [sp, #8]
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
 800b076:	9b02      	ldr	r3, [sp, #8]
 800b078:	2b00      	cmp	r3, #0
 800b07a:	d003      	beq.n	800b084 <spi_lld_start+0x84>
 800b07c:	9b02      	ldr	r3, [sp, #8]
 800b07e:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b082:	d80c      	bhi.n	800b09e <spi_lld_start+0x9e>
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b084:	9b01      	ldr	r3, [sp, #4]
 800b086:	6a9b      	ldr	r3, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b088:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00

  /* Configuration-specific DMA setup.*/
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b08c:	9b01      	ldr	r3, [sp, #4]
 800b08e:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b090:	9b01      	ldr	r3, [sp, #4]
 800b092:	6adb      	ldr	r3, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
 800b094:	f423 6270 	bic.w	r2, r3, #3840	; 0xf00
  ds = spip->config->cr2 & SPI_CR2_DS;
  if (!ds || (ds <= (SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0))) {
    /* Frame width is 8 bits or smaller.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b098:	9b01      	ldr	r3, [sp, #4]
 800b09a:	62da      	str	r2, [r3, #44]	; 0x2c
 800b09c:	e00f      	b.n	800b0be <spi_lld_start+0xbe>
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b09e:	9b01      	ldr	r3, [sp, #4]
 800b0a0:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b0a2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b0a6:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_BYTE | STM32_DMA_CR_MSIZE_BYTE;
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0aa:	9b01      	ldr	r3, [sp, #4]
 800b0ac:	629a      	str	r2, [r3, #40]	; 0x28
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0ae:	9b01      	ldr	r3, [sp, #4]
 800b0b0:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b0b2:	f423 6370 	bic.w	r3, r3, #3840	; 0xf00
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
 800b0b6:	f443 62a0 	orr.w	r2, r3, #1280	; 0x500
  }
  else {
    /* Frame width is larger than 8 bits.*/
    spip->rxdmamode = (spip->rxdmamode & ~STM32_DMA_CR_SIZE_MASK) |
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
    spip->txdmamode = (spip->txdmamode & ~STM32_DMA_CR_SIZE_MASK) |
 800b0ba:	9b01      	ldr	r3, [sp, #4]
 800b0bc:	62da      	str	r2, [r3, #44]	; 0x2c
                      STM32_DMA_CR_PSIZE_HWORD | STM32_DMA_CR_MSIZE_HWORD;
  }

  /* SPI setup and enable.*/
  spip->spi->CR1  = 0;
 800b0be:	9b01      	ldr	r3, [sp, #4]
 800b0c0:	69db      	ldr	r3, [r3, #28]
 800b0c2:	2200      	movs	r2, #0
 800b0c4:	601a      	str	r2, [r3, #0]
  spip->spi->CR1  = spip->config->cr1 | SPI_CR1_MSTR;
 800b0c6:	9b01      	ldr	r3, [sp, #4]
 800b0c8:	69db      	ldr	r3, [r3, #28]
 800b0ca:	9a01      	ldr	r2, [sp, #4]
 800b0cc:	6852      	ldr	r2, [r2, #4]
 800b0ce:	8952      	ldrh	r2, [r2, #10]
 800b0d0:	f042 0204 	orr.w	r2, r2, #4
 800b0d4:	b292      	uxth	r2, r2
 800b0d6:	601a      	str	r2, [r3, #0]
  spip->spi->CR2  = spip->config->cr2 | SPI_CR2_FRXTH | SPI_CR2_SSOE |
 800b0d8:	9b01      	ldr	r3, [sp, #4]
 800b0da:	69da      	ldr	r2, [r3, #28]
 800b0dc:	9b01      	ldr	r3, [sp, #4]
 800b0de:	685b      	ldr	r3, [r3, #4]
 800b0e0:	899b      	ldrh	r3, [r3, #12]
 800b0e2:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 800b0e6:	f043 0307 	orr.w	r3, r3, #7
 800b0ea:	b29b      	uxth	r3, r3
 800b0ec:	6053      	str	r3, [r2, #4]
                    SPI_CR2_RXDMAEN | SPI_CR2_TXDMAEN;
  spip->spi->CR1 |= SPI_CR1_SPE;
 800b0ee:	9b01      	ldr	r3, [sp, #4]
 800b0f0:	69db      	ldr	r3, [r3, #28]
 800b0f2:	9a01      	ldr	r2, [sp, #4]
 800b0f4:	69d2      	ldr	r2, [r2, #28]
 800b0f6:	6812      	ldr	r2, [r2, #0]
 800b0f8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b0fc:	601a      	str	r2, [r3, #0]
}
 800b0fe:	b005      	add	sp, #20
 800b100:	f85d fb04 	ldr.w	pc, [sp], #4
 800b104:	20001fa8 	.word	0x20001fa8
 800b108:	0800aed1 	.word	0x0800aed1
 800b10c:	0800af91 	.word	0x0800af91
 800b110:	40021000 	.word	0x40021000
 800b114:	f3af 8000 	nop.w
 800b118:	f3af 8000 	nop.w
 800b11c:	f3af 8000 	nop.w

0800b120 <spi_lld_stop>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_stop(SPIDriver *spip) {
 800b120:	b500      	push	{lr}
 800b122:	b083      	sub	sp, #12
 800b124:	9001      	str	r0, [sp, #4]

  /* If in ready state then disables the SPI clock.*/
  if (spip->state == SPI_READY) {
 800b126:	9b01      	ldr	r3, [sp, #4]
 800b128:	781b      	ldrb	r3, [r3, #0]
 800b12a:	2b02      	cmp	r3, #2
 800b12c:	d11b      	bne.n	800b166 <spi_lld_stop+0x46>

    /* SPI disable.*/
    spip->spi->CR1 = 0;
 800b12e:	9b01      	ldr	r3, [sp, #4]
 800b130:	69db      	ldr	r3, [r3, #28]
 800b132:	2200      	movs	r2, #0
 800b134:	601a      	str	r2, [r3, #0]
    spip->spi->CR2 = 0;
 800b136:	9b01      	ldr	r3, [sp, #4]
 800b138:	69db      	ldr	r3, [r3, #28]
 800b13a:	2200      	movs	r2, #0
 800b13c:	605a      	str	r2, [r3, #4]
    dmaStreamRelease(spip->dmarx);
 800b13e:	9b01      	ldr	r3, [sp, #4]
 800b140:	6a1b      	ldr	r3, [r3, #32]
 800b142:	4618      	mov	r0, r3
 800b144:	f7fc fe84 	bl	8007e50 <dmaStreamRelease>
    dmaStreamRelease(spip->dmatx);
 800b148:	9b01      	ldr	r3, [sp, #4]
 800b14a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b14c:	4618      	mov	r0, r3
 800b14e:	f7fc fe7f 	bl	8007e50 <dmaStreamRelease>
#if STM32_SPI_USE_SPI1
    if (&SPID1 == spip)
      rccDisableSPI1(FALSE);
#endif
#if STM32_SPI_USE_SPI2
    if (&SPID2 == spip)
 800b152:	9a01      	ldr	r2, [sp, #4]
 800b154:	4b05      	ldr	r3, [pc, #20]	; (800b16c <spi_lld_stop+0x4c>)
 800b156:	429a      	cmp	r2, r3
 800b158:	d105      	bne.n	800b166 <spi_lld_stop+0x46>
      rccDisableSPI2(FALSE);
 800b15a:	4b05      	ldr	r3, [pc, #20]	; (800b170 <spi_lld_stop+0x50>)
 800b15c:	4a04      	ldr	r2, [pc, #16]	; (800b170 <spi_lld_stop+0x50>)
 800b15e:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800b160:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 800b164:	659a      	str	r2, [r3, #88]	; 0x58
#if STM32_SPI_USE_SPI6
    if (&SPID6 == spip)
      rccDisableSPI6(FALSE);
#endif
  }
}
 800b166:	b003      	add	sp, #12
 800b168:	f85d fb04 	ldr.w	pc, [sp], #4
 800b16c:	20001fa8 	.word	0x20001fa8
 800b170:	40021000 	.word	0x40021000
 800b174:	f3af 8000 	nop.w
 800b178:	f3af 8000 	nop.w
 800b17c:	f3af 8000 	nop.w

0800b180 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver *spip) {
 800b180:	b082      	sub	sp, #8
 800b182:	9001      	str	r0, [sp, #4]

  palClearPad(spip->config->ssport, spip->config->sspad);
 800b184:	9b01      	ldr	r3, [sp, #4]
 800b186:	685b      	ldr	r3, [r3, #4]
 800b188:	685b      	ldr	r3, [r3, #4]
 800b18a:	9a01      	ldr	r2, [sp, #4]
 800b18c:	6852      	ldr	r2, [r2, #4]
 800b18e:	8912      	ldrh	r2, [r2, #8]
 800b190:	2101      	movs	r1, #1
 800b192:	fa01 f202 	lsl.w	r2, r1, r2
 800b196:	b292      	uxth	r2, r2
 800b198:	835a      	strh	r2, [r3, #26]
}
 800b19a:	b002      	add	sp, #8
 800b19c:	4770      	bx	lr
 800b19e:	bf00      	nop

0800b1a0 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver *spip) {
 800b1a0:	b082      	sub	sp, #8
 800b1a2:	9001      	str	r0, [sp, #4]

  palSetPad(spip->config->ssport, spip->config->sspad);
 800b1a4:	9b01      	ldr	r3, [sp, #4]
 800b1a6:	685b      	ldr	r3, [r3, #4]
 800b1a8:	685b      	ldr	r3, [r3, #4]
 800b1aa:	9a01      	ldr	r2, [sp, #4]
 800b1ac:	6852      	ldr	r2, [r2, #4]
 800b1ae:	8912      	ldrh	r2, [r2, #8]
 800b1b0:	2101      	movs	r1, #1
 800b1b2:	fa01 f202 	lsl.w	r2, r1, r2
 800b1b6:	b292      	uxth	r2, r2
 800b1b8:	831a      	strh	r2, [r3, #24]
}
 800b1ba:	b002      	add	sp, #8
 800b1bc:	4770      	bx	lr
 800b1be:	bf00      	nop

0800b1c0 <spi_lld_ignore>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] n         number of words to be ignored
 *
 * @notapi
 */
void spi_lld_ignore(SPIDriver *spip, size_t n) {
 800b1c0:	b084      	sub	sp, #16
 800b1c2:	9001      	str	r0, [sp, #4]
 800b1c4:	9100      	str	r1, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b1c6:	9b01      	ldr	r3, [sp, #4]
 800b1c8:	6a1b      	ldr	r3, [r3, #32]
 800b1ca:	685b      	ldr	r3, [r3, #4]
 800b1cc:	4a38      	ldr	r2, [pc, #224]	; (800b2b0 <spi_lld_ignore+0xf0>)
 800b1ce:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b1d0:	9b01      	ldr	r3, [sp, #4]
 800b1d2:	6a1b      	ldr	r3, [r3, #32]
 800b1d4:	685b      	ldr	r3, [r3, #4]
 800b1d6:	9a00      	ldr	r2, [sp, #0]
 800b1d8:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b1da:	9b01      	ldr	r3, [sp, #4]
 800b1dc:	6a1b      	ldr	r3, [r3, #32]
 800b1de:	68db      	ldr	r3, [r3, #12]
 800b1e0:	681b      	ldr	r3, [r3, #0]
 800b1e2:	9303      	str	r3, [sp, #12]
 800b1e4:	9b01      	ldr	r3, [sp, #4]
 800b1e6:	6a1b      	ldr	r3, [r3, #32]
 800b1e8:	7c1b      	ldrb	r3, [r3, #16]
 800b1ea:	220f      	movs	r2, #15
 800b1ec:	fa02 f303 	lsl.w	r3, r2, r3
 800b1f0:	43db      	mvns	r3, r3
 800b1f2:	9a03      	ldr	r2, [sp, #12]
 800b1f4:	4013      	ands	r3, r2
 800b1f6:	9303      	str	r3, [sp, #12]
 800b1f8:	9b01      	ldr	r3, [sp, #4]
 800b1fa:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b1fc:	0c1a      	lsrs	r2, r3, #16
 800b1fe:	9b01      	ldr	r3, [sp, #4]
 800b200:	6a1b      	ldr	r3, [r3, #32]
 800b202:	7c1b      	ldrb	r3, [r3, #16]
 800b204:	fa02 f303 	lsl.w	r3, r2, r3
 800b208:	9a03      	ldr	r2, [sp, #12]
 800b20a:	4313      	orrs	r3, r2
 800b20c:	9303      	str	r3, [sp, #12]
 800b20e:	9b01      	ldr	r3, [sp, #4]
 800b210:	6a1b      	ldr	r3, [r3, #32]
 800b212:	68db      	ldr	r3, [r3, #12]
 800b214:	9a03      	ldr	r2, [sp, #12]
 800b216:	601a      	str	r2, [r3, #0]
 800b218:	9b01      	ldr	r3, [sp, #4]
 800b21a:	6a1b      	ldr	r3, [r3, #32]
 800b21c:	685b      	ldr	r3, [r3, #4]
 800b21e:	9a01      	ldr	r2, [sp, #4]
 800b220:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b222:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b224:	9b01      	ldr	r3, [sp, #4]
 800b226:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b228:	685b      	ldr	r3, [r3, #4]
 800b22a:	4a22      	ldr	r2, [pc, #136]	; (800b2b4 <spi_lld_ignore+0xf4>)
 800b22c:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b22e:	9b01      	ldr	r3, [sp, #4]
 800b230:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b232:	685b      	ldr	r3, [r3, #4]
 800b234:	9a00      	ldr	r2, [sp, #0]
 800b236:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b238:	9b01      	ldr	r3, [sp, #4]
 800b23a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b23c:	68db      	ldr	r3, [r3, #12]
 800b23e:	681b      	ldr	r3, [r3, #0]
 800b240:	9302      	str	r3, [sp, #8]
 800b242:	9b01      	ldr	r3, [sp, #4]
 800b244:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b246:	7c1b      	ldrb	r3, [r3, #16]
 800b248:	220f      	movs	r2, #15
 800b24a:	fa02 f303 	lsl.w	r3, r2, r3
 800b24e:	43db      	mvns	r3, r3
 800b250:	9a02      	ldr	r2, [sp, #8]
 800b252:	4013      	ands	r3, r2
 800b254:	9302      	str	r3, [sp, #8]
 800b256:	9b01      	ldr	r3, [sp, #4]
 800b258:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b25a:	0c1a      	lsrs	r2, r3, #16
 800b25c:	9b01      	ldr	r3, [sp, #4]
 800b25e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b260:	7c1b      	ldrb	r3, [r3, #16]
 800b262:	fa02 f303 	lsl.w	r3, r2, r3
 800b266:	9a02      	ldr	r2, [sp, #8]
 800b268:	4313      	orrs	r3, r2
 800b26a:	9302      	str	r3, [sp, #8]
 800b26c:	9b01      	ldr	r3, [sp, #4]
 800b26e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b270:	68db      	ldr	r3, [r3, #12]
 800b272:	9a02      	ldr	r2, [sp, #8]
 800b274:	601a      	str	r2, [r3, #0]
 800b276:	9b01      	ldr	r3, [sp, #4]
 800b278:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b27a:	685b      	ldr	r3, [r3, #4]
 800b27c:	9a01      	ldr	r2, [sp, #4]
 800b27e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b280:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b282:	9b01      	ldr	r3, [sp, #4]
 800b284:	6a1b      	ldr	r3, [r3, #32]
 800b286:	685b      	ldr	r3, [r3, #4]
 800b288:	9a01      	ldr	r2, [sp, #4]
 800b28a:	6a12      	ldr	r2, [r2, #32]
 800b28c:	6852      	ldr	r2, [r2, #4]
 800b28e:	6812      	ldr	r2, [r2, #0]
 800b290:	f042 0201 	orr.w	r2, r2, #1
 800b294:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b296:	9b01      	ldr	r3, [sp, #4]
 800b298:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b29a:	685b      	ldr	r3, [r3, #4]
 800b29c:	9a01      	ldr	r2, [sp, #4]
 800b29e:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b2a0:	6852      	ldr	r2, [r2, #4]
 800b2a2:	6812      	ldr	r2, [r2, #0]
 800b2a4:	f042 0201 	orr.w	r2, r2, #1
 800b2a8:	601a      	str	r2, [r3, #0]
}
 800b2aa:	b004      	add	sp, #16
 800b2ac:	4770      	bx	lr
 800b2ae:	bf00      	nop
 800b2b0:	200013cc 	.word	0x200013cc
 800b2b4:	08019610 	.word	0x08019610
 800b2b8:	f3af 8000 	nop.w
 800b2bc:	f3af 8000 	nop.w

0800b2c0 <spi_lld_exchange>:
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_exchange(SPIDriver *spip, size_t n,
                      const void *txbuf, void *rxbuf) {
 800b2c0:	b086      	sub	sp, #24
 800b2c2:	9003      	str	r0, [sp, #12]
 800b2c4:	9102      	str	r1, [sp, #8]
 800b2c6:	9201      	str	r2, [sp, #4]
 800b2c8:	9300      	str	r3, [sp, #0]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b2ca:	9b03      	ldr	r3, [sp, #12]
 800b2cc:	6a1b      	ldr	r3, [r3, #32]
 800b2ce:	685b      	ldr	r3, [r3, #4]
 800b2d0:	9a00      	ldr	r2, [sp, #0]
 800b2d2:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b2d4:	9b03      	ldr	r3, [sp, #12]
 800b2d6:	6a1b      	ldr	r3, [r3, #32]
 800b2d8:	685b      	ldr	r3, [r3, #4]
 800b2da:	9a02      	ldr	r2, [sp, #8]
 800b2dc:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b2de:	9b03      	ldr	r3, [sp, #12]
 800b2e0:	6a1b      	ldr	r3, [r3, #32]
 800b2e2:	68db      	ldr	r3, [r3, #12]
 800b2e4:	681b      	ldr	r3, [r3, #0]
 800b2e6:	9305      	str	r3, [sp, #20]
 800b2e8:	9b03      	ldr	r3, [sp, #12]
 800b2ea:	6a1b      	ldr	r3, [r3, #32]
 800b2ec:	7c1b      	ldrb	r3, [r3, #16]
 800b2ee:	220f      	movs	r2, #15
 800b2f0:	fa02 f303 	lsl.w	r3, r2, r3
 800b2f4:	43db      	mvns	r3, r3
 800b2f6:	9a05      	ldr	r2, [sp, #20]
 800b2f8:	4013      	ands	r3, r2
 800b2fa:	9305      	str	r3, [sp, #20]
 800b2fc:	9b03      	ldr	r3, [sp, #12]
 800b2fe:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b300:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b304:	0c1a      	lsrs	r2, r3, #16
 800b306:	9b03      	ldr	r3, [sp, #12]
 800b308:	6a1b      	ldr	r3, [r3, #32]
 800b30a:	7c1b      	ldrb	r3, [r3, #16]
 800b30c:	fa02 f303 	lsl.w	r3, r2, r3
 800b310:	9a05      	ldr	r2, [sp, #20]
 800b312:	4313      	orrs	r3, r2
 800b314:	9305      	str	r3, [sp, #20]
 800b316:	9b03      	ldr	r3, [sp, #12]
 800b318:	6a1b      	ldr	r3, [r3, #32]
 800b31a:	68db      	ldr	r3, [r3, #12]
 800b31c:	9a05      	ldr	r2, [sp, #20]
 800b31e:	601a      	str	r2, [r3, #0]
 800b320:	9b03      	ldr	r3, [sp, #12]
 800b322:	6a1b      	ldr	r3, [r3, #32]
 800b324:	685b      	ldr	r3, [r3, #4]
 800b326:	9a03      	ldr	r2, [sp, #12]
 800b328:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b32a:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b32e:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b330:	9b03      	ldr	r3, [sp, #12]
 800b332:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b334:	685b      	ldr	r3, [r3, #4]
 800b336:	9a01      	ldr	r2, [sp, #4]
 800b338:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b33a:	9b03      	ldr	r3, [sp, #12]
 800b33c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b33e:	685b      	ldr	r3, [r3, #4]
 800b340:	9a02      	ldr	r2, [sp, #8]
 800b342:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b344:	9b03      	ldr	r3, [sp, #12]
 800b346:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b348:	68db      	ldr	r3, [r3, #12]
 800b34a:	681b      	ldr	r3, [r3, #0]
 800b34c:	9304      	str	r3, [sp, #16]
 800b34e:	9b03      	ldr	r3, [sp, #12]
 800b350:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b352:	7c1b      	ldrb	r3, [r3, #16]
 800b354:	220f      	movs	r2, #15
 800b356:	fa02 f303 	lsl.w	r3, r2, r3
 800b35a:	43db      	mvns	r3, r3
 800b35c:	9a04      	ldr	r2, [sp, #16]
 800b35e:	4013      	ands	r3, r2
 800b360:	9304      	str	r3, [sp, #16]
 800b362:	9b03      	ldr	r3, [sp, #12]
 800b364:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b366:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b36a:	0c1a      	lsrs	r2, r3, #16
 800b36c:	9b03      	ldr	r3, [sp, #12]
 800b36e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b370:	7c1b      	ldrb	r3, [r3, #16]
 800b372:	fa02 f303 	lsl.w	r3, r2, r3
 800b376:	9a04      	ldr	r2, [sp, #16]
 800b378:	4313      	orrs	r3, r2
 800b37a:	9304      	str	r3, [sp, #16]
 800b37c:	9b03      	ldr	r3, [sp, #12]
 800b37e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b380:	68db      	ldr	r3, [r3, #12]
 800b382:	9a04      	ldr	r2, [sp, #16]
 800b384:	601a      	str	r2, [r3, #0]
 800b386:	9b03      	ldr	r3, [sp, #12]
 800b388:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b38a:	685b      	ldr	r3, [r3, #4]
 800b38c:	9a03      	ldr	r2, [sp, #12]
 800b38e:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b390:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b394:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b396:	9b03      	ldr	r3, [sp, #12]
 800b398:	6a1b      	ldr	r3, [r3, #32]
 800b39a:	685b      	ldr	r3, [r3, #4]
 800b39c:	9a03      	ldr	r2, [sp, #12]
 800b39e:	6a12      	ldr	r2, [r2, #32]
 800b3a0:	6852      	ldr	r2, [r2, #4]
 800b3a2:	6812      	ldr	r2, [r2, #0]
 800b3a4:	f042 0201 	orr.w	r2, r2, #1
 800b3a8:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b3aa:	9b03      	ldr	r3, [sp, #12]
 800b3ac:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b3ae:	685b      	ldr	r3, [r3, #4]
 800b3b0:	9a03      	ldr	r2, [sp, #12]
 800b3b2:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b3b4:	6852      	ldr	r2, [r2, #4]
 800b3b6:	6812      	ldr	r2, [r2, #0]
 800b3b8:	f042 0201 	orr.w	r2, r2, #1
 800b3bc:	601a      	str	r2, [r3, #0]
}
 800b3be:	b006      	add	sp, #24
 800b3c0:	4770      	bx	lr
 800b3c2:	bf00      	nop
 800b3c4:	f3af 8000 	nop.w
 800b3c8:	f3af 8000 	nop.w
 800b3cc:	f3af 8000 	nop.w

0800b3d0 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver *spip, size_t n, const void *txbuf) {
 800b3d0:	b086      	sub	sp, #24
 800b3d2:	9003      	str	r0, [sp, #12]
 800b3d4:	9102      	str	r1, [sp, #8]
 800b3d6:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, &dummyrx);
 800b3d8:	9b03      	ldr	r3, [sp, #12]
 800b3da:	6a1b      	ldr	r3, [r3, #32]
 800b3dc:	685b      	ldr	r3, [r3, #4]
 800b3de:	4a3a      	ldr	r2, [pc, #232]	; (800b4c8 <spi_lld_send+0xf8>)
 800b3e0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b3e2:	9b03      	ldr	r3, [sp, #12]
 800b3e4:	6a1b      	ldr	r3, [r3, #32]
 800b3e6:	685b      	ldr	r3, [r3, #4]
 800b3e8:	9a02      	ldr	r2, [sp, #8]
 800b3ea:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode);
 800b3ec:	9b03      	ldr	r3, [sp, #12]
 800b3ee:	6a1b      	ldr	r3, [r3, #32]
 800b3f0:	68db      	ldr	r3, [r3, #12]
 800b3f2:	681b      	ldr	r3, [r3, #0]
 800b3f4:	9305      	str	r3, [sp, #20]
 800b3f6:	9b03      	ldr	r3, [sp, #12]
 800b3f8:	6a1b      	ldr	r3, [r3, #32]
 800b3fa:	7c1b      	ldrb	r3, [r3, #16]
 800b3fc:	220f      	movs	r2, #15
 800b3fe:	fa02 f303 	lsl.w	r3, r2, r3
 800b402:	43db      	mvns	r3, r3
 800b404:	9a05      	ldr	r2, [sp, #20]
 800b406:	4013      	ands	r3, r2
 800b408:	9305      	str	r3, [sp, #20]
 800b40a:	9b03      	ldr	r3, [sp, #12]
 800b40c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b40e:	0c1a      	lsrs	r2, r3, #16
 800b410:	9b03      	ldr	r3, [sp, #12]
 800b412:	6a1b      	ldr	r3, [r3, #32]
 800b414:	7c1b      	ldrb	r3, [r3, #16]
 800b416:	fa02 f303 	lsl.w	r3, r2, r3
 800b41a:	9a05      	ldr	r2, [sp, #20]
 800b41c:	4313      	orrs	r3, r2
 800b41e:	9305      	str	r3, [sp, #20]
 800b420:	9b03      	ldr	r3, [sp, #12]
 800b422:	6a1b      	ldr	r3, [r3, #32]
 800b424:	68db      	ldr	r3, [r3, #12]
 800b426:	9a05      	ldr	r2, [sp, #20]
 800b428:	601a      	str	r2, [r3, #0]
 800b42a:	9b03      	ldr	r3, [sp, #12]
 800b42c:	6a1b      	ldr	r3, [r3, #32]
 800b42e:	685b      	ldr	r3, [r3, #4]
 800b430:	9a03      	ldr	r2, [sp, #12]
 800b432:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b434:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, txbuf);
 800b436:	9b03      	ldr	r3, [sp, #12]
 800b438:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b43a:	685b      	ldr	r3, [r3, #4]
 800b43c:	9a01      	ldr	r2, [sp, #4]
 800b43e:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b440:	9b03      	ldr	r3, [sp, #12]
 800b442:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b444:	685b      	ldr	r3, [r3, #4]
 800b446:	9a02      	ldr	r2, [sp, #8]
 800b448:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode | STM32_DMA_CR_MINC);
 800b44a:	9b03      	ldr	r3, [sp, #12]
 800b44c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b44e:	68db      	ldr	r3, [r3, #12]
 800b450:	681b      	ldr	r3, [r3, #0]
 800b452:	9304      	str	r3, [sp, #16]
 800b454:	9b03      	ldr	r3, [sp, #12]
 800b456:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b458:	7c1b      	ldrb	r3, [r3, #16]
 800b45a:	220f      	movs	r2, #15
 800b45c:	fa02 f303 	lsl.w	r3, r2, r3
 800b460:	43db      	mvns	r3, r3
 800b462:	9a04      	ldr	r2, [sp, #16]
 800b464:	4013      	ands	r3, r2
 800b466:	9304      	str	r3, [sp, #16]
 800b468:	9b03      	ldr	r3, [sp, #12]
 800b46a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b46c:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b470:	0c1a      	lsrs	r2, r3, #16
 800b472:	9b03      	ldr	r3, [sp, #12]
 800b474:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b476:	7c1b      	ldrb	r3, [r3, #16]
 800b478:	fa02 f303 	lsl.w	r3, r2, r3
 800b47c:	9a04      	ldr	r2, [sp, #16]
 800b47e:	4313      	orrs	r3, r2
 800b480:	9304      	str	r3, [sp, #16]
 800b482:	9b03      	ldr	r3, [sp, #12]
 800b484:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b486:	68db      	ldr	r3, [r3, #12]
 800b488:	9a04      	ldr	r2, [sp, #16]
 800b48a:	601a      	str	r2, [r3, #0]
 800b48c:	9b03      	ldr	r3, [sp, #12]
 800b48e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b490:	685b      	ldr	r3, [r3, #4]
 800b492:	9a03      	ldr	r2, [sp, #12]
 800b494:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b496:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b49a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b49c:	9b03      	ldr	r3, [sp, #12]
 800b49e:	6a1b      	ldr	r3, [r3, #32]
 800b4a0:	685b      	ldr	r3, [r3, #4]
 800b4a2:	9a03      	ldr	r2, [sp, #12]
 800b4a4:	6a12      	ldr	r2, [r2, #32]
 800b4a6:	6852      	ldr	r2, [r2, #4]
 800b4a8:	6812      	ldr	r2, [r2, #0]
 800b4aa:	f042 0201 	orr.w	r2, r2, #1
 800b4ae:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b4b0:	9b03      	ldr	r3, [sp, #12]
 800b4b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b4b4:	685b      	ldr	r3, [r3, #4]
 800b4b6:	9a03      	ldr	r2, [sp, #12]
 800b4b8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b4ba:	6852      	ldr	r2, [r2, #4]
 800b4bc:	6812      	ldr	r2, [r2, #0]
 800b4be:	f042 0201 	orr.w	r2, r2, #1
 800b4c2:	601a      	str	r2, [r3, #0]
}
 800b4c4:	b006      	add	sp, #24
 800b4c6:	4770      	bx	lr
 800b4c8:	200013cc 	.word	0x200013cc
 800b4cc:	f3af 8000 	nop.w

0800b4d0 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver *spip, size_t n, void *rxbuf) {
 800b4d0:	b086      	sub	sp, #24
 800b4d2:	9003      	str	r0, [sp, #12]
 800b4d4:	9102      	str	r1, [sp, #8]
 800b4d6:	9201      	str	r2, [sp, #4]

  dmaStreamSetMemory0(spip->dmarx, rxbuf);
 800b4d8:	9b03      	ldr	r3, [sp, #12]
 800b4da:	6a1b      	ldr	r3, [r3, #32]
 800b4dc:	685b      	ldr	r3, [r3, #4]
 800b4de:	9a01      	ldr	r2, [sp, #4]
 800b4e0:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmarx, n);
 800b4e2:	9b03      	ldr	r3, [sp, #12]
 800b4e4:	6a1b      	ldr	r3, [r3, #32]
 800b4e6:	685b      	ldr	r3, [r3, #4]
 800b4e8:	9a02      	ldr	r2, [sp, #8]
 800b4ea:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmarx, spip->rxdmamode | STM32_DMA_CR_MINC);
 800b4ec:	9b03      	ldr	r3, [sp, #12]
 800b4ee:	6a1b      	ldr	r3, [r3, #32]
 800b4f0:	68db      	ldr	r3, [r3, #12]
 800b4f2:	681b      	ldr	r3, [r3, #0]
 800b4f4:	9305      	str	r3, [sp, #20]
 800b4f6:	9b03      	ldr	r3, [sp, #12]
 800b4f8:	6a1b      	ldr	r3, [r3, #32]
 800b4fa:	7c1b      	ldrb	r3, [r3, #16]
 800b4fc:	220f      	movs	r2, #15
 800b4fe:	fa02 f303 	lsl.w	r3, r2, r3
 800b502:	43db      	mvns	r3, r3
 800b504:	9a05      	ldr	r2, [sp, #20]
 800b506:	4013      	ands	r3, r2
 800b508:	9305      	str	r3, [sp, #20]
 800b50a:	9b03      	ldr	r3, [sp, #12]
 800b50c:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 800b50e:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b512:	0c1a      	lsrs	r2, r3, #16
 800b514:	9b03      	ldr	r3, [sp, #12]
 800b516:	6a1b      	ldr	r3, [r3, #32]
 800b518:	7c1b      	ldrb	r3, [r3, #16]
 800b51a:	fa02 f303 	lsl.w	r3, r2, r3
 800b51e:	9a05      	ldr	r2, [sp, #20]
 800b520:	4313      	orrs	r3, r2
 800b522:	9305      	str	r3, [sp, #20]
 800b524:	9b03      	ldr	r3, [sp, #12]
 800b526:	6a1b      	ldr	r3, [r3, #32]
 800b528:	68db      	ldr	r3, [r3, #12]
 800b52a:	9a05      	ldr	r2, [sp, #20]
 800b52c:	601a      	str	r2, [r3, #0]
 800b52e:	9b03      	ldr	r3, [sp, #12]
 800b530:	6a1b      	ldr	r3, [r3, #32]
 800b532:	685b      	ldr	r3, [r3, #4]
 800b534:	9a03      	ldr	r2, [sp, #12]
 800b536:	6a92      	ldr	r2, [r2, #40]	; 0x28
 800b538:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b53c:	601a      	str	r2, [r3, #0]

  dmaStreamSetMemory0(spip->dmatx, &dummytx);
 800b53e:	9b03      	ldr	r3, [sp, #12]
 800b540:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b542:	685b      	ldr	r3, [r3, #4]
 800b544:	4a20      	ldr	r2, [pc, #128]	; (800b5c8 <spi_lld_receive+0xf8>)
 800b546:	60da      	str	r2, [r3, #12]
  dmaStreamSetTransactionSize(spip->dmatx, n);
 800b548:	9b03      	ldr	r3, [sp, #12]
 800b54a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b54c:	685b      	ldr	r3, [r3, #4]
 800b54e:	9a02      	ldr	r2, [sp, #8]
 800b550:	605a      	str	r2, [r3, #4]
  dmaStreamSetMode(spip->dmatx, spip->txdmamode);
 800b552:	9b03      	ldr	r3, [sp, #12]
 800b554:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b556:	68db      	ldr	r3, [r3, #12]
 800b558:	681b      	ldr	r3, [r3, #0]
 800b55a:	9304      	str	r3, [sp, #16]
 800b55c:	9b03      	ldr	r3, [sp, #12]
 800b55e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b560:	7c1b      	ldrb	r3, [r3, #16]
 800b562:	220f      	movs	r2, #15
 800b564:	fa02 f303 	lsl.w	r3, r2, r3
 800b568:	43db      	mvns	r3, r3
 800b56a:	9a04      	ldr	r2, [sp, #16]
 800b56c:	4013      	ands	r3, r2
 800b56e:	9304      	str	r3, [sp, #16]
 800b570:	9b03      	ldr	r3, [sp, #12]
 800b572:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 800b574:	0c1a      	lsrs	r2, r3, #16
 800b576:	9b03      	ldr	r3, [sp, #12]
 800b578:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b57a:	7c1b      	ldrb	r3, [r3, #16]
 800b57c:	fa02 f303 	lsl.w	r3, r2, r3
 800b580:	9a04      	ldr	r2, [sp, #16]
 800b582:	4313      	orrs	r3, r2
 800b584:	9304      	str	r3, [sp, #16]
 800b586:	9b03      	ldr	r3, [sp, #12]
 800b588:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b58a:	68db      	ldr	r3, [r3, #12]
 800b58c:	9a04      	ldr	r2, [sp, #16]
 800b58e:	601a      	str	r2, [r3, #0]
 800b590:	9b03      	ldr	r3, [sp, #12]
 800b592:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b594:	685b      	ldr	r3, [r3, #4]
 800b596:	9a03      	ldr	r2, [sp, #12]
 800b598:	6ad2      	ldr	r2, [r2, #44]	; 0x2c
 800b59a:	601a      	str	r2, [r3, #0]

  dmaStreamEnable(spip->dmarx);
 800b59c:	9b03      	ldr	r3, [sp, #12]
 800b59e:	6a1b      	ldr	r3, [r3, #32]
 800b5a0:	685b      	ldr	r3, [r3, #4]
 800b5a2:	9a03      	ldr	r2, [sp, #12]
 800b5a4:	6a12      	ldr	r2, [r2, #32]
 800b5a6:	6852      	ldr	r2, [r2, #4]
 800b5a8:	6812      	ldr	r2, [r2, #0]
 800b5aa:	f042 0201 	orr.w	r2, r2, #1
 800b5ae:	601a      	str	r2, [r3, #0]
  dmaStreamEnable(spip->dmatx);
 800b5b0:	9b03      	ldr	r3, [sp, #12]
 800b5b2:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800b5b4:	685b      	ldr	r3, [r3, #4]
 800b5b6:	9a03      	ldr	r2, [sp, #12]
 800b5b8:	6a52      	ldr	r2, [r2, #36]	; 0x24
 800b5ba:	6852      	ldr	r2, [r2, #4]
 800b5bc:	6812      	ldr	r2, [r2, #0]
 800b5be:	f042 0201 	orr.w	r2, r2, #1
 800b5c2:	601a      	str	r2, [r3, #0]
}
 800b5c4:	b006      	add	sp, #24
 800b5c6:	4770      	bx	lr
 800b5c8:	08019610 	.word	0x08019610
 800b5cc:	f3af 8000 	nop.w

0800b5d0 <spi_lld_polled_exchange>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */
uint16_t spi_lld_polled_exchange(SPIDriver *spip, uint16_t frame) {
 800b5d0:	b084      	sub	sp, #16
 800b5d2:	9001      	str	r0, [sp, #4]
 800b5d4:	460b      	mov	r3, r1
 800b5d6:	f8ad 3002 	strh.w	r3, [sp, #2]
  /*
   * Data register must be accessed with the appropriate data size.
   * Byte size access (uint8_t *) for transactions that are <= 8-bit.
   * Halfword size access (uint16_t) for transactions that are <= 8-bit.
   */
  if ((spip->config->cr2 & SPI_CR2_DS) <= (SPI_CR2_DS_2 |
 800b5da:	9b01      	ldr	r3, [sp, #4]
 800b5dc:	685b      	ldr	r3, [r3, #4]
 800b5de:	899b      	ldrh	r3, [r3, #12]
 800b5e0:	f403 6370 	and.w	r3, r3, #3840	; 0xf00
 800b5e4:	f5b3 6fe0 	cmp.w	r3, #1792	; 0x700
 800b5e8:	d814      	bhi.n	800b614 <spi_lld_polled_exchange+0x44>
                                           SPI_CR2_DS_1 |
                                           SPI_CR2_DS_0)) {
    volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b5ea:	9b01      	ldr	r3, [sp, #4]
 800b5ec:	69db      	ldr	r3, [r3, #28]
 800b5ee:	330c      	adds	r3, #12
 800b5f0:	9303      	str	r3, [sp, #12]
    *spidr = (uint8_t)frame;
 800b5f2:	f8bd 3002 	ldrh.w	r3, [sp, #2]
 800b5f6:	b2da      	uxtb	r2, r3
 800b5f8:	9b03      	ldr	r3, [sp, #12]
 800b5fa:	701a      	strb	r2, [r3, #0]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b5fc:	bf00      	nop
 800b5fe:	9b01      	ldr	r3, [sp, #4]
 800b600:	69db      	ldr	r3, [r3, #28]
 800b602:	689b      	ldr	r3, [r3, #8]
 800b604:	f003 0301 	and.w	r3, r3, #1
 800b608:	2b00      	cmp	r3, #0
 800b60a:	d0f8      	beq.n	800b5fe <spi_lld_polled_exchange+0x2e>
      ;
    return (uint16_t)*spidr;
 800b60c:	9b03      	ldr	r3, [sp, #12]
 800b60e:	781b      	ldrb	r3, [r3, #0]
 800b610:	b2db      	uxtb	r3, r3
 800b612:	e010      	b.n	800b636 <spi_lld_polled_exchange+0x66>
  }
  else {
    spip->spi->DR = frame;
 800b614:	9b01      	ldr	r3, [sp, #4]
 800b616:	69db      	ldr	r3, [r3, #28]
 800b618:	f8bd 2002 	ldrh.w	r2, [sp, #2]
 800b61c:	60da      	str	r2, [r3, #12]
    while ((spip->spi->SR & SPI_SR_RXNE) == 0)
 800b61e:	bf00      	nop
 800b620:	9b01      	ldr	r3, [sp, #4]
 800b622:	69db      	ldr	r3, [r3, #28]
 800b624:	689b      	ldr	r3, [r3, #8]
 800b626:	f003 0301 	and.w	r3, r3, #1
 800b62a:	2b00      	cmp	r3, #0
 800b62c:	d0f8      	beq.n	800b620 <spi_lld_polled_exchange+0x50>
      ;
    return spip->spi->DR;
 800b62e:	9b01      	ldr	r3, [sp, #4]
 800b630:	69db      	ldr	r3, [r3, #28]
 800b632:	68db      	ldr	r3, [r3, #12]
 800b634:	b29b      	uxth	r3, r3
  }
}
 800b636:	4618      	mov	r0, r3
 800b638:	b004      	add	sp, #16
 800b63a:	4770      	bx	lr
 800b63c:	f3af 8000 	nop.w

0800b640 <spi_lld_polled_tx>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] frame     the data frame to send over the SPI bus
 * @return              The received data frame from the SPI bus.
 */

int spi_lld_polled_tx(SPIDriver *spip, uint8_t val) {
 800b640:	b084      	sub	sp, #16
 800b642:	9001      	str	r0, [sp, #4]
 800b644:	460b      	mov	r3, r1
 800b646:	f88d 3003 	strb.w	r3, [sp, #3]

  /* check TXE flag */
  while ((spip->spi->SR & SPI_SR_TXE) != SPI_SR_TXE);
 800b64a:	bf00      	nop
 800b64c:	9b01      	ldr	r3, [sp, #4]
 800b64e:	69db      	ldr	r3, [r3, #28]
 800b650:	689b      	ldr	r3, [r3, #8]
 800b652:	f003 0302 	and.w	r3, r3, #2
 800b656:	2b00      	cmp	r3, #0
 800b658:	d0f8      	beq.n	800b64c <spi_lld_polled_tx+0xc>

  /* Write the data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b65a:	9b01      	ldr	r3, [sp, #4]
 800b65c:	69db      	ldr	r3, [r3, #28]
 800b65e:	330c      	adds	r3, #12
 800b660:	9303      	str	r3, [sp, #12]
  *spidr = val;
 800b662:	9b03      	ldr	r3, [sp, #12]
 800b664:	f89d 2003 	ldrb.w	r2, [sp, #3]
 800b668:	701a      	strb	r2, [r3, #0]

  /* Check to see that the Transmitter is empty */
  while (spip->spi->SR & SPI_SR_FTLVL);
 800b66a:	bf00      	nop
 800b66c:	9b01      	ldr	r3, [sp, #4]
 800b66e:	69db      	ldr	r3, [r3, #28]
 800b670:	689b      	ldr	r3, [r3, #8]
 800b672:	f403 53c0 	and.w	r3, r3, #6144	; 0x1800
 800b676:	2b00      	cmp	r3, #0
 800b678:	d1f8      	bne.n	800b66c <spi_lld_polled_tx+0x2c>
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b67a:	bf00      	nop
 800b67c:	9b01      	ldr	r3, [sp, #4]
 800b67e:	69db      	ldr	r3, [r3, #28]
 800b680:	689b      	ldr	r3, [r3, #8]
 800b682:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b686:	2b00      	cmp	r3, #0
 800b688:	d1f8      	bne.n	800b67c <spi_lld_polled_tx+0x3c>

  return (0);
 800b68a:	2300      	movs	r3, #0
}
 800b68c:	4618      	mov	r0, r3
 800b68e:	b004      	add	sp, #16
 800b690:	4770      	bx	lr
 800b692:	bf00      	nop
 800b694:	f3af 8000 	nop.w
 800b698:	f3af 8000 	nop.w
 800b69c:	f3af 8000 	nop.w

0800b6a0 <spi_lld_polled_rx>:

int spi_lld_polled_rx(SPIDriver *spip) {
 800b6a0:	b500      	push	{lr}
 800b6a2:	b085      	sub	sp, #20
 800b6a4:	9001      	str	r0, [sp, #4]
  /* In master RX mode the clock is automaticaly generated on the SPI enable.
  So to guarantee the clock generation for only one data, the clock must be
  disabled after the first bit and before the latest bit */
  /* Interrupts should be disabled during this operation */

  chSysLock();
 800b6a6:	f7ff fbc3 	bl	800ae30 <chSysLock>
  spip->spi->CR1 |= SPI_CR1_SPE;   // Turn on the SPI 
 800b6aa:	9b01      	ldr	r3, [sp, #4]
 800b6ac:	69db      	ldr	r3, [r3, #28]
 800b6ae:	9a01      	ldr	r2, [sp, #4]
 800b6b0:	69d2      	ldr	r2, [r2, #28]
 800b6b2:	6812      	ldr	r2, [r2, #0]
 800b6b4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 800b6b8:	601a      	str	r2, [r3, #0]
  __asm("dsb\n");
 800b6ba:	f3bf 8f4f 	dsb	sy
  __asm("dsb\n");
 800b6be:	f3bf 8f4f 	dsb	sy
  spip->spi->CR1 &= ~SPI_CR1_SPE;   // Turn off the SPI
 800b6c2:	9b01      	ldr	r3, [sp, #4]
 800b6c4:	69db      	ldr	r3, [r3, #28]
 800b6c6:	9a01      	ldr	r2, [sp, #4]
 800b6c8:	69d2      	ldr	r2, [r2, #28]
 800b6ca:	6812      	ldr	r2, [r2, #0]
 800b6cc:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 800b6d0:	601a      	str	r2, [r3, #0]
  chSysUnlock();
 800b6d2:	f7ff fbb5 	bl	800ae40 <chSysUnlock>
  
  while ((spip->spi->SR & SPI_SR_RXNE) != SPI_SR_RXNE);
 800b6d6:	bf00      	nop
 800b6d8:	9b01      	ldr	r3, [sp, #4]
 800b6da:	69db      	ldr	r3, [r3, #28]
 800b6dc:	689b      	ldr	r3, [r3, #8]
 800b6de:	f003 0301 	and.w	r3, r3, #1
 800b6e2:	2b00      	cmp	r3, #0
 800b6e4:	d0f8      	beq.n	800b6d8 <spi_lld_polled_rx+0x38>
  /* read the received data */
  volatile uint8_t *spidr = (volatile uint8_t *)&spip->spi->DR;
 800b6e6:	9b01      	ldr	r3, [sp, #4]
 800b6e8:	69db      	ldr	r3, [r3, #28]
 800b6ea:	330c      	adds	r3, #12
 800b6ec:	9303      	str	r3, [sp, #12]
  val = *spidr;
 800b6ee:	9b03      	ldr	r3, [sp, #12]
 800b6f0:	781b      	ldrb	r3, [r3, #0]
 800b6f2:	f88d 300b 	strb.w	r3, [sp, #11]
  while ((spip->spi->SR & SPI_SR_BSY) == SPI_SR_BSY);
 800b6f6:	bf00      	nop
 800b6f8:	9b01      	ldr	r3, [sp, #4]
 800b6fa:	69db      	ldr	r3, [r3, #28]
 800b6fc:	689b      	ldr	r3, [r3, #8]
 800b6fe:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b702:	2b00      	cmp	r3, #0
 800b704:	d1f8      	bne.n	800b6f8 <spi_lld_polled_rx+0x58>
  return (val);
 800b706:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800b70a:	4618      	mov	r0, r3
 800b70c:	b005      	add	sp, #20
 800b70e:	f85d fb04 	ldr.w	pc, [sp], #4
 800b712:	bf00      	nop
 800b714:	f3af 8000 	nop.w
 800b718:	f3af 8000 	nop.w
 800b71c:	f3af 8000 	nop.w

0800b720 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800b720:	b082      	sub	sp, #8
 800b722:	2320      	movs	r3, #32
 800b724:	9301      	str	r3, [sp, #4]
 800b726:	9b01      	ldr	r3, [sp, #4]
 800b728:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b72c:	b002      	add	sp, #8
 800b72e:	4770      	bx	lr

0800b730 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800b730:	b082      	sub	sp, #8
 800b732:	2300      	movs	r3, #0
 800b734:	9301      	str	r3, [sp, #4]
 800b736:	9b01      	ldr	r3, [sp, #4]
 800b738:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800b73c:	b002      	add	sp, #8
 800b73e:	4770      	bx	lr

0800b740 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800b740:	b508      	push	{r3, lr}

  port_lock();
 800b742:	f7ff ffed 	bl	800b720 <port_lock>
}
 800b746:	bd08      	pop	{r3, pc}
 800b748:	f3af 8000 	nop.w
 800b74c:	f3af 8000 	nop.w

0800b750 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800b750:	b508      	push	{r3, lr}

  port_unlock();
 800b752:	f7ff ffed 	bl	800b730 <port_unlock>
}
 800b756:	bd08      	pop	{r3, pc}
 800b758:	f3af 8000 	nop.w
 800b75c:	f3af 8000 	nop.w

0800b760 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800b760:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800b762:	f7ff ffed 	bl	800b740 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800b766:	bd08      	pop	{r3, pc}
 800b768:	f3af 8000 	nop.w
 800b76c:	f3af 8000 	nop.w

0800b770 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800b770:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800b772:	f7ff ffed 	bl	800b750 <port_unlock_from_isr>
}
 800b776:	bd08      	pop	{r3, pc}
 800b778:	f3af 8000 	nop.w
 800b77c:	f3af 8000 	nop.w

0800b780 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800b780:	b082      	sub	sp, #8
 800b782:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800b784:	9b01      	ldr	r3, [sp, #4]
 800b786:	695a      	ldr	r2, [r3, #20]
 800b788:	9b01      	ldr	r3, [sp, #4]
 800b78a:	699b      	ldr	r3, [r3, #24]
 800b78c:	429a      	cmp	r2, r3
 800b78e:	d105      	bne.n	800b79c <chOQIsEmptyI+0x1c>
 800b790:	9b01      	ldr	r3, [sp, #4]
 800b792:	689b      	ldr	r3, [r3, #8]
 800b794:	2b00      	cmp	r3, #0
 800b796:	d001      	beq.n	800b79c <chOQIsEmptyI+0x1c>
 800b798:	2301      	movs	r3, #1
 800b79a:	e000      	b.n	800b79e <chOQIsEmptyI+0x1e>
 800b79c:	2300      	movs	r3, #0
 800b79e:	f003 0301 	and.w	r3, r3, #1
 800b7a2:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800b7a4:	4618      	mov	r0, r3
 800b7a6:	b002      	add	sp, #8
 800b7a8:	4770      	bx	lr
 800b7aa:	bf00      	nop
 800b7ac:	f3af 8000 	nop.w

0800b7b0 <osalSysLockFromISR>:
 * @brief   Enters a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {
 800b7b0:	b508      	push	{r3, lr}

  chSysLockFromISR();
 800b7b2:	f7ff ffd5 	bl	800b760 <chSysLockFromISR>
}
 800b7b6:	bd08      	pop	{r3, pc}
 800b7b8:	f3af 8000 	nop.w
 800b7bc:	f3af 8000 	nop.w

0800b7c0 <osalSysUnlockFromISR>:
 * @brief   Leaves a critical zone from ISR context.
 * @note    This function cannot be used for reentrant critical zones.
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {
 800b7c0:	b508      	push	{r3, lr}

  chSysUnlockFromISR();
 800b7c2:	f7ff ffd5 	bl	800b770 <chSysUnlockFromISR>
}
 800b7c6:	bd08      	pop	{r3, pc}
 800b7c8:	f3af 8000 	nop.w
 800b7cc:	f3af 8000 	nop.w

0800b7d0 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
 800b7d0:	b500      	push	{lr}
 800b7d2:	b083      	sub	sp, #12
 800b7d4:	9001      	str	r0, [sp, #4]
 800b7d6:	9100      	str	r1, [sp, #0]

  chEvtBroadcastFlagsI(esp, flags);
 800b7d8:	9801      	ldr	r0, [sp, #4]
 800b7da:	9900      	ldr	r1, [sp, #0]
 800b7dc:	f7f6 ff50 	bl	8002680 <chEvtBroadcastFlagsI>
}
 800b7e0:	b003      	add	sp, #12
 800b7e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800b7e6:	bf00      	nop
 800b7e8:	f3af 8000 	nop.w
 800b7ec:	f3af 8000 	nop.w

0800b7f0 <usart_init>:
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
 800b7f0:	b084      	sub	sp, #16
 800b7f2:	9001      	str	r0, [sp, #4]
 800b7f4:	9100      	str	r1, [sp, #0]
  USART_TypeDef *u = sdp->usart;
 800b7f6:	9b01      	ldr	r3, [sp, #4]
 800b7f8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b7fa:	9303      	str	r3, [sp, #12]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 800b7fc:	9b01      	ldr	r3, [sp, #4]
 800b7fe:	6f9a      	ldr	r2, [r3, #120]	; 0x78
 800b800:	9b00      	ldr	r3, [sp, #0]
 800b802:	681b      	ldr	r3, [r3, #0]
 800b804:	fbb2 f2f3 	udiv	r2, r2, r3
 800b808:	9b03      	ldr	r3, [sp, #12]
 800b80a:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800b80c:	9b00      	ldr	r3, [sp, #0]
 800b80e:	689b      	ldr	r3, [r3, #8]
 800b810:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800b814:	9b03      	ldr	r3, [sp, #12]
 800b816:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 800b818:	9b00      	ldr	r3, [sp, #0]
 800b81a:	68db      	ldr	r3, [r3, #12]
 800b81c:	f043 0201 	orr.w	r2, r3, #1
 800b820:	9b03      	ldr	r3, [sp, #12]
 800b822:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b824:	9b00      	ldr	r3, [sp, #0]
 800b826:	685b      	ldr	r3, [r3, #4]
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800b828:	f443 7396 	orr.w	r3, r3, #300	; 0x12c
 800b82c:	f043 0301 	orr.w	r3, r3, #1
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 800b830:	9a03      	ldr	r2, [sp, #12]
 800b832:	6013      	str	r3, [r2, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 800b834:	9b03      	ldr	r3, [sp, #12]
 800b836:	f04f 32ff 	mov.w	r2, #4294967295
 800b83a:	621a      	str	r2, [r3, #32]
}
 800b83c:	b004      	add	sp, #16
 800b83e:	4770      	bx	lr

0800b840 <usart_deinit>:
 * @brief   USART de-initialization.
 * @details This function must be invoked with interrupts disabled.
 *
 * @param[in] u         pointer to an USART I/O block
 */
static void usart_deinit(USART_TypeDef *u) {
 800b840:	b082      	sub	sp, #8
 800b842:	9001      	str	r0, [sp, #4]

  u->CR1 = 0;
 800b844:	9b01      	ldr	r3, [sp, #4]
 800b846:	2200      	movs	r2, #0
 800b848:	601a      	str	r2, [r3, #0]
  u->CR2 = 0;
 800b84a:	9b01      	ldr	r3, [sp, #4]
 800b84c:	2200      	movs	r2, #0
 800b84e:	605a      	str	r2, [r3, #4]
  u->CR3 = 0;
 800b850:	9b01      	ldr	r3, [sp, #4]
 800b852:	2200      	movs	r2, #0
 800b854:	609a      	str	r2, [r3, #8]
}
 800b856:	b002      	add	sp, #8
 800b858:	4770      	bx	lr
 800b85a:	bf00      	nop
 800b85c:	f3af 8000 	nop.w

0800b860 <set_error>:
 * @brief   Error handling routine.
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] isr       USART ISR register value
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
 800b860:	b500      	push	{lr}
 800b862:	b085      	sub	sp, #20
 800b864:	9001      	str	r0, [sp, #4]
 800b866:	9100      	str	r1, [sp, #0]
  eventflags_t sts = 0;
 800b868:	2300      	movs	r3, #0
 800b86a:	9303      	str	r3, [sp, #12]

  if (isr & USART_ISR_ORE)
 800b86c:	9b00      	ldr	r3, [sp, #0]
 800b86e:	f003 0308 	and.w	r3, r3, #8
 800b872:	2b00      	cmp	r3, #0
 800b874:	d003      	beq.n	800b87e <set_error+0x1e>
    sts |= SD_OVERRUN_ERROR;
 800b876:	9b03      	ldr	r3, [sp, #12]
 800b878:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 800b87c:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_PE)
 800b87e:	9b00      	ldr	r3, [sp, #0]
 800b880:	f003 0301 	and.w	r3, r3, #1
 800b884:	2b00      	cmp	r3, #0
 800b886:	d003      	beq.n	800b890 <set_error+0x30>
    sts |= SD_PARITY_ERROR;
 800b888:	9b03      	ldr	r3, [sp, #12]
 800b88a:	f043 0320 	orr.w	r3, r3, #32
 800b88e:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_FE)
 800b890:	9b00      	ldr	r3, [sp, #0]
 800b892:	f003 0302 	and.w	r3, r3, #2
 800b896:	2b00      	cmp	r3, #0
 800b898:	d003      	beq.n	800b8a2 <set_error+0x42>
    sts |= SD_FRAMING_ERROR;
 800b89a:	9b03      	ldr	r3, [sp, #12]
 800b89c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800b8a0:	9303      	str	r3, [sp, #12]
  if (isr & USART_ISR_NE)
 800b8a2:	9b00      	ldr	r3, [sp, #0]
 800b8a4:	f003 0304 	and.w	r3, r3, #4
 800b8a8:	2b00      	cmp	r3, #0
 800b8aa:	d003      	beq.n	800b8b4 <set_error+0x54>
    sts |= SD_NOISE_ERROR;
 800b8ac:	9b03      	ldr	r3, [sp, #12]
 800b8ae:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 800b8b2:	9303      	str	r3, [sp, #12]
  osalSysLockFromISR();
 800b8b4:	f7ff ff7c 	bl	800b7b0 <osalSysLockFromISR>
  chnAddFlagsI(sdp, sts);
 800b8b8:	9b01      	ldr	r3, [sp, #4]
 800b8ba:	3304      	adds	r3, #4
 800b8bc:	4618      	mov	r0, r3
 800b8be:	9903      	ldr	r1, [sp, #12]
 800b8c0:	f7ff ff86 	bl	800b7d0 <osalEventBroadcastFlagsI>
  osalSysUnlockFromISR();
 800b8c4:	f7ff ff7c 	bl	800b7c0 <osalSysUnlockFromISR>
}
 800b8c8:	b005      	add	sp, #20
 800b8ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800b8ce:	bf00      	nop

0800b8d0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 800b8d0:	b500      	push	{lr}
 800b8d2:	b087      	sub	sp, #28
 800b8d4:	9001      	str	r0, [sp, #4]
  USART_TypeDef *u = sdp->usart;
 800b8d6:	9b01      	ldr	r3, [sp, #4]
 800b8d8:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800b8da:	9305      	str	r3, [sp, #20]
  uint32_t cr1 = u->CR1;
 800b8dc:	9b05      	ldr	r3, [sp, #20]
 800b8de:	681b      	ldr	r3, [r3, #0]
 800b8e0:	9304      	str	r3, [sp, #16]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 800b8e2:	9b05      	ldr	r3, [sp, #20]
 800b8e4:	69db      	ldr	r3, [r3, #28]
 800b8e6:	9303      	str	r3, [sp, #12]
  u->ICR = isr;
 800b8e8:	9b05      	ldr	r3, [sp, #20]
 800b8ea:	9a03      	ldr	r2, [sp, #12]
 800b8ec:	621a      	str	r2, [r3, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 800b8ee:	9b03      	ldr	r3, [sp, #12]
 800b8f0:	f003 030f 	and.w	r3, r3, #15
 800b8f4:	2b00      	cmp	r3, #0
 800b8f6:	d003      	beq.n	800b900 <serve_interrupt+0x30>
    set_error(sdp, isr);
 800b8f8:	9801      	ldr	r0, [sp, #4]
 800b8fa:	9903      	ldr	r1, [sp, #12]
 800b8fc:	f7ff ffb0 	bl	800b860 <set_error>

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 800b900:	9b03      	ldr	r3, [sp, #12]
 800b902:	f403 7380 	and.w	r3, r3, #256	; 0x100
 800b906:	2b00      	cmp	r3, #0
 800b908:	d00a      	beq.n	800b920 <serve_interrupt+0x50>
    osalSysLockFromISR();
 800b90a:	f7ff ff51 	bl	800b7b0 <osalSysLockFromISR>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
 800b90e:	9b01      	ldr	r3, [sp, #4]
 800b910:	3304      	adds	r3, #4
 800b912:	4618      	mov	r0, r3
 800b914:	f44f 7100 	mov.w	r1, #512	; 0x200
 800b918:	f7ff ff5a 	bl	800b7d0 <osalEventBroadcastFlagsI>
    osalSysUnlockFromISR();
 800b91c:	f7ff ff50 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 800b920:	9b03      	ldr	r3, [sp, #12]
 800b922:	f003 0320 	and.w	r3, r3, #32
 800b926:	2b00      	cmp	r3, #0
 800b928:	d00b      	beq.n	800b942 <serve_interrupt+0x72>
    osalSysLockFromISR();
 800b92a:	f7ff ff41 	bl	800b7b0 <osalSysLockFromISR>
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800b92e:	9b05      	ldr	r3, [sp, #20]
 800b930:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 800b932:	b29b      	uxth	r3, r3
 800b934:	b2db      	uxtb	r3, r3
 800b936:	9801      	ldr	r0, [sp, #4]
 800b938:	4619      	mov	r1, r3
 800b93a:	f7fa fca1 	bl	8006280 <sdIncomingDataI>
    osalSysUnlockFromISR();
 800b93e:	f7ff ff3f 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 800b942:	9b04      	ldr	r3, [sp, #16]
 800b944:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b948:	2b00      	cmp	r3, #0
 800b94a:	d023      	beq.n	800b994 <serve_interrupt+0xc4>
 800b94c:	9b03      	ldr	r3, [sp, #12]
 800b94e:	f003 0380 	and.w	r3, r3, #128	; 0x80
 800b952:	2b00      	cmp	r3, #0
 800b954:	d01e      	beq.n	800b994 <serve_interrupt+0xc4>
    msg_t b;
    osalSysLockFromISR();
 800b956:	f7ff ff2b 	bl	800b7b0 <osalSysLockFromISR>
    b = oqGetI(&sdp->oqueue);
 800b95a:	9b01      	ldr	r3, [sp, #4]
 800b95c:	3330      	adds	r3, #48	; 0x30
 800b95e:	4618      	mov	r0, r3
 800b960:	f7f7 fdbe 	bl	80034e0 <chOQGetI>
 800b964:	9002      	str	r0, [sp, #8]
    if (b < Q_OK) {
 800b966:	9b02      	ldr	r3, [sp, #8]
 800b968:	2b00      	cmp	r3, #0
 800b96a:	da0d      	bge.n	800b988 <serve_interrupt+0xb8>
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
 800b96c:	9b01      	ldr	r3, [sp, #4]
 800b96e:	3304      	adds	r3, #4
 800b970:	4618      	mov	r0, r3
 800b972:	2108      	movs	r1, #8
 800b974:	f7ff ff2c 	bl	800b7d0 <osalEventBroadcastFlagsI>
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 800b978:	9b04      	ldr	r3, [sp, #16]
 800b97a:	f023 03c0 	bic.w	r3, r3, #192	; 0xc0
 800b97e:	f043 0240 	orr.w	r2, r3, #64	; 0x40
 800b982:	9b05      	ldr	r3, [sp, #20]
 800b984:	601a      	str	r2, [r3, #0]
 800b986:	e003      	b.n	800b990 <serve_interrupt+0xc0>
    }
    else
      u->TDR = b;
 800b988:	9b02      	ldr	r3, [sp, #8]
 800b98a:	b29a      	uxth	r2, r3
 800b98c:	9b05      	ldr	r3, [sp, #20]
 800b98e:	851a      	strh	r2, [r3, #40]	; 0x28
    osalSysUnlockFromISR();
 800b990:	f7ff ff16 	bl	800b7c0 <osalSysUnlockFromISR>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 800b994:	9b03      	ldr	r3, [sp, #12]
 800b996:	f003 0340 	and.w	r3, r3, #64	; 0x40
 800b99a:	2b00      	cmp	r3, #0
 800b99c:	d016      	beq.n	800b9cc <serve_interrupt+0xfc>
    osalSysLockFromISR();
 800b99e:	f7ff ff07 	bl	800b7b0 <osalSysLockFromISR>
    if (oqIsEmptyI(&sdp->oqueue))
 800b9a2:	9b01      	ldr	r3, [sp, #4]
 800b9a4:	3330      	adds	r3, #48	; 0x30
 800b9a6:	4618      	mov	r0, r3
 800b9a8:	f7ff feea 	bl	800b780 <chOQIsEmptyI>
 800b9ac:	4603      	mov	r3, r0
 800b9ae:	2b00      	cmp	r3, #0
 800b9b0:	d005      	beq.n	800b9be <serve_interrupt+0xee>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
 800b9b2:	9b01      	ldr	r3, [sp, #4]
 800b9b4:	3304      	adds	r3, #4
 800b9b6:	4618      	mov	r0, r3
 800b9b8:	2110      	movs	r1, #16
 800b9ba:	f7ff ff09 	bl	800b7d0 <osalEventBroadcastFlagsI>
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 800b9be:	9b04      	ldr	r3, [sp, #16]
 800b9c0:	f023 0240 	bic.w	r2, r3, #64	; 0x40
 800b9c4:	9b05      	ldr	r3, [sp, #20]
 800b9c6:	601a      	str	r2, [r3, #0]
    osalSysUnlockFromISR();
 800b9c8:	f7ff fefa 	bl	800b7c0 <osalSysUnlockFromISR>
  }
}
 800b9cc:	b007      	add	sp, #28
 800b9ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800b9d2:	bf00      	nop
 800b9d4:	f3af 8000 	nop.w
 800b9d8:	f3af 8000 	nop.w
 800b9dc:	f3af 8000 	nop.w

0800b9e0 <notify5>:
  UART4->CR1 |= USART_CR1_TXEIE;
}
#endif

#if STM32_SERIAL_USE_UART5 || defined(__DOXYGEN__)
static void notify5(io_queue_t *qp) {
 800b9e0:	b082      	sub	sp, #8
 800b9e2:	9001      	str	r0, [sp, #4]

  (void)qp;
  UART5->CR1 |= USART_CR1_TXEIE;
 800b9e4:	4b03      	ldr	r3, [pc, #12]	; (800b9f4 <notify5+0x14>)
 800b9e6:	4a03      	ldr	r2, [pc, #12]	; (800b9f4 <notify5+0x14>)
 800b9e8:	6812      	ldr	r2, [r2, #0]
 800b9ea:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 800b9ee:	601a      	str	r2, [r3, #0]
}
 800b9f0:	b002      	add	sp, #8
 800b9f2:	4770      	bx	lr
 800b9f4:	40005000 	.word	0x40005000
 800b9f8:	f3af 8000 	nop.w
 800b9fc:	f3af 8000 	nop.w

0800ba00 <Vector114>:
/**
 * @brief   UART5 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_UART5_HANDLER) {
 800ba00:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD5);
 800ba02:	4803      	ldr	r0, [pc, #12]	; (800ba10 <Vector114+0x10>)
 800ba04:	f7ff ff64 	bl	800b8d0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
 800ba08:	f7f8 f8a2 	bl	8003b50 <_port_irq_epilogue>
}
 800ba0c:	bd08      	pop	{r3, pc}
 800ba0e:	bf00      	nop
 800ba10:	20001fd8 	.word	0x20001fd8
 800ba14:	f3af 8000 	nop.w
 800ba18:	f3af 8000 	nop.w
 800ba1c:	f3af 8000 	nop.w

0800ba20 <sd_lld_init>:
/**
 * @brief   Low level serial driver initialization.
 *
 * @notapi
 */
void sd_lld_init(void) {
 800ba20:	b508      	push	{r3, lr}
  nvicEnableVector(STM32_UART4_NUMBER, STM32_SERIAL_UART4_PRIORITY);
#endif
#endif

#if STM32_SERIAL_USE_UART5
  sdObjectInit(&SD5, NULL, notify5);
 800ba22:	4808      	ldr	r0, [pc, #32]	; (800ba44 <sd_lld_init+0x24>)
 800ba24:	2100      	movs	r1, #0
 800ba26:	4a08      	ldr	r2, [pc, #32]	; (800ba48 <sd_lld_init+0x28>)
 800ba28:	f7fa fbc2 	bl	80061b0 <sdObjectInit>
  SD5.usart = UART5;
 800ba2c:	4b05      	ldr	r3, [pc, #20]	; (800ba44 <sd_lld_init+0x24>)
 800ba2e:	4a07      	ldr	r2, [pc, #28]	; (800ba4c <sd_lld_init+0x2c>)
 800ba30:	675a      	str	r2, [r3, #116]	; 0x74
  SD5.clock = STM32_UART5CLK;
 800ba32:	4b04      	ldr	r3, [pc, #16]	; (800ba44 <sd_lld_init+0x24>)
 800ba34:	4a06      	ldr	r2, [pc, #24]	; (800ba50 <sd_lld_init+0x30>)
 800ba36:	679a      	str	r2, [r3, #120]	; 0x78
#if defined(STM32_UART5_NUMBER)
  nvicEnableVector(STM32_UART5_NUMBER, STM32_SERIAL_UART5_PRIORITY);
 800ba38:	2035      	movs	r0, #53	; 0x35
 800ba3a:	210c      	movs	r1, #12
 800ba3c:	f7fb fc78 	bl	8007330 <nvicEnableVector>
    STM32_SERIAL_USE_UART7  ||  STM32_SERIAL_USE_UART8 || defined(__DOXYGEN__)
#if defined(STM32_USART3_8_HANDLER)
  nvicEnableVector(STM32_USART3_8_NUMBER, STM32_SERIAL_USART3_8_PRIORITY);
#endif
#endif
}
 800ba40:	bd08      	pop	{r3, pc}
 800ba42:	bf00      	nop
 800ba44:	20001fd8 	.word	0x20001fd8
 800ba48:	0800b9e1 	.word	0x0800b9e1
 800ba4c:	40005000 	.word	0x40005000
 800ba50:	04c4b400 	.word	0x04c4b400
 800ba54:	f3af 8000 	nop.w
 800ba58:	f3af 8000 	nop.w
 800ba5c:	f3af 8000 	nop.w

0800ba60 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {
 800ba60:	b500      	push	{lr}
 800ba62:	b083      	sub	sp, #12
 800ba64:	9001      	str	r0, [sp, #4]
 800ba66:	9100      	str	r1, [sp, #0]

  if (config == NULL)
 800ba68:	9b00      	ldr	r3, [sp, #0]
 800ba6a:	2b00      	cmp	r3, #0
 800ba6c:	d101      	bne.n	800ba72 <sd_lld_start+0x12>
    config = &default_config;
 800ba6e:	4b0b      	ldr	r3, [pc, #44]	; (800ba9c <sd_lld_start+0x3c>)
 800ba70:	9300      	str	r3, [sp, #0]

  if (sdp->state == SD_STOP) {
 800ba72:	9b01      	ldr	r3, [sp, #4]
 800ba74:	7a1b      	ldrb	r3, [r3, #8]
 800ba76:	2b01      	cmp	r3, #1
 800ba78:	d109      	bne.n	800ba8e <sd_lld_start+0x2e>
    if (&SD4 == sdp) {
      rccEnableUART4(FALSE);
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800ba7a:	9a01      	ldr	r2, [sp, #4]
 800ba7c:	4b08      	ldr	r3, [pc, #32]	; (800baa0 <sd_lld_start+0x40>)
 800ba7e:	429a      	cmp	r2, r3
 800ba80:	d105      	bne.n	800ba8e <sd_lld_start+0x2e>
      rccEnableUART5(FALSE);
 800ba82:	4b08      	ldr	r3, [pc, #32]	; (800baa4 <sd_lld_start+0x44>)
 800ba84:	4a07      	ldr	r2, [pc, #28]	; (800baa4 <sd_lld_start+0x44>)
 800ba86:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800ba88:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 800ba8c:	659a      	str	r2, [r3, #88]	; 0x58
    if (&LPSD1 == sdp) {
      rccEnableLPUART1(FALSE);
    }
#endif
  }
  usart_init(sdp, config);
 800ba8e:	9801      	ldr	r0, [sp, #4]
 800ba90:	9900      	ldr	r1, [sp, #0]
 800ba92:	f7ff fead 	bl	800b7f0 <usart_init>
}
 800ba96:	b003      	add	sp, #12
 800ba98:	f85d fb04 	ldr.w	pc, [sp], #4
 800ba9c:	08019620 	.word	0x08019620
 800baa0:	20001fd8 	.word	0x20001fd8
 800baa4:	40021000 	.word	0x40021000
 800baa8:	f3af 8000 	nop.w
 800baac:	f3af 8000 	nop.w

0800bab0 <sd_lld_stop>:
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 *
 * @notapi
 */
void sd_lld_stop(SerialDriver *sdp) {
 800bab0:	b500      	push	{lr}
 800bab2:	b083      	sub	sp, #12
 800bab4:	9001      	str	r0, [sp, #4]

  if (sdp->state == SD_READY) {
 800bab6:	9b01      	ldr	r3, [sp, #4]
 800bab8:	7a1b      	ldrb	r3, [r3, #8]
 800baba:	2b02      	cmp	r3, #2
 800babc:	d10f      	bne.n	800bade <sd_lld_stop+0x2e>
    /* UART is de-initialized then clocks are disabled.*/
    usart_deinit(sdp->usart);
 800babe:	9b01      	ldr	r3, [sp, #4]
 800bac0:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 800bac2:	4618      	mov	r0, r3
 800bac4:	f7ff febc 	bl	800b840 <usart_deinit>
      rccDisableUART4(FALSE);
      return;
    }
#endif
#if STM32_SERIAL_USE_UART5
    if (&SD5 == sdp) {
 800bac8:	9a01      	ldr	r2, [sp, #4]
 800baca:	4b06      	ldr	r3, [pc, #24]	; (800bae4 <sd_lld_stop+0x34>)
 800bacc:	429a      	cmp	r2, r3
 800bace:	d106      	bne.n	800bade <sd_lld_stop+0x2e>
      rccDisableUART5(FALSE);
 800bad0:	4b05      	ldr	r3, [pc, #20]	; (800bae8 <sd_lld_stop+0x38>)
 800bad2:	4a05      	ldr	r2, [pc, #20]	; (800bae8 <sd_lld_stop+0x38>)
 800bad4:	6d92      	ldr	r2, [r2, #88]	; 0x58
 800bad6:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 800bada:	659a      	str	r2, [r3, #88]	; 0x58
      return;
 800badc:	bf00      	nop
      rccDisableLPUART1(FALSE);
      return;
    }
#endif
  }
}
 800bade:	b003      	add	sp, #12
 800bae0:	f85d fb04 	ldr.w	pc, [sp], #4
 800bae4:	20001fd8 	.word	0x20001fd8
 800bae8:	40021000 	.word	0x40021000
 800baec:	f3af 8000 	nop.w

0800baf0 <__early_init>:
/**
 * @brief   Early initialization code.
 * @details This initialization must be performed just after stack setup
 *          and before any other initialization.
 */
void __early_init(void) {
 800baf0:	b508      	push	{r3, lr}

  stm32_clock_init();
 800baf2:	f7fb fd2d 	bl	8007550 <stm32_clock_init>
}
 800baf6:	bd08      	pop	{r3, pc}
 800baf8:	f3af 8000 	nop.w
 800bafc:	f3af 8000 	nop.w

0800bb00 <sdc_lld_is_card_inserted>:

#if HAL_USE_SDC || defined(__DOXYGEN__)
/**
 * @brief   SDC card detection.
 */
bool sdc_lld_is_card_inserted(SDCDriver *sdcp) {
 800bb00:	b082      	sub	sp, #8
 800bb02:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return true;
 800bb04:	2301      	movs	r3, #1
}
 800bb06:	4618      	mov	r0, r3
 800bb08:	b002      	add	sp, #8
 800bb0a:	4770      	bx	lr
 800bb0c:	f3af 8000 	nop.w

0800bb10 <sdc_lld_is_write_protected>:

/**
 * @brief   SDC card write protection detection.
 */
bool sdc_lld_is_write_protected(SDCDriver *sdcp) {
 800bb10:	b082      	sub	sp, #8
 800bb12:	9001      	str	r0, [sp, #4]

  (void)sdcp;
  /* TODO: Fill the implementation.*/
  return false;
 800bb14:	2300      	movs	r3, #0
}
 800bb16:	4618      	mov	r0, r3
 800bb18:	b002      	add	sp, #8
 800bb1a:	4770      	bx	lr
 800bb1c:	f3af 8000 	nop.w

0800bb20 <boardInit>:
/**
 * @brief   Board-specific initialization code.
 * @todo    Add your board-specific code, if any.
 */
void boardInit(void) {
}
 800bb20:	4770      	bx	lr
 800bb22:	bf00      	nop
 800bb24:	f3af 8000 	nop.w
 800bb28:	f3af 8000 	nop.w
 800bb2c:	f3af 8000 	nop.w

0800bb30 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800bb30:	b082      	sub	sp, #8
 800bb32:	2320      	movs	r3, #32
 800bb34:	9301      	str	r3, [sp, #4]
 800bb36:	9b01      	ldr	r3, [sp, #4]
 800bb38:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bb3c:	b002      	add	sp, #8
 800bb3e:	4770      	bx	lr

0800bb40 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800bb40:	b082      	sub	sp, #8
 800bb42:	2300      	movs	r3, #0
 800bb44:	9301      	str	r3, [sp, #4]
 800bb46:	9b01      	ldr	r3, [sp, #4]
 800bb48:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800bb4c:	b002      	add	sp, #8
 800bb4e:	4770      	bx	lr

0800bb50 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800bb50:	b508      	push	{r3, lr}

  port_lock();
 800bb52:	f7ff ffed 	bl	800bb30 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800bb56:	bd08      	pop	{r3, pc}
 800bb58:	f3af 8000 	nop.w
 800bb5c:	f3af 8000 	nop.w

0800bb60 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800bb60:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800bb62:	f7ff ffed 	bl	800bb40 <port_unlock>
}
 800bb66:	bd08      	pop	{r3, pc}
 800bb68:	f3af 8000 	nop.w
 800bb6c:	f3af 8000 	nop.w

0800bb70 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800bb70:	4b01      	ldr	r3, [pc, #4]	; (800bb78 <chVTGetSystemTimeX+0x8>)
 800bb72:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800bb74:	4618      	mov	r0, r3
 800bb76:	4770      	bx	lr
 800bb78:	20001bc8 	.word	0x20001bc8
 800bb7c:	f3af 8000 	nop.w

0800bb80 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800bb80:	b500      	push	{lr}
 800bb82:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800bb84:	f7ff ffe4 	bl	800bb50 <chSysLock>
  systime = chVTGetSystemTimeX();
 800bb88:	f7ff fff2 	bl	800bb70 <chVTGetSystemTimeX>
 800bb8c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800bb8e:	f7ff ffe7 	bl	800bb60 <chSysUnlock>

  return systime;
 800bb92:	9b01      	ldr	r3, [sp, #4]
}
 800bb94:	4618      	mov	r0, r3
 800bb96:	b003      	add	sp, #12
 800bb98:	f85d fb04 	ldr.w	pc, [sp], #4
 800bb9c:	f3af 8000 	nop.w

0800bba0 <chVTIsTimeWithinX>:
 *
 * @xclass
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {
 800bba0:	b084      	sub	sp, #16
 800bba2:	9003      	str	r0, [sp, #12]
 800bba4:	9102      	str	r1, [sp, #8]
 800bba6:	9201      	str	r2, [sp, #4]

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800bba8:	9a03      	ldr	r2, [sp, #12]
 800bbaa:	9b02      	ldr	r3, [sp, #8]
 800bbac:	1ad2      	subs	r2, r2, r3
 800bbae:	9901      	ldr	r1, [sp, #4]
 800bbb0:	9b02      	ldr	r3, [sp, #8]
 800bbb2:	1acb      	subs	r3, r1, r3
 800bbb4:	429a      	cmp	r2, r3
 800bbb6:	bf2c      	ite	cs
 800bbb8:	2300      	movcs	r3, #0
 800bbba:	2301      	movcc	r3, #1
 800bbbc:	b2db      	uxtb	r3, r3
}
 800bbbe:	4618      	mov	r0, r3
 800bbc0:	b004      	add	sp, #16
 800bbc2:	4770      	bx	lr
 800bbc4:	f3af 8000 	nop.w
 800bbc8:	f3af 8000 	nop.w
 800bbcc:	f3af 8000 	nop.w

0800bbd0 <chVTIsSystemTimeWithin>:
 * @retval true         current time within the specified time window.
 * @retval false        current time not within the specified time window.
 *
 * @api
 */
static inline bool chVTIsSystemTimeWithin(systime_t start, systime_t end) {
 800bbd0:	b500      	push	{lr}
 800bbd2:	b083      	sub	sp, #12
 800bbd4:	9001      	str	r0, [sp, #4]
 800bbd6:	9100      	str	r1, [sp, #0]

  return chVTIsTimeWithinX(chVTGetSystemTime(), start, end);
 800bbd8:	f7ff ffd2 	bl	800bb80 <chVTGetSystemTime>
 800bbdc:	4603      	mov	r3, r0
 800bbde:	4618      	mov	r0, r3
 800bbe0:	9901      	ldr	r1, [sp, #4]
 800bbe2:	9a00      	ldr	r2, [sp, #0]
 800bbe4:	f7ff ffdc 	bl	800bba0 <chVTIsTimeWithinX>
 800bbe8:	4603      	mov	r3, r0
}
 800bbea:	4618      	mov	r0, r3
 800bbec:	b003      	add	sp, #12
 800bbee:	f85d fb04 	ldr.w	pc, [sp], #4
 800bbf2:	bf00      	nop
 800bbf4:	f3af 8000 	nop.w
 800bbf8:	f3af 8000 	nop.w
 800bbfc:	f3af 8000 	nop.w

0800bc00 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800bc00:	b082      	sub	sp, #8
 800bc02:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800bc04:	9b01      	ldr	r3, [sp, #4]
 800bc06:	68db      	ldr	r3, [r3, #12]
 800bc08:	2b00      	cmp	r3, #0
 800bc0a:	bf0c      	ite	eq
 800bc0c:	2300      	moveq	r3, #0
 800bc0e:	2301      	movne	r3, #1
 800bc10:	b2db      	uxtb	r3, r3
}
 800bc12:	4618      	mov	r0, r3
 800bc14:	b002      	add	sp, #8
 800bc16:	4770      	bx	lr
 800bc18:	f3af 8000 	nop.w
 800bc1c:	f3af 8000 	nop.w

0800bc20 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800bc20:	b500      	push	{lr}
 800bc22:	b083      	sub	sp, #12
 800bc24:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800bc26:	9801      	ldr	r0, [sp, #4]
 800bc28:	f7ff ffea 	bl	800bc00 <chVTIsArmedI>
 800bc2c:	4603      	mov	r3, r0
 800bc2e:	2b00      	cmp	r3, #0
 800bc30:	d002      	beq.n	800bc38 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800bc32:	9801      	ldr	r0, [sp, #4]
 800bc34:	f7f4 feec 	bl	8000a10 <chVTDoResetI>
  }
}
 800bc38:	b003      	add	sp, #12
 800bc3a:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc3e:	bf00      	nop

0800bc40 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800bc40:	b500      	push	{lr}
 800bc42:	b085      	sub	sp, #20
 800bc44:	9003      	str	r0, [sp, #12]
 800bc46:	9102      	str	r1, [sp, #8]
 800bc48:	9201      	str	r2, [sp, #4]
 800bc4a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800bc4c:	9803      	ldr	r0, [sp, #12]
 800bc4e:	f7ff ffe7 	bl	800bc20 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800bc52:	9803      	ldr	r0, [sp, #12]
 800bc54:	9902      	ldr	r1, [sp, #8]
 800bc56:	9a01      	ldr	r2, [sp, #4]
 800bc58:	9b00      	ldr	r3, [sp, #0]
 800bc5a:	f7f4 fe99 	bl	8000990 <chVTDoSetI>
}
 800bc5e:	b005      	add	sp, #20
 800bc60:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc64:	f3af 8000 	nop.w
 800bc68:	f3af 8000 	nop.w
 800bc6c:	f3af 8000 	nop.w

0800bc70 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800bc70:	b500      	push	{lr}
 800bc72:	b085      	sub	sp, #20
 800bc74:	9003      	str	r0, [sp, #12]
 800bc76:	9102      	str	r1, [sp, #8]
 800bc78:	9201      	str	r2, [sp, #4]
 800bc7a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800bc7c:	f7ff ff68 	bl	800bb50 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800bc80:	9803      	ldr	r0, [sp, #12]
 800bc82:	9902      	ldr	r1, [sp, #8]
 800bc84:	9a01      	ldr	r2, [sp, #4]
 800bc86:	9b00      	ldr	r3, [sp, #0]
 800bc88:	f7ff ffda 	bl	800bc40 <chVTSetI>
  chSysUnlock();
 800bc8c:	f7ff ff68 	bl	800bb60 <chSysUnlock>
}
 800bc90:	b005      	add	sp, #20
 800bc92:	f85d fb04 	ldr.w	pc, [sp], #4
 800bc96:	bf00      	nop
 800bc98:	f3af 8000 	nop.w
 800bc9c:	f3af 8000 	nop.w

0800bca0 <test_printn>:
/**
 * @brief   Prints a decimal unsigned number.
 *
 * @param[in] n         the number to be printed
 */
void test_printn(uint32_t n) {
 800bca0:	b500      	push	{lr}
 800bca2:	b089      	sub	sp, #36	; 0x24
 800bca4:	9001      	str	r0, [sp, #4]
  char buf[16], *p;

  if (!n)
 800bca6:	9b01      	ldr	r3, [sp, #4]
 800bca8:	2b00      	cmp	r3, #0
 800bcaa:	d109      	bne.n	800bcc0 <test_printn+0x20>
    chSequentialStreamPut(chp, '0');
 800bcac:	4b1e      	ldr	r3, [pc, #120]	; (800bd28 <test_printn+0x88>)
 800bcae:	681b      	ldr	r3, [r3, #0]
 800bcb0:	681b      	ldr	r3, [r3, #0]
 800bcb2:	689b      	ldr	r3, [r3, #8]
 800bcb4:	4a1c      	ldr	r2, [pc, #112]	; (800bd28 <test_printn+0x88>)
 800bcb6:	6812      	ldr	r2, [r2, #0]
 800bcb8:	4610      	mov	r0, r2
 800bcba:	2130      	movs	r1, #48	; 0x30
 800bcbc:	4798      	blx	r3
 800bcbe:	e02f      	b.n	800bd20 <test_printn+0x80>
  else {
    p = buf;
 800bcc0:	ab03      	add	r3, sp, #12
 800bcc2:	9307      	str	r3, [sp, #28]
    while (n)
 800bcc4:	e016      	b.n	800bcf4 <test_printn+0x54>
      *p++ = (n % 10) + '0', n /= 10;
 800bcc6:	9907      	ldr	r1, [sp, #28]
 800bcc8:	1c4b      	adds	r3, r1, #1
 800bcca:	9307      	str	r3, [sp, #28]
 800bccc:	9801      	ldr	r0, [sp, #4]
 800bcce:	4b17      	ldr	r3, [pc, #92]	; (800bd2c <test_printn+0x8c>)
 800bcd0:	fba3 2300 	umull	r2, r3, r3, r0
 800bcd4:	08da      	lsrs	r2, r3, #3
 800bcd6:	4613      	mov	r3, r2
 800bcd8:	009b      	lsls	r3, r3, #2
 800bcda:	4413      	add	r3, r2
 800bcdc:	005b      	lsls	r3, r3, #1
 800bcde:	1ac2      	subs	r2, r0, r3
 800bce0:	b2d3      	uxtb	r3, r2
 800bce2:	3330      	adds	r3, #48	; 0x30
 800bce4:	b2db      	uxtb	r3, r3
 800bce6:	700b      	strb	r3, [r1, #0]
 800bce8:	9a01      	ldr	r2, [sp, #4]
 800bcea:	4b10      	ldr	r3, [pc, #64]	; (800bd2c <test_printn+0x8c>)
 800bcec:	fba3 1302 	umull	r1, r3, r3, r2
 800bcf0:	08db      	lsrs	r3, r3, #3
 800bcf2:	9301      	str	r3, [sp, #4]

  if (!n)
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
 800bcf4:	9b01      	ldr	r3, [sp, #4]
 800bcf6:	2b00      	cmp	r3, #0
 800bcf8:	d1e5      	bne.n	800bcc6 <test_printn+0x26>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bcfa:	e00d      	b.n	800bd18 <test_printn+0x78>
      chSequentialStreamPut(chp, *--p);
 800bcfc:	4b0a      	ldr	r3, [pc, #40]	; (800bd28 <test_printn+0x88>)
 800bcfe:	681b      	ldr	r3, [r3, #0]
 800bd00:	681b      	ldr	r3, [r3, #0]
 800bd02:	689b      	ldr	r3, [r3, #8]
 800bd04:	4a08      	ldr	r2, [pc, #32]	; (800bd28 <test_printn+0x88>)
 800bd06:	6811      	ldr	r1, [r2, #0]
 800bd08:	9a07      	ldr	r2, [sp, #28]
 800bd0a:	3a01      	subs	r2, #1
 800bd0c:	9207      	str	r2, [sp, #28]
 800bd0e:	9a07      	ldr	r2, [sp, #28]
 800bd10:	7812      	ldrb	r2, [r2, #0]
 800bd12:	4608      	mov	r0, r1
 800bd14:	4611      	mov	r1, r2
 800bd16:	4798      	blx	r3
    chSequentialStreamPut(chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 800bd18:	ab03      	add	r3, sp, #12
 800bd1a:	9a07      	ldr	r2, [sp, #28]
 800bd1c:	429a      	cmp	r2, r3
 800bd1e:	d8ed      	bhi.n	800bcfc <test_printn+0x5c>
      chSequentialStreamPut(chp, *--p);
  }
}
 800bd20:	b009      	add	sp, #36	; 0x24
 800bd22:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd26:	bf00      	nop
 800bd28:	200013ec 	.word	0x200013ec
 800bd2c:	cccccccd 	.word	0xcccccccd

0800bd30 <test_print>:
/**
 * @brief   Prints a line without final end-of-line.
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {
 800bd30:	b500      	push	{lr}
 800bd32:	b083      	sub	sp, #12
 800bd34:	9001      	str	r0, [sp, #4]

  while (*msgp)
 800bd36:	e00c      	b.n	800bd52 <test_print+0x22>
    chSequentialStreamPut(chp, *msgp++);
 800bd38:	4b09      	ldr	r3, [pc, #36]	; (800bd60 <test_print+0x30>)
 800bd3a:	681b      	ldr	r3, [r3, #0]
 800bd3c:	681b      	ldr	r3, [r3, #0]
 800bd3e:	689a      	ldr	r2, [r3, #8]
 800bd40:	4b07      	ldr	r3, [pc, #28]	; (800bd60 <test_print+0x30>)
 800bd42:	6819      	ldr	r1, [r3, #0]
 800bd44:	9b01      	ldr	r3, [sp, #4]
 800bd46:	1c58      	adds	r0, r3, #1
 800bd48:	9001      	str	r0, [sp, #4]
 800bd4a:	781b      	ldrb	r3, [r3, #0]
 800bd4c:	4608      	mov	r0, r1
 800bd4e:	4619      	mov	r1, r3
 800bd50:	4790      	blx	r2
 *
 * @param[in] msgp      the message
 */
void test_print(const char *msgp) {

  while (*msgp)
 800bd52:	9b01      	ldr	r3, [sp, #4]
 800bd54:	781b      	ldrb	r3, [r3, #0]
 800bd56:	2b00      	cmp	r3, #0
 800bd58:	d1ee      	bne.n	800bd38 <test_print+0x8>
    chSequentialStreamPut(chp, *msgp++);
}
 800bd5a:	b003      	add	sp, #12
 800bd5c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd60:	200013ec 	.word	0x200013ec
 800bd64:	f3af 8000 	nop.w
 800bd68:	f3af 8000 	nop.w
 800bd6c:	f3af 8000 	nop.w

0800bd70 <test_println>:
/**
 * @brief   Prints a line.
 *
 * @param[in] msgp      the message
 */
void test_println(const char *msgp) {
 800bd70:	b500      	push	{lr}
 800bd72:	b083      	sub	sp, #12
 800bd74:	9001      	str	r0, [sp, #4]

  test_print(msgp);
 800bd76:	9801      	ldr	r0, [sp, #4]
 800bd78:	f7ff ffda 	bl	800bd30 <test_print>
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800bd7c:	4b06      	ldr	r3, [pc, #24]	; (800bd98 <test_println+0x28>)
 800bd7e:	681b      	ldr	r3, [r3, #0]
 800bd80:	681b      	ldr	r3, [r3, #0]
 800bd82:	681b      	ldr	r3, [r3, #0]
 800bd84:	4a04      	ldr	r2, [pc, #16]	; (800bd98 <test_println+0x28>)
 800bd86:	6812      	ldr	r2, [r2, #0]
 800bd88:	4610      	mov	r0, r2
 800bd8a:	4904      	ldr	r1, [pc, #16]	; (800bd9c <test_println+0x2c>)
 800bd8c:	2202      	movs	r2, #2
 800bd8e:	4798      	blx	r3
}
 800bd90:	b003      	add	sp, #12
 800bd92:	f85d fb04 	ldr.w	pc, [sp], #4
 800bd96:	bf00      	nop
 800bd98:	200013ec 	.word	0x200013ec
 800bd9c:	08019764 	.word	0x08019764

0800bda0 <clear_tokens>:
/*
 * Tokens.
 */
static void clear_tokens(void) {

  tokp = tokens_buffer;
 800bda0:	4b01      	ldr	r3, [pc, #4]	; (800bda8 <clear_tokens+0x8>)
 800bda2:	4a02      	ldr	r2, [pc, #8]	; (800bdac <clear_tokens+0xc>)
 800bda4:	601a      	str	r2, [r3, #0]
}
 800bda6:	4770      	bx	lr
 800bda8:	200013e8 	.word	0x200013e8
 800bdac:	200013d8 	.word	0x200013d8

0800bdb0 <print_tokens>:

static void print_tokens(void) {
 800bdb0:	b500      	push	{lr}
 800bdb2:	b083      	sub	sp, #12
  char *cp = tokens_buffer;
 800bdb4:	4b0b      	ldr	r3, [pc, #44]	; (800bde4 <print_tokens+0x34>)
 800bdb6:	9301      	str	r3, [sp, #4]

  while (cp < tokp)
 800bdb8:	e00c      	b.n	800bdd4 <print_tokens+0x24>
    chSequentialStreamPut(chp, *cp++);
 800bdba:	4b0b      	ldr	r3, [pc, #44]	; (800bde8 <print_tokens+0x38>)
 800bdbc:	681b      	ldr	r3, [r3, #0]
 800bdbe:	681b      	ldr	r3, [r3, #0]
 800bdc0:	689a      	ldr	r2, [r3, #8]
 800bdc2:	4b09      	ldr	r3, [pc, #36]	; (800bde8 <print_tokens+0x38>)
 800bdc4:	6819      	ldr	r1, [r3, #0]
 800bdc6:	9b01      	ldr	r3, [sp, #4]
 800bdc8:	1c58      	adds	r0, r3, #1
 800bdca:	9001      	str	r0, [sp, #4]
 800bdcc:	781b      	ldrb	r3, [r3, #0]
 800bdce:	4608      	mov	r0, r1
 800bdd0:	4619      	mov	r1, r3
 800bdd2:	4790      	blx	r2
}

static void print_tokens(void) {
  char *cp = tokens_buffer;

  while (cp < tokp)
 800bdd4:	4b05      	ldr	r3, [pc, #20]	; (800bdec <print_tokens+0x3c>)
 800bdd6:	681b      	ldr	r3, [r3, #0]
 800bdd8:	9a01      	ldr	r2, [sp, #4]
 800bdda:	429a      	cmp	r2, r3
 800bddc:	d3ed      	bcc.n	800bdba <print_tokens+0xa>
    chSequentialStreamPut(chp, *cp++);
}
 800bdde:	b003      	add	sp, #12
 800bde0:	f85d fb04 	ldr.w	pc, [sp], #4
 800bde4:	200013d8 	.word	0x200013d8
 800bde8:	200013ec 	.word	0x200013ec
 800bdec:	200013e8 	.word	0x200013e8

0800bdf0 <test_emit_token>:
/**
 * @brief   Emits a token into the tokens buffer.
 *
 * @param[in] token     the token as a char
 */
void test_emit_token(char token) {
 800bdf0:	b500      	push	{lr}
 800bdf2:	b083      	sub	sp, #12
 800bdf4:	4603      	mov	r3, r0
 800bdf6:	f88d 3007 	strb.w	r3, [sp, #7]

  chSysLock();
 800bdfa:	f7ff fea9 	bl	800bb50 <chSysLock>
  *tokp++ = token;
 800bdfe:	4b06      	ldr	r3, [pc, #24]	; (800be18 <test_emit_token+0x28>)
 800be00:	681b      	ldr	r3, [r3, #0]
 800be02:	1c59      	adds	r1, r3, #1
 800be04:	4a04      	ldr	r2, [pc, #16]	; (800be18 <test_emit_token+0x28>)
 800be06:	6011      	str	r1, [r2, #0]
 800be08:	f89d 2007 	ldrb.w	r2, [sp, #7]
 800be0c:	701a      	strb	r2, [r3, #0]
  chSysUnlock();
 800be0e:	f7ff fea7 	bl	800bb60 <chSysUnlock>
}
 800be12:	b003      	add	sp, #12
 800be14:	f85d fb04 	ldr.w	pc, [sp], #4
 800be18:	200013e8 	.word	0x200013e8
 800be1c:	f3af 8000 	nop.w

0800be20 <_test_fail>:

/*
 * Assertions.
 */
bool _test_fail(unsigned point) {
 800be20:	b082      	sub	sp, #8
 800be22:	9001      	str	r0, [sp, #4]

  test_global_fail = TRUE;
 800be24:	4b06      	ldr	r3, [pc, #24]	; (800be40 <_test_fail+0x20>)
 800be26:	2201      	movs	r2, #1
 800be28:	701a      	strb	r2, [r3, #0]
  local_fail = TRUE;
 800be2a:	4b06      	ldr	r3, [pc, #24]	; (800be44 <_test_fail+0x24>)
 800be2c:	2201      	movs	r2, #1
 800be2e:	701a      	strb	r2, [r3, #0]
  failpoint = point;
 800be30:	4b05      	ldr	r3, [pc, #20]	; (800be48 <_test_fail+0x28>)
 800be32:	9a01      	ldr	r2, [sp, #4]
 800be34:	601a      	str	r2, [r3, #0]
  return TRUE;
 800be36:	2301      	movs	r3, #1
}
 800be38:	4618      	mov	r0, r3
 800be3a:	b002      	add	sp, #8
 800be3c:	4770      	bx	lr
 800be3e:	bf00      	nop
 800be40:	20002058 	.word	0x20002058
 800be44:	200013d0 	.word	0x200013d0
 800be48:	200013d4 	.word	0x200013d4
 800be4c:	f3af 8000 	nop.w

0800be50 <_test_assert>:

bool _test_assert(unsigned point, bool condition) {
 800be50:	b500      	push	{lr}
 800be52:	b083      	sub	sp, #12
 800be54:	9001      	str	r0, [sp, #4]
 800be56:	460b      	mov	r3, r1
 800be58:	f88d 3003 	strb.w	r3, [sp, #3]

  if (!condition)
 800be5c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800be60:	f083 0301 	eor.w	r3, r3, #1
 800be64:	b2db      	uxtb	r3, r3
 800be66:	2b00      	cmp	r3, #0
 800be68:	d004      	beq.n	800be74 <_test_assert+0x24>
    return _test_fail(point);
 800be6a:	9801      	ldr	r0, [sp, #4]
 800be6c:	f7ff ffd8 	bl	800be20 <_test_fail>
 800be70:	4603      	mov	r3, r0
 800be72:	e000      	b.n	800be76 <_test_assert+0x26>
  return FALSE;
 800be74:	2300      	movs	r3, #0
}
 800be76:	4618      	mov	r0, r3
 800be78:	b003      	add	sp, #12
 800be7a:	f85d fb04 	ldr.w	pc, [sp], #4
 800be7e:	bf00      	nop

0800be80 <_test_assert_sequence>:

bool _test_assert_sequence(unsigned point, char *expected) {
 800be80:	b500      	push	{lr}
 800be82:	b085      	sub	sp, #20
 800be84:	9001      	str	r0, [sp, #4]
 800be86:	9100      	str	r1, [sp, #0]
  char *cp = tokens_buffer;
 800be88:	4b13      	ldr	r3, [pc, #76]	; (800bed8 <_test_assert_sequence+0x58>)
 800be8a:	9303      	str	r3, [sp, #12]
  while (cp < tokp) {
 800be8c:	e00e      	b.n	800beac <_test_assert_sequence+0x2c>
    if (*cp++ != *expected++)
 800be8e:	9b03      	ldr	r3, [sp, #12]
 800be90:	1c5a      	adds	r2, r3, #1
 800be92:	9203      	str	r2, [sp, #12]
 800be94:	781a      	ldrb	r2, [r3, #0]
 800be96:	9b00      	ldr	r3, [sp, #0]
 800be98:	1c59      	adds	r1, r3, #1
 800be9a:	9100      	str	r1, [sp, #0]
 800be9c:	781b      	ldrb	r3, [r3, #0]
 800be9e:	429a      	cmp	r2, r3
 800bea0:	d004      	beq.n	800beac <_test_assert_sequence+0x2c>
     return _test_fail(point);
 800bea2:	9801      	ldr	r0, [sp, #4]
 800bea4:	f7ff ffbc 	bl	800be20 <_test_fail>
 800bea8:	4603      	mov	r3, r0
 800beaa:	e010      	b.n	800bece <_test_assert_sequence+0x4e>
  return FALSE;
}

bool _test_assert_sequence(unsigned point, char *expected) {
  char *cp = tokens_buffer;
  while (cp < tokp) {
 800beac:	4b0b      	ldr	r3, [pc, #44]	; (800bedc <_test_assert_sequence+0x5c>)
 800beae:	681b      	ldr	r3, [r3, #0]
 800beb0:	9a03      	ldr	r2, [sp, #12]
 800beb2:	429a      	cmp	r2, r3
 800beb4:	d3eb      	bcc.n	800be8e <_test_assert_sequence+0xe>
    if (*cp++ != *expected++)
     return _test_fail(point);
  }
  if (*expected)
 800beb6:	9b00      	ldr	r3, [sp, #0]
 800beb8:	781b      	ldrb	r3, [r3, #0]
 800beba:	2b00      	cmp	r3, #0
 800bebc:	d004      	beq.n	800bec8 <_test_assert_sequence+0x48>
    return _test_fail(point);
 800bebe:	9801      	ldr	r0, [sp, #4]
 800bec0:	f7ff ffae 	bl	800be20 <_test_fail>
 800bec4:	4603      	mov	r3, r0
 800bec6:	e002      	b.n	800bece <_test_assert_sequence+0x4e>
  clear_tokens();
 800bec8:	f7ff ff6a 	bl	800bda0 <clear_tokens>
  return FALSE;
 800becc:	2300      	movs	r3, #0
}
 800bece:	4618      	mov	r0, r3
 800bed0:	b005      	add	sp, #20
 800bed2:	f85d fb04 	ldr.w	pc, [sp], #4
 800bed6:	bf00      	nop
 800bed8:	200013d8 	.word	0x200013d8
 800bedc:	200013e8 	.word	0x200013e8

0800bee0 <_test_assert_time_window>:

bool _test_assert_time_window(unsigned point, systime_t start, systime_t end) {
 800bee0:	b500      	push	{lr}
 800bee2:	b085      	sub	sp, #20
 800bee4:	9003      	str	r0, [sp, #12]
 800bee6:	9102      	str	r1, [sp, #8]
 800bee8:	9201      	str	r2, [sp, #4]

  return _test_assert(point, chVTIsSystemTimeWithin(start, end));
 800beea:	9802      	ldr	r0, [sp, #8]
 800beec:	9901      	ldr	r1, [sp, #4]
 800beee:	f7ff fe6f 	bl	800bbd0 <chVTIsSystemTimeWithin>
 800bef2:	4603      	mov	r3, r0
 800bef4:	9803      	ldr	r0, [sp, #12]
 800bef6:	4619      	mov	r1, r3
 800bef8:	f7ff ffaa 	bl	800be50 <_test_assert>
 800befc:	4603      	mov	r3, r0
}
 800befe:	4618      	mov	r0, r3
 800bf00:	b005      	add	sp, #20
 800bf02:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf06:	bf00      	nop
 800bf08:	f3af 8000 	nop.w
 800bf0c:	f3af 8000 	nop.w

0800bf10 <test_terminate_threads>:
 */

/**
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 800bf10:	b500      	push	{lr}
 800bf12:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf14:	2300      	movs	r3, #0
 800bf16:	9301      	str	r3, [sp, #4]
 800bf18:	e00f      	b.n	800bf3a <test_terminate_threads+0x2a>
    if (threads[i])
 800bf1a:	4b0b      	ldr	r3, [pc, #44]	; (800bf48 <test_terminate_threads+0x38>)
 800bf1c:	9a01      	ldr	r2, [sp, #4]
 800bf1e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf22:	2b00      	cmp	r3, #0
 800bf24:	d006      	beq.n	800bf34 <test_terminate_threads+0x24>
      chThdTerminate(threads[i]);
 800bf26:	4b08      	ldr	r3, [pc, #32]	; (800bf48 <test_terminate_threads+0x38>)
 800bf28:	9a01      	ldr	r2, [sp, #4]
 800bf2a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf2e:	4618      	mov	r0, r3
 800bf30:	f7f5 f9b6 	bl	80012a0 <chThdTerminate>
 * @brief   Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf34:	9b01      	ldr	r3, [sp, #4]
 800bf36:	3301      	adds	r3, #1
 800bf38:	9301      	str	r3, [sp, #4]
 800bf3a:	9b01      	ldr	r3, [sp, #4]
 800bf3c:	2b04      	cmp	r3, #4
 800bf3e:	ddec      	ble.n	800bf1a <test_terminate_threads+0xa>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 800bf40:	b003      	add	sp, #12
 800bf42:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf46:	bf00      	nop
 800bf48:	2000205c 	.word	0x2000205c
 800bf4c:	f3af 8000 	nop.w

0800bf50 <test_wait_threads>:

/**
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 800bf50:	b500      	push	{lr}
 800bf52:	b083      	sub	sp, #12
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf54:	2300      	movs	r3, #0
 800bf56:	9301      	str	r3, [sp, #4]
 800bf58:	e014      	b.n	800bf84 <test_wait_threads+0x34>
    if (threads[i] != NULL) {
 800bf5a:	4b0d      	ldr	r3, [pc, #52]	; (800bf90 <test_wait_threads+0x40>)
 800bf5c:	9a01      	ldr	r2, [sp, #4]
 800bf5e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf62:	2b00      	cmp	r3, #0
 800bf64:	d00b      	beq.n	800bf7e <test_wait_threads+0x2e>
      chThdWait(threads[i]);
 800bf66:	4b0a      	ldr	r3, [pc, #40]	; (800bf90 <test_wait_threads+0x40>)
 800bf68:	9a01      	ldr	r2, [sp, #4]
 800bf6a:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800bf6e:	4618      	mov	r0, r3
 800bf70:	f7f5 fa46 	bl	8001400 <chThdWait>
      threads[i] = NULL;
 800bf74:	4b06      	ldr	r3, [pc, #24]	; (800bf90 <test_wait_threads+0x40>)
 800bf76:	9a01      	ldr	r2, [sp, #4]
 800bf78:	2100      	movs	r1, #0
 800bf7a:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
 * @brief   Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  int i;

  for (i = 0; i < MAX_THREADS; i++)
 800bf7e:	9b01      	ldr	r3, [sp, #4]
 800bf80:	3301      	adds	r3, #1
 800bf82:	9301      	str	r3, [sp, #4]
 800bf84:	9b01      	ldr	r3, [sp, #4]
 800bf86:	2b04      	cmp	r3, #4
 800bf88:	dde7      	ble.n	800bf5a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 800bf8a:	b003      	add	sp, #12
 800bf8c:	f85d fb04 	ldr.w	pc, [sp], #4
 800bf90:	2000205c 	.word	0x2000205c
 800bf94:	f3af 8000 	nop.w
 800bf98:	f3af 8000 	nop.w
 800bf9c:	f3af 8000 	nop.w

0800bfa0 <test_wait_tick>:
/**
 * @brief   Delays execution until next system time tick.
 *
 * @return              The system time.
 */
systime_t test_wait_tick(void) {
 800bfa0:	b508      	push	{r3, lr}

  chThdSleep(1);
 800bfa2:	2001      	movs	r0, #1
 800bfa4:	f7f5 f994 	bl	80012d0 <chThdSleep>
  return chVTGetSystemTime();
 800bfa8:	f7ff fdea 	bl	800bb80 <chVTGetSystemTime>
 800bfac:	4603      	mov	r3, r0
}
 800bfae:	4618      	mov	r0, r3
 800bfb0:	bd08      	pop	{r3, pc}
 800bfb2:	bf00      	nop
 800bfb4:	f3af 8000 	nop.w
 800bfb8:	f3af 8000 	nop.w
 800bfbc:	f3af 8000 	nop.w

0800bfc0 <tmr>:
 * @brief   Set to @p TRUE when the test timer reaches its deadline.
 */
bool test_timer_done;

static virtual_timer_t vt;
static void tmr(void *p) {
 800bfc0:	b082      	sub	sp, #8
 800bfc2:	9001      	str	r0, [sp, #4]
  (void)p;

  test_timer_done = TRUE;
 800bfc4:	4b02      	ldr	r3, [pc, #8]	; (800bfd0 <tmr+0x10>)
 800bfc6:	2201      	movs	r2, #1
 800bfc8:	701a      	strb	r2, [r3, #0]
}
 800bfca:	b002      	add	sp, #8
 800bfcc:	4770      	bx	lr
 800bfce:	bf00      	nop
 800bfd0:	20002059 	.word	0x20002059
 800bfd4:	f3af 8000 	nop.w
 800bfd8:	f3af 8000 	nop.w
 800bfdc:	f3af 8000 	nop.w

0800bfe0 <test_start_timer>:
/**
 * @brief   Starts the test timer.
 *
 * @param[in] ms        time in milliseconds
 */
void test_start_timer(unsigned ms) {
 800bfe0:	b500      	push	{lr}
 800bfe2:	b085      	sub	sp, #20
 800bfe4:	9001      	str	r0, [sp, #4]

  systime_t duration = MS2ST(ms);
 800bfe6:	9b01      	ldr	r3, [sp, #4]
 800bfe8:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 800bfec:	fb02 f303 	mul.w	r3, r2, r3
 800bff0:	f203 32e7 	addw	r2, r3, #999	; 0x3e7
 800bff4:	4b08      	ldr	r3, [pc, #32]	; (800c018 <test_start_timer+0x38>)
 800bff6:	fba3 1302 	umull	r1, r3, r3, r2
 800bffa:	099b      	lsrs	r3, r3, #6
 800bffc:	9303      	str	r3, [sp, #12]
  test_timer_done = FALSE;
 800bffe:	4b07      	ldr	r3, [pc, #28]	; (800c01c <test_start_timer+0x3c>)
 800c000:	2200      	movs	r2, #0
 800c002:	701a      	strb	r2, [r3, #0]
  chVTSet(&vt, duration, tmr, NULL);
 800c004:	4806      	ldr	r0, [pc, #24]	; (800c020 <test_start_timer+0x40>)
 800c006:	9903      	ldr	r1, [sp, #12]
 800c008:	4a06      	ldr	r2, [pc, #24]	; (800c024 <test_start_timer+0x44>)
 800c00a:	2300      	movs	r3, #0
 800c00c:	f7ff fe30 	bl	800bc70 <chVTSet>
}
 800c010:	b005      	add	sp, #20
 800c012:	f85d fb04 	ldr.w	pc, [sp], #4
 800c016:	bf00      	nop
 800c018:	10624dd3 	.word	0x10624dd3
 800c01c:	20002059 	.word	0x20002059
 800c020:	200013f0 	.word	0x200013f0
 800c024:	0800bfc1 	.word	0x0800bfc1
 800c028:	f3af 8000 	nopgt.w
 800c02c:	f3af 8000 	nopgt.w

0800c030 <execute_test>:

/*
 * Test suite execution.
 */
static void execute_test(const struct testcase *tcp) {
 800c030:	b500      	pushgt	{lr}
 800c032:	b085      	sub	sp, #20
 800c034:	9001      	str	r0, [sp, #4]
  int i;

  /* Initialization */
  clear_tokens();
 800c036:	f7ff feb3 	bl	800bda0 <clear_tokens>
  local_fail = FALSE;
 800c03a:	4b13      	ldr	r3, [pc, #76]	; (800c088 <execute_test+0x58>)
 800c03c:	2200      	movs	r2, #0
 800c03e:	701a      	strb	r2, [r3, #0]
  for (i = 0; i < MAX_THREADS; i++)
 800c040:	2300      	movs	r3, #0
 800c042:	9303      	str	r3, [sp, #12]
 800c044:	e007      	b.n	800c056 <execute_test+0x26>
    threads[i] = NULL;
 800c046:	4b11      	ldr	r3, [pc, #68]	; (800c08c <execute_test+0x5c>)
 800c048:	9a03      	ldr	r2, [sp, #12]
 800c04a:	2100      	movs	r1, #0
 800c04c:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
  int i;

  /* Initialization */
  clear_tokens();
  local_fail = FALSE;
  for (i = 0; i < MAX_THREADS; i++)
 800c050:	9b03      	ldr	r3, [sp, #12]
 800c052:	3301      	adds	r3, #1
 800c054:	9303      	str	r3, [sp, #12]
 800c056:	9b03      	ldr	r3, [sp, #12]
 800c058:	2b04      	cmp	r3, #4
 800c05a:	ddf4      	ble.n	800c046 <execute_test+0x16>
    threads[i] = NULL;

  if (tcp->setup != NULL)
 800c05c:	9b01      	ldr	r3, [sp, #4]
 800c05e:	685b      	ldr	r3, [r3, #4]
 800c060:	2b00      	cmp	r3, #0
 800c062:	d002      	beq.n	800c06a <execute_test+0x3a>
    tcp->setup();
 800c064:	9b01      	ldr	r3, [sp, #4]
 800c066:	685b      	ldr	r3, [r3, #4]
 800c068:	4798      	blx	r3
  tcp->execute();
 800c06a:	9b01      	ldr	r3, [sp, #4]
 800c06c:	68db      	ldr	r3, [r3, #12]
 800c06e:	4798      	blx	r3
  if (tcp->teardown != NULL)
 800c070:	9b01      	ldr	r3, [sp, #4]
 800c072:	689b      	ldr	r3, [r3, #8]
 800c074:	2b00      	cmp	r3, #0
 800c076:	d002      	beq.n	800c07e <execute_test+0x4e>
    tcp->teardown();
 800c078:	9b01      	ldr	r3, [sp, #4]
 800c07a:	689b      	ldr	r3, [r3, #8]
 800c07c:	4798      	blx	r3

  test_wait_threads();
 800c07e:	f7ff ff67 	bl	800bf50 <test_wait_threads>
}
 800c082:	b005      	add	sp, #20
 800c084:	f85d fb04 	ldr.w	pc, [sp], #4
 800c088:	200013d0 	.word	0x200013d0
 800c08c:	2000205c 	.word	0x2000205c

0800c090 <print_line>:

static void print_line(void) {
 800c090:	b500      	push	{lr}
 800c092:	b083      	sub	sp, #12
  unsigned i;

  for (i = 0; i < 76; i++)
 800c094:	2300      	movs	r3, #0
 800c096:	9301      	str	r3, [sp, #4]
 800c098:	e00b      	b.n	800c0b2 <print_line+0x22>
    chSequentialStreamPut(chp, '-');
 800c09a:	4b0e      	ldr	r3, [pc, #56]	; (800c0d4 <print_line+0x44>)
 800c09c:	681b      	ldr	r3, [r3, #0]
 800c09e:	681b      	ldr	r3, [r3, #0]
 800c0a0:	689b      	ldr	r3, [r3, #8]
 800c0a2:	4a0c      	ldr	r2, [pc, #48]	; (800c0d4 <print_line+0x44>)
 800c0a4:	6812      	ldr	r2, [r2, #0]
 800c0a6:	4610      	mov	r0, r2
 800c0a8:	212d      	movs	r1, #45	; 0x2d
 800c0aa:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 800c0ac:	9b01      	ldr	r3, [sp, #4]
 800c0ae:	3301      	adds	r3, #1
 800c0b0:	9301      	str	r3, [sp, #4]
 800c0b2:	9b01      	ldr	r3, [sp, #4]
 800c0b4:	2b4b      	cmp	r3, #75	; 0x4b
 800c0b6:	d9f0      	bls.n	800c09a <print_line+0xa>
    chSequentialStreamPut(chp, '-');
  chSequentialStreamWrite(chp, (const uint8_t *)"\r\n", 2);
 800c0b8:	4b06      	ldr	r3, [pc, #24]	; (800c0d4 <print_line+0x44>)
 800c0ba:	681b      	ldr	r3, [r3, #0]
 800c0bc:	681b      	ldr	r3, [r3, #0]
 800c0be:	681b      	ldr	r3, [r3, #0]
 800c0c0:	4a04      	ldr	r2, [pc, #16]	; (800c0d4 <print_line+0x44>)
 800c0c2:	6812      	ldr	r2, [r2, #0]
 800c0c4:	4610      	mov	r0, r2
 800c0c6:	4904      	ldr	r1, [pc, #16]	; (800c0d8 <print_line+0x48>)
 800c0c8:	2202      	movs	r2, #2
 800c0ca:	4798      	blx	r3
}
 800c0cc:	b003      	add	sp, #12
 800c0ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800c0d2:	bf00      	nop
 800c0d4:	200013ec 	.word	0x200013ec
 800c0d8:	08019764 	.word	0x08019764
 800c0dc:	f3af 8000 	nop.w

0800c0e0 <TestThread>:
/**
 * @brief   Test execution thread function.
 *
 * @param[in] p         pointer to a @p BaseChannel object for test output
 */
void TestThread(void *p) {
 800c0e0:	b500      	push	{lr}
 800c0e2:	b085      	sub	sp, #20
 800c0e4:	9001      	str	r0, [sp, #4]
  int i, j;

  chp = p;
 800c0e6:	4b5f      	ldr	r3, [pc, #380]	; (800c264 <TestThread+0x184>)
 800c0e8:	9a01      	ldr	r2, [sp, #4]
 800c0ea:	601a      	str	r2, [r3, #0]
  test_println("");
 800c0ec:	485e      	ldr	r0, [pc, #376]	; (800c268 <TestThread+0x188>)
 800c0ee:	f7ff fe3f 	bl	800bd70 <test_println>
  test_println("*** ChibiOS/RT test suite");
 800c0f2:	485e      	ldr	r0, [pc, #376]	; (800c26c <TestThread+0x18c>)
 800c0f4:	f7ff fe3c 	bl	800bd70 <test_println>
  test_println("***");
 800c0f8:	485d      	ldr	r0, [pc, #372]	; (800c270 <TestThread+0x190>)
 800c0fa:	f7ff fe39 	bl	800bd70 <test_println>
  test_print("*** Kernel:       ");
 800c0fe:	485d      	ldr	r0, [pc, #372]	; (800c274 <TestThread+0x194>)
 800c100:	f7ff fe16 	bl	800bd30 <test_print>
  test_println(CH_KERNEL_VERSION);
 800c104:	485c      	ldr	r0, [pc, #368]	; (800c278 <TestThread+0x198>)
 800c106:	f7ff fe33 	bl	800bd70 <test_println>
  test_print("*** Compiled:     ");
 800c10a:	485c      	ldr	r0, [pc, #368]	; (800c27c <TestThread+0x19c>)
 800c10c:	f7ff fe10 	bl	800bd30 <test_print>
  test_println(__DATE__ " - " __TIME__);
 800c110:	485b      	ldr	r0, [pc, #364]	; (800c280 <TestThread+0x1a0>)
 800c112:	f7ff fe2d 	bl	800bd70 <test_println>
#ifdef PORT_COMPILER_NAME
  test_print("*** Compiler:     ");
 800c116:	485b      	ldr	r0, [pc, #364]	; (800c284 <TestThread+0x1a4>)
 800c118:	f7ff fe0a 	bl	800bd30 <test_print>
  test_println(PORT_COMPILER_NAME);
 800c11c:	485a      	ldr	r0, [pc, #360]	; (800c288 <TestThread+0x1a8>)
 800c11e:	f7ff fe27 	bl	800bd70 <test_println>
#endif
  test_print("*** Architecture: ");
 800c122:	485a      	ldr	r0, [pc, #360]	; (800c28c <TestThread+0x1ac>)
 800c124:	f7ff fe04 	bl	800bd30 <test_print>
  test_println(PORT_ARCHITECTURE_NAME);
 800c128:	4859      	ldr	r0, [pc, #356]	; (800c290 <TestThread+0x1b0>)
 800c12a:	f7ff fe21 	bl	800bd70 <test_println>
#ifdef PORT_CORE_VARIANT_NAME
  test_print("*** Core Variant: ");
 800c12e:	4859      	ldr	r0, [pc, #356]	; (800c294 <TestThread+0x1b4>)
 800c130:	f7ff fdfe 	bl	800bd30 <test_print>
  test_println(PORT_CORE_VARIANT_NAME);
 800c134:	4858      	ldr	r0, [pc, #352]	; (800c298 <TestThread+0x1b8>)
 800c136:	f7ff fe1b 	bl	800bd70 <test_println>
#endif
#ifdef PORT_INFO
  test_print("*** Port Info:    ");
 800c13a:	4858      	ldr	r0, [pc, #352]	; (800c29c <TestThread+0x1bc>)
 800c13c:	f7ff fdf8 	bl	800bd30 <test_print>
  test_println(PORT_INFO);
 800c140:	4857      	ldr	r0, [pc, #348]	; (800c2a0 <TestThread+0x1c0>)
 800c142:	f7ff fe15 	bl	800bd70 <test_println>
#endif
#ifdef PLATFORM_NAME
  test_print("*** Platform:     ");
 800c146:	4857      	ldr	r0, [pc, #348]	; (800c2a4 <TestThread+0x1c4>)
 800c148:	f7ff fdf2 	bl	800bd30 <test_print>
  test_println(PLATFORM_NAME);
 800c14c:	4856      	ldr	r0, [pc, #344]	; (800c2a8 <TestThread+0x1c8>)
 800c14e:	f7ff fe0f 	bl	800bd70 <test_println>
#endif
#ifdef BOARD_NAME
  test_print("*** Test Board:   ");
 800c152:	4856      	ldr	r0, [pc, #344]	; (800c2ac <TestThread+0x1cc>)
 800c154:	f7ff fdec 	bl	800bd30 <test_print>
  test_println(BOARD_NAME);
 800c158:	4855      	ldr	r0, [pc, #340]	; (800c2b0 <TestThread+0x1d0>)
 800c15a:	f7ff fe09 	bl	800bd70 <test_println>
#endif
  test_println("");
 800c15e:	4842      	ldr	r0, [pc, #264]	; (800c268 <TestThread+0x188>)
 800c160:	f7ff fe06 	bl	800bd70 <test_println>

  test_global_fail = FALSE;
 800c164:	4b53      	ldr	r3, [pc, #332]	; (800c2b4 <TestThread+0x1d4>)
 800c166:	2200      	movs	r2, #0
 800c168:	701a      	strb	r2, [r3, #0]
  i = 0;
 800c16a:	2300      	movs	r3, #0
 800c16c:	9303      	str	r3, [sp, #12]
  while (patterns[i]) {
 800c16e:	e05c      	b.n	800c22a <TestThread+0x14a>
    j = 0;
 800c170:	2300      	movs	r3, #0
 800c172:	9302      	str	r3, [sp, #8]
    while (patterns[i][j]) {
 800c174:	e04c      	b.n	800c210 <TestThread+0x130>
      print_line();
 800c176:	f7ff ff8b 	bl	800c090 <print_line>
      test_print("--- Test Case ");
 800c17a:	484f      	ldr	r0, [pc, #316]	; (800c2b8 <TestThread+0x1d8>)
 800c17c:	f7ff fdd8 	bl	800bd30 <test_print>
      test_printn(i + 1);
 800c180:	9b03      	ldr	r3, [sp, #12]
 800c182:	3301      	adds	r3, #1
 800c184:	4618      	mov	r0, r3
 800c186:	f7ff fd8b 	bl	800bca0 <test_printn>
      test_print(".");
 800c18a:	484c      	ldr	r0, [pc, #304]	; (800c2bc <TestThread+0x1dc>)
 800c18c:	f7ff fdd0 	bl	800bd30 <test_print>
      test_printn(j + 1);
 800c190:	9b02      	ldr	r3, [sp, #8]
 800c192:	3301      	adds	r3, #1
 800c194:	4618      	mov	r0, r3
 800c196:	f7ff fd83 	bl	800bca0 <test_printn>
      test_print(" (");
 800c19a:	4849      	ldr	r0, [pc, #292]	; (800c2c0 <TestThread+0x1e0>)
 800c19c:	f7ff fdc8 	bl	800bd30 <test_print>
      test_print(patterns[i][j]->name);
 800c1a0:	4b48      	ldr	r3, [pc, #288]	; (800c2c4 <TestThread+0x1e4>)
 800c1a2:	9a03      	ldr	r2, [sp, #12]
 800c1a4:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c1a8:	9b02      	ldr	r3, [sp, #8]
 800c1aa:	009b      	lsls	r3, r3, #2
 800c1ac:	4413      	add	r3, r2
 800c1ae:	681b      	ldr	r3, [r3, #0]
 800c1b0:	681b      	ldr	r3, [r3, #0]
 800c1b2:	4618      	mov	r0, r3
 800c1b4:	f7ff fdbc 	bl	800bd30 <test_print>
      test_println(")");
 800c1b8:	4843      	ldr	r0, [pc, #268]	; (800c2c8 <TestThread+0x1e8>)
 800c1ba:	f7ff fdd9 	bl	800bd70 <test_println>
#if DELAY_BETWEEN_TESTS > 0
      chThdSleepMilliseconds(DELAY_BETWEEN_TESTS);
 800c1be:	20c8      	movs	r0, #200	; 0xc8
 800c1c0:	f7f5 f886 	bl	80012d0 <chThdSleep>
#endif
      execute_test(patterns[i][j]);
 800c1c4:	4b3f      	ldr	r3, [pc, #252]	; (800c2c4 <TestThread+0x1e4>)
 800c1c6:	9a03      	ldr	r2, [sp, #12]
 800c1c8:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c1cc:	9b02      	ldr	r3, [sp, #8]
 800c1ce:	009b      	lsls	r3, r3, #2
 800c1d0:	4413      	add	r3, r2
 800c1d2:	681b      	ldr	r3, [r3, #0]
 800c1d4:	4618      	mov	r0, r3
 800c1d6:	f7ff ff2b 	bl	800c030 <execute_test>
      if (local_fail) {
 800c1da:	4b3c      	ldr	r3, [pc, #240]	; (800c2cc <TestThread+0x1ec>)
 800c1dc:	781b      	ldrb	r3, [r3, #0]
 800c1de:	2b00      	cmp	r3, #0
 800c1e0:	d010      	beq.n	800c204 <TestThread+0x124>
        test_print("--- Result: FAILURE (#");
 800c1e2:	483b      	ldr	r0, [pc, #236]	; (800c2d0 <TestThread+0x1f0>)
 800c1e4:	f7ff fda4 	bl	800bd30 <test_print>
        test_printn(failpoint);
 800c1e8:	4b3a      	ldr	r3, [pc, #232]	; (800c2d4 <TestThread+0x1f4>)
 800c1ea:	681b      	ldr	r3, [r3, #0]
 800c1ec:	4618      	mov	r0, r3
 800c1ee:	f7ff fd57 	bl	800bca0 <test_printn>
        test_print(" [");
 800c1f2:	4839      	ldr	r0, [pc, #228]	; (800c2d8 <TestThread+0x1f8>)
 800c1f4:	f7ff fd9c 	bl	800bd30 <test_print>
        print_tokens();
 800c1f8:	f7ff fdda 	bl	800bdb0 <print_tokens>
        test_println("])");
 800c1fc:	4837      	ldr	r0, [pc, #220]	; (800c2dc <TestThread+0x1fc>)
 800c1fe:	f7ff fdb7 	bl	800bd70 <test_println>
 800c202:	e002      	b.n	800c20a <TestThread+0x12a>
      }
      else
        test_println("--- Result: SUCCESS");
 800c204:	4836      	ldr	r0, [pc, #216]	; (800c2e0 <TestThread+0x200>)
 800c206:	f7ff fdb3 	bl	800bd70 <test_println>
      j++;
 800c20a:	9b02      	ldr	r3, [sp, #8]
 800c20c:	3301      	adds	r3, #1
 800c20e:	9302      	str	r3, [sp, #8]

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
    j = 0;
    while (patterns[i][j]) {
 800c210:	4b2c      	ldr	r3, [pc, #176]	; (800c2c4 <TestThread+0x1e4>)
 800c212:	9a03      	ldr	r2, [sp, #12]
 800c214:	f853 2022 	ldr.w	r2, [r3, r2, lsl #2]
 800c218:	9b02      	ldr	r3, [sp, #8]
 800c21a:	009b      	lsls	r3, r3, #2
 800c21c:	4413      	add	r3, r2
 800c21e:	681b      	ldr	r3, [r3, #0]
 800c220:	2b00      	cmp	r3, #0
 800c222:	d1a8      	bne.n	800c176 <TestThread+0x96>
      }
      else
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
 800c224:	9b03      	ldr	r3, [sp, #12]
 800c226:	3301      	adds	r3, #1
 800c228:	9303      	str	r3, [sp, #12]
#endif
  test_println("");

  test_global_fail = FALSE;
  i = 0;
  while (patterns[i]) {
 800c22a:	4b26      	ldr	r3, [pc, #152]	; (800c2c4 <TestThread+0x1e4>)
 800c22c:	9a03      	ldr	r2, [sp, #12]
 800c22e:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800c232:	2b00      	cmp	r3, #0
 800c234:	d19c      	bne.n	800c170 <TestThread+0x90>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800c236:	f7ff ff2b 	bl	800c090 <print_line>
  test_println("");
 800c23a:	480b      	ldr	r0, [pc, #44]	; (800c268 <TestThread+0x188>)
 800c23c:	f7ff fd98 	bl	800bd70 <test_println>
  test_print("Final result: ");
 800c240:	4828      	ldr	r0, [pc, #160]	; (800c2e4 <TestThread+0x204>)
 800c242:	f7ff fd75 	bl	800bd30 <test_print>
  if (test_global_fail)
 800c246:	4b1b      	ldr	r3, [pc, #108]	; (800c2b4 <TestThread+0x1d4>)
 800c248:	781b      	ldrb	r3, [r3, #0]
 800c24a:	2b00      	cmp	r3, #0
 800c24c:	d003      	beq.n	800c256 <TestThread+0x176>
    test_println("FAILURE");
 800c24e:	4826      	ldr	r0, [pc, #152]	; (800c2e8 <TestThread+0x208>)
 800c250:	f7ff fd8e 	bl	800bd70 <test_println>
 800c254:	e002      	b.n	800c25c <TestThread+0x17c>
  else
    test_println("SUCCESS");
 800c256:	4825      	ldr	r0, [pc, #148]	; (800c2ec <TestThread+0x20c>)
 800c258:	f7ff fd8a 	bl	800bd70 <test_println>
}
 800c25c:	b005      	add	sp, #20
 800c25e:	f85d fb04 	ldr.w	pc, [sp], #4
 800c262:	bf00      	nop
 800c264:	200013ec 	.word	0x200013ec
 800c268:	08019768 	.word	0x08019768
 800c26c:	0801976c 	.word	0x0801976c
 800c270:	08019788 	.word	0x08019788
 800c274:	0801978c 	.word	0x0801978c
 800c278:	080197a0 	.word	0x080197a0
 800c27c:	080197a8 	.word	0x080197a8
 800c280:	080197bc 	.word	0x080197bc
 800c284:	080197d4 	.word	0x080197d4
 800c288:	080197e8 	.word	0x080197e8
 800c28c:	08019830 	.word	0x08019830
 800c290:	08019844 	.word	0x08019844
 800c294:	08019850 	.word	0x08019850
 800c298:	08019864 	.word	0x08019864
 800c29c:	08019870 	.word	0x08019870
 800c2a0:	08019884 	.word	0x08019884
 800c2a4:	0801989c 	.word	0x0801989c
 800c2a8:	080198b0 	.word	0x080198b0
 800c2ac:	080198cc 	.word	0x080198cc
 800c2b0:	080198e0 	.word	0x080198e0
 800c2b4:	20002058 	.word	0x20002058
 800c2b8:	080198f0 	.word	0x080198f0
 800c2bc:	08019900 	.word	0x08019900
 800c2c0:	08019904 	.word	0x08019904
 800c2c4:	20000804 	.word	0x20000804
 800c2c8:	08019908 	.word	0x08019908
 800c2cc:	200013d0 	.word	0x200013d0
 800c2d0:	0801990c 	.word	0x0801990c
 800c2d4:	200013d4 	.word	0x200013d4
 800c2d8:	08019924 	.word	0x08019924
 800c2dc:	08019928 	.word	0x08019928
 800c2e0:	0801992c 	.word	0x0801992c
 800c2e4:	08019940 	.word	0x08019940
 800c2e8:	08019950 	.word	0x08019950
 800c2ec:	08019958 	.word	0x08019958

0800c2f0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c2f0:	b082      	sub	sp, #8
 800c2f2:	2320      	movs	r3, #32
 800c2f4:	9301      	str	r3, [sp, #4]
 800c2f6:	9b01      	ldr	r3, [sp, #4]
 800c2f8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c2fc:	b002      	add	sp, #8
 800c2fe:	4770      	bx	lr

0800c300 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c300:	b082      	sub	sp, #8
 800c302:	2300      	movs	r3, #0
 800c304:	9301      	str	r3, [sp, #4]
 800c306:	9b01      	ldr	r3, [sp, #4]
 800c308:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c30c:	b002      	add	sp, #8
 800c30e:	4770      	bx	lr

0800c310 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c310:	b508      	push	{r3, lr}

  port_lock();
 800c312:	f7ff ffed 	bl	800c2f0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c316:	bd08      	pop	{r3, pc}
 800c318:	f3af 8000 	nop.w
 800c31c:	f3af 8000 	nop.w

0800c320 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c320:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c322:	f7ff ffed 	bl	800c300 <port_unlock>
}
 800c326:	bd08      	pop	{r3, pc}
 800c328:	f3af 8000 	nop.w
 800c32c:	f3af 8000 	nop.w

0800c330 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c330:	4b01      	ldr	r3, [pc, #4]	; (800c338 <chVTGetSystemTimeX+0x8>)
 800c332:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c334:	4618      	mov	r0, r3
 800c336:	4770      	bx	lr
 800c338:	20001bc8 	.word	0x20001bc8
 800c33c:	f3af 8000 	nop.w

0800c340 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c340:	b500      	push	{lr}
 800c342:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c344:	f7ff ffe4 	bl	800c310 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c348:	f7ff fff2 	bl	800c330 <chVTGetSystemTimeX>
 800c34c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c34e:	f7ff ffe7 	bl	800c320 <chSysUnlock>

  return systime;
 800c352:	9b01      	ldr	r3, [sp, #4]
}
 800c354:	4618      	mov	r0, r3
 800c356:	b003      	add	sp, #12
 800c358:	f85d fb04 	ldr.w	pc, [sp], #4
 800c35c:	f3af 8000 	nop.w

0800c360 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c360:	4b01      	ldr	r3, [pc, #4]	; (800c368 <chThdGetSelfX+0x8>)
 800c362:	699b      	ldr	r3, [r3, #24]
}
 800c364:	4618      	mov	r0, r3
 800c366:	4770      	bx	lr
 800c368:	20001bc8 	.word	0x20001bc8
 800c36c:	f3af 8000 	nop.w

0800c370 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c370:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c372:	f7ff fff5 	bl	800c360 <chThdGetSelfX>
 800c376:	4603      	mov	r3, r0
 800c378:	689b      	ldr	r3, [r3, #8]
}
 800c37a:	4618      	mov	r0, r3
 800c37c:	bd08      	pop	{r3, pc}
 800c37e:	bf00      	nop

0800c380 <thread>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static THD_FUNCTION(thread, p) {
 800c380:	b500      	push	{lr}
 800c382:	b083      	sub	sp, #12
 800c384:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800c386:	9b01      	ldr	r3, [sp, #4]
 800c388:	781b      	ldrb	r3, [r3, #0]
 800c38a:	4618      	mov	r0, r3
 800c38c:	f7ff fd30 	bl	800bdf0 <test_emit_token>
}
 800c390:	b003      	add	sp, #12
 800c392:	f85d fb04 	ldr.w	pc, [sp], #4
 800c396:	bf00      	nop
 800c398:	f3af 8000 	nop.w
 800c39c:	f3af 8000 	nop.w

0800c3a0 <thd1_execute>:

static void thd1_execute(void) {
 800c3a0:	b510      	push	{r4, lr}
 800c3a2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c3a4:	4b32      	ldr	r3, [pc, #200]	; (800c470 <thd1_execute+0xd0>)
 800c3a6:	681c      	ldr	r4, [r3, #0]
 800c3a8:	f7ff ffe2 	bl	800c370 <chThdGetPriorityX>
 800c3ac:	4603      	mov	r3, r0
 800c3ae:	3b05      	subs	r3, #5
 800c3b0:	4a30      	ldr	r2, [pc, #192]	; (800c474 <thd1_execute+0xd4>)
 800c3b2:	9200      	str	r2, [sp, #0]
 800c3b4:	4620      	mov	r0, r4
 800c3b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c3ba:	461a      	mov	r2, r3
 800c3bc:	4b2e      	ldr	r3, [pc, #184]	; (800c478 <thd1_execute+0xd8>)
 800c3be:	f7f4 ff0f 	bl	80011e0 <chThdCreateStatic>
 800c3c2:	4602      	mov	r2, r0
 800c3c4:	4b2d      	ldr	r3, [pc, #180]	; (800c47c <thd1_execute+0xdc>)
 800c3c6:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c3c8:	4b29      	ldr	r3, [pc, #164]	; (800c470 <thd1_execute+0xd0>)
 800c3ca:	685c      	ldr	r4, [r3, #4]
 800c3cc:	f7ff ffd0 	bl	800c370 <chThdGetPriorityX>
 800c3d0:	4603      	mov	r3, r0
 800c3d2:	3b04      	subs	r3, #4
 800c3d4:	4a2a      	ldr	r2, [pc, #168]	; (800c480 <thd1_execute+0xe0>)
 800c3d6:	9200      	str	r2, [sp, #0]
 800c3d8:	4620      	mov	r0, r4
 800c3da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c3de:	461a      	mov	r2, r3
 800c3e0:	4b25      	ldr	r3, [pc, #148]	; (800c478 <thd1_execute+0xd8>)
 800c3e2:	f7f4 fefd 	bl	80011e0 <chThdCreateStatic>
 800c3e6:	4602      	mov	r2, r0
 800c3e8:	4b24      	ldr	r3, [pc, #144]	; (800c47c <thd1_execute+0xdc>)
 800c3ea:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c3ec:	4b20      	ldr	r3, [pc, #128]	; (800c470 <thd1_execute+0xd0>)
 800c3ee:	689c      	ldr	r4, [r3, #8]
 800c3f0:	f7ff ffbe 	bl	800c370 <chThdGetPriorityX>
 800c3f4:	4603      	mov	r3, r0
 800c3f6:	3b03      	subs	r3, #3
 800c3f8:	4a22      	ldr	r2, [pc, #136]	; (800c484 <thd1_execute+0xe4>)
 800c3fa:	9200      	str	r2, [sp, #0]
 800c3fc:	4620      	mov	r0, r4
 800c3fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c402:	461a      	mov	r2, r3
 800c404:	4b1c      	ldr	r3, [pc, #112]	; (800c478 <thd1_execute+0xd8>)
 800c406:	f7f4 feeb 	bl	80011e0 <chThdCreateStatic>
 800c40a:	4602      	mov	r2, r0
 800c40c:	4b1b      	ldr	r3, [pc, #108]	; (800c47c <thd1_execute+0xdc>)
 800c40e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c410:	4b17      	ldr	r3, [pc, #92]	; (800c470 <thd1_execute+0xd0>)
 800c412:	68dc      	ldr	r4, [r3, #12]
 800c414:	f7ff ffac 	bl	800c370 <chThdGetPriorityX>
 800c418:	4603      	mov	r3, r0
 800c41a:	3b02      	subs	r3, #2
 800c41c:	4a1a      	ldr	r2, [pc, #104]	; (800c488 <thd1_execute+0xe8>)
 800c41e:	9200      	str	r2, [sp, #0]
 800c420:	4620      	mov	r0, r4
 800c422:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c426:	461a      	mov	r2, r3
 800c428:	4b13      	ldr	r3, [pc, #76]	; (800c478 <thd1_execute+0xd8>)
 800c42a:	f7f4 fed9 	bl	80011e0 <chThdCreateStatic>
 800c42e:	4602      	mov	r2, r0
 800c430:	4b12      	ldr	r3, [pc, #72]	; (800c47c <thd1_execute+0xdc>)
 800c432:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c434:	4b0e      	ldr	r3, [pc, #56]	; (800c470 <thd1_execute+0xd0>)
 800c436:	691c      	ldr	r4, [r3, #16]
 800c438:	f7ff ff9a 	bl	800c370 <chThdGetPriorityX>
 800c43c:	4603      	mov	r3, r0
 800c43e:	3b01      	subs	r3, #1
 800c440:	4a12      	ldr	r2, [pc, #72]	; (800c48c <thd1_execute+0xec>)
 800c442:	9200      	str	r2, [sp, #0]
 800c444:	4620      	mov	r0, r4
 800c446:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c44a:	461a      	mov	r2, r3
 800c44c:	4b0a      	ldr	r3, [pc, #40]	; (800c478 <thd1_execute+0xd8>)
 800c44e:	f7f4 fec7 	bl	80011e0 <chThdCreateStatic>
 800c452:	4602      	mov	r2, r0
 800c454:	4b09      	ldr	r3, [pc, #36]	; (800c47c <thd1_execute+0xdc>)
 800c456:	611a      	str	r2, [r3, #16]
  test_wait_threads();
 800c458:	f7ff fd7a 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c45c:	2001      	movs	r0, #1
 800c45e:	490c      	ldr	r1, [pc, #48]	; (800c490 <thd1_execute+0xf0>)
 800c460:	f7ff fd0e 	bl	800be80 <_test_assert_sequence>
 800c464:	4603      	mov	r3, r0
 800c466:	2b00      	cmp	r3, #0
 800c468:	d000      	beq.n	800c46c <thd1_execute+0xcc>
 800c46a:	bf00      	nop
}
 800c46c:	b002      	add	sp, #8
 800c46e:	bd10      	pop	{r4, pc}
 800c470:	08019750 	.word	0x08019750
 800c474:	08019960 	.word	0x08019960
 800c478:	0800c381 	.word	0x0800c381
 800c47c:	2000205c 	.word	0x2000205c
 800c480:	08019964 	.word	0x08019964
 800c484:	08019968 	.word	0x08019968
 800c488:	0801996c 	.word	0x0801996c
 800c48c:	08019970 	.word	0x08019970
 800c490:	08019974 	.word	0x08019974
 800c494:	f3af 8000 	nop.w
 800c498:	f3af 8000 	nop.w
 800c49c:	f3af 8000 	nop.w

0800c4a0 <thd2_execute>:
 * and atomically executed.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void thd2_execute(void) {
 800c4a0:	b510      	push	{r4, lr}
 800c4a2:	b082      	sub	sp, #8

  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 800c4a4:	4b37      	ldr	r3, [pc, #220]	; (800c584 <thd2_execute+0xe4>)
 800c4a6:	685c      	ldr	r4, [r3, #4]
 800c4a8:	f7ff ff62 	bl	800c370 <chThdGetPriorityX>
 800c4ac:	4603      	mov	r3, r0
 800c4ae:	3b04      	subs	r3, #4
 800c4b0:	4a35      	ldr	r2, [pc, #212]	; (800c588 <thd2_execute+0xe8>)
 800c4b2:	9200      	str	r2, [sp, #0]
 800c4b4:	4620      	mov	r0, r4
 800c4b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4ba:	461a      	mov	r2, r3
 800c4bc:	4b33      	ldr	r3, [pc, #204]	; (800c58c <thd2_execute+0xec>)
 800c4be:	f7f4 fe8f 	bl	80011e0 <chThdCreateStatic>
 800c4c2:	4602      	mov	r2, r0
 800c4c4:	4b32      	ldr	r3, [pc, #200]	; (800c590 <thd2_execute+0xf0>)
 800c4c6:	605a      	str	r2, [r3, #4]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 800c4c8:	4b2e      	ldr	r3, [pc, #184]	; (800c584 <thd2_execute+0xe4>)
 800c4ca:	681c      	ldr	r4, [r3, #0]
 800c4cc:	f7ff ff50 	bl	800c370 <chThdGetPriorityX>
 800c4d0:	4603      	mov	r3, r0
 800c4d2:	3b05      	subs	r3, #5
 800c4d4:	4a2f      	ldr	r2, [pc, #188]	; (800c594 <thd2_execute+0xf4>)
 800c4d6:	9200      	str	r2, [sp, #0]
 800c4d8:	4620      	mov	r0, r4
 800c4da:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c4de:	461a      	mov	r2, r3
 800c4e0:	4b2a      	ldr	r3, [pc, #168]	; (800c58c <thd2_execute+0xec>)
 800c4e2:	f7f4 fe7d 	bl	80011e0 <chThdCreateStatic>
 800c4e6:	4602      	mov	r2, r0
 800c4e8:	4b29      	ldr	r3, [pc, #164]	; (800c590 <thd2_execute+0xf0>)
 800c4ea:	601a      	str	r2, [r3, #0]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 800c4ec:	4b25      	ldr	r3, [pc, #148]	; (800c584 <thd2_execute+0xe4>)
 800c4ee:	691c      	ldr	r4, [r3, #16]
 800c4f0:	f7ff ff3e 	bl	800c370 <chThdGetPriorityX>
 800c4f4:	4603      	mov	r3, r0
 800c4f6:	3b01      	subs	r3, #1
 800c4f8:	4a27      	ldr	r2, [pc, #156]	; (800c598 <thd2_execute+0xf8>)
 800c4fa:	9200      	str	r2, [sp, #0]
 800c4fc:	4620      	mov	r0, r4
 800c4fe:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c502:	461a      	mov	r2, r3
 800c504:	4b21      	ldr	r3, [pc, #132]	; (800c58c <thd2_execute+0xec>)
 800c506:	f7f4 fe6b 	bl	80011e0 <chThdCreateStatic>
 800c50a:	4602      	mov	r2, r0
 800c50c:	4b20      	ldr	r3, [pc, #128]	; (800c590 <thd2_execute+0xf0>)
 800c50e:	611a      	str	r2, [r3, #16]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800c510:	4b1c      	ldr	r3, [pc, #112]	; (800c584 <thd2_execute+0xe4>)
 800c512:	68dc      	ldr	r4, [r3, #12]
 800c514:	f7ff ff2c 	bl	800c370 <chThdGetPriorityX>
 800c518:	4603      	mov	r3, r0
 800c51a:	3b02      	subs	r3, #2
 800c51c:	4a1f      	ldr	r2, [pc, #124]	; (800c59c <thd2_execute+0xfc>)
 800c51e:	9200      	str	r2, [sp, #0]
 800c520:	4620      	mov	r0, r4
 800c522:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c526:	461a      	mov	r2, r3
 800c528:	4b18      	ldr	r3, [pc, #96]	; (800c58c <thd2_execute+0xec>)
 800c52a:	f7f4 fe59 	bl	80011e0 <chThdCreateStatic>
 800c52e:	4602      	mov	r2, r0
 800c530:	4b17      	ldr	r3, [pc, #92]	; (800c590 <thd2_execute+0xf0>)
 800c532:	60da      	str	r2, [r3, #12]
  /* Done this way for coverage of chThdCreateI() and chThdStart().*/
  chSysLock();
 800c534:	f7ff feec 	bl	800c310 <chSysLock>
  threads[2] = chThdCreateI(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 800c538:	4b12      	ldr	r3, [pc, #72]	; (800c584 <thd2_execute+0xe4>)
 800c53a:	689c      	ldr	r4, [r3, #8]
 800c53c:	f7ff ff18 	bl	800c370 <chThdGetPriorityX>
 800c540:	4603      	mov	r3, r0
 800c542:	3b03      	subs	r3, #3
 800c544:	4a16      	ldr	r2, [pc, #88]	; (800c5a0 <thd2_execute+0x100>)
 800c546:	9200      	str	r2, [sp, #0]
 800c548:	4620      	mov	r0, r4
 800c54a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800c54e:	461a      	mov	r2, r3
 800c550:	4b0e      	ldr	r3, [pc, #56]	; (800c58c <thd2_execute+0xec>)
 800c552:	f7f4 fe1d 	bl	8001190 <chThdCreateI>
 800c556:	4602      	mov	r2, r0
 800c558:	4b0d      	ldr	r3, [pc, #52]	; (800c590 <thd2_execute+0xf0>)
 800c55a:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c55c:	f7ff fee0 	bl	800c320 <chSysUnlock>
  chThdStart(threads[2]);
 800c560:	4b0b      	ldr	r3, [pc, #44]	; (800c590 <thd2_execute+0xf0>)
 800c562:	689b      	ldr	r3, [r3, #8]
 800c564:	4618      	mov	r0, r3
 800c566:	f7f4 fe5b 	bl	8001220 <chThdStart>
  test_wait_threads();
 800c56a:	f7ff fcf1 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800c56e:	2001      	movs	r0, #1
 800c570:	490c      	ldr	r1, [pc, #48]	; (800c5a4 <thd2_execute+0x104>)
 800c572:	f7ff fc85 	bl	800be80 <_test_assert_sequence>
 800c576:	4603      	mov	r3, r0
 800c578:	2b00      	cmp	r3, #0
 800c57a:	d000      	beq.n	800c57e <thd2_execute+0xde>
 800c57c:	bf00      	nop
}
 800c57e:	b002      	add	sp, #8
 800c580:	bd10      	pop	{r4, pc}
 800c582:	bf00      	nop
 800c584:	08019750 	.word	0x08019750
 800c588:	08019964 	.word	0x08019964
 800c58c:	0800c381 	.word	0x0800c381
 800c590:	2000205c 	.word	0x2000205c
 800c594:	08019960 	.word	0x08019960
 800c598:	08019970 	.word	0x08019970
 800c59c:	0801996c 	.word	0x0801996c
 800c5a0:	08019968 	.word	0x08019968
 800c5a4:	08019974 	.word	0x08019974
 800c5a8:	f3af 8000 	nop.w
 800c5ac:	f3af 8000 	nop.w

0800c5b0 <thd3_execute>:
 * to verify that the priority change happens as expected.<br>
 * If the @p CH_CFG_USE_MUTEXES option is enabled then the priority changes are
 * also tested under priority inheritance boosted priority state.
 */

static void thd3_execute(void) {
 800c5b0:	b500      	push	{lr}
 800c5b2:	b083      	sub	sp, #12
  tprio_t prio, p1;

  prio = chThdGetPriorityX();
 800c5b4:	f7ff fedc 	bl	800c370 <chThdGetPriorityX>
 800c5b8:	9001      	str	r0, [sp, #4]
  p1 = chThdSetPriority(prio + 1);
 800c5ba:	9b01      	ldr	r3, [sp, #4]
 800c5bc:	3301      	adds	r3, #1
 800c5be:	4618      	mov	r0, r3
 800c5c0:	f7f4 fe3e 	bl	8001240 <chThdSetPriority>
 800c5c4:	9000      	str	r0, [sp, #0]
  test_assert(1, p1 == prio,
 800c5c6:	9a00      	ldr	r2, [sp, #0]
 800c5c8:	9b01      	ldr	r3, [sp, #4]
 800c5ca:	429a      	cmp	r2, r3
 800c5cc:	bf14      	ite	ne
 800c5ce:	2300      	movne	r3, #0
 800c5d0:	2301      	moveq	r3, #1
 800c5d2:	b2db      	uxtb	r3, r3
 800c5d4:	2001      	movs	r0, #1
 800c5d6:	4619      	mov	r1, r3
 800c5d8:	f7ff fc3a 	bl	800be50 <_test_assert>
 800c5dc:	4603      	mov	r3, r0
 800c5de:	2b00      	cmp	r3, #0
 800c5e0:	d000      	beq.n	800c5e4 <thd3_execute+0x34>
 800c5e2:	e0d7      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(2, chThdGetPriorityX() == prio + 1,
 800c5e4:	f7ff fec4 	bl	800c370 <chThdGetPriorityX>
 800c5e8:	4602      	mov	r2, r0
 800c5ea:	9b01      	ldr	r3, [sp, #4]
 800c5ec:	3301      	adds	r3, #1
 800c5ee:	429a      	cmp	r2, r3
 800c5f0:	bf14      	ite	ne
 800c5f2:	2300      	movne	r3, #0
 800c5f4:	2301      	moveq	r3, #1
 800c5f6:	b2db      	uxtb	r3, r3
 800c5f8:	2002      	movs	r0, #2
 800c5fa:	4619      	mov	r1, r3
 800c5fc:	f7ff fc28 	bl	800be50 <_test_assert>
 800c600:	4603      	mov	r3, r0
 800c602:	2b00      	cmp	r3, #0
 800c604:	d000      	beq.n	800c608 <thd3_execute+0x58>
 800c606:	e0c5      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  p1 = chThdSetPriority(p1);
 800c608:	9800      	ldr	r0, [sp, #0]
 800c60a:	f7f4 fe19 	bl	8001240 <chThdSetPriority>
 800c60e:	9000      	str	r0, [sp, #0]
  test_assert(3, p1 == prio + 1,
 800c610:	9b01      	ldr	r3, [sp, #4]
 800c612:	1c5a      	adds	r2, r3, #1
 800c614:	9b00      	ldr	r3, [sp, #0]
 800c616:	429a      	cmp	r2, r3
 800c618:	bf14      	ite	ne
 800c61a:	2300      	movne	r3, #0
 800c61c:	2301      	moveq	r3, #1
 800c61e:	b2db      	uxtb	r3, r3
 800c620:	2003      	movs	r0, #3
 800c622:	4619      	mov	r1, r3
 800c624:	f7ff fc14 	bl	800be50 <_test_assert>
 800c628:	4603      	mov	r3, r0
 800c62a:	2b00      	cmp	r3, #0
 800c62c:	d000      	beq.n	800c630 <thd3_execute+0x80>
 800c62e:	e0b1      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(4, chThdGetPriorityX() == prio,
 800c630:	f7ff fe9e 	bl	800c370 <chThdGetPriorityX>
 800c634:	4602      	mov	r2, r0
 800c636:	9b01      	ldr	r3, [sp, #4]
 800c638:	429a      	cmp	r2, r3
 800c63a:	bf14      	ite	ne
 800c63c:	2300      	movne	r3, #0
 800c63e:	2301      	moveq	r3, #1
 800c640:	b2db      	uxtb	r3, r3
 800c642:	2004      	movs	r0, #4
 800c644:	4619      	mov	r1, r3
 800c646:	f7ff fc03 	bl	800be50 <_test_assert>
 800c64a:	4603      	mov	r3, r0
 800c64c:	2b00      	cmp	r3, #0
 800c64e:	d000      	beq.n	800c652 <thd3_execute+0xa2>
 800c650:	e0a0      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");

#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  /* Simulates a priority boost situation (p_prio > p_realprio).*/
  chSysLock();
 800c652:	f7ff fe5d 	bl	800c310 <chSysLock>
  chThdGetSelfX()->p_prio += 2;
 800c656:	f7ff fe83 	bl	800c360 <chThdGetSelfX>
 800c65a:	4603      	mov	r3, r0
 800c65c:	689a      	ldr	r2, [r3, #8]
 800c65e:	3202      	adds	r2, #2
 800c660:	609a      	str	r2, [r3, #8]
  chSysUnlock();
 800c662:	f7ff fe5d 	bl	800c320 <chSysUnlock>
  test_assert(5, chThdGetPriorityX() == prio + 2,
 800c666:	f7ff fe83 	bl	800c370 <chThdGetPriorityX>
 800c66a:	4602      	mov	r2, r0
 800c66c:	9b01      	ldr	r3, [sp, #4]
 800c66e:	3302      	adds	r3, #2
 800c670:	429a      	cmp	r2, r3
 800c672:	bf14      	ite	ne
 800c674:	2300      	movne	r3, #0
 800c676:	2301      	moveq	r3, #1
 800c678:	b2db      	uxtb	r3, r3
 800c67a:	2005      	movs	r0, #5
 800c67c:	4619      	mov	r1, r3
 800c67e:	f7ff fbe7 	bl	800be50 <_test_assert>
 800c682:	4603      	mov	r3, r0
 800c684:	2b00      	cmp	r3, #0
 800c686:	d000      	beq.n	800c68a <thd3_execute+0xda>
 800c688:	e084      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");

  /* Tries to raise but below the boost level. */
  p1 = chThdSetPriority(prio + 1);
 800c68a:	9b01      	ldr	r3, [sp, #4]
 800c68c:	3301      	adds	r3, #1
 800c68e:	4618      	mov	r0, r3
 800c690:	f7f4 fdd6 	bl	8001240 <chThdSetPriority>
 800c694:	9000      	str	r0, [sp, #0]
  test_assert(6, p1 == prio,
 800c696:	9a00      	ldr	r2, [sp, #0]
 800c698:	9b01      	ldr	r3, [sp, #4]
 800c69a:	429a      	cmp	r2, r3
 800c69c:	bf14      	ite	ne
 800c69e:	2300      	movne	r3, #0
 800c6a0:	2301      	moveq	r3, #1
 800c6a2:	b2db      	uxtb	r3, r3
 800c6a4:	2006      	movs	r0, #6
 800c6a6:	4619      	mov	r1, r3
 800c6a8:	f7ff fbd2 	bl	800be50 <_test_assert>
 800c6ac:	4603      	mov	r3, r0
 800c6ae:	2b00      	cmp	r3, #0
 800c6b0:	d000      	beq.n	800c6b4 <thd3_execute+0x104>
 800c6b2:	e06f      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(7, chThdGetSelfX()->p_prio == prio + 2,
 800c6b4:	f7ff fe54 	bl	800c360 <chThdGetSelfX>
 800c6b8:	4603      	mov	r3, r0
 800c6ba:	689a      	ldr	r2, [r3, #8]
 800c6bc:	9b01      	ldr	r3, [sp, #4]
 800c6be:	3302      	adds	r3, #2
 800c6c0:	429a      	cmp	r2, r3
 800c6c2:	bf14      	ite	ne
 800c6c4:	2300      	movne	r3, #0
 800c6c6:	2301      	moveq	r3, #1
 800c6c8:	b2db      	uxtb	r3, r3
 800c6ca:	2007      	movs	r0, #7
 800c6cc:	4619      	mov	r1, r3
 800c6ce:	f7ff fbbf 	bl	800be50 <_test_assert>
 800c6d2:	4603      	mov	r3, r0
 800c6d4:	2b00      	cmp	r3, #0
 800c6d6:	d000      	beq.n	800c6da <thd3_execute+0x12a>
 800c6d8:	e05c      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(8, chThdGetSelfX()->p_realprio == prio + 1,
 800c6da:	f7ff fe41 	bl	800c360 <chThdGetSelfX>
 800c6de:	4603      	mov	r3, r0
 800c6e0:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c6e2:	9b01      	ldr	r3, [sp, #4]
 800c6e4:	3301      	adds	r3, #1
 800c6e6:	429a      	cmp	r2, r3
 800c6e8:	bf14      	ite	ne
 800c6ea:	2300      	movne	r3, #0
 800c6ec:	2301      	moveq	r3, #1
 800c6ee:	b2db      	uxtb	r3, r3
 800c6f0:	2008      	movs	r0, #8
 800c6f2:	4619      	mov	r1, r3
 800c6f4:	f7ff fbac 	bl	800be50 <_test_assert>
 800c6f8:	4603      	mov	r3, r0
 800c6fa:	2b00      	cmp	r3, #0
 800c6fc:	d000      	beq.n	800c700 <thd3_execute+0x150>
 800c6fe:	e049      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned real priority level");

  /* Tries to raise above the boost level. */
  p1 = chThdSetPriority(prio + 3);
 800c700:	9b01      	ldr	r3, [sp, #4]
 800c702:	3303      	adds	r3, #3
 800c704:	4618      	mov	r0, r3
 800c706:	f7f4 fd9b 	bl	8001240 <chThdSetPriority>
 800c70a:	9000      	str	r0, [sp, #0]
  test_assert(9, p1 == prio + 1,
 800c70c:	9b01      	ldr	r3, [sp, #4]
 800c70e:	1c5a      	adds	r2, r3, #1
 800c710:	9b00      	ldr	r3, [sp, #0]
 800c712:	429a      	cmp	r2, r3
 800c714:	bf14      	ite	ne
 800c716:	2300      	movne	r3, #0
 800c718:	2301      	moveq	r3, #1
 800c71a:	b2db      	uxtb	r3, r3
 800c71c:	2009      	movs	r0, #9
 800c71e:	4619      	mov	r1, r3
 800c720:	f7ff fb96 	bl	800be50 <_test_assert>
 800c724:	4603      	mov	r3, r0
 800c726:	2b00      	cmp	r3, #0
 800c728:	d000      	beq.n	800c72c <thd3_execute+0x17c>
 800c72a:	e033      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected returned priority level");
  test_assert(10, chThdGetSelfX()->p_prio == prio + 3,
 800c72c:	f7ff fe18 	bl	800c360 <chThdGetSelfX>
 800c730:	4603      	mov	r3, r0
 800c732:	689a      	ldr	r2, [r3, #8]
 800c734:	9b01      	ldr	r3, [sp, #4]
 800c736:	3303      	adds	r3, #3
 800c738:	429a      	cmp	r2, r3
 800c73a:	bf14      	ite	ne
 800c73c:	2300      	movne	r3, #0
 800c73e:	2301      	moveq	r3, #1
 800c740:	b2db      	uxtb	r3, r3
 800c742:	200a      	movs	r0, #10
 800c744:	4619      	mov	r1, r3
 800c746:	f7ff fb83 	bl	800be50 <_test_assert>
 800c74a:	4603      	mov	r3, r0
 800c74c:	2b00      	cmp	r3, #0
 800c74e:	d000      	beq.n	800c752 <thd3_execute+0x1a2>
 800c750:	e020      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected priority level");
  test_assert(11, chThdGetSelfX()->p_realprio == prio + 3,
 800c752:	f7ff fe05 	bl	800c360 <chThdGetSelfX>
 800c756:	4603      	mov	r3, r0
 800c758:	6bda      	ldr	r2, [r3, #60]	; 0x3c
 800c75a:	9b01      	ldr	r3, [sp, #4]
 800c75c:	3303      	adds	r3, #3
 800c75e:	429a      	cmp	r2, r3
 800c760:	bf14      	ite	ne
 800c762:	2300      	movne	r3, #0
 800c764:	2301      	moveq	r3, #1
 800c766:	b2db      	uxtb	r3, r3
 800c768:	200b      	movs	r0, #11
 800c76a:	4619      	mov	r1, r3
 800c76c:	f7ff fb70 	bl	800be50 <_test_assert>
 800c770:	4603      	mov	r3, r0
 800c772:	2b00      	cmp	r3, #0
 800c774:	d000      	beq.n	800c778 <thd3_execute+0x1c8>
 800c776:	e00d      	b.n	800c794 <thd3_execute+0x1e4>
              "unexpected real priority level");

  chSysLock();
 800c778:	f7ff fdca 	bl	800c310 <chSysLock>
  chThdGetSelfX()->p_prio = prio;
 800c77c:	f7ff fdf0 	bl	800c360 <chThdGetSelfX>
 800c780:	4603      	mov	r3, r0
 800c782:	9a01      	ldr	r2, [sp, #4]
 800c784:	609a      	str	r2, [r3, #8]
  chThdGetSelfX()->p_realprio = prio;
 800c786:	f7ff fdeb 	bl	800c360 <chThdGetSelfX>
 800c78a:	4603      	mov	r3, r0
 800c78c:	9a01      	ldr	r2, [sp, #4]
 800c78e:	63da      	str	r2, [r3, #60]	; 0x3c
  chSysUnlock();
 800c790:	f7ff fdc6 	bl	800c320 <chSysUnlock>
#endif
}
 800c794:	b003      	add	sp, #12
 800c796:	f85d fb04 	ldr.w	pc, [sp], #4
 800c79a:	bf00      	nop
 800c79c:	f3af 8000 	nop.w

0800c7a0 <thd4_execute>:
 * <h2>Description</h2>
 * Delay APIs and associated macros are tested, the invoking thread is verified
 * to wake up at the exact expected time.
 */

static void thd4_execute(void) {
 800c7a0:	b500      	push	{lr}
 800c7a2:	b083      	sub	sp, #12
  systime_t time;

  test_wait_tick();
 800c7a4:	f7ff fbfc 	bl	800bfa0 <test_wait_tick>

  /* Timeouts in microseconds.*/
  time = chVTGetSystemTime();
 800c7a8:	f7ff fdca 	bl	800c340 <chVTGetSystemTime>
 800c7ac:	9001      	str	r0, [sp, #4]
  chThdSleepMicroseconds(100000);
 800c7ae:	2064      	movs	r0, #100	; 0x64
 800c7b0:	f7f4 fd8e 	bl	80012d0 <chThdSleep>
  test_assert_time_window(1,
 800c7b4:	9b01      	ldr	r3, [sp, #4]
 800c7b6:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800c7ba:	9b01      	ldr	r3, [sp, #4]
 800c7bc:	3365      	adds	r3, #101	; 0x65
 800c7be:	2001      	movs	r0, #1
 800c7c0:	4611      	mov	r1, r2
 800c7c2:	461a      	mov	r2, r3
 800c7c4:	f7ff fb8c 	bl	800bee0 <_test_assert_time_window>
 800c7c8:	4603      	mov	r3, r0
 800c7ca:	2b00      	cmp	r3, #0
 800c7cc:	d000      	beq.n	800c7d0 <thd4_execute+0x30>
 800c7ce:	e03c      	b.n	800c84a <thd4_execute+0xaa>
                          time + US2ST(100000),
                          time + US2ST(100000) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in milliseconds.*/
  time = chVTGetSystemTime();
 800c7d0:	f7ff fdb6 	bl	800c340 <chVTGetSystemTime>
 800c7d4:	9001      	str	r0, [sp, #4]
  chThdSleepMilliseconds(100);
 800c7d6:	2064      	movs	r0, #100	; 0x64
 800c7d8:	f7f4 fd7a 	bl	80012d0 <chThdSleep>
  test_assert_time_window(2,
 800c7dc:	9b01      	ldr	r3, [sp, #4]
 800c7de:	f103 0264 	add.w	r2, r3, #100	; 0x64
 800c7e2:	9b01      	ldr	r3, [sp, #4]
 800c7e4:	3365      	adds	r3, #101	; 0x65
 800c7e6:	2002      	movs	r0, #2
 800c7e8:	4611      	mov	r1, r2
 800c7ea:	461a      	mov	r2, r3
 800c7ec:	f7ff fb78 	bl	800bee0 <_test_assert_time_window>
 800c7f0:	4603      	mov	r3, r0
 800c7f2:	2b00      	cmp	r3, #0
 800c7f4:	d000      	beq.n	800c7f8 <thd4_execute+0x58>
 800c7f6:	e028      	b.n	800c84a <thd4_execute+0xaa>
                          time + MS2ST(100),
                          time + MS2ST(100) + CH_CFG_ST_TIMEDELTA + 1);

  /* Timeouts in seconds.*/
  time = chVTGetSystemTime();
 800c7f8:	f7ff fda2 	bl	800c340 <chVTGetSystemTime>
 800c7fc:	9001      	str	r0, [sp, #4]
  chThdSleepSeconds(1);
 800c7fe:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 800c802:	f7f4 fd65 	bl	80012d0 <chThdSleep>
  test_assert_time_window(3,
 800c806:	9b01      	ldr	r3, [sp, #4]
 800c808:	f503 727a 	add.w	r2, r3, #1000	; 0x3e8
 800c80c:	9b01      	ldr	r3, [sp, #4]
 800c80e:	f203 33e9 	addw	r3, r3, #1001	; 0x3e9
 800c812:	2003      	movs	r0, #3
 800c814:	4611      	mov	r1, r2
 800c816:	461a      	mov	r2, r3
 800c818:	f7ff fb62 	bl	800bee0 <_test_assert_time_window>
 800c81c:	4603      	mov	r3, r0
 800c81e:	2b00      	cmp	r3, #0
 800c820:	d000      	beq.n	800c824 <thd4_execute+0x84>
 800c822:	e012      	b.n	800c84a <thd4_execute+0xaa>
                          time + S2ST(1),
                          time + S2ST(1) + CH_CFG_ST_TIMEDELTA + 1);

  /* Absolute timelines.*/
  time = chVTGetSystemTime() + MS2ST(100);
 800c824:	f7ff fd8c 	bl	800c340 <chVTGetSystemTime>
 800c828:	4603      	mov	r3, r0
 800c82a:	3364      	adds	r3, #100	; 0x64
 800c82c:	9301      	str	r3, [sp, #4]
  chThdSleepUntil(time);
 800c82e:	9801      	ldr	r0, [sp, #4]
 800c830:	f7f4 fd5e 	bl	80012f0 <chThdSleepUntil>
  test_assert_time_window(4,
 800c834:	9b01      	ldr	r3, [sp, #4]
 800c836:	3301      	adds	r3, #1
 800c838:	2004      	movs	r0, #4
 800c83a:	9901      	ldr	r1, [sp, #4]
 800c83c:	461a      	mov	r2, r3
 800c83e:	f7ff fb4f 	bl	800bee0 <_test_assert_time_window>
 800c842:	4603      	mov	r3, r0
 800c844:	2b00      	cmp	r3, #0
 800c846:	d000      	beq.n	800c84a <thd4_execute+0xaa>
 800c848:	bf00      	nop
                          time,
                          time + CH_CFG_ST_TIMEDELTA + 1);
}
 800c84a:	b003      	add	sp, #12
 800c84c:	f85d fb04 	ldr.w	pc, [sp], #4

0800c850 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800c850:	b082      	sub	sp, #8
 800c852:	2320      	movs	r3, #32
 800c854:	9301      	str	r3, [sp, #4]
 800c856:	9b01      	ldr	r3, [sp, #4]
 800c858:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c85c:	b002      	add	sp, #8
 800c85e:	4770      	bx	lr

0800c860 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800c860:	b082      	sub	sp, #8
 800c862:	2300      	movs	r3, #0
 800c864:	9301      	str	r3, [sp, #4]
 800c866:	9b01      	ldr	r3, [sp, #4]
 800c868:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800c86c:	b002      	add	sp, #8
 800c86e:	4770      	bx	lr

0800c870 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800c870:	b082      	sub	sp, #8
 800c872:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800c874:	9b01      	ldr	r3, [sp, #4]
 800c876:	681a      	ldr	r2, [r3, #0]
 800c878:	9b01      	ldr	r3, [sp, #4]
 800c87a:	429a      	cmp	r2, r3
 800c87c:	bf14      	ite	ne
 800c87e:	2300      	movne	r3, #0
 800c880:	2301      	moveq	r3, #1
 800c882:	b2db      	uxtb	r3, r3
}
 800c884:	4618      	mov	r0, r3
 800c886:	b002      	add	sp, #8
 800c888:	4770      	bx	lr
 800c88a:	bf00      	nop
 800c88c:	f3af 8000 	nop.w

0800c890 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800c890:	b508      	push	{r3, lr}

  port_lock();
 800c892:	f7ff ffdd 	bl	800c850 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800c896:	bd08      	pop	{r3, pc}
 800c898:	f3af 8000 	nop.w
 800c89c:	f3af 8000 	nop.w

0800c8a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800c8a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800c8a2:	f7ff ffdd 	bl	800c860 <port_unlock>
}
 800c8a6:	bd08      	pop	{r3, pc}
 800c8a8:	f3af 8000 	nop.w
 800c8ac:	f3af 8000 	nop.w

0800c8b0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800c8b0:	4b01      	ldr	r3, [pc, #4]	; (800c8b8 <chVTGetSystemTimeX+0x8>)
 800c8b2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800c8b4:	4618      	mov	r0, r3
 800c8b6:	4770      	bx	lr
 800c8b8:	20001bc8 	.word	0x20001bc8
 800c8bc:	f3af 8000 	nop.w

0800c8c0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800c8c0:	b500      	push	{lr}
 800c8c2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800c8c4:	f7ff ffe4 	bl	800c890 <chSysLock>
  systime = chVTGetSystemTimeX();
 800c8c8:	f7ff fff2 	bl	800c8b0 <chVTGetSystemTimeX>
 800c8cc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800c8ce:	f7ff ffe7 	bl	800c8a0 <chSysUnlock>

  return systime;
 800c8d2:	9b01      	ldr	r3, [sp, #4]
}
 800c8d4:	4618      	mov	r0, r3
 800c8d6:	b003      	add	sp, #12
 800c8d8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c8dc:	f3af 8000 	nop.w

0800c8e0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800c8e0:	4b01      	ldr	r3, [pc, #4]	; (800c8e8 <chThdGetSelfX+0x8>)
 800c8e2:	699b      	ldr	r3, [r3, #24]
}
 800c8e4:	4618      	mov	r0, r3
 800c8e6:	4770      	bx	lr
 800c8e8:	20001bc8 	.word	0x20001bc8
 800c8ec:	f3af 8000 	nop.w

0800c8f0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800c8f0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800c8f2:	f7ff fff5 	bl	800c8e0 <chThdGetSelfX>
 800c8f6:	4603      	mov	r3, r0
 800c8f8:	689b      	ldr	r3, [r3, #8]
}
 800c8fa:	4618      	mov	r0, r3
 800c8fc:	bd08      	pop	{r3, pc}
 800c8fe:	bf00      	nop

0800c900 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800c900:	b082      	sub	sp, #8
 800c902:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800c904:	9b01      	ldr	r3, [sp, #4]
 800c906:	689b      	ldr	r3, [r3, #8]
}
 800c908:	4618      	mov	r0, r3
 800c90a:	b002      	add	sp, #8
 800c90c:	4770      	bx	lr
 800c90e:	bf00      	nop

0800c910 <chBSemObjectInit>:
 *                      - @a true, the initial state is taken.
 *                      .
 *
 * @init
 */
static inline void chBSemObjectInit(binary_semaphore_t *bsp, bool taken) {
 800c910:	b500      	push	{lr}
 800c912:	b083      	sub	sp, #12
 800c914:	9001      	str	r0, [sp, #4]
 800c916:	460b      	mov	r3, r1
 800c918:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemObjectInit(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c91c:	9a01      	ldr	r2, [sp, #4]
 800c91e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c922:	2b00      	cmp	r3, #0
 800c924:	d001      	beq.n	800c92a <chBSemObjectInit+0x1a>
 800c926:	2300      	movs	r3, #0
 800c928:	e000      	b.n	800c92c <chBSemObjectInit+0x1c>
 800c92a:	2301      	movs	r3, #1
 800c92c:	4610      	mov	r0, r2
 800c92e:	4619      	mov	r1, r3
 800c930:	f7f5 f8c6 	bl	8001ac0 <chSemObjectInit>
}
 800c934:	b003      	add	sp, #12
 800c936:	f85d fb04 	ldr.w	pc, [sp], #4
 800c93a:	bf00      	nop
 800c93c:	f3af 8000 	nop.w

0800c940 <chBSemWait>:
 * @retval MSG_RESET    if the binary semaphore has been reset using
 *                      @p bsemReset().
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {
 800c940:	b500      	push	{lr}
 800c942:	b083      	sub	sp, #12
 800c944:	9001      	str	r0, [sp, #4]

  return chSemWait(&bsp->bs_sem);
 800c946:	9b01      	ldr	r3, [sp, #4]
 800c948:	4618      	mov	r0, r3
 800c94a:	f7f5 f901 	bl	8001b50 <chSemWait>
 800c94e:	4603      	mov	r3, r0
}
 800c950:	4618      	mov	r0, r3
 800c952:	b003      	add	sp, #12
 800c954:	f85d fb04 	ldr.w	pc, [sp], #4
 800c958:	f3af 8000 	nop.w
 800c95c:	f3af 8000 	nop.w

0800c960 <chBSemReset>:
 *                      - @a true, the new state is taken.
 *                      .
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {
 800c960:	b500      	push	{lr}
 800c962:	b083      	sub	sp, #12
 800c964:	9001      	str	r0, [sp, #4]
 800c966:	460b      	mov	r3, r1
 800c968:	f88d 3003 	strb.w	r3, [sp, #3]

  chSemReset(&bsp->bs_sem, taken ? (cnt_t)0 : (cnt_t)1);
 800c96c:	9a01      	ldr	r2, [sp, #4]
 800c96e:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800c972:	2b00      	cmp	r3, #0
 800c974:	d001      	beq.n	800c97a <chBSemReset+0x1a>
 800c976:	2300      	movs	r3, #0
 800c978:	e000      	b.n	800c97c <chBSemReset+0x1c>
 800c97a:	2301      	movs	r3, #1
 800c97c:	4610      	mov	r0, r2
 800c97e:	4619      	mov	r1, r3
 800c980:	f7f5 f8ae 	bl	8001ae0 <chSemReset>
}
 800c984:	b003      	add	sp, #12
 800c986:	f85d fb04 	ldr.w	pc, [sp], #4
 800c98a:	bf00      	nop
 800c98c:	f3af 8000 	nop.w

0800c990 <chBSemSignalI>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @iclass
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {
 800c990:	b500      	push	{lr}
 800c992:	b083      	sub	sp, #12
 800c994:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  if (bsp->bs_sem.s_cnt < (cnt_t)1) {
 800c996:	9b01      	ldr	r3, [sp, #4]
 800c998:	689b      	ldr	r3, [r3, #8]
 800c99a:	2b00      	cmp	r3, #0
 800c99c:	dc03      	bgt.n	800c9a6 <chBSemSignalI+0x16>
    chSemSignalI(&bsp->bs_sem);
 800c99e:	9b01      	ldr	r3, [sp, #4]
 800c9a0:	4618      	mov	r0, r3
 800c9a2:	f7f5 f975 	bl	8001c90 <chSemSignalI>
  }
}
 800c9a6:	b003      	add	sp, #12
 800c9a8:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9ac:	f3af 8000 	nop.w

0800c9b0 <chBSemSignal>:
 *
 * @param[in] bsp       pointer to a @p binary_semaphore_t structure
 *
 * @api
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {
 800c9b0:	b500      	push	{lr}
 800c9b2:	b083      	sub	sp, #12
 800c9b4:	9001      	str	r0, [sp, #4]

  chSysLock();
 800c9b6:	f7ff ff6b 	bl	800c890 <chSysLock>
  chBSemSignalI(bsp);
 800c9ba:	9801      	ldr	r0, [sp, #4]
 800c9bc:	f7ff ffe8 	bl	800c990 <chBSemSignalI>
  chSchRescheduleS();
 800c9c0:	f7f4 f9de 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800c9c4:	f7ff ff6c 	bl	800c8a0 <chSysUnlock>
}
 800c9c8:	b003      	add	sp, #12
 800c9ca:	f85d fb04 	ldr.w	pc, [sp], #4
 800c9ce:	bf00      	nop

0800c9d0 <chBSemGetStateI>:
 * @retval false        if the binary semaphore is not taken.
 * @retval true         if the binary semaphore is taken.
 *
 * @iclass
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {
 800c9d0:	b082      	sub	sp, #8
 800c9d2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bsp->bs_sem.s_cnt > (cnt_t)0) ? false : true;
 800c9d4:	9b01      	ldr	r3, [sp, #4]
 800c9d6:	689b      	ldr	r3, [r3, #8]
 800c9d8:	2b00      	cmp	r3, #0
 800c9da:	bfcc      	ite	gt
 800c9dc:	2300      	movgt	r3, #0
 800c9de:	2301      	movle	r3, #1
 800c9e0:	b2db      	uxtb	r3, r3
}
 800c9e2:	4618      	mov	r0, r3
 800c9e4:	b002      	add	sp, #8
 800c9e6:	4770      	bx	lr
 800c9e8:	f3af 8000 	nop.w
 800c9ec:	f3af 8000 	nop.w

0800c9f0 <sem1_setup>:
 * The test expects that the threads reach their goal in FIFO order or
 * priority order depending on the CH_CFG_USE_SEMAPHORES_PRIORITY configuration
 * setting.
 */

static void sem1_setup(void) {
 800c9f0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800c9f2:	4802      	ldr	r0, [pc, #8]	; (800c9fc <sem1_setup+0xc>)
 800c9f4:	2100      	movs	r1, #0
 800c9f6:	f7f5 f863 	bl	8001ac0 <chSemObjectInit>
}
 800c9fa:	bd08      	pop	{r3, pc}
 800c9fc:	20000838 	.word	0x20000838

0800ca00 <thread1>:

static THD_FUNCTION(thread1, p) {
 800ca00:	b500      	push	{lr}
 800ca02:	b083      	sub	sp, #12
 800ca04:	9001      	str	r0, [sp, #4]

  chSemWait(&sem1);
 800ca06:	4805      	ldr	r0, [pc, #20]	; (800ca1c <thread1+0x1c>)
 800ca08:	f7f5 f8a2 	bl	8001b50 <chSemWait>
  test_emit_token(*(char *)p);
 800ca0c:	9b01      	ldr	r3, [sp, #4]
 800ca0e:	781b      	ldrb	r3, [r3, #0]
 800ca10:	4618      	mov	r0, r3
 800ca12:	f7ff f9ed 	bl	800bdf0 <test_emit_token>
}
 800ca16:	b003      	add	sp, #12
 800ca18:	f85d fb04 	ldr.w	pc, [sp], #4
 800ca1c:	20000838 	.word	0x20000838

0800ca20 <sem1_execute>:

static void sem1_execute(void) {
 800ca20:	b510      	push	{r4, lr}
 800ca22:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800ca24:	4b54      	ldr	r3, [pc, #336]	; (800cb78 <sem1_execute+0x158>)
 800ca26:	681c      	ldr	r4, [r3, #0]
 800ca28:	f7ff ff62 	bl	800c8f0 <chThdGetPriorityX>
 800ca2c:	4603      	mov	r3, r0
 800ca2e:	3305      	adds	r3, #5
 800ca30:	4a52      	ldr	r2, [pc, #328]	; (800cb7c <sem1_execute+0x15c>)
 800ca32:	9200      	str	r2, [sp, #0]
 800ca34:	4620      	mov	r0, r4
 800ca36:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca3a:	461a      	mov	r2, r3
 800ca3c:	4b50      	ldr	r3, [pc, #320]	; (800cb80 <sem1_execute+0x160>)
 800ca3e:	f7f4 fbcf 	bl	80011e0 <chThdCreateStatic>
 800ca42:	4602      	mov	r2, r0
 800ca44:	4b4f      	ldr	r3, [pc, #316]	; (800cb84 <sem1_execute+0x164>)
 800ca46:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 800ca48:	4b4b      	ldr	r3, [pc, #300]	; (800cb78 <sem1_execute+0x158>)
 800ca4a:	685c      	ldr	r4, [r3, #4]
 800ca4c:	f7ff ff50 	bl	800c8f0 <chThdGetPriorityX>
 800ca50:	4603      	mov	r3, r0
 800ca52:	3301      	adds	r3, #1
 800ca54:	4a4c      	ldr	r2, [pc, #304]	; (800cb88 <sem1_execute+0x168>)
 800ca56:	9200      	str	r2, [sp, #0]
 800ca58:	4620      	mov	r0, r4
 800ca5a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca5e:	461a      	mov	r2, r3
 800ca60:	4b47      	ldr	r3, [pc, #284]	; (800cb80 <sem1_execute+0x160>)
 800ca62:	f7f4 fbbd 	bl	80011e0 <chThdCreateStatic>
 800ca66:	4602      	mov	r2, r0
 800ca68:	4b46      	ldr	r3, [pc, #280]	; (800cb84 <sem1_execute+0x164>)
 800ca6a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800ca6c:	4b42      	ldr	r3, [pc, #264]	; (800cb78 <sem1_execute+0x158>)
 800ca6e:	689c      	ldr	r4, [r3, #8]
 800ca70:	f7ff ff3e 	bl	800c8f0 <chThdGetPriorityX>
 800ca74:	4603      	mov	r3, r0
 800ca76:	3303      	adds	r3, #3
 800ca78:	4a44      	ldr	r2, [pc, #272]	; (800cb8c <sem1_execute+0x16c>)
 800ca7a:	9200      	str	r2, [sp, #0]
 800ca7c:	4620      	mov	r0, r4
 800ca7e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800ca82:	461a      	mov	r2, r3
 800ca84:	4b3e      	ldr	r3, [pc, #248]	; (800cb80 <sem1_execute+0x160>)
 800ca86:	f7f4 fbab 	bl	80011e0 <chThdCreateStatic>
 800ca8a:	4602      	mov	r2, r0
 800ca8c:	4b3d      	ldr	r3, [pc, #244]	; (800cb84 <sem1_execute+0x164>)
 800ca8e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 800ca90:	4b39      	ldr	r3, [pc, #228]	; (800cb78 <sem1_execute+0x158>)
 800ca92:	68dc      	ldr	r4, [r3, #12]
 800ca94:	f7ff ff2c 	bl	800c8f0 <chThdGetPriorityX>
 800ca98:	4603      	mov	r3, r0
 800ca9a:	3304      	adds	r3, #4
 800ca9c:	4a3c      	ldr	r2, [pc, #240]	; (800cb90 <sem1_execute+0x170>)
 800ca9e:	9200      	str	r2, [sp, #0]
 800caa0:	4620      	mov	r0, r4
 800caa2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caa6:	461a      	mov	r2, r3
 800caa8:	4b35      	ldr	r3, [pc, #212]	; (800cb80 <sem1_execute+0x160>)
 800caaa:	f7f4 fb99 	bl	80011e0 <chThdCreateStatic>
 800caae:	4602      	mov	r2, r0
 800cab0:	4b34      	ldr	r3, [pc, #208]	; (800cb84 <sem1_execute+0x164>)
 800cab2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 800cab4:	4b30      	ldr	r3, [pc, #192]	; (800cb78 <sem1_execute+0x158>)
 800cab6:	691c      	ldr	r4, [r3, #16]
 800cab8:	f7ff ff1a 	bl	800c8f0 <chThdGetPriorityX>
 800cabc:	4603      	mov	r3, r0
 800cabe:	3302      	adds	r3, #2
 800cac0:	4a34      	ldr	r2, [pc, #208]	; (800cb94 <sem1_execute+0x174>)
 800cac2:	9200      	str	r2, [sp, #0]
 800cac4:	4620      	mov	r0, r4
 800cac6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800caca:	461a      	mov	r2, r3
 800cacc:	4b2c      	ldr	r3, [pc, #176]	; (800cb80 <sem1_execute+0x160>)
 800cace:	f7f4 fb87 	bl	80011e0 <chThdCreateStatic>
 800cad2:	4602      	mov	r2, r0
 800cad4:	4b2b      	ldr	r3, [pc, #172]	; (800cb84 <sem1_execute+0x164>)
 800cad6:	611a      	str	r2, [r3, #16]
  chSemSignal(&sem1);
 800cad8:	482f      	ldr	r0, [pc, #188]	; (800cb98 <sem1_execute+0x178>)
 800cada:	f7f5 f8b9 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cade:	482e      	ldr	r0, [pc, #184]	; (800cb98 <sem1_execute+0x178>)
 800cae0:	f7f5 f8b6 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800cae4:	482c      	ldr	r0, [pc, #176]	; (800cb98 <sem1_execute+0x178>)
 800cae6:	f7f5 f8b3 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800caea:	482b      	ldr	r0, [pc, #172]	; (800cb98 <sem1_execute+0x178>)
 800caec:	f7f5 f8b0 	bl	8001c50 <chSemSignal>
  chSemSignal(&sem1);
 800caf0:	4829      	ldr	r0, [pc, #164]	; (800cb98 <sem1_execute+0x178>)
 800caf2:	f7f5 f8ad 	bl	8001c50 <chSemSignal>
  test_wait_threads();
 800caf6:	f7ff fa2b 	bl	800bf50 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
  test_assert_sequence(1, "ADCEB");
#else
  test_assert_sequence(1, "ABCDE");
 800cafa:	2001      	movs	r0, #1
 800cafc:	4927      	ldr	r1, [pc, #156]	; (800cb9c <sem1_execute+0x17c>)
 800cafe:	f7ff f9bf 	bl	800be80 <_test_assert_sequence>
 800cb02:	4603      	mov	r3, r0
 800cb04:	2b00      	cmp	r3, #0
 800cb06:	d000      	beq.n	800cb0a <sem1_execute+0xea>
 800cb08:	e034      	b.n	800cb74 <sem1_execute+0x154>
#endif
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 800cb0a:	4b1b      	ldr	r3, [pc, #108]	; (800cb78 <sem1_execute+0x158>)
 800cb0c:	681c      	ldr	r4, [r3, #0]
 800cb0e:	f7ff feef 	bl	800c8f0 <chThdGetPriorityX>
 800cb12:	4603      	mov	r3, r0
 800cb14:	3305      	adds	r3, #5
 800cb16:	4a19      	ldr	r2, [pc, #100]	; (800cb7c <sem1_execute+0x15c>)
 800cb18:	9200      	str	r2, [sp, #0]
 800cb1a:	4620      	mov	r0, r4
 800cb1c:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cb20:	461a      	mov	r2, r3
 800cb22:	4b17      	ldr	r3, [pc, #92]	; (800cb80 <sem1_execute+0x160>)
 800cb24:	f7f4 fb5c 	bl	80011e0 <chThdCreateStatic>
 800cb28:	4602      	mov	r2, r0
 800cb2a:	4b16      	ldr	r3, [pc, #88]	; (800cb84 <sem1_execute+0x164>)
 800cb2c:	601a      	str	r2, [r3, #0]
  chSysLock();
 800cb2e:	f7ff feaf 	bl	800c890 <chSysLock>
  chSemAddCounterI(&sem1, 2);
 800cb32:	4819      	ldr	r0, [pc, #100]	; (800cb98 <sem1_execute+0x178>)
 800cb34:	2102      	movs	r1, #2
 800cb36:	f7f5 f8cb 	bl	8001cd0 <chSemAddCounterI>
  chSchRescheduleS();
 800cb3a:	f7f4 f921 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cb3e:	f7ff feaf 	bl	800c8a0 <chSysUnlock>
  test_wait_threads();
 800cb42:	f7ff fa05 	bl	800bf50 <test_wait_threads>
  test_assert_lock(2, chSemGetCounterI(&sem1) == 1, "invalid counter");
 800cb46:	f7ff fea3 	bl	800c890 <chSysLock>
 800cb4a:	4813      	ldr	r0, [pc, #76]	; (800cb98 <sem1_execute+0x178>)
 800cb4c:	f7ff fed8 	bl	800c900 <chSemGetCounterI>
 800cb50:	4603      	mov	r3, r0
 800cb52:	2b01      	cmp	r3, #1
 800cb54:	bf14      	ite	ne
 800cb56:	2300      	movne	r3, #0
 800cb58:	2301      	moveq	r3, #1
 800cb5a:	b2db      	uxtb	r3, r3
 800cb5c:	2002      	movs	r0, #2
 800cb5e:	4619      	mov	r1, r3
 800cb60:	f7ff f976 	bl	800be50 <_test_assert>
 800cb64:	4603      	mov	r3, r0
 800cb66:	2b00      	cmp	r3, #0
 800cb68:	d002      	beq.n	800cb70 <sem1_execute+0x150>
 800cb6a:	f7ff fe99 	bl	800c8a0 <chSysUnlock>
 800cb6e:	e001      	b.n	800cb74 <sem1_execute+0x154>
 800cb70:	f7ff fe96 	bl	800c8a0 <chSysUnlock>
}
 800cb74:	b002      	add	sp, #8
 800cb76:	bd10      	pop	{r4, pc}
 800cb78:	08019750 	.word	0x08019750
 800cb7c:	08019a40 	.word	0x08019a40
 800cb80:	0800ca01 	.word	0x0800ca01
 800cb84:	2000205c 	.word	0x2000205c
 800cb88:	08019a44 	.word	0x08019a44
 800cb8c:	08019a48 	.word	0x08019a48
 800cb90:	08019a4c 	.word	0x08019a4c
 800cb94:	08019a50 	.word	0x08019a50
 800cb98:	20000838 	.word	0x20000838
 800cb9c:	08019a54 	.word	0x08019a54

0800cba0 <sem2_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem2_setup(void) {
 800cba0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800cba2:	4802      	ldr	r0, [pc, #8]	; (800cbac <sem2_setup+0xc>)
 800cba4:	2100      	movs	r1, #0
 800cba6:	f7f4 ff8b 	bl	8001ac0 <chSemObjectInit>
}
 800cbaa:	bd08      	pop	{r3, pc}
 800cbac:	20000838 	.word	0x20000838

0800cbb0 <thread2>:

static THD_FUNCTION(thread2, p) {
 800cbb0:	b500      	push	{lr}
 800cbb2:	b083      	sub	sp, #12
 800cbb4:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800cbb6:	2032      	movs	r0, #50	; 0x32
 800cbb8:	f7f4 fb8a 	bl	80012d0 <chThdSleep>
  chSysLock();
 800cbbc:	f7ff fe68 	bl	800c890 <chSysLock>
  chSemSignalI(&sem1); /* For coverage reasons */
 800cbc0:	4804      	ldr	r0, [pc, #16]	; (800cbd4 <thread2+0x24>)
 800cbc2:	f7f5 f865 	bl	8001c90 <chSemSignalI>
  chSchRescheduleS();
 800cbc6:	f7f4 f8db 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800cbca:	f7ff fe69 	bl	800c8a0 <chSysUnlock>
}
 800cbce:	b003      	add	sp, #12
 800cbd0:	f85d fb04 	ldr.w	pc, [sp], #4
 800cbd4:	20000838 	.word	0x20000838
 800cbd8:	f3af 8000 	nop.w
 800cbdc:	f3af 8000 	nop.w

0800cbe0 <sem2_execute>:

static void sem2_execute(void) {
 800cbe0:	b510      	push	{r4, lr}
 800cbe2:	b086      	sub	sp, #24
  msg_t msg;

  /*
   * Testing special case TIME_IMMEDIATE.
   */
  msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
 800cbe4:	4866      	ldr	r0, [pc, #408]	; (800cd80 <sem2_execute+0x1a0>)
 800cbe6:	2100      	movs	r1, #0
 800cbe8:	f7f4 ffea 	bl	8001bc0 <chSemWaitTimeout>
 800cbec:	9004      	str	r0, [sp, #16]
  test_assert(1, msg == MSG_TIMEOUT, "wrong wake-up message");
 800cbee:	9b04      	ldr	r3, [sp, #16]
 800cbf0:	f1b3 3fff 	cmp.w	r3, #4294967295
 800cbf4:	bf14      	ite	ne
 800cbf6:	2300      	movne	r3, #0
 800cbf8:	2301      	moveq	r3, #1
 800cbfa:	b2db      	uxtb	r3, r3
 800cbfc:	2001      	movs	r0, #1
 800cbfe:	4619      	mov	r1, r3
 800cc00:	f7ff f926 	bl	800be50 <_test_assert>
 800cc04:	4603      	mov	r3, r0
 800cc06:	2b00      	cmp	r3, #0
 800cc08:	d000      	beq.n	800cc0c <sem2_execute+0x2c>
 800cc0a:	e0b6      	b.n	800cd7a <sem2_execute+0x19a>
  test_assert(2, queue_isempty(&sem1.s_queue), "queue not empty");
 800cc0c:	485c      	ldr	r0, [pc, #368]	; (800cd80 <sem2_execute+0x1a0>)
 800cc0e:	f7ff fe2f 	bl	800c870 <queue_isempty>
 800cc12:	4603      	mov	r3, r0
 800cc14:	2002      	movs	r0, #2
 800cc16:	4619      	mov	r1, r3
 800cc18:	f7ff f91a 	bl	800be50 <_test_assert>
 800cc1c:	4603      	mov	r3, r0
 800cc1e:	2b00      	cmp	r3, #0
 800cc20:	d000      	beq.n	800cc24 <sem2_execute+0x44>
 800cc22:	e0aa      	b.n	800cd7a <sem2_execute+0x19a>
  test_assert(3, sem1.s_cnt == 0, "counter not zero");
 800cc24:	4b56      	ldr	r3, [pc, #344]	; (800cd80 <sem2_execute+0x1a0>)
 800cc26:	689b      	ldr	r3, [r3, #8]
 800cc28:	2b00      	cmp	r3, #0
 800cc2a:	bf14      	ite	ne
 800cc2c:	2300      	movne	r3, #0
 800cc2e:	2301      	moveq	r3, #1
 800cc30:	b2db      	uxtb	r3, r3
 800cc32:	2003      	movs	r0, #3
 800cc34:	4619      	mov	r1, r3
 800cc36:	f7ff f90b 	bl	800be50 <_test_assert>
 800cc3a:	4603      	mov	r3, r0
 800cc3c:	2b00      	cmp	r3, #0
 800cc3e:	d000      	beq.n	800cc42 <sem2_execute+0x62>
 800cc40:	e09b      	b.n	800cd7a <sem2_execute+0x19a>

  /*
   * Testing not timeout condition.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800cc42:	4b50      	ldr	r3, [pc, #320]	; (800cd84 <sem2_execute+0x1a4>)
 800cc44:	681c      	ldr	r4, [r3, #0]
 800cc46:	f7ff fe53 	bl	800c8f0 <chThdGetPriorityX>
 800cc4a:	4603      	mov	r3, r0
 800cc4c:	3b01      	subs	r3, #1
 800cc4e:	2200      	movs	r2, #0
 800cc50:	9200      	str	r2, [sp, #0]
 800cc52:	4620      	mov	r0, r4
 800cc54:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cc58:	461a      	mov	r2, r3
 800cc5a:	4b4b      	ldr	r3, [pc, #300]	; (800cd88 <sem2_execute+0x1a8>)
 800cc5c:	f7f4 fac0 	bl	80011e0 <chThdCreateStatic>
 800cc60:	4602      	mov	r2, r0
 800cc62:	4b4a      	ldr	r3, [pc, #296]	; (800cd8c <sem2_execute+0x1ac>)
 800cc64:	601a      	str	r2, [r3, #0]
                                 thread2, 0);
  msg = chSemWaitTimeout(&sem1, MS2ST(500));
 800cc66:	4846      	ldr	r0, [pc, #280]	; (800cd80 <sem2_execute+0x1a0>)
 800cc68:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800cc6c:	f7f4 ffa8 	bl	8001bc0 <chSemWaitTimeout>
 800cc70:	9004      	str	r0, [sp, #16]
  test_wait_threads();
 800cc72:	f7ff f96d 	bl	800bf50 <test_wait_threads>
  test_assert(4, msg == MSG_OK, "wrong wake-up message");
 800cc76:	9b04      	ldr	r3, [sp, #16]
 800cc78:	2b00      	cmp	r3, #0
 800cc7a:	bf14      	ite	ne
 800cc7c:	2300      	movne	r3, #0
 800cc7e:	2301      	moveq	r3, #1
 800cc80:	b2db      	uxtb	r3, r3
 800cc82:	2004      	movs	r0, #4
 800cc84:	4619      	mov	r1, r3
 800cc86:	f7ff f8e3 	bl	800be50 <_test_assert>
 800cc8a:	4603      	mov	r3, r0
 800cc8c:	2b00      	cmp	r3, #0
 800cc8e:	d000      	beq.n	800cc92 <sem2_execute+0xb2>
 800cc90:	e073      	b.n	800cd7a <sem2_execute+0x19a>
  test_assert(5, queue_isempty(&sem1.s_queue), "queue not empty");
 800cc92:	483b      	ldr	r0, [pc, #236]	; (800cd80 <sem2_execute+0x1a0>)
 800cc94:	f7ff fdec 	bl	800c870 <queue_isempty>
 800cc98:	4603      	mov	r3, r0
 800cc9a:	2005      	movs	r0, #5
 800cc9c:	4619      	mov	r1, r3
 800cc9e:	f7ff f8d7 	bl	800be50 <_test_assert>
 800cca2:	4603      	mov	r3, r0
 800cca4:	2b00      	cmp	r3, #0
 800cca6:	d000      	beq.n	800ccaa <sem2_execute+0xca>
 800cca8:	e067      	b.n	800cd7a <sem2_execute+0x19a>
  test_assert(6, sem1.s_cnt == 0, "counter not zero");
 800ccaa:	4b35      	ldr	r3, [pc, #212]	; (800cd80 <sem2_execute+0x1a0>)
 800ccac:	689b      	ldr	r3, [r3, #8]
 800ccae:	2b00      	cmp	r3, #0
 800ccb0:	bf14      	ite	ne
 800ccb2:	2300      	movne	r3, #0
 800ccb4:	2301      	moveq	r3, #1
 800ccb6:	b2db      	uxtb	r3, r3
 800ccb8:	2006      	movs	r0, #6
 800ccba:	4619      	mov	r1, r3
 800ccbc:	f7ff f8c8 	bl	800be50 <_test_assert>
 800ccc0:	4603      	mov	r3, r0
 800ccc2:	2b00      	cmp	r3, #0
 800ccc4:	d000      	beq.n	800ccc8 <sem2_execute+0xe8>
 800ccc6:	e058      	b.n	800cd7a <sem2_execute+0x19a>

  /*
   * Testing timeout condition.
   */
  test_wait_tick();
 800ccc8:	f7ff f96a 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
 800cccc:	f7ff fdf8 	bl	800c8c0 <chVTGetSystemTime>
 800ccd0:	4603      	mov	r3, r0
 800ccd2:	33fa      	adds	r3, #250	; 0xfa
 800ccd4:	9303      	str	r3, [sp, #12]
  for (i = 0; i < 5; i++) {
 800ccd6:	2300      	movs	r3, #0
 800ccd8:	9305      	str	r3, [sp, #20]
 800ccda:	e038      	b.n	800cd4e <sem2_execute+0x16e>
    test_emit_token('A' + i);
 800ccdc:	9b05      	ldr	r3, [sp, #20]
 800ccde:	b2db      	uxtb	r3, r3
 800cce0:	3341      	adds	r3, #65	; 0x41
 800cce2:	b2db      	uxtb	r3, r3
 800cce4:	4618      	mov	r0, r3
 800cce6:	f7ff f883 	bl	800bdf0 <test_emit_token>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
 800ccea:	4825      	ldr	r0, [pc, #148]	; (800cd80 <sem2_execute+0x1a0>)
 800ccec:	2132      	movs	r1, #50	; 0x32
 800ccee:	f7f4 ff67 	bl	8001bc0 <chSemWaitTimeout>
 800ccf2:	9004      	str	r0, [sp, #16]
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
 800ccf4:	9b04      	ldr	r3, [sp, #16]
 800ccf6:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ccfa:	bf14      	ite	ne
 800ccfc:	2300      	movne	r3, #0
 800ccfe:	2301      	moveq	r3, #1
 800cd00:	b2db      	uxtb	r3, r3
 800cd02:	2007      	movs	r0, #7
 800cd04:	4619      	mov	r1, r3
 800cd06:	f7ff f8a3 	bl	800be50 <_test_assert>
 800cd0a:	4603      	mov	r3, r0
 800cd0c:	2b00      	cmp	r3, #0
 800cd0e:	d000      	beq.n	800cd12 <sem2_execute+0x132>
 800cd10:	e033      	b.n	800cd7a <sem2_execute+0x19a>
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
 800cd12:	481b      	ldr	r0, [pc, #108]	; (800cd80 <sem2_execute+0x1a0>)
 800cd14:	f7ff fdac 	bl	800c870 <queue_isempty>
 800cd18:	4603      	mov	r3, r0
 800cd1a:	2008      	movs	r0, #8
 800cd1c:	4619      	mov	r1, r3
 800cd1e:	f7ff f897 	bl	800be50 <_test_assert>
 800cd22:	4603      	mov	r3, r0
 800cd24:	2b00      	cmp	r3, #0
 800cd26:	d000      	beq.n	800cd2a <sem2_execute+0x14a>
 800cd28:	e027      	b.n	800cd7a <sem2_execute+0x19a>
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
 800cd2a:	4b15      	ldr	r3, [pc, #84]	; (800cd80 <sem2_execute+0x1a0>)
 800cd2c:	689b      	ldr	r3, [r3, #8]
 800cd2e:	2b00      	cmp	r3, #0
 800cd30:	bf14      	ite	ne
 800cd32:	2300      	movne	r3, #0
 800cd34:	2301      	moveq	r3, #1
 800cd36:	b2db      	uxtb	r3, r3
 800cd38:	2009      	movs	r0, #9
 800cd3a:	4619      	mov	r1, r3
 800cd3c:	f7ff f888 	bl	800be50 <_test_assert>
 800cd40:	4603      	mov	r3, r0
 800cd42:	2b00      	cmp	r3, #0
 800cd44:	d000      	beq.n	800cd48 <sem2_execute+0x168>
 800cd46:	e018      	b.n	800cd7a <sem2_execute+0x19a>
  /*
   * Testing timeout condition.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(5 * 50);
  for (i = 0; i < 5; i++) {
 800cd48:	9b05      	ldr	r3, [sp, #20]
 800cd4a:	3301      	adds	r3, #1
 800cd4c:	9305      	str	r3, [sp, #20]
 800cd4e:	9b05      	ldr	r3, [sp, #20]
 800cd50:	2b04      	cmp	r3, #4
 800cd52:	ddc3      	ble.n	800ccdc <sem2_execute+0xfc>
    msg = chSemWaitTimeout(&sem1, MS2ST(50));
    test_assert(7, msg == MSG_TIMEOUT, "wrong wake-up message");
    test_assert(8, queue_isempty(&sem1.s_queue), "queue not empty");
    test_assert(9, sem1.s_cnt == 0, "counter not zero");
  }
  test_assert_sequence(10, "ABCDE");
 800cd54:	200a      	movs	r0, #10
 800cd56:	490e      	ldr	r1, [pc, #56]	; (800cd90 <sem2_execute+0x1b0>)
 800cd58:	f7ff f892 	bl	800be80 <_test_assert_sequence>
 800cd5c:	4603      	mov	r3, r0
 800cd5e:	2b00      	cmp	r3, #0
 800cd60:	d000      	beq.n	800cd64 <sem2_execute+0x184>
 800cd62:	e00a      	b.n	800cd7a <sem2_execute+0x19a>
  test_assert_time_window(11, target_time, target_time + ALLOWED_DELAY);
 800cd64:	9b03      	ldr	r3, [sp, #12]
 800cd66:	3302      	adds	r3, #2
 800cd68:	200b      	movs	r0, #11
 800cd6a:	9903      	ldr	r1, [sp, #12]
 800cd6c:	461a      	mov	r2, r3
 800cd6e:	f7ff f8b7 	bl	800bee0 <_test_assert_time_window>
 800cd72:	4603      	mov	r3, r0
 800cd74:	2b00      	cmp	r3, #0
 800cd76:	d000      	beq.n	800cd7a <sem2_execute+0x19a>
 800cd78:	bf00      	nop
}
 800cd7a:	b006      	add	sp, #24
 800cd7c:	bd10      	pop	{r4, pc}
 800cd7e:	bf00      	nop
 800cd80:	20000838 	.word	0x20000838
 800cd84:	08019750 	.word	0x08019750
 800cd88:	0800cbb1 	.word	0x0800cbb1
 800cd8c:	2000205c 	.word	0x2000205c
 800cd90:	08019a54 	.word	0x08019a54
 800cd94:	f3af 8000 	nop.w
 800cd98:	f3af 8000 	nop.w
 800cd9c:	f3af 8000 	nop.w

0800cda0 <sem3_setup>:
 * The test expects that the semaphore wait function returns the correct value
 * in each of the above scenario and that the semaphore structure status is
 * correct after each operation.
 */

static void sem3_setup(void) {
 800cda0:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 800cda2:	4802      	ldr	r0, [pc, #8]	; (800cdac <sem3_setup+0xc>)
 800cda4:	2100      	movs	r1, #0
 800cda6:	f7f4 fe8b 	bl	8001ac0 <chSemObjectInit>
}
 800cdaa:	bd08      	pop	{r3, pc}
 800cdac:	20000838 	.word	0x20000838

0800cdb0 <thread3>:

static THD_FUNCTION(thread3, p) {
 800cdb0:	b500      	push	{lr}
 800cdb2:	b083      	sub	sp, #12
 800cdb4:	9001      	str	r0, [sp, #4]

  (void)p;
  chSemWait(&sem1);
 800cdb6:	4804      	ldr	r0, [pc, #16]	; (800cdc8 <thread3+0x18>)
 800cdb8:	f7f4 feca 	bl	8001b50 <chSemWait>
  chSemSignal(&sem1);
 800cdbc:	4802      	ldr	r0, [pc, #8]	; (800cdc8 <thread3+0x18>)
 800cdbe:	f7f4 ff47 	bl	8001c50 <chSemSignal>
}
 800cdc2:	b003      	add	sp, #12
 800cdc4:	f85d fb04 	ldr.w	pc, [sp], #4
 800cdc8:	20000838 	.word	0x20000838
 800cdcc:	f3af 8000 	nop.w

0800cdd0 <sem3_execute>:

static void sem3_execute(void) {
 800cdd0:	b510      	push	{r4, lr}
 800cdd2:	b082      	sub	sp, #8

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 800cdd4:	4b28      	ldr	r3, [pc, #160]	; (800ce78 <sem3_execute+0xa8>)
 800cdd6:	681c      	ldr	r4, [r3, #0]
 800cdd8:	f7ff fd8a 	bl	800c8f0 <chThdGetPriorityX>
 800cddc:	4603      	mov	r3, r0
 800cdde:	3301      	adds	r3, #1
 800cde0:	2200      	movs	r2, #0
 800cde2:	9200      	str	r2, [sp, #0]
 800cde4:	4620      	mov	r0, r4
 800cde6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cdea:	461a      	mov	r2, r3
 800cdec:	4b23      	ldr	r3, [pc, #140]	; (800ce7c <sem3_execute+0xac>)
 800cdee:	f7f4 f9f7 	bl	80011e0 <chThdCreateStatic>
 800cdf2:	4602      	mov	r2, r0
 800cdf4:	4b22      	ldr	r3, [pc, #136]	; (800ce80 <sem3_execute+0xb0>)
 800cdf6:	601a      	str	r2, [r3, #0]
  chSemSignalWait(&sem1, &sem1);
 800cdf8:	4822      	ldr	r0, [pc, #136]	; (800ce84 <sem3_execute+0xb4>)
 800cdfa:	4922      	ldr	r1, [pc, #136]	; (800ce84 <sem3_execute+0xb4>)
 800cdfc:	f7f4 ff90 	bl	8001d20 <chSemSignalWait>
  test_assert(1, queue_isempty(&sem1.s_queue), "queue not empty");
 800ce00:	4820      	ldr	r0, [pc, #128]	; (800ce84 <sem3_execute+0xb4>)
 800ce02:	f7ff fd35 	bl	800c870 <queue_isempty>
 800ce06:	4603      	mov	r3, r0
 800ce08:	2001      	movs	r0, #1
 800ce0a:	4619      	mov	r1, r3
 800ce0c:	f7ff f820 	bl	800be50 <_test_assert>
 800ce10:	4603      	mov	r3, r0
 800ce12:	2b00      	cmp	r3, #0
 800ce14:	d000      	beq.n	800ce18 <sem3_execute+0x48>
 800ce16:	e02d      	b.n	800ce74 <sem3_execute+0xa4>
  test_assert(2, sem1.s_cnt == 0, "counter not zero");
 800ce18:	4b1a      	ldr	r3, [pc, #104]	; (800ce84 <sem3_execute+0xb4>)
 800ce1a:	689b      	ldr	r3, [r3, #8]
 800ce1c:	2b00      	cmp	r3, #0
 800ce1e:	bf14      	ite	ne
 800ce20:	2300      	movne	r3, #0
 800ce22:	2301      	moveq	r3, #1
 800ce24:	b2db      	uxtb	r3, r3
 800ce26:	2002      	movs	r0, #2
 800ce28:	4619      	mov	r1, r3
 800ce2a:	f7ff f811 	bl	800be50 <_test_assert>
 800ce2e:	4603      	mov	r3, r0
 800ce30:	2b00      	cmp	r3, #0
 800ce32:	d000      	beq.n	800ce36 <sem3_execute+0x66>
 800ce34:	e01e      	b.n	800ce74 <sem3_execute+0xa4>

  chSemSignalWait(&sem1, &sem1);
 800ce36:	4813      	ldr	r0, [pc, #76]	; (800ce84 <sem3_execute+0xb4>)
 800ce38:	4912      	ldr	r1, [pc, #72]	; (800ce84 <sem3_execute+0xb4>)
 800ce3a:	f7f4 ff71 	bl	8001d20 <chSemSignalWait>
  test_assert(3, queue_isempty(&sem1.s_queue), "queue not empty");
 800ce3e:	4811      	ldr	r0, [pc, #68]	; (800ce84 <sem3_execute+0xb4>)
 800ce40:	f7ff fd16 	bl	800c870 <queue_isempty>
 800ce44:	4603      	mov	r3, r0
 800ce46:	2003      	movs	r0, #3
 800ce48:	4619      	mov	r1, r3
 800ce4a:	f7ff f801 	bl	800be50 <_test_assert>
 800ce4e:	4603      	mov	r3, r0
 800ce50:	2b00      	cmp	r3, #0
 800ce52:	d000      	beq.n	800ce56 <sem3_execute+0x86>
 800ce54:	e00e      	b.n	800ce74 <sem3_execute+0xa4>
  test_assert(4, sem1.s_cnt == 0, "counter not zero");
 800ce56:	4b0b      	ldr	r3, [pc, #44]	; (800ce84 <sem3_execute+0xb4>)
 800ce58:	689b      	ldr	r3, [r3, #8]
 800ce5a:	2b00      	cmp	r3, #0
 800ce5c:	bf14      	ite	ne
 800ce5e:	2300      	movne	r3, #0
 800ce60:	2301      	moveq	r3, #1
 800ce62:	b2db      	uxtb	r3, r3
 800ce64:	2004      	movs	r0, #4
 800ce66:	4619      	mov	r1, r3
 800ce68:	f7fe fff2 	bl	800be50 <_test_assert>
 800ce6c:	4603      	mov	r3, r0
 800ce6e:	2b00      	cmp	r3, #0
 800ce70:	d000      	beq.n	800ce74 <sem3_execute+0xa4>
 800ce72:	bf00      	nop
}
 800ce74:	b002      	add	sp, #8
 800ce76:	bd10      	pop	{r4, pc}
 800ce78:	08019750 	.word	0x08019750
 800ce7c:	0800cdb1 	.word	0x0800cdb1
 800ce80:	2000205c 	.word	0x2000205c
 800ce84:	20000838 	.word	0x20000838
 800ce88:	f3af 8000 	nop.w
 800ce8c:	f3af 8000 	nop.w

0800ce90 <thread4>:
 * <h2>Description</h2>
 * This test case tests the binary semaphores functionality. The test both
 * checks the binary semaphore status and the expected status of the underlying
 * counting semaphore.
 */
static THD_FUNCTION(thread4, p) {
 800ce90:	b500      	push	{lr}
 800ce92:	b083      	sub	sp, #12
 800ce94:	9001      	str	r0, [sp, #4]

  chBSemSignal((binary_semaphore_t *)p);
 800ce96:	9801      	ldr	r0, [sp, #4]
 800ce98:	f7ff fd8a 	bl	800c9b0 <chBSemSignal>
}
 800ce9c:	b003      	add	sp, #12
 800ce9e:	f85d fb04 	ldr.w	pc, [sp], #4
 800cea2:	bf00      	nop
 800cea4:	f3af 8000 	nop.w
 800cea8:	f3af 8000 	nop.w
 800ceac:	f3af 8000 	nop.w

0800ceb0 <sem4_execute>:

static void sem4_execute(void) {
 800ceb0:	b510      	push	{r4, lr}
 800ceb2:	b086      	sub	sp, #24
  binary_semaphore_t bsem;
  
  /* Creates a taken binary semaphore.*/
  chBSemObjectInit(&bsem, TRUE);
 800ceb4:	ab03      	add	r3, sp, #12
 800ceb6:	4618      	mov	r0, r3
 800ceb8:	2101      	movs	r1, #1
 800ceba:	f7ff fd29 	bl	800c910 <chBSemObjectInit>
  chBSemReset(&bsem, TRUE);
 800cebe:	ab03      	add	r3, sp, #12
 800cec0:	4618      	mov	r0, r3
 800cec2:	2101      	movs	r1, #1
 800cec4:	f7ff fd4c 	bl	800c960 <chBSemReset>
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cec8:	f7ff fce2 	bl	800c890 <chSysLock>
 800cecc:	ab03      	add	r3, sp, #12
 800cece:	4618      	mov	r0, r3
 800ced0:	f7ff fd7e 	bl	800c9d0 <chBSemGetStateI>
 800ced4:	4603      	mov	r3, r0
 800ced6:	2b00      	cmp	r3, #0
 800ced8:	bf0c      	ite	eq
 800ceda:	2300      	moveq	r3, #0
 800cedc:	2301      	movne	r3, #1
 800cede:	b2db      	uxtb	r3, r3
 800cee0:	2001      	movs	r0, #1
 800cee2:	4619      	mov	r1, r3
 800cee4:	f7fe ffb4 	bl	800be50 <_test_assert>
 800cee8:	4603      	mov	r3, r0
 800ceea:	2b00      	cmp	r3, #0
 800ceec:	d002      	beq.n	800cef4 <sem4_execute+0x44>
 800ceee:	f7ff fcd7 	bl	800c8a0 <chSysUnlock>
 800cef2:	e0a3      	b.n	800d03c <sem4_execute+0x18c>
 800cef4:	f7ff fcd4 	bl	800c8a0 <chSysUnlock>

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cef8:	4b51      	ldr	r3, [pc, #324]	; (800d040 <sem4_execute+0x190>)
 800cefa:	681c      	ldr	r4, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
 800cefc:	f7ff fcf8 	bl	800c8f0 <chThdGetPriorityX>
 800cf00:	4603      	mov	r3, r0
  chBSemObjectInit(&bsem, TRUE);
  chBSemReset(&bsem, TRUE);
  test_assert_lock(1, chBSemGetStateI(&bsem) == TRUE, "not taken");

  /* Starts a signaler thread at a lower priority.*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800cf02:	3b01      	subs	r3, #1
 800cf04:	aa03      	add	r2, sp, #12
 800cf06:	9200      	str	r2, [sp, #0]
 800cf08:	4620      	mov	r0, r4
 800cf0a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800cf0e:	461a      	mov	r2, r3
 800cf10:	4b4c      	ldr	r3, [pc, #304]	; (800d044 <sem4_execute+0x194>)
 800cf12:	f7f4 f965 	bl	80011e0 <chThdCreateStatic>
 800cf16:	4602      	mov	r2, r0
 800cf18:	4b4b      	ldr	r3, [pc, #300]	; (800d048 <sem4_execute+0x198>)
 800cf1a:	601a      	str	r2, [r3, #0]
                                 chThdGetPriorityX()-1, thread4, &bsem);
                                 
  /* Waits to be signaled.*/
  chBSemWait(&bsem);
 800cf1c:	ab03      	add	r3, sp, #12
 800cf1e:	4618      	mov	r0, r3
 800cf20:	f7ff fd0e 	bl	800c940 <chBSemWait>
  
  /* The binary semaphore is expected to be taken.*/
  test_assert_lock(2, chBSemGetStateI(&bsem) == TRUE, "not taken");
 800cf24:	f7ff fcb4 	bl	800c890 <chSysLock>
 800cf28:	ab03      	add	r3, sp, #12
 800cf2a:	4618      	mov	r0, r3
 800cf2c:	f7ff fd50 	bl	800c9d0 <chBSemGetStateI>
 800cf30:	4603      	mov	r3, r0
 800cf32:	2b00      	cmp	r3, #0
 800cf34:	bf0c      	ite	eq
 800cf36:	2300      	moveq	r3, #0
 800cf38:	2301      	movne	r3, #1
 800cf3a:	b2db      	uxtb	r3, r3
 800cf3c:	2002      	movs	r0, #2
 800cf3e:	4619      	mov	r1, r3
 800cf40:	f7fe ff86 	bl	800be50 <_test_assert>
 800cf44:	4603      	mov	r3, r0
 800cf46:	2b00      	cmp	r3, #0
 800cf48:	d002      	beq.n	800cf50 <sem4_execute+0xa0>
 800cf4a:	f7ff fca9 	bl	800c8a0 <chSysUnlock>
 800cf4e:	e075      	b.n	800d03c <sem4_execute+0x18c>
 800cf50:	f7ff fca6 	bl	800c8a0 <chSysUnlock>

  /* Releasing it, check both the binary semaphore state and the underlying
     counter semaphore state..*/
  chBSemSignal(&bsem);
 800cf54:	ab03      	add	r3, sp, #12
 800cf56:	4618      	mov	r0, r3
 800cf58:	f7ff fd2a 	bl	800c9b0 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "still taken");
 800cf5c:	f7ff fc98 	bl	800c890 <chSysLock>
 800cf60:	ab03      	add	r3, sp, #12
 800cf62:	4618      	mov	r0, r3
 800cf64:	f7ff fd34 	bl	800c9d0 <chBSemGetStateI>
 800cf68:	4603      	mov	r3, r0
 800cf6a:	2b00      	cmp	r3, #0
 800cf6c:	bf0c      	ite	eq
 800cf6e:	2300      	moveq	r3, #0
 800cf70:	2301      	movne	r3, #1
 800cf72:	b2db      	uxtb	r3, r3
 800cf74:	f083 0301 	eor.w	r3, r3, #1
 800cf78:	b2db      	uxtb	r3, r3
 800cf7a:	f003 0301 	and.w	r3, r3, #1
 800cf7e:	b2db      	uxtb	r3, r3
 800cf80:	2003      	movs	r0, #3
 800cf82:	4619      	mov	r1, r3
 800cf84:	f7fe ff64 	bl	800be50 <_test_assert>
 800cf88:	4603      	mov	r3, r0
 800cf8a:	2b00      	cmp	r3, #0
 800cf8c:	d002      	beq.n	800cf94 <sem4_execute+0xe4>
 800cf8e:	f7ff fc87 	bl	800c8a0 <chSysUnlock>
 800cf92:	e053      	b.n	800d03c <sem4_execute+0x18c>
 800cf94:	f7ff fc84 	bl	800c8a0 <chSysUnlock>
  test_assert_lock(4, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800cf98:	f7ff fc7a 	bl	800c890 <chSysLock>
 800cf9c:	ab03      	add	r3, sp, #12
 800cf9e:	4618      	mov	r0, r3
 800cfa0:	f7ff fcae 	bl	800c900 <chSemGetCounterI>
 800cfa4:	4603      	mov	r3, r0
 800cfa6:	2b01      	cmp	r3, #1
 800cfa8:	bf14      	ite	ne
 800cfaa:	2300      	movne	r3, #0
 800cfac:	2301      	moveq	r3, #1
 800cfae:	b2db      	uxtb	r3, r3
 800cfb0:	2004      	movs	r0, #4
 800cfb2:	4619      	mov	r1, r3
 800cfb4:	f7fe ff4c 	bl	800be50 <_test_assert>
 800cfb8:	4603      	mov	r3, r0
 800cfba:	2b00      	cmp	r3, #0
 800cfbc:	d002      	beq.n	800cfc4 <sem4_execute+0x114>
 800cfbe:	f7ff fc6f 	bl	800c8a0 <chSysUnlock>
 800cfc2:	e03b      	b.n	800d03c <sem4_execute+0x18c>
 800cfc4:	f7ff fc6c 	bl	800c8a0 <chSysUnlock>

  /* Checking signaling overflow, the counter must not go beyond 1.*/
  chBSemSignal(&bsem);
 800cfc8:	ab03      	add	r3, sp, #12
 800cfca:	4618      	mov	r0, r3
 800cfcc:	f7ff fcf0 	bl	800c9b0 <chBSemSignal>
  test_assert_lock(3, chBSemGetStateI(&bsem) == FALSE, "taken");
 800cfd0:	f7ff fc5e 	bl	800c890 <chSysLock>
 800cfd4:	ab03      	add	r3, sp, #12
 800cfd6:	4618      	mov	r0, r3
 800cfd8:	f7ff fcfa 	bl	800c9d0 <chBSemGetStateI>
 800cfdc:	4603      	mov	r3, r0
 800cfde:	2b00      	cmp	r3, #0
 800cfe0:	bf0c      	ite	eq
 800cfe2:	2300      	moveq	r3, #0
 800cfe4:	2301      	movne	r3, #1
 800cfe6:	b2db      	uxtb	r3, r3
 800cfe8:	f083 0301 	eor.w	r3, r3, #1
 800cfec:	b2db      	uxtb	r3, r3
 800cfee:	f003 0301 	and.w	r3, r3, #1
 800cff2:	b2db      	uxtb	r3, r3
 800cff4:	2003      	movs	r0, #3
 800cff6:	4619      	mov	r1, r3
 800cff8:	f7fe ff2a 	bl	800be50 <_test_assert>
 800cffc:	4603      	mov	r3, r0
 800cffe:	2b00      	cmp	r3, #0
 800d000:	d002      	beq.n	800d008 <sem4_execute+0x158>
 800d002:	f7ff fc4d 	bl	800c8a0 <chSysUnlock>
 800d006:	e019      	b.n	800d03c <sem4_execute+0x18c>
 800d008:	f7ff fc4a 	bl	800c8a0 <chSysUnlock>
  test_assert_lock(5, chSemGetCounterI(&bsem.bs_sem) == 1, "unexpected counter");
 800d00c:	f7ff fc40 	bl	800c890 <chSysLock>
 800d010:	ab03      	add	r3, sp, #12
 800d012:	4618      	mov	r0, r3
 800d014:	f7ff fc74 	bl	800c900 <chSemGetCounterI>
 800d018:	4603      	mov	r3, r0
 800d01a:	2b01      	cmp	r3, #1
 800d01c:	bf14      	ite	ne
 800d01e:	2300      	movne	r3, #0
 800d020:	2301      	moveq	r3, #1
 800d022:	b2db      	uxtb	r3, r3
 800d024:	2005      	movs	r0, #5
 800d026:	4619      	mov	r1, r3
 800d028:	f7fe ff12 	bl	800be50 <_test_assert>
 800d02c:	4603      	mov	r3, r0
 800d02e:	2b00      	cmp	r3, #0
 800d030:	d002      	beq.n	800d038 <sem4_execute+0x188>
 800d032:	f7ff fc35 	bl	800c8a0 <chSysUnlock>
 800d036:	e001      	b.n	800d03c <sem4_execute+0x18c>
 800d038:	f7ff fc32 	bl	800c8a0 <chSysUnlock>
}
 800d03c:	b006      	add	sp, #24
 800d03e:	bd10      	pop	{r4, pc}
 800d040:	08019750 	.word	0x08019750
 800d044:	0800ce91 	.word	0x0800ce91
 800d048:	2000205c 	.word	0x2000205c
 800d04c:	f3af 8000 	nop.w

0800d050 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800d050:	b082      	sub	sp, #8
 800d052:	2320      	movs	r3, #32
 800d054:	9301      	str	r3, [sp, #4]
 800d056:	9b01      	ldr	r3, [sp, #4]
 800d058:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d05c:	b002      	add	sp, #8
 800d05e:	4770      	bx	lr

0800d060 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800d060:	b082      	sub	sp, #8
 800d062:	2300      	movs	r3, #0
 800d064:	9301      	str	r3, [sp, #4]
 800d066:	9b01      	ldr	r3, [sp, #4]
 800d068:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800d06c:	b002      	add	sp, #8
 800d06e:	4770      	bx	lr

0800d070 <queue_isempty>:
 * @param[in] tqp       pointer to the threads queue object
 * @return              The status of the queue.
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {
 800d070:	b082      	sub	sp, #8
 800d072:	9001      	str	r0, [sp, #4]

  return (bool)(tqp->p_next == (const thread_t *)tqp);
 800d074:	9b01      	ldr	r3, [sp, #4]
 800d076:	681a      	ldr	r2, [r3, #0]
 800d078:	9b01      	ldr	r3, [sp, #4]
 800d07a:	429a      	cmp	r2, r3
 800d07c:	bf14      	ite	ne
 800d07e:	2300      	movne	r3, #0
 800d080:	2301      	moveq	r3, #1
 800d082:	b2db      	uxtb	r3, r3
}
 800d084:	4618      	mov	r0, r3
 800d086:	b002      	add	sp, #8
 800d088:	4770      	bx	lr
 800d08a:	bf00      	nop
 800d08c:	f3af 8000 	nop.w

0800d090 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800d090:	b508      	push	{r3, lr}

  port_lock();
 800d092:	f7ff ffdd 	bl	800d050 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800d096:	bd08      	pop	{r3, pc}
 800d098:	f3af 8000 	nop.w
 800d09c:	f3af 8000 	nop.w

0800d0a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800d0a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800d0a2:	f7ff ffdd 	bl	800d060 <port_unlock>
}
 800d0a6:	bd08      	pop	{r3, pc}
 800d0a8:	f3af 8000 	nop.w
 800d0ac:	f3af 8000 	nop.w

0800d0b0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800d0b0:	4b01      	ldr	r3, [pc, #4]	; (800d0b8 <chThdGetSelfX+0x8>)
 800d0b2:	699b      	ldr	r3, [r3, #24]
}
 800d0b4:	4618      	mov	r0, r3
 800d0b6:	4770      	bx	lr
 800d0b8:	20001bc8 	.word	0x20001bc8
 800d0bc:	f3af 8000 	nop.w

0800d0c0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800d0c0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800d0c2:	f7ff fff5 	bl	800d0b0 <chThdGetSelfX>
 800d0c6:	4603      	mov	r3, r0
 800d0c8:	689b      	ldr	r3, [r3, #8]
}
 800d0ca:	4618      	mov	r0, r3
 800d0cc:	bd08      	pop	{r3, pc}
 800d0ce:	bf00      	nop

0800d0d0 <mtx1_setup>:
 * the mutex is unlocked.<br>
 * The test expects the threads to perform their operations in increasing
 * priority order regardless of the initial order.
 */

static void mtx1_setup(void) {
 800d0d0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d0d2:	4802      	ldr	r0, [pc, #8]	; (800d0dc <mtx1_setup+0xc>)
 800d0d4:	f7f4 ff0c 	bl	8001ef0 <chMtxObjectInit>
}
 800d0d8:	bd08      	pop	{r3, pc}
 800d0da:	bf00      	nop
 800d0dc:	20000844 	.word	0x20000844

0800d0e0 <thread1>:

static THD_FUNCTION(thread1, p) {
 800d0e0:	b500      	push	{lr}
 800d0e2:	b083      	sub	sp, #12
 800d0e4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d0e6:	4807      	ldr	r0, [pc, #28]	; (800d104 <thread1+0x24>)
 800d0e8:	f7f4 ff12 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800d0ec:	9b01      	ldr	r3, [sp, #4]
 800d0ee:	781b      	ldrb	r3, [r3, #0]
 800d0f0:	4618      	mov	r0, r3
 800d0f2:	f7fe fe7d 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d0f6:	4803      	ldr	r0, [pc, #12]	; (800d104 <thread1+0x24>)
 800d0f8:	f7f4 ffb2 	bl	8002060 <chMtxUnlock>
}
 800d0fc:	b003      	add	sp, #12
 800d0fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800d102:	bf00      	nop
 800d104:	20000844 	.word	0x20000844
 800d108:	f3af 8000 	nop.w
 800d10c:	f3af 8000 	nop.w

0800d110 <mtx1_execute>:

static void mtx1_execute(void) {
 800d110:	b500      	push	{lr}
 800d112:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX(); /* Because priority inheritance.*/
 800d114:	f7ff ffd4 	bl	800d0c0 <chThdGetPriorityX>
 800d118:	9003      	str	r0, [sp, #12]
  chMtxLock(&m1);
 800d11a:	483a      	ldr	r0, [pc, #232]	; (800d204 <mtx1_execute+0xf4>)
 800d11c:	f7f4 fef8 	bl	8001f10 <chMtxLock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 800d120:	4b39      	ldr	r3, [pc, #228]	; (800d208 <mtx1_execute+0xf8>)
 800d122:	681a      	ldr	r2, [r3, #0]
 800d124:	9b03      	ldr	r3, [sp, #12]
 800d126:	3301      	adds	r3, #1
 800d128:	4938      	ldr	r1, [pc, #224]	; (800d20c <mtx1_execute+0xfc>)
 800d12a:	9100      	str	r1, [sp, #0]
 800d12c:	4610      	mov	r0, r2
 800d12e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d132:	461a      	mov	r2, r3
 800d134:	4b36      	ldr	r3, [pc, #216]	; (800d210 <mtx1_execute+0x100>)
 800d136:	f7f4 f853 	bl	80011e0 <chThdCreateStatic>
 800d13a:	4602      	mov	r2, r0
 800d13c:	4b35      	ldr	r3, [pc, #212]	; (800d214 <mtx1_execute+0x104>)
 800d13e:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 800d140:	4b31      	ldr	r3, [pc, #196]	; (800d208 <mtx1_execute+0xf8>)
 800d142:	685a      	ldr	r2, [r3, #4]
 800d144:	9b03      	ldr	r3, [sp, #12]
 800d146:	3302      	adds	r3, #2
 800d148:	4933      	ldr	r1, [pc, #204]	; (800d218 <mtx1_execute+0x108>)
 800d14a:	9100      	str	r1, [sp, #0]
 800d14c:	4610      	mov	r0, r2
 800d14e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d152:	461a      	mov	r2, r3
 800d154:	4b2e      	ldr	r3, [pc, #184]	; (800d210 <mtx1_execute+0x100>)
 800d156:	f7f4 f843 	bl	80011e0 <chThdCreateStatic>
 800d15a:	4602      	mov	r2, r0
 800d15c:	4b2d      	ldr	r3, [pc, #180]	; (800d214 <mtx1_execute+0x104>)
 800d15e:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 800d160:	4b29      	ldr	r3, [pc, #164]	; (800d208 <mtx1_execute+0xf8>)
 800d162:	689a      	ldr	r2, [r3, #8]
 800d164:	9b03      	ldr	r3, [sp, #12]
 800d166:	3303      	adds	r3, #3
 800d168:	492c      	ldr	r1, [pc, #176]	; (800d21c <mtx1_execute+0x10c>)
 800d16a:	9100      	str	r1, [sp, #0]
 800d16c:	4610      	mov	r0, r2
 800d16e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d172:	461a      	mov	r2, r3
 800d174:	4b26      	ldr	r3, [pc, #152]	; (800d210 <mtx1_execute+0x100>)
 800d176:	f7f4 f833 	bl	80011e0 <chThdCreateStatic>
 800d17a:	4602      	mov	r2, r0
 800d17c:	4b25      	ldr	r3, [pc, #148]	; (800d214 <mtx1_execute+0x104>)
 800d17e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800d180:	4b21      	ldr	r3, [pc, #132]	; (800d208 <mtx1_execute+0xf8>)
 800d182:	68da      	ldr	r2, [r3, #12]
 800d184:	9b03      	ldr	r3, [sp, #12]
 800d186:	3304      	adds	r3, #4
 800d188:	4925      	ldr	r1, [pc, #148]	; (800d220 <mtx1_execute+0x110>)
 800d18a:	9100      	str	r1, [sp, #0]
 800d18c:	4610      	mov	r0, r2
 800d18e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d192:	461a      	mov	r2, r3
 800d194:	4b1e      	ldr	r3, [pc, #120]	; (800d210 <mtx1_execute+0x100>)
 800d196:	f7f4 f823 	bl	80011e0 <chThdCreateStatic>
 800d19a:	4602      	mov	r2, r0
 800d19c:	4b1d      	ldr	r3, [pc, #116]	; (800d214 <mtx1_execute+0x104>)
 800d19e:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800d1a0:	4b19      	ldr	r3, [pc, #100]	; (800d208 <mtx1_execute+0xf8>)
 800d1a2:	691a      	ldr	r2, [r3, #16]
 800d1a4:	9b03      	ldr	r3, [sp, #12]
 800d1a6:	3305      	adds	r3, #5
 800d1a8:	491e      	ldr	r1, [pc, #120]	; (800d224 <mtx1_execute+0x114>)
 800d1aa:	9100      	str	r1, [sp, #0]
 800d1ac:	4610      	mov	r0, r2
 800d1ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d1b2:	461a      	mov	r2, r3
 800d1b4:	4b16      	ldr	r3, [pc, #88]	; (800d210 <mtx1_execute+0x100>)
 800d1b6:	f7f4 f813 	bl	80011e0 <chThdCreateStatic>
 800d1ba:	4602      	mov	r2, r0
 800d1bc:	4b15      	ldr	r3, [pc, #84]	; (800d214 <mtx1_execute+0x104>)
 800d1be:	611a      	str	r2, [r3, #16]
  chMtxUnlock(&m1);
 800d1c0:	4810      	ldr	r0, [pc, #64]	; (800d204 <mtx1_execute+0xf4>)
 800d1c2:	f7f4 ff4d 	bl	8002060 <chMtxUnlock>
  test_wait_threads();
 800d1c6:	f7fe fec3 	bl	800bf50 <test_wait_threads>
  test_assert(1, prio == chThdGetPriorityX(), "wrong priority level");
 800d1ca:	f7ff ff79 	bl	800d0c0 <chThdGetPriorityX>
 800d1ce:	4602      	mov	r2, r0
 800d1d0:	9b03      	ldr	r3, [sp, #12]
 800d1d2:	429a      	cmp	r2, r3
 800d1d4:	bf14      	ite	ne
 800d1d6:	2300      	movne	r3, #0
 800d1d8:	2301      	moveq	r3, #1
 800d1da:	b2db      	uxtb	r3, r3
 800d1dc:	2001      	movs	r0, #1
 800d1de:	4619      	mov	r1, r3
 800d1e0:	f7fe fe36 	bl	800be50 <_test_assert>
 800d1e4:	4603      	mov	r3, r0
 800d1e6:	2b00      	cmp	r3, #0
 800d1e8:	d000      	beq.n	800d1ec <mtx1_execute+0xdc>
 800d1ea:	e007      	b.n	800d1fc <mtx1_execute+0xec>
  test_assert_sequence(2, "ABCDE");
 800d1ec:	2002      	movs	r0, #2
 800d1ee:	490e      	ldr	r1, [pc, #56]	; (800d228 <mtx1_execute+0x118>)
 800d1f0:	f7fe fe46 	bl	800be80 <_test_assert_sequence>
 800d1f4:	4603      	mov	r3, r0
 800d1f6:	2b00      	cmp	r3, #0
 800d1f8:	d000      	beq.n	800d1fc <mtx1_execute+0xec>
 800d1fa:	bf00      	nop
}
 800d1fc:	b005      	add	sp, #20
 800d1fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800d202:	bf00      	nop
 800d204:	20000844 	.word	0x20000844
 800d208:	08019750 	.word	0x08019750
 800d20c:	08019b20 	.word	0x08019b20
 800d210:	0800d0e1 	.word	0x0800d0e1
 800d214:	2000205c 	.word	0x2000205c
 800d218:	08019b24 	.word	0x08019b24
 800d21c:	08019b28 	.word	0x08019b28
 800d220:	08019b2c 	.word	0x08019b2c
 800d224:	08019b30 	.word	0x08019b30
 800d228:	08019b34 	.word	0x08019b34
 800d22c:	f3af 8000 	nop.w

0800d230 <mtx4_setup>:
 * thread with precise timing.<br>
 * The test expects that the priority changes caused by the priority
 * inheritance algorithm happen at the right moment and with the right values.
 */

static void mtx4_setup(void) {
 800d230:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d232:	4803      	ldr	r0, [pc, #12]	; (800d240 <mtx4_setup+0x10>)
 800d234:	f7f4 fe5c 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d238:	4802      	ldr	r0, [pc, #8]	; (800d244 <mtx4_setup+0x14>)
 800d23a:	f7f4 fe59 	bl	8001ef0 <chMtxObjectInit>
}
 800d23e:	bd08      	pop	{r3, pc}
 800d240:	20000844 	.word	0x20000844
 800d244:	20000854 	.word	0x20000854
 800d248:	f3af 8000 	nop.w
 800d24c:	f3af 8000 	nop.w

0800d250 <thread4a>:

static THD_FUNCTION(thread4a, p) {
 800d250:	b500      	push	{lr}
 800d252:	b083      	sub	sp, #12
 800d254:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(50);
 800d256:	2032      	movs	r0, #50	; 0x32
 800d258:	f7f4 f83a 	bl	80012d0 <chThdSleep>
  chMtxLock(&m2);
 800d25c:	4804      	ldr	r0, [pc, #16]	; (800d270 <thread4a+0x20>)
 800d25e:	f7f4 fe57 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m2);
 800d262:	4803      	ldr	r0, [pc, #12]	; (800d270 <thread4a+0x20>)
 800d264:	f7f4 fefc 	bl	8002060 <chMtxUnlock>
}
 800d268:	b003      	add	sp, #12
 800d26a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d26e:	bf00      	nop
 800d270:	20000854 	.word	0x20000854
 800d274:	f3af 8000 	nop.w
 800d278:	f3af 8000 	nop.w
 800d27c:	f3af 8000 	nop.w

0800d280 <thread4b>:

static THD_FUNCTION(thread4b, p) {
 800d280:	b500      	push	{lr}
 800d282:	b083      	sub	sp, #12
 800d284:	9001      	str	r0, [sp, #4]

  (void)p;
  chThdSleepMilliseconds(150);
 800d286:	2096      	movs	r0, #150	; 0x96
 800d288:	f7f4 f822 	bl	80012d0 <chThdSleep>
  chMtxLock(&m1);
 800d28c:	4804      	ldr	r0, [pc, #16]	; (800d2a0 <thread4b+0x20>)
 800d28e:	f7f4 fe3f 	bl	8001f10 <chMtxLock>
  chMtxUnlock(&m1);
 800d292:	4803      	ldr	r0, [pc, #12]	; (800d2a0 <thread4b+0x20>)
 800d294:	f7f4 fee4 	bl	8002060 <chMtxUnlock>
}
 800d298:	b003      	add	sp, #12
 800d29a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d29e:	bf00      	nop
 800d2a0:	20000844 	.word	0x20000844
 800d2a4:	f3af 8000 	nop.w
 800d2a8:	f3af 8000 	nop.w
 800d2ac:	f3af 8000 	nop.w

0800d2b0 <mtx4_execute>:

static void mtx4_execute(void) {
 800d2b0:	b500      	push	{lr}
 800d2b2:	b087      	sub	sp, #28
  tprio_t p, p1, p2;

  p = chThdGetPriorityX();
 800d2b4:	f7ff ff04 	bl	800d0c0 <chThdGetPriorityX>
 800d2b8:	9005      	str	r0, [sp, #20]
  p1 = p + 1;
 800d2ba:	9b05      	ldr	r3, [sp, #20]
 800d2bc:	3301      	adds	r3, #1
 800d2be:	9304      	str	r3, [sp, #16]
  p2 = p + 2;
 800d2c0:	9b05      	ldr	r3, [sp, #20]
 800d2c2:	3302      	adds	r3, #2
 800d2c4:	9303      	str	r3, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "B");
 800d2c6:	4ba1      	ldr	r3, [pc, #644]	; (800d54c <mtx4_execute+0x29c>)
 800d2c8:	681b      	ldr	r3, [r3, #0]
 800d2ca:	4aa1      	ldr	r2, [pc, #644]	; (800d550 <mtx4_execute+0x2a0>)
 800d2cc:	9200      	str	r2, [sp, #0]
 800d2ce:	4618      	mov	r0, r3
 800d2d0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d2d4:	9a04      	ldr	r2, [sp, #16]
 800d2d6:	4b9f      	ldr	r3, [pc, #636]	; (800d554 <mtx4_execute+0x2a4>)
 800d2d8:	f7f3 ff82 	bl	80011e0 <chThdCreateStatic>
 800d2dc:	4602      	mov	r2, r0
 800d2de:	4b9e      	ldr	r3, [pc, #632]	; (800d558 <mtx4_execute+0x2a8>)
 800d2e0:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "A");
 800d2e2:	4b9a      	ldr	r3, [pc, #616]	; (800d54c <mtx4_execute+0x29c>)
 800d2e4:	685b      	ldr	r3, [r3, #4]
 800d2e6:	4a9d      	ldr	r2, [pc, #628]	; (800d55c <mtx4_execute+0x2ac>)
 800d2e8:	9200      	str	r2, [sp, #0]
 800d2ea:	4618      	mov	r0, r3
 800d2ec:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d2f0:	9a03      	ldr	r2, [sp, #12]
 800d2f2:	4b9b      	ldr	r3, [pc, #620]	; (800d560 <mtx4_execute+0x2b0>)
 800d2f4:	f7f3 ff74 	bl	80011e0 <chThdCreateStatic>
 800d2f8:	4602      	mov	r2, r0
 800d2fa:	4b97      	ldr	r3, [pc, #604]	; (800d558 <mtx4_execute+0x2a8>)
 800d2fc:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d2fe:	4899      	ldr	r0, [pc, #612]	; (800d564 <mtx4_execute+0x2b4>)
 800d300:	f7f4 fe06 	bl	8001f10 <chMtxLock>
  test_assert(1, chThdGetPriorityX() == p, "wrong priority level");
 800d304:	f7ff fedc 	bl	800d0c0 <chThdGetPriorityX>
 800d308:	4602      	mov	r2, r0
 800d30a:	9b05      	ldr	r3, [sp, #20]
 800d30c:	429a      	cmp	r2, r3
 800d30e:	bf14      	ite	ne
 800d310:	2300      	movne	r3, #0
 800d312:	2301      	moveq	r3, #1
 800d314:	b2db      	uxtb	r3, r3
 800d316:	2001      	movs	r0, #1
 800d318:	4619      	mov	r1, r3
 800d31a:	f7fe fd99 	bl	800be50 <_test_assert>
 800d31e:	4603      	mov	r3, r0
 800d320:	2b00      	cmp	r3, #0
 800d322:	d000      	beq.n	800d326 <mtx4_execute+0x76>
 800d324:	e13b      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d326:	2064      	movs	r0, #100	; 0x64
 800d328:	f7f3 ffd2 	bl	80012d0 <chThdSleep>
  test_assert(2, chThdGetPriorityX() == p1, "wrong priority level");
 800d32c:	f7ff fec8 	bl	800d0c0 <chThdGetPriorityX>
 800d330:	4602      	mov	r2, r0
 800d332:	9b04      	ldr	r3, [sp, #16]
 800d334:	429a      	cmp	r2, r3
 800d336:	bf14      	ite	ne
 800d338:	2300      	movne	r3, #0
 800d33a:	2301      	moveq	r3, #1
 800d33c:	b2db      	uxtb	r3, r3
 800d33e:	2002      	movs	r0, #2
 800d340:	4619      	mov	r1, r3
 800d342:	f7fe fd85 	bl	800be50 <_test_assert>
 800d346:	4603      	mov	r3, r0
 800d348:	2b00      	cmp	r3, #0
 800d34a:	d000      	beq.n	800d34e <mtx4_execute+0x9e>
 800d34c:	e127      	b.n	800d59e <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800d34e:	4886      	ldr	r0, [pc, #536]	; (800d568 <mtx4_execute+0x2b8>)
 800d350:	f7f4 fdde 	bl	8001f10 <chMtxLock>
  test_assert(3, chThdGetPriorityX() == p1, "wrong priority level");
 800d354:	f7ff feb4 	bl	800d0c0 <chThdGetPriorityX>
 800d358:	4602      	mov	r2, r0
 800d35a:	9b04      	ldr	r3, [sp, #16]
 800d35c:	429a      	cmp	r2, r3
 800d35e:	bf14      	ite	ne
 800d360:	2300      	movne	r3, #0
 800d362:	2301      	moveq	r3, #1
 800d364:	b2db      	uxtb	r3, r3
 800d366:	2003      	movs	r0, #3
 800d368:	4619      	mov	r1, r3
 800d36a:	f7fe fd71 	bl	800be50 <_test_assert>
 800d36e:	4603      	mov	r3, r0
 800d370:	2b00      	cmp	r3, #0
 800d372:	d000      	beq.n	800d376 <mtx4_execute+0xc6>
 800d374:	e113      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d376:	2064      	movs	r0, #100	; 0x64
 800d378:	f7f3 ffaa 	bl	80012d0 <chThdSleep>
  test_assert(4, chThdGetPriorityX() == p2, "wrong priority level");
 800d37c:	f7ff fea0 	bl	800d0c0 <chThdGetPriorityX>
 800d380:	4602      	mov	r2, r0
 800d382:	9b03      	ldr	r3, [sp, #12]
 800d384:	429a      	cmp	r2, r3
 800d386:	bf14      	ite	ne
 800d388:	2300      	movne	r3, #0
 800d38a:	2301      	moveq	r3, #1
 800d38c:	b2db      	uxtb	r3, r3
 800d38e:	2004      	movs	r0, #4
 800d390:	4619      	mov	r1, r3
 800d392:	f7fe fd5d 	bl	800be50 <_test_assert>
 800d396:	4603      	mov	r3, r0
 800d398:	2b00      	cmp	r3, #0
 800d39a:	d000      	beq.n	800d39e <mtx4_execute+0xee>
 800d39c:	e0ff      	b.n	800d59e <mtx4_execute+0x2ee>
  chMtxUnlock(&m1);
 800d39e:	4872      	ldr	r0, [pc, #456]	; (800d568 <mtx4_execute+0x2b8>)
 800d3a0:	f7f4 fe5e 	bl	8002060 <chMtxUnlock>
  test_assert(5, chThdGetPriorityX() == p1, "wrong priority level");
 800d3a4:	f7ff fe8c 	bl	800d0c0 <chThdGetPriorityX>
 800d3a8:	4602      	mov	r2, r0
 800d3aa:	9b04      	ldr	r3, [sp, #16]
 800d3ac:	429a      	cmp	r2, r3
 800d3ae:	bf14      	ite	ne
 800d3b0:	2300      	movne	r3, #0
 800d3b2:	2301      	moveq	r3, #1
 800d3b4:	b2db      	uxtb	r3, r3
 800d3b6:	2005      	movs	r0, #5
 800d3b8:	4619      	mov	r1, r3
 800d3ba:	f7fe fd49 	bl	800be50 <_test_assert>
 800d3be:	4603      	mov	r3, r0
 800d3c0:	2b00      	cmp	r3, #0
 800d3c2:	d000      	beq.n	800d3c6 <mtx4_execute+0x116>
 800d3c4:	e0eb      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d3c6:	2064      	movs	r0, #100	; 0x64
 800d3c8:	f7f3 ff82 	bl	80012d0 <chThdSleep>
  test_assert(6, chThdGetPriorityX() == p1, "wrong priority level");
 800d3cc:	f7ff fe78 	bl	800d0c0 <chThdGetPriorityX>
 800d3d0:	4602      	mov	r2, r0
 800d3d2:	9b04      	ldr	r3, [sp, #16]
 800d3d4:	429a      	cmp	r2, r3
 800d3d6:	bf14      	ite	ne
 800d3d8:	2300      	movne	r3, #0
 800d3da:	2301      	moveq	r3, #1
 800d3dc:	b2db      	uxtb	r3, r3
 800d3de:	2006      	movs	r0, #6
 800d3e0:	4619      	mov	r1, r3
 800d3e2:	f7fe fd35 	bl	800be50 <_test_assert>
 800d3e6:	4603      	mov	r3, r0
 800d3e8:	2b00      	cmp	r3, #0
 800d3ea:	d000      	beq.n	800d3ee <mtx4_execute+0x13e>
 800d3ec:	e0d7      	b.n	800d59e <mtx4_execute+0x2ee>
  chMtxUnlockAll();
 800d3ee:	f7f4 fedf 	bl	80021b0 <chMtxUnlockAll>
  test_assert(7, chThdGetPriorityX() == p, "wrong priority level");
 800d3f2:	f7ff fe65 	bl	800d0c0 <chThdGetPriorityX>
 800d3f6:	4602      	mov	r2, r0
 800d3f8:	9b05      	ldr	r3, [sp, #20]
 800d3fa:	429a      	cmp	r2, r3
 800d3fc:	bf14      	ite	ne
 800d3fe:	2300      	movne	r3, #0
 800d400:	2301      	moveq	r3, #1
 800d402:	b2db      	uxtb	r3, r3
 800d404:	2007      	movs	r0, #7
 800d406:	4619      	mov	r1, r3
 800d408:	f7fe fd22 	bl	800be50 <_test_assert>
 800d40c:	4603      	mov	r3, r0
 800d40e:	2b00      	cmp	r3, #0
 800d410:	d000      	beq.n	800d414 <mtx4_execute+0x164>
 800d412:	e0c4      	b.n	800d59e <mtx4_execute+0x2ee>
  test_wait_threads();
 800d414:	f7fe fd9c 	bl	800bf50 <test_wait_threads>

  /* Test repeated in order to cover chMtxUnlockS().*/
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, p1, thread4a, "D");
 800d418:	4b4c      	ldr	r3, [pc, #304]	; (800d54c <mtx4_execute+0x29c>)
 800d41a:	681b      	ldr	r3, [r3, #0]
 800d41c:	4a53      	ldr	r2, [pc, #332]	; (800d56c <mtx4_execute+0x2bc>)
 800d41e:	9200      	str	r2, [sp, #0]
 800d420:	4618      	mov	r0, r3
 800d422:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d426:	9a04      	ldr	r2, [sp, #16]
 800d428:	4b4a      	ldr	r3, [pc, #296]	; (800d554 <mtx4_execute+0x2a4>)
 800d42a:	f7f3 fed9 	bl	80011e0 <chThdCreateStatic>
 800d42e:	4602      	mov	r2, r0
 800d430:	4b49      	ldr	r3, [pc, #292]	; (800d558 <mtx4_execute+0x2a8>)
 800d432:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, p2, thread4b, "C");
 800d434:	4b45      	ldr	r3, [pc, #276]	; (800d54c <mtx4_execute+0x29c>)
 800d436:	685b      	ldr	r3, [r3, #4]
 800d438:	4a4d      	ldr	r2, [pc, #308]	; (800d570 <mtx4_execute+0x2c0>)
 800d43a:	9200      	str	r2, [sp, #0]
 800d43c:	4618      	mov	r0, r3
 800d43e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d442:	9a03      	ldr	r2, [sp, #12]
 800d444:	4b46      	ldr	r3, [pc, #280]	; (800d560 <mtx4_execute+0x2b0>)
 800d446:	f7f3 fecb 	bl	80011e0 <chThdCreateStatic>
 800d44a:	4602      	mov	r2, r0
 800d44c:	4b42      	ldr	r3, [pc, #264]	; (800d558 <mtx4_execute+0x2a8>)
 800d44e:	605a      	str	r2, [r3, #4]
  chMtxLock(&m2);
 800d450:	4844      	ldr	r0, [pc, #272]	; (800d564 <mtx4_execute+0x2b4>)
 800d452:	f7f4 fd5d 	bl	8001f10 <chMtxLock>
  test_assert(8, chThdGetPriorityX() == p, "wrong priority level");
 800d456:	f7ff fe33 	bl	800d0c0 <chThdGetPriorityX>
 800d45a:	4602      	mov	r2, r0
 800d45c:	9b05      	ldr	r3, [sp, #20]
 800d45e:	429a      	cmp	r2, r3
 800d460:	bf14      	ite	ne
 800d462:	2300      	movne	r3, #0
 800d464:	2301      	moveq	r3, #1
 800d466:	b2db      	uxtb	r3, r3
 800d468:	2008      	movs	r0, #8
 800d46a:	4619      	mov	r1, r3
 800d46c:	f7fe fcf0 	bl	800be50 <_test_assert>
 800d470:	4603      	mov	r3, r0
 800d472:	2b00      	cmp	r3, #0
 800d474:	d000      	beq.n	800d478 <mtx4_execute+0x1c8>
 800d476:	e092      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d478:	2064      	movs	r0, #100	; 0x64
 800d47a:	f7f3 ff29 	bl	80012d0 <chThdSleep>
  test_assert(9, chThdGetPriorityX() == p1, "wrong priority level");
 800d47e:	f7ff fe1f 	bl	800d0c0 <chThdGetPriorityX>
 800d482:	4602      	mov	r2, r0
 800d484:	9b04      	ldr	r3, [sp, #16]
 800d486:	429a      	cmp	r2, r3
 800d488:	bf14      	ite	ne
 800d48a:	2300      	movne	r3, #0
 800d48c:	2301      	moveq	r3, #1
 800d48e:	b2db      	uxtb	r3, r3
 800d490:	2009      	movs	r0, #9
 800d492:	4619      	mov	r1, r3
 800d494:	f7fe fcdc 	bl	800be50 <_test_assert>
 800d498:	4603      	mov	r3, r0
 800d49a:	2b00      	cmp	r3, #0
 800d49c:	d000      	beq.n	800d4a0 <mtx4_execute+0x1f0>
 800d49e:	e07e      	b.n	800d59e <mtx4_execute+0x2ee>
  chMtxLock(&m1);
 800d4a0:	4831      	ldr	r0, [pc, #196]	; (800d568 <mtx4_execute+0x2b8>)
 800d4a2:	f7f4 fd35 	bl	8001f10 <chMtxLock>
  test_assert(10, chThdGetPriorityX() == p1, "wrong priority level");
 800d4a6:	f7ff fe0b 	bl	800d0c0 <chThdGetPriorityX>
 800d4aa:	4602      	mov	r2, r0
 800d4ac:	9b04      	ldr	r3, [sp, #16]
 800d4ae:	429a      	cmp	r2, r3
 800d4b0:	bf14      	ite	ne
 800d4b2:	2300      	movne	r3, #0
 800d4b4:	2301      	moveq	r3, #1
 800d4b6:	b2db      	uxtb	r3, r3
 800d4b8:	200a      	movs	r0, #10
 800d4ba:	4619      	mov	r1, r3
 800d4bc:	f7fe fcc8 	bl	800be50 <_test_assert>
 800d4c0:	4603      	mov	r3, r0
 800d4c2:	2b00      	cmp	r3, #0
 800d4c4:	d000      	beq.n	800d4c8 <mtx4_execute+0x218>
 800d4c6:	e06a      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d4c8:	2064      	movs	r0, #100	; 0x64
 800d4ca:	f7f3 ff01 	bl	80012d0 <chThdSleep>
  test_assert(11, chThdGetPriorityX() == p2, "wrong priority level");
 800d4ce:	f7ff fdf7 	bl	800d0c0 <chThdGetPriorityX>
 800d4d2:	4602      	mov	r2, r0
 800d4d4:	9b03      	ldr	r3, [sp, #12]
 800d4d6:	429a      	cmp	r2, r3
 800d4d8:	bf14      	ite	ne
 800d4da:	2300      	movne	r3, #0
 800d4dc:	2301      	moveq	r3, #1
 800d4de:	b2db      	uxtb	r3, r3
 800d4e0:	200b      	movs	r0, #11
 800d4e2:	4619      	mov	r1, r3
 800d4e4:	f7fe fcb4 	bl	800be50 <_test_assert>
 800d4e8:	4603      	mov	r3, r0
 800d4ea:	2b00      	cmp	r3, #0
 800d4ec:	d000      	beq.n	800d4f0 <mtx4_execute+0x240>
 800d4ee:	e056      	b.n	800d59e <mtx4_execute+0x2ee>
  chSysLock();
 800d4f0:	f7ff fdce 	bl	800d090 <chSysLock>
  chMtxUnlockS(&m1);
 800d4f4:	481c      	ldr	r0, [pc, #112]	; (800d568 <mtx4_execute+0x2b8>)
 800d4f6:	f7f4 fe0b 	bl	8002110 <chMtxUnlockS>
  chSchRescheduleS();
 800d4fa:	f7f3 fc41 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d4fe:	f7ff fdcf 	bl	800d0a0 <chSysUnlock>
  test_assert(12, chThdGetPriorityX() == p1, "wrong priority level");
 800d502:	f7ff fddd 	bl	800d0c0 <chThdGetPriorityX>
 800d506:	4602      	mov	r2, r0
 800d508:	9b04      	ldr	r3, [sp, #16]
 800d50a:	429a      	cmp	r2, r3
 800d50c:	bf14      	ite	ne
 800d50e:	2300      	movne	r3, #0
 800d510:	2301      	moveq	r3, #1
 800d512:	b2db      	uxtb	r3, r3
 800d514:	200c      	movs	r0, #12
 800d516:	4619      	mov	r1, r3
 800d518:	f7fe fc9a 	bl	800be50 <_test_assert>
 800d51c:	4603      	mov	r3, r0
 800d51e:	2b00      	cmp	r3, #0
 800d520:	d000      	beq.n	800d524 <mtx4_execute+0x274>
 800d522:	e03c      	b.n	800d59e <mtx4_execute+0x2ee>
  chThdSleepMilliseconds(100);
 800d524:	2064      	movs	r0, #100	; 0x64
 800d526:	f7f3 fed3 	bl	80012d0 <chThdSleep>
  test_assert(13, chThdGetPriorityX() == p1, "wrong priority level");
 800d52a:	f7ff fdc9 	bl	800d0c0 <chThdGetPriorityX>
 800d52e:	4602      	mov	r2, r0
 800d530:	9b04      	ldr	r3, [sp, #16]
 800d532:	429a      	cmp	r2, r3
 800d534:	bf14      	ite	ne
 800d536:	2300      	movne	r3, #0
 800d538:	2301      	moveq	r3, #1
 800d53a:	b2db      	uxtb	r3, r3
 800d53c:	200d      	movs	r0, #13
 800d53e:	4619      	mov	r1, r3
 800d540:	f7fe fc86 	bl	800be50 <_test_assert>
 800d544:	4603      	mov	r3, r0
 800d546:	2b00      	cmp	r3, #0
 800d548:	d014      	beq.n	800d574 <mtx4_execute+0x2c4>
 800d54a:	e028      	b.n	800d59e <mtx4_execute+0x2ee>
 800d54c:	08019750 	.word	0x08019750
 800d550:	08019b2c 	.word	0x08019b2c
 800d554:	0800d251 	.word	0x0800d251
 800d558:	2000205c 	.word	0x2000205c
 800d55c:	08019b30 	.word	0x08019b30
 800d560:	0800d281 	.word	0x0800d281
 800d564:	20000854 	.word	0x20000854
 800d568:	20000844 	.word	0x20000844
 800d56c:	08019b24 	.word	0x08019b24
 800d570:	08019b28 	.word	0x08019b28
  chMtxUnlockAll();
 800d574:	f7f4 fe1c 	bl	80021b0 <chMtxUnlockAll>
  test_assert(14, chThdGetPriorityX() == p, "wrong priority level");
 800d578:	f7ff fda2 	bl	800d0c0 <chThdGetPriorityX>
 800d57c:	4602      	mov	r2, r0
 800d57e:	9b05      	ldr	r3, [sp, #20]
 800d580:	429a      	cmp	r2, r3
 800d582:	bf14      	ite	ne
 800d584:	2300      	movne	r3, #0
 800d586:	2301      	moveq	r3, #1
 800d588:	b2db      	uxtb	r3, r3
 800d58a:	200e      	movs	r0, #14
 800d58c:	4619      	mov	r1, r3
 800d58e:	f7fe fc5f 	bl	800be50 <_test_assert>
 800d592:	4603      	mov	r3, r0
 800d594:	2b00      	cmp	r3, #0
 800d596:	d000      	beq.n	800d59a <mtx4_execute+0x2ea>
 800d598:	e001      	b.n	800d59e <mtx4_execute+0x2ee>
  test_wait_threads();
 800d59a:	f7fe fcd9 	bl	800bf50 <test_wait_threads>
}
 800d59e:	b007      	add	sp, #28
 800d5a0:	f85d fb04 	ldr.w	pc, [sp], #4
 800d5a4:	f3af 8000 	nop.w
 800d5a8:	f3af 8000 	nop.w
 800d5ac:	f3af 8000 	nop.w

0800d5b0 <mtx5_setup>:
 * unlock operations.<br>
 * The test expects that the internal mutex status is consistent after each
 * operation.
 */

static void mtx5_setup(void) {
 800d5b0:	b508      	push	{r3, lr}

  chMtxObjectInit(&m1);
 800d5b2:	4802      	ldr	r0, [pc, #8]	; (800d5bc <mtx5_setup+0xc>)
 800d5b4:	f7f4 fc9c 	bl	8001ef0 <chMtxObjectInit>
}
 800d5b8:	bd08      	pop	{r3, pc}
 800d5ba:	bf00      	nop
 800d5bc:	20000844 	.word	0x20000844

0800d5c0 <mtx5_execute>:

static void mtx5_execute(void) {
 800d5c0:	b500      	push	{lr}
 800d5c2:	b083      	sub	sp, #12

#if !CH_CFG_USE_MUTEXES_RECURSIVE
  bool b;
  tprio_t prio = chThdGetPriorityX();
 800d5c4:	f7ff fd7c 	bl	800d0c0 <chThdGetPriorityX>
 800d5c8:	9001      	str	r0, [sp, #4]

  b = chMtxTryLock(&m1);
 800d5ca:	4840      	ldr	r0, [pc, #256]	; (800d6cc <mtx5_execute+0x10c>)
 800d5cc:	f7f4 fd10 	bl	8001ff0 <chMtxTryLock>
 800d5d0:	4603      	mov	r3, r0
 800d5d2:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(1, b, "already locked");
 800d5d6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d5da:	2001      	movs	r0, #1
 800d5dc:	4619      	mov	r1, r3
 800d5de:	f7fe fc37 	bl	800be50 <_test_assert>
 800d5e2:	4603      	mov	r3, r0
 800d5e4:	2b00      	cmp	r3, #0
 800d5e6:	d000      	beq.n	800d5ea <mtx5_execute+0x2a>
 800d5e8:	e06d      	b.n	800d6c6 <mtx5_execute+0x106>

  b = chMtxTryLock(&m1);
 800d5ea:	4838      	ldr	r0, [pc, #224]	; (800d6cc <mtx5_execute+0x10c>)
 800d5ec:	f7f4 fd00 	bl	8001ff0 <chMtxTryLock>
 800d5f0:	4603      	mov	r3, r0
 800d5f2:	f88d 3003 	strb.w	r3, [sp, #3]
  test_assert(2, !b, "not locked");
 800d5f6:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800d5fa:	2b00      	cmp	r3, #0
 800d5fc:	bf0c      	ite	eq
 800d5fe:	2300      	moveq	r3, #0
 800d600:	2301      	movne	r3, #1
 800d602:	b2db      	uxtb	r3, r3
 800d604:	f083 0301 	eor.w	r3, r3, #1
 800d608:	b2db      	uxtb	r3, r3
 800d60a:	f003 0301 	and.w	r3, r3, #1
 800d60e:	b2db      	uxtb	r3, r3
 800d610:	2002      	movs	r0, #2
 800d612:	4619      	mov	r1, r3
 800d614:	f7fe fc1c 	bl	800be50 <_test_assert>
 800d618:	4603      	mov	r3, r0
 800d61a:	2b00      	cmp	r3, #0
 800d61c:	d000      	beq.n	800d620 <mtx5_execute+0x60>
 800d61e:	e052      	b.n	800d6c6 <mtx5_execute+0x106>

  chSysLock();
 800d620:	f7ff fd36 	bl	800d090 <chSysLock>
  chMtxUnlockS(&m1);
 800d624:	4829      	ldr	r0, [pc, #164]	; (800d6cc <mtx5_execute+0x10c>)
 800d626:	f7f4 fd73 	bl	8002110 <chMtxUnlockS>
  chSysUnlock();
 800d62a:	f7ff fd39 	bl	800d0a0 <chSysUnlock>

  test_assert(3, queue_isempty(&m1.m_queue), "queue not empty");
 800d62e:	4827      	ldr	r0, [pc, #156]	; (800d6cc <mtx5_execute+0x10c>)
 800d630:	f7ff fd1e 	bl	800d070 <queue_isempty>
 800d634:	4603      	mov	r3, r0
 800d636:	2003      	movs	r0, #3
 800d638:	4619      	mov	r1, r3
 800d63a:	f7fe fc09 	bl	800be50 <_test_assert>
 800d63e:	4603      	mov	r3, r0
 800d640:	2b00      	cmp	r3, #0
 800d642:	d000      	beq.n	800d646 <mtx5_execute+0x86>
 800d644:	e03f      	b.n	800d6c6 <mtx5_execute+0x106>
  test_assert(4, m1.m_owner == NULL, "still owned");
 800d646:	4b21      	ldr	r3, [pc, #132]	; (800d6cc <mtx5_execute+0x10c>)
 800d648:	689b      	ldr	r3, [r3, #8]
 800d64a:	2b00      	cmp	r3, #0
 800d64c:	bf14      	ite	ne
 800d64e:	2300      	movne	r3, #0
 800d650:	2301      	moveq	r3, #1
 800d652:	b2db      	uxtb	r3, r3
 800d654:	2004      	movs	r0, #4
 800d656:	4619      	mov	r1, r3
 800d658:	f7fe fbfa 	bl	800be50 <_test_assert>
 800d65c:	4603      	mov	r3, r0
 800d65e:	2b00      	cmp	r3, #0
 800d660:	d000      	beq.n	800d664 <mtx5_execute+0xa4>
 800d662:	e030      	b.n	800d6c6 <mtx5_execute+0x106>
  test_assert(5, chThdGetPriorityX() == prio, "wrong priority level");
 800d664:	f7ff fd2c 	bl	800d0c0 <chThdGetPriorityX>
 800d668:	4602      	mov	r2, r0
 800d66a:	9b01      	ldr	r3, [sp, #4]
 800d66c:	429a      	cmp	r2, r3
 800d66e:	bf14      	ite	ne
 800d670:	2300      	movne	r3, #0
 800d672:	2301      	moveq	r3, #1
 800d674:	b2db      	uxtb	r3, r3
 800d676:	2005      	movs	r0, #5
 800d678:	4619      	mov	r1, r3
 800d67a:	f7fe fbe9 	bl	800be50 <_test_assert>
 800d67e:	4603      	mov	r3, r0
 800d680:	2b00      	cmp	r3, #0
 800d682:	d000      	beq.n	800d686 <mtx5_execute+0xc6>
 800d684:	e01f      	b.n	800d6c6 <mtx5_execute+0x106>
#endif /* !CH_CFG_USE_MUTEXES_RECURSIVE */
  
  chMtxLock(&m1);
 800d686:	4811      	ldr	r0, [pc, #68]	; (800d6cc <mtx5_execute+0x10c>)
 800d688:	f7f4 fc42 	bl	8001f10 <chMtxLock>
  chMtxUnlockAll();
 800d68c:	f7f4 fd90 	bl	80021b0 <chMtxUnlockAll>
  test_assert(6, queue_isempty(&m1.m_queue), "queue not empty");
 800d690:	480e      	ldr	r0, [pc, #56]	; (800d6cc <mtx5_execute+0x10c>)
 800d692:	f7ff fced 	bl	800d070 <queue_isempty>
 800d696:	4603      	mov	r3, r0
 800d698:	2006      	movs	r0, #6
 800d69a:	4619      	mov	r1, r3
 800d69c:	f7fe fbd8 	bl	800be50 <_test_assert>
 800d6a0:	4603      	mov	r3, r0
 800d6a2:	2b00      	cmp	r3, #0
 800d6a4:	d000      	beq.n	800d6a8 <mtx5_execute+0xe8>
 800d6a6:	e00e      	b.n	800d6c6 <mtx5_execute+0x106>
  test_assert(7, m1.m_owner == NULL, "still owned");
 800d6a8:	4b08      	ldr	r3, [pc, #32]	; (800d6cc <mtx5_execute+0x10c>)
 800d6aa:	689b      	ldr	r3, [r3, #8]
 800d6ac:	2b00      	cmp	r3, #0
 800d6ae:	bf14      	ite	ne
 800d6b0:	2300      	movne	r3, #0
 800d6b2:	2301      	moveq	r3, #1
 800d6b4:	b2db      	uxtb	r3, r3
 800d6b6:	2007      	movs	r0, #7
 800d6b8:	4619      	mov	r1, r3
 800d6ba:	f7fe fbc9 	bl	800be50 <_test_assert>
 800d6be:	4603      	mov	r3, r0
 800d6c0:	2b00      	cmp	r3, #0
 800d6c2:	d000      	beq.n	800d6c6 <mtx5_execute+0x106>
 800d6c4:	bf00      	nop
}
 800d6c6:	b003      	add	sp, #12
 800d6c8:	f85d fb04 	ldr.w	pc, [sp], #4
 800d6cc:	20000844 	.word	0x20000844

0800d6d0 <mtx6_setup>:
 * atomically.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx6_setup(void) {
 800d6d0:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d6d2:	4803      	ldr	r0, [pc, #12]	; (800d6e0 <mtx6_setup+0x10>)
 800d6d4:	f7f4 fe3c 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d6d8:	4802      	ldr	r0, [pc, #8]	; (800d6e4 <mtx6_setup+0x14>)
 800d6da:	f7f4 fc09 	bl	8001ef0 <chMtxObjectInit>
}
 800d6de:	bd08      	pop	{r3, pc}
 800d6e0:	20000864 	.word	0x20000864
 800d6e4:	20000844 	.word	0x20000844
 800d6e8:	f3af 8000 	nop.w
 800d6ec:	f3af 8000 	nop.w

0800d6f0 <thread10>:

static THD_FUNCTION(thread10, p) {
 800d6f0:	b500      	push	{lr}
 800d6f2:	b083      	sub	sp, #12
 800d6f4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m1);
 800d6f6:	4808      	ldr	r0, [pc, #32]	; (800d718 <thread10+0x28>)
 800d6f8:	f7f4 fc0a 	bl	8001f10 <chMtxLock>
  chCondWait(&c1);
 800d6fc:	4807      	ldr	r0, [pc, #28]	; (800d71c <thread10+0x2c>)
 800d6fe:	f7f4 fe9f 	bl	8002440 <chCondWait>
  test_emit_token(*(char *)p);
 800d702:	9b01      	ldr	r3, [sp, #4]
 800d704:	781b      	ldrb	r3, [r3, #0]
 800d706:	4618      	mov	r0, r3
 800d708:	f7fe fb72 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d70c:	4802      	ldr	r0, [pc, #8]	; (800d718 <thread10+0x28>)
 800d70e:	f7f4 fca7 	bl	8002060 <chMtxUnlock>
}
 800d712:	b003      	add	sp, #12
 800d714:	f85d fb04 	ldr.w	pc, [sp], #4
 800d718:	20000844 	.word	0x20000844
 800d71c:	20000864 	.word	0x20000864

0800d720 <mtx6_execute>:

static void mtx6_execute(void) {
 800d720:	b500      	push	{lr}
 800d722:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d724:	f7ff fccc 	bl	800d0c0 <chThdGetPriorityX>
 800d728:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d72a:	4b39      	ldr	r3, [pc, #228]	; (800d810 <mtx6_execute+0xf0>)
 800d72c:	681a      	ldr	r2, [r3, #0]
 800d72e:	9b03      	ldr	r3, [sp, #12]
 800d730:	3301      	adds	r3, #1
 800d732:	4938      	ldr	r1, [pc, #224]	; (800d814 <mtx6_execute+0xf4>)
 800d734:	9100      	str	r1, [sp, #0]
 800d736:	4610      	mov	r0, r2
 800d738:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d73c:	461a      	mov	r2, r3
 800d73e:	4b36      	ldr	r3, [pc, #216]	; (800d818 <mtx6_execute+0xf8>)
 800d740:	f7f3 fd4e 	bl	80011e0 <chThdCreateStatic>
 800d744:	4602      	mov	r2, r0
 800d746:	4b35      	ldr	r3, [pc, #212]	; (800d81c <mtx6_execute+0xfc>)
 800d748:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d74a:	4b31      	ldr	r3, [pc, #196]	; (800d810 <mtx6_execute+0xf0>)
 800d74c:	685a      	ldr	r2, [r3, #4]
 800d74e:	9b03      	ldr	r3, [sp, #12]
 800d750:	3302      	adds	r3, #2
 800d752:	4933      	ldr	r1, [pc, #204]	; (800d820 <mtx6_execute+0x100>)
 800d754:	9100      	str	r1, [sp, #0]
 800d756:	4610      	mov	r0, r2
 800d758:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d75c:	461a      	mov	r2, r3
 800d75e:	4b2e      	ldr	r3, [pc, #184]	; (800d818 <mtx6_execute+0xf8>)
 800d760:	f7f3 fd3e 	bl	80011e0 <chThdCreateStatic>
 800d764:	4602      	mov	r2, r0
 800d766:	4b2d      	ldr	r3, [pc, #180]	; (800d81c <mtx6_execute+0xfc>)
 800d768:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d76a:	4b29      	ldr	r3, [pc, #164]	; (800d810 <mtx6_execute+0xf0>)
 800d76c:	689a      	ldr	r2, [r3, #8]
 800d76e:	9b03      	ldr	r3, [sp, #12]
 800d770:	3303      	adds	r3, #3
 800d772:	492c      	ldr	r1, [pc, #176]	; (800d824 <mtx6_execute+0x104>)
 800d774:	9100      	str	r1, [sp, #0]
 800d776:	4610      	mov	r0, r2
 800d778:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d77c:	461a      	mov	r2, r3
 800d77e:	4b26      	ldr	r3, [pc, #152]	; (800d818 <mtx6_execute+0xf8>)
 800d780:	f7f3 fd2e 	bl	80011e0 <chThdCreateStatic>
 800d784:	4602      	mov	r2, r0
 800d786:	4b25      	ldr	r3, [pc, #148]	; (800d81c <mtx6_execute+0xfc>)
 800d788:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d78a:	4b21      	ldr	r3, [pc, #132]	; (800d810 <mtx6_execute+0xf0>)
 800d78c:	68da      	ldr	r2, [r3, #12]
 800d78e:	9b03      	ldr	r3, [sp, #12]
 800d790:	3304      	adds	r3, #4
 800d792:	4925      	ldr	r1, [pc, #148]	; (800d828 <mtx6_execute+0x108>)
 800d794:	9100      	str	r1, [sp, #0]
 800d796:	4610      	mov	r0, r2
 800d798:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d79c:	461a      	mov	r2, r3
 800d79e:	4b1e      	ldr	r3, [pc, #120]	; (800d818 <mtx6_execute+0xf8>)
 800d7a0:	f7f3 fd1e 	bl	80011e0 <chThdCreateStatic>
 800d7a4:	4602      	mov	r2, r0
 800d7a6:	4b1d      	ldr	r3, [pc, #116]	; (800d81c <mtx6_execute+0xfc>)
 800d7a8:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d7aa:	4b19      	ldr	r3, [pc, #100]	; (800d810 <mtx6_execute+0xf0>)
 800d7ac:	691a      	ldr	r2, [r3, #16]
 800d7ae:	9b03      	ldr	r3, [sp, #12]
 800d7b0:	3305      	adds	r3, #5
 800d7b2:	491e      	ldr	r1, [pc, #120]	; (800d82c <mtx6_execute+0x10c>)
 800d7b4:	9100      	str	r1, [sp, #0]
 800d7b6:	4610      	mov	r0, r2
 800d7b8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d7bc:	461a      	mov	r2, r3
 800d7be:	4b16      	ldr	r3, [pc, #88]	; (800d818 <mtx6_execute+0xf8>)
 800d7c0:	f7f3 fd0e 	bl	80011e0 <chThdCreateStatic>
 800d7c4:	4602      	mov	r2, r0
 800d7c6:	4b15      	ldr	r3, [pc, #84]	; (800d81c <mtx6_execute+0xfc>)
 800d7c8:	611a      	str	r2, [r3, #16]
  chSysLock();
 800d7ca:	f7ff fc61 	bl	800d090 <chSysLock>
  chCondSignalI(&c1);
 800d7ce:	4818      	ldr	r0, [pc, #96]	; (800d830 <mtx6_execute+0x110>)
 800d7d0:	f7f4 fdee 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7d4:	4816      	ldr	r0, [pc, #88]	; (800d830 <mtx6_execute+0x110>)
 800d7d6:	f7f4 fdeb 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7da:	4815      	ldr	r0, [pc, #84]	; (800d830 <mtx6_execute+0x110>)
 800d7dc:	f7f4 fde8 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7e0:	4813      	ldr	r0, [pc, #76]	; (800d830 <mtx6_execute+0x110>)
 800d7e2:	f7f4 fde5 	bl	80023b0 <chCondSignalI>
  chCondSignalI(&c1);
 800d7e6:	4812      	ldr	r0, [pc, #72]	; (800d830 <mtx6_execute+0x110>)
 800d7e8:	f7f4 fde2 	bl	80023b0 <chCondSignalI>
  chSchRescheduleS();
 800d7ec:	f7f3 fac8 	bl	8000d80 <chSchRescheduleS>
  chSysUnlock();
 800d7f0:	f7ff fc56 	bl	800d0a0 <chSysUnlock>
  test_wait_threads();
 800d7f4:	f7fe fbac 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d7f8:	2001      	movs	r0, #1
 800d7fa:	490e      	ldr	r1, [pc, #56]	; (800d834 <mtx6_execute+0x114>)
 800d7fc:	f7fe fb40 	bl	800be80 <_test_assert_sequence>
 800d800:	4603      	mov	r3, r0
 800d802:	2b00      	cmp	r3, #0
 800d804:	d000      	beq.n	800d808 <mtx6_execute+0xe8>
 800d806:	bf00      	nop
}
 800d808:	b005      	add	sp, #20
 800d80a:	f85d fb04 	ldr.w	pc, [sp], #4
 800d80e:	bf00      	nop
 800d810:	08019750 	.word	0x08019750
 800d814:	08019b20 	.word	0x08019b20
 800d818:	0800d6f1 	.word	0x0800d6f1
 800d81c:	2000205c 	.word	0x2000205c
 800d820:	08019b24 	.word	0x08019b24
 800d824:	08019b28 	.word	0x08019b28
 800d828:	08019b2c 	.word	0x08019b2c
 800d82c:	08019b30 	.word	0x08019b30
 800d830:	20000864 	.word	0x20000864
 800d834:	08019b34 	.word	0x08019b34
 800d838:	f3af 8000 	nop.w
 800d83c:	f3af 8000 	nop.w

0800d840 <mtx7_setup>:
 * tester thread then proceeds to broadcast the conditional variable.<br>
 * The test expects the threads to reach their goal in increasing priority
 * order regardless of the initial order.
 */

static void mtx7_setup(void) {
 800d840:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d842:	4803      	ldr	r0, [pc, #12]	; (800d850 <mtx7_setup+0x10>)
 800d844:	f7f4 fd84 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d848:	4802      	ldr	r0, [pc, #8]	; (800d854 <mtx7_setup+0x14>)
 800d84a:	f7f4 fb51 	bl	8001ef0 <chMtxObjectInit>
}
 800d84e:	bd08      	pop	{r3, pc}
 800d850:	20000864 	.word	0x20000864
 800d854:	20000844 	.word	0x20000844
 800d858:	f3af 8000 	nop.w
 800d85c:	f3af 8000 	nop.w

0800d860 <mtx7_execute>:

static void mtx7_execute(void) {
 800d860:	b500      	push	{lr}
 800d862:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800d864:	f7ff fc2c 	bl	800d0c0 <chThdGetPriorityX>
 800d868:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread10, "E");
 800d86a:	4b30      	ldr	r3, [pc, #192]	; (800d92c <mtx7_execute+0xcc>)
 800d86c:	681a      	ldr	r2, [r3, #0]
 800d86e:	9b03      	ldr	r3, [sp, #12]
 800d870:	3301      	adds	r3, #1
 800d872:	492f      	ldr	r1, [pc, #188]	; (800d930 <mtx7_execute+0xd0>)
 800d874:	9100      	str	r1, [sp, #0]
 800d876:	4610      	mov	r0, r2
 800d878:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d87c:	461a      	mov	r2, r3
 800d87e:	4b2d      	ldr	r3, [pc, #180]	; (800d934 <mtx7_execute+0xd4>)
 800d880:	f7f3 fcae 	bl	80011e0 <chThdCreateStatic>
 800d884:	4602      	mov	r2, r0
 800d886:	4b2c      	ldr	r3, [pc, #176]	; (800d938 <mtx7_execute+0xd8>)
 800d888:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "D");
 800d88a:	4b28      	ldr	r3, [pc, #160]	; (800d92c <mtx7_execute+0xcc>)
 800d88c:	685a      	ldr	r2, [r3, #4]
 800d88e:	9b03      	ldr	r3, [sp, #12]
 800d890:	3302      	adds	r3, #2
 800d892:	492a      	ldr	r1, [pc, #168]	; (800d93c <mtx7_execute+0xdc>)
 800d894:	9100      	str	r1, [sp, #0]
 800d896:	4610      	mov	r0, r2
 800d898:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d89c:	461a      	mov	r2, r3
 800d89e:	4b25      	ldr	r3, [pc, #148]	; (800d934 <mtx7_execute+0xd4>)
 800d8a0:	f7f3 fc9e 	bl	80011e0 <chThdCreateStatic>
 800d8a4:	4602      	mov	r2, r0
 800d8a6:	4b24      	ldr	r3, [pc, #144]	; (800d938 <mtx7_execute+0xd8>)
 800d8a8:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread10, "C");
 800d8aa:	4b20      	ldr	r3, [pc, #128]	; (800d92c <mtx7_execute+0xcc>)
 800d8ac:	689a      	ldr	r2, [r3, #8]
 800d8ae:	9b03      	ldr	r3, [sp, #12]
 800d8b0:	3303      	adds	r3, #3
 800d8b2:	4923      	ldr	r1, [pc, #140]	; (800d940 <mtx7_execute+0xe0>)
 800d8b4:	9100      	str	r1, [sp, #0]
 800d8b6:	4610      	mov	r0, r2
 800d8b8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8bc:	461a      	mov	r2, r3
 800d8be:	4b1d      	ldr	r3, [pc, #116]	; (800d934 <mtx7_execute+0xd4>)
 800d8c0:	f7f3 fc8e 	bl	80011e0 <chThdCreateStatic>
 800d8c4:	4602      	mov	r2, r0
 800d8c6:	4b1c      	ldr	r3, [pc, #112]	; (800d938 <mtx7_execute+0xd8>)
 800d8c8:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread10, "B");
 800d8ca:	4b18      	ldr	r3, [pc, #96]	; (800d92c <mtx7_execute+0xcc>)
 800d8cc:	68da      	ldr	r2, [r3, #12]
 800d8ce:	9b03      	ldr	r3, [sp, #12]
 800d8d0:	3304      	adds	r3, #4
 800d8d2:	491c      	ldr	r1, [pc, #112]	; (800d944 <mtx7_execute+0xe4>)
 800d8d4:	9100      	str	r1, [sp, #0]
 800d8d6:	4610      	mov	r0, r2
 800d8d8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8dc:	461a      	mov	r2, r3
 800d8de:	4b15      	ldr	r3, [pc, #84]	; (800d934 <mtx7_execute+0xd4>)
 800d8e0:	f7f3 fc7e 	bl	80011e0 <chThdCreateStatic>
 800d8e4:	4602      	mov	r2, r0
 800d8e6:	4b14      	ldr	r3, [pc, #80]	; (800d938 <mtx7_execute+0xd8>)
 800d8e8:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread10, "A");
 800d8ea:	4b10      	ldr	r3, [pc, #64]	; (800d92c <mtx7_execute+0xcc>)
 800d8ec:	691a      	ldr	r2, [r3, #16]
 800d8ee:	9b03      	ldr	r3, [sp, #12]
 800d8f0:	3305      	adds	r3, #5
 800d8f2:	4915      	ldr	r1, [pc, #84]	; (800d948 <mtx7_execute+0xe8>)
 800d8f4:	9100      	str	r1, [sp, #0]
 800d8f6:	4610      	mov	r0, r2
 800d8f8:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800d8fc:	461a      	mov	r2, r3
 800d8fe:	4b0d      	ldr	r3, [pc, #52]	; (800d934 <mtx7_execute+0xd4>)
 800d900:	f7f3 fc6e 	bl	80011e0 <chThdCreateStatic>
 800d904:	4602      	mov	r2, r0
 800d906:	4b0c      	ldr	r3, [pc, #48]	; (800d938 <mtx7_execute+0xd8>)
 800d908:	611a      	str	r2, [r3, #16]
  chCondBroadcast(&c1);
 800d90a:	4810      	ldr	r0, [pc, #64]	; (800d94c <mtx7_execute+0xec>)
 800d90c:	f7f4 fd68 	bl	80023e0 <chCondBroadcast>
  test_wait_threads();
 800d910:	f7fe fb1e 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABCDE");
 800d914:	2001      	movs	r0, #1
 800d916:	490e      	ldr	r1, [pc, #56]	; (800d950 <mtx7_execute+0xf0>)
 800d918:	f7fe fab2 	bl	800be80 <_test_assert_sequence>
 800d91c:	4603      	mov	r3, r0
 800d91e:	2b00      	cmp	r3, #0
 800d920:	d000      	beq.n	800d924 <mtx7_execute+0xc4>
 800d922:	bf00      	nop
}
 800d924:	b005      	add	sp, #20
 800d926:	f85d fb04 	ldr.w	pc, [sp], #4
 800d92a:	bf00      	nop
 800d92c:	08019750 	.word	0x08019750
 800d930:	08019b20 	.word	0x08019b20
 800d934:	0800d6f1 	.word	0x0800d6f1
 800d938:	2000205c 	.word	0x2000205c
 800d93c:	08019b24 	.word	0x08019b24
 800d940:	08019b28 	.word	0x08019b28
 800d944:	08019b2c 	.word	0x08019b2c
 800d948:	08019b30 	.word	0x08019b30
 800d94c:	20000864 	.word	0x20000864
 800d950:	08019b34 	.word	0x08019b34
 800d954:	f3af 8000 	nop.w
 800d958:	f3af 8000 	nop.w
 800d95c:	f3af 8000 	nop.w

0800d960 <mtx8_setup>:
 * This test case verifies the priority boost of a thread waiting on a
 * conditional variable queue. It tests this very specific situation in order
 * to complete the code coverage.
 */

static void mtx8_setup(void) {
 800d960:	b508      	push	{r3, lr}

  chCondObjectInit(&c1);
 800d962:	4805      	ldr	r0, [pc, #20]	; (800d978 <mtx8_setup+0x18>)
 800d964:	f7f4 fcf4 	bl	8002350 <chCondObjectInit>
  chMtxObjectInit(&m1);
 800d968:	4804      	ldr	r0, [pc, #16]	; (800d97c <mtx8_setup+0x1c>)
 800d96a:	f7f4 fac1 	bl	8001ef0 <chMtxObjectInit>
  chMtxObjectInit(&m2);
 800d96e:	4804      	ldr	r0, [pc, #16]	; (800d980 <mtx8_setup+0x20>)
 800d970:	f7f4 fabe 	bl	8001ef0 <chMtxObjectInit>
}
 800d974:	bd08      	pop	{r3, pc}
 800d976:	bf00      	nop
 800d978:	20000864 	.word	0x20000864
 800d97c:	20000844 	.word	0x20000844
 800d980:	20000854 	.word	0x20000854
 800d984:	f3af 8000 	nop.w
 800d988:	f3af 8000 	nop.w
 800d98c:	f3af 8000 	nop.w

0800d990 <thread11>:

static THD_FUNCTION(thread11, p) {
 800d990:	b500      	push	{lr}
 800d992:	b083      	sub	sp, #12
 800d994:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800d996:	480c      	ldr	r0, [pc, #48]	; (800d9c8 <thread11+0x38>)
 800d998:	f7f4 faba 	bl	8001f10 <chMtxLock>
  chMtxLock(&m1);
 800d99c:	480b      	ldr	r0, [pc, #44]	; (800d9cc <thread11+0x3c>)
 800d99e:	f7f4 fab7 	bl	8001f10 <chMtxLock>
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
 800d9a2:	480b      	ldr	r0, [pc, #44]	; (800d9d0 <thread11+0x40>)
 800d9a4:	f04f 31ff 	mov.w	r1, #4294967295
 800d9a8:	f7f4 fd82 	bl	80024b0 <chCondWaitTimeout>
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800d9ac:	9b01      	ldr	r3, [sp, #4]
 800d9ae:	781b      	ldrb	r3, [r3, #0]
 800d9b0:	4618      	mov	r0, r3
 800d9b2:	f7fe fa1d 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m1);
 800d9b6:	4805      	ldr	r0, [pc, #20]	; (800d9cc <thread11+0x3c>)
 800d9b8:	f7f4 fb52 	bl	8002060 <chMtxUnlock>
  chMtxUnlock(&m2);
 800d9bc:	4802      	ldr	r0, [pc, #8]	; (800d9c8 <thread11+0x38>)
 800d9be:	f7f4 fb4f 	bl	8002060 <chMtxUnlock>
}
 800d9c2:	b003      	add	sp, #12
 800d9c4:	f85d fb04 	ldr.w	pc, [sp], #4
 800d9c8:	20000854 	.word	0x20000854
 800d9cc:	20000844 	.word	0x20000844
 800d9d0:	20000864 	.word	0x20000864
 800d9d4:	f3af 8000 	nop.w
 800d9d8:	f3af 8000 	nop.w
 800d9dc:	f3af 8000 	nop.w

0800d9e0 <thread12>:

static THD_FUNCTION(thread12, p) {
 800d9e0:	b500      	push	{lr}
 800d9e2:	b083      	sub	sp, #12
 800d9e4:	9001      	str	r0, [sp, #4]

  chMtxLock(&m2);
 800d9e6:	4807      	ldr	r0, [pc, #28]	; (800da04 <thread12+0x24>)
 800d9e8:	f7f4 fa92 	bl	8001f10 <chMtxLock>
  test_emit_token(*(char *)p);
 800d9ec:	9b01      	ldr	r3, [sp, #4]
 800d9ee:	781b      	ldrb	r3, [r3, #0]
 800d9f0:	4618      	mov	r0, r3
 800d9f2:	f7fe f9fd 	bl	800bdf0 <test_emit_token>
  chMtxUnlock(&m2);
 800d9f6:	4803      	ldr	r0, [pc, #12]	; (800da04 <thread12+0x24>)
 800d9f8:	f7f4 fb32 	bl	8002060 <chMtxUnlock>
}
 800d9fc:	b003      	add	sp, #12
 800d9fe:	f85d fb04 	ldr.w	pc, [sp], #4
 800da02:	bf00      	nop
 800da04:	20000854 	.word	0x20000854
 800da08:	f3af 8000 	nop.w
 800da0c:	f3af 8000 	nop.w

0800da10 <mtx8_execute>:

static void mtx8_execute(void) {
 800da10:	b500      	push	{lr}
 800da12:	b085      	sub	sp, #20

  tprio_t prio = chThdGetPriorityX();
 800da14:	f7ff fb54 	bl	800d0c0 <chThdGetPriorityX>
 800da18:	9003      	str	r0, [sp, #12]
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread11, "A");
 800da1a:	4b21      	ldr	r3, [pc, #132]	; (800daa0 <mtx8_execute+0x90>)
 800da1c:	681a      	ldr	r2, [r3, #0]
 800da1e:	9b03      	ldr	r3, [sp, #12]
 800da20:	3301      	adds	r3, #1
 800da22:	4920      	ldr	r1, [pc, #128]	; (800daa4 <mtx8_execute+0x94>)
 800da24:	9100      	str	r1, [sp, #0]
 800da26:	4610      	mov	r0, r2
 800da28:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da2c:	461a      	mov	r2, r3
 800da2e:	4b1e      	ldr	r3, [pc, #120]	; (800daa8 <mtx8_execute+0x98>)
 800da30:	f7f3 fbd6 	bl	80011e0 <chThdCreateStatic>
 800da34:	4602      	mov	r2, r0
 800da36:	4b1d      	ldr	r3, [pc, #116]	; (800daac <mtx8_execute+0x9c>)
 800da38:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread10, "C");
 800da3a:	4b19      	ldr	r3, [pc, #100]	; (800daa0 <mtx8_execute+0x90>)
 800da3c:	685a      	ldr	r2, [r3, #4]
 800da3e:	9b03      	ldr	r3, [sp, #12]
 800da40:	3302      	adds	r3, #2
 800da42:	491b      	ldr	r1, [pc, #108]	; (800dab0 <mtx8_execute+0xa0>)
 800da44:	9100      	str	r1, [sp, #0]
 800da46:	4610      	mov	r0, r2
 800da48:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da4c:	461a      	mov	r2, r3
 800da4e:	4b19      	ldr	r3, [pc, #100]	; (800dab4 <mtx8_execute+0xa4>)
 800da50:	f7f3 fbc6 	bl	80011e0 <chThdCreateStatic>
 800da54:	4602      	mov	r2, r0
 800da56:	4b15      	ldr	r3, [pc, #84]	; (800daac <mtx8_execute+0x9c>)
 800da58:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread12, "B");
 800da5a:	4b11      	ldr	r3, [pc, #68]	; (800daa0 <mtx8_execute+0x90>)
 800da5c:	689a      	ldr	r2, [r3, #8]
 800da5e:	9b03      	ldr	r3, [sp, #12]
 800da60:	3303      	adds	r3, #3
 800da62:	4915      	ldr	r1, [pc, #84]	; (800dab8 <mtx8_execute+0xa8>)
 800da64:	9100      	str	r1, [sp, #0]
 800da66:	4610      	mov	r0, r2
 800da68:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800da6c:	461a      	mov	r2, r3
 800da6e:	4b13      	ldr	r3, [pc, #76]	; (800dabc <mtx8_execute+0xac>)
 800da70:	f7f3 fbb6 	bl	80011e0 <chThdCreateStatic>
 800da74:	4602      	mov	r2, r0
 800da76:	4b0d      	ldr	r3, [pc, #52]	; (800daac <mtx8_execute+0x9c>)
 800da78:	609a      	str	r2, [r3, #8]
  chCondSignal(&c1);
 800da7a:	4811      	ldr	r0, [pc, #68]	; (800dac0 <mtx8_execute+0xb0>)
 800da7c:	f7f4 fc78 	bl	8002370 <chCondSignal>
  chCondSignal(&c1);
 800da80:	480f      	ldr	r0, [pc, #60]	; (800dac0 <mtx8_execute+0xb0>)
 800da82:	f7f4 fc75 	bl	8002370 <chCondSignal>
  test_wait_threads();
 800da86:	f7fe fa63 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(1, "ABC");
 800da8a:	2001      	movs	r0, #1
 800da8c:	490d      	ldr	r1, [pc, #52]	; (800dac4 <mtx8_execute+0xb4>)
 800da8e:	f7fe f9f7 	bl	800be80 <_test_assert_sequence>
 800da92:	4603      	mov	r3, r0
 800da94:	2b00      	cmp	r3, #0
 800da96:	d000      	beq.n	800da9a <mtx8_execute+0x8a>
 800da98:	bf00      	nop
}
 800da9a:	b005      	add	sp, #20
 800da9c:	f85d fb04 	ldr.w	pc, [sp], #4
 800daa0:	08019750 	.word	0x08019750
 800daa4:	08019b30 	.word	0x08019b30
 800daa8:	0800d991 	.word	0x0800d991
 800daac:	2000205c 	.word	0x2000205c
 800dab0:	08019b28 	.word	0x08019b28
 800dab4:	0800d6f1 	.word	0x0800d6f1
 800dab8:	08019b2c 	.word	0x08019b2c
 800dabc:	0800d9e1 	.word	0x0800d9e1
 800dac0:	20000864 	.word	0x20000864
 800dac4:	08019c0c 	.word	0x08019c0c
 800dac8:	f3af 8000 	nop.w
 800dacc:	f3af 8000 	nop.w

0800dad0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800dad0:	4b01      	ldr	r3, [pc, #4]	; (800dad8 <chThdGetSelfX+0x8>)
 800dad2:	699b      	ldr	r3, [r3, #24]
}
 800dad4:	4618      	mov	r0, r3
 800dad6:	4770      	bx	lr
 800dad8:	20001bc8 	.word	0x20001bc8
 800dadc:	f3af 8000 	nop.w

0800dae0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800dae0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800dae2:	f7ff fff5 	bl	800dad0 <chThdGetSelfX>
 800dae6:	4603      	mov	r3, r0
 800dae8:	689b      	ldr	r3, [r3, #8]
}
 800daea:	4618      	mov	r0, r3
 800daec:	bd08      	pop	{r3, pc}
 800daee:	bf00      	nop

0800daf0 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 800daf0:	b082      	sub	sp, #8
 800daf2:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 800daf4:	9b01      	ldr	r3, [sp, #4]
 800daf6:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 800daf8:	4618      	mov	r0, r3
 800dafa:	b002      	add	sp, #8
 800dafc:	4770      	bx	lr
 800dafe:	bf00      	nop

0800db00 <thread>:
 * A thread is spawned that sends four messages back to the tester thread.<br>
 * The test expect to receive the messages in the correct sequence and to
 * not find a fifth message waiting.
 */

static THD_FUNCTION(thread, p) {
 800db00:	b500      	push	{lr}
 800db02:	b083      	sub	sp, #12
 800db04:	9001      	str	r0, [sp, #4]

  chMsgSend(p, 'A');
 800db06:	9801      	ldr	r0, [sp, #4]
 800db08:	2141      	movs	r1, #65	; 0x41
 800db0a:	f7f5 f849 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'B');
 800db0e:	9801      	ldr	r0, [sp, #4]
 800db10:	2142      	movs	r1, #66	; 0x42
 800db12:	f7f5 f845 	bl	8002ba0 <chMsgSend>
  chMsgSend(p, 'C');
 800db16:	9801      	ldr	r0, [sp, #4]
 800db18:	2143      	movs	r1, #67	; 0x43
 800db1a:	f7f5 f841 	bl	8002ba0 <chMsgSend>
}
 800db1e:	b003      	add	sp, #12
 800db20:	f85d fb04 	ldr.w	pc, [sp], #4
 800db24:	f3af 8000 	nop.w
 800db28:	f3af 8000 	nop.w
 800db2c:	f3af 8000 	nop.w

0800db30 <msg1_execute>:

static void msg1_execute(void) {
 800db30:	b530      	push	{r4, r5, lr}
 800db32:	b085      	sub	sp, #20
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800db34:	4b26      	ldr	r3, [pc, #152]	; (800dbd0 <msg1_execute+0xa0>)
 800db36:	681d      	ldr	r5, [r3, #0]
 800db38:	f7ff ffd2 	bl	800dae0 <chThdGetPriorityX>
 800db3c:	4603      	mov	r3, r0
 800db3e:	1c5c      	adds	r4, r3, #1
                                 thread, chThdGetSelfX());
 800db40:	f7ff ffc6 	bl	800dad0 <chThdGetSelfX>
 800db44:	4603      	mov	r3, r0
  msg_t msg;

  /*
   * Testing the whole messages loop.
   */
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 800db46:	9300      	str	r3, [sp, #0]
 800db48:	4628      	mov	r0, r5
 800db4a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800db4e:	4622      	mov	r2, r4
 800db50:	4b20      	ldr	r3, [pc, #128]	; (800dbd4 <msg1_execute+0xa4>)
 800db52:	f7f3 fb45 	bl	80011e0 <chThdCreateStatic>
 800db56:	4602      	mov	r2, r0
 800db58:	4b1f      	ldr	r3, [pc, #124]	; (800dbd8 <msg1_execute+0xa8>)
 800db5a:	601a      	str	r2, [r3, #0]
                                 thread, chThdGetSelfX());
  tp = chMsgWait();
 800db5c:	f7f5 f850 	bl	8002c00 <chMsgWait>
 800db60:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800db62:	9803      	ldr	r0, [sp, #12]
 800db64:	f7ff ffc4 	bl	800daf0 <chMsgGet>
 800db68:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800db6a:	9803      	ldr	r0, [sp, #12]
 800db6c:	9902      	ldr	r1, [sp, #8]
 800db6e:	f7f5 f86f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800db72:	9b02      	ldr	r3, [sp, #8]
 800db74:	b2db      	uxtb	r3, r3
 800db76:	4618      	mov	r0, r3
 800db78:	f7fe f93a 	bl	800bdf0 <test_emit_token>
  tp = chMsgWait();
 800db7c:	f7f5 f840 	bl	8002c00 <chMsgWait>
 800db80:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800db82:	9803      	ldr	r0, [sp, #12]
 800db84:	f7ff ffb4 	bl	800daf0 <chMsgGet>
 800db88:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800db8a:	9803      	ldr	r0, [sp, #12]
 800db8c:	9902      	ldr	r1, [sp, #8]
 800db8e:	f7f5 f85f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800db92:	9b02      	ldr	r3, [sp, #8]
 800db94:	b2db      	uxtb	r3, r3
 800db96:	4618      	mov	r0, r3
 800db98:	f7fe f92a 	bl	800bdf0 <test_emit_token>
  tp = chMsgWait();
 800db9c:	f7f5 f830 	bl	8002c00 <chMsgWait>
 800dba0:	9003      	str	r0, [sp, #12]
  msg = chMsgGet(tp);
 800dba2:	9803      	ldr	r0, [sp, #12]
 800dba4:	f7ff ffa4 	bl	800daf0 <chMsgGet>
 800dba8:	9002      	str	r0, [sp, #8]
  chMsgRelease(tp, msg);
 800dbaa:	9803      	ldr	r0, [sp, #12]
 800dbac:	9902      	ldr	r1, [sp, #8]
 800dbae:	f7f5 f84f 	bl	8002c50 <chMsgRelease>
  test_emit_token(msg);
 800dbb2:	9b02      	ldr	r3, [sp, #8]
 800dbb4:	b2db      	uxtb	r3, r3
 800dbb6:	4618      	mov	r0, r3
 800dbb8:	f7fe f91a 	bl	800bdf0 <test_emit_token>
  test_assert_sequence(1, "ABC");
 800dbbc:	2001      	movs	r0, #1
 800dbbe:	4907      	ldr	r1, [pc, #28]	; (800dbdc <msg1_execute+0xac>)
 800dbc0:	f7fe f95e 	bl	800be80 <_test_assert_sequence>
 800dbc4:	4603      	mov	r3, r0
 800dbc6:	2b00      	cmp	r3, #0
 800dbc8:	d000      	beq.n	800dbcc <msg1_execute+0x9c>
 800dbca:	bf00      	nop
}
 800dbcc:	b005      	add	sp, #20
 800dbce:	bd30      	pop	{r4, r5, pc}
 800dbd0:	08019750 	.word	0x08019750
 800dbd4:	0800db01 	.word	0x0800db01
 800dbd8:	2000205c 	.word	0x2000205c
 800dbdc:	08019c50 	.word	0x08019c50

0800dbe0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800dbe0:	b082      	sub	sp, #8
 800dbe2:	2320      	movs	r3, #32
 800dbe4:	9301      	str	r3, [sp, #4]
 800dbe6:	9b01      	ldr	r3, [sp, #4]
 800dbe8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dbec:	b002      	add	sp, #8
 800dbee:	4770      	bx	lr

0800dbf0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800dbf0:	b082      	sub	sp, #8
 800dbf2:	2300      	movs	r3, #0
 800dbf4:	9301      	str	r3, [sp, #4]
 800dbf6:	9b01      	ldr	r3, [sp, #4]
 800dbf8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800dbfc:	b002      	add	sp, #8
 800dbfe:	4770      	bx	lr

0800dc00 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800dc00:	b508      	push	{r3, lr}

  port_lock();
 800dc02:	f7ff ffed 	bl	800dbe0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800dc06:	bd08      	pop	{r3, pc}
 800dc08:	f3af 8000 	nop.w
 800dc0c:	f3af 8000 	nop.w

0800dc10 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800dc10:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800dc12:	f7ff ffed 	bl	800dbf0 <port_unlock>
}
 800dc16:	bd08      	pop	{r3, pc}
 800dc18:	f3af 8000 	nop.w
 800dc1c:	f3af 8000 	nop.w

0800dc20 <chSemGetCounterI>:
 * @param[in] sp        pointer to a @p semaphore_t structure
 * @return              The semaphore counter value.
 *
 * @iclass
 */
static inline cnt_t chSemGetCounterI(semaphore_t *sp) {
 800dc20:	b082      	sub	sp, #8
 800dc22:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return sp->s_cnt;
 800dc24:	9b01      	ldr	r3, [sp, #4]
 800dc26:	689b      	ldr	r3, [r3, #8]
}
 800dc28:	4618      	mov	r0, r3
 800dc2a:	b002      	add	sp, #8
 800dc2c:	4770      	bx	lr
 800dc2e:	bf00      	nop

0800dc30 <chMBGetFreeCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of empty message slots.
 *
 * @iclass
 */
static inline cnt_t chMBGetFreeCountI(mailbox_t *mbp) {
 800dc30:	b500      	push	{lr}
 800dc32:	b083      	sub	sp, #12
 800dc34:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_emptysem);
 800dc36:	9b01      	ldr	r3, [sp, #4]
 800dc38:	331c      	adds	r3, #28
 800dc3a:	4618      	mov	r0, r3
 800dc3c:	f7ff fff0 	bl	800dc20 <chSemGetCounterI>
 800dc40:	4603      	mov	r3, r0
}
 800dc42:	4618      	mov	r0, r3
 800dc44:	b003      	add	sp, #12
 800dc46:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc4a:	bf00      	nop
 800dc4c:	f3af 8000 	nop.w

0800dc50 <chMBGetUsedCountI>:
 * @param[in] mbp       the pointer to an initialized mailbox_t object
 * @return              The number of queued messages.
 *
 * @iclass
 */
static inline cnt_t chMBGetUsedCountI(mailbox_t *mbp) {
 800dc50:	b500      	push	{lr}
 800dc52:	b083      	sub	sp, #12
 800dc54:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return chSemGetCounterI(&mbp->mb_fullsem);
 800dc56:	9b01      	ldr	r3, [sp, #4]
 800dc58:	3310      	adds	r3, #16
 800dc5a:	4618      	mov	r0, r3
 800dc5c:	f7ff ffe0 	bl	800dc20 <chSemGetCounterI>
 800dc60:	4603      	mov	r3, r0
}
 800dc62:	4618      	mov	r0, r3
 800dc64:	b003      	add	sp, #12
 800dc66:	f85d fb04 	ldr.w	pc, [sp], #4
 800dc6a:	bf00      	nop
 800dc6c:	f3af 8000 	nop.w

0800dc70 <mbox1_setup>:
 * Messages are posted/fetched from a mailbox in carefully designed sequences
 * in order to stimulate all the possible code paths inside the mailbox.<br>
 * The test expects to find a consistent mailbox status after each operation.
 */

static void mbox1_setup(void) {
 800dc70:	b508      	push	{r3, lr}

  chMBObjectInit(&mb1, (msg_t *)test.wa.T0, MB_SIZE);
 800dc72:	4803      	ldr	r0, [pc, #12]	; (800dc80 <mbox1_setup+0x10>)
 800dc74:	4903      	ldr	r1, [pc, #12]	; (800dc84 <mbox1_setup+0x14>)
 800dc76:	2205      	movs	r2, #5
 800dc78:	f7f5 f832 	bl	8002ce0 <chMBObjectInit>
}
 800dc7c:	bd08      	pop	{r3, pc}
 800dc7e:	bf00      	nop
 800dc80:	2000086c 	.word	0x2000086c
 800dc84:	20002070 	.word	0x20002070
 800dc88:	f3af 8000 	nop.w
 800dc8c:	f3af 8000 	nop.w

0800dc90 <mbox1_execute>:

static void mbox1_execute(void) {
 800dc90:	b500      	push	{lr}
 800dc92:	b085      	sub	sp, #20
  unsigned i;

  /*
   * Testing initial space.
   */
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 800dc94:	f7ff ffb4 	bl	800dc00 <chSysLock>
 800dc98:	48a9      	ldr	r0, [pc, #676]	; (800df40 <mbox1_execute+0x2b0>)
 800dc9a:	f7ff ffc9 	bl	800dc30 <chMBGetFreeCountI>
 800dc9e:	4603      	mov	r3, r0
 800dca0:	2b05      	cmp	r3, #5
 800dca2:	bf14      	ite	ne
 800dca4:	2300      	movne	r3, #0
 800dca6:	2301      	moveq	r3, #1
 800dca8:	b2db      	uxtb	r3, r3
 800dcaa:	2001      	movs	r0, #1
 800dcac:	4619      	mov	r1, r3
 800dcae:	f7fe f8cf 	bl	800be50 <_test_assert>
 800dcb2:	4603      	mov	r3, r0
 800dcb4:	2b00      	cmp	r3, #0
 800dcb6:	d002      	beq.n	800dcbe <mbox1_execute+0x2e>
 800dcb8:	f7ff ffaa 	bl	800dc10 <chSysUnlock>
 800dcbc:	e3ef      	b.n	800e49e <mbox1_execute+0x80e>
 800dcbe:	f7ff ffa7 	bl	800dc10 <chSysUnlock>

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dcc2:	2300      	movs	r3, #0
 800dcc4:	9303      	str	r3, [sp, #12]
 800dcc6:	e019      	b.n	800dcfc <mbox1_execute+0x6c>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800dcc8:	9b03      	ldr	r3, [sp, #12]
 800dcca:	3342      	adds	r3, #66	; 0x42
 800dccc:	489c      	ldr	r0, [pc, #624]	; (800df40 <mbox1_execute+0x2b0>)
 800dcce:	4619      	mov	r1, r3
 800dcd0:	f04f 32ff 	mov.w	r2, #4294967295
 800dcd4:	f7f5 f864 	bl	8002da0 <chMBPost>
 800dcd8:	9002      	str	r0, [sp, #8]
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
 800dcda:	9b02      	ldr	r3, [sp, #8]
 800dcdc:	2b00      	cmp	r3, #0
 800dcde:	bf14      	ite	ne
 800dce0:	2300      	movne	r3, #0
 800dce2:	2301      	moveq	r3, #1
 800dce4:	b2db      	uxtb	r3, r3
 800dce6:	2002      	movs	r0, #2
 800dce8:	4619      	mov	r1, r3
 800dcea:	f7fe f8b1 	bl	800be50 <_test_assert>
 800dcee:	4603      	mov	r3, r0
 800dcf0:	2b00      	cmp	r3, #0
 800dcf2:	d000      	beq.n	800dcf6 <mbox1_execute+0x66>
 800dcf4:	e3d3      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert_lock(1, chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");

  /*
   * Testing enqueuing and backward circularity.
   */
  for (i = 0; i < MB_SIZE - 1; i++) {
 800dcf6:	9b03      	ldr	r3, [sp, #12]
 800dcf8:	3301      	adds	r3, #1
 800dcfa:	9303      	str	r3, [sp, #12]
 800dcfc:	9b03      	ldr	r3, [sp, #12]
 800dcfe:	2b03      	cmp	r3, #3
 800dd00:	d9e2      	bls.n	800dcc8 <mbox1_execute+0x38>
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(2, msg1 == MSG_OK, "wrong wake-up message");
  }
  msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 800dd02:	488f      	ldr	r0, [pc, #572]	; (800df40 <mbox1_execute+0x2b0>)
 800dd04:	2141      	movs	r1, #65	; 0x41
 800dd06:	f04f 32ff 	mov.w	r2, #4294967295
 800dd0a:	f7f5 f8c1 	bl	8002e90 <chMBPostAhead>
 800dd0e:	9002      	str	r0, [sp, #8]
  test_assert(3, msg1 == MSG_OK, "wrong wake-up message");
 800dd10:	9b02      	ldr	r3, [sp, #8]
 800dd12:	2b00      	cmp	r3, #0
 800dd14:	bf14      	ite	ne
 800dd16:	2300      	movne	r3, #0
 800dd18:	2301      	moveq	r3, #1
 800dd1a:	b2db      	uxtb	r3, r3
 800dd1c:	2003      	movs	r0, #3
 800dd1e:	4619      	mov	r1, r3
 800dd20:	f7fe f896 	bl	800be50 <_test_assert>
 800dd24:	4603      	mov	r3, r0
 800dd26:	2b00      	cmp	r3, #0
 800dd28:	d000      	beq.n	800dd2c <mbox1_execute+0x9c>
 800dd2a:	e3b8      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing post timeout.
   */
  msg1 = chMBPost(&mb1, 'X', 1);
 800dd2c:	4884      	ldr	r0, [pc, #528]	; (800df40 <mbox1_execute+0x2b0>)
 800dd2e:	2158      	movs	r1, #88	; 0x58
 800dd30:	2201      	movs	r2, #1
 800dd32:	f7f5 f835 	bl	8002da0 <chMBPost>
 800dd36:	9002      	str	r0, [sp, #8]
  test_assert(4, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dd38:	9b02      	ldr	r3, [sp, #8]
 800dd3a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd3e:	bf14      	ite	ne
 800dd40:	2300      	movne	r3, #0
 800dd42:	2301      	moveq	r3, #1
 800dd44:	b2db      	uxtb	r3, r3
 800dd46:	2004      	movs	r0, #4
 800dd48:	4619      	mov	r1, r3
 800dd4a:	f7fe f881 	bl	800be50 <_test_assert>
 800dd4e:	4603      	mov	r3, r0
 800dd50:	2b00      	cmp	r3, #0
 800dd52:	d000      	beq.n	800dd56 <mbox1_execute+0xc6>
 800dd54:	e3a3      	b.n	800e49e <mbox1_execute+0x80e>
  chSysLock();
 800dd56:	f7ff ff53 	bl	800dc00 <chSysLock>
  msg1 = chMBPostI(&mb1, 'X');
 800dd5a:	4879      	ldr	r0, [pc, #484]	; (800df40 <mbox1_execute+0x2b0>)
 800dd5c:	2158      	movs	r1, #88	; 0x58
 800dd5e:	f7f5 f867 	bl	8002e30 <chMBPostI>
 800dd62:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800dd64:	f7ff ff54 	bl	800dc10 <chSysUnlock>
  test_assert(5, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dd68:	9b02      	ldr	r3, [sp, #8]
 800dd6a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd6e:	bf14      	ite	ne
 800dd70:	2300      	movne	r3, #0
 800dd72:	2301      	moveq	r3, #1
 800dd74:	b2db      	uxtb	r3, r3
 800dd76:	2005      	movs	r0, #5
 800dd78:	4619      	mov	r1, r3
 800dd7a:	f7fe f869 	bl	800be50 <_test_assert>
 800dd7e:	4603      	mov	r3, r0
 800dd80:	2b00      	cmp	r3, #0
 800dd82:	d000      	beq.n	800dd86 <mbox1_execute+0xf6>
 800dd84:	e38b      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostAhead(&mb1, 'X', 1);
 800dd86:	486e      	ldr	r0, [pc, #440]	; (800df40 <mbox1_execute+0x2b0>)
 800dd88:	2158      	movs	r1, #88	; 0x58
 800dd8a:	2201      	movs	r2, #1
 800dd8c:	f7f5 f880 	bl	8002e90 <chMBPostAhead>
 800dd90:	9002      	str	r0, [sp, #8]
  test_assert(6, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dd92:	9b02      	ldr	r3, [sp, #8]
 800dd94:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dd98:	bf14      	ite	ne
 800dd9a:	2300      	movne	r3, #0
 800dd9c:	2301      	moveq	r3, #1
 800dd9e:	b2db      	uxtb	r3, r3
 800dda0:	2006      	movs	r0, #6
 800dda2:	4619      	mov	r1, r3
 800dda4:	f7fe f854 	bl	800be50 <_test_assert>
 800dda8:	4603      	mov	r3, r0
 800ddaa:	2b00      	cmp	r3, #0
 800ddac:	d000      	beq.n	800ddb0 <mbox1_execute+0x120>
 800ddae:	e376      	b.n	800e49e <mbox1_execute+0x80e>
  chSysLock();
 800ddb0:	f7ff ff26 	bl	800dc00 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'X');
 800ddb4:	4862      	ldr	r0, [pc, #392]	; (800df40 <mbox1_execute+0x2b0>)
 800ddb6:	2158      	movs	r1, #88	; 0x58
 800ddb8:	f7f5 f8b2 	bl	8002f20 <chMBPostAheadI>
 800ddbc:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800ddbe:	f7ff ff27 	bl	800dc10 <chSysUnlock>
  test_assert(7, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800ddc2:	9b02      	ldr	r3, [sp, #8]
 800ddc4:	f1b3 3fff 	cmp.w	r3, #4294967295
 800ddc8:	bf14      	ite	ne
 800ddca:	2300      	movne	r3, #0
 800ddcc:	2301      	moveq	r3, #1
 800ddce:	b2db      	uxtb	r3, r3
 800ddd0:	2007      	movs	r0, #7
 800ddd2:	4619      	mov	r1, r3
 800ddd4:	f7fe f83c 	bl	800be50 <_test_assert>
 800ddd8:	4603      	mov	r3, r0
 800ddda:	2b00      	cmp	r3, #0
 800dddc:	d000      	beq.n	800dde0 <mbox1_execute+0x150>
 800ddde:	e35e      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(8, chMBGetFreeCountI(&mb1) == 0, "still empty");
 800dde0:	f7ff ff0e 	bl	800dc00 <chSysLock>
 800dde4:	4856      	ldr	r0, [pc, #344]	; (800df40 <mbox1_execute+0x2b0>)
 800dde6:	f7ff ff23 	bl	800dc30 <chMBGetFreeCountI>
 800ddea:	4603      	mov	r3, r0
 800ddec:	2b00      	cmp	r3, #0
 800ddee:	bf14      	ite	ne
 800ddf0:	2300      	movne	r3, #0
 800ddf2:	2301      	moveq	r3, #1
 800ddf4:	b2db      	uxtb	r3, r3
 800ddf6:	2008      	movs	r0, #8
 800ddf8:	4619      	mov	r1, r3
 800ddfa:	f7fe f829 	bl	800be50 <_test_assert>
 800ddfe:	4603      	mov	r3, r0
 800de00:	2b00      	cmp	r3, #0
 800de02:	d002      	beq.n	800de0a <mbox1_execute+0x17a>
 800de04:	f7ff ff04 	bl	800dc10 <chSysUnlock>
 800de08:	e349      	b.n	800e49e <mbox1_execute+0x80e>
 800de0a:	f7ff ff01 	bl	800dc10 <chSysUnlock>
  test_assert_lock(9, chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800de0e:	f7ff fef7 	bl	800dc00 <chSysLock>
 800de12:	484b      	ldr	r0, [pc, #300]	; (800df40 <mbox1_execute+0x2b0>)
 800de14:	f7ff ff1c 	bl	800dc50 <chMBGetUsedCountI>
 800de18:	4603      	mov	r3, r0
 800de1a:	2b05      	cmp	r3, #5
 800de1c:	bf14      	ite	ne
 800de1e:	2300      	movne	r3, #0
 800de20:	2301      	moveq	r3, #1
 800de22:	b2db      	uxtb	r3, r3
 800de24:	2009      	movs	r0, #9
 800de26:	4619      	mov	r1, r3
 800de28:	f7fe f812 	bl	800be50 <_test_assert>
 800de2c:	4603      	mov	r3, r0
 800de2e:	2b00      	cmp	r3, #0
 800de30:	d002      	beq.n	800de38 <mbox1_execute+0x1a8>
 800de32:	f7ff feed 	bl	800dc10 <chSysUnlock>
 800de36:	e332      	b.n	800e49e <mbox1_execute+0x80e>
 800de38:	f7ff feea 	bl	800dc10 <chSysUnlock>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800de3c:	f7ff fee0 	bl	800dc00 <chSysLock>
 800de40:	4b3f      	ldr	r3, [pc, #252]	; (800df40 <mbox1_execute+0x2b0>)
 800de42:	68da      	ldr	r2, [r3, #12]
 800de44:	4b3e      	ldr	r3, [pc, #248]	; (800df40 <mbox1_execute+0x2b0>)
 800de46:	689b      	ldr	r3, [r3, #8]
 800de48:	429a      	cmp	r2, r3
 800de4a:	bf14      	ite	ne
 800de4c:	2300      	movne	r3, #0
 800de4e:	2301      	moveq	r3, #1
 800de50:	b2db      	uxtb	r3, r3
 800de52:	200a      	movs	r0, #10
 800de54:	4619      	mov	r1, r3
 800de56:	f7fd fffb 	bl	800be50 <_test_assert>
 800de5a:	4603      	mov	r3, r0
 800de5c:	2b00      	cmp	r3, #0
 800de5e:	d002      	beq.n	800de66 <mbox1_execute+0x1d6>
 800de60:	f7ff fed6 	bl	800dc10 <chSysUnlock>
 800de64:	e31b      	b.n	800e49e <mbox1_execute+0x80e>
 800de66:	f7ff fed3 	bl	800dc10 <chSysUnlock>

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800de6a:	2300      	movs	r3, #0
 800de6c:	9303      	str	r3, [sp, #12]
 800de6e:	e01d      	b.n	800deac <mbox1_execute+0x21c>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800de70:	ab01      	add	r3, sp, #4
 800de72:	4833      	ldr	r0, [pc, #204]	; (800df40 <mbox1_execute+0x2b0>)
 800de74:	4619      	mov	r1, r3
 800de76:	f04f 32ff 	mov.w	r2, #4294967295
 800de7a:	f7f5 f889 	bl	8002f90 <chMBFetch>
 800de7e:	9002      	str	r0, [sp, #8]
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
 800de80:	9b02      	ldr	r3, [sp, #8]
 800de82:	2b00      	cmp	r3, #0
 800de84:	bf14      	ite	ne
 800de86:	2300      	movne	r3, #0
 800de88:	2301      	moveq	r3, #1
 800de8a:	b2db      	uxtb	r3, r3
 800de8c:	200b      	movs	r0, #11
 800de8e:	4619      	mov	r1, r3
 800de90:	f7fd ffde 	bl	800be50 <_test_assert>
 800de94:	4603      	mov	r3, r0
 800de96:	2b00      	cmp	r3, #0
 800de98:	d000      	beq.n	800de9c <mbox1_execute+0x20c>
 800de9a:	e300      	b.n	800e49e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800de9c:	9b01      	ldr	r3, [sp, #4]
 800de9e:	b2db      	uxtb	r3, r3
 800dea0:	4618      	mov	r0, r3
 800dea2:	f7fd ffa5 	bl	800bdf0 <test_emit_token>
  test_assert_lock(10, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");

  /*
   * Testing dequeuing.
   */
  for (i = 0; i < MB_SIZE; i++) {
 800dea6:	9b03      	ldr	r3, [sp, #12]
 800dea8:	3301      	adds	r3, #1
 800deaa:	9303      	str	r3, [sp, #12]
 800deac:	9b03      	ldr	r3, [sp, #12]
 800deae:	2b04      	cmp	r3, #4
 800deb0:	d9de      	bls.n	800de70 <mbox1_execute+0x1e0>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
    test_assert(11, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(12, "ABCDE");
 800deb2:	200c      	movs	r0, #12
 800deb4:	4923      	ldr	r1, [pc, #140]	; (800df44 <mbox1_execute+0x2b4>)
 800deb6:	f7fd ffe3 	bl	800be80 <_test_assert_sequence>
 800deba:	4603      	mov	r3, r0
 800debc:	2b00      	cmp	r3, #0
 800debe:	d000      	beq.n	800dec2 <mbox1_execute+0x232>
 800dec0:	e2ed      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing buffer circularity.
   */
  msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800dec2:	9b03      	ldr	r3, [sp, #12]
 800dec4:	3342      	adds	r3, #66	; 0x42
 800dec6:	481e      	ldr	r0, [pc, #120]	; (800df40 <mbox1_execute+0x2b0>)
 800dec8:	4619      	mov	r1, r3
 800deca:	f04f 32ff 	mov.w	r2, #4294967295
 800dece:	f7f4 ff67 	bl	8002da0 <chMBPost>
 800ded2:	9002      	str	r0, [sp, #8]
  test_assert(13, msg1 == MSG_OK, "wrong wake-up message");
 800ded4:	9b02      	ldr	r3, [sp, #8]
 800ded6:	2b00      	cmp	r3, #0
 800ded8:	bf14      	ite	ne
 800deda:	2300      	movne	r3, #0
 800dedc:	2301      	moveq	r3, #1
 800dede:	b2db      	uxtb	r3, r3
 800dee0:	200d      	movs	r0, #13
 800dee2:	4619      	mov	r1, r3
 800dee4:	f7fd ffb4 	bl	800be50 <_test_assert>
 800dee8:	4603      	mov	r3, r0
 800deea:	2b00      	cmp	r3, #0
 800deec:	d000      	beq.n	800def0 <mbox1_execute+0x260>
 800deee:	e2d6      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800def0:	ab01      	add	r3, sp, #4
 800def2:	4813      	ldr	r0, [pc, #76]	; (800df40 <mbox1_execute+0x2b0>)
 800def4:	4619      	mov	r1, r3
 800def6:	f04f 32ff 	mov.w	r2, #4294967295
 800defa:	f7f5 f849 	bl	8002f90 <chMBFetch>
 800defe:	9002      	str	r0, [sp, #8]
  test_assert(14, msg1 == MSG_OK, "wrong wake-up message");
 800df00:	9b02      	ldr	r3, [sp, #8]
 800df02:	2b00      	cmp	r3, #0
 800df04:	bf14      	ite	ne
 800df06:	2300      	movne	r3, #0
 800df08:	2301      	moveq	r3, #1
 800df0a:	b2db      	uxtb	r3, r3
 800df0c:	200e      	movs	r0, #14
 800df0e:	4619      	mov	r1, r3
 800df10:	f7fd ff9e 	bl	800be50 <_test_assert>
 800df14:	4603      	mov	r3, r0
 800df16:	2b00      	cmp	r3, #0
 800df18:	d000      	beq.n	800df1c <mbox1_execute+0x28c>
 800df1a:	e2c0      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert(15, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800df1c:	4b08      	ldr	r3, [pc, #32]	; (800df40 <mbox1_execute+0x2b0>)
 800df1e:	681a      	ldr	r2, [r3, #0]
 800df20:	4b07      	ldr	r3, [pc, #28]	; (800df40 <mbox1_execute+0x2b0>)
 800df22:	689b      	ldr	r3, [r3, #8]
 800df24:	429a      	cmp	r2, r3
 800df26:	bf14      	ite	ne
 800df28:	2300      	movne	r3, #0
 800df2a:	2301      	moveq	r3, #1
 800df2c:	b2db      	uxtb	r3, r3
 800df2e:	200f      	movs	r0, #15
 800df30:	4619      	mov	r1, r3
 800df32:	f7fd ff8d 	bl	800be50 <_test_assert>
 800df36:	4603      	mov	r3, r0
 800df38:	2b00      	cmp	r3, #0
 800df3a:	d005      	beq.n	800df48 <mbox1_execute+0x2b8>
 800df3c:	e2af      	b.n	800e49e <mbox1_execute+0x80e>
 800df3e:	bf00      	nop
 800df40:	2000086c 	.word	0x2000086c
 800df44:	08019c80 	.word	0x08019c80
  test_assert(16, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800df48:	4ba9      	ldr	r3, [pc, #676]	; (800e1f0 <mbox1_execute+0x560>)
 800df4a:	681a      	ldr	r2, [r3, #0]
 800df4c:	4ba8      	ldr	r3, [pc, #672]	; (800e1f0 <mbox1_execute+0x560>)
 800df4e:	68db      	ldr	r3, [r3, #12]
 800df50:	429a      	cmp	r2, r3
 800df52:	bf14      	ite	ne
 800df54:	2300      	movne	r3, #0
 800df56:	2301      	moveq	r3, #1
 800df58:	b2db      	uxtb	r3, r3
 800df5a:	2010      	movs	r0, #16
 800df5c:	4619      	mov	r1, r3
 800df5e:	f7fd ff77 	bl	800be50 <_test_assert>
 800df62:	4603      	mov	r3, r0
 800df64:	2b00      	cmp	r3, #0
 800df66:	d000      	beq.n	800df6a <mbox1_execute+0x2da>
 800df68:	e299      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing fetch timeout.
   */
  msg1 = chMBFetch(&mb1, &msg2, 1);
 800df6a:	ab01      	add	r3, sp, #4
 800df6c:	48a0      	ldr	r0, [pc, #640]	; (800e1f0 <mbox1_execute+0x560>)
 800df6e:	4619      	mov	r1, r3
 800df70:	2201      	movs	r2, #1
 800df72:	f7f5 f80d 	bl	8002f90 <chMBFetch>
 800df76:	9002      	str	r0, [sp, #8]
  test_assert(17, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800df78:	9b02      	ldr	r3, [sp, #8]
 800df7a:	f1b3 3fff 	cmp.w	r3, #4294967295
 800df7e:	bf14      	ite	ne
 800df80:	2300      	movne	r3, #0
 800df82:	2301      	moveq	r3, #1
 800df84:	b2db      	uxtb	r3, r3
 800df86:	2011      	movs	r0, #17
 800df88:	4619      	mov	r1, r3
 800df8a:	f7fd ff61 	bl	800be50 <_test_assert>
 800df8e:	4603      	mov	r3, r0
 800df90:	2b00      	cmp	r3, #0
 800df92:	d000      	beq.n	800df96 <mbox1_execute+0x306>
 800df94:	e283      	b.n	800e49e <mbox1_execute+0x80e>
  chSysLock();
 800df96:	f7ff fe33 	bl	800dc00 <chSysLock>
  msg1 = chMBFetchI(&mb1, &msg2);
 800df9a:	ab01      	add	r3, sp, #4
 800df9c:	4894      	ldr	r0, [pc, #592]	; (800e1f0 <mbox1_execute+0x560>)
 800df9e:	4619      	mov	r1, r3
 800dfa0:	f7f5 f83e 	bl	8003020 <chMBFetchI>
 800dfa4:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800dfa6:	f7ff fe33 	bl	800dc10 <chSysUnlock>
  test_assert(18, msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800dfaa:	9b02      	ldr	r3, [sp, #8]
 800dfac:	f1b3 3fff 	cmp.w	r3, #4294967295
 800dfb0:	bf14      	ite	ne
 800dfb2:	2300      	movne	r3, #0
 800dfb4:	2301      	moveq	r3, #1
 800dfb6:	b2db      	uxtb	r3, r3
 800dfb8:	2012      	movs	r0, #18
 800dfba:	4619      	mov	r1, r3
 800dfbc:	f7fd ff48 	bl	800be50 <_test_assert>
 800dfc0:	4603      	mov	r3, r0
 800dfc2:	2b00      	cmp	r3, #0
 800dfc4:	d000      	beq.n	800dfc8 <mbox1_execute+0x338>
 800dfc6:	e26a      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing final conditions.
   */
  test_assert_lock(19, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800dfc8:	f7ff fe1a 	bl	800dc00 <chSysLock>
 800dfcc:	4888      	ldr	r0, [pc, #544]	; (800e1f0 <mbox1_execute+0x560>)
 800dfce:	f7ff fe2f 	bl	800dc30 <chMBGetFreeCountI>
 800dfd2:	4603      	mov	r3, r0
 800dfd4:	2b05      	cmp	r3, #5
 800dfd6:	bf14      	ite	ne
 800dfd8:	2300      	movne	r3, #0
 800dfda:	2301      	moveq	r3, #1
 800dfdc:	b2db      	uxtb	r3, r3
 800dfde:	2013      	movs	r0, #19
 800dfe0:	4619      	mov	r1, r3
 800dfe2:	f7fd ff35 	bl	800be50 <_test_assert>
 800dfe6:	4603      	mov	r3, r0
 800dfe8:	2b00      	cmp	r3, #0
 800dfea:	d002      	beq.n	800dff2 <mbox1_execute+0x362>
 800dfec:	f7ff fe10 	bl	800dc10 <chSysUnlock>
 800dff0:	e255      	b.n	800e49e <mbox1_execute+0x80e>
 800dff2:	f7ff fe0d 	bl	800dc10 <chSysUnlock>
  test_assert_lock(20, chMBGetUsedCountI(&mb1) == 0, "still full");
 800dff6:	f7ff fe03 	bl	800dc00 <chSysLock>
 800dffa:	487d      	ldr	r0, [pc, #500]	; (800e1f0 <mbox1_execute+0x560>)
 800dffc:	f7ff fe28 	bl	800dc50 <chMBGetUsedCountI>
 800e000:	4603      	mov	r3, r0
 800e002:	2b00      	cmp	r3, #0
 800e004:	bf14      	ite	ne
 800e006:	2300      	movne	r3, #0
 800e008:	2301      	moveq	r3, #1
 800e00a:	b2db      	uxtb	r3, r3
 800e00c:	2014      	movs	r0, #20
 800e00e:	4619      	mov	r1, r3
 800e010:	f7fd ff1e 	bl	800be50 <_test_assert>
 800e014:	4603      	mov	r3, r0
 800e016:	2b00      	cmp	r3, #0
 800e018:	d002      	beq.n	800e020 <mbox1_execute+0x390>
 800e01a:	f7ff fdf9 	bl	800dc10 <chSysUnlock>
 800e01e:	e23e      	b.n	800e49e <mbox1_execute+0x80e>
 800e020:	f7ff fdf6 	bl	800dc10 <chSysUnlock>
  test_assert_lock(21, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e024:	f7ff fdec 	bl	800dc00 <chSysLock>
 800e028:	4b71      	ldr	r3, [pc, #452]	; (800e1f0 <mbox1_execute+0x560>)
 800e02a:	68da      	ldr	r2, [r3, #12]
 800e02c:	4b70      	ldr	r3, [pc, #448]	; (800e1f0 <mbox1_execute+0x560>)
 800e02e:	689b      	ldr	r3, [r3, #8]
 800e030:	429a      	cmp	r2, r3
 800e032:	bf14      	ite	ne
 800e034:	2300      	movne	r3, #0
 800e036:	2301      	moveq	r3, #1
 800e038:	b2db      	uxtb	r3, r3
 800e03a:	2015      	movs	r0, #21
 800e03c:	4619      	mov	r1, r3
 800e03e:	f7fd ff07 	bl	800be50 <_test_assert>
 800e042:	4603      	mov	r3, r0
 800e044:	2b00      	cmp	r3, #0
 800e046:	d002      	beq.n	800e04e <mbox1_execute+0x3be>
 800e048:	f7ff fde2 	bl	800dc10 <chSysUnlock>
 800e04c:	e227      	b.n	800e49e <mbox1_execute+0x80e>
 800e04e:	f7ff fddf 	bl	800dc10 <chSysUnlock>

  /*
   * Testing I-Class.
   */
  chSysLock();
 800e052:	f7ff fdd5 	bl	800dc00 <chSysLock>
  msg1 = chMBPostI(&mb1, 'A');
 800e056:	4866      	ldr	r0, [pc, #408]	; (800e1f0 <mbox1_execute+0x560>)
 800e058:	2141      	movs	r1, #65	; 0x41
 800e05a:	f7f4 fee9 	bl	8002e30 <chMBPostI>
 800e05e:	9002      	str	r0, [sp, #8]
  test_assert(22, msg1 == MSG_OK, "wrong wake-up message");
 800e060:	9b02      	ldr	r3, [sp, #8]
 800e062:	2b00      	cmp	r3, #0
 800e064:	bf14      	ite	ne
 800e066:	2300      	movne	r3, #0
 800e068:	2301      	moveq	r3, #1
 800e06a:	b2db      	uxtb	r3, r3
 800e06c:	2016      	movs	r0, #22
 800e06e:	4619      	mov	r1, r3
 800e070:	f7fd feee 	bl	800be50 <_test_assert>
 800e074:	4603      	mov	r3, r0
 800e076:	2b00      	cmp	r3, #0
 800e078:	d000      	beq.n	800e07c <mbox1_execute+0x3ec>
 800e07a:	e210      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'B');
 800e07c:	485c      	ldr	r0, [pc, #368]	; (800e1f0 <mbox1_execute+0x560>)
 800e07e:	2142      	movs	r1, #66	; 0x42
 800e080:	f7f4 fed6 	bl	8002e30 <chMBPostI>
 800e084:	9002      	str	r0, [sp, #8]
  test_assert(23, msg1 == MSG_OK, "wrong wake-up message");
 800e086:	9b02      	ldr	r3, [sp, #8]
 800e088:	2b00      	cmp	r3, #0
 800e08a:	bf14      	ite	ne
 800e08c:	2300      	movne	r3, #0
 800e08e:	2301      	moveq	r3, #1
 800e090:	b2db      	uxtb	r3, r3
 800e092:	2017      	movs	r0, #23
 800e094:	4619      	mov	r1, r3
 800e096:	f7fd fedb 	bl	800be50 <_test_assert>
 800e09a:	4603      	mov	r3, r0
 800e09c:	2b00      	cmp	r3, #0
 800e09e:	d000      	beq.n	800e0a2 <mbox1_execute+0x412>
 800e0a0:	e1fd      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'C');
 800e0a2:	4853      	ldr	r0, [pc, #332]	; (800e1f0 <mbox1_execute+0x560>)
 800e0a4:	2143      	movs	r1, #67	; 0x43
 800e0a6:	f7f4 fec3 	bl	8002e30 <chMBPostI>
 800e0aa:	9002      	str	r0, [sp, #8]
  test_assert(24, msg1 == MSG_OK, "wrong wake-up message");
 800e0ac:	9b02      	ldr	r3, [sp, #8]
 800e0ae:	2b00      	cmp	r3, #0
 800e0b0:	bf14      	ite	ne
 800e0b2:	2300      	movne	r3, #0
 800e0b4:	2301      	moveq	r3, #1
 800e0b6:	b2db      	uxtb	r3, r3
 800e0b8:	2018      	movs	r0, #24
 800e0ba:	4619      	mov	r1, r3
 800e0bc:	f7fd fec8 	bl	800be50 <_test_assert>
 800e0c0:	4603      	mov	r3, r0
 800e0c2:	2b00      	cmp	r3, #0
 800e0c4:	d000      	beq.n	800e0c8 <mbox1_execute+0x438>
 800e0c6:	e1ea      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'D');
 800e0c8:	4849      	ldr	r0, [pc, #292]	; (800e1f0 <mbox1_execute+0x560>)
 800e0ca:	2144      	movs	r1, #68	; 0x44
 800e0cc:	f7f4 feb0 	bl	8002e30 <chMBPostI>
 800e0d0:	9002      	str	r0, [sp, #8]
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
 800e0d2:	9b02      	ldr	r3, [sp, #8]
 800e0d4:	2b00      	cmp	r3, #0
 800e0d6:	bf14      	ite	ne
 800e0d8:	2300      	movne	r3, #0
 800e0da:	2301      	moveq	r3, #1
 800e0dc:	b2db      	uxtb	r3, r3
 800e0de:	2019      	movs	r0, #25
 800e0e0:	4619      	mov	r1, r3
 800e0e2:	f7fd feb5 	bl	800be50 <_test_assert>
 800e0e6:	4603      	mov	r3, r0
 800e0e8:	2b00      	cmp	r3, #0
 800e0ea:	d000      	beq.n	800e0ee <mbox1_execute+0x45e>
 800e0ec:	e1d7      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostI(&mb1, 'E');
 800e0ee:	4840      	ldr	r0, [pc, #256]	; (800e1f0 <mbox1_execute+0x560>)
 800e0f0:	2145      	movs	r1, #69	; 0x45
 800e0f2:	f7f4 fe9d 	bl	8002e30 <chMBPostI>
 800e0f6:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e0f8:	f7ff fd8a 	bl	800dc10 <chSysUnlock>
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
 800e0fc:	9b02      	ldr	r3, [sp, #8]
 800e0fe:	2b00      	cmp	r3, #0
 800e100:	bf14      	ite	ne
 800e102:	2300      	movne	r3, #0
 800e104:	2301      	moveq	r3, #1
 800e106:	b2db      	uxtb	r3, r3
 800e108:	201a      	movs	r0, #26
 800e10a:	4619      	mov	r1, r3
 800e10c:	f7fd fea0 	bl	800be50 <_test_assert>
 800e110:	4603      	mov	r3, r0
 800e112:	2b00      	cmp	r3, #0
 800e114:	d000      	beq.n	800e118 <mbox1_execute+0x488>
 800e116:	e1c2      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e118:	4b35      	ldr	r3, [pc, #212]	; (800e1f0 <mbox1_execute+0x560>)
 800e11a:	68da      	ldr	r2, [r3, #12]
 800e11c:	4b34      	ldr	r3, [pc, #208]	; (800e1f0 <mbox1_execute+0x560>)
 800e11e:	689b      	ldr	r3, [r3, #8]
 800e120:	429a      	cmp	r2, r3
 800e122:	bf14      	ite	ne
 800e124:	2300      	movne	r3, #0
 800e126:	2301      	moveq	r3, #1
 800e128:	b2db      	uxtb	r3, r3
 800e12a:	201b      	movs	r0, #27
 800e12c:	4619      	mov	r1, r3
 800e12e:	f7fd fe8f 	bl	800be50 <_test_assert>
 800e132:	4603      	mov	r3, r0
 800e134:	2b00      	cmp	r3, #0
 800e136:	d000      	beq.n	800e13a <mbox1_execute+0x4aa>
 800e138:	e1b1      	b.n	800e49e <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e13a:	2300      	movs	r3, #0
 800e13c:	9303      	str	r3, [sp, #12]
 800e13e:	e01f      	b.n	800e180 <mbox1_execute+0x4f0>
    chSysLock();
 800e140:	f7ff fd5e 	bl	800dc00 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e144:	ab01      	add	r3, sp, #4
 800e146:	482a      	ldr	r0, [pc, #168]	; (800e1f0 <mbox1_execute+0x560>)
 800e148:	4619      	mov	r1, r3
 800e14a:	f7f4 ff69 	bl	8003020 <chMBFetchI>
 800e14e:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e150:	f7ff fd5e 	bl	800dc10 <chSysUnlock>
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
 800e154:	9b02      	ldr	r3, [sp, #8]
 800e156:	2b00      	cmp	r3, #0
 800e158:	bf14      	ite	ne
 800e15a:	2300      	movne	r3, #0
 800e15c:	2301      	moveq	r3, #1
 800e15e:	b2db      	uxtb	r3, r3
 800e160:	201c      	movs	r0, #28
 800e162:	4619      	mov	r1, r3
 800e164:	f7fd fe74 	bl	800be50 <_test_assert>
 800e168:	4603      	mov	r3, r0
 800e16a:	2b00      	cmp	r3, #0
 800e16c:	d000      	beq.n	800e170 <mbox1_execute+0x4e0>
 800e16e:	e196      	b.n	800e49e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e170:	9b01      	ldr	r3, [sp, #4]
 800e172:	b2db      	uxtb	r3, r3
 800e174:	4618      	mov	r0, r3
 800e176:	f7fd fe3b 	bl	800bdf0 <test_emit_token>
  test_assert(25, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostI(&mb1, 'E');
  chSysUnlock();
  test_assert(26, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(27, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e17a:	9b03      	ldr	r3, [sp, #12]
 800e17c:	3301      	adds	r3, #1
 800e17e:	9303      	str	r3, [sp, #12]
 800e180:	9b03      	ldr	r3, [sp, #12]
 800e182:	2b04      	cmp	r3, #4
 800e184:	d9dc      	bls.n	800e140 <mbox1_execute+0x4b0>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(28, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(29, "ABCDE");
 800e186:	201d      	movs	r0, #29
 800e188:	491a      	ldr	r1, [pc, #104]	; (800e1f4 <mbox1_execute+0x564>)
 800e18a:	f7fd fe79 	bl	800be80 <_test_assert_sequence>
 800e18e:	4603      	mov	r3, r0
 800e190:	2b00      	cmp	r3, #0
 800e192:	d000      	beq.n	800e196 <mbox1_execute+0x506>
 800e194:	e183      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert_lock(30, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e196:	f7ff fd33 	bl	800dc00 <chSysLock>
 800e19a:	4815      	ldr	r0, [pc, #84]	; (800e1f0 <mbox1_execute+0x560>)
 800e19c:	f7ff fd48 	bl	800dc30 <chMBGetFreeCountI>
 800e1a0:	4603      	mov	r3, r0
 800e1a2:	2b05      	cmp	r3, #5
 800e1a4:	bf14      	ite	ne
 800e1a6:	2300      	movne	r3, #0
 800e1a8:	2301      	moveq	r3, #1
 800e1aa:	b2db      	uxtb	r3, r3
 800e1ac:	201e      	movs	r0, #30
 800e1ae:	4619      	mov	r1, r3
 800e1b0:	f7fd fe4e 	bl	800be50 <_test_assert>
 800e1b4:	4603      	mov	r3, r0
 800e1b6:	2b00      	cmp	r3, #0
 800e1b8:	d002      	beq.n	800e1c0 <mbox1_execute+0x530>
 800e1ba:	f7ff fd29 	bl	800dc10 <chSysUnlock>
 800e1be:	e16e      	b.n	800e49e <mbox1_execute+0x80e>
 800e1c0:	f7ff fd26 	bl	800dc10 <chSysUnlock>
  test_assert_lock(31, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e1c4:	f7ff fd1c 	bl	800dc00 <chSysLock>
 800e1c8:	4809      	ldr	r0, [pc, #36]	; (800e1f0 <mbox1_execute+0x560>)
 800e1ca:	f7ff fd41 	bl	800dc50 <chMBGetUsedCountI>
 800e1ce:	4603      	mov	r3, r0
 800e1d0:	2b00      	cmp	r3, #0
 800e1d2:	bf14      	ite	ne
 800e1d4:	2300      	movne	r3, #0
 800e1d6:	2301      	moveq	r3, #1
 800e1d8:	b2db      	uxtb	r3, r3
 800e1da:	201f      	movs	r0, #31
 800e1dc:	4619      	mov	r1, r3
 800e1de:	f7fd fe37 	bl	800be50 <_test_assert>
 800e1e2:	4603      	mov	r3, r0
 800e1e4:	2b00      	cmp	r3, #0
 800e1e6:	d007      	beq.n	800e1f8 <mbox1_execute+0x568>
 800e1e8:	f7ff fd12 	bl	800dc10 <chSysUnlock>
 800e1ec:	e157      	b.n	800e49e <mbox1_execute+0x80e>
 800e1ee:	bf00      	nop
 800e1f0:	2000086c 	.word	0x2000086c
 800e1f4:	08019c80 	.word	0x08019c80
 800e1f8:	f7ff fd0a 	bl	800dc10 <chSysUnlock>
  test_assert(32, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e1fc:	4ba9      	ldr	r3, [pc, #676]	; (800e4a4 <mbox1_execute+0x814>)
 800e1fe:	68da      	ldr	r2, [r3, #12]
 800e200:	4ba8      	ldr	r3, [pc, #672]	; (800e4a4 <mbox1_execute+0x814>)
 800e202:	689b      	ldr	r3, [r3, #8]
 800e204:	429a      	cmp	r2, r3
 800e206:	bf14      	ite	ne
 800e208:	2300      	movne	r3, #0
 800e20a:	2301      	moveq	r3, #1
 800e20c:	b2db      	uxtb	r3, r3
 800e20e:	2020      	movs	r0, #32
 800e210:	4619      	mov	r1, r3
 800e212:	f7fd fe1d 	bl	800be50 <_test_assert>
 800e216:	4603      	mov	r3, r0
 800e218:	2b00      	cmp	r3, #0
 800e21a:	d000      	beq.n	800e21e <mbox1_execute+0x58e>
 800e21c:	e13f      	b.n	800e49e <mbox1_execute+0x80e>

  chSysLock();
 800e21e:	f7ff fcef 	bl	800dc00 <chSysLock>
  msg1 = chMBPostAheadI(&mb1, 'E');
 800e222:	48a0      	ldr	r0, [pc, #640]	; (800e4a4 <mbox1_execute+0x814>)
 800e224:	2145      	movs	r1, #69	; 0x45
 800e226:	f7f4 fe7b 	bl	8002f20 <chMBPostAheadI>
 800e22a:	9002      	str	r0, [sp, #8]
  test_assert(33, msg1 == MSG_OK, "wrong wake-up message");
 800e22c:	9b02      	ldr	r3, [sp, #8]
 800e22e:	2b00      	cmp	r3, #0
 800e230:	bf14      	ite	ne
 800e232:	2300      	movne	r3, #0
 800e234:	2301      	moveq	r3, #1
 800e236:	b2db      	uxtb	r3, r3
 800e238:	2021      	movs	r0, #33	; 0x21
 800e23a:	4619      	mov	r1, r3
 800e23c:	f7fd fe08 	bl	800be50 <_test_assert>
 800e240:	4603      	mov	r3, r0
 800e242:	2b00      	cmp	r3, #0
 800e244:	d000      	beq.n	800e248 <mbox1_execute+0x5b8>
 800e246:	e12a      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'D');
 800e248:	4896      	ldr	r0, [pc, #600]	; (800e4a4 <mbox1_execute+0x814>)
 800e24a:	2144      	movs	r1, #68	; 0x44
 800e24c:	f7f4 fe68 	bl	8002f20 <chMBPostAheadI>
 800e250:	9002      	str	r0, [sp, #8]
  test_assert(34, msg1 == MSG_OK, "wrong wake-up message");
 800e252:	9b02      	ldr	r3, [sp, #8]
 800e254:	2b00      	cmp	r3, #0
 800e256:	bf14      	ite	ne
 800e258:	2300      	movne	r3, #0
 800e25a:	2301      	moveq	r3, #1
 800e25c:	b2db      	uxtb	r3, r3
 800e25e:	2022      	movs	r0, #34	; 0x22
 800e260:	4619      	mov	r1, r3
 800e262:	f7fd fdf5 	bl	800be50 <_test_assert>
 800e266:	4603      	mov	r3, r0
 800e268:	2b00      	cmp	r3, #0
 800e26a:	d000      	beq.n	800e26e <mbox1_execute+0x5de>
 800e26c:	e117      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'C');
 800e26e:	488d      	ldr	r0, [pc, #564]	; (800e4a4 <mbox1_execute+0x814>)
 800e270:	2143      	movs	r1, #67	; 0x43
 800e272:	f7f4 fe55 	bl	8002f20 <chMBPostAheadI>
 800e276:	9002      	str	r0, [sp, #8]
  test_assert(35, msg1 == MSG_OK, "wrong wake-up message");
 800e278:	9b02      	ldr	r3, [sp, #8]
 800e27a:	2b00      	cmp	r3, #0
 800e27c:	bf14      	ite	ne
 800e27e:	2300      	movne	r3, #0
 800e280:	2301      	moveq	r3, #1
 800e282:	b2db      	uxtb	r3, r3
 800e284:	2023      	movs	r0, #35	; 0x23
 800e286:	4619      	mov	r1, r3
 800e288:	f7fd fde2 	bl	800be50 <_test_assert>
 800e28c:	4603      	mov	r3, r0
 800e28e:	2b00      	cmp	r3, #0
 800e290:	d000      	beq.n	800e294 <mbox1_execute+0x604>
 800e292:	e104      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'B');
 800e294:	4883      	ldr	r0, [pc, #524]	; (800e4a4 <mbox1_execute+0x814>)
 800e296:	2142      	movs	r1, #66	; 0x42
 800e298:	f7f4 fe42 	bl	8002f20 <chMBPostAheadI>
 800e29c:	9002      	str	r0, [sp, #8]
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
 800e29e:	9b02      	ldr	r3, [sp, #8]
 800e2a0:	2b00      	cmp	r3, #0
 800e2a2:	bf14      	ite	ne
 800e2a4:	2300      	movne	r3, #0
 800e2a6:	2301      	moveq	r3, #1
 800e2a8:	b2db      	uxtb	r3, r3
 800e2aa:	2024      	movs	r0, #36	; 0x24
 800e2ac:	4619      	mov	r1, r3
 800e2ae:	f7fd fdcf 	bl	800be50 <_test_assert>
 800e2b2:	4603      	mov	r3, r0
 800e2b4:	2b00      	cmp	r3, #0
 800e2b6:	d000      	beq.n	800e2ba <mbox1_execute+0x62a>
 800e2b8:	e0f1      	b.n	800e49e <mbox1_execute+0x80e>
  msg1 = chMBPostAheadI(&mb1, 'A');
 800e2ba:	487a      	ldr	r0, [pc, #488]	; (800e4a4 <mbox1_execute+0x814>)
 800e2bc:	2141      	movs	r1, #65	; 0x41
 800e2be:	f7f4 fe2f 	bl	8002f20 <chMBPostAheadI>
 800e2c2:	9002      	str	r0, [sp, #8]
  chSysUnlock();
 800e2c4:	f7ff fca4 	bl	800dc10 <chSysUnlock>
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
 800e2c8:	9b02      	ldr	r3, [sp, #8]
 800e2ca:	2b00      	cmp	r3, #0
 800e2cc:	bf14      	ite	ne
 800e2ce:	2300      	movne	r3, #0
 800e2d0:	2301      	moveq	r3, #1
 800e2d2:	b2db      	uxtb	r3, r3
 800e2d4:	2025      	movs	r0, #37	; 0x25
 800e2d6:	4619      	mov	r1, r3
 800e2d8:	f7fd fdba 	bl	800be50 <_test_assert>
 800e2dc:	4603      	mov	r3, r0
 800e2de:	2b00      	cmp	r3, #0
 800e2e0:	d000      	beq.n	800e2e4 <mbox1_execute+0x654>
 800e2e2:	e0dc      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e2e4:	4b6f      	ldr	r3, [pc, #444]	; (800e4a4 <mbox1_execute+0x814>)
 800e2e6:	68da      	ldr	r2, [r3, #12]
 800e2e8:	4b6e      	ldr	r3, [pc, #440]	; (800e4a4 <mbox1_execute+0x814>)
 800e2ea:	689b      	ldr	r3, [r3, #8]
 800e2ec:	429a      	cmp	r2, r3
 800e2ee:	bf14      	ite	ne
 800e2f0:	2300      	movne	r3, #0
 800e2f2:	2301      	moveq	r3, #1
 800e2f4:	b2db      	uxtb	r3, r3
 800e2f6:	2026      	movs	r0, #38	; 0x26
 800e2f8:	4619      	mov	r1, r3
 800e2fa:	f7fd fda9 	bl	800be50 <_test_assert>
 800e2fe:	4603      	mov	r3, r0
 800e300:	2b00      	cmp	r3, #0
 800e302:	d000      	beq.n	800e306 <mbox1_execute+0x676>
 800e304:	e0cb      	b.n	800e49e <mbox1_execute+0x80e>
  for (i = 0; i < MB_SIZE; i++) {
 800e306:	2300      	movs	r3, #0
 800e308:	9303      	str	r3, [sp, #12]
 800e30a:	e01f      	b.n	800e34c <mbox1_execute+0x6bc>
    chSysLock();
 800e30c:	f7ff fc78 	bl	800dc00 <chSysLock>
    msg1 = chMBFetchI(&mb1, &msg2);
 800e310:	ab01      	add	r3, sp, #4
 800e312:	4864      	ldr	r0, [pc, #400]	; (800e4a4 <mbox1_execute+0x814>)
 800e314:	4619      	mov	r1, r3
 800e316:	f7f4 fe83 	bl	8003020 <chMBFetchI>
 800e31a:	9002      	str	r0, [sp, #8]
    chSysUnlock();
 800e31c:	f7ff fc78 	bl	800dc10 <chSysUnlock>
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
 800e320:	9b02      	ldr	r3, [sp, #8]
 800e322:	2b00      	cmp	r3, #0
 800e324:	bf14      	ite	ne
 800e326:	2300      	movne	r3, #0
 800e328:	2301      	moveq	r3, #1
 800e32a:	b2db      	uxtb	r3, r3
 800e32c:	2027      	movs	r0, #39	; 0x27
 800e32e:	4619      	mov	r1, r3
 800e330:	f7fd fd8e 	bl	800be50 <_test_assert>
 800e334:	4603      	mov	r3, r0
 800e336:	2b00      	cmp	r3, #0
 800e338:	d000      	beq.n	800e33c <mbox1_execute+0x6ac>
 800e33a:	e0b0      	b.n	800e49e <mbox1_execute+0x80e>
    test_emit_token(msg2);
 800e33c:	9b01      	ldr	r3, [sp, #4]
 800e33e:	b2db      	uxtb	r3, r3
 800e340:	4618      	mov	r0, r3
 800e342:	f7fd fd55 	bl	800bdf0 <test_emit_token>
  test_assert(36, msg1 == MSG_OK, "wrong wake-up message");
  msg1 = chMBPostAheadI(&mb1, 'A');
  chSysUnlock();
  test_assert(37, msg1 == MSG_OK, "wrong wake-up message");
  test_assert(38, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
  for (i = 0; i < MB_SIZE; i++) {
 800e346:	9b03      	ldr	r3, [sp, #12]
 800e348:	3301      	adds	r3, #1
 800e34a:	9303      	str	r3, [sp, #12]
 800e34c:	9b03      	ldr	r3, [sp, #12]
 800e34e:	2b04      	cmp	r3, #4
 800e350:	d9dc      	bls.n	800e30c <mbox1_execute+0x67c>
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(39, msg1 == MSG_OK, "wrong wake-up message");
    test_emit_token(msg2);
  }
  test_assert_sequence(40, "ABCDE");
 800e352:	2028      	movs	r0, #40	; 0x28
 800e354:	4954      	ldr	r1, [pc, #336]	; (800e4a8 <mbox1_execute+0x818>)
 800e356:	f7fd fd93 	bl	800be80 <_test_assert_sequence>
 800e35a:	4603      	mov	r3, r0
 800e35c:	2b00      	cmp	r3, #0
 800e35e:	d000      	beq.n	800e362 <mbox1_execute+0x6d2>
 800e360:	e09d      	b.n	800e49e <mbox1_execute+0x80e>
  test_assert_lock(41, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e362:	f7ff fc4d 	bl	800dc00 <chSysLock>
 800e366:	484f      	ldr	r0, [pc, #316]	; (800e4a4 <mbox1_execute+0x814>)
 800e368:	f7ff fc62 	bl	800dc30 <chMBGetFreeCountI>
 800e36c:	4603      	mov	r3, r0
 800e36e:	2b05      	cmp	r3, #5
 800e370:	bf14      	ite	ne
 800e372:	2300      	movne	r3, #0
 800e374:	2301      	moveq	r3, #1
 800e376:	b2db      	uxtb	r3, r3
 800e378:	2029      	movs	r0, #41	; 0x29
 800e37a:	4619      	mov	r1, r3
 800e37c:	f7fd fd68 	bl	800be50 <_test_assert>
 800e380:	4603      	mov	r3, r0
 800e382:	2b00      	cmp	r3, #0
 800e384:	d002      	beq.n	800e38c <mbox1_execute+0x6fc>
 800e386:	f7ff fc43 	bl	800dc10 <chSysUnlock>
 800e38a:	e088      	b.n	800e49e <mbox1_execute+0x80e>
 800e38c:	f7ff fc40 	bl	800dc10 <chSysUnlock>
  test_assert_lock(42, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e390:	f7ff fc36 	bl	800dc00 <chSysLock>
 800e394:	4843      	ldr	r0, [pc, #268]	; (800e4a4 <mbox1_execute+0x814>)
 800e396:	f7ff fc5b 	bl	800dc50 <chMBGetUsedCountI>
 800e39a:	4603      	mov	r3, r0
 800e39c:	2b00      	cmp	r3, #0
 800e39e:	bf14      	ite	ne
 800e3a0:	2300      	movne	r3, #0
 800e3a2:	2301      	moveq	r3, #1
 800e3a4:	b2db      	uxtb	r3, r3
 800e3a6:	202a      	movs	r0, #42	; 0x2a
 800e3a8:	4619      	mov	r1, r3
 800e3aa:	f7fd fd51 	bl	800be50 <_test_assert>
 800e3ae:	4603      	mov	r3, r0
 800e3b0:	2b00      	cmp	r3, #0
 800e3b2:	d002      	beq.n	800e3ba <mbox1_execute+0x72a>
 800e3b4:	f7ff fc2c 	bl	800dc10 <chSysUnlock>
 800e3b8:	e071      	b.n	800e49e <mbox1_execute+0x80e>
 800e3ba:	f7ff fc29 	bl	800dc10 <chSysUnlock>
  test_assert(43, mb1.mb_rdptr == mb1.mb_wrptr, "pointers not aligned");
 800e3be:	4b39      	ldr	r3, [pc, #228]	; (800e4a4 <mbox1_execute+0x814>)
 800e3c0:	68da      	ldr	r2, [r3, #12]
 800e3c2:	4b38      	ldr	r3, [pc, #224]	; (800e4a4 <mbox1_execute+0x814>)
 800e3c4:	689b      	ldr	r3, [r3, #8]
 800e3c6:	429a      	cmp	r2, r3
 800e3c8:	bf14      	ite	ne
 800e3ca:	2300      	movne	r3, #0
 800e3cc:	2301      	moveq	r3, #1
 800e3ce:	b2db      	uxtb	r3, r3
 800e3d0:	202b      	movs	r0, #43	; 0x2b
 800e3d2:	4619      	mov	r1, r3
 800e3d4:	f7fd fd3c 	bl	800be50 <_test_assert>
 800e3d8:	4603      	mov	r3, r0
 800e3da:	2b00      	cmp	r3, #0
 800e3dc:	d000      	beq.n	800e3e0 <mbox1_execute+0x750>
 800e3de:	e05e      	b.n	800e49e <mbox1_execute+0x80e>

  /*
   * Testing reset.
   */
  chMBReset(&mb1);
 800e3e0:	4830      	ldr	r0, [pc, #192]	; (800e4a4 <mbox1_execute+0x814>)
 800e3e2:	f7f4 fca5 	bl	8002d30 <chMBReset>

  /*
   * Re-testing final conditions.
   */
  test_assert_lock(44, chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 800e3e6:	f7ff fc0b 	bl	800dc00 <chSysLock>
 800e3ea:	482e      	ldr	r0, [pc, #184]	; (800e4a4 <mbox1_execute+0x814>)
 800e3ec:	f7ff fc20 	bl	800dc30 <chMBGetFreeCountI>
 800e3f0:	4603      	mov	r3, r0
 800e3f2:	2b05      	cmp	r3, #5
 800e3f4:	bf14      	ite	ne
 800e3f6:	2300      	movne	r3, #0
 800e3f8:	2301      	moveq	r3, #1
 800e3fa:	b2db      	uxtb	r3, r3
 800e3fc:	202c      	movs	r0, #44	; 0x2c
 800e3fe:	4619      	mov	r1, r3
 800e400:	f7fd fd26 	bl	800be50 <_test_assert>
 800e404:	4603      	mov	r3, r0
 800e406:	2b00      	cmp	r3, #0
 800e408:	d002      	beq.n	800e410 <mbox1_execute+0x780>
 800e40a:	f7ff fc01 	bl	800dc10 <chSysUnlock>
 800e40e:	e046      	b.n	800e49e <mbox1_execute+0x80e>
 800e410:	f7ff fbfe 	bl	800dc10 <chSysUnlock>
  test_assert_lock(45, chMBGetUsedCountI(&mb1) == 0, "still full");
 800e414:	f7ff fbf4 	bl	800dc00 <chSysLock>
 800e418:	4822      	ldr	r0, [pc, #136]	; (800e4a4 <mbox1_execute+0x814>)
 800e41a:	f7ff fc19 	bl	800dc50 <chMBGetUsedCountI>
 800e41e:	4603      	mov	r3, r0
 800e420:	2b00      	cmp	r3, #0
 800e422:	bf14      	ite	ne
 800e424:	2300      	movne	r3, #0
 800e426:	2301      	moveq	r3, #1
 800e428:	b2db      	uxtb	r3, r3
 800e42a:	202d      	movs	r0, #45	; 0x2d
 800e42c:	4619      	mov	r1, r3
 800e42e:	f7fd fd0f 	bl	800be50 <_test_assert>
 800e432:	4603      	mov	r3, r0
 800e434:	2b00      	cmp	r3, #0
 800e436:	d002      	beq.n	800e43e <mbox1_execute+0x7ae>
 800e438:	f7ff fbea 	bl	800dc10 <chSysUnlock>
 800e43c:	e02f      	b.n	800e49e <mbox1_execute+0x80e>
 800e43e:	f7ff fbe7 	bl	800dc10 <chSysUnlock>
  test_assert_lock(46, mb1.mb_buffer == mb1.mb_wrptr, "write pointer not aligned to base");
 800e442:	f7ff fbdd 	bl	800dc00 <chSysLock>
 800e446:	4b17      	ldr	r3, [pc, #92]	; (800e4a4 <mbox1_execute+0x814>)
 800e448:	681a      	ldr	r2, [r3, #0]
 800e44a:	4b16      	ldr	r3, [pc, #88]	; (800e4a4 <mbox1_execute+0x814>)
 800e44c:	689b      	ldr	r3, [r3, #8]
 800e44e:	429a      	cmp	r2, r3
 800e450:	bf14      	ite	ne
 800e452:	2300      	movne	r3, #0
 800e454:	2301      	moveq	r3, #1
 800e456:	b2db      	uxtb	r3, r3
 800e458:	202e      	movs	r0, #46	; 0x2e
 800e45a:	4619      	mov	r1, r3
 800e45c:	f7fd fcf8 	bl	800be50 <_test_assert>
 800e460:	4603      	mov	r3, r0
 800e462:	2b00      	cmp	r3, #0
 800e464:	d002      	beq.n	800e46c <mbox1_execute+0x7dc>
 800e466:	f7ff fbd3 	bl	800dc10 <chSysUnlock>
 800e46a:	e018      	b.n	800e49e <mbox1_execute+0x80e>
 800e46c:	f7ff fbd0 	bl	800dc10 <chSysUnlock>
  test_assert_lock(47, mb1.mb_buffer == mb1.mb_rdptr, "read pointer not aligned to base");
 800e470:	f7ff fbc6 	bl	800dc00 <chSysLock>
 800e474:	4b0b      	ldr	r3, [pc, #44]	; (800e4a4 <mbox1_execute+0x814>)
 800e476:	681a      	ldr	r2, [r3, #0]
 800e478:	4b0a      	ldr	r3, [pc, #40]	; (800e4a4 <mbox1_execute+0x814>)
 800e47a:	68db      	ldr	r3, [r3, #12]
 800e47c:	429a      	cmp	r2, r3
 800e47e:	bf14      	ite	ne
 800e480:	2300      	movne	r3, #0
 800e482:	2301      	moveq	r3, #1
 800e484:	b2db      	uxtb	r3, r3
 800e486:	202f      	movs	r0, #47	; 0x2f
 800e488:	4619      	mov	r1, r3
 800e48a:	f7fd fce1 	bl	800be50 <_test_assert>
 800e48e:	4603      	mov	r3, r0
 800e490:	2b00      	cmp	r3, #0
 800e492:	d002      	beq.n	800e49a <mbox1_execute+0x80a>
 800e494:	f7ff fbbc 	bl	800dc10 <chSysUnlock>
 800e498:	e001      	b.n	800e49e <mbox1_execute+0x80e>
 800e49a:	f7ff fbb9 	bl	800dc10 <chSysUnlock>
}
 800e49e:	b005      	add	sp, #20
 800e4a0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e4a4:	2000086c 	.word	0x2000086c
 800e4a8:	08019c80 	.word	0x08019c80
 800e4ac:	f3af 8000 	nop.w

0800e4b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800e4b0:	b082      	sub	sp, #8
 800e4b2:	2320      	movs	r3, #32
 800e4b4:	9301      	str	r3, [sp, #4]
 800e4b6:	9b01      	ldr	r3, [sp, #4]
 800e4b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e4bc:	b002      	add	sp, #8
 800e4be:	4770      	bx	lr

0800e4c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800e4c0:	b082      	sub	sp, #8
 800e4c2:	2300      	movs	r3, #0
 800e4c4:	9301      	str	r3, [sp, #4]
 800e4c6:	9b01      	ldr	r3, [sp, #4]
 800e4c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800e4cc:	b002      	add	sp, #8
 800e4ce:	4770      	bx	lr

0800e4d0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800e4d0:	b508      	push	{r3, lr}

  port_lock();
 800e4d2:	f7ff ffed 	bl	800e4b0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800e4d6:	bd08      	pop	{r3, pc}
 800e4d8:	f3af 8000 	nop.w
 800e4dc:	f3af 8000 	nop.w

0800e4e0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800e4e0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800e4e2:	f7ff ffed 	bl	800e4c0 <port_unlock>
}
 800e4e6:	bd08      	pop	{r3, pc}
 800e4e8:	f3af 8000 	nop.w
 800e4ec:	f3af 8000 	nop.w

0800e4f0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800e4f0:	4b01      	ldr	r3, [pc, #4]	; (800e4f8 <chVTGetSystemTimeX+0x8>)
 800e4f2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 800e4f4:	4618      	mov	r0, r3
 800e4f6:	4770      	bx	lr
 800e4f8:	20001bc8 	.word	0x20001bc8
 800e4fc:	f3af 8000 	nop.w

0800e500 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 800e500:	b500      	push	{lr}
 800e502:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 800e504:	f7ff ffe4 	bl	800e4d0 <chSysLock>
  systime = chVTGetSystemTimeX();
 800e508:	f7ff fff2 	bl	800e4f0 <chVTGetSystemTimeX>
 800e50c:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 800e50e:	f7ff ffe7 	bl	800e4e0 <chSysUnlock>

  return systime;
 800e512:	9b01      	ldr	r3, [sp, #4]
}
 800e514:	4618      	mov	r0, r3
 800e516:	b003      	add	sp, #12
 800e518:	f85d fb04 	ldr.w	pc, [sp], #4
 800e51c:	f3af 8000 	nop.w

0800e520 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800e520:	4b01      	ldr	r3, [pc, #4]	; (800e528 <chThdGetSelfX+0x8>)
 800e522:	699b      	ldr	r3, [r3, #24]
}
 800e524:	4618      	mov	r0, r3
 800e526:	4770      	bx	lr
 800e528:	20001bc8 	.word	0x20001bc8
 800e52c:	f3af 8000 	nop.w

0800e530 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800e530:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800e532:	f7ff fff5 	bl	800e520 <chThdGetSelfX>
 800e536:	4603      	mov	r3, r0
 800e538:	689b      	ldr	r3, [r3, #8]
}
 800e53a:	4618      	mov	r0, r3
 800e53c:	bd08      	pop	{r3, pc}
 800e53e:	bf00      	nop

0800e540 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 800e540:	b082      	sub	sp, #8
 800e542:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 800e544:	9b01      	ldr	r3, [sp, #4]
 800e546:	9a01      	ldr	r2, [sp, #4]
 800e548:	601a      	str	r2, [r3, #0]
}
 800e54a:	b002      	add	sp, #8
 800e54c:	4770      	bx	lr
 800e54e:	bf00      	nop

0800e550 <chEvtRegisterMask>:
 *
 * @api
 */
static inline void chEvtRegisterMask(event_source_t *esp,
                                     event_listener_t *elp,
                                     eventmask_t events) {
 800e550:	b500      	push	{lr}
 800e552:	b085      	sub	sp, #20
 800e554:	9003      	str	r0, [sp, #12]
 800e556:	9102      	str	r1, [sp, #8]
 800e558:	9201      	str	r2, [sp, #4]

  chEvtRegisterMaskWithFlags(esp, elp, events, (eventflags_t)-1);
 800e55a:	9803      	ldr	r0, [sp, #12]
 800e55c:	9902      	ldr	r1, [sp, #8]
 800e55e:	9a01      	ldr	r2, [sp, #4]
 800e560:	f04f 33ff 	mov.w	r3, #4294967295
 800e564:	f7f4 f804 	bl	8002570 <chEvtRegisterMaskWithFlags>
}
 800e568:	b005      	add	sp, #20
 800e56a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e56e:	bf00      	nop

0800e570 <chEvtIsListeningI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @return              The event source status.
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {
 800e570:	b082      	sub	sp, #8
 800e572:	9001      	str	r0, [sp, #4]

  return (bool)(esp != (event_source_t *)esp->es_next);
 800e574:	9b01      	ldr	r3, [sp, #4]
 800e576:	681a      	ldr	r2, [r3, #0]
 800e578:	9b01      	ldr	r3, [sp, #4]
 800e57a:	429a      	cmp	r2, r3
 800e57c:	bf0c      	ite	eq
 800e57e:	2300      	moveq	r3, #0
 800e580:	2301      	movne	r3, #1
 800e582:	b2db      	uxtb	r3, r3
}
 800e584:	4618      	mov	r0, r3
 800e586:	b002      	add	sp, #8
 800e588:	4770      	bx	lr
 800e58a:	bf00      	nop
 800e58c:	f3af 8000 	nop.w

0800e590 <chEvtBroadcast>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @api
 */
static inline void chEvtBroadcast(event_source_t *esp) {
 800e590:	b500      	push	{lr}
 800e592:	b083      	sub	sp, #12
 800e594:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlags(esp, (eventflags_t)0);
 800e596:	9801      	ldr	r0, [sp, #4]
 800e598:	2100      	movs	r1, #0
 800e59a:	f7f4 f901 	bl	80027a0 <chEvtBroadcastFlags>
}
 800e59e:	b003      	add	sp, #12
 800e5a0:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5a4:	f3af 8000 	nop.w
 800e5a8:	f3af 8000 	nop.w
 800e5ac:	f3af 8000 	nop.w

0800e5b0 <evt1_setup>:
 * the test expects no more listeners.<br>
 * In the second part the test dispatches three event flags and verifies that
 * the associated event handlers are invoked in LSb-first order.
 */

static void evt1_setup(void) {
 800e5b0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e5b2:	f04f 30ff 	mov.w	r0, #4294967295
 800e5b6:	f7f4 f823 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e5ba:	bd08      	pop	{r3, pc}
 800e5bc:	f3af 8000 	nop.w

0800e5c0 <h1>:

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 800e5c0:	b500      	push	{lr}
 800e5c2:	b083      	sub	sp, #12
 800e5c4:	9001      	str	r0, [sp, #4]
 800e5c6:	2041      	movs	r0, #65	; 0x41
 800e5c8:	f7fd fc12 	bl	800bdf0 <test_emit_token>
 800e5cc:	b003      	add	sp, #12
 800e5ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5d2:	bf00      	nop
 800e5d4:	f3af 8000 	nop.w
 800e5d8:	f3af 8000 	nop.w
 800e5dc:	f3af 8000 	nop.w

0800e5e0 <h2>:
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 800e5e0:	b500      	push	{lr}
 800e5e2:	b083      	sub	sp, #12
 800e5e4:	9001      	str	r0, [sp, #4]
 800e5e6:	2042      	movs	r0, #66	; 0x42
 800e5e8:	f7fd fc02 	bl	800bdf0 <test_emit_token>
 800e5ec:	b003      	add	sp, #12
 800e5ee:	f85d fb04 	ldr.w	pc, [sp], #4
 800e5f2:	bf00      	nop
 800e5f4:	f3af 8000 	nop.w
 800e5f8:	f3af 8000 	nop.w
 800e5fc:	f3af 8000 	nop.w

0800e600 <h3>:
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 800e600:	b500      	push	{lr}
 800e602:	b083      	sub	sp, #12
 800e604:	9001      	str	r0, [sp, #4]
 800e606:	2043      	movs	r0, #67	; 0x43
 800e608:	f7fd fbf2 	bl	800bdf0 <test_emit_token>
 800e60c:	b003      	add	sp, #12
 800e60e:	f85d fb04 	ldr.w	pc, [sp], #4
 800e612:	bf00      	nop
 800e614:	f3af 8000 	nop.w
 800e618:	f3af 8000 	nop.w
 800e61c:	f3af 8000 	nop.w

0800e620 <evt1_execute>:
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static void evt1_execute(void) {
 800e620:	b500      	push	{lr}
 800e622:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;

  /*
   * Testing chEvtRegisterMask() and chEvtUnregister().
   */
  chEvtObjectInit(&es1);
 800e624:	482b      	ldr	r0, [pc, #172]	; (800e6d4 <evt1_execute+0xb4>)
 800e626:	f7ff ff8b 	bl	800e540 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800e62a:	ab05      	add	r3, sp, #20
 800e62c:	4829      	ldr	r0, [pc, #164]	; (800e6d4 <evt1_execute+0xb4>)
 800e62e:	4619      	mov	r1, r3
 800e630:	2201      	movs	r2, #1
 800e632:	f7ff ff8d 	bl	800e550 <chEvtRegisterMask>
  chEvtRegisterMask(&es1, &el2, 2);
 800e636:	466b      	mov	r3, sp
 800e638:	4826      	ldr	r0, [pc, #152]	; (800e6d4 <evt1_execute+0xb4>)
 800e63a:	4619      	mov	r1, r3
 800e63c:	2202      	movs	r2, #2
 800e63e:	f7ff ff87 	bl	800e550 <chEvtRegisterMask>
  test_assert(1, chEvtIsListeningI(&es1), "no listener");
 800e642:	4824      	ldr	r0, [pc, #144]	; (800e6d4 <evt1_execute+0xb4>)
 800e644:	f7ff ff94 	bl	800e570 <chEvtIsListeningI>
 800e648:	4603      	mov	r3, r0
 800e64a:	2001      	movs	r0, #1
 800e64c:	4619      	mov	r1, r3
 800e64e:	f7fd fbff 	bl	800be50 <_test_assert>
 800e652:	4603      	mov	r3, r0
 800e654:	2b00      	cmp	r3, #0
 800e656:	d000      	beq.n	800e65a <evt1_execute+0x3a>
 800e658:	e038      	b.n	800e6cc <evt1_execute+0xac>
  chEvtUnregister(&es1, &el1);
 800e65a:	ab05      	add	r3, sp, #20
 800e65c:	481d      	ldr	r0, [pc, #116]	; (800e6d4 <evt1_execute+0xb4>)
 800e65e:	4619      	mov	r1, r3
 800e660:	f7f3 ffae 	bl	80025c0 <chEvtUnregister>
  test_assert(2, chEvtIsListeningI(&es1), "no listener");
 800e664:	481b      	ldr	r0, [pc, #108]	; (800e6d4 <evt1_execute+0xb4>)
 800e666:	f7ff ff83 	bl	800e570 <chEvtIsListeningI>
 800e66a:	4603      	mov	r3, r0
 800e66c:	2002      	movs	r0, #2
 800e66e:	4619      	mov	r1, r3
 800e670:	f7fd fbee 	bl	800be50 <_test_assert>
 800e674:	4603      	mov	r3, r0
 800e676:	2b00      	cmp	r3, #0
 800e678:	d000      	beq.n	800e67c <evt1_execute+0x5c>
 800e67a:	e027      	b.n	800e6cc <evt1_execute+0xac>
  chEvtUnregister(&es1, &el2);
 800e67c:	466b      	mov	r3, sp
 800e67e:	4815      	ldr	r0, [pc, #84]	; (800e6d4 <evt1_execute+0xb4>)
 800e680:	4619      	mov	r1, r3
 800e682:	f7f3 ff9d 	bl	80025c0 <chEvtUnregister>
  test_assert(3, !chEvtIsListeningI(&es1), "stuck listener");
 800e686:	4813      	ldr	r0, [pc, #76]	; (800e6d4 <evt1_execute+0xb4>)
 800e688:	f7ff ff72 	bl	800e570 <chEvtIsListeningI>
 800e68c:	4603      	mov	r3, r0
 800e68e:	2b00      	cmp	r3, #0
 800e690:	bf0c      	ite	eq
 800e692:	2300      	moveq	r3, #0
 800e694:	2301      	movne	r3, #1
 800e696:	b2db      	uxtb	r3, r3
 800e698:	f083 0301 	eor.w	r3, r3, #1
 800e69c:	b2db      	uxtb	r3, r3
 800e69e:	f003 0301 	and.w	r3, r3, #1
 800e6a2:	b2db      	uxtb	r3, r3
 800e6a4:	2003      	movs	r0, #3
 800e6a6:	4619      	mov	r1, r3
 800e6a8:	f7fd fbd2 	bl	800be50 <_test_assert>
 800e6ac:	4603      	mov	r3, r0
 800e6ae:	2b00      	cmp	r3, #0
 800e6b0:	d000      	beq.n	800e6b4 <evt1_execute+0x94>
 800e6b2:	e00b      	b.n	800e6cc <evt1_execute+0xac>

  /*
   * Testing chEvtDispatch().
   */
  chEvtDispatch(evhndl, 7);
 800e6b4:	4808      	ldr	r0, [pc, #32]	; (800e6d8 <evt1_execute+0xb8>)
 800e6b6:	2107      	movs	r1, #7
 800e6b8:	f7f4 f89a 	bl	80027f0 <chEvtDispatch>
  test_assert_sequence(4, "ABC");
 800e6bc:	2004      	movs	r0, #4
 800e6be:	4907      	ldr	r1, [pc, #28]	; (800e6dc <evt1_execute+0xbc>)
 800e6c0:	f7fd fbde 	bl	800be80 <_test_assert_sequence>
 800e6c4:	4603      	mov	r3, r0
 800e6c6:	2b00      	cmp	r3, #0
 800e6c8:	d000      	beq.n	800e6cc <evt1_execute+0xac>
 800e6ca:	bf00      	nop
}
 800e6cc:	b00b      	add	sp, #44	; 0x2c
 800e6ce:	f85d fb04 	ldr.w	pc, [sp], #4
 800e6d2:	bf00      	nop
 800e6d4:	20000894 	.word	0x20000894
 800e6d8:	08019cc0 	.word	0x08019cc0
 800e6dc:	08019ccc 	.word	0x08019ccc

0800e6e0 <evt2_setup>:
 * .
 * After each test phase the test verifies that the events have been served at
 * the expected time and that there are no stuck event flags.
 */

static void evt2_setup(void) {
 800e6e0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800e6e2:	f04f 30ff 	mov.w	r0, #4294967295
 800e6e6:	f7f3 ff8b 	bl	8002600 <chEvtGetAndClearEvents>
}
 800e6ea:	bd08      	pop	{r3, pc}
 800e6ec:	f3af 8000 	nop.w

0800e6f0 <thread1>:

static THD_FUNCTION(thread1, p) {
 800e6f0:	b500      	push	{lr}
 800e6f2:	b083      	sub	sp, #12
 800e6f4:	9001      	str	r0, [sp, #4]

  chThdSleepMilliseconds(50);
 800e6f6:	2032      	movs	r0, #50	; 0x32
 800e6f8:	f7f2 fdea 	bl	80012d0 <chThdSleep>
  chEvtSignal((thread_t *)p, 1);
 800e6fc:	9801      	ldr	r0, [sp, #4]
 800e6fe:	2101      	movs	r1, #1
 800e700:	f7f4 f806 	bl	8002710 <chEvtSignal>
}
 800e704:	b003      	add	sp, #12
 800e706:	f85d fb04 	ldr.w	pc, [sp], #4
 800e70a:	bf00      	nop
 800e70c:	f3af 8000 	nop.w

0800e710 <thread2>:

static THD_FUNCTION(thread2, p) {
 800e710:	b500      	push	{lr}
 800e712:	b083      	sub	sp, #12
 800e714:	9001      	str	r0, [sp, #4]

  (void)p;
  chEvtBroadcast(&es1);
 800e716:	4806      	ldr	r0, [pc, #24]	; (800e730 <thread2+0x20>)
 800e718:	f7ff ff3a 	bl	800e590 <chEvtBroadcast>
  chThdSleepMilliseconds(50);
 800e71c:	2032      	movs	r0, #50	; 0x32
 800e71e:	f7f2 fdd7 	bl	80012d0 <chThdSleep>
  chEvtBroadcast(&es2);
 800e722:	4804      	ldr	r0, [pc, #16]	; (800e734 <thread2+0x24>)
 800e724:	f7ff ff34 	bl	800e590 <chEvtBroadcast>
}
 800e728:	b003      	add	sp, #12
 800e72a:	f85d fb04 	ldr.w	pc, [sp], #4
 800e72e:	bf00      	nop
 800e730:	20000894 	.word	0x20000894
 800e734:	20000898 	.word	0x20000898
 800e738:	f3af 8000 	nop.w
 800e73c:	f3af 8000 	nop.w

0800e740 <evt2_execute>:

static void evt2_execute(void) {
 800e740:	b530      	push	{r4, r5, lr}
 800e742:	b08f      	sub	sp, #60	; 0x3c
  systime_t target_time;

  /*
   * Test on chEvtWaitOne() without wait.
   */
  chEvtAddEvents(7);
 800e744:	2007      	movs	r0, #7
 800e746:	f7f3 ff7b 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitOne(ALL_EVENTS);
 800e74a:	f04f 30ff 	mov.w	r0, #4294967295
 800e74e:	f7f4 f877 	bl	8002840 <chEvtWaitOne>
 800e752:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(1, m == 1, "single event error");
 800e754:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e756:	2b01      	cmp	r3, #1
 800e758:	bf14      	ite	ne
 800e75a:	2300      	movne	r3, #0
 800e75c:	2301      	moveq	r3, #1
 800e75e:	b2db      	uxtb	r3, r3
 800e760:	2001      	movs	r0, #1
 800e762:	4619      	mov	r1, r3
 800e764:	f7fd fb74 	bl	800be50 <_test_assert>
 800e768:	4603      	mov	r3, r0
 800e76a:	2b00      	cmp	r3, #0
 800e76c:	d000      	beq.n	800e770 <evt2_execute+0x30>
 800e76e:	e184      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800e770:	f04f 30ff 	mov.w	r0, #4294967295
 800e774:	f7f4 f864 	bl	8002840 <chEvtWaitOne>
 800e778:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(2, m == 2, "single event error");
 800e77a:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e77c:	2b02      	cmp	r3, #2
 800e77e:	bf14      	ite	ne
 800e780:	2300      	movne	r3, #0
 800e782:	2301      	moveq	r3, #1
 800e784:	b2db      	uxtb	r3, r3
 800e786:	2002      	movs	r0, #2
 800e788:	4619      	mov	r1, r3
 800e78a:	f7fd fb61 	bl	800be50 <_test_assert>
 800e78e:	4603      	mov	r3, r0
 800e790:	2b00      	cmp	r3, #0
 800e792:	d000      	beq.n	800e796 <evt2_execute+0x56>
 800e794:	e171      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtWaitOne(ALL_EVENTS);
 800e796:	f04f 30ff 	mov.w	r0, #4294967295
 800e79a:	f7f4 f851 	bl	8002840 <chEvtWaitOne>
 800e79e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(3, m == 4, "single event error");
 800e7a0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e7a2:	2b04      	cmp	r3, #4
 800e7a4:	bf14      	ite	ne
 800e7a6:	2300      	movne	r3, #0
 800e7a8:	2301      	moveq	r3, #1
 800e7aa:	b2db      	uxtb	r3, r3
 800e7ac:	2003      	movs	r0, #3
 800e7ae:	4619      	mov	r1, r3
 800e7b0:	f7fd fb4e 	bl	800be50 <_test_assert>
 800e7b4:	4603      	mov	r3, r0
 800e7b6:	2b00      	cmp	r3, #0
 800e7b8:	d000      	beq.n	800e7bc <evt2_execute+0x7c>
 800e7ba:	e15e      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e7bc:	f04f 30ff 	mov.w	r0, #4294967295
 800e7c0:	f7f3 ff1e 	bl	8002600 <chEvtGetAndClearEvents>
 800e7c4:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(4, m == 0, "stuck event");
 800e7c6:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e7c8:	2b00      	cmp	r3, #0
 800e7ca:	bf14      	ite	ne
 800e7cc:	2300      	movne	r3, #0
 800e7ce:	2301      	moveq	r3, #1
 800e7d0:	b2db      	uxtb	r3, r3
 800e7d2:	2004      	movs	r0, #4
 800e7d4:	4619      	mov	r1, r3
 800e7d6:	f7fd fb3b 	bl	800be50 <_test_assert>
 800e7da:	4603      	mov	r3, r0
 800e7dc:	2b00      	cmp	r3, #0
 800e7de:	d000      	beq.n	800e7e2 <evt2_execute+0xa2>
 800e7e0:	e14b      	b.n	800ea7a <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
 800e7e2:	f7fd fbdd 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e7e6:	f7ff fe8b 	bl	800e500 <chVTGetSystemTime>
 800e7ea:	4603      	mov	r3, r0
 800e7ec:	3332      	adds	r3, #50	; 0x32
 800e7ee:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e7f0:	4ba3      	ldr	r3, [pc, #652]	; (800ea80 <evt2_execute+0x340>)
 800e7f2:	681d      	ldr	r5, [r3, #0]
 800e7f4:	f7ff fe9c 	bl	800e530 <chThdGetPriorityX>
 800e7f8:	4603      	mov	r3, r0
 800e7fa:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e7fc:	f7ff fe90 	bl	800e520 <chThdGetSelfX>
 800e800:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitOne() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e802:	9300      	str	r3, [sp, #0]
 800e804:	4628      	mov	r0, r5
 800e806:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e80a:	4622      	mov	r2, r4
 800e80c:	4b9d      	ldr	r3, [pc, #628]	; (800ea84 <evt2_execute+0x344>)
 800e80e:	f7f2 fce7 	bl	80011e0 <chThdCreateStatic>
 800e812:	4602      	mov	r2, r0
 800e814:	4b9c      	ldr	r3, [pc, #624]	; (800ea88 <evt2_execute+0x348>)
 800e816:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitOne(ALL_EVENTS);
 800e818:	f04f 30ff 	mov.w	r0, #4294967295
 800e81c:	f7f4 f810 	bl	8002840 <chEvtWaitOne>
 800e820:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(5, target_time, target_time + ALLOWED_DELAY);
 800e822:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e824:	3305      	adds	r3, #5
 800e826:	2005      	movs	r0, #5
 800e828:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e82a:	461a      	mov	r2, r3
 800e82c:	f7fd fb58 	bl	800bee0 <_test_assert_time_window>
 800e830:	4603      	mov	r3, r0
 800e832:	2b00      	cmp	r3, #0
 800e834:	d000      	beq.n	800e838 <evt2_execute+0xf8>
 800e836:	e120      	b.n	800ea7a <evt2_execute+0x33a>
  test_assert(6, m == 1, "single event error");
 800e838:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e83a:	2b01      	cmp	r3, #1
 800e83c:	bf14      	ite	ne
 800e83e:	2300      	movne	r3, #0
 800e840:	2301      	moveq	r3, #1
 800e842:	b2db      	uxtb	r3, r3
 800e844:	2006      	movs	r0, #6
 800e846:	4619      	mov	r1, r3
 800e848:	f7fd fb02 	bl	800be50 <_test_assert>
 800e84c:	4603      	mov	r3, r0
 800e84e:	2b00      	cmp	r3, #0
 800e850:	d000      	beq.n	800e854 <evt2_execute+0x114>
 800e852:	e112      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e854:	f04f 30ff 	mov.w	r0, #4294967295
 800e858:	f7f3 fed2 	bl	8002600 <chEvtGetAndClearEvents>
 800e85c:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(7, m == 0, "stuck event");
 800e85e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e860:	2b00      	cmp	r3, #0
 800e862:	bf14      	ite	ne
 800e864:	2300      	movne	r3, #0
 800e866:	2301      	moveq	r3, #1
 800e868:	b2db      	uxtb	r3, r3
 800e86a:	2007      	movs	r0, #7
 800e86c:	4619      	mov	r1, r3
 800e86e:	f7fd faef 	bl	800be50 <_test_assert>
 800e872:	4603      	mov	r3, r0
 800e874:	2b00      	cmp	r3, #0
 800e876:	d000      	beq.n	800e87a <evt2_execute+0x13a>
 800e878:	e0ff      	b.n	800ea7a <evt2_execute+0x33a>
  test_wait_threads();
 800e87a:	f7fd fb69 	bl	800bf50 <test_wait_threads>

  /*
   * Test on chEvtWaitAny() without wait.
   */
  chEvtAddEvents(5);
 800e87e:	2005      	movs	r0, #5
 800e880:	f7f3 fede 	bl	8002640 <chEvtAddEvents>
  m = chEvtWaitAny(ALL_EVENTS);
 800e884:	f04f 30ff 	mov.w	r0, #4294967295
 800e888:	f7f4 f80a 	bl	80028a0 <chEvtWaitAny>
 800e88c:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(8, m == 5, "unexpected pending bit");
 800e88e:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e890:	2b05      	cmp	r3, #5
 800e892:	bf14      	ite	ne
 800e894:	2300      	movne	r3, #0
 800e896:	2301      	moveq	r3, #1
 800e898:	b2db      	uxtb	r3, r3
 800e89a:	2008      	movs	r0, #8
 800e89c:	4619      	mov	r1, r3
 800e89e:	f7fd fad7 	bl	800be50 <_test_assert>
 800e8a2:	4603      	mov	r3, r0
 800e8a4:	2b00      	cmp	r3, #0
 800e8a6:	d000      	beq.n	800e8aa <evt2_execute+0x16a>
 800e8a8:	e0e7      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e8aa:	f04f 30ff 	mov.w	r0, #4294967295
 800e8ae:	f7f3 fea7 	bl	8002600 <chEvtGetAndClearEvents>
 800e8b2:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(9, m == 0, "stuck event");
 800e8b4:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e8b6:	2b00      	cmp	r3, #0
 800e8b8:	bf14      	ite	ne
 800e8ba:	2300      	movne	r3, #0
 800e8bc:	2301      	moveq	r3, #1
 800e8be:	b2db      	uxtb	r3, r3
 800e8c0:	2009      	movs	r0, #9
 800e8c2:	4619      	mov	r1, r3
 800e8c4:	f7fd fac4 	bl	800be50 <_test_assert>
 800e8c8:	4603      	mov	r3, r0
 800e8ca:	2b00      	cmp	r3, #0
 800e8cc:	d000      	beq.n	800e8d0 <evt2_execute+0x190>
 800e8ce:	e0d4      	b.n	800ea7a <evt2_execute+0x33a>

  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
 800e8d0:	f7fd fb66 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e8d4:	f7ff fe14 	bl	800e500 <chVTGetSystemTime>
 800e8d8:	4603      	mov	r3, r0
 800e8da:	3332      	adds	r3, #50	; 0x32
 800e8dc:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e8de:	4b68      	ldr	r3, [pc, #416]	; (800ea80 <evt2_execute+0x340>)
 800e8e0:	681d      	ldr	r5, [r3, #0]
 800e8e2:	f7ff fe25 	bl	800e530 <chThdGetPriorityX>
 800e8e6:	4603      	mov	r3, r0
 800e8e8:	1e5c      	subs	r4, r3, #1
                                 thread1, chThdGetSelfX());
 800e8ea:	f7ff fe19 	bl	800e520 <chThdGetSelfX>
 800e8ee:	4603      	mov	r3, r0
  /*
   * Test on chEvtWaitAny() with wait.
   */
  test_wait_tick();
  target_time = chVTGetSystemTime() + MS2ST(50);
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e8f0:	9300      	str	r3, [sp, #0]
 800e8f2:	4628      	mov	r0, r5
 800e8f4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e8f8:	4622      	mov	r2, r4
 800e8fa:	4b62      	ldr	r3, [pc, #392]	; (800ea84 <evt2_execute+0x344>)
 800e8fc:	f7f2 fc70 	bl	80011e0 <chThdCreateStatic>
 800e900:	4602      	mov	r2, r0
 800e902:	4b61      	ldr	r3, [pc, #388]	; (800ea88 <evt2_execute+0x348>)
 800e904:	601a      	str	r2, [r3, #0]
                                 thread1, chThdGetSelfX());
  m = chEvtWaitAny(ALL_EVENTS);
 800e906:	f04f 30ff 	mov.w	r0, #4294967295
 800e90a:	f7f3 ffc9 	bl	80028a0 <chEvtWaitAny>
 800e90e:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(10, target_time, target_time + ALLOWED_DELAY);
 800e910:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e912:	3305      	adds	r3, #5
 800e914:	200a      	movs	r0, #10
 800e916:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e918:	461a      	mov	r2, r3
 800e91a:	f7fd fae1 	bl	800bee0 <_test_assert_time_window>
 800e91e:	4603      	mov	r3, r0
 800e920:	2b00      	cmp	r3, #0
 800e922:	d000      	beq.n	800e926 <evt2_execute+0x1e6>
 800e924:	e0a9      	b.n	800ea7a <evt2_execute+0x33a>
  test_assert(11, m == 1, "single event error");
 800e926:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e928:	2b01      	cmp	r3, #1
 800e92a:	bf14      	ite	ne
 800e92c:	2300      	movne	r3, #0
 800e92e:	2301      	moveq	r3, #1
 800e930:	b2db      	uxtb	r3, r3
 800e932:	200b      	movs	r0, #11
 800e934:	4619      	mov	r1, r3
 800e936:	f7fd fa8b 	bl	800be50 <_test_assert>
 800e93a:	4603      	mov	r3, r0
 800e93c:	2b00      	cmp	r3, #0
 800e93e:	d000      	beq.n	800e942 <evt2_execute+0x202>
 800e940:	e09b      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e942:	f04f 30ff 	mov.w	r0, #4294967295
 800e946:	f7f3 fe5b 	bl	8002600 <chEvtGetAndClearEvents>
 800e94a:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(12, m == 0, "stuck event");
 800e94c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e94e:	2b00      	cmp	r3, #0
 800e950:	bf14      	ite	ne
 800e952:	2300      	movne	r3, #0
 800e954:	2301      	moveq	r3, #1
 800e956:	b2db      	uxtb	r3, r3
 800e958:	200c      	movs	r0, #12
 800e95a:	4619      	mov	r1, r3
 800e95c:	f7fd fa78 	bl	800be50 <_test_assert>
 800e960:	4603      	mov	r3, r0
 800e962:	2b00      	cmp	r3, #0
 800e964:	d000      	beq.n	800e968 <evt2_execute+0x228>
 800e966:	e088      	b.n	800ea7a <evt2_execute+0x33a>
  test_wait_threads();
 800e968:	f7fd faf2 	bl	800bf50 <test_wait_threads>

  /*
   * Test on chEvtWaitAll().
   */
  chEvtObjectInit(&es1);
 800e96c:	4847      	ldr	r0, [pc, #284]	; (800ea8c <evt2_execute+0x34c>)
 800e96e:	f7ff fde7 	bl	800e540 <chEvtObjectInit>
  chEvtObjectInit(&es2);
 800e972:	4847      	ldr	r0, [pc, #284]	; (800ea90 <evt2_execute+0x350>)
 800e974:	f7ff fde4 	bl	800e540 <chEvtObjectInit>
  chEvtRegisterMask(&es1, &el1, 1);
 800e978:	ab07      	add	r3, sp, #28
 800e97a:	4844      	ldr	r0, [pc, #272]	; (800ea8c <evt2_execute+0x34c>)
 800e97c:	4619      	mov	r1, r3
 800e97e:	2201      	movs	r2, #1
 800e980:	f7ff fde6 	bl	800e550 <chEvtRegisterMask>
  chEvtRegisterMask(&es2, &el2, 4);
 800e984:	ab02      	add	r3, sp, #8
 800e986:	4842      	ldr	r0, [pc, #264]	; (800ea90 <evt2_execute+0x350>)
 800e988:	4619      	mov	r1, r3
 800e98a:	2204      	movs	r2, #4
 800e98c:	f7ff fde0 	bl	800e550 <chEvtRegisterMask>
  test_wait_tick();
 800e990:	f7fd fb06 	bl	800bfa0 <test_wait_tick>
  target_time = chVTGetSystemTime() + MS2ST(50);
 800e994:	f7ff fdb4 	bl	800e500 <chVTGetSystemTime>
 800e998:	4603      	mov	r3, r0
 800e99a:	3332      	adds	r3, #50	; 0x32
 800e99c:	930c      	str	r3, [sp, #48]	; 0x30
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800e99e:	4b38      	ldr	r3, [pc, #224]	; (800ea80 <evt2_execute+0x340>)
 800e9a0:	681c      	ldr	r4, [r3, #0]
 800e9a2:	f7ff fdc5 	bl	800e530 <chThdGetPriorityX>
 800e9a6:	4603      	mov	r3, r0
 800e9a8:	3b01      	subs	r3, #1
 800e9aa:	4a3a      	ldr	r2, [pc, #232]	; (800ea94 <evt2_execute+0x354>)
 800e9ac:	9200      	str	r2, [sp, #0]
 800e9ae:	4620      	mov	r0, r4
 800e9b0:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800e9b4:	461a      	mov	r2, r3
 800e9b6:	4b38      	ldr	r3, [pc, #224]	; (800ea98 <evt2_execute+0x358>)
 800e9b8:	f7f2 fc12 	bl	80011e0 <chThdCreateStatic>
 800e9bc:	4602      	mov	r2, r0
 800e9be:	4b32      	ldr	r3, [pc, #200]	; (800ea88 <evt2_execute+0x348>)
 800e9c0:	601a      	str	r2, [r3, #0]
                                 thread2, "A");
  m = chEvtWaitAll(5);
 800e9c2:	2005      	movs	r0, #5
 800e9c4:	f7f3 ff9c 	bl	8002900 <chEvtWaitAll>
 800e9c8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert_time_window(13, target_time, target_time + ALLOWED_DELAY);
 800e9ca:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 800e9cc:	3305      	adds	r3, #5
 800e9ce:	200d      	movs	r0, #13
 800e9d0:	990c      	ldr	r1, [sp, #48]	; 0x30
 800e9d2:	461a      	mov	r2, r3
 800e9d4:	f7fd fa84 	bl	800bee0 <_test_assert_time_window>
 800e9d8:	4603      	mov	r3, r0
 800e9da:	2b00      	cmp	r3, #0
 800e9dc:	d000      	beq.n	800e9e0 <evt2_execute+0x2a0>
 800e9de:	e04c      	b.n	800ea7a <evt2_execute+0x33a>
  m = chEvtGetAndClearEvents(ALL_EVENTS);
 800e9e0:	f04f 30ff 	mov.w	r0, #4294967295
 800e9e4:	f7f3 fe0c 	bl	8002600 <chEvtGetAndClearEvents>
 800e9e8:	900d      	str	r0, [sp, #52]	; 0x34
  test_assert(14, m == 0, "stuck event");
 800e9ea:	9b0d      	ldr	r3, [sp, #52]	; 0x34
 800e9ec:	2b00      	cmp	r3, #0
 800e9ee:	bf14      	ite	ne
 800e9f0:	2300      	movne	r3, #0
 800e9f2:	2301      	moveq	r3, #1
 800e9f4:	b2db      	uxtb	r3, r3
 800e9f6:	200e      	movs	r0, #14
 800e9f8:	4619      	mov	r1, r3
 800e9fa:	f7fd fa29 	bl	800be50 <_test_assert>
 800e9fe:	4603      	mov	r3, r0
 800ea00:	2b00      	cmp	r3, #0
 800ea02:	d000      	beq.n	800ea06 <evt2_execute+0x2c6>
 800ea04:	e039      	b.n	800ea7a <evt2_execute+0x33a>
  test_wait_threads();
 800ea06:	f7fd faa3 	bl	800bf50 <test_wait_threads>
  chEvtUnregister(&es1, &el1);
 800ea0a:	ab07      	add	r3, sp, #28
 800ea0c:	481f      	ldr	r0, [pc, #124]	; (800ea8c <evt2_execute+0x34c>)
 800ea0e:	4619      	mov	r1, r3
 800ea10:	f7f3 fdd6 	bl	80025c0 <chEvtUnregister>
  chEvtUnregister(&es2, &el2);
 800ea14:	ab02      	add	r3, sp, #8
 800ea16:	481e      	ldr	r0, [pc, #120]	; (800ea90 <evt2_execute+0x350>)
 800ea18:	4619      	mov	r1, r3
 800ea1a:	f7f3 fdd1 	bl	80025c0 <chEvtUnregister>
  test_assert(15, !chEvtIsListeningI(&es1), "stuck listener");
 800ea1e:	481b      	ldr	r0, [pc, #108]	; (800ea8c <evt2_execute+0x34c>)
 800ea20:	f7ff fda6 	bl	800e570 <chEvtIsListeningI>
 800ea24:	4603      	mov	r3, r0
 800ea26:	2b00      	cmp	r3, #0
 800ea28:	bf0c      	ite	eq
 800ea2a:	2300      	moveq	r3, #0
 800ea2c:	2301      	movne	r3, #1
 800ea2e:	b2db      	uxtb	r3, r3
 800ea30:	f083 0301 	eor.w	r3, r3, #1
 800ea34:	b2db      	uxtb	r3, r3
 800ea36:	f003 0301 	and.w	r3, r3, #1
 800ea3a:	b2db      	uxtb	r3, r3
 800ea3c:	200f      	movs	r0, #15
 800ea3e:	4619      	mov	r1, r3
 800ea40:	f7fd fa06 	bl	800be50 <_test_assert>
 800ea44:	4603      	mov	r3, r0
 800ea46:	2b00      	cmp	r3, #0
 800ea48:	d000      	beq.n	800ea4c <evt2_execute+0x30c>
 800ea4a:	e016      	b.n	800ea7a <evt2_execute+0x33a>
  test_assert(16, !chEvtIsListeningI(&es2), "stuck listener");
 800ea4c:	4810      	ldr	r0, [pc, #64]	; (800ea90 <evt2_execute+0x350>)
 800ea4e:	f7ff fd8f 	bl	800e570 <chEvtIsListeningI>
 800ea52:	4603      	mov	r3, r0
 800ea54:	2b00      	cmp	r3, #0
 800ea56:	bf0c      	ite	eq
 800ea58:	2300      	moveq	r3, #0
 800ea5a:	2301      	movne	r3, #1
 800ea5c:	b2db      	uxtb	r3, r3
 800ea5e:	f083 0301 	eor.w	r3, r3, #1
 800ea62:	b2db      	uxtb	r3, r3
 800ea64:	f003 0301 	and.w	r3, r3, #1
 800ea68:	b2db      	uxtb	r3, r3
 800ea6a:	2010      	movs	r0, #16
 800ea6c:	4619      	mov	r1, r3
 800ea6e:	f7fd f9ef 	bl	800be50 <_test_assert>
 800ea72:	4603      	mov	r3, r0
 800ea74:	2b00      	cmp	r3, #0
 800ea76:	d000      	beq.n	800ea7a <evt2_execute+0x33a>
 800ea78:	bf00      	nop
}
 800ea7a:	b00f      	add	sp, #60	; 0x3c
 800ea7c:	bd30      	pop	{r4, r5, pc}
 800ea7e:	bf00      	nop
 800ea80:	08019750 	.word	0x08019750
 800ea84:	0800e6f1 	.word	0x0800e6f1
 800ea88:	2000205c 	.word	0x2000205c
 800ea8c:	20000894 	.word	0x20000894
 800ea90:	20000898 	.word	0x20000898
 800ea94:	08019d04 	.word	0x08019d04
 800ea98:	0800e711 	.word	0x0800e711
 800ea9c:	f3af 8000 	nop.w

0800eaa0 <evt3_setup>:
 * - @p chEvtWaitAllTimeout()
 * .
 * After each test phase the test verifies that there are no stuck event flags.
 */

static void evt3_setup(void) {
 800eaa0:	b508      	push	{r3, lr}

  chEvtGetAndClearEvents(ALL_EVENTS);
 800eaa2:	f04f 30ff 	mov.w	r0, #4294967295
 800eaa6:	f7f3 fdab 	bl	8002600 <chEvtGetAndClearEvents>
}
 800eaaa:	bd08      	pop	{r3, pc}
 800eaac:	f3af 8000 	nop.w

0800eab0 <evt3_execute>:

static void evt3_execute(void) {
 800eab0:	b500      	push	{lr}
 800eab2:	b083      	sub	sp, #12
  eventmask_t m;

  /*
   * Tests various timeout situations.
   */
  m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eab4:	f04f 30ff 	mov.w	r0, #4294967295
 800eab8:	2100      	movs	r1, #0
 800eaba:	f7f3 ff49 	bl	8002950 <chEvtWaitOneTimeout>
 800eabe:	9001      	str	r0, [sp, #4]
  test_assert(1, m == 0, "spurious event");
 800eac0:	9b01      	ldr	r3, [sp, #4]
 800eac2:	2b00      	cmp	r3, #0
 800eac4:	bf14      	ite	ne
 800eac6:	2300      	movne	r3, #0
 800eac8:	2301      	moveq	r3, #1
 800eaca:	b2db      	uxtb	r3, r3
 800eacc:	2001      	movs	r0, #1
 800eace:	4619      	mov	r1, r3
 800ead0:	f7fd f9be 	bl	800be50 <_test_assert>
 800ead4:	4603      	mov	r3, r0
 800ead6:	2b00      	cmp	r3, #0
 800ead8:	d000      	beq.n	800eadc <evt3_execute+0x2c>
 800eada:	e063      	b.n	800eba4 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eadc:	f04f 30ff 	mov.w	r0, #4294967295
 800eae0:	2100      	movs	r1, #0
 800eae2:	f7f3 ff75 	bl	80029d0 <chEvtWaitAnyTimeout>
 800eae6:	9001      	str	r0, [sp, #4]
  test_assert(2, m == 0, "spurious event");
 800eae8:	9b01      	ldr	r3, [sp, #4]
 800eaea:	2b00      	cmp	r3, #0
 800eaec:	bf14      	ite	ne
 800eaee:	2300      	movne	r3, #0
 800eaf0:	2301      	moveq	r3, #1
 800eaf2:	b2db      	uxtb	r3, r3
 800eaf4:	2002      	movs	r0, #2
 800eaf6:	4619      	mov	r1, r3
 800eaf8:	f7fd f9aa 	bl	800be50 <_test_assert>
 800eafc:	4603      	mov	r3, r0
 800eafe:	2b00      	cmp	r3, #0
 800eb00:	d000      	beq.n	800eb04 <evt3_execute+0x54>
 800eb02:	e04f      	b.n	800eba4 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
 800eb04:	f04f 30ff 	mov.w	r0, #4294967295
 800eb08:	2100      	movs	r1, #0
 800eb0a:	f7f3 ffa1 	bl	8002a50 <chEvtWaitAllTimeout>
 800eb0e:	9001      	str	r0, [sp, #4]
  test_assert(3, m == 0, "spurious event");
 800eb10:	9b01      	ldr	r3, [sp, #4]
 800eb12:	2b00      	cmp	r3, #0
 800eb14:	bf14      	ite	ne
 800eb16:	2300      	movne	r3, #0
 800eb18:	2301      	moveq	r3, #1
 800eb1a:	b2db      	uxtb	r3, r3
 800eb1c:	2003      	movs	r0, #3
 800eb1e:	4619      	mov	r1, r3
 800eb20:	f7fd f996 	bl	800be50 <_test_assert>
 800eb24:	4603      	mov	r3, r0
 800eb26:	2b00      	cmp	r3, #0
 800eb28:	d000      	beq.n	800eb2c <evt3_execute+0x7c>
 800eb2a:	e03b      	b.n	800eba4 <evt3_execute+0xf4>
  m = chEvtWaitOneTimeout(ALL_EVENTS, 10);
 800eb2c:	f04f 30ff 	mov.w	r0, #4294967295
 800eb30:	210a      	movs	r1, #10
 800eb32:	f7f3 ff0d 	bl	8002950 <chEvtWaitOneTimeout>
 800eb36:	9001      	str	r0, [sp, #4]
  test_assert(4, m == 0, "spurious event");
 800eb38:	9b01      	ldr	r3, [sp, #4]
 800eb3a:	2b00      	cmp	r3, #0
 800eb3c:	bf14      	ite	ne
 800eb3e:	2300      	movne	r3, #0
 800eb40:	2301      	moveq	r3, #1
 800eb42:	b2db      	uxtb	r3, r3
 800eb44:	2004      	movs	r0, #4
 800eb46:	4619      	mov	r1, r3
 800eb48:	f7fd f982 	bl	800be50 <_test_assert>
 800eb4c:	4603      	mov	r3, r0
 800eb4e:	2b00      	cmp	r3, #0
 800eb50:	d000      	beq.n	800eb54 <evt3_execute+0xa4>
 800eb52:	e027      	b.n	800eba4 <evt3_execute+0xf4>
  m = chEvtWaitAnyTimeout(ALL_EVENTS, 10);
 800eb54:	f04f 30ff 	mov.w	r0, #4294967295
 800eb58:	210a      	movs	r1, #10
 800eb5a:	f7f3 ff39 	bl	80029d0 <chEvtWaitAnyTimeout>
 800eb5e:	9001      	str	r0, [sp, #4]
  test_assert(5, m == 0, "spurious event");
 800eb60:	9b01      	ldr	r3, [sp, #4]
 800eb62:	2b00      	cmp	r3, #0
 800eb64:	bf14      	ite	ne
 800eb66:	2300      	movne	r3, #0
 800eb68:	2301      	moveq	r3, #1
 800eb6a:	b2db      	uxtb	r3, r3
 800eb6c:	2005      	movs	r0, #5
 800eb6e:	4619      	mov	r1, r3
 800eb70:	f7fd f96e 	bl	800be50 <_test_assert>
 800eb74:	4603      	mov	r3, r0
 800eb76:	2b00      	cmp	r3, #0
 800eb78:	d000      	beq.n	800eb7c <evt3_execute+0xcc>
 800eb7a:	e013      	b.n	800eba4 <evt3_execute+0xf4>
  m = chEvtWaitAllTimeout(ALL_EVENTS, 10);
 800eb7c:	f04f 30ff 	mov.w	r0, #4294967295
 800eb80:	210a      	movs	r1, #10
 800eb82:	f7f3 ff65 	bl	8002a50 <chEvtWaitAllTimeout>
 800eb86:	9001      	str	r0, [sp, #4]
  test_assert(6, m == 0, "spurious event");
 800eb88:	9b01      	ldr	r3, [sp, #4]
 800eb8a:	2b00      	cmp	r3, #0
 800eb8c:	bf14      	ite	ne
 800eb8e:	2300      	movne	r3, #0
 800eb90:	2301      	moveq	r3, #1
 800eb92:	b2db      	uxtb	r3, r3
 800eb94:	2006      	movs	r0, #6
 800eb96:	4619      	mov	r1, r3
 800eb98:	f7fd f95a 	bl	800be50 <_test_assert>
 800eb9c:	4603      	mov	r3, r0
 800eb9e:	2b00      	cmp	r3, #0
 800eba0:	d000      	beq.n	800eba4 <evt3_execute+0xf4>
 800eba2:	bf00      	nop
}
 800eba4:	b003      	add	sp, #12
 800eba6:	f85d fb04 	ldr.w	pc, [sp], #4
 800ebaa:	bf00      	nop
 800ebac:	f3af 8000 	nop.w

0800ebb0 <heap1_setup>:
 * allocator.<br>
 * The test expects to find the heap back to the initial status after each
 * sequence.
 */

static void heap1_setup(void) {
 800ebb0:	b508      	push	{r3, lr}

  chHeapObjectInit(&test_heap, test.buffer, sizeof(union test_buffers));
 800ebb2:	4803      	ldr	r0, [pc, #12]	; (800ebc0 <heap1_setup+0x10>)
 800ebb4:	4903      	ldr	r1, [pc, #12]	; (800ebc4 <heap1_setup+0x14>)
 800ebb6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800ebba:	f7f4 fdb1 	bl	8003720 <chHeapObjectInit>
}
 800ebbe:	bd08      	pop	{r3, pc}
 800ebc0:	20001408 	.word	0x20001408
 800ebc4:	20002070 	.word	0x20002070
 800ebc8:	f3af 8000 	nop.w
 800ebcc:	f3af 8000 	nop.w

0800ebd0 <heap1_execute>:

static void heap1_execute(void) {
 800ebd0:	b500      	push	{lr}
 800ebd2:	b087      	sub	sp, #28
  void *p1, *p2, *p3;
  size_t n, sz;

  /* Unrelated, for coverage only.*/
  (void)chCoreGetStatusX();
 800ebd4:	f7f4 fd7c 	bl	80036d0 <chCoreGetStatusX>

  /*
   * Test on the default heap in order to cover the core allocator at
   * least one time.
   */
  (void)chHeapStatus(NULL, &sz);
 800ebd8:	ab01      	add	r3, sp, #4
 800ebda:	2000      	movs	r0, #0
 800ebdc:	4619      	mov	r1, r3
 800ebde:	f7f4 fe9f 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(NULL, SIZE);
 800ebe2:	2000      	movs	r0, #0
 800ebe4:	2110      	movs	r1, #16
 800ebe6:	f7f4 fdbb 	bl	8003760 <chHeapAlloc>
 800ebea:	9005      	str	r0, [sp, #20]
  test_assert(1, p1 != NULL, "allocation failed");
 800ebec:	9b05      	ldr	r3, [sp, #20]
 800ebee:	2b00      	cmp	r3, #0
 800ebf0:	bf0c      	ite	eq
 800ebf2:	2300      	moveq	r3, #0
 800ebf4:	2301      	movne	r3, #1
 800ebf6:	b2db      	uxtb	r3, r3
 800ebf8:	2001      	movs	r0, #1
 800ebfa:	4619      	mov	r1, r3
 800ebfc:	f7fd f928 	bl	800be50 <_test_assert>
 800ec00:	4603      	mov	r3, r0
 800ec02:	2b00      	cmp	r3, #0
 800ec04:	d000      	beq.n	800ec08 <heap1_execute+0x38>
 800ec06:	e14e      	b.n	800eea6 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800ec08:	9805      	ldr	r0, [sp, #20]
 800ec0a:	f7f4 fe21 	bl	8003850 <chHeapFree>
  p1 = chHeapAlloc(NULL, (size_t)-256);
 800ec0e:	2000      	movs	r0, #0
 800ec10:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 800ec14:	f7f4 fda4 	bl	8003760 <chHeapAlloc>
 800ec18:	9005      	str	r0, [sp, #20]
  test_assert(2, p1 == NULL, "allocation not failed");
 800ec1a:	9b05      	ldr	r3, [sp, #20]
 800ec1c:	2b00      	cmp	r3, #0
 800ec1e:	bf14      	ite	ne
 800ec20:	2300      	movne	r3, #0
 800ec22:	2301      	moveq	r3, #1
 800ec24:	b2db      	uxtb	r3, r3
 800ec26:	2002      	movs	r0, #2
 800ec28:	4619      	mov	r1, r3
 800ec2a:	f7fd f911 	bl	800be50 <_test_assert>
 800ec2e:	4603      	mov	r3, r0
 800ec30:	2b00      	cmp	r3, #0
 800ec32:	d000      	beq.n	800ec36 <heap1_execute+0x66>
 800ec34:	e137      	b.n	800eea6 <heap1_execute+0x2d6>

  /* Initial local heap state.*/
  (void)chHeapStatus(&test_heap, &sz);
 800ec36:	ab01      	add	r3, sp, #4
 800ec38:	489c      	ldr	r0, [pc, #624]	; (800eeac <heap1_execute+0x2dc>)
 800ec3a:	4619      	mov	r1, r3
 800ec3c:	f7f4 fe70 	bl	8003920 <chHeapStatus>

  /* Same order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ec40:	489a      	ldr	r0, [pc, #616]	; (800eeac <heap1_execute+0x2dc>)
 800ec42:	2110      	movs	r1, #16
 800ec44:	f7f4 fd8c 	bl	8003760 <chHeapAlloc>
 800ec48:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ec4a:	4898      	ldr	r0, [pc, #608]	; (800eeac <heap1_execute+0x2dc>)
 800ec4c:	2110      	movs	r1, #16
 800ec4e:	f7f4 fd87 	bl	8003760 <chHeapAlloc>
 800ec52:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ec54:	4895      	ldr	r0, [pc, #596]	; (800eeac <heap1_execute+0x2dc>)
 800ec56:	2110      	movs	r1, #16
 800ec58:	f7f4 fd82 	bl	8003760 <chHeapAlloc>
 800ec5c:	9003      	str	r0, [sp, #12]
  chHeapFree(p1);                               /* Does not merge.*/
 800ec5e:	9805      	ldr	r0, [sp, #20]
 800ec60:	f7f4 fdf6 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges backward.*/
 800ec64:	9804      	ldr	r0, [sp, #16]
 800ec66:	f7f4 fdf3 	bl	8003850 <chHeapFree>
  chHeapFree(p3);                               /* Merges both sides.*/
 800ec6a:	9803      	ldr	r0, [sp, #12]
 800ec6c:	f7f4 fdf0 	bl	8003850 <chHeapFree>
  test_assert(3, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ec70:	ab02      	add	r3, sp, #8
 800ec72:	488e      	ldr	r0, [pc, #568]	; (800eeac <heap1_execute+0x2dc>)
 800ec74:	4619      	mov	r1, r3
 800ec76:	f7f4 fe53 	bl	8003920 <chHeapStatus>
 800ec7a:	4603      	mov	r3, r0
 800ec7c:	2b01      	cmp	r3, #1
 800ec7e:	bf14      	ite	ne
 800ec80:	2300      	movne	r3, #0
 800ec82:	2301      	moveq	r3, #1
 800ec84:	b2db      	uxtb	r3, r3
 800ec86:	2003      	movs	r0, #3
 800ec88:	4619      	mov	r1, r3
 800ec8a:	f7fd f8e1 	bl	800be50 <_test_assert>
 800ec8e:	4603      	mov	r3, r0
 800ec90:	2b00      	cmp	r3, #0
 800ec92:	d000      	beq.n	800ec96 <heap1_execute+0xc6>
 800ec94:	e107      	b.n	800eea6 <heap1_execute+0x2d6>

  /* Reverse order.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ec96:	4885      	ldr	r0, [pc, #532]	; (800eeac <heap1_execute+0x2dc>)
 800ec98:	2110      	movs	r1, #16
 800ec9a:	f7f4 fd61 	bl	8003760 <chHeapAlloc>
 800ec9e:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800eca0:	4882      	ldr	r0, [pc, #520]	; (800eeac <heap1_execute+0x2dc>)
 800eca2:	2110      	movs	r1, #16
 800eca4:	f7f4 fd5c 	bl	8003760 <chHeapAlloc>
 800eca8:	9004      	str	r0, [sp, #16]
  p3 = chHeapAlloc(&test_heap, SIZE);
 800ecaa:	4880      	ldr	r0, [pc, #512]	; (800eeac <heap1_execute+0x2dc>)
 800ecac:	2110      	movs	r1, #16
 800ecae:	f7f4 fd57 	bl	8003760 <chHeapAlloc>
 800ecb2:	9003      	str	r0, [sp, #12]
  chHeapFree(p3);                               /* Merges forward.*/
 800ecb4:	9803      	ldr	r0, [sp, #12]
 800ecb6:	f7f4 fdcb 	bl	8003850 <chHeapFree>
  chHeapFree(p2);                               /* Merges forward.*/
 800ecba:	9804      	ldr	r0, [sp, #16]
 800ecbc:	f7f4 fdc8 	bl	8003850 <chHeapFree>
  chHeapFree(p1);                               /* Merges forward.*/
 800ecc0:	9805      	ldr	r0, [sp, #20]
 800ecc2:	f7f4 fdc5 	bl	8003850 <chHeapFree>
  test_assert(4, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ecc6:	ab02      	add	r3, sp, #8
 800ecc8:	4878      	ldr	r0, [pc, #480]	; (800eeac <heap1_execute+0x2dc>)
 800ecca:	4619      	mov	r1, r3
 800eccc:	f7f4 fe28 	bl	8003920 <chHeapStatus>
 800ecd0:	4603      	mov	r3, r0
 800ecd2:	2b01      	cmp	r3, #1
 800ecd4:	bf14      	ite	ne
 800ecd6:	2300      	movne	r3, #0
 800ecd8:	2301      	moveq	r3, #1
 800ecda:	b2db      	uxtb	r3, r3
 800ecdc:	2004      	movs	r0, #4
 800ecde:	4619      	mov	r1, r3
 800ece0:	f7fd f8b6 	bl	800be50 <_test_assert>
 800ece4:	4603      	mov	r3, r0
 800ece6:	2b00      	cmp	r3, #0
 800ece8:	d000      	beq.n	800ecec <heap1_execute+0x11c>
 800ecea:	e0dc      	b.n	800eea6 <heap1_execute+0x2d6>

  /* Small fragments handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE + 1);
 800ecec:	486f      	ldr	r0, [pc, #444]	; (800eeac <heap1_execute+0x2dc>)
 800ecee:	2111      	movs	r1, #17
 800ecf0:	f7f4 fd36 	bl	8003760 <chHeapAlloc>
 800ecf4:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800ecf6:	486d      	ldr	r0, [pc, #436]	; (800eeac <heap1_execute+0x2dc>)
 800ecf8:	2110      	movs	r1, #16
 800ecfa:	f7f4 fd31 	bl	8003760 <chHeapAlloc>
 800ecfe:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800ed00:	9805      	ldr	r0, [sp, #20]
 800ed02:	f7f4 fda5 	bl	8003850 <chHeapFree>
  test_assert(5, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800ed06:	ab02      	add	r3, sp, #8
 800ed08:	4868      	ldr	r0, [pc, #416]	; (800eeac <heap1_execute+0x2dc>)
 800ed0a:	4619      	mov	r1, r3
 800ed0c:	f7f4 fe08 	bl	8003920 <chHeapStatus>
 800ed10:	4603      	mov	r3, r0
 800ed12:	2b02      	cmp	r3, #2
 800ed14:	bf14      	ite	ne
 800ed16:	2300      	movne	r3, #0
 800ed18:	2301      	moveq	r3, #1
 800ed1a:	b2db      	uxtb	r3, r3
 800ed1c:	2005      	movs	r0, #5
 800ed1e:	4619      	mov	r1, r3
 800ed20:	f7fd f896 	bl	800be50 <_test_assert>
 800ed24:	4603      	mov	r3, r0
 800ed26:	2b00      	cmp	r3, #0
 800ed28:	d000      	beq.n	800ed2c <heap1_execute+0x15c>
 800ed2a:	e0bc      	b.n	800eea6 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE);
 800ed2c:	485f      	ldr	r0, [pc, #380]	; (800eeac <heap1_execute+0x2dc>)
 800ed2e:	2110      	movs	r1, #16
 800ed30:	f7f4 fd16 	bl	8003760 <chHeapAlloc>
 800ed34:	9005      	str	r0, [sp, #20]
  /* Note, the first situation happens when the alignment size is smaller
     than the header size, the second in the other cases.*/
  test_assert(6, (chHeapStatus(&test_heap, &n) == 1) ||
 800ed36:	ab02      	add	r3, sp, #8
 800ed38:	485c      	ldr	r0, [pc, #368]	; (800eeac <heap1_execute+0x2dc>)
 800ed3a:	4619      	mov	r1, r3
 800ed3c:	f7f4 fdf0 	bl	8003920 <chHeapStatus>
 800ed40:	4603      	mov	r3, r0
 800ed42:	2b01      	cmp	r3, #1
 800ed44:	d007      	beq.n	800ed56 <heap1_execute+0x186>
 800ed46:	ab02      	add	r3, sp, #8
 800ed48:	4858      	ldr	r0, [pc, #352]	; (800eeac <heap1_execute+0x2dc>)
 800ed4a:	4619      	mov	r1, r3
 800ed4c:	f7f4 fde8 	bl	8003920 <chHeapStatus>
 800ed50:	4603      	mov	r3, r0
 800ed52:	2b02      	cmp	r3, #2
 800ed54:	d101      	bne.n	800ed5a <heap1_execute+0x18a>
 800ed56:	2301      	movs	r3, #1
 800ed58:	e000      	b.n	800ed5c <heap1_execute+0x18c>
 800ed5a:	2300      	movs	r3, #0
 800ed5c:	f003 0301 	and.w	r3, r3, #1
 800ed60:	b2db      	uxtb	r3, r3
 800ed62:	2006      	movs	r0, #6
 800ed64:	4619      	mov	r1, r3
 800ed66:	f7fd f873 	bl	800be50 <_test_assert>
 800ed6a:	4603      	mov	r3, r0
 800ed6c:	2b00      	cmp	r3, #0
 800ed6e:	d000      	beq.n	800ed72 <heap1_execute+0x1a2>
 800ed70:	e099      	b.n	800eea6 <heap1_execute+0x2d6>
                 (chHeapStatus(&test_heap, &n) == 2), "heap fragmented");
  chHeapFree(p2);
 800ed72:	9804      	ldr	r0, [sp, #16]
 800ed74:	f7f4 fd6c 	bl	8003850 <chHeapFree>
  chHeapFree(p1);
 800ed78:	9805      	ldr	r0, [sp, #20]
 800ed7a:	f7f4 fd69 	bl	8003850 <chHeapFree>
  test_assert(7, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ed7e:	ab02      	add	r3, sp, #8
 800ed80:	484a      	ldr	r0, [pc, #296]	; (800eeac <heap1_execute+0x2dc>)
 800ed82:	4619      	mov	r1, r3
 800ed84:	f7f4 fdcc 	bl	8003920 <chHeapStatus>
 800ed88:	4603      	mov	r3, r0
 800ed8a:	2b01      	cmp	r3, #1
 800ed8c:	bf14      	ite	ne
 800ed8e:	2300      	movne	r3, #0
 800ed90:	2301      	moveq	r3, #1
 800ed92:	b2db      	uxtb	r3, r3
 800ed94:	2007      	movs	r0, #7
 800ed96:	4619      	mov	r1, r3
 800ed98:	f7fd f85a 	bl	800be50 <_test_assert>
 800ed9c:	4603      	mov	r3, r0
 800ed9e:	2b00      	cmp	r3, #0
 800eda0:	d000      	beq.n	800eda4 <heap1_execute+0x1d4>
 800eda2:	e080      	b.n	800eea6 <heap1_execute+0x2d6>

  /* Skip fragment handling.*/
  p1 = chHeapAlloc(&test_heap, SIZE);
 800eda4:	4841      	ldr	r0, [pc, #260]	; (800eeac <heap1_execute+0x2dc>)
 800eda6:	2110      	movs	r1, #16
 800eda8:	f7f4 fcda 	bl	8003760 <chHeapAlloc>
 800edac:	9005      	str	r0, [sp, #20]
  p2 = chHeapAlloc(&test_heap, SIZE);
 800edae:	483f      	ldr	r0, [pc, #252]	; (800eeac <heap1_execute+0x2dc>)
 800edb0:	2110      	movs	r1, #16
 800edb2:	f7f4 fcd5 	bl	8003760 <chHeapAlloc>
 800edb6:	9004      	str	r0, [sp, #16]
  chHeapFree(p1);
 800edb8:	9805      	ldr	r0, [sp, #20]
 800edba:	f7f4 fd49 	bl	8003850 <chHeapFree>
  test_assert(8, chHeapStatus(&test_heap, &n) == 2, "invalid state");
 800edbe:	ab02      	add	r3, sp, #8
 800edc0:	483a      	ldr	r0, [pc, #232]	; (800eeac <heap1_execute+0x2dc>)
 800edc2:	4619      	mov	r1, r3
 800edc4:	f7f4 fdac 	bl	8003920 <chHeapStatus>
 800edc8:	4603      	mov	r3, r0
 800edca:	2b02      	cmp	r3, #2
 800edcc:	bf14      	ite	ne
 800edce:	2300      	movne	r3, #0
 800edd0:	2301      	moveq	r3, #1
 800edd2:	b2db      	uxtb	r3, r3
 800edd4:	2008      	movs	r0, #8
 800edd6:	4619      	mov	r1, r3
 800edd8:	f7fd f83a 	bl	800be50 <_test_assert>
 800eddc:	4603      	mov	r3, r0
 800edde:	2b00      	cmp	r3, #0
 800ede0:	d000      	beq.n	800ede4 <heap1_execute+0x214>
 800ede2:	e060      	b.n	800eea6 <heap1_execute+0x2d6>
  p1 = chHeapAlloc(&test_heap, SIZE * 2);       /* Skips first fragment.*/
 800ede4:	4831      	ldr	r0, [pc, #196]	; (800eeac <heap1_execute+0x2dc>)
 800ede6:	2120      	movs	r1, #32
 800ede8:	f7f4 fcba 	bl	8003760 <chHeapAlloc>
 800edec:	9005      	str	r0, [sp, #20]
  chHeapFree(p1);
 800edee:	9805      	ldr	r0, [sp, #20]
 800edf0:	f7f4 fd2e 	bl	8003850 <chHeapFree>
  chHeapFree(p2);
 800edf4:	9804      	ldr	r0, [sp, #16]
 800edf6:	f7f4 fd2b 	bl	8003850 <chHeapFree>
  test_assert(9, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800edfa:	ab02      	add	r3, sp, #8
 800edfc:	482b      	ldr	r0, [pc, #172]	; (800eeac <heap1_execute+0x2dc>)
 800edfe:	4619      	mov	r1, r3
 800ee00:	f7f4 fd8e 	bl	8003920 <chHeapStatus>
 800ee04:	4603      	mov	r3, r0
 800ee06:	2b01      	cmp	r3, #1
 800ee08:	bf14      	ite	ne
 800ee0a:	2300      	movne	r3, #0
 800ee0c:	2301      	moveq	r3, #1
 800ee0e:	b2db      	uxtb	r3, r3
 800ee10:	2009      	movs	r0, #9
 800ee12:	4619      	mov	r1, r3
 800ee14:	f7fd f81c 	bl	800be50 <_test_assert>
 800ee18:	4603      	mov	r3, r0
 800ee1a:	2b00      	cmp	r3, #0
 800ee1c:	d000      	beq.n	800ee20 <heap1_execute+0x250>
 800ee1e:	e042      	b.n	800eea6 <heap1_execute+0x2d6>

  /* Allocate all handling.*/
  (void)chHeapStatus(&test_heap, &n);
 800ee20:	ab02      	add	r3, sp, #8
 800ee22:	4822      	ldr	r0, [pc, #136]	; (800eeac <heap1_execute+0x2dc>)
 800ee24:	4619      	mov	r1, r3
 800ee26:	f7f4 fd7b 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&test_heap, n);
 800ee2a:	9b02      	ldr	r3, [sp, #8]
 800ee2c:	481f      	ldr	r0, [pc, #124]	; (800eeac <heap1_execute+0x2dc>)
 800ee2e:	4619      	mov	r1, r3
 800ee30:	f7f4 fc96 	bl	8003760 <chHeapAlloc>
 800ee34:	9005      	str	r0, [sp, #20]
  test_assert(10, chHeapStatus(&test_heap, &n) == 0, "not empty");
 800ee36:	ab02      	add	r3, sp, #8
 800ee38:	481c      	ldr	r0, [pc, #112]	; (800eeac <heap1_execute+0x2dc>)
 800ee3a:	4619      	mov	r1, r3
 800ee3c:	f7f4 fd70 	bl	8003920 <chHeapStatus>
 800ee40:	4603      	mov	r3, r0
 800ee42:	2b00      	cmp	r3, #0
 800ee44:	bf14      	ite	ne
 800ee46:	2300      	movne	r3, #0
 800ee48:	2301      	moveq	r3, #1
 800ee4a:	b2db      	uxtb	r3, r3
 800ee4c:	200a      	movs	r0, #10
 800ee4e:	4619      	mov	r1, r3
 800ee50:	f7fc fffe 	bl	800be50 <_test_assert>
 800ee54:	4603      	mov	r3, r0
 800ee56:	2b00      	cmp	r3, #0
 800ee58:	d000      	beq.n	800ee5c <heap1_execute+0x28c>
 800ee5a:	e024      	b.n	800eea6 <heap1_execute+0x2d6>
  chHeapFree(p1);
 800ee5c:	9805      	ldr	r0, [sp, #20]
 800ee5e:	f7f4 fcf7 	bl	8003850 <chHeapFree>

  test_assert(11, chHeapStatus(&test_heap, &n) == 1, "heap fragmented");
 800ee62:	ab02      	add	r3, sp, #8
 800ee64:	4811      	ldr	r0, [pc, #68]	; (800eeac <heap1_execute+0x2dc>)
 800ee66:	4619      	mov	r1, r3
 800ee68:	f7f4 fd5a 	bl	8003920 <chHeapStatus>
 800ee6c:	4603      	mov	r3, r0
 800ee6e:	2b01      	cmp	r3, #1
 800ee70:	bf14      	ite	ne
 800ee72:	2300      	movne	r3, #0
 800ee74:	2301      	moveq	r3, #1
 800ee76:	b2db      	uxtb	r3, r3
 800ee78:	200b      	movs	r0, #11
 800ee7a:	4619      	mov	r1, r3
 800ee7c:	f7fc ffe8 	bl	800be50 <_test_assert>
 800ee80:	4603      	mov	r3, r0
 800ee82:	2b00      	cmp	r3, #0
 800ee84:	d000      	beq.n	800ee88 <heap1_execute+0x2b8>
 800ee86:	e00e      	b.n	800eea6 <heap1_execute+0x2d6>
  test_assert(12, n == sz, "size changed");
 800ee88:	9a02      	ldr	r2, [sp, #8]
 800ee8a:	9b01      	ldr	r3, [sp, #4]
 800ee8c:	429a      	cmp	r2, r3
 800ee8e:	bf14      	ite	ne
 800ee90:	2300      	movne	r3, #0
 800ee92:	2301      	moveq	r3, #1
 800ee94:	b2db      	uxtb	r3, r3
 800ee96:	200c      	movs	r0, #12
 800ee98:	4619      	mov	r1, r3
 800ee9a:	f7fc ffd9 	bl	800be50 <_test_assert>
 800ee9e:	4603      	mov	r3, r0
 800eea0:	2b00      	cmp	r3, #0
 800eea2:	d000      	beq.n	800eea6 <heap1_execute+0x2d6>
 800eea4:	bf00      	nop
}
 800eea6:	b007      	add	sp, #28
 800eea8:	f85d fb04 	ldr.w	pc, [sp], #4
 800eeac:	20001408 	.word	0x20001408

0800eeb0 <null_provider>:
 * Five memory blocks are added to a memory pool then removed.<br>
 * The test expects to find the pool queue in the proper status after each
 * operation.
 */

static void *null_provider(size_t size) {
 800eeb0:	b082      	sub	sp, #8
 800eeb2:	9001      	str	r0, [sp, #4]

  (void)size;
  return NULL;
 800eeb4:	2300      	movs	r3, #0
}
 800eeb6:	4618      	mov	r0, r3
 800eeb8:	b002      	add	sp, #8
 800eeba:	4770      	bx	lr
 800eebc:	f3af 8000 	nop.w

0800eec0 <pools1_setup>:

static void pools1_setup(void) {
 800eec0:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800eec2:	4803      	ldr	r0, [pc, #12]	; (800eed0 <pools1_setup+0x10>)
 800eec4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800eec8:	2200      	movs	r2, #0
 800eeca:	f7f4 fd91 	bl	80039f0 <chPoolObjectInit>
}
 800eece:	bd08      	pop	{r3, pc}
 800eed0:	2000089c 	.word	0x2000089c
 800eed4:	f3af 8000 	nop.w
 800eed8:	f3af 8000 	nop.w
 800eedc:	f3af 8000 	nop.w

0800eee0 <pools1_execute>:

static void pools1_execute(void) {
 800eee0:	b500      	push	{lr}
 800eee2:	b083      	sub	sp, #12
  int i;

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);
 800eee4:	4b43      	ldr	r3, [pc, #268]	; (800eff4 <pools1_execute+0x114>)
 800eee6:	681b      	ldr	r3, [r3, #0]
 800eee8:	4843      	ldr	r0, [pc, #268]	; (800eff8 <pools1_execute+0x118>)
 800eeea:	4619      	mov	r1, r3
 800eeec:	2205      	movs	r2, #5
 800eeee:	f7f4 fd8f 	bl	8003a10 <chPoolLoadArray>

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800eef2:	2300      	movs	r3, #0
 800eef4:	9301      	str	r3, [sp, #4]
 800eef6:	e013      	b.n	800ef20 <pools1_execute+0x40>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");
 800eef8:	483f      	ldr	r0, [pc, #252]	; (800eff8 <pools1_execute+0x118>)
 800eefa:	f7f4 fdc1 	bl	8003a80 <chPoolAlloc>
 800eefe:	4603      	mov	r3, r0
 800ef00:	2b00      	cmp	r3, #0
 800ef02:	bf0c      	ite	eq
 800ef04:	2300      	moveq	r3, #0
 800ef06:	2301      	movne	r3, #1
 800ef08:	b2db      	uxtb	r3, r3
 800ef0a:	2001      	movs	r0, #1
 800ef0c:	4619      	mov	r1, r3
 800ef0e:	f7fc ff9f 	bl	800be50 <_test_assert>
 800ef12:	4603      	mov	r3, r0
 800ef14:	2b00      	cmp	r3, #0
 800ef16:	d000      	beq.n	800ef1a <pools1_execute+0x3a>
 800ef18:	e068      	b.n	800efec <pools1_execute+0x10c>

  /* Adding the WAs to the pool.*/
  chPoolLoadArray(&mp1, wa[0], MAX_THREADS);

  /* Emptying the pool.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef1a:	9b01      	ldr	r3, [sp, #4]
 800ef1c:	3301      	adds	r3, #1
 800ef1e:	9301      	str	r3, [sp, #4]
 800ef20:	9b01      	ldr	r3, [sp, #4]
 800ef22:	2b04      	cmp	r3, #4
 800ef24:	dde8      	ble.n	800eef8 <pools1_execute+0x18>
    test_assert(1, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");
 800ef26:	4834      	ldr	r0, [pc, #208]	; (800eff8 <pools1_execute+0x118>)
 800ef28:	f7f4 fdaa 	bl	8003a80 <chPoolAlloc>
 800ef2c:	4603      	mov	r3, r0
 800ef2e:	2b00      	cmp	r3, #0
 800ef30:	bf14      	ite	ne
 800ef32:	2300      	movne	r3, #0
 800ef34:	2301      	moveq	r3, #1
 800ef36:	b2db      	uxtb	r3, r3
 800ef38:	2002      	movs	r0, #2
 800ef3a:	4619      	mov	r1, r3
 800ef3c:	f7fc ff88 	bl	800be50 <_test_assert>
 800ef40:	4603      	mov	r3, r0
 800ef42:	2b00      	cmp	r3, #0
 800ef44:	d000      	beq.n	800ef48 <pools1_execute+0x68>
 800ef46:	e051      	b.n	800efec <pools1_execute+0x10c>

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef48:	2300      	movs	r3, #0
 800ef4a:	9301      	str	r3, [sp, #4]
 800ef4c:	e00a      	b.n	800ef64 <pools1_execute+0x84>
    chPoolFree(&mp1, wa[i]);
 800ef4e:	4b29      	ldr	r3, [pc, #164]	; (800eff4 <pools1_execute+0x114>)
 800ef50:	9a01      	ldr	r2, [sp, #4]
 800ef52:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800ef56:	4828      	ldr	r0, [pc, #160]	; (800eff8 <pools1_execute+0x118>)
 800ef58:	4619      	mov	r1, r3
 800ef5a:	f7f4 fdb1 	bl	8003ac0 <chPoolFree>

  /* Now must be empty.*/
  test_assert(2, chPoolAlloc(&mp1) == NULL, "list not empty");

  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef5e:	9b01      	ldr	r3, [sp, #4]
 800ef60:	3301      	adds	r3, #1
 800ef62:	9301      	str	r3, [sp, #4]
 800ef64:	9b01      	ldr	r3, [sp, #4]
 800ef66:	2b04      	cmp	r3, #4
 800ef68:	ddf1      	ble.n	800ef4e <pools1_execute+0x6e>
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef6a:	2300      	movs	r3, #0
 800ef6c:	9301      	str	r3, [sp, #4]
 800ef6e:	e013      	b.n	800ef98 <pools1_execute+0xb8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");
 800ef70:	4821      	ldr	r0, [pc, #132]	; (800eff8 <pools1_execute+0x118>)
 800ef72:	f7f4 fd85 	bl	8003a80 <chPoolAlloc>
 800ef76:	4603      	mov	r3, r0
 800ef78:	2b00      	cmp	r3, #0
 800ef7a:	bf0c      	ite	eq
 800ef7c:	2300      	moveq	r3, #0
 800ef7e:	2301      	movne	r3, #1
 800ef80:	b2db      	uxtb	r3, r3
 800ef82:	2003      	movs	r0, #3
 800ef84:	4619      	mov	r1, r3
 800ef86:	f7fc ff63 	bl	800be50 <_test_assert>
 800ef8a:	4603      	mov	r3, r0
 800ef8c:	2b00      	cmp	r3, #0
 800ef8e:	d000      	beq.n	800ef92 <pools1_execute+0xb2>
 800ef90:	e02c      	b.n	800efec <pools1_execute+0x10c>
  /* Adding the WAs to the pool, one by one this time.*/
  for (i = 0; i < MAX_THREADS; i++)
    chPoolFree(&mp1, wa[i]);

  /* Emptying the pool again.*/
  for (i = 0; i < MAX_THREADS; i++)
 800ef92:	9b01      	ldr	r3, [sp, #4]
 800ef94:	3301      	adds	r3, #1
 800ef96:	9301      	str	r3, [sp, #4]
 800ef98:	9b01      	ldr	r3, [sp, #4]
 800ef9a:	2b04      	cmp	r3, #4
 800ef9c:	dde8      	ble.n	800ef70 <pools1_execute+0x90>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "list empty");

  /* Now must be empty again.*/
  test_assert(4, chPoolAlloc(&mp1) == NULL, "list not empty");
 800ef9e:	4816      	ldr	r0, [pc, #88]	; (800eff8 <pools1_execute+0x118>)
 800efa0:	f7f4 fd6e 	bl	8003a80 <chPoolAlloc>
 800efa4:	4603      	mov	r3, r0
 800efa6:	2b00      	cmp	r3, #0
 800efa8:	bf14      	ite	ne
 800efaa:	2300      	movne	r3, #0
 800efac:	2301      	moveq	r3, #1
 800efae:	b2db      	uxtb	r3, r3
 800efb0:	2004      	movs	r0, #4
 800efb2:	4619      	mov	r1, r3
 800efb4:	f7fc ff4c 	bl	800be50 <_test_assert>
 800efb8:	4603      	mov	r3, r0
 800efba:	2b00      	cmp	r3, #0
 800efbc:	d000      	beq.n	800efc0 <pools1_execute+0xe0>
 800efbe:	e015      	b.n	800efec <pools1_execute+0x10c>

  /* Covering the case where a provider is unable to return more memory.*/
  chPoolObjectInit(&mp1, 16, null_provider);
 800efc0:	480d      	ldr	r0, [pc, #52]	; (800eff8 <pools1_execute+0x118>)
 800efc2:	2110      	movs	r1, #16
 800efc4:	4a0d      	ldr	r2, [pc, #52]	; (800effc <pools1_execute+0x11c>)
 800efc6:	f7f4 fd13 	bl	80039f0 <chPoolObjectInit>
  test_assert(5, chPoolAlloc(&mp1) == NULL, "provider returned memory");
 800efca:	480b      	ldr	r0, [pc, #44]	; (800eff8 <pools1_execute+0x118>)
 800efcc:	f7f4 fd58 	bl	8003a80 <chPoolAlloc>
 800efd0:	4603      	mov	r3, r0
 800efd2:	2b00      	cmp	r3, #0
 800efd4:	bf14      	ite	ne
 800efd6:	2300      	movne	r3, #0
 800efd8:	2301      	moveq	r3, #1
 800efda:	b2db      	uxtb	r3, r3
 800efdc:	2005      	movs	r0, #5
 800efde:	4619      	mov	r1, r3
 800efe0:	f7fc ff36 	bl	800be50 <_test_assert>
 800efe4:	4603      	mov	r3, r0
 800efe6:	2b00      	cmp	r3, #0
 800efe8:	d000      	beq.n	800efec <pools1_execute+0x10c>
 800efea:	bf00      	nop
}
 800efec:	b003      	add	sp, #12
 800efee:	f85d fb04 	ldr.w	pc, [sp], #4
 800eff2:	bf00      	nop
 800eff4:	08019750 	.word	0x08019750
 800eff8:	2000089c 	.word	0x2000089c
 800effc:	0800eeb1 	.word	0x0800eeb1

0800f000 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f000:	4b01      	ldr	r3, [pc, #4]	; (800f008 <chThdGetSelfX+0x8>)
 800f002:	699b      	ldr	r3, [r3, #24]
}
 800f004:	4618      	mov	r0, r3
 800f006:	4770      	bx	lr
 800f008:	20001bc8 	.word	0x20001bc8
 800f00c:	f3af 8000 	nop.w

0800f010 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f010:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f012:	f7ff fff5 	bl	800f000 <chThdGetSelfX>
 800f016:	4603      	mov	r3, r0
 800f018:	689b      	ldr	r3, [r3, #8]
}
 800f01a:	4618      	mov	r0, r3
 800f01c:	bd08      	pop	{r3, pc}
 800f01e:	bf00      	nop

0800f020 <thread>:
 * is attempted.<br>
 * The test expects the first two threads to successfully start and the last
 * one to fail.
 */

static THD_FUNCTION(thread, p) {
 800f020:	b500      	push	{lr}
 800f022:	b083      	sub	sp, #12
 800f024:	9001      	str	r0, [sp, #4]

  test_emit_token(*(char *)p);
 800f026:	9b01      	ldr	r3, [sp, #4]
 800f028:	781b      	ldrb	r3, [r3, #0]
 800f02a:	4618      	mov	r0, r3
 800f02c:	f7fc fee0 	bl	800bdf0 <test_emit_token>
}
 800f030:	b003      	add	sp, #12
 800f032:	f85d fb04 	ldr.w	pc, [sp], #4
 800f036:	bf00      	nop
 800f038:	f3af 8000 	nop.w
 800f03c:	f3af 8000 	nop.w

0800f040 <dyn1_setup>:

#if CH_CFG_USE_HEAP || defined(__DOXYGEN__)
static void dyn1_setup(void) {
 800f040:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f042:	4803      	ldr	r0, [pc, #12]	; (800f050 <dyn1_setup+0x10>)
 800f044:	4903      	ldr	r1, [pc, #12]	; (800f054 <dyn1_setup+0x14>)
 800f046:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f04a:	f7f4 fb69 	bl	8003720 <chHeapObjectInit>
}
 800f04e:	bd08      	pop	{r3, pc}
 800f050:	20001428 	.word	0x20001428
 800f054:	20002070 	.word	0x20002070
 800f058:	f3af 8000 	nop.w
 800f05c:	f3af 8000 	nop.w

0800f060 <dyn1_execute>:

static void dyn1_execute(void) {
 800f060:	b500      	push	{lr}
 800f062:	b087      	sub	sp, #28
  size_t n, sz;
  void *p1;
  tprio_t prio = chThdGetPriorityX();
 800f064:	f7ff ffd4 	bl	800f010 <chThdGetPriorityX>
 800f068:	9005      	str	r0, [sp, #20]

  (void)chHeapStatus(&heap1, &sz);
 800f06a:	ab02      	add	r3, sp, #8
 800f06c:	4846      	ldr	r0, [pc, #280]	; (800f188 <dyn1_execute+0x128>)
 800f06e:	4619      	mov	r1, r3
 800f070:	f7f4 fc56 	bl	8003920 <chHeapStatus>
  /* Starting threads from the heap. */
  threads[0] = chThdCreateFromHeap(&heap1,
 800f074:	9b05      	ldr	r3, [sp, #20]
 800f076:	3b01      	subs	r3, #1
 800f078:	4a44      	ldr	r2, [pc, #272]	; (800f18c <dyn1_execute+0x12c>)
 800f07a:	9200      	str	r2, [sp, #0]
 800f07c:	4842      	ldr	r0, [pc, #264]	; (800f188 <dyn1_execute+0x128>)
 800f07e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f082:	461a      	mov	r2, r3
 800f084:	4b42      	ldr	r3, [pc, #264]	; (800f190 <dyn1_execute+0x130>)
 800f086:	f7f2 fbe3 	bl	8001850 <chThdCreateFromHeap>
 800f08a:	4602      	mov	r2, r0
 800f08c:	4b41      	ldr	r3, [pc, #260]	; (800f194 <dyn1_execute+0x134>)
 800f08e:	601a      	str	r2, [r3, #0]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-1, thread, "A");
  threads[1] = chThdCreateFromHeap(&heap1,
 800f090:	9b05      	ldr	r3, [sp, #20]
 800f092:	3b02      	subs	r3, #2
 800f094:	4a40      	ldr	r2, [pc, #256]	; (800f198 <dyn1_execute+0x138>)
 800f096:	9200      	str	r2, [sp, #0]
 800f098:	483b      	ldr	r0, [pc, #236]	; (800f188 <dyn1_execute+0x128>)
 800f09a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f09e:	461a      	mov	r2, r3
 800f0a0:	4b3b      	ldr	r3, [pc, #236]	; (800f190 <dyn1_execute+0x130>)
 800f0a2:	f7f2 fbd5 	bl	8001850 <chThdCreateFromHeap>
 800f0a6:	4602      	mov	r2, r0
 800f0a8:	4b3a      	ldr	r3, [pc, #232]	; (800f194 <dyn1_execute+0x134>)
 800f0aa:	605a      	str	r2, [r3, #4]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-2, thread, "B");
  /* Allocating the whole heap in order to make the thread creation fail.*/
  (void)chHeapStatus(&heap1, &n);
 800f0ac:	ab03      	add	r3, sp, #12
 800f0ae:	4836      	ldr	r0, [pc, #216]	; (800f188 <dyn1_execute+0x128>)
 800f0b0:	4619      	mov	r1, r3
 800f0b2:	f7f4 fc35 	bl	8003920 <chHeapStatus>
  p1 = chHeapAlloc(&heap1, n);
 800f0b6:	9b03      	ldr	r3, [sp, #12]
 800f0b8:	4833      	ldr	r0, [pc, #204]	; (800f188 <dyn1_execute+0x128>)
 800f0ba:	4619      	mov	r1, r3
 800f0bc:	f7f4 fb50 	bl	8003760 <chHeapAlloc>
 800f0c0:	9004      	str	r0, [sp, #16]
  threads[2] = chThdCreateFromHeap(&heap1,
 800f0c2:	9b05      	ldr	r3, [sp, #20]
 800f0c4:	3b03      	subs	r3, #3
 800f0c6:	4a35      	ldr	r2, [pc, #212]	; (800f19c <dyn1_execute+0x13c>)
 800f0c8:	9200      	str	r2, [sp, #0]
 800f0ca:	482f      	ldr	r0, [pc, #188]	; (800f188 <dyn1_execute+0x128>)
 800f0cc:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f0d0:	461a      	mov	r2, r3
 800f0d2:	4b2f      	ldr	r3, [pc, #188]	; (800f190 <dyn1_execute+0x130>)
 800f0d4:	f7f2 fbbc 	bl	8001850 <chThdCreateFromHeap>
 800f0d8:	4602      	mov	r2, r0
 800f0da:	4b2e      	ldr	r3, [pc, #184]	; (800f194 <dyn1_execute+0x134>)
 800f0dc:	609a      	str	r2, [r3, #8]
                                   THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                   prio-3, thread, "C");
  chHeapFree(p1);
 800f0de:	9804      	ldr	r0, [sp, #16]
 800f0e0:	f7f4 fbb6 	bl	8003850 <chHeapFree>

  test_assert(1, (threads[0] != NULL) &&
 800f0e4:	4b2b      	ldr	r3, [pc, #172]	; (800f194 <dyn1_execute+0x134>)
 800f0e6:	681b      	ldr	r3, [r3, #0]
 800f0e8:	2b00      	cmp	r3, #0
 800f0ea:	d011      	beq.n	800f110 <dyn1_execute+0xb0>
 800f0ec:	4b29      	ldr	r3, [pc, #164]	; (800f194 <dyn1_execute+0x134>)
 800f0ee:	685b      	ldr	r3, [r3, #4]
 800f0f0:	2b00      	cmp	r3, #0
 800f0f2:	d00d      	beq.n	800f110 <dyn1_execute+0xb0>
 800f0f4:	4b27      	ldr	r3, [pc, #156]	; (800f194 <dyn1_execute+0x134>)
 800f0f6:	689b      	ldr	r3, [r3, #8]
 800f0f8:	2b00      	cmp	r3, #0
 800f0fa:	d109      	bne.n	800f110 <dyn1_execute+0xb0>
 800f0fc:	4b25      	ldr	r3, [pc, #148]	; (800f194 <dyn1_execute+0x134>)
 800f0fe:	68db      	ldr	r3, [r3, #12]
 800f100:	2b00      	cmp	r3, #0
 800f102:	d105      	bne.n	800f110 <dyn1_execute+0xb0>
 800f104:	4b23      	ldr	r3, [pc, #140]	; (800f194 <dyn1_execute+0x134>)
 800f106:	691b      	ldr	r3, [r3, #16]
 800f108:	2b00      	cmp	r3, #0
 800f10a:	d101      	bne.n	800f110 <dyn1_execute+0xb0>
 800f10c:	2301      	movs	r3, #1
 800f10e:	e000      	b.n	800f112 <dyn1_execute+0xb2>
 800f110:	2300      	movs	r3, #0
 800f112:	f003 0301 	and.w	r3, r3, #1
 800f116:	b2db      	uxtb	r3, r3
 800f118:	2001      	movs	r0, #1
 800f11a:	4619      	mov	r1, r3
 800f11c:	f7fc fe98 	bl	800be50 <_test_assert>
 800f120:	4603      	mov	r3, r0
 800f122:	2b00      	cmp	r3, #0
 800f124:	d000      	beq.n	800f128 <dyn1_execute+0xc8>
 800f126:	e02b      	b.n	800f180 <dyn1_execute+0x120>
                 (threads[3] == NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f128:	f7fc ff12 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(2, "AB");
 800f12c:	2002      	movs	r0, #2
 800f12e:	491c      	ldr	r1, [pc, #112]	; (800f1a0 <dyn1_execute+0x140>)
 800f130:	f7fc fea6 	bl	800be80 <_test_assert_sequence>
 800f134:	4603      	mov	r3, r0
 800f136:	2b00      	cmp	r3, #0
 800f138:	d000      	beq.n	800f13c <dyn1_execute+0xdc>
 800f13a:	e021      	b.n	800f180 <dyn1_execute+0x120>

  /* Heap status checked again.*/
  test_assert(3, chHeapStatus(&heap1, &n) == 1, "heap fragmented");
 800f13c:	ab03      	add	r3, sp, #12
 800f13e:	4812      	ldr	r0, [pc, #72]	; (800f188 <dyn1_execute+0x128>)
 800f140:	4619      	mov	r1, r3
 800f142:	f7f4 fbed 	bl	8003920 <chHeapStatus>
 800f146:	4603      	mov	r3, r0
 800f148:	2b01      	cmp	r3, #1
 800f14a:	bf14      	ite	ne
 800f14c:	2300      	movne	r3, #0
 800f14e:	2301      	moveq	r3, #1
 800f150:	b2db      	uxtb	r3, r3
 800f152:	2003      	movs	r0, #3
 800f154:	4619      	mov	r1, r3
 800f156:	f7fc fe7b 	bl	800be50 <_test_assert>
 800f15a:	4603      	mov	r3, r0
 800f15c:	2b00      	cmp	r3, #0
 800f15e:	d000      	beq.n	800f162 <dyn1_execute+0x102>
 800f160:	e00e      	b.n	800f180 <dyn1_execute+0x120>
  test_assert(4, n == sz, "heap size changed");
 800f162:	9a03      	ldr	r2, [sp, #12]
 800f164:	9b02      	ldr	r3, [sp, #8]
 800f166:	429a      	cmp	r2, r3
 800f168:	bf14      	ite	ne
 800f16a:	2300      	movne	r3, #0
 800f16c:	2301      	moveq	r3, #1
 800f16e:	b2db      	uxtb	r3, r3
 800f170:	2004      	movs	r0, #4
 800f172:	4619      	mov	r1, r3
 800f174:	f7fc fe6c 	bl	800be50 <_test_assert>
 800f178:	4603      	mov	r3, r0
 800f17a:	2b00      	cmp	r3, #0
 800f17c:	d000      	beq.n	800f180 <dyn1_execute+0x120>
 800f17e:	bf00      	nop
}
 800f180:	b007      	add	sp, #28
 800f182:	f85d fb04 	ldr.w	pc, [sp], #4
 800f186:	bf00      	nop
 800f188:	20001428 	.word	0x20001428
 800f18c:	08019df0 	.word	0x08019df0
 800f190:	0800f021 	.word	0x0800f021
 800f194:	2000205c 	.word	0x2000205c
 800f198:	08019df4 	.word	0x08019df4
 800f19c:	08019df8 	.word	0x08019df8
 800f1a0:	08019dfc 	.word	0x08019dfc
 800f1a4:	f3af 8000 	nop.w
 800f1a8:	f3af 8000 	nop.w
 800f1ac:	f3af 8000 	nop.w

0800f1b0 <dyn2_setup>:
 * elements.<br>
 * The test expects the first four threads to successfully start and the last
 * one to fail.
 */

static void dyn2_setup(void) {
 800f1b0:	b508      	push	{r3, lr}

  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
 800f1b2:	4803      	ldr	r0, [pc, #12]	; (800f1c0 <dyn2_setup+0x10>)
 800f1b4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f1b8:	2200      	movs	r2, #0
 800f1ba:	f7f4 fc19 	bl	80039f0 <chPoolObjectInit>
}
 800f1be:	bd08      	pop	{r3, pc}
 800f1c0:	20001448 	.word	0x20001448
 800f1c4:	f3af 8000 	nop.w
 800f1c8:	f3af 8000 	nop.w
 800f1cc:	f3af 8000 	nop.w

0800f1d0 <dyn2_execute>:

static void dyn2_execute(void) {
 800f1d0:	b500      	push	{lr}
 800f1d2:	b083      	sub	sp, #12
  int i;
  tprio_t prio = chThdGetPriorityX();
 800f1d4:	f7ff ff1c 	bl	800f010 <chThdGetPriorityX>
 800f1d8:	9000      	str	r0, [sp, #0]

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f1da:	2300      	movs	r3, #0
 800f1dc:	9301      	str	r3, [sp, #4]
 800f1de:	e00a      	b.n	800f1f6 <dyn2_execute+0x26>
    chPoolFree(&mp1, wa[i]);
 800f1e0:	4b4f      	ldr	r3, [pc, #316]	; (800f320 <dyn2_execute+0x150>)
 800f1e2:	9a01      	ldr	r2, [sp, #4]
 800f1e4:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 800f1e8:	484e      	ldr	r0, [pc, #312]	; (800f324 <dyn2_execute+0x154>)
 800f1ea:	4619      	mov	r1, r3
 800f1ec:	f7f4 fc68 	bl	8003ac0 <chPoolFree>
static void dyn2_execute(void) {
  int i;
  tprio_t prio = chThdGetPriorityX();

  /* Adding the WAs to the pool. */
  for (i = 0; i < 4; i++)
 800f1f0:	9b01      	ldr	r3, [sp, #4]
 800f1f2:	3301      	adds	r3, #1
 800f1f4:	9301      	str	r3, [sp, #4]
 800f1f6:	9b01      	ldr	r3, [sp, #4]
 800f1f8:	2b03      	cmp	r3, #3
 800f1fa:	ddf1      	ble.n	800f1e0 <dyn2_execute+0x10>
    chPoolFree(&mp1, wa[i]);

  /* Starting threads from the memory pool. */
  threads[0] = chThdCreateFromMemoryPool(&mp1, prio-1, thread, "A");
 800f1fc:	9b00      	ldr	r3, [sp, #0]
 800f1fe:	3b01      	subs	r3, #1
 800f200:	4848      	ldr	r0, [pc, #288]	; (800f324 <dyn2_execute+0x154>)
 800f202:	4619      	mov	r1, r3
 800f204:	4a48      	ldr	r2, [pc, #288]	; (800f328 <dyn2_execute+0x158>)
 800f206:	4b49      	ldr	r3, [pc, #292]	; (800f32c <dyn2_execute+0x15c>)
 800f208:	f7f2 fb52 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f20c:	4602      	mov	r2, r0
 800f20e:	4b48      	ldr	r3, [pc, #288]	; (800f330 <dyn2_execute+0x160>)
 800f210:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateFromMemoryPool(&mp1, prio-2, thread, "B");
 800f212:	9b00      	ldr	r3, [sp, #0]
 800f214:	3b02      	subs	r3, #2
 800f216:	4843      	ldr	r0, [pc, #268]	; (800f324 <dyn2_execute+0x154>)
 800f218:	4619      	mov	r1, r3
 800f21a:	4a43      	ldr	r2, [pc, #268]	; (800f328 <dyn2_execute+0x158>)
 800f21c:	4b45      	ldr	r3, [pc, #276]	; (800f334 <dyn2_execute+0x164>)
 800f21e:	f7f2 fb47 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f222:	4602      	mov	r2, r0
 800f224:	4b42      	ldr	r3, [pc, #264]	; (800f330 <dyn2_execute+0x160>)
 800f226:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateFromMemoryPool(&mp1, prio-3, thread, "C");
 800f228:	9b00      	ldr	r3, [sp, #0]
 800f22a:	3b03      	subs	r3, #3
 800f22c:	483d      	ldr	r0, [pc, #244]	; (800f324 <dyn2_execute+0x154>)
 800f22e:	4619      	mov	r1, r3
 800f230:	4a3d      	ldr	r2, [pc, #244]	; (800f328 <dyn2_execute+0x158>)
 800f232:	4b41      	ldr	r3, [pc, #260]	; (800f338 <dyn2_execute+0x168>)
 800f234:	f7f2 fb3c 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f238:	4602      	mov	r2, r0
 800f23a:	4b3d      	ldr	r3, [pc, #244]	; (800f330 <dyn2_execute+0x160>)
 800f23c:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateFromMemoryPool(&mp1, prio-4, thread, "D");
 800f23e:	9b00      	ldr	r3, [sp, #0]
 800f240:	3b04      	subs	r3, #4
 800f242:	4838      	ldr	r0, [pc, #224]	; (800f324 <dyn2_execute+0x154>)
 800f244:	4619      	mov	r1, r3
 800f246:	4a38      	ldr	r2, [pc, #224]	; (800f328 <dyn2_execute+0x158>)
 800f248:	4b3c      	ldr	r3, [pc, #240]	; (800f33c <dyn2_execute+0x16c>)
 800f24a:	f7f2 fb31 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f24e:	4602      	mov	r2, r0
 800f250:	4b37      	ldr	r3, [pc, #220]	; (800f330 <dyn2_execute+0x160>)
 800f252:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateFromMemoryPool(&mp1, prio-5, thread, "E");
 800f254:	9b00      	ldr	r3, [sp, #0]
 800f256:	3b05      	subs	r3, #5
 800f258:	4832      	ldr	r0, [pc, #200]	; (800f324 <dyn2_execute+0x154>)
 800f25a:	4619      	mov	r1, r3
 800f25c:	4a32      	ldr	r2, [pc, #200]	; (800f328 <dyn2_execute+0x158>)
 800f25e:	4b38      	ldr	r3, [pc, #224]	; (800f340 <dyn2_execute+0x170>)
 800f260:	f7f2 fb26 	bl	80018b0 <chThdCreateFromMemoryPool>
 800f264:	4602      	mov	r2, r0
 800f266:	4b32      	ldr	r3, [pc, #200]	; (800f330 <dyn2_execute+0x160>)
 800f268:	611a      	str	r2, [r3, #16]

  test_assert(1, (threads[0] != NULL) &&
 800f26a:	4b31      	ldr	r3, [pc, #196]	; (800f330 <dyn2_execute+0x160>)
 800f26c:	681b      	ldr	r3, [r3, #0]
 800f26e:	2b00      	cmp	r3, #0
 800f270:	d011      	beq.n	800f296 <dyn2_execute+0xc6>
 800f272:	4b2f      	ldr	r3, [pc, #188]	; (800f330 <dyn2_execute+0x160>)
 800f274:	685b      	ldr	r3, [r3, #4]
 800f276:	2b00      	cmp	r3, #0
 800f278:	d00d      	beq.n	800f296 <dyn2_execute+0xc6>
 800f27a:	4b2d      	ldr	r3, [pc, #180]	; (800f330 <dyn2_execute+0x160>)
 800f27c:	689b      	ldr	r3, [r3, #8]
 800f27e:	2b00      	cmp	r3, #0
 800f280:	d009      	beq.n	800f296 <dyn2_execute+0xc6>
 800f282:	4b2b      	ldr	r3, [pc, #172]	; (800f330 <dyn2_execute+0x160>)
 800f284:	68db      	ldr	r3, [r3, #12]
 800f286:	2b00      	cmp	r3, #0
 800f288:	d005      	beq.n	800f296 <dyn2_execute+0xc6>
 800f28a:	4b29      	ldr	r3, [pc, #164]	; (800f330 <dyn2_execute+0x160>)
 800f28c:	691b      	ldr	r3, [r3, #16]
 800f28e:	2b00      	cmp	r3, #0
 800f290:	d101      	bne.n	800f296 <dyn2_execute+0xc6>
 800f292:	2301      	movs	r3, #1
 800f294:	e000      	b.n	800f298 <dyn2_execute+0xc8>
 800f296:	2300      	movs	r3, #0
 800f298:	f003 0301 	and.w	r3, r3, #1
 800f29c:	b2db      	uxtb	r3, r3
 800f29e:	2001      	movs	r0, #1
 800f2a0:	4619      	mov	r1, r3
 800f2a2:	f7fc fdd5 	bl	800be50 <_test_assert>
 800f2a6:	4603      	mov	r3, r0
 800f2a8:	2b00      	cmp	r3, #0
 800f2aa:	d000      	beq.n	800f2ae <dyn2_execute+0xde>
 800f2ac:	e034      	b.n	800f318 <dyn2_execute+0x148>
                 (threads[3] != NULL) &&
                 (threads[4] == NULL),
                 "thread creation failed");

  /* Claiming the memory from terminated threads. */
  test_wait_threads();
 800f2ae:	f7fc fe4f 	bl	800bf50 <test_wait_threads>
  test_assert_sequence(2, "ABCD");
 800f2b2:	2002      	movs	r0, #2
 800f2b4:	4923      	ldr	r1, [pc, #140]	; (800f344 <dyn2_execute+0x174>)
 800f2b6:	f7fc fde3 	bl	800be80 <_test_assert_sequence>
 800f2ba:	4603      	mov	r3, r0
 800f2bc:	2b00      	cmp	r3, #0
 800f2be:	d000      	beq.n	800f2c2 <dyn2_execute+0xf2>
 800f2c0:	e02a      	b.n	800f318 <dyn2_execute+0x148>

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f2c2:	2300      	movs	r3, #0
 800f2c4:	9301      	str	r3, [sp, #4]
 800f2c6:	e013      	b.n	800f2f0 <dyn2_execute+0x120>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
 800f2c8:	4816      	ldr	r0, [pc, #88]	; (800f324 <dyn2_execute+0x154>)
 800f2ca:	f7f4 fbd9 	bl	8003a80 <chPoolAlloc>
 800f2ce:	4603      	mov	r3, r0
 800f2d0:	2b00      	cmp	r3, #0
 800f2d2:	bf0c      	ite	eq
 800f2d4:	2300      	moveq	r3, #0
 800f2d6:	2301      	movne	r3, #1
 800f2d8:	b2db      	uxtb	r3, r3
 800f2da:	2003      	movs	r0, #3
 800f2dc:	4619      	mov	r1, r3
 800f2de:	f7fc fdb7 	bl	800be50 <_test_assert>
 800f2e2:	4603      	mov	r3, r0
 800f2e4:	2b00      	cmp	r3, #0
 800f2e6:	d000      	beq.n	800f2ea <dyn2_execute+0x11a>
 800f2e8:	e016      	b.n	800f318 <dyn2_execute+0x148>
  /* Claiming the memory from terminated threads. */
  test_wait_threads();
  test_assert_sequence(2, "ABCD");

  /* Now the pool must be full again. */
  for (i = 0; i < 4; i++)
 800f2ea:	9b01      	ldr	r3, [sp, #4]
 800f2ec:	3301      	adds	r3, #1
 800f2ee:	9301      	str	r3, [sp, #4]
 800f2f0:	9b01      	ldr	r3, [sp, #4]
 800f2f2:	2b03      	cmp	r3, #3
 800f2f4:	dde8      	ble.n	800f2c8 <dyn2_execute+0xf8>
    test_assert(3, chPoolAlloc(&mp1) != NULL, "pool list empty");
  test_assert(4, chPoolAlloc(&mp1) == NULL, "pool list not empty");
 800f2f6:	480b      	ldr	r0, [pc, #44]	; (800f324 <dyn2_execute+0x154>)
 800f2f8:	f7f4 fbc2 	bl	8003a80 <chPoolAlloc>
 800f2fc:	4603      	mov	r3, r0
 800f2fe:	2b00      	cmp	r3, #0
 800f300:	bf14      	ite	ne
 800f302:	2300      	movne	r3, #0
 800f304:	2301      	moveq	r3, #1
 800f306:	b2db      	uxtb	r3, r3
 800f308:	2004      	movs	r0, #4
 800f30a:	4619      	mov	r1, r3
 800f30c:	f7fc fda0 	bl	800be50 <_test_assert>
 800f310:	4603      	mov	r3, r0
 800f312:	2b00      	cmp	r3, #0
 800f314:	d000      	beq.n	800f318 <dyn2_execute+0x148>
 800f316:	bf00      	nop
}
 800f318:	b003      	add	sp, #12
 800f31a:	f85d fb04 	ldr.w	pc, [sp], #4
 800f31e:	bf00      	nop
 800f320:	08019750 	.word	0x08019750
 800f324:	20001448 	.word	0x20001448
 800f328:	0800f021 	.word	0x0800f021
 800f32c:	08019df0 	.word	0x08019df0
 800f330:	2000205c 	.word	0x2000205c
 800f334:	08019df4 	.word	0x08019df4
 800f338:	08019df8 	.word	0x08019df8
 800f33c:	08019e3c 	.word	0x08019e3c
 800f340:	08019e40 	.word	0x08019e40
 800f344:	08019e44 	.word	0x08019e44
 800f348:	f3af 8000 	nop.w
 800f34c:	f3af 8000 	nop.w

0800f350 <regfind>:
 * <h2>Description</h2>
 * Registry and Thread References APIs are tested for functionality and
 * coverage.
 */

static bool regfind(thread_t *tp) {
 800f350:	b500      	push	{lr}
 800f352:	b085      	sub	sp, #20
 800f354:	9001      	str	r0, [sp, #4]
  thread_t *ftp;
  bool found = false;
 800f356:	2300      	movs	r3, #0
 800f358:	f88d 300b 	strb.w	r3, [sp, #11]

  ftp = chRegFirstThread();
 800f35c:	f7f2 faf8 	bl	8001950 <chRegFirstThread>
 800f360:	9003      	str	r0, [sp, #12]
  do {
    found |= ftp == tp;
 800f362:	f89d 200b 	ldrb.w	r2, [sp, #11]
 800f366:	9903      	ldr	r1, [sp, #12]
 800f368:	9b01      	ldr	r3, [sp, #4]
 800f36a:	4299      	cmp	r1, r3
 800f36c:	bf14      	ite	ne
 800f36e:	2300      	movne	r3, #0
 800f370:	2301      	moveq	r3, #1
 800f372:	b2db      	uxtb	r3, r3
 800f374:	4313      	orrs	r3, r2
 800f376:	2b00      	cmp	r3, #0
 800f378:	bf0c      	ite	eq
 800f37a:	2300      	moveq	r3, #0
 800f37c:	2301      	movne	r3, #1
 800f37e:	f88d 300b 	strb.w	r3, [sp, #11]
    ftp = chRegNextThread(ftp);
 800f382:	9803      	ldr	r0, [sp, #12]
 800f384:	f7f2 fafc 	bl	8001980 <chRegNextThread>
 800f388:	9003      	str	r0, [sp, #12]
  } while (ftp != NULL);
 800f38a:	9b03      	ldr	r3, [sp, #12]
 800f38c:	2b00      	cmp	r3, #0
 800f38e:	d1e8      	bne.n	800f362 <regfind+0x12>
  return found;
 800f390:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 800f394:	4618      	mov	r0, r3
 800f396:	b005      	add	sp, #20
 800f398:	f85d fb04 	ldr.w	pc, [sp], #4
 800f39c:	f3af 8000 	nop.w

0800f3a0 <dyn3_setup>:

static void dyn3_setup(void) {
 800f3a0:	b508      	push	{r3, lr}

  chHeapObjectInit(&heap1, test.buffer, sizeof(union test_buffers));
 800f3a2:	4803      	ldr	r0, [pc, #12]	; (800f3b0 <dyn3_setup+0x10>)
 800f3a4:	4903      	ldr	r1, [pc, #12]	; (800f3b4 <dyn3_setup+0x14>)
 800f3a6:	f44f 62cd 	mov.w	r2, #1640	; 0x668
 800f3aa:	f7f4 f9b9 	bl	8003720 <chHeapObjectInit>
}
 800f3ae:	bd08      	pop	{r3, pc}
 800f3b0:	20001428 	.word	0x20001428
 800f3b4:	20002070 	.word	0x20002070
 800f3b8:	f3af 8000 	nop.w
 800f3bc:	f3af 8000 	nop.w

0800f3c0 <dyn3_execute>:

static void dyn3_execute(void) {
 800f3c0:	b500      	push	{lr}
 800f3c2:	b085      	sub	sp, #20
  thread_t *tp;
  tprio_t prio = chThdGetPriorityX();
 800f3c4:	f7ff fe24 	bl	800f010 <chThdGetPriorityX>
 800f3c8:	9003      	str	r0, [sp, #12]

  /* Testing references increase/decrease and final detach.*/
  tp = chThdCreateFromHeap(&heap1, WA_SIZE, prio-1, thread, "A");
 800f3ca:	9b03      	ldr	r3, [sp, #12]
 800f3cc:	3b01      	subs	r3, #1
 800f3ce:	4a63      	ldr	r2, [pc, #396]	; (800f55c <dyn3_execute+0x19c>)
 800f3d0:	9200      	str	r2, [sp, #0]
 800f3d2:	4863      	ldr	r0, [pc, #396]	; (800f560 <dyn3_execute+0x1a0>)
 800f3d4:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f3d8:	461a      	mov	r2, r3
 800f3da:	4b62      	ldr	r3, [pc, #392]	; (800f564 <dyn3_execute+0x1a4>)
 800f3dc:	f7f2 fa38 	bl	8001850 <chThdCreateFromHeap>
 800f3e0:	9002      	str	r0, [sp, #8]
  test_assert(1, tp->p_refs == 1, "wrong initial reference counter");
 800f3e2:	9b02      	ldr	r3, [sp, #8]
 800f3e4:	7f9b      	ldrb	r3, [r3, #30]
 800f3e6:	2b01      	cmp	r3, #1
 800f3e8:	bf14      	ite	ne
 800f3ea:	2300      	movne	r3, #0
 800f3ec:	2301      	moveq	r3, #1
 800f3ee:	b2db      	uxtb	r3, r3
 800f3f0:	2001      	movs	r0, #1
 800f3f2:	4619      	mov	r1, r3
 800f3f4:	f7fc fd2c 	bl	800be50 <_test_assert>
 800f3f8:	4603      	mov	r3, r0
 800f3fa:	2b00      	cmp	r3, #0
 800f3fc:	d000      	beq.n	800f400 <dyn3_execute+0x40>
 800f3fe:	e0a9      	b.n	800f554 <dyn3_execute+0x194>
  chThdAddRef(tp);
 800f400:	9802      	ldr	r0, [sp, #8]
 800f402:	f7f2 f9c5 	bl	8001790 <chThdAddRef>
  test_assert(2, tp->p_refs == 2, "references increase failure");
 800f406:	9b02      	ldr	r3, [sp, #8]
 800f408:	7f9b      	ldrb	r3, [r3, #30]
 800f40a:	2b02      	cmp	r3, #2
 800f40c:	bf14      	ite	ne
 800f40e:	2300      	movne	r3, #0
 800f410:	2301      	moveq	r3, #1
 800f412:	b2db      	uxtb	r3, r3
 800f414:	2002      	movs	r0, #2
 800f416:	4619      	mov	r1, r3
 800f418:	f7fc fd1a 	bl	800be50 <_test_assert>
 800f41c:	4603      	mov	r3, r0
 800f41e:	2b00      	cmp	r3, #0
 800f420:	d000      	beq.n	800f424 <dyn3_execute+0x64>
 800f422:	e097      	b.n	800f554 <dyn3_execute+0x194>
  chThdRelease(tp);
 800f424:	9802      	ldr	r0, [sp, #8]
 800f426:	f7f2 f9cb 	bl	80017c0 <chThdRelease>
  test_assert(3, tp->p_refs == 1, "references decrease failure");
 800f42a:	9b02      	ldr	r3, [sp, #8]
 800f42c:	7f9b      	ldrb	r3, [r3, #30]
 800f42e:	2b01      	cmp	r3, #1
 800f430:	bf14      	ite	ne
 800f432:	2300      	movne	r3, #0
 800f434:	2301      	moveq	r3, #1
 800f436:	b2db      	uxtb	r3, r3
 800f438:	2003      	movs	r0, #3
 800f43a:	4619      	mov	r1, r3
 800f43c:	f7fc fd08 	bl	800be50 <_test_assert>
 800f440:	4603      	mov	r3, r0
 800f442:	2b00      	cmp	r3, #0
 800f444:	d000      	beq.n	800f448 <dyn3_execute+0x88>
 800f446:	e085      	b.n	800f554 <dyn3_execute+0x194>

  /* Verify the new threads count.*/
  test_assert(4, regfind(tp), "thread missing from registry");
 800f448:	9802      	ldr	r0, [sp, #8]
 800f44a:	f7ff ff81 	bl	800f350 <regfind>
 800f44e:	4603      	mov	r3, r0
 800f450:	2004      	movs	r0, #4
 800f452:	4619      	mov	r1, r3
 800f454:	f7fc fcfc 	bl	800be50 <_test_assert>
 800f458:	4603      	mov	r3, r0
 800f45a:	2b00      	cmp	r3, #0
 800f45c:	d000      	beq.n	800f460 <dyn3_execute+0xa0>
 800f45e:	e079      	b.n	800f554 <dyn3_execute+0x194>
  test_assert(5, regfind(tp), "thread disappeared");
 800f460:	9802      	ldr	r0, [sp, #8]
 800f462:	f7ff ff75 	bl	800f350 <regfind>
 800f466:	4603      	mov	r3, r0
 800f468:	2005      	movs	r0, #5
 800f46a:	4619      	mov	r1, r3
 800f46c:	f7fc fcf0 	bl	800be50 <_test_assert>
 800f470:	4603      	mov	r3, r0
 800f472:	2b00      	cmp	r3, #0
 800f474:	d000      	beq.n	800f478 <dyn3_execute+0xb8>
 800f476:	e06d      	b.n	800f554 <dyn3_execute+0x194>

  /* Detach and let the thread execute and terminate.*/
  chThdRelease(tp);
 800f478:	9802      	ldr	r0, [sp, #8]
 800f47a:	f7f2 f9a1 	bl	80017c0 <chThdRelease>
  test_assert(6, tp->p_refs == 0, "detach failure");
 800f47e:	9b02      	ldr	r3, [sp, #8]
 800f480:	7f9b      	ldrb	r3, [r3, #30]
 800f482:	2b00      	cmp	r3, #0
 800f484:	bf14      	ite	ne
 800f486:	2300      	movne	r3, #0
 800f488:	2301      	moveq	r3, #1
 800f48a:	b2db      	uxtb	r3, r3
 800f48c:	2006      	movs	r0, #6
 800f48e:	4619      	mov	r1, r3
 800f490:	f7fc fcde 	bl	800be50 <_test_assert>
 800f494:	4603      	mov	r3, r0
 800f496:	2b00      	cmp	r3, #0
 800f498:	d000      	beq.n	800f49c <dyn3_execute+0xdc>
 800f49a:	e05b      	b.n	800f554 <dyn3_execute+0x194>
  test_assert(7, tp->p_state == CH_STATE_READY, "invalid state");
 800f49c:	9b02      	ldr	r3, [sp, #8]
 800f49e:	7f1b      	ldrb	r3, [r3, #28]
 800f4a0:	2b00      	cmp	r3, #0
 800f4a2:	bf14      	ite	ne
 800f4a4:	2300      	movne	r3, #0
 800f4a6:	2301      	moveq	r3, #1
 800f4a8:	b2db      	uxtb	r3, r3
 800f4aa:	2007      	movs	r0, #7
 800f4ac:	4619      	mov	r1, r3
 800f4ae:	f7fc fccf 	bl	800be50 <_test_assert>
 800f4b2:	4603      	mov	r3, r0
 800f4b4:	2b00      	cmp	r3, #0
 800f4b6:	d000      	beq.n	800f4ba <dyn3_execute+0xfa>
 800f4b8:	e04c      	b.n	800f554 <dyn3_execute+0x194>
  test_assert(8, regfind(tp), "thread disappeared");
 800f4ba:	9802      	ldr	r0, [sp, #8]
 800f4bc:	f7ff ff48 	bl	800f350 <regfind>
 800f4c0:	4603      	mov	r3, r0
 800f4c2:	2008      	movs	r0, #8
 800f4c4:	4619      	mov	r1, r3
 800f4c6:	f7fc fcc3 	bl	800be50 <_test_assert>
 800f4ca:	4603      	mov	r3, r0
 800f4cc:	2b00      	cmp	r3, #0
 800f4ce:	d000      	beq.n	800f4d2 <dyn3_execute+0x112>
 800f4d0:	e040      	b.n	800f554 <dyn3_execute+0x194>
  test_assert(9, regfind(tp), "thread disappeared");
 800f4d2:	9802      	ldr	r0, [sp, #8]
 800f4d4:	f7ff ff3c 	bl	800f350 <regfind>
 800f4d8:	4603      	mov	r3, r0
 800f4da:	2009      	movs	r0, #9
 800f4dc:	4619      	mov	r1, r3
 800f4de:	f7fc fcb7 	bl	800be50 <_test_assert>
 800f4e2:	4603      	mov	r3, r0
 800f4e4:	2b00      	cmp	r3, #0
 800f4e6:	d000      	beq.n	800f4ea <dyn3_execute+0x12a>
 800f4e8:	e034      	b.n	800f554 <dyn3_execute+0x194>
  chThdSleepMilliseconds(50);           /* The thread just terminates.      */
 800f4ea:	2032      	movs	r0, #50	; 0x32
 800f4ec:	f7f1 fef0 	bl	80012d0 <chThdSleep>
  test_assert(10, tp->p_state == CH_STATE_FINAL, "invalid state");
 800f4f0:	9b02      	ldr	r3, [sp, #8]
 800f4f2:	7f1b      	ldrb	r3, [r3, #28]
 800f4f4:	2b0f      	cmp	r3, #15
 800f4f6:	bf14      	ite	ne
 800f4f8:	2300      	movne	r3, #0
 800f4fa:	2301      	moveq	r3, #1
 800f4fc:	b2db      	uxtb	r3, r3
 800f4fe:	200a      	movs	r0, #10
 800f500:	4619      	mov	r1, r3
 800f502:	f7fc fca5 	bl	800be50 <_test_assert>
 800f506:	4603      	mov	r3, r0
 800f508:	2b00      	cmp	r3, #0
 800f50a:	d000      	beq.n	800f50e <dyn3_execute+0x14e>
 800f50c:	e022      	b.n	800f554 <dyn3_execute+0x194>

  /* Clearing the zombie by scanning the registry.*/
  test_assert(11, regfind(tp), "thread disappeared");
 800f50e:	9802      	ldr	r0, [sp, #8]
 800f510:	f7ff ff1e 	bl	800f350 <regfind>
 800f514:	4603      	mov	r3, r0
 800f516:	200b      	movs	r0, #11
 800f518:	4619      	mov	r1, r3
 800f51a:	f7fc fc99 	bl	800be50 <_test_assert>
 800f51e:	4603      	mov	r3, r0
 800f520:	2b00      	cmp	r3, #0
 800f522:	d000      	beq.n	800f526 <dyn3_execute+0x166>
 800f524:	e016      	b.n	800f554 <dyn3_execute+0x194>
  test_assert(12, !regfind(tp), "thread still in registry");
 800f526:	9802      	ldr	r0, [sp, #8]
 800f528:	f7ff ff12 	bl	800f350 <regfind>
 800f52c:	4603      	mov	r3, r0
 800f52e:	2b00      	cmp	r3, #0
 800f530:	bf0c      	ite	eq
 800f532:	2300      	moveq	r3, #0
 800f534:	2301      	movne	r3, #1
 800f536:	b2db      	uxtb	r3, r3
 800f538:	f083 0301 	eor.w	r3, r3, #1
 800f53c:	b2db      	uxtb	r3, r3
 800f53e:	f003 0301 	and.w	r3, r3, #1
 800f542:	b2db      	uxtb	r3, r3
 800f544:	200c      	movs	r0, #12
 800f546:	4619      	mov	r1, r3
 800f548:	f7fc fc82 	bl	800be50 <_test_assert>
 800f54c:	4603      	mov	r3, r0
 800f54e:	2b00      	cmp	r3, #0
 800f550:	d000      	beq.n	800f554 <dyn3_execute+0x194>
 800f552:	bf00      	nop
}
 800f554:	b005      	add	sp, #20
 800f556:	f85d fb04 	ldr.w	pc, [sp], #4
 800f55a:	bf00      	nop
 800f55c:	08019df0 	.word	0x08019df0
 800f560:	20001428 	.word	0x20001428
 800f564:	0800f021 	.word	0x0800f021
 800f568:	f3af 8000 	nop.w
 800f56c:	f3af 8000 	nop.w

0800f570 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800f570:	b082      	sub	sp, #8
 800f572:	2320      	movs	r3, #32
 800f574:	9301      	str	r3, [sp, #4]
 800f576:	9b01      	ldr	r3, [sp, #4]
 800f578:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f57c:	b002      	add	sp, #8
 800f57e:	4770      	bx	lr

0800f580 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800f580:	b082      	sub	sp, #8
 800f582:	2300      	movs	r3, #0
 800f584:	9301      	str	r3, [sp, #4]
 800f586:	9b01      	ldr	r3, [sp, #4]
 800f588:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800f58c:	b002      	add	sp, #8
 800f58e:	4770      	bx	lr

0800f590 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800f590:	b508      	push	{r3, lr}

  port_lock();
 800f592:	f7ff ffed 	bl	800f570 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800f596:	bd08      	pop	{r3, pc}
 800f598:	f3af 8000 	nop.w
 800f59c:	f3af 8000 	nop.w

0800f5a0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800f5a0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800f5a2:	f7ff ffed 	bl	800f580 <port_unlock>
}
 800f5a6:	bd08      	pop	{r3, pc}
 800f5a8:	f3af 8000 	nop.w
 800f5ac:	f3af 8000 	nop.w

0800f5b0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 800f5b0:	4b01      	ldr	r3, [pc, #4]	; (800f5b8 <chThdGetSelfX+0x8>)
 800f5b2:	699b      	ldr	r3, [r3, #24]
}
 800f5b4:	4618      	mov	r0, r3
 800f5b6:	4770      	bx	lr
 800f5b8:	20001bc8 	.word	0x20001bc8
 800f5bc:	f3af 8000 	nop.w

0800f5c0 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 800f5c0:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 800f5c2:	f7ff fff5 	bl	800f5b0 <chThdGetSelfX>
 800f5c6:	4603      	mov	r3, r0
 800f5c8:	689b      	ldr	r3, [r3, #8]
}
 800f5ca:	4618      	mov	r0, r3
 800f5cc:	bd08      	pop	{r3, pc}
 800f5ce:	bf00      	nop

0800f5d0 <chIQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chIQGetFullI(input_queue_t *iqp) {
 800f5d0:	b082      	sub	sp, #8
 800f5d2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)chQSpaceI(iqp);
 800f5d4:	9b01      	ldr	r3, [sp, #4]
 800f5d6:	689b      	ldr	r3, [r3, #8]
}
 800f5d8:	4618      	mov	r0, r3
 800f5da:	b002      	add	sp, #8
 800f5dc:	4770      	bx	lr
 800f5de:	bf00      	nop

0800f5e0 <chIQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {
 800f5e0:	b082      	sub	sp, #8
 800f5e2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 800f5e4:	9b01      	ldr	r3, [sp, #4]
 800f5e6:	689b      	ldr	r3, [r3, #8]
 800f5e8:	2b00      	cmp	r3, #0
 800f5ea:	bf14      	ite	ne
 800f5ec:	2300      	movne	r3, #0
 800f5ee:	2301      	moveq	r3, #1
 800f5f0:	b2db      	uxtb	r3, r3
}
 800f5f2:	4618      	mov	r0, r3
 800f5f4:	b002      	add	sp, #8
 800f5f6:	4770      	bx	lr
 800f5f8:	f3af 8000 	nop.w
 800f5fc:	f3af 8000 	nop.w

0800f600 <chIQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {
 800f600:	b082      	sub	sp, #8
 800f602:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800f604:	9b01      	ldr	r3, [sp, #4]
 800f606:	695a      	ldr	r2, [r3, #20]
 800f608:	9b01      	ldr	r3, [sp, #4]
 800f60a:	699b      	ldr	r3, [r3, #24]
 800f60c:	429a      	cmp	r2, r3
 800f60e:	d105      	bne.n	800f61c <chIQIsFullI+0x1c>
 800f610:	9b01      	ldr	r3, [sp, #4]
 800f612:	689b      	ldr	r3, [r3, #8]
 800f614:	2b00      	cmp	r3, #0
 800f616:	d001      	beq.n	800f61c <chIQIsFullI+0x1c>
 800f618:	2301      	movs	r3, #1
 800f61a:	e000      	b.n	800f61e <chIQIsFullI+0x1e>
 800f61c:	2300      	movs	r3, #0
 800f61e:	f003 0301 	and.w	r3, r3, #1
 800f622:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f624:	4618      	mov	r0, r3
 800f626:	b002      	add	sp, #8
 800f628:	4770      	bx	lr
 800f62a:	bf00      	nop
 800f62c:	f3af 8000 	nop.w

0800f630 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 800f630:	b500      	push	{lr}
 800f632:	b083      	sub	sp, #12
 800f634:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 800f636:	9801      	ldr	r0, [sp, #4]
 800f638:	f04f 31ff 	mov.w	r1, #4294967295
 800f63c:	f7f3 fe20 	bl	8003280 <chIQGetTimeout>
 800f640:	4603      	mov	r3, r0
}
 800f642:	4618      	mov	r0, r3
 800f644:	b003      	add	sp, #12
 800f646:	f85d fb04 	ldr.w	pc, [sp], #4
 800f64a:	bf00      	nop
 800f64c:	f3af 8000 	nop.w

0800f650 <chOQGetFullI>:
 * @return              The number of full bytes in the queue.
 * @retval 0            if the queue is empty.
 *
 * @iclass
 */
static inline size_t chOQGetFullI(output_queue_t *oqp) {
 800f650:	b082      	sub	sp, #8
 800f652:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (size_t)(chQSizeX(oqp) - chQSpaceI(oqp));
 800f654:	9b01      	ldr	r3, [sp, #4]
 800f656:	691b      	ldr	r3, [r3, #16]
 800f658:	461a      	mov	r2, r3
 800f65a:	9b01      	ldr	r3, [sp, #4]
 800f65c:	68db      	ldr	r3, [r3, #12]
 800f65e:	1ad3      	subs	r3, r2, r3
 800f660:	461a      	mov	r2, r3
 800f662:	9b01      	ldr	r3, [sp, #4]
 800f664:	689b      	ldr	r3, [r3, #8]
 800f666:	1ad3      	subs	r3, r2, r3
}
 800f668:	4618      	mov	r0, r3
 800f66a:	b002      	add	sp, #8
 800f66c:	4770      	bx	lr
 800f66e:	bf00      	nop

0800f670 <chOQIsEmptyI>:
 * @retval false        if the queue is not empty.
 * @retval true         if the queue is empty.
 *
 * @iclass
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {
 800f670:	b082      	sub	sp, #8
 800f672:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  /*lint -save -e9007 [13.5] No side effects.*/
  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 800f674:	9b01      	ldr	r3, [sp, #4]
 800f676:	695a      	ldr	r2, [r3, #20]
 800f678:	9b01      	ldr	r3, [sp, #4]
 800f67a:	699b      	ldr	r3, [r3, #24]
 800f67c:	429a      	cmp	r2, r3
 800f67e:	d105      	bne.n	800f68c <chOQIsEmptyI+0x1c>
 800f680:	9b01      	ldr	r3, [sp, #4]
 800f682:	689b      	ldr	r3, [r3, #8]
 800f684:	2b00      	cmp	r3, #0
 800f686:	d001      	beq.n	800f68c <chOQIsEmptyI+0x1c>
 800f688:	2301      	movs	r3, #1
 800f68a:	e000      	b.n	800f68e <chOQIsEmptyI+0x1e>
 800f68c:	2300      	movs	r3, #0
 800f68e:	f003 0301 	and.w	r3, r3, #1
 800f692:	b2db      	uxtb	r3, r3
  /*lint -restore*/
}
 800f694:	4618      	mov	r0, r3
 800f696:	b002      	add	sp, #8
 800f698:	4770      	bx	lr
 800f69a:	bf00      	nop
 800f69c:	f3af 8000 	nop.w

0800f6a0 <chOQIsFullI>:
 * @retval false        if the queue is not full.
 * @retval true         if the queue is full.
 *
 * @iclass
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {
 800f6a0:	b082      	sub	sp, #8
 800f6a2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 800f6a4:	9b01      	ldr	r3, [sp, #4]
 800f6a6:	689b      	ldr	r3, [r3, #8]
 800f6a8:	2b00      	cmp	r3, #0
 800f6aa:	bf14      	ite	ne
 800f6ac:	2300      	movne	r3, #0
 800f6ae:	2301      	moveq	r3, #1
 800f6b0:	b2db      	uxtb	r3, r3
}
 800f6b2:	4618      	mov	r0, r3
 800f6b4:	b002      	add	sp, #8
 800f6b6:	4770      	bx	lr
 800f6b8:	f3af 8000 	nop.w
 800f6bc:	f3af 8000 	nop.w

0800f6c0 <chOQPut>:
 * @retval Q_OK         if the operation succeeded.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chOQPut(output_queue_t *oqp, uint8_t b) {
 800f6c0:	b500      	push	{lr}
 800f6c2:	b083      	sub	sp, #12
 800f6c4:	9001      	str	r0, [sp, #4]
 800f6c6:	460b      	mov	r3, r1
 800f6c8:	f88d 3003 	strb.w	r3, [sp, #3]

  return chOQPutTimeout(oqp, b, TIME_INFINITE);
 800f6cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 800f6d0:	9801      	ldr	r0, [sp, #4]
 800f6d2:	4619      	mov	r1, r3
 800f6d4:	f04f 32ff 	mov.w	r2, #4294967295
 800f6d8:	f7f3 feba 	bl	8003450 <chOQPutTimeout>
 800f6dc:	4603      	mov	r3, r0
}
 800f6de:	4618      	mov	r0, r3
 800f6e0:	b003      	add	sp, #12
 800f6e2:	f85d fb04 	ldr.w	pc, [sp], #4
 800f6e6:	bf00      	nop
 800f6e8:	f3af 8000 	nop.w
 800f6ec:	f3af 8000 	nop.w

0800f6f0 <notify>:

#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)

#define TEST_QUEUES_SIZE 4

static void notify(io_queue_t *qp) {
 800f6f0:	b082      	sub	sp, #8
 800f6f2:	9001      	str	r0, [sp, #4]
  (void)qp;
}
 800f6f4:	b002      	add	sp, #8
 800f6f6:	4770      	bx	lr
 800f6f8:	f3af 8000 	nop.w
 800f6fc:	f3af 8000 	nop.w

0800f700 <queues1_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p InputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues1_setup(void) {
 800f700:	b500      	push	{lr}
 800f702:	b083      	sub	sp, #12

  chIQObjectInit(&iq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800f704:	4b06      	ldr	r3, [pc, #24]	; (800f720 <queues1_setup+0x20>)
 800f706:	681b      	ldr	r3, [r3, #0]
 800f708:	2200      	movs	r2, #0
 800f70a:	9200      	str	r2, [sp, #0]
 800f70c:	4805      	ldr	r0, [pc, #20]	; (800f724 <queues1_setup+0x24>)
 800f70e:	4619      	mov	r1, r3
 800f710:	2204      	movs	r2, #4
 800f712:	4b05      	ldr	r3, [pc, #20]	; (800f728 <queues1_setup+0x28>)
 800f714:	f7f3 fd44 	bl	80031a0 <chIQObjectInit>
}
 800f718:	b003      	add	sp, #12
 800f71a:	f85d fb04 	ldr.w	pc, [sp], #4
 800f71e:	bf00      	nop
 800f720:	08019750 	.word	0x08019750
 800f724:	200008a8 	.word	0x200008a8
 800f728:	0800f6f1 	.word	0x0800f6f1
 800f72c:	f3af 8000 	nop.w

0800f730 <thread1>:

static THD_FUNCTION(thread1, p) {
 800f730:	b500      	push	{lr}
 800f732:	b083      	sub	sp, #12
 800f734:	9001      	str	r0, [sp, #4]

  (void)p;
  chIQGetTimeout(&iq, MS2ST(200));
 800f736:	4803      	ldr	r0, [pc, #12]	; (800f744 <thread1+0x14>)
 800f738:	21c8      	movs	r1, #200	; 0xc8
 800f73a:	f7f3 fda1 	bl	8003280 <chIQGetTimeout>
}
 800f73e:	b003      	add	sp, #12
 800f740:	f85d fb04 	ldr.w	pc, [sp], #4
 800f744:	200008a8 	.word	0x200008a8
 800f748:	f3af 8000 	nop.w
 800f74c:	f3af 8000 	nop.w

0800f750 <queues1_execute>:

static void queues1_execute(void) {
 800f750:	b510      	push	{r4, lr}
 800f752:	b084      	sub	sp, #16
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");
 800f754:	f7ff ff1c 	bl	800f590 <chSysLock>
 800f758:	48ab      	ldr	r0, [pc, #684]	; (800fa08 <queues1_execute+0x2b8>)
 800f75a:	f7ff ff41 	bl	800f5e0 <chIQIsEmptyI>
 800f75e:	4603      	mov	r3, r0
 800f760:	2001      	movs	r0, #1
 800f762:	4619      	mov	r1, r3
 800f764:	f7fc fb74 	bl	800be50 <_test_assert>
 800f768:	4603      	mov	r3, r0
 800f76a:	2b00      	cmp	r3, #0
 800f76c:	d002      	beq.n	800f774 <queues1_execute+0x24>
 800f76e:	f7ff ff17 	bl	800f5a0 <chSysUnlock>
 800f772:	e16a      	b.n	800fa4a <queues1_execute+0x2fa>
 800f774:	f7ff ff14 	bl	800f5a0 <chSysUnlock>

  /* Queue filling */
  chSysLock();
 800f778:	f7ff ff0a 	bl	800f590 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f77c:	2300      	movs	r3, #0
 800f77e:	9303      	str	r3, [sp, #12]
 800f780:	e00a      	b.n	800f798 <queues1_execute+0x48>
    chIQPutI(&iq, 'A' + i);
 800f782:	9b03      	ldr	r3, [sp, #12]
 800f784:	b2db      	uxtb	r3, r3
 800f786:	3341      	adds	r3, #65	; 0x41
 800f788:	b2db      	uxtb	r3, r3
 800f78a:	489f      	ldr	r0, [pc, #636]	; (800fa08 <queues1_execute+0x2b8>)
 800f78c:	4619      	mov	r1, r3
 800f78e:	f7f3 fd47 	bl	8003220 <chIQPutI>
  /* Initial empty state */
  test_assert_lock(1, chIQIsEmptyI(&iq), "not empty");

  /* Queue filling */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f792:	9b03      	ldr	r3, [sp, #12]
 800f794:	3301      	adds	r3, #1
 800f796:	9303      	str	r3, [sp, #12]
 800f798:	9b03      	ldr	r3, [sp, #12]
 800f79a:	2b03      	cmp	r3, #3
 800f79c:	d9f1      	bls.n	800f782 <queues1_execute+0x32>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f79e:	f7ff feff 	bl	800f5a0 <chSysUnlock>
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
 800f7a2:	f7ff fef5 	bl	800f590 <chSysLock>
 800f7a6:	4898      	ldr	r0, [pc, #608]	; (800fa08 <queues1_execute+0x2b8>)
 800f7a8:	f7ff ff2a 	bl	800f600 <chIQIsFullI>
 800f7ac:	4603      	mov	r3, r0
 800f7ae:	2002      	movs	r0, #2
 800f7b0:	4619      	mov	r1, r3
 800f7b2:	f7fc fb4d 	bl	800be50 <_test_assert>
 800f7b6:	4603      	mov	r3, r0
 800f7b8:	2b00      	cmp	r3, #0
 800f7ba:	d002      	beq.n	800f7c2 <queues1_execute+0x72>
 800f7bc:	f7ff fef0 	bl	800f5a0 <chSysUnlock>
 800f7c0:	e143      	b.n	800fa4a <queues1_execute+0x2fa>
 800f7c2:	f7ff feed 	bl	800f5a0 <chSysUnlock>
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");
 800f7c6:	f7ff fee3 	bl	800f590 <chSysLock>
 800f7ca:	488f      	ldr	r0, [pc, #572]	; (800fa08 <queues1_execute+0x2b8>)
 800f7cc:	2100      	movs	r1, #0
 800f7ce:	f7f3 fd27 	bl	8003220 <chIQPutI>
 800f7d2:	4603      	mov	r3, r0
 800f7d4:	f113 0f04 	cmn.w	r3, #4
 800f7d8:	bf14      	ite	ne
 800f7da:	2300      	movne	r3, #0
 800f7dc:	2301      	moveq	r3, #1
 800f7de:	b2db      	uxtb	r3, r3
 800f7e0:	2003      	movs	r0, #3
 800f7e2:	4619      	mov	r1, r3
 800f7e4:	f7fc fb34 	bl	800be50 <_test_assert>
 800f7e8:	4603      	mov	r3, r0
 800f7ea:	2b00      	cmp	r3, #0
 800f7ec:	d002      	beq.n	800f7f4 <queues1_execute+0xa4>
 800f7ee:	f7ff fed7 	bl	800f5a0 <chSysUnlock>
 800f7f2:	e12a      	b.n	800fa4a <queues1_execute+0x2fa>
 800f7f4:	f7ff fed4 	bl	800f5a0 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f7f8:	2300      	movs	r3, #0
 800f7fa:	9303      	str	r3, [sp, #12]
 800f7fc:	e00a      	b.n	800f814 <queues1_execute+0xc4>
    test_emit_token(chIQGet(&iq));
 800f7fe:	4882      	ldr	r0, [pc, #520]	; (800fa08 <queues1_execute+0x2b8>)
 800f800:	f7ff ff16 	bl	800f630 <chIQGet>
 800f804:	4603      	mov	r3, r0
 800f806:	b2db      	uxtb	r3, r3
 800f808:	4618      	mov	r0, r3
 800f80a:	f7fc faf1 	bl	800bdf0 <test_emit_token>
  chSysUnlock();
  test_assert_lock(2, chIQIsFullI(&iq), "still has space");
  test_assert_lock(3, chIQPutI(&iq, 0) == Q_FULL, "failed to report Q_FULL");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f80e:	9b03      	ldr	r3, [sp, #12]
 800f810:	3301      	adds	r3, #1
 800f812:	9303      	str	r3, [sp, #12]
 800f814:	9b03      	ldr	r3, [sp, #12]
 800f816:	2b03      	cmp	r3, #3
 800f818:	d9f1      	bls.n	800f7fe <queues1_execute+0xae>
    test_emit_token(chIQGet(&iq));
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
 800f81a:	f7ff feb9 	bl	800f590 <chSysLock>
 800f81e:	487a      	ldr	r0, [pc, #488]	; (800fa08 <queues1_execute+0x2b8>)
 800f820:	f7ff fede 	bl	800f5e0 <chIQIsEmptyI>
 800f824:	4603      	mov	r3, r0
 800f826:	2004      	movs	r0, #4
 800f828:	4619      	mov	r1, r3
 800f82a:	f7fc fb11 	bl	800be50 <_test_assert>
 800f82e:	4603      	mov	r3, r0
 800f830:	2b00      	cmp	r3, #0
 800f832:	d002      	beq.n	800f83a <queues1_execute+0xea>
 800f834:	f7ff feb4 	bl	800f5a0 <chSysUnlock>
 800f838:	e107      	b.n	800fa4a <queues1_execute+0x2fa>
 800f83a:	f7ff feb1 	bl	800f5a0 <chSysUnlock>
  test_assert_sequence(5, "ABCD");
 800f83e:	2005      	movs	r0, #5
 800f840:	4972      	ldr	r1, [pc, #456]	; (800fa0c <queues1_execute+0x2bc>)
 800f842:	f7fc fb1d 	bl	800be80 <_test_assert_sequence>
 800f846:	4603      	mov	r3, r0
 800f848:	2b00      	cmp	r3, #0
 800f84a:	d000      	beq.n	800f84e <queues1_execute+0xfe>
 800f84c:	e0fd      	b.n	800fa4a <queues1_execute+0x2fa>

  /* Queue filling again */
  chSysLock();
 800f84e:	f7ff fe9f 	bl	800f590 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f852:	2300      	movs	r3, #0
 800f854:	9303      	str	r3, [sp, #12]
 800f856:	e00a      	b.n	800f86e <queues1_execute+0x11e>
    chIQPutI(&iq, 'A' + i);
 800f858:	9b03      	ldr	r3, [sp, #12]
 800f85a:	b2db      	uxtb	r3, r3
 800f85c:	3341      	adds	r3, #65	; 0x41
 800f85e:	b2db      	uxtb	r3, r3
 800f860:	4869      	ldr	r0, [pc, #420]	; (800fa08 <queues1_execute+0x2b8>)
 800f862:	4619      	mov	r1, r3
 800f864:	f7f3 fcdc 	bl	8003220 <chIQPutI>
  test_assert_lock(4, chIQIsEmptyI(&iq), "still full");
  test_assert_sequence(5, "ABCD");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f868:	9b03      	ldr	r3, [sp, #12]
 800f86a:	3301      	adds	r3, #1
 800f86c:	9303      	str	r3, [sp, #12]
 800f86e:	9b03      	ldr	r3, [sp, #12]
 800f870:	2b03      	cmp	r3, #3
 800f872:	d9f1      	bls.n	800f858 <queues1_execute+0x108>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f874:	f7ff fe94 	bl	800f5a0 <chSysUnlock>

  /* Reading the whole thing */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800f878:	4b65      	ldr	r3, [pc, #404]	; (800fa10 <queues1_execute+0x2c0>)
 800f87a:	685b      	ldr	r3, [r3, #4]
 800f87c:	4862      	ldr	r0, [pc, #392]	; (800fa08 <queues1_execute+0x2b8>)
 800f87e:	4619      	mov	r1, r3
 800f880:	2208      	movs	r2, #8
 800f882:	2300      	movs	r3, #0
 800f884:	f7f3 fd44 	bl	8003310 <chIQReadTimeout>
 800f888:	9002      	str	r0, [sp, #8]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800f88a:	9b02      	ldr	r3, [sp, #8]
 800f88c:	2b04      	cmp	r3, #4
 800f88e:	bf14      	ite	ne
 800f890:	2300      	movne	r3, #0
 800f892:	2301      	moveq	r3, #1
 800f894:	b2db      	uxtb	r3, r3
 800f896:	2006      	movs	r0, #6
 800f898:	4619      	mov	r1, r3
 800f89a:	f7fc fad9 	bl	800be50 <_test_assert>
 800f89e:	4603      	mov	r3, r0
 800f8a0:	2b00      	cmp	r3, #0
 800f8a2:	d000      	beq.n	800f8a6 <queues1_execute+0x156>
 800f8a4:	e0d1      	b.n	800fa4a <queues1_execute+0x2fa>
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");
 800f8a6:	f7ff fe73 	bl	800f590 <chSysLock>
 800f8aa:	4857      	ldr	r0, [pc, #348]	; (800fa08 <queues1_execute+0x2b8>)
 800f8ac:	f7ff fe98 	bl	800f5e0 <chIQIsEmptyI>
 800f8b0:	4603      	mov	r3, r0
 800f8b2:	2007      	movs	r0, #7
 800f8b4:	4619      	mov	r1, r3
 800f8b6:	f7fc facb 	bl	800be50 <_test_assert>
 800f8ba:	4603      	mov	r3, r0
 800f8bc:	2b00      	cmp	r3, #0
 800f8be:	d002      	beq.n	800f8c6 <queues1_execute+0x176>
 800f8c0:	f7ff fe6e 	bl	800f5a0 <chSysUnlock>
 800f8c4:	e0c1      	b.n	800fa4a <queues1_execute+0x2fa>
 800f8c6:	f7ff fe6b 	bl	800f5a0 <chSysUnlock>

  /* Queue filling again */
  chSysLock();
 800f8ca:	f7ff fe61 	bl	800f590 <chSysLock>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f8ce:	2300      	movs	r3, #0
 800f8d0:	9303      	str	r3, [sp, #12]
 800f8d2:	e00a      	b.n	800f8ea <queues1_execute+0x19a>
    chIQPutI(&iq, 'A' + i);
 800f8d4:	9b03      	ldr	r3, [sp, #12]
 800f8d6:	b2db      	uxtb	r3, r3
 800f8d8:	3341      	adds	r3, #65	; 0x41
 800f8da:	b2db      	uxtb	r3, r3
 800f8dc:	484a      	ldr	r0, [pc, #296]	; (800fa08 <queues1_execute+0x2b8>)
 800f8de:	4619      	mov	r1, r3
 800f8e0:	f7f3 fc9e 	bl	8003220 <chIQPutI>
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
  test_assert_lock(7, chIQIsEmptyI(&iq), "still full");

  /* Queue filling again */
  chSysLock();
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800f8e4:	9b03      	ldr	r3, [sp, #12]
 800f8e6:	3301      	adds	r3, #1
 800f8e8:	9303      	str	r3, [sp, #12]
 800f8ea:	9b03      	ldr	r3, [sp, #12]
 800f8ec:	2b03      	cmp	r3, #3
 800f8ee:	d9f1      	bls.n	800f8d4 <queues1_execute+0x184>
    chIQPutI(&iq, 'A' + i);
  chSysUnlock();
 800f8f0:	f7ff fe56 	bl	800f5a0 <chSysUnlock>

  /* Partial reads */
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f8f4:	4b46      	ldr	r3, [pc, #280]	; (800fa10 <queues1_execute+0x2c0>)
 800f8f6:	685b      	ldr	r3, [r3, #4]
 800f8f8:	4843      	ldr	r0, [pc, #268]	; (800fa08 <queues1_execute+0x2b8>)
 800f8fa:	4619      	mov	r1, r3
 800f8fc:	2202      	movs	r2, #2
 800f8fe:	2300      	movs	r3, #0
 800f900:	f7f3 fd06 	bl	8003310 <chIQReadTimeout>
 800f904:	9002      	str	r0, [sp, #8]
  test_assert(8, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f906:	9b02      	ldr	r3, [sp, #8]
 800f908:	2b02      	cmp	r3, #2
 800f90a:	bf14      	ite	ne
 800f90c:	2300      	movne	r3, #0
 800f90e:	2301      	moveq	r3, #1
 800f910:	b2db      	uxtb	r3, r3
 800f912:	2008      	movs	r0, #8
 800f914:	4619      	mov	r1, r3
 800f916:	f7fc fa9b 	bl	800be50 <_test_assert>
 800f91a:	4603      	mov	r3, r0
 800f91c:	2b00      	cmp	r3, #0
 800f91e:	d000      	beq.n	800f922 <queues1_execute+0x1d2>
 800f920:	e093      	b.n	800fa4a <queues1_execute+0x2fa>
  n = chIQReadTimeout(&iq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800f922:	4b3b      	ldr	r3, [pc, #236]	; (800fa10 <queues1_execute+0x2c0>)
 800f924:	685b      	ldr	r3, [r3, #4]
 800f926:	4838      	ldr	r0, [pc, #224]	; (800fa08 <queues1_execute+0x2b8>)
 800f928:	4619      	mov	r1, r3
 800f92a:	2202      	movs	r2, #2
 800f92c:	2300      	movs	r3, #0
 800f92e:	f7f3 fcef 	bl	8003310 <chIQReadTimeout>
 800f932:	9002      	str	r0, [sp, #8]
  test_assert(9, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800f934:	9b02      	ldr	r3, [sp, #8]
 800f936:	2b02      	cmp	r3, #2
 800f938:	bf14      	ite	ne
 800f93a:	2300      	movne	r3, #0
 800f93c:	2301      	moveq	r3, #1
 800f93e:	b2db      	uxtb	r3, r3
 800f940:	2009      	movs	r0, #9
 800f942:	4619      	mov	r1, r3
 800f944:	f7fc fa84 	bl	800be50 <_test_assert>
 800f948:	4603      	mov	r3, r0
 800f94a:	2b00      	cmp	r3, #0
 800f94c:	d000      	beq.n	800f950 <queues1_execute+0x200>
 800f94e:	e07c      	b.n	800fa4a <queues1_execute+0x2fa>
  test_assert_lock(10, chIQIsEmptyI(&iq), "still full");
 800f950:	f7ff fe1e 	bl	800f590 <chSysLock>
 800f954:	482c      	ldr	r0, [pc, #176]	; (800fa08 <queues1_execute+0x2b8>)
 800f956:	f7ff fe43 	bl	800f5e0 <chIQIsEmptyI>
 800f95a:	4603      	mov	r3, r0
 800f95c:	200a      	movs	r0, #10
 800f95e:	4619      	mov	r1, r3
 800f960:	f7fc fa76 	bl	800be50 <_test_assert>
 800f964:	4603      	mov	r3, r0
 800f966:	2b00      	cmp	r3, #0
 800f968:	d002      	beq.n	800f970 <queues1_execute+0x220>
 800f96a:	f7ff fe19 	bl	800f5a0 <chSysUnlock>
 800f96e:	e06c      	b.n	800fa4a <queues1_execute+0x2fa>
 800f970:	f7ff fe16 	bl	800f5a0 <chSysUnlock>

  /* Testing reset */
  chSysLock();
 800f974:	f7ff fe0c 	bl	800f590 <chSysLock>
  chIQPutI(&iq, 0);
 800f978:	4823      	ldr	r0, [pc, #140]	; (800fa08 <queues1_execute+0x2b8>)
 800f97a:	2100      	movs	r1, #0
 800f97c:	f7f3 fc50 	bl	8003220 <chIQPutI>
  chIQResetI(&iq);
 800f980:	4821      	ldr	r0, [pc, #132]	; (800fa08 <queues1_execute+0x2b8>)
 800f982:	f7f3 fc35 	bl	80031f0 <chIQResetI>
  chSysUnlock();
 800f986:	f7ff fe0b 	bl	800f5a0 <chSysUnlock>
  test_assert_lock(11, chIQGetFullI(&iq) == 0, "still full");
 800f98a:	f7ff fe01 	bl	800f590 <chSysLock>
 800f98e:	481e      	ldr	r0, [pc, #120]	; (800fa08 <queues1_execute+0x2b8>)
 800f990:	f7ff fe1e 	bl	800f5d0 <chIQGetFullI>
 800f994:	4603      	mov	r3, r0
 800f996:	2b00      	cmp	r3, #0
 800f998:	bf14      	ite	ne
 800f99a:	2300      	movne	r3, #0
 800f99c:	2301      	moveq	r3, #1
 800f99e:	b2db      	uxtb	r3, r3
 800f9a0:	200b      	movs	r0, #11
 800f9a2:	4619      	mov	r1, r3
 800f9a4:	f7fc fa54 	bl	800be50 <_test_assert>
 800f9a8:	4603      	mov	r3, r0
 800f9aa:	2b00      	cmp	r3, #0
 800f9ac:	d002      	beq.n	800f9b4 <queues1_execute+0x264>
 800f9ae:	f7ff fdf7 	bl	800f5a0 <chSysUnlock>
 800f9b2:	e04a      	b.n	800fa4a <queues1_execute+0x2fa>
 800f9b4:	f7ff fdf4 	bl	800f5a0 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, NULL);
 800f9b8:	4b15      	ldr	r3, [pc, #84]	; (800fa10 <queues1_execute+0x2c0>)
 800f9ba:	681c      	ldr	r4, [r3, #0]
 800f9bc:	f7ff fe00 	bl	800f5c0 <chThdGetPriorityX>
 800f9c0:	4603      	mov	r3, r0
 800f9c2:	3301      	adds	r3, #1
 800f9c4:	2200      	movs	r2, #0
 800f9c6:	9200      	str	r2, [sp, #0]
 800f9c8:	4620      	mov	r0, r4
 800f9ca:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800f9ce:	461a      	mov	r2, r3
 800f9d0:	4b10      	ldr	r3, [pc, #64]	; (800fa14 <queues1_execute+0x2c4>)
 800f9d2:	f7f1 fc05 	bl	80011e0 <chThdCreateStatic>
 800f9d6:	4602      	mov	r2, r0
 800f9d8:	4b0f      	ldr	r3, [pc, #60]	; (800fa18 <queues1_execute+0x2c8>)
 800f9da:	601a      	str	r2, [r3, #0]
  test_assert_lock(12, chIQGetFullI(&iq) == 0, "not empty");
 800f9dc:	f7ff fdd8 	bl	800f590 <chSysLock>
 800f9e0:	4809      	ldr	r0, [pc, #36]	; (800fa08 <queues1_execute+0x2b8>)
 800f9e2:	f7ff fdf5 	bl	800f5d0 <chIQGetFullI>
 800f9e6:	4603      	mov	r3, r0
 800f9e8:	2b00      	cmp	r3, #0
 800f9ea:	bf14      	ite	ne
 800f9ec:	2300      	movne	r3, #0
 800f9ee:	2301      	moveq	r3, #1
 800f9f0:	b2db      	uxtb	r3, r3
 800f9f2:	200c      	movs	r0, #12
 800f9f4:	4619      	mov	r1, r3
 800f9f6:	f7fc fa2b 	bl	800be50 <_test_assert>
 800f9fa:	4603      	mov	r3, r0
 800f9fc:	2b00      	cmp	r3, #0
 800f9fe:	d00d      	beq.n	800fa1c <queues1_execute+0x2cc>
 800fa00:	f7ff fdce 	bl	800f5a0 <chSysUnlock>
 800fa04:	e021      	b.n	800fa4a <queues1_execute+0x2fa>
 800fa06:	bf00      	nop
 800fa08:	200008a8 	.word	0x200008a8
 800fa0c:	08019ee0 	.word	0x08019ee0
 800fa10:	08019750 	.word	0x08019750
 800fa14:	0800f731 	.word	0x0800f731
 800fa18:	2000205c 	.word	0x2000205c
 800fa1c:	f7ff fdc0 	bl	800f5a0 <chSysUnlock>
  test_wait_threads();
 800fa20:	f7fc fa96 	bl	800bf50 <test_wait_threads>

  /* Timeout */
  test_assert(13, chIQGetTimeout(&iq, 10) == Q_TIMEOUT, "wrong timeout return");
 800fa24:	480a      	ldr	r0, [pc, #40]	; (800fa50 <queues1_execute+0x300>)
 800fa26:	210a      	movs	r1, #10
 800fa28:	f7f3 fc2a 	bl	8003280 <chIQGetTimeout>
 800fa2c:	4603      	mov	r3, r0
 800fa2e:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fa32:	bf14      	ite	ne
 800fa34:	2300      	movne	r3, #0
 800fa36:	2301      	moveq	r3, #1
 800fa38:	b2db      	uxtb	r3, r3
 800fa3a:	200d      	movs	r0, #13
 800fa3c:	4619      	mov	r1, r3
 800fa3e:	f7fc fa07 	bl	800be50 <_test_assert>
 800fa42:	4603      	mov	r3, r0
 800fa44:	2b00      	cmp	r3, #0
 800fa46:	d000      	beq.n	800fa4a <queues1_execute+0x2fa>
 800fa48:	bf00      	nop
}
 800fa4a:	b004      	add	sp, #16
 800fa4c:	bd10      	pop	{r4, pc}
 800fa4e:	bf00      	nop
 800fa50:	200008a8 	.word	0x200008a8
 800fa54:	f3af 8000 	nop.w
 800fa58:	f3af 8000 	nop.w
 800fa5c:	f3af 8000 	nop.w

0800fa60 <queues2_setup>:
 * This test case tests synchronous and asynchronous operations on an
 * @p OutputQueue object including timeouts. The queue state must remain
 * consistent through the whole test.
 */

static void queues2_setup(void) {
 800fa60:	b500      	push	{lr}
 800fa62:	b083      	sub	sp, #12

  chOQObjectInit(&oq, wa[0], TEST_QUEUES_SIZE, notify, NULL);
 800fa64:	4b06      	ldr	r3, [pc, #24]	; (800fa80 <queues2_setup+0x20>)
 800fa66:	681b      	ldr	r3, [r3, #0]
 800fa68:	2200      	movs	r2, #0
 800fa6a:	9200      	str	r2, [sp, #0]
 800fa6c:	4805      	ldr	r0, [pc, #20]	; (800fa84 <queues2_setup+0x24>)
 800fa6e:	4619      	mov	r1, r3
 800fa70:	2204      	movs	r2, #4
 800fa72:	4b05      	ldr	r3, [pc, #20]	; (800fa88 <queues2_setup+0x28>)
 800fa74:	f7f3 fca4 	bl	80033c0 <chOQObjectInit>
}
 800fa78:	b003      	add	sp, #12
 800fa7a:	f85d fb04 	ldr.w	pc, [sp], #4
 800fa7e:	bf00      	nop
 800fa80:	08019750 	.word	0x08019750
 800fa84:	200008cc 	.word	0x200008cc
 800fa88:	0800f6f1 	.word	0x0800f6f1
 800fa8c:	f3af 8000 	nop.w

0800fa90 <thread2>:

static THD_FUNCTION(thread2, p) {
 800fa90:	b500      	push	{lr}
 800fa92:	b083      	sub	sp, #12
 800fa94:	9001      	str	r0, [sp, #4]

  (void)p;
  chOQPutTimeout(&oq, 0, MS2ST(200));
 800fa96:	4804      	ldr	r0, [pc, #16]	; (800faa8 <thread2+0x18>)
 800fa98:	2100      	movs	r1, #0
 800fa9a:	22c8      	movs	r2, #200	; 0xc8
 800fa9c:	f7f3 fcd8 	bl	8003450 <chOQPutTimeout>
}
 800faa0:	b003      	add	sp, #12
 800faa2:	f85d fb04 	ldr.w	pc, [sp], #4
 800faa6:	bf00      	nop
 800faa8:	200008cc 	.word	0x200008cc
 800faac:	f3af 8000 	nop.w

0800fab0 <queues2_execute>:

static void queues2_execute(void) {
 800fab0:	b510      	push	{r4, lr}
 800fab2:	b086      	sub	sp, #24
  unsigned i;
  size_t n;

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");
 800fab4:	f7ff fd6c 	bl	800f590 <chSysLock>
 800fab8:	48a2      	ldr	r0, [pc, #648]	; (800fd44 <queues2_execute+0x294>)
 800faba:	f7ff fdd9 	bl	800f670 <chOQIsEmptyI>
 800fabe:	4603      	mov	r3, r0
 800fac0:	2001      	movs	r0, #1
 800fac2:	4619      	mov	r1, r3
 800fac4:	f7fc f9c4 	bl	800be50 <_test_assert>
 800fac8:	4603      	mov	r3, r0
 800faca:	2b00      	cmp	r3, #0
 800facc:	d002      	beq.n	800fad4 <queues2_execute+0x24>
 800face:	f7ff fd67 	bl	800f5a0 <chSysUnlock>
 800fad2:	e134      	b.n	800fd3e <queues2_execute+0x28e>
 800fad4:	f7ff fd64 	bl	800f5a0 <chSysUnlock>

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800fad8:	2300      	movs	r3, #0
 800fada:	9305      	str	r3, [sp, #20]
 800fadc:	e00a      	b.n	800faf4 <queues2_execute+0x44>
    chOQPut(&oq, 'A' + i);
 800fade:	9b05      	ldr	r3, [sp, #20]
 800fae0:	b2db      	uxtb	r3, r3
 800fae2:	3341      	adds	r3, #65	; 0x41
 800fae4:	b2db      	uxtb	r3, r3
 800fae6:	4897      	ldr	r0, [pc, #604]	; (800fd44 <queues2_execute+0x294>)
 800fae8:	4619      	mov	r1, r3
 800faea:	f7ff fde9 	bl	800f6c0 <chOQPut>

  /* Initial empty state */
  test_assert_lock(1, chOQIsEmptyI(&oq), "not empty");

  /* Queue filling */
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
 800faee:	9b05      	ldr	r3, [sp, #20]
 800faf0:	3301      	adds	r3, #1
 800faf2:	9305      	str	r3, [sp, #20]
 800faf4:	9b05      	ldr	r3, [sp, #20]
 800faf6:	2b03      	cmp	r3, #3
 800faf8:	d9f1      	bls.n	800fade <queues2_execute+0x2e>
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");
 800fafa:	f7ff fd49 	bl	800f590 <chSysLock>
 800fafe:	4891      	ldr	r0, [pc, #580]	; (800fd44 <queues2_execute+0x294>)
 800fb00:	f7ff fdce 	bl	800f6a0 <chOQIsFullI>
 800fb04:	4603      	mov	r3, r0
 800fb06:	2002      	movs	r0, #2
 800fb08:	4619      	mov	r1, r3
 800fb0a:	f7fc f9a1 	bl	800be50 <_test_assert>
 800fb0e:	4603      	mov	r3, r0
 800fb10:	2b00      	cmp	r3, #0
 800fb12:	d002      	beq.n	800fb1a <queues2_execute+0x6a>
 800fb14:	f7ff fd44 	bl	800f5a0 <chSysUnlock>
 800fb18:	e111      	b.n	800fd3e <queues2_execute+0x28e>
 800fb1a:	f7ff fd41 	bl	800f5a0 <chSysUnlock>

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fb1e:	2300      	movs	r3, #0
 800fb20:	9305      	str	r3, [sp, #20]
 800fb22:	e011      	b.n	800fb48 <queues2_execute+0x98>
    char c;

    chSysLock();
 800fb24:	f7ff fd34 	bl	800f590 <chSysLock>
    c = chOQGetI(&oq);
 800fb28:	4886      	ldr	r0, [pc, #536]	; (800fd44 <queues2_execute+0x294>)
 800fb2a:	f7f3 fcd9 	bl	80034e0 <chOQGetI>
 800fb2e:	4603      	mov	r3, r0
 800fb30:	f88d 3013 	strb.w	r3, [sp, #19]
    chSysUnlock();
 800fb34:	f7ff fd34 	bl	800f5a0 <chSysUnlock>
    test_emit_token(c);
 800fb38:	f89d 3013 	ldrb.w	r3, [sp, #19]
 800fb3c:	4618      	mov	r0, r3
 800fb3e:	f7fc f957 	bl	800bdf0 <test_emit_token>
  for (i = 0; i < TEST_QUEUES_SIZE; i++)
    chOQPut(&oq, 'A' + i);
  test_assert_lock(2, chOQIsFullI(&oq), "still has space");

  /* Queue emptying */
  for (i = 0; i < TEST_QUEUES_SIZE; i++) {
 800fb42:	9b05      	ldr	r3, [sp, #20]
 800fb44:	3301      	adds	r3, #1
 800fb46:	9305      	str	r3, [sp, #20]
 800fb48:	9b05      	ldr	r3, [sp, #20]
 800fb4a:	2b03      	cmp	r3, #3
 800fb4c:	d9ea      	bls.n	800fb24 <queues2_execute+0x74>
    chSysLock();
    c = chOQGetI(&oq);
    chSysUnlock();
    test_emit_token(c);
  }
  test_assert_lock(3, chOQIsEmptyI(&oq), "still full");
 800fb4e:	f7ff fd1f 	bl	800f590 <chSysLock>
 800fb52:	487c      	ldr	r0, [pc, #496]	; (800fd44 <queues2_execute+0x294>)
 800fb54:	f7ff fd8c 	bl	800f670 <chOQIsEmptyI>
 800fb58:	4603      	mov	r3, r0
 800fb5a:	2003      	movs	r0, #3
 800fb5c:	4619      	mov	r1, r3
 800fb5e:	f7fc f977 	bl	800be50 <_test_assert>
 800fb62:	4603      	mov	r3, r0
 800fb64:	2b00      	cmp	r3, #0
 800fb66:	d002      	beq.n	800fb6e <queues2_execute+0xbe>
 800fb68:	f7ff fd1a 	bl	800f5a0 <chSysUnlock>
 800fb6c:	e0e7      	b.n	800fd3e <queues2_execute+0x28e>
 800fb6e:	f7ff fd17 	bl	800f5a0 <chSysUnlock>
  test_assert_sequence(4, "ABCD");
 800fb72:	2004      	movs	r0, #4
 800fb74:	4974      	ldr	r1, [pc, #464]	; (800fd48 <queues2_execute+0x298>)
 800fb76:	f7fc f983 	bl	800be80 <_test_assert_sequence>
 800fb7a:	4603      	mov	r3, r0
 800fb7c:	2b00      	cmp	r3, #0
 800fb7e:	d000      	beq.n	800fb82 <queues2_execute+0xd2>
 800fb80:	e0dd      	b.n	800fd3e <queues2_execute+0x28e>
  test_assert_lock(5, chOQGetI(&oq) == Q_EMPTY, "failed to report Q_EMPTY");
 800fb82:	f7ff fd05 	bl	800f590 <chSysLock>
 800fb86:	486f      	ldr	r0, [pc, #444]	; (800fd44 <queues2_execute+0x294>)
 800fb88:	f7f3 fcaa 	bl	80034e0 <chOQGetI>
 800fb8c:	4603      	mov	r3, r0
 800fb8e:	f113 0f03 	cmn.w	r3, #3
 800fb92:	bf14      	ite	ne
 800fb94:	2300      	movne	r3, #0
 800fb96:	2301      	moveq	r3, #1
 800fb98:	b2db      	uxtb	r3, r3
 800fb9a:	2005      	movs	r0, #5
 800fb9c:	4619      	mov	r1, r3
 800fb9e:	f7fc f957 	bl	800be50 <_test_assert>
 800fba2:	4603      	mov	r3, r0
 800fba4:	2b00      	cmp	r3, #0
 800fba6:	d002      	beq.n	800fbae <queues2_execute+0xfe>
 800fba8:	f7ff fcfa 	bl	800f5a0 <chSysUnlock>
 800fbac:	e0c7      	b.n	800fd3e <queues2_execute+0x28e>
 800fbae:	f7ff fcf7 	bl	800f5a0 <chSysUnlock>

  /* Writing the whole thing */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE * 2, TIME_IMMEDIATE);
 800fbb2:	4b66      	ldr	r3, [pc, #408]	; (800fd4c <queues2_execute+0x29c>)
 800fbb4:	685b      	ldr	r3, [r3, #4]
 800fbb6:	4863      	ldr	r0, [pc, #396]	; (800fd44 <queues2_execute+0x294>)
 800fbb8:	4619      	mov	r1, r3
 800fbba:	2208      	movs	r2, #8
 800fbbc:	2300      	movs	r3, #0
 800fbbe:	f7f3 fcbf 	bl	8003540 <chOQWriteTimeout>
 800fbc2:	9003      	str	r0, [sp, #12]
  test_assert(6, n == TEST_QUEUES_SIZE, "wrong returned size");
 800fbc4:	9b03      	ldr	r3, [sp, #12]
 800fbc6:	2b04      	cmp	r3, #4
 800fbc8:	bf14      	ite	ne
 800fbca:	2300      	movne	r3, #0
 800fbcc:	2301      	moveq	r3, #1
 800fbce:	b2db      	uxtb	r3, r3
 800fbd0:	2006      	movs	r0, #6
 800fbd2:	4619      	mov	r1, r3
 800fbd4:	f7fc f93c 	bl	800be50 <_test_assert>
 800fbd8:	4603      	mov	r3, r0
 800fbda:	2b00      	cmp	r3, #0
 800fbdc:	d000      	beq.n	800fbe0 <queues2_execute+0x130>
 800fbde:	e0ae      	b.n	800fd3e <queues2_execute+0x28e>
  test_assert_lock(7, chOQIsFullI(&oq), "not full");
 800fbe0:	f7ff fcd6 	bl	800f590 <chSysLock>
 800fbe4:	4857      	ldr	r0, [pc, #348]	; (800fd44 <queues2_execute+0x294>)
 800fbe6:	f7ff fd5b 	bl	800f6a0 <chOQIsFullI>
 800fbea:	4603      	mov	r3, r0
 800fbec:	2007      	movs	r0, #7
 800fbee:	4619      	mov	r1, r3
 800fbf0:	f7fc f92e 	bl	800be50 <_test_assert>
 800fbf4:	4603      	mov	r3, r0
 800fbf6:	2b00      	cmp	r3, #0
 800fbf8:	d002      	beq.n	800fc00 <queues2_execute+0x150>
 800fbfa:	f7ff fcd1 	bl	800f5a0 <chSysUnlock>
 800fbfe:	e09e      	b.n	800fd3e <queues2_execute+0x28e>
 800fc00:	f7ff fcce 	bl	800f5a0 <chSysUnlock>
  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 800fc04:	4b51      	ldr	r3, [pc, #324]	; (800fd4c <queues2_execute+0x29c>)
 800fc06:	681c      	ldr	r4, [r3, #0]
 800fc08:	f7ff fcda 	bl	800f5c0 <chThdGetPriorityX>
 800fc0c:	4603      	mov	r3, r0
 800fc0e:	3301      	adds	r3, #1
 800fc10:	2200      	movs	r2, #0
 800fc12:	9200      	str	r2, [sp, #0]
 800fc14:	4620      	mov	r0, r4
 800fc16:	f44f 71a4 	mov.w	r1, #328	; 0x148
 800fc1a:	461a      	mov	r2, r3
 800fc1c:	4b4c      	ldr	r3, [pc, #304]	; (800fd50 <queues2_execute+0x2a0>)
 800fc1e:	f7f1 fadf 	bl	80011e0 <chThdCreateStatic>
 800fc22:	4602      	mov	r2, r0
 800fc24:	4b4b      	ldr	r3, [pc, #300]	; (800fd54 <queues2_execute+0x2a4>)
 800fc26:	601a      	str	r2, [r3, #0]
  test_assert_lock(8, chOQGetFullI(&oq) == TEST_QUEUES_SIZE, "not empty");
 800fc28:	f7ff fcb2 	bl	800f590 <chSysLock>
 800fc2c:	4845      	ldr	r0, [pc, #276]	; (800fd44 <queues2_execute+0x294>)
 800fc2e:	f7ff fd0f 	bl	800f650 <chOQGetFullI>
 800fc32:	4603      	mov	r3, r0
 800fc34:	2b04      	cmp	r3, #4
 800fc36:	bf14      	ite	ne
 800fc38:	2300      	movne	r3, #0
 800fc3a:	2301      	moveq	r3, #1
 800fc3c:	b2db      	uxtb	r3, r3
 800fc3e:	2008      	movs	r0, #8
 800fc40:	4619      	mov	r1, r3
 800fc42:	f7fc f905 	bl	800be50 <_test_assert>
 800fc46:	4603      	mov	r3, r0
 800fc48:	2b00      	cmp	r3, #0
 800fc4a:	d002      	beq.n	800fc52 <queues2_execute+0x1a2>
 800fc4c:	f7ff fca8 	bl	800f5a0 <chSysUnlock>
 800fc50:	e075      	b.n	800fd3e <queues2_execute+0x28e>
 800fc52:	f7ff fca5 	bl	800f5a0 <chSysUnlock>
  test_wait_threads();
 800fc56:	f7fc f97b 	bl	800bf50 <test_wait_threads>

  /* Testing reset */
  chSysLock();
 800fc5a:	f7ff fc99 	bl	800f590 <chSysLock>
  chOQResetI(&oq);
 800fc5e:	4839      	ldr	r0, [pc, #228]	; (800fd44 <queues2_execute+0x294>)
 800fc60:	f7f3 fbd6 	bl	8003410 <chOQResetI>
  chSysUnlock();
 800fc64:	f7ff fc9c 	bl	800f5a0 <chSysUnlock>
  test_assert_lock(9, chOQGetFullI(&oq) == 0, "still full");
 800fc68:	f7ff fc92 	bl	800f590 <chSysLock>
 800fc6c:	4835      	ldr	r0, [pc, #212]	; (800fd44 <queues2_execute+0x294>)
 800fc6e:	f7ff fcef 	bl	800f650 <chOQGetFullI>
 800fc72:	4603      	mov	r3, r0
 800fc74:	2b00      	cmp	r3, #0
 800fc76:	bf14      	ite	ne
 800fc78:	2300      	movne	r3, #0
 800fc7a:	2301      	moveq	r3, #1
 800fc7c:	b2db      	uxtb	r3, r3
 800fc7e:	2009      	movs	r0, #9
 800fc80:	4619      	mov	r1, r3
 800fc82:	f7fc f8e5 	bl	800be50 <_test_assert>
 800fc86:	4603      	mov	r3, r0
 800fc88:	2b00      	cmp	r3, #0
 800fc8a:	d002      	beq.n	800fc92 <queues2_execute+0x1e2>
 800fc8c:	f7ff fc88 	bl	800f5a0 <chSysUnlock>
 800fc90:	e055      	b.n	800fd3e <queues2_execute+0x28e>
 800fc92:	f7ff fc85 	bl	800f5a0 <chSysUnlock>

  /* Partial writes */
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fc96:	4b2d      	ldr	r3, [pc, #180]	; (800fd4c <queues2_execute+0x29c>)
 800fc98:	685b      	ldr	r3, [r3, #4]
 800fc9a:	482a      	ldr	r0, [pc, #168]	; (800fd44 <queues2_execute+0x294>)
 800fc9c:	4619      	mov	r1, r3
 800fc9e:	2202      	movs	r2, #2
 800fca0:	2300      	movs	r3, #0
 800fca2:	f7f3 fc4d 	bl	8003540 <chOQWriteTimeout>
 800fca6:	9003      	str	r0, [sp, #12]
  test_assert(10, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fca8:	9b03      	ldr	r3, [sp, #12]
 800fcaa:	2b02      	cmp	r3, #2
 800fcac:	bf14      	ite	ne
 800fcae:	2300      	movne	r3, #0
 800fcb0:	2301      	moveq	r3, #1
 800fcb2:	b2db      	uxtb	r3, r3
 800fcb4:	200a      	movs	r0, #10
 800fcb6:	4619      	mov	r1, r3
 800fcb8:	f7fc f8ca 	bl	800be50 <_test_assert>
 800fcbc:	4603      	mov	r3, r0
 800fcbe:	2b00      	cmp	r3, #0
 800fcc0:	d000      	beq.n	800fcc4 <queues2_execute+0x214>
 800fcc2:	e03c      	b.n	800fd3e <queues2_execute+0x28e>
  n = chOQWriteTimeout(&oq, wa[1], TEST_QUEUES_SIZE / 2, TIME_IMMEDIATE);
 800fcc4:	4b21      	ldr	r3, [pc, #132]	; (800fd4c <queues2_execute+0x29c>)
 800fcc6:	685b      	ldr	r3, [r3, #4]
 800fcc8:	481e      	ldr	r0, [pc, #120]	; (800fd44 <queues2_execute+0x294>)
 800fcca:	4619      	mov	r1, r3
 800fccc:	2202      	movs	r2, #2
 800fcce:	2300      	movs	r3, #0
 800fcd0:	f7f3 fc36 	bl	8003540 <chOQWriteTimeout>
 800fcd4:	9003      	str	r0, [sp, #12]
  test_assert(11, n == TEST_QUEUES_SIZE / 2, "wrong returned size");
 800fcd6:	9b03      	ldr	r3, [sp, #12]
 800fcd8:	2b02      	cmp	r3, #2
 800fcda:	bf14      	ite	ne
 800fcdc:	2300      	movne	r3, #0
 800fcde:	2301      	moveq	r3, #1
 800fce0:	b2db      	uxtb	r3, r3
 800fce2:	200b      	movs	r0, #11
 800fce4:	4619      	mov	r1, r3
 800fce6:	f7fc f8b3 	bl	800be50 <_test_assert>
 800fcea:	4603      	mov	r3, r0
 800fcec:	2b00      	cmp	r3, #0
 800fcee:	d000      	beq.n	800fcf2 <queues2_execute+0x242>
 800fcf0:	e025      	b.n	800fd3e <queues2_execute+0x28e>
  test_assert_lock(12, chOQIsFullI(&oq), "not full");
 800fcf2:	f7ff fc4d 	bl	800f590 <chSysLock>
 800fcf6:	4813      	ldr	r0, [pc, #76]	; (800fd44 <queues2_execute+0x294>)
 800fcf8:	f7ff fcd2 	bl	800f6a0 <chOQIsFullI>
 800fcfc:	4603      	mov	r3, r0
 800fcfe:	200c      	movs	r0, #12
 800fd00:	4619      	mov	r1, r3
 800fd02:	f7fc f8a5 	bl	800be50 <_test_assert>
 800fd06:	4603      	mov	r3, r0
 800fd08:	2b00      	cmp	r3, #0
 800fd0a:	d002      	beq.n	800fd12 <queues2_execute+0x262>
 800fd0c:	f7ff fc48 	bl	800f5a0 <chSysUnlock>
 800fd10:	e015      	b.n	800fd3e <queues2_execute+0x28e>
 800fd12:	f7ff fc45 	bl	800f5a0 <chSysUnlock>

  /* Timeout */
  test_assert(13, chOQPutTimeout(&oq, 0, 10) == Q_TIMEOUT, "wrong timeout return");
 800fd16:	480b      	ldr	r0, [pc, #44]	; (800fd44 <queues2_execute+0x294>)
 800fd18:	2100      	movs	r1, #0
 800fd1a:	220a      	movs	r2, #10
 800fd1c:	f7f3 fb98 	bl	8003450 <chOQPutTimeout>
 800fd20:	4603      	mov	r3, r0
 800fd22:	f1b3 3fff 	cmp.w	r3, #4294967295
 800fd26:	bf14      	ite	ne
 800fd28:	2300      	movne	r3, #0
 800fd2a:	2301      	moveq	r3, #1
 800fd2c:	b2db      	uxtb	r3, r3
 800fd2e:	200d      	movs	r0, #13
 800fd30:	4619      	mov	r1, r3
 800fd32:	f7fc f88d 	bl	800be50 <_test_assert>
 800fd36:	4603      	mov	r3, r0
 800fd38:	2b00      	cmp	r3, #0
 800fd3a:	d000      	beq.n	800fd3e <queues2_execute+0x28e>
 800fd3c:	bf00      	nop
}
 800fd3e:	b006      	add	sp, #24
 800fd40:	bd10      	pop	{r4, pc}
 800fd42:	bf00      	nop
 800fd44:	200008cc 	.word	0x200008cc
 800fd48:	08019ee0 	.word	0x08019ee0
 800fd4c:	08019750 	.word	0x08019750
 800fd50:	0800fa91 	.word	0x0800fa91
 800fd54:	2000205c 	.word	0x2000205c
 800fd58:	f3af 8000 	nop.w
 800fd5c:	f3af 8000 	nop.w

0800fd60 <port_get_irq_status>:
/**
 * @brief   Returns a word encoding the current interrupts status.
 *
 * @return              The interrupts status.
 */
static inline syssts_t port_get_irq_status(void) {
 800fd60:	b082      	sub	sp, #8
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 800fd62:	f3ef 8311 	mrs	r3, BASEPRI
 800fd66:	9300      	str	r3, [sp, #0]
  return(result);
 800fd68:	9b00      	ldr	r3, [sp, #0]
  syssts_t sts;

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  sts = (syssts_t)__get_BASEPRI();
 800fd6a:	9301      	str	r3, [sp, #4]
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  sts = (syssts_t)__get_PRIMASK();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
  return sts;
 800fd6c:	9b01      	ldr	r3, [sp, #4]
}
 800fd6e:	4618      	mov	r0, r3
 800fd70:	b002      	add	sp, #8
 800fd72:	4770      	bx	lr
 800fd74:	f3af 8000 	nop.w
 800fd78:	f3af 8000 	nop.w
 800fd7c:	f3af 8000 	nop.w

0800fd80 <port_irq_enabled>:
 *
 * @return              The interrupt status.
 * @retvel false        the word specified a disabled interrupts status.
 * @retvel true         the word specified an enabled interrupts status.
 */
static inline bool port_irq_enabled(syssts_t sts) {
 800fd80:	b082      	sub	sp, #8
 800fd82:	9001      	str	r0, [sp, #4]

#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  return sts == (syssts_t)CORTEX_BASEPRI_DISABLED;
 800fd84:	9b01      	ldr	r3, [sp, #4]
 800fd86:	2b00      	cmp	r3, #0
 800fd88:	bf14      	ite	ne
 800fd8a:	2300      	movne	r3, #0
 800fd8c:	2301      	moveq	r3, #1
 800fd8e:	b2db      	uxtb	r3, r3
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  return (sts & (syssts_t)1) == (syssts_t)0;
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fd90:	4618      	mov	r0, r3
 800fd92:	b002      	add	sp, #8
 800fd94:	4770      	bx	lr
 800fd96:	bf00      	nop
 800fd98:	f3af 8000 	nop.w
 800fd9c:	f3af 8000 	nop.w

0800fda0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 800fda0:	b082      	sub	sp, #8
 800fda2:	2320      	movs	r3, #32
 800fda4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fda6:	9b01      	ldr	r3, [sp, #4]
 800fda8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fdac:	b002      	add	sp, #8
 800fdae:	4770      	bx	lr

0800fdb0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 800fdb0:	b082      	sub	sp, #8
 800fdb2:	2300      	movs	r3, #0
 800fdb4:	9301      	str	r3, [sp, #4]
 800fdb6:	9b01      	ldr	r3, [sp, #4]
 800fdb8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 800fdbc:	b002      	add	sp, #8
 800fdbe:	4770      	bx	lr

0800fdc0 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 800fdc0:	b508      	push	{r3, lr}

  port_lock();
 800fdc2:	f7ff ffed 	bl	800fda0 <port_lock>
}
 800fdc6:	bd08      	pop	{r3, pc}
 800fdc8:	f3af 8000 	nop.w
 800fdcc:	f3af 8000 	nop.w

0800fdd0 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 800fdd0:	b508      	push	{r3, lr}

  port_unlock();
 800fdd2:	f7ff ffed 	bl	800fdb0 <port_unlock>
}
 800fdd6:	bd08      	pop	{r3, pc}
 800fdd8:	f3af 8000 	nop.w
 800fddc:	f3af 8000 	nop.w

0800fde0 <port_disable>:
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 800fde0:	b672      	cpsid	i
 *          the priority mask to level 0.
 */
static inline void port_disable(void) {

  __disable_irq();
}
 800fde2:	4770      	bx	lr
 800fde4:	f3af 8000 	nop.w
 800fde8:	f3af 8000 	nop.w
 800fdec:	f3af 8000 	nop.w

0800fdf0 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 * @note    Interrupt sources above kernel level remains enabled.
 * @note    In this port it raises/lowers the base priority to kernel level.
 */
static inline void port_suspend(void) {
 800fdf0:	b082      	sub	sp, #8
 800fdf2:	2320      	movs	r3, #32
 800fdf4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fdf6:	9b01      	ldr	r3, [sp, #4]
 800fdf8:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fdfc:	b662      	cpsie	i
  __set_BASEPRI(CORTEX_BASEPRI_KERNEL);
  __enable_irq();
#else
  __disable_irq();
#endif
}
 800fdfe:	b002      	add	sp, #8
 800fe00:	4770      	bx	lr
 800fe02:	bf00      	nop
 800fe04:	f3af 8000 	nop.w
 800fe08:	f3af 8000 	nop.w
 800fe0c:	f3af 8000 	nop.w

0800fe10 <port_enable>:

/**
 * @brief   Enables all the interrupt sources.
 * @note    In this port it lowers the base priority to user level.
 */
static inline void port_enable(void) {
 800fe10:	b082      	sub	sp, #8
 800fe12:	2300      	movs	r3, #0
 800fe14:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800fe16:	9b01      	ldr	r3, [sp, #4]
 800fe18:	f383 8811 	msr	BASEPRI, r3
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 800fe1c:	b662      	cpsie	i

#if (CORTEX_SIMPLIFIED_PRIORITY == FALSE) || defined(__DOXYGEN__)
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#endif
  __enable_irq();
}
 800fe1e:	b002      	add	sp, #8
 800fe20:	4770      	bx	lr
 800fe22:	bf00      	nop
 800fe24:	f3af 8000 	nop.w
 800fe28:	f3af 8000 	nop.w
 800fe2c:	f3af 8000 	nop.w

0800fe30 <chSysDisable>:
 *          hardware priority.
 * @note    Do not invoke this API from within a kernel lock.
 *
 * @special
 */
static inline void chSysDisable(void) {
 800fe30:	b508      	push	{r3, lr}

  port_disable();
 800fe32:	f7ff ffd5 	bl	800fde0 <port_disable>
  _dbg_check_disable();
}
 800fe36:	bd08      	pop	{r3, pc}
 800fe38:	f3af 8000 	nop.w
 800fe3c:	f3af 8000 	nop.w

0800fe40 <chSysSuspend>:
 * @note    This API is no replacement for @p chSysLock(), the @p chSysLock()
 *          could do more than just disable the interrupts.
 *
 * @special
 */
static inline void chSysSuspend(void) {
 800fe40:	b508      	push	{r3, lr}

  port_suspend();
 800fe42:	f7ff ffd5 	bl	800fdf0 <port_suspend>
  _dbg_check_suspend();
}
 800fe46:	bd08      	pop	{r3, pc}
 800fe48:	f3af 8000 	nop.w
 800fe4c:	f3af 8000 	nop.w

0800fe50 <chSysEnable>:
 * @note    This API is no replacement for @p chSysUnlock(), the
 *          @p chSysUnlock() could do more than just enable the interrupts.
 *
 * @special
 */
static inline void chSysEnable(void) {
 800fe50:	b508      	push	{r3, lr}

  _dbg_check_enable();
  port_enable();
 800fe52:	f7ff ffdd 	bl	800fe10 <port_enable>
}
 800fe56:	bd08      	pop	{r3, pc}
 800fe58:	f3af 8000 	nop.w
 800fe5c:	f3af 8000 	nop.w

0800fe60 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 800fe60:	b508      	push	{r3, lr}

  port_lock();
 800fe62:	f7ff ff9d 	bl	800fda0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 800fe66:	bd08      	pop	{r3, pc}
 800fe68:	f3af 8000 	nop.w
 800fe6c:	f3af 8000 	nop.w

0800fe70 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 800fe70:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 800fe72:	f7ff ff9d 	bl	800fdb0 <port_unlock>
}
 800fe76:	bd08      	pop	{r3, pc}
 800fe78:	f3af 8000 	nop.w
 800fe7c:	f3af 8000 	nop.w

0800fe80 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 800fe80:	b508      	push	{r3, lr}

  port_lock_from_isr();
 800fe82:	f7ff ff9d 	bl	800fdc0 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 800fe86:	bd08      	pop	{r3, pc}
 800fe88:	f3af 8000 	nop.w
 800fe8c:	f3af 8000 	nop.w

0800fe90 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 800fe90:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 800fe92:	f7ff ff9d 	bl	800fdd0 <port_unlock_from_isr>
}
 800fe96:	bd08      	pop	{r3, pc}
 800fe98:	f3af 8000 	nop.w
 800fe9c:	f3af 8000 	nop.w

0800fea0 <chSysUnconditionalLock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "s-locked".
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {
 800fea0:	b508      	push	{r3, lr}

  if (port_irq_enabled(port_get_irq_status())) {
 800fea2:	f7ff ff5d 	bl	800fd60 <port_get_irq_status>
 800fea6:	4603      	mov	r3, r0
 800fea8:	4618      	mov	r0, r3
 800feaa:	f7ff ff69 	bl	800fd80 <port_irq_enabled>
 800feae:	4603      	mov	r3, r0
 800feb0:	2b00      	cmp	r3, #0
 800feb2:	d001      	beq.n	800feb8 <chSysUnconditionalLock+0x18>
    chSysLock();
 800feb4:	f7ff ffd4 	bl	800fe60 <chSysLock>
  }
}
 800feb8:	bd08      	pop	{r3, pc}
 800feba:	bf00      	nop
 800febc:	f3af 8000 	nop.w

0800fec0 <chSysUnconditionalUnlock>:
 * @note    Can be called without previous knowledge of the current lock state.
 *          The final state is "normal".
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {
 800fec0:	b508      	push	{r3, lr}

  if (!port_irq_enabled(port_get_irq_status())) {
 800fec2:	f7ff ff4d 	bl	800fd60 <port_get_irq_status>
 800fec6:	4603      	mov	r3, r0
 800fec8:	4618      	mov	r0, r3
 800feca:	f7ff ff59 	bl	800fd80 <port_irq_enabled>
 800fece:	4603      	mov	r3, r0
 800fed0:	f083 0301 	eor.w	r3, r3, #1
 800fed4:	b2db      	uxtb	r3, r3
 800fed6:	2b00      	cmp	r3, #0
 800fed8:	d001      	beq.n	800fede <chSysUnconditionalUnlock+0x1e>
    chSysUnlock();
 800feda:	f7ff ffc9 	bl	800fe70 <chSysUnlock>
  }
}
 800fede:	bd08      	pop	{r3, pc}

0800fee0 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 800fee0:	b082      	sub	sp, #8
 800fee2:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 800fee4:	9b01      	ldr	r3, [sp, #4]
 800fee6:	2200      	movs	r2, #0
 800fee8:	60da      	str	r2, [r3, #12]
}
 800feea:	b002      	add	sp, #8
 800feec:	4770      	bx	lr
 800feee:	bf00      	nop

0800fef0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 800fef0:	b082      	sub	sp, #8
 800fef2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 800fef4:	9b01      	ldr	r3, [sp, #4]
 800fef6:	68db      	ldr	r3, [r3, #12]
 800fef8:	2b00      	cmp	r3, #0
 800fefa:	bf0c      	ite	eq
 800fefc:	2300      	moveq	r3, #0
 800fefe:	2301      	movne	r3, #1
 800ff00:	b2db      	uxtb	r3, r3
}
 800ff02:	4618      	mov	r0, r3
 800ff04:	b002      	add	sp, #8
 800ff06:	4770      	bx	lr
 800ff08:	f3af 8000 	nop.w
 800ff0c:	f3af 8000 	nop.w

0800ff10 <chVTIsArmed>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @api
 */
static inline bool chVTIsArmed(virtual_timer_t *vtp) {
 800ff10:	b500      	push	{lr}
 800ff12:	b085      	sub	sp, #20
 800ff14:	9001      	str	r0, [sp, #4]
  bool b;

  chSysLock();
 800ff16:	f7ff ffa3 	bl	800fe60 <chSysLock>
  b = chVTIsArmedI(vtp);
 800ff1a:	9801      	ldr	r0, [sp, #4]
 800ff1c:	f7ff ffe8 	bl	800fef0 <chVTIsArmedI>
 800ff20:	4603      	mov	r3, r0
 800ff22:	f88d 300f 	strb.w	r3, [sp, #15]
  chSysUnlock();
 800ff26:	f7ff ffa3 	bl	800fe70 <chSysUnlock>

  return b;
 800ff2a:	f89d 300f 	ldrb.w	r3, [sp, #15]
}
 800ff2e:	4618      	mov	r0, r3
 800ff30:	b005      	add	sp, #20
 800ff32:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff36:	bf00      	nop
 800ff38:	f3af 8000 	nop.w
 800ff3c:	f3af 8000 	nop.w

0800ff40 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 800ff40:	b500      	push	{lr}
 800ff42:	b083      	sub	sp, #12
 800ff44:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 800ff46:	9801      	ldr	r0, [sp, #4]
 800ff48:	f7ff ffd2 	bl	800fef0 <chVTIsArmedI>
 800ff4c:	4603      	mov	r3, r0
 800ff4e:	2b00      	cmp	r3, #0
 800ff50:	d002      	beq.n	800ff58 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 800ff52:	9801      	ldr	r0, [sp, #4]
 800ff54:	f7f0 fd5c 	bl	8000a10 <chVTDoResetI>
  }
}
 800ff58:	b003      	add	sp, #12
 800ff5a:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff5e:	bf00      	nop

0800ff60 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 800ff60:	b500      	push	{lr}
 800ff62:	b085      	sub	sp, #20
 800ff64:	9003      	str	r0, [sp, #12]
 800ff66:	9102      	str	r1, [sp, #8]
 800ff68:	9201      	str	r2, [sp, #4]
 800ff6a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 800ff6c:	9803      	ldr	r0, [sp, #12]
 800ff6e:	f7ff ffe7 	bl	800ff40 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 800ff72:	9803      	ldr	r0, [sp, #12]
 800ff74:	9902      	ldr	r1, [sp, #8]
 800ff76:	9a01      	ldr	r2, [sp, #4]
 800ff78:	9b00      	ldr	r3, [sp, #0]
 800ff7a:	f7f0 fd09 	bl	8000990 <chVTDoSetI>
}
 800ff7e:	b005      	add	sp, #20
 800ff80:	f85d fb04 	ldr.w	pc, [sp], #4
 800ff84:	f3af 8000 	nop.w
 800ff88:	f3af 8000 	nop.w
 800ff8c:	f3af 8000 	nop.w

0800ff90 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 800ff90:	b500      	push	{lr}
 800ff92:	b085      	sub	sp, #20
 800ff94:	9003      	str	r0, [sp, #12]
 800ff96:	9102      	str	r1, [sp, #8]
 800ff98:	9201      	str	r2, [sp, #4]
 800ff9a:	9300      	str	r3, [sp, #0]

  chSysLock();
 800ff9c:	f7ff ff60 	bl	800fe60 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 800ffa0:	9803      	ldr	r0, [sp, #12]
 800ffa2:	9902      	ldr	r1, [sp, #8]
 800ffa4:	9a01      	ldr	r2, [sp, #4]
 800ffa6:	9b00      	ldr	r3, [sp, #0]
 800ffa8:	f7ff ffda 	bl	800ff60 <chVTSetI>
  chSysUnlock();
 800ffac:	f7ff ff60 	bl	800fe70 <chSysUnlock>
}
 800ffb0:	b005      	add	sp, #20
 800ffb2:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffb6:	bf00      	nop
 800ffb8:	f3af 8000 	nop.w
 800ffbc:	f3af 8000 	nop.w

0800ffc0 <vtcb>:
 *
 * <h2>Description</h2>
 * The critical zones API is invoked for coverage.
 */

static void vtcb(void *p) {
 800ffc0:	b500      	push	{lr}
 800ffc2:	b085      	sub	sp, #20
 800ffc4:	9001      	str	r0, [sp, #4]
  syssts_t sts;

  (void)p;

  /* Testing normal case.*/
  chSysLockFromISR();
 800ffc6:	f7ff ff5b 	bl	800fe80 <chSysLockFromISR>
  chSysUnlockFromISR();
 800ffca:	f7ff ff61 	bl	800fe90 <chSysUnlockFromISR>

  /* Reentrant case.*/
  chSysLockFromISR();
 800ffce:	f7ff ff57 	bl	800fe80 <chSysLockFromISR>
  sts = chSysGetStatusAndLockX();
 800ffd2:	f7f0 fc55 	bl	8000880 <chSysGetStatusAndLockX>
 800ffd6:	9003      	str	r0, [sp, #12]
  chSysRestoreStatusX(sts);
 800ffd8:	9803      	ldr	r0, [sp, #12]
 800ffda:	f7f0 fc71 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlockFromISR();
 800ffde:	f7ff ff57 	bl	800fe90 <chSysUnlockFromISR>
}
 800ffe2:	b005      	add	sp, #20
 800ffe4:	f85d fb04 	ldr.w	pc, [sp], #4
 800ffe8:	f3af 8000 	nop.w
 800ffec:	f3af 8000 	nop.w

0800fff0 <sys1_execute>:

static void sys1_execute(void) {
 800fff0:	b500      	push	{lr}
 800fff2:	b087      	sub	sp, #28
  syssts_t sts;
  virtual_timer_t vt;

  /* Testing normal case.*/
  sts = chSysGetStatusAndLockX();
 800fff4:	f7f0 fc44 	bl	8000880 <chSysGetStatusAndLockX>
 800fff8:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 800fffa:	9805      	ldr	r0, [sp, #20]
 800fffc:	f7f0 fc60 	bl	80008c0 <chSysRestoreStatusX>

  /* Reentrant case.*/
  chSysLock();
 8010000:	f7ff ff2e 	bl	800fe60 <chSysLock>
  sts = chSysGetStatusAndLockX();
 8010004:	f7f0 fc3c 	bl	8000880 <chSysGetStatusAndLockX>
 8010008:	9005      	str	r0, [sp, #20]
  chSysRestoreStatusX(sts);
 801000a:	9805      	ldr	r0, [sp, #20]
 801000c:	f7f0 fc58 	bl	80008c0 <chSysRestoreStatusX>
  chSysUnlock();
 8010010:	f7ff ff2e 	bl	800fe70 <chSysUnlock>

  /* Unconditional lock.*/
  chSysUnconditionalLock();
 8010014:	f7ff ff44 	bl	800fea0 <chSysUnconditionalLock>
  chSysUnconditionalLock();
 8010018:	f7ff ff42 	bl	800fea0 <chSysUnconditionalLock>
  chSysUnlock();
 801001c:	f7ff ff28 	bl	800fe70 <chSysUnlock>

  /* Unconditional unlock.*/
  chSysLock();
 8010020:	f7ff ff1e 	bl	800fe60 <chSysLock>
  chSysUnconditionalUnlock();
 8010024:	f7ff ff4c 	bl	800fec0 <chSysUnconditionalUnlock>
  chSysUnconditionalUnlock();
 8010028:	f7ff ff4a 	bl	800fec0 <chSysUnconditionalUnlock>

  /*/Testing from ISR context using a virtual timer.*/
  chVTObjectInit(&vt);
 801002c:	466b      	mov	r3, sp
 801002e:	4618      	mov	r0, r3
 8010030:	f7ff ff56 	bl	800fee0 <chVTObjectInit>
  chVTSet(&vt, 1, vtcb, NULL);
 8010034:	466b      	mov	r3, sp
 8010036:	4618      	mov	r0, r3
 8010038:	2101      	movs	r1, #1
 801003a:	4a10      	ldr	r2, [pc, #64]	; (801007c <sys1_execute+0x8c>)
 801003c:	2300      	movs	r3, #0
 801003e:	f7ff ffa7 	bl	800ff90 <chVTSet>
  chThdSleep(10);
 8010042:	200a      	movs	r0, #10
 8010044:	f7f1 f944 	bl	80012d0 <chThdSleep>

  test_assert(1, chVTIsArmed(&vt) == false, "timer still armed");
 8010048:	466b      	mov	r3, sp
 801004a:	4618      	mov	r0, r3
 801004c:	f7ff ff60 	bl	800ff10 <chVTIsArmed>
 8010050:	4603      	mov	r3, r0
 8010052:	2b00      	cmp	r3, #0
 8010054:	bf0c      	ite	eq
 8010056:	2300      	moveq	r3, #0
 8010058:	2301      	movne	r3, #1
 801005a:	b2db      	uxtb	r3, r3
 801005c:	f083 0301 	eor.w	r3, r3, #1
 8010060:	b2db      	uxtb	r3, r3
 8010062:	f003 0301 	and.w	r3, r3, #1
 8010066:	b2db      	uxtb	r3, r3
 8010068:	2001      	movs	r0, #1
 801006a:	4619      	mov	r1, r3
 801006c:	f7fb fef0 	bl	800be50 <_test_assert>
 8010070:	4603      	mov	r3, r0
 8010072:	2b00      	cmp	r3, #0
}
 8010074:	b007      	add	sp, #28
 8010076:	f85d fb04 	ldr.w	pc, [sp], #4
 801007a:	bf00      	nop
 801007c:	0800ffc1 	.word	0x0800ffc1

08010080 <sys2_execute>:
 *
 * <h2>Description</h2>
 * The interrupts handling API is invoked for coverage.
 */

static void sys2_execute(void) {
 8010080:	b508      	push	{r3, lr}

  chSysSuspend();
 8010082:	f7ff fedd 	bl	800fe40 <chSysSuspend>
  chSysDisable();
 8010086:	f7ff fed3 	bl	800fe30 <chSysDisable>
  chSysSuspend();
 801008a:	f7ff fed9 	bl	800fe40 <chSysSuspend>
  chSysEnable();
 801008e:	f7ff fedf 	bl	800fe50 <chSysEnable>
}
 8010092:	bd08      	pop	{r3, pc}
 8010094:	f3af 8000 	nop.w
 8010098:	f3af 8000 	nop.w
 801009c:	f3af 8000 	nop.w

080100a0 <sys3_execute>:
 * <h2>Description</h2>
 * The chSysIntegrityCheckI() API is invoked in order to asses the state of the
 * system data structures.
 */

static void sys3_execute(void) {
 80100a0:	b500      	push	{lr}
 80100a2:	b083      	sub	sp, #12
  bool result;

  chSysLock();
 80100a4:	f7ff fedc 	bl	800fe60 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 80100a8:	2001      	movs	r0, #1
 80100aa:	f7f0 fb49 	bl	8000740 <chSysIntegrityCheckI>
 80100ae:	4603      	mov	r3, r0
 80100b0:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80100b4:	f7ff fedc 	bl	800fe70 <chSysUnlock>
  test_assert(1, result == false, "ready list check failed");
 80100b8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80100bc:	2b00      	cmp	r3, #0
 80100be:	bf0c      	ite	eq
 80100c0:	2300      	moveq	r3, #0
 80100c2:	2301      	movne	r3, #1
 80100c4:	b2db      	uxtb	r3, r3
 80100c6:	f083 0301 	eor.w	r3, r3, #1
 80100ca:	b2db      	uxtb	r3, r3
 80100cc:	f003 0301 	and.w	r3, r3, #1
 80100d0:	b2db      	uxtb	r3, r3
 80100d2:	2001      	movs	r0, #1
 80100d4:	4619      	mov	r1, r3
 80100d6:	f7fb febb 	bl	800be50 <_test_assert>
 80100da:	4603      	mov	r3, r0
 80100dc:	2b00      	cmp	r3, #0
 80100de:	d000      	beq.n	80100e2 <sys3_execute+0x42>
 80100e0:	e05c      	b.n	801019c <sys3_execute+0xfc>

  chSysLock();
 80100e2:	f7ff febd 	bl	800fe60 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 80100e6:	2002      	movs	r0, #2
 80100e8:	f7f0 fb2a 	bl	8000740 <chSysIntegrityCheckI>
 80100ec:	4603      	mov	r3, r0
 80100ee:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 80100f2:	f7ff febd 	bl	800fe70 <chSysUnlock>
  test_assert(2, result == false, "virtual timers list check failed");
 80100f6:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80100fa:	2b00      	cmp	r3, #0
 80100fc:	bf0c      	ite	eq
 80100fe:	2300      	moveq	r3, #0
 8010100:	2301      	movne	r3, #1
 8010102:	b2db      	uxtb	r3, r3
 8010104:	f083 0301 	eor.w	r3, r3, #1
 8010108:	b2db      	uxtb	r3, r3
 801010a:	f003 0301 	and.w	r3, r3, #1
 801010e:	b2db      	uxtb	r3, r3
 8010110:	2002      	movs	r0, #2
 8010112:	4619      	mov	r1, r3
 8010114:	f7fb fe9c 	bl	800be50 <_test_assert>
 8010118:	4603      	mov	r3, r0
 801011a:	2b00      	cmp	r3, #0
 801011c:	d000      	beq.n	8010120 <sys3_execute+0x80>
 801011e:	e03d      	b.n	801019c <sys3_execute+0xfc>

  chSysLock();
 8010120:	f7ff fe9e 	bl	800fe60 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8010124:	2004      	movs	r0, #4
 8010126:	f7f0 fb0b 	bl	8000740 <chSysIntegrityCheckI>
 801012a:	4603      	mov	r3, r0
 801012c:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 8010130:	f7ff fe9e 	bl	800fe70 <chSysUnlock>
  test_assert(3, result == false, "registry list check failed");
 8010134:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010138:	2b00      	cmp	r3, #0
 801013a:	bf0c      	ite	eq
 801013c:	2300      	moveq	r3, #0
 801013e:	2301      	movne	r3, #1
 8010140:	b2db      	uxtb	r3, r3
 8010142:	f083 0301 	eor.w	r3, r3, #1
 8010146:	b2db      	uxtb	r3, r3
 8010148:	f003 0301 	and.w	r3, r3, #1
 801014c:	b2db      	uxtb	r3, r3
 801014e:	2003      	movs	r0, #3
 8010150:	4619      	mov	r1, r3
 8010152:	f7fb fe7d 	bl	800be50 <_test_assert>
 8010156:	4603      	mov	r3, r0
 8010158:	2b00      	cmp	r3, #0
 801015a:	d000      	beq.n	801015e <sys3_execute+0xbe>
 801015c:	e01e      	b.n	801019c <sys3_execute+0xfc>

  chSysLock();
 801015e:	f7ff fe7f 	bl	800fe60 <chSysLock>
  result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8010162:	2008      	movs	r0, #8
 8010164:	f7f0 faec 	bl	8000740 <chSysIntegrityCheckI>
 8010168:	4603      	mov	r3, r0
 801016a:	f88d 3007 	strb.w	r3, [sp, #7]
  chSysUnlock();
 801016e:	f7ff fe7f 	bl	800fe70 <chSysUnlock>
  test_assert(4, result == false, "port layer check failed");
 8010172:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8010176:	2b00      	cmp	r3, #0
 8010178:	bf0c      	ite	eq
 801017a:	2300      	moveq	r3, #0
 801017c:	2301      	movne	r3, #1
 801017e:	b2db      	uxtb	r3, r3
 8010180:	f083 0301 	eor.w	r3, r3, #1
 8010184:	b2db      	uxtb	r3, r3
 8010186:	f003 0301 	and.w	r3, r3, #1
 801018a:	b2db      	uxtb	r3, r3
 801018c:	2004      	movs	r0, #4
 801018e:	4619      	mov	r1, r3
 8010190:	f7fb fe5e 	bl	800be50 <_test_assert>
 8010194:	4603      	mov	r3, r0
 8010196:	2b00      	cmp	r3, #0
 8010198:	d000      	beq.n	801019c <sys3_execute+0xfc>
 801019a:	bf00      	nop
}
 801019c:	b003      	add	sp, #12
 801019e:	f85d fb04 	ldr.w	pc, [sp], #4
 80101a2:	bf00      	nop
 80101a4:	f3af 8000 	nop.w
 80101a8:	f3af 8000 	nop.w
 80101ac:	f3af 8000 	nop.w

080101b0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 80101b0:	b082      	sub	sp, #8
 80101b2:	2320      	movs	r3, #32
 80101b4:	9301      	str	r3, [sp, #4]

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80101b6:	9b01      	ldr	r3, [sp, #4]
 80101b8:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101bc:	b002      	add	sp, #8
 80101be:	4770      	bx	lr

080101c0 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 80101c0:	b082      	sub	sp, #8
 80101c2:	2300      	movs	r3, #0
 80101c4:	9301      	str	r3, [sp, #4]
 80101c6:	9b01      	ldr	r3, [sp, #4]
 80101c8:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 80101cc:	b002      	add	sp, #8
 80101ce:	4770      	bx	lr

080101d0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80101d0:	b508      	push	{r3, lr}

  port_lock();
 80101d2:	f7ff ffed 	bl	80101b0 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80101d6:	bd08      	pop	{r3, pc}
 80101d8:	f3af 8000 	nop.w
 80101dc:	f3af 8000 	nop.w

080101e0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80101e0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80101e2:	f7ff ffed 	bl	80101c0 <port_unlock>
}
 80101e6:	bd08      	pop	{r3, pc}
 80101e8:	f3af 8000 	nop.w
 80101ec:	f3af 8000 	nop.w

080101f0 <chThdGetSelfX>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80101f0:	4b01      	ldr	r3, [pc, #4]	; (80101f8 <chThdGetSelfX+0x8>)
 80101f2:	699b      	ldr	r3, [r3, #24]
}
 80101f4:	4618      	mov	r0, r3
 80101f6:	4770      	bx	lr
 80101f8:	20001bc8 	.word	0x20001bc8
 80101fc:	f3af 8000 	nop.w

08010200 <chThdGetPriorityX>:
 *
 * @return              The current thread priority.
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {
 8010200:	b508      	push	{r3, lr}

  return chThdGetSelfX()->p_prio;
 8010202:	f7ff fff5 	bl	80101f0 <chThdGetSelfX>
 8010206:	4603      	mov	r3, r0
 8010208:	689b      	ldr	r3, [r3, #8]
}
 801020a:	4618      	mov	r0, r3
 801020c:	bd08      	pop	{r3, pc}
 801020e:	bf00      	nop

08010210 <chThdShouldTerminateX>:
 * @retval true         termination request pending.
 * @retval false        termination request not pending.
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {
 8010210:	b508      	push	{r3, lr}

  return (bool)((chThdGetSelfX()->p_flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8010212:	f7ff ffed 	bl	80101f0 <chThdGetSelfX>
 8010216:	4603      	mov	r3, r0
 8010218:	7f5b      	ldrb	r3, [r3, #29]
 801021a:	f003 0304 	and.w	r3, r3, #4
 801021e:	2b00      	cmp	r3, #0
 8010220:	bf0c      	ite	eq
 8010222:	2300      	moveq	r3, #0
 8010224:	2301      	movne	r3, #1
 8010226:	b2db      	uxtb	r3, r3
}
 8010228:	4618      	mov	r0, r3
 801022a:	bd08      	pop	{r3, pc}
 801022c:	f3af 8000 	nop.w

08010230 <chMsgGet>:
 * @param[in] tp        pointer to the thread
 * @return              The message carried by the sender.
 *
 * @api
 */
static inline msg_t chMsgGet(thread_t *tp) {
 8010230:	b082      	sub	sp, #8
 8010232:	9001      	str	r0, [sp, #4]

  return tp->p_msg;
 8010234:	9b01      	ldr	r3, [sp, #4]
 8010236:	6b1b      	ldr	r3, [r3, #48]	; 0x30
}
 8010238:	4618      	mov	r0, r3
 801023a:	b002      	add	sp, #8
 801023c:	4770      	bx	lr
 801023e:	bf00      	nop

08010240 <chIQGet>:
 * @return              A byte value from the queue.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
static inline msg_t chIQGet(input_queue_t *iqp) {
 8010240:	b500      	push	{lr}
 8010242:	b083      	sub	sp, #12
 8010244:	9001      	str	r0, [sp, #4]

  return chIQGetTimeout(iqp, TIME_INFINITE);
 8010246:	9801      	ldr	r0, [sp, #4]
 8010248:	f04f 31ff 	mov.w	r1, #4294967295
 801024c:	f7f3 f818 	bl	8003280 <chIQGetTimeout>
 8010250:	4603      	mov	r3, r0
}
 8010252:	4618      	mov	r0, r3
 8010254:	b003      	add	sp, #12
 8010256:	f85d fb04 	ldr.w	pc, [sp], #4
 801025a:	bf00      	nop
 801025c:	f3af 8000 	nop.w

08010260 <thread1>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static THD_FUNCTION(thread1, p) {
 8010260:	b500      	push	{lr}
 8010262:	b083      	sub	sp, #12
 8010264:	9001      	str	r0, [sp, #4]

  chThdExit((msg_t)p);
 8010266:	9b01      	ldr	r3, [sp, #4]
 8010268:	4618      	mov	r0, r3
 801026a:	f7f1 f881 	bl	8001370 <chThdExit>
}
 801026e:	b003      	add	sp, #12
 8010270:	f85d fb04 	ldr.w	pc, [sp], #4
 8010274:	f3af 8000 	nop.w
 8010278:	f3af 8000 	nop.w
 801027c:	f3af 8000 	nop.w

08010280 <thread2>:

#if CH_CFG_USE_MESSAGES || defined(__DOXYGEN__)
static THD_FUNCTION(thread2, p) {
 8010280:	b500      	push	{lr}
 8010282:	b085      	sub	sp, #20
 8010284:	9001      	str	r0, [sp, #4]
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 8010286:	f7f2 fcbb 	bl	8002c00 <chMsgWait>
 801028a:	9003      	str	r0, [sp, #12]
    msg = chMsgGet(tp);
 801028c:	9803      	ldr	r0, [sp, #12]
 801028e:	f7ff ffcf 	bl	8010230 <chMsgGet>
 8010292:	9002      	str	r0, [sp, #8]
    chMsgRelease(tp, msg);
 8010294:	9803      	ldr	r0, [sp, #12]
 8010296:	9902      	ldr	r1, [sp, #8]
 8010298:	f7f2 fcda 	bl	8002c50 <chMsgRelease>
  } while (msg);
 801029c:	9b02      	ldr	r3, [sp, #8]
 801029e:	2b00      	cmp	r3, #0
 80102a0:	d1f1      	bne.n	8010286 <thread2+0x6>
}
 80102a2:	b005      	add	sp, #20
 80102a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80102a8:	f3af 8000 	nop.w
 80102ac:	f3af 8000 	nop.w

080102b0 <msg_loop_test>:

#ifdef __GNUC__
__attribute__((noinline))
#endif
static unsigned int msg_loop_test(thread_t *tp) {
 80102b0:	b500      	push	{lr}
 80102b2:	b085      	sub	sp, #20
 80102b4:	9001      	str	r0, [sp, #4]

  uint32_t n = 0;
 80102b6:	2300      	movs	r3, #0
 80102b8:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80102ba:	f7fb fe71 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80102be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80102c2:	f7fb fe8d 	bl	800bfe0 <test_start_timer>
  do {
    (void)chMsgSend(tp, 1);
 80102c6:	9801      	ldr	r0, [sp, #4]
 80102c8:	2101      	movs	r1, #1
 80102ca:	f7f2 fc69 	bl	8002ba0 <chMsgSend>
    n++;
 80102ce:	9b03      	ldr	r3, [sp, #12]
 80102d0:	3301      	adds	r3, #1
 80102d2:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80102d4:	4b07      	ldr	r3, [pc, #28]	; (80102f4 <msg_loop_test+0x44>)
 80102d6:	781b      	ldrb	r3, [r3, #0]
 80102d8:	f083 0301 	eor.w	r3, r3, #1
 80102dc:	b2db      	uxtb	r3, r3
 80102de:	2b00      	cmp	r3, #0
 80102e0:	d1f1      	bne.n	80102c6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 80102e2:	9801      	ldr	r0, [sp, #4]
 80102e4:	2100      	movs	r1, #0
 80102e6:	f7f2 fc5b 	bl	8002ba0 <chMsgSend>
  return n;
 80102ea:	9b03      	ldr	r3, [sp, #12]
}
 80102ec:	4618      	mov	r0, r3
 80102ee:	b005      	add	sp, #20
 80102f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80102f4:	20002059 	.word	0x20002059
 80102f8:	f3af 8000 	nop.w
 80102fc:	f3af 8000 	nop.w

08010300 <bmk1_execute>:
 * A message server thread is created with a lower priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk1_execute(void) {
 8010300:	b510      	push	{r4, lr}
 8010302:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread2, NULL);
 8010304:	4b16      	ldr	r3, [pc, #88]	; (8010360 <bmk1_execute+0x60>)
 8010306:	681c      	ldr	r4, [r3, #0]
 8010308:	f7ff ff7a 	bl	8010200 <chThdGetPriorityX>
 801030c:	4603      	mov	r3, r0
 801030e:	3b01      	subs	r3, #1
 8010310:	2200      	movs	r2, #0
 8010312:	9200      	str	r2, [sp, #0]
 8010314:	4620      	mov	r0, r4
 8010316:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801031a:	461a      	mov	r2, r3
 801031c:	4b11      	ldr	r3, [pc, #68]	; (8010364 <bmk1_execute+0x64>)
 801031e:	f7f0 ff5f 	bl	80011e0 <chThdCreateStatic>
 8010322:	4602      	mov	r2, r0
 8010324:	4b10      	ldr	r3, [pc, #64]	; (8010368 <bmk1_execute+0x68>)
 8010326:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 8010328:	4b0f      	ldr	r3, [pc, #60]	; (8010368 <bmk1_execute+0x68>)
 801032a:	681b      	ldr	r3, [r3, #0]
 801032c:	4618      	mov	r0, r3
 801032e:	f7ff ffbf 	bl	80102b0 <msg_loop_test>
 8010332:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 8010334:	f7fb fe0c 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 8010338:	480c      	ldr	r0, [pc, #48]	; (801036c <bmk1_execute+0x6c>)
 801033a:	f7fb fcf9 	bl	800bd30 <test_print>
  test_printn(n);
 801033e:	9803      	ldr	r0, [sp, #12]
 8010340:	f7fb fcae 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 8010344:	480a      	ldr	r0, [pc, #40]	; (8010370 <bmk1_execute+0x70>)
 8010346:	f7fb fcf3 	bl	800bd30 <test_print>
  test_printn(n << 1);
 801034a:	9b03      	ldr	r3, [sp, #12]
 801034c:	005b      	lsls	r3, r3, #1
 801034e:	4618      	mov	r0, r3
 8010350:	f7fb fca6 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010354:	4807      	ldr	r0, [pc, #28]	; (8010374 <bmk1_execute+0x74>)
 8010356:	f7fb fd0b 	bl	800bd70 <test_println>
}
 801035a:	b004      	add	sp, #16
 801035c:	bd10      	pop	{r4, pc}
 801035e:	bf00      	nop
 8010360:	08019750 	.word	0x08019750
 8010364:	08010281 	.word	0x08010281
 8010368:	2000205c 	.word	0x2000205c
 801036c:	08019fe0 	.word	0x08019fe0
 8010370:	08019ff0 	.word	0x08019ff0
 8010374:	08019ffc 	.word	0x08019ffc
 8010378:	f3af 8000 	nop.w
 801037c:	f3af 8000 	nop.w

08010380 <bmk2_execute>:
 * A message server thread is created with an higher priority than the client
 * thread, the messages throughput per second is measured and the result
 * printed in the output log.
 */

static void bmk2_execute(void) {
 8010380:	b510      	push	{r4, lr}
 8010382:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8010384:	4b16      	ldr	r3, [pc, #88]	; (80103e0 <bmk2_execute+0x60>)
 8010386:	681c      	ldr	r4, [r3, #0]
 8010388:	f7ff ff3a 	bl	8010200 <chThdGetPriorityX>
 801038c:	4603      	mov	r3, r0
 801038e:	3301      	adds	r3, #1
 8010390:	2200      	movs	r2, #0
 8010392:	9200      	str	r2, [sp, #0]
 8010394:	4620      	mov	r0, r4
 8010396:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801039a:	461a      	mov	r2, r3
 801039c:	4b11      	ldr	r3, [pc, #68]	; (80103e4 <bmk2_execute+0x64>)
 801039e:	f7f0 ff1f 	bl	80011e0 <chThdCreateStatic>
 80103a2:	4602      	mov	r2, r0
 80103a4:	4b10      	ldr	r3, [pc, #64]	; (80103e8 <bmk2_execute+0x68>)
 80103a6:	601a      	str	r2, [r3, #0]
  n = msg_loop_test(threads[0]);
 80103a8:	4b0f      	ldr	r3, [pc, #60]	; (80103e8 <bmk2_execute+0x68>)
 80103aa:	681b      	ldr	r3, [r3, #0]
 80103ac:	4618      	mov	r0, r3
 80103ae:	f7ff ff7f 	bl	80102b0 <msg_loop_test>
 80103b2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80103b4:	f7fb fdcc 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 80103b8:	480c      	ldr	r0, [pc, #48]	; (80103ec <bmk2_execute+0x6c>)
 80103ba:	f7fb fcb9 	bl	800bd30 <test_print>
  test_printn(n);
 80103be:	9803      	ldr	r0, [sp, #12]
 80103c0:	f7fb fc6e 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 80103c4:	480a      	ldr	r0, [pc, #40]	; (80103f0 <bmk2_execute+0x70>)
 80103c6:	f7fb fcb3 	bl	800bd30 <test_print>
  test_printn(n << 1);
 80103ca:	9b03      	ldr	r3, [sp, #12]
 80103cc:	005b      	lsls	r3, r3, #1
 80103ce:	4618      	mov	r0, r3
 80103d0:	f7fb fc66 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 80103d4:	4807      	ldr	r0, [pc, #28]	; (80103f4 <bmk2_execute+0x74>)
 80103d6:	f7fb fccb 	bl	800bd70 <test_println>
}
 80103da:	b004      	add	sp, #16
 80103dc:	bd10      	pop	{r4, pc}
 80103de:	bf00      	nop
 80103e0:	08019750 	.word	0x08019750
 80103e4:	08010281 	.word	0x08010281
 80103e8:	2000205c 	.word	0x2000205c
 80103ec:	08019fe0 	.word	0x08019fe0
 80103f0:	08019ff0 	.word	0x08019ff0
 80103f4:	08019ffc 	.word	0x08019ffc
 80103f8:	f3af 8000 	nop.w
 80103fc:	f3af 8000 	nop.w

08010400 <bmk3_execute>:
 * thread, four lower priority threads crowd the ready list, the messages
 * throughput per second is measured while the ready list and the result
 * printed in the output log.
 */

static void bmk3_execute(void) {
 8010400:	b510      	push	{r4, lr}
 8010402:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread2, NULL);
 8010404:	4b3a      	ldr	r3, [pc, #232]	; (80104f0 <bmk3_execute+0xf0>)
 8010406:	681c      	ldr	r4, [r3, #0]
 8010408:	f7ff fefa 	bl	8010200 <chThdGetPriorityX>
 801040c:	4603      	mov	r3, r0
 801040e:	3301      	adds	r3, #1
 8010410:	2200      	movs	r2, #0
 8010412:	9200      	str	r2, [sp, #0]
 8010414:	4620      	mov	r0, r4
 8010416:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801041a:	461a      	mov	r2, r3
 801041c:	4b35      	ldr	r3, [pc, #212]	; (80104f4 <bmk3_execute+0xf4>)
 801041e:	f7f0 fedf 	bl	80011e0 <chThdCreateStatic>
 8010422:	4602      	mov	r2, r0
 8010424:	4b34      	ldr	r3, [pc, #208]	; (80104f8 <bmk3_execute+0xf8>)
 8010426:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, thread1, NULL);
 8010428:	4b31      	ldr	r3, [pc, #196]	; (80104f0 <bmk3_execute+0xf0>)
 801042a:	685c      	ldr	r4, [r3, #4]
 801042c:	f7ff fee8 	bl	8010200 <chThdGetPriorityX>
 8010430:	4603      	mov	r3, r0
 8010432:	3b02      	subs	r3, #2
 8010434:	2200      	movs	r2, #0
 8010436:	9200      	str	r2, [sp, #0]
 8010438:	4620      	mov	r0, r4
 801043a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801043e:	461a      	mov	r2, r3
 8010440:	4b2e      	ldr	r3, [pc, #184]	; (80104fc <bmk3_execute+0xfc>)
 8010442:	f7f0 fecd 	bl	80011e0 <chThdCreateStatic>
 8010446:	4602      	mov	r2, r0
 8010448:	4b2b      	ldr	r3, [pc, #172]	; (80104f8 <bmk3_execute+0xf8>)
 801044a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread1, NULL);
 801044c:	4b28      	ldr	r3, [pc, #160]	; (80104f0 <bmk3_execute+0xf0>)
 801044e:	689c      	ldr	r4, [r3, #8]
 8010450:	f7ff fed6 	bl	8010200 <chThdGetPriorityX>
 8010454:	4603      	mov	r3, r0
 8010456:	3b03      	subs	r3, #3
 8010458:	2200      	movs	r2, #0
 801045a:	9200      	str	r2, [sp, #0]
 801045c:	4620      	mov	r0, r4
 801045e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010462:	461a      	mov	r2, r3
 8010464:	4b25      	ldr	r3, [pc, #148]	; (80104fc <bmk3_execute+0xfc>)
 8010466:	f7f0 febb 	bl	80011e0 <chThdCreateStatic>
 801046a:	4602      	mov	r2, r0
 801046c:	4b22      	ldr	r3, [pc, #136]	; (80104f8 <bmk3_execute+0xf8>)
 801046e:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, thread1, NULL);
 8010470:	4b1f      	ldr	r3, [pc, #124]	; (80104f0 <bmk3_execute+0xf0>)
 8010472:	68dc      	ldr	r4, [r3, #12]
 8010474:	f7ff fec4 	bl	8010200 <chThdGetPriorityX>
 8010478:	4603      	mov	r3, r0
 801047a:	3b04      	subs	r3, #4
 801047c:	2200      	movs	r2, #0
 801047e:	9200      	str	r2, [sp, #0]
 8010480:	4620      	mov	r0, r4
 8010482:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010486:	461a      	mov	r2, r3
 8010488:	4b1c      	ldr	r3, [pc, #112]	; (80104fc <bmk3_execute+0xfc>)
 801048a:	f7f0 fea9 	bl	80011e0 <chThdCreateStatic>
 801048e:	4602      	mov	r2, r0
 8010490:	4b19      	ldr	r3, [pc, #100]	; (80104f8 <bmk3_execute+0xf8>)
 8010492:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, thread1, NULL);
 8010494:	4b16      	ldr	r3, [pc, #88]	; (80104f0 <bmk3_execute+0xf0>)
 8010496:	691c      	ldr	r4, [r3, #16]
 8010498:	f7ff feb2 	bl	8010200 <chThdGetPriorityX>
 801049c:	4603      	mov	r3, r0
 801049e:	3b05      	subs	r3, #5
 80104a0:	2200      	movs	r2, #0
 80104a2:	9200      	str	r2, [sp, #0]
 80104a4:	4620      	mov	r0, r4
 80104a6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80104aa:	461a      	mov	r2, r3
 80104ac:	4b13      	ldr	r3, [pc, #76]	; (80104fc <bmk3_execute+0xfc>)
 80104ae:	f7f0 fe97 	bl	80011e0 <chThdCreateStatic>
 80104b2:	4602      	mov	r2, r0
 80104b4:	4b10      	ldr	r3, [pc, #64]	; (80104f8 <bmk3_execute+0xf8>)
 80104b6:	611a      	str	r2, [r3, #16]
  n = msg_loop_test(threads[0]);
 80104b8:	4b0f      	ldr	r3, [pc, #60]	; (80104f8 <bmk3_execute+0xf8>)
 80104ba:	681b      	ldr	r3, [r3, #0]
 80104bc:	4618      	mov	r0, r3
 80104be:	f7ff fef7 	bl	80102b0 <msg_loop_test>
 80104c2:	9003      	str	r0, [sp, #12]
  test_wait_threads();
 80104c4:	f7fb fd44 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 80104c8:	480d      	ldr	r0, [pc, #52]	; (8010500 <bmk3_execute+0x100>)
 80104ca:	f7fb fc31 	bl	800bd30 <test_print>
  test_printn(n);
 80104ce:	9803      	ldr	r0, [sp, #12]
 80104d0:	f7fb fbe6 	bl	800bca0 <test_printn>
  test_print(" msgs/S, ");
 80104d4:	480b      	ldr	r0, [pc, #44]	; (8010504 <bmk3_execute+0x104>)
 80104d6:	f7fb fc2b 	bl	800bd30 <test_print>
  test_printn(n << 1);
 80104da:	9b03      	ldr	r3, [sp, #12]
 80104dc:	005b      	lsls	r3, r3, #1
 80104de:	4618      	mov	r0, r3
 80104e0:	f7fb fbde 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 80104e4:	4808      	ldr	r0, [pc, #32]	; (8010508 <bmk3_execute+0x108>)
 80104e6:	f7fb fc43 	bl	800bd70 <test_println>
}
 80104ea:	b004      	add	sp, #16
 80104ec:	bd10      	pop	{r4, pc}
 80104ee:	bf00      	nop
 80104f0:	08019750 	.word	0x08019750
 80104f4:	08010281 	.word	0x08010281
 80104f8:	2000205c 	.word	0x2000205c
 80104fc:	08010261 	.word	0x08010261
 8010500:	08019fe0 	.word	0x08019fe0
 8010504:	08019ff0 	.word	0x08019ff0
 8010508:	08019ffc 	.word	0x08019ffc
 801050c:	f3af 8000 	nop.w

08010510 <thread4>:
 * the thread is awakened as fast is possible by the tester thread.<br>
 * The Context Switch performance is calculated by measuring the number of
 * iterations after a second of continuous operations.
 */

static THD_FUNCTION(thread4, p) {
 8010510:	b500      	push	{lr}
 8010512:	b085      	sub	sp, #20
 8010514:	9001      	str	r0, [sp, #4]
  msg_t msg;
  thread_t *self = chThdGetSelfX();
 8010516:	f7ff fe6b 	bl	80101f0 <chThdGetSelfX>
 801051a:	9003      	str	r0, [sp, #12]

  (void)p;
  chSysLock();
 801051c:	f7ff fe58 	bl	80101d0 <chSysLock>
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 8010520:	2003      	movs	r0, #3
 8010522:	f7f0 fb65 	bl	8000bf0 <chSchGoSleepS>
    msg = self->p_u.rdymsg;
 8010526:	9b03      	ldr	r3, [sp, #12]
 8010528:	6a1b      	ldr	r3, [r3, #32]
 801052a:	9302      	str	r3, [sp, #8]
  } while (msg == MSG_OK);
 801052c:	9b02      	ldr	r3, [sp, #8]
 801052e:	2b00      	cmp	r3, #0
 8010530:	d0f6      	beq.n	8010520 <thread4+0x10>
  chSysUnlock();
 8010532:	f7ff fe55 	bl	80101e0 <chSysUnlock>
}
 8010536:	b005      	add	sp, #20
 8010538:	f85d fb04 	ldr.w	pc, [sp], #4
 801053c:	f3af 8000 	nop.w

08010540 <bmk4_execute>:

static void bmk4_execute(void) {
 8010540:	b510      	push	{r4, lr}
 8010542:	b084      	sub	sp, #16
  thread_t *tp;
  uint32_t n;

  tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 8010544:	4b29      	ldr	r3, [pc, #164]	; (80105ec <bmk4_execute+0xac>)
 8010546:	681c      	ldr	r4, [r3, #0]
 8010548:	f7ff fe5a 	bl	8010200 <chThdGetPriorityX>
 801054c:	4603      	mov	r3, r0
 801054e:	3301      	adds	r3, #1
 8010550:	2200      	movs	r2, #0
 8010552:	9200      	str	r2, [sp, #0]
 8010554:	4620      	mov	r0, r4
 8010556:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801055a:	461a      	mov	r2, r3
 801055c:	4b24      	ldr	r3, [pc, #144]	; (80105f0 <bmk4_execute+0xb0>)
 801055e:	f7f0 fe3f 	bl	80011e0 <chThdCreateStatic>
 8010562:	4602      	mov	r2, r0
 8010564:	4b23      	ldr	r3, [pc, #140]	; (80105f4 <bmk4_execute+0xb4>)
 8010566:	601a      	str	r2, [r3, #0]
 8010568:	4b22      	ldr	r3, [pc, #136]	; (80105f4 <bmk4_execute+0xb4>)
 801056a:	681b      	ldr	r3, [r3, #0]
 801056c:	9302      	str	r3, [sp, #8]
                                      thread4, NULL);
  n = 0;
 801056e:	2300      	movs	r3, #0
 8010570:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010572:	f7fb fd15 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010576:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 801057a:	f7fb fd31 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 801057e:	f7ff fe27 	bl	80101d0 <chSysLock>
    chSchWakeupS(tp, MSG_OK);
 8010582:	9802      	ldr	r0, [sp, #8]
 8010584:	2100      	movs	r1, #0
 8010586:	f7f0 fbd3 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 801058a:	9802      	ldr	r0, [sp, #8]
 801058c:	2100      	movs	r1, #0
 801058e:	f7f0 fbcf 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 8010592:	9802      	ldr	r0, [sp, #8]
 8010594:	2100      	movs	r1, #0
 8010596:	f7f0 fbcb 	bl	8000d30 <chSchWakeupS>
    chSchWakeupS(tp, MSG_OK);
 801059a:	9802      	ldr	r0, [sp, #8]
 801059c:	2100      	movs	r1, #0
 801059e:	f7f0 fbc7 	bl	8000d30 <chSchWakeupS>
    chSysUnlock();
 80105a2:	f7ff fe1d 	bl	80101e0 <chSysUnlock>
    n += 4;
 80105a6:	9b03      	ldr	r3, [sp, #12]
 80105a8:	3304      	adds	r3, #4
 80105aa:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80105ac:	4b12      	ldr	r3, [pc, #72]	; (80105f8 <bmk4_execute+0xb8>)
 80105ae:	781b      	ldrb	r3, [r3, #0]
 80105b0:	f083 0301 	eor.w	r3, r3, #1
 80105b4:	b2db      	uxtb	r3, r3
 80105b6:	2b00      	cmp	r3, #0
 80105b8:	d1e1      	bne.n	801057e <bmk4_execute+0x3e>
  chSysLock();
 80105ba:	f7ff fe09 	bl	80101d0 <chSysLock>
  chSchWakeupS(tp, MSG_TIMEOUT);
 80105be:	9802      	ldr	r0, [sp, #8]
 80105c0:	f04f 31ff 	mov.w	r1, #4294967295
 80105c4:	f7f0 fbb4 	bl	8000d30 <chSchWakeupS>
  chSysUnlock();
 80105c8:	f7ff fe0a 	bl	80101e0 <chSysUnlock>

  test_wait_threads();
 80105cc:	f7fb fcc0 	bl	800bf50 <test_wait_threads>
  test_print("--- Score : ");
 80105d0:	480a      	ldr	r0, [pc, #40]	; (80105fc <bmk4_execute+0xbc>)
 80105d2:	f7fb fbad 	bl	800bd30 <test_print>
  test_printn(n * 2);
 80105d6:	9b03      	ldr	r3, [sp, #12]
 80105d8:	005b      	lsls	r3, r3, #1
 80105da:	4618      	mov	r0, r3
 80105dc:	f7fb fb60 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 80105e0:	4807      	ldr	r0, [pc, #28]	; (8010600 <bmk4_execute+0xc0>)
 80105e2:	f7fb fbc5 	bl	800bd70 <test_println>
}
 80105e6:	b004      	add	sp, #16
 80105e8:	bd10      	pop	{r4, pc}
 80105ea:	bf00      	nop
 80105ec:	08019750 	.word	0x08019750
 80105f0:	08010511 	.word	0x08010511
 80105f4:	2000205c 	.word	0x2000205c
 80105f8:	20002059 	.word	0x20002059
 80105fc:	08019fe0 	.word	0x08019fe0
 8010600:	08019ffc 	.word	0x08019ffc
 8010604:	f3af 8000 	nop.w
 8010608:	f3af 8000 	nop.w
 801060c:	f3af 8000 	nop.w

08010610 <bmk5_execute>:
 * in each iteration.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk5_execute(void) {
 8010610:	b500      	push	{lr}
 8010612:	b087      	sub	sp, #28

  uint32_t n = 0;
 8010614:	2300      	movs	r3, #0
 8010616:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8010618:	4b18      	ldr	r3, [pc, #96]	; (801067c <bmk5_execute+0x6c>)
 801061a:	681b      	ldr	r3, [r3, #0]
 801061c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() - 1;
 801061e:	f7ff fdef 	bl	8010200 <chThdGetPriorityX>
 8010622:	4603      	mov	r3, r0
 8010624:	3b01      	subs	r3, #1
 8010626:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 8010628:	f7fb fcba 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 801062c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010630:	f7fb fcd6 	bl	800bfe0 <test_start_timer>
  do {
    chThdWait(chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL));
 8010634:	2300      	movs	r3, #0
 8010636:	9300      	str	r3, [sp, #0]
 8010638:	9804      	ldr	r0, [sp, #16]
 801063a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801063e:	9a03      	ldr	r2, [sp, #12]
 8010640:	4b0f      	ldr	r3, [pc, #60]	; (8010680 <bmk5_execute+0x70>)
 8010642:	f7f0 fdcd 	bl	80011e0 <chThdCreateStatic>
 8010646:	4603      	mov	r3, r0
 8010648:	4618      	mov	r0, r3
 801064a:	f7f0 fed9 	bl	8001400 <chThdWait>
    n++;
 801064e:	9b05      	ldr	r3, [sp, #20]
 8010650:	3301      	adds	r3, #1
 8010652:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010654:	4b0b      	ldr	r3, [pc, #44]	; (8010684 <bmk5_execute+0x74>)
 8010656:	781b      	ldrb	r3, [r3, #0]
 8010658:	f083 0301 	eor.w	r3, r3, #1
 801065c:	b2db      	uxtb	r3, r3
 801065e:	2b00      	cmp	r3, #0
 8010660:	d1e8      	bne.n	8010634 <bmk5_execute+0x24>
  test_print("--- Score : ");
 8010662:	4809      	ldr	r0, [pc, #36]	; (8010688 <bmk5_execute+0x78>)
 8010664:	f7fb fb64 	bl	800bd30 <test_print>
  test_printn(n);
 8010668:	9805      	ldr	r0, [sp, #20]
 801066a:	f7fb fb19 	bl	800bca0 <test_printn>
  test_println(" threads/S");
 801066e:	4807      	ldr	r0, [pc, #28]	; (801068c <bmk5_execute+0x7c>)
 8010670:	f7fb fb7e 	bl	800bd70 <test_println>
}
 8010674:	b007      	add	sp, #28
 8010676:	f85d fb04 	ldr.w	pc, [sp], #4
 801067a:	bf00      	nop
 801067c:	08019750 	.word	0x08019750
 8010680:	08010261 	.word	0x08010261
 8010684:	20002059 	.word	0x20002059
 8010688:	08019fe0 	.word	0x08019fe0
 801068c:	0801a0ac 	.word	0x0801a0ac

08010690 <bmk6_execute>:
 * terminate.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk6_execute(void) {
 8010690:	b500      	push	{lr}
 8010692:	b087      	sub	sp, #28

  uint32_t n = 0;
 8010694:	2300      	movs	r3, #0
 8010696:	9305      	str	r3, [sp, #20]
  void *wap = wa[0];
 8010698:	4b16      	ldr	r3, [pc, #88]	; (80106f4 <bmk6_execute+0x64>)
 801069a:	681b      	ldr	r3, [r3, #0]
 801069c:	9304      	str	r3, [sp, #16]
  tprio_t prio = chThdGetPriorityX() + 1;
 801069e:	f7ff fdaf 	bl	8010200 <chThdGetPriorityX>
 80106a2:	4603      	mov	r3, r0
 80106a4:	3301      	adds	r3, #1
 80106a6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80106a8:	f7fb fc7a 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80106ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80106b0:	f7fb fc96 	bl	800bfe0 <test_start_timer>
  do {
    chThdCreateStatic(wap, WA_SIZE, prio, thread1, NULL);
 80106b4:	2300      	movs	r3, #0
 80106b6:	9300      	str	r3, [sp, #0]
 80106b8:	9804      	ldr	r0, [sp, #16]
 80106ba:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80106be:	9a03      	ldr	r2, [sp, #12]
 80106c0:	4b0d      	ldr	r3, [pc, #52]	; (80106f8 <bmk6_execute+0x68>)
 80106c2:	f7f0 fd8d 	bl	80011e0 <chThdCreateStatic>
    n++;
 80106c6:	9b05      	ldr	r3, [sp, #20]
 80106c8:	3301      	adds	r3, #1
 80106ca:	9305      	str	r3, [sp, #20]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 80106cc:	4b0b      	ldr	r3, [pc, #44]	; (80106fc <bmk6_execute+0x6c>)
 80106ce:	781b      	ldrb	r3, [r3, #0]
 80106d0:	f083 0301 	eor.w	r3, r3, #1
 80106d4:	b2db      	uxtb	r3, r3
 80106d6:	2b00      	cmp	r3, #0
 80106d8:	d1ec      	bne.n	80106b4 <bmk6_execute+0x24>
  test_print("--- Score : ");
 80106da:	4809      	ldr	r0, [pc, #36]	; (8010700 <bmk6_execute+0x70>)
 80106dc:	f7fb fb28 	bl	800bd30 <test_print>
  test_printn(n);
 80106e0:	9805      	ldr	r0, [sp, #20]
 80106e2:	f7fb fadd 	bl	800bca0 <test_printn>
  test_println(" threads/S");
 80106e6:	4807      	ldr	r0, [pc, #28]	; (8010704 <bmk6_execute+0x74>)
 80106e8:	f7fb fb42 	bl	800bd70 <test_println>
}
 80106ec:	b007      	add	sp, #28
 80106ee:	f85d fb04 	ldr.w	pc, [sp], #4
 80106f2:	bf00      	nop
 80106f4:	08019750 	.word	0x08019750
 80106f8:	08010261 	.word	0x08010261
 80106fc:	20002059 	.word	0x20002059
 8010700:	08019fe0 	.word	0x08019fe0
 8010704:	0801a0ac 	.word	0x0801a0ac
 8010708:	f3af 8000 	nop.w
 801070c:	f3af 8000 	nop.w

08010710 <thread3>:
 * continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread3, p) {
 8010710:	b500      	push	{lr}
 8010712:	b083      	sub	sp, #12
 8010714:	9001      	str	r0, [sp, #4]

  (void)p;
  while (!chThdShouldTerminateX())
 8010716:	e002      	b.n	801071e <thread3+0xe>
    chSemWait(&sem1);
 8010718:	4806      	ldr	r0, [pc, #24]	; (8010734 <thread3+0x24>)
 801071a:	f7f1 fa19 	bl	8001b50 <chSemWait>
 */

static THD_FUNCTION(thread3, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 801071e:	f7ff fd77 	bl	8010210 <chThdShouldTerminateX>
 8010722:	4603      	mov	r3, r0
 8010724:	f083 0301 	eor.w	r3, r3, #1
 8010728:	b2db      	uxtb	r3, r3
 801072a:	2b00      	cmp	r3, #0
 801072c:	d1f4      	bne.n	8010718 <thread3+0x8>
    chSemWait(&sem1);
}
 801072e:	b003      	add	sp, #12
 8010730:	f85d fb04 	ldr.w	pc, [sp], #4
 8010734:	20001458 	.word	0x20001458
 8010738:	f3af 8000 	nop.w
 801073c:	f3af 8000 	nop.w

08010740 <bmk7_setup>:

static void bmk7_setup(void) {
 8010740:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 0);
 8010742:	4802      	ldr	r0, [pc, #8]	; (801074c <bmk7_setup+0xc>)
 8010744:	2100      	movs	r1, #0
 8010746:	f7f1 f9bb 	bl	8001ac0 <chSemObjectInit>
}
 801074a:	bd08      	pop	{r3, pc}
 801074c:	20001458 	.word	0x20001458

08010750 <bmk7_execute>:

static void bmk7_execute(void) {
 8010750:	b510      	push	{r4, lr}
 8010752:	b084      	sub	sp, #16
  uint32_t n;

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread3, NULL);
 8010754:	4b46      	ldr	r3, [pc, #280]	; (8010870 <bmk7_execute+0x120>)
 8010756:	681c      	ldr	r4, [r3, #0]
 8010758:	f7ff fd52 	bl	8010200 <chThdGetPriorityX>
 801075c:	4603      	mov	r3, r0
 801075e:	3305      	adds	r3, #5
 8010760:	2200      	movs	r2, #0
 8010762:	9200      	str	r2, [sp, #0]
 8010764:	4620      	mov	r0, r4
 8010766:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801076a:	461a      	mov	r2, r3
 801076c:	4b41      	ldr	r3, [pc, #260]	; (8010874 <bmk7_execute+0x124>)
 801076e:	f7f0 fd37 	bl	80011e0 <chThdCreateStatic>
 8010772:	4602      	mov	r2, r0
 8010774:	4b40      	ldr	r3, [pc, #256]	; (8010878 <bmk7_execute+0x128>)
 8010776:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, thread3, NULL);
 8010778:	4b3d      	ldr	r3, [pc, #244]	; (8010870 <bmk7_execute+0x120>)
 801077a:	685c      	ldr	r4, [r3, #4]
 801077c:	f7ff fd40 	bl	8010200 <chThdGetPriorityX>
 8010780:	4603      	mov	r3, r0
 8010782:	3304      	adds	r3, #4
 8010784:	2200      	movs	r2, #0
 8010786:	9200      	str	r2, [sp, #0]
 8010788:	4620      	mov	r0, r4
 801078a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801078e:	461a      	mov	r2, r3
 8010790:	4b38      	ldr	r3, [pc, #224]	; (8010874 <bmk7_execute+0x124>)
 8010792:	f7f0 fd25 	bl	80011e0 <chThdCreateStatic>
 8010796:	4602      	mov	r2, r0
 8010798:	4b37      	ldr	r3, [pc, #220]	; (8010878 <bmk7_execute+0x128>)
 801079a:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread3, NULL);
 801079c:	4b34      	ldr	r3, [pc, #208]	; (8010870 <bmk7_execute+0x120>)
 801079e:	689c      	ldr	r4, [r3, #8]
 80107a0:	f7ff fd2e 	bl	8010200 <chThdGetPriorityX>
 80107a4:	4603      	mov	r3, r0
 80107a6:	3303      	adds	r3, #3
 80107a8:	2200      	movs	r2, #0
 80107aa:	9200      	str	r2, [sp, #0]
 80107ac:	4620      	mov	r0, r4
 80107ae:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107b2:	461a      	mov	r2, r3
 80107b4:	4b2f      	ldr	r3, [pc, #188]	; (8010874 <bmk7_execute+0x124>)
 80107b6:	f7f0 fd13 	bl	80011e0 <chThdCreateStatic>
 80107ba:	4602      	mov	r2, r0
 80107bc:	4b2e      	ldr	r3, [pc, #184]	; (8010878 <bmk7_execute+0x128>)
 80107be:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, thread3, NULL);
 80107c0:	4b2b      	ldr	r3, [pc, #172]	; (8010870 <bmk7_execute+0x120>)
 80107c2:	68dc      	ldr	r4, [r3, #12]
 80107c4:	f7ff fd1c 	bl	8010200 <chThdGetPriorityX>
 80107c8:	4603      	mov	r3, r0
 80107ca:	3302      	adds	r3, #2
 80107cc:	2200      	movs	r2, #0
 80107ce:	9200      	str	r2, [sp, #0]
 80107d0:	4620      	mov	r0, r4
 80107d2:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107d6:	461a      	mov	r2, r3
 80107d8:	4b26      	ldr	r3, [pc, #152]	; (8010874 <bmk7_execute+0x124>)
 80107da:	f7f0 fd01 	bl	80011e0 <chThdCreateStatic>
 80107de:	4602      	mov	r2, r0
 80107e0:	4b25      	ldr	r3, [pc, #148]	; (8010878 <bmk7_execute+0x128>)
 80107e2:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, thread3, NULL);
 80107e4:	4b22      	ldr	r3, [pc, #136]	; (8010870 <bmk7_execute+0x120>)
 80107e6:	691c      	ldr	r4, [r3, #16]
 80107e8:	f7ff fd0a 	bl	8010200 <chThdGetPriorityX>
 80107ec:	4603      	mov	r3, r0
 80107ee:	3301      	adds	r3, #1
 80107f0:	2200      	movs	r2, #0
 80107f2:	9200      	str	r2, [sp, #0]
 80107f4:	4620      	mov	r0, r4
 80107f6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80107fa:	461a      	mov	r2, r3
 80107fc:	4b1d      	ldr	r3, [pc, #116]	; (8010874 <bmk7_execute+0x124>)
 80107fe:	f7f0 fcef 	bl	80011e0 <chThdCreateStatic>
 8010802:	4602      	mov	r2, r0
 8010804:	4b1c      	ldr	r3, [pc, #112]	; (8010878 <bmk7_execute+0x128>)
 8010806:	611a      	str	r2, [r3, #16]

  n = 0;
 8010808:	2300      	movs	r3, #0
 801080a:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 801080c:	f7fb fbc8 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010810:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010814:	f7fb fbe4 	bl	800bfe0 <test_start_timer>
  do {
    chSemReset(&sem1, 0);
 8010818:	4818      	ldr	r0, [pc, #96]	; (801087c <bmk7_execute+0x12c>)
 801081a:	2100      	movs	r1, #0
 801081c:	f7f1 f960 	bl	8001ae0 <chSemReset>
    n++;
 8010820:	9b03      	ldr	r3, [sp, #12]
 8010822:	3301      	adds	r3, #1
 8010824:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010826:	4b16      	ldr	r3, [pc, #88]	; (8010880 <bmk7_execute+0x130>)
 8010828:	781b      	ldrb	r3, [r3, #0]
 801082a:	f083 0301 	eor.w	r3, r3, #1
 801082e:	b2db      	uxtb	r3, r3
 8010830:	2b00      	cmp	r3, #0
 8010832:	d1f1      	bne.n	8010818 <bmk7_execute+0xc8>
  test_terminate_threads();
 8010834:	f7fb fb6c 	bl	800bf10 <test_terminate_threads>
  chSemReset(&sem1, 0);
 8010838:	4810      	ldr	r0, [pc, #64]	; (801087c <bmk7_execute+0x12c>)
 801083a:	2100      	movs	r1, #0
 801083c:	f7f1 f950 	bl	8001ae0 <chSemReset>
  test_wait_threads();
 8010840:	f7fb fb86 	bl	800bf50 <test_wait_threads>

  test_print("--- Score : ");
 8010844:	480f      	ldr	r0, [pc, #60]	; (8010884 <bmk7_execute+0x134>)
 8010846:	f7fb fa73 	bl	800bd30 <test_print>
  test_printn(n);
 801084a:	9803      	ldr	r0, [sp, #12]
 801084c:	f7fb fa28 	bl	800bca0 <test_printn>
  test_print(" reschedules/S, ");
 8010850:	480d      	ldr	r0, [pc, #52]	; (8010888 <bmk7_execute+0x138>)
 8010852:	f7fb fa6d 	bl	800bd30 <test_print>
  test_printn(n * 6);
 8010856:	9a03      	ldr	r2, [sp, #12]
 8010858:	4613      	mov	r3, r2
 801085a:	005b      	lsls	r3, r3, #1
 801085c:	4413      	add	r3, r2
 801085e:	005b      	lsls	r3, r3, #1
 8010860:	4618      	mov	r0, r3
 8010862:	f7fb fa1d 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 8010866:	4809      	ldr	r0, [pc, #36]	; (801088c <bmk7_execute+0x13c>)
 8010868:	f7fb fa82 	bl	800bd70 <test_println>
}
 801086c:	b004      	add	sp, #16
 801086e:	bd10      	pop	{r4, pc}
 8010870:	08019750 	.word	0x08019750
 8010874:	08010711 	.word	0x08010711
 8010878:	2000205c 	.word	0x2000205c
 801087c:	20001458 	.word	0x20001458
 8010880:	20002059 	.word	0x20002059
 8010884:	08019fe0 	.word	0x08019fe0
 8010888:	0801a118 	.word	0x0801a118
 801088c:	08019ffc 	.word	0x08019ffc

08010890 <thread8>:
 * variable and yields.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static THD_FUNCTION(thread8, p) {
 8010890:	b500      	push	{lr}
 8010892:	b083      	sub	sp, #12
 8010894:	9001      	str	r0, [sp, #4]

  do {
    chThdYield();
 8010896:	f7f0 fd63 	bl	8001360 <chThdYield>
    chThdYield();
 801089a:	f7f0 fd61 	bl	8001360 <chThdYield>
    chThdYield();
 801089e:	f7f0 fd5f 	bl	8001360 <chThdYield>
    chThdYield();
 80108a2:	f7f0 fd5d 	bl	8001360 <chThdYield>
    (*(uint32_t *)p) += 4;
 80108a6:	9b01      	ldr	r3, [sp, #4]
 80108a8:	681b      	ldr	r3, [r3, #0]
 80108aa:	1d1a      	adds	r2, r3, #4
 80108ac:	9b01      	ldr	r3, [sp, #4]
 80108ae:	601a      	str	r2, [r3, #0]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 80108b0:	f7ff fcae 	bl	8010210 <chThdShouldTerminateX>
 80108b4:	4603      	mov	r3, r0
 80108b6:	f083 0301 	eor.w	r3, r3, #1
 80108ba:	b2db      	uxtb	r3, r3
 80108bc:	2b00      	cmp	r3, #0
 80108be:	d1ea      	bne.n	8010896 <thread8+0x6>
}
 80108c0:	b003      	add	sp, #12
 80108c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80108c6:	bf00      	nop
 80108c8:	f3af 8000 	nop.w
 80108cc:	f3af 8000 	nop.w

080108d0 <bmk8_execute>:

static void bmk8_execute(void) {
 80108d0:	b510      	push	{r4, lr}
 80108d2:	b084      	sub	sp, #16
  uint32_t n;

  n = 0;
 80108d4:	2300      	movs	r3, #0
 80108d6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80108d8:	f7fb fb62 	bl	800bfa0 <test_wait_tick>

  threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 80108dc:	4b36      	ldr	r3, [pc, #216]	; (80109b8 <bmk8_execute+0xe8>)
 80108de:	681c      	ldr	r4, [r3, #0]
 80108e0:	f7ff fc8e 	bl	8010200 <chThdGetPriorityX>
 80108e4:	4603      	mov	r3, r0
 80108e6:	3b01      	subs	r3, #1
 80108e8:	aa03      	add	r2, sp, #12
 80108ea:	9200      	str	r2, [sp, #0]
 80108ec:	4620      	mov	r0, r4
 80108ee:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80108f2:	461a      	mov	r2, r3
 80108f4:	4b31      	ldr	r3, [pc, #196]	; (80109bc <bmk8_execute+0xec>)
 80108f6:	f7f0 fc73 	bl	80011e0 <chThdCreateStatic>
 80108fa:	4602      	mov	r2, r0
 80108fc:	4b30      	ldr	r3, [pc, #192]	; (80109c0 <bmk8_execute+0xf0>)
 80108fe:	601a      	str	r2, [r3, #0]
  threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010900:	4b2d      	ldr	r3, [pc, #180]	; (80109b8 <bmk8_execute+0xe8>)
 8010902:	685c      	ldr	r4, [r3, #4]
 8010904:	f7ff fc7c 	bl	8010200 <chThdGetPriorityX>
 8010908:	4603      	mov	r3, r0
 801090a:	3b01      	subs	r3, #1
 801090c:	aa03      	add	r2, sp, #12
 801090e:	9200      	str	r2, [sp, #0]
 8010910:	4620      	mov	r0, r4
 8010912:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010916:	461a      	mov	r2, r3
 8010918:	4b28      	ldr	r3, [pc, #160]	; (80109bc <bmk8_execute+0xec>)
 801091a:	f7f0 fc61 	bl	80011e0 <chThdCreateStatic>
 801091e:	4602      	mov	r2, r0
 8010920:	4b27      	ldr	r3, [pc, #156]	; (80109c0 <bmk8_execute+0xf0>)
 8010922:	605a      	str	r2, [r3, #4]
  threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010924:	4b24      	ldr	r3, [pc, #144]	; (80109b8 <bmk8_execute+0xe8>)
 8010926:	689c      	ldr	r4, [r3, #8]
 8010928:	f7ff fc6a 	bl	8010200 <chThdGetPriorityX>
 801092c:	4603      	mov	r3, r0
 801092e:	3b01      	subs	r3, #1
 8010930:	aa03      	add	r2, sp, #12
 8010932:	9200      	str	r2, [sp, #0]
 8010934:	4620      	mov	r0, r4
 8010936:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801093a:	461a      	mov	r2, r3
 801093c:	4b1f      	ldr	r3, [pc, #124]	; (80109bc <bmk8_execute+0xec>)
 801093e:	f7f0 fc4f 	bl	80011e0 <chThdCreateStatic>
 8010942:	4602      	mov	r2, r0
 8010944:	4b1e      	ldr	r3, [pc, #120]	; (80109c0 <bmk8_execute+0xf0>)
 8010946:	609a      	str	r2, [r3, #8]
  threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 8010948:	4b1b      	ldr	r3, [pc, #108]	; (80109b8 <bmk8_execute+0xe8>)
 801094a:	68dc      	ldr	r4, [r3, #12]
 801094c:	f7ff fc58 	bl	8010200 <chThdGetPriorityX>
 8010950:	4603      	mov	r3, r0
 8010952:	3b01      	subs	r3, #1
 8010954:	aa03      	add	r2, sp, #12
 8010956:	9200      	str	r2, [sp, #0]
 8010958:	4620      	mov	r0, r4
 801095a:	f44f 71a4 	mov.w	r1, #328	; 0x148
 801095e:	461a      	mov	r2, r3
 8010960:	4b16      	ldr	r3, [pc, #88]	; (80109bc <bmk8_execute+0xec>)
 8010962:	f7f0 fc3d 	bl	80011e0 <chThdCreateStatic>
 8010966:	4602      	mov	r2, r0
 8010968:	4b15      	ldr	r3, [pc, #84]	; (80109c0 <bmk8_execute+0xf0>)
 801096a:	60da      	str	r2, [r3, #12]
  threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread8, (void *)&n);
 801096c:	4b12      	ldr	r3, [pc, #72]	; (80109b8 <bmk8_execute+0xe8>)
 801096e:	691c      	ldr	r4, [r3, #16]
 8010970:	f7ff fc46 	bl	8010200 <chThdGetPriorityX>
 8010974:	4603      	mov	r3, r0
 8010976:	3b01      	subs	r3, #1
 8010978:	aa03      	add	r2, sp, #12
 801097a:	9200      	str	r2, [sp, #0]
 801097c:	4620      	mov	r0, r4
 801097e:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8010982:	461a      	mov	r2, r3
 8010984:	4b0d      	ldr	r3, [pc, #52]	; (80109bc <bmk8_execute+0xec>)
 8010986:	f7f0 fc2b 	bl	80011e0 <chThdCreateStatic>
 801098a:	4602      	mov	r2, r0
 801098c:	4b0c      	ldr	r3, [pc, #48]	; (80109c0 <bmk8_execute+0xf0>)
 801098e:	611a      	str	r2, [r3, #16]

  chThdSleepSeconds(1);
 8010990:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010994:	f7f0 fc9c 	bl	80012d0 <chThdSleep>
  test_terminate_threads();
 8010998:	f7fb faba 	bl	800bf10 <test_terminate_threads>
  test_wait_threads();
 801099c:	f7fb fad8 	bl	800bf50 <test_wait_threads>

  test_print("--- Score : ");
 80109a0:	4808      	ldr	r0, [pc, #32]	; (80109c4 <bmk8_execute+0xf4>)
 80109a2:	f7fb f9c5 	bl	800bd30 <test_print>
  test_printn(n);
 80109a6:	9b03      	ldr	r3, [sp, #12]
 80109a8:	4618      	mov	r0, r3
 80109aa:	f7fb f979 	bl	800bca0 <test_printn>
  test_println(" ctxswc/S");
 80109ae:	4806      	ldr	r0, [pc, #24]	; (80109c8 <bmk8_execute+0xf8>)
 80109b0:	f7fb f9de 	bl	800bd70 <test_println>
}
 80109b4:	b004      	add	sp, #16
 80109b6:	bd10      	pop	{r4, pc}
 80109b8:	08019750 	.word	0x08019750
 80109bc:	08010891 	.word	0x08010891
 80109c0:	2000205c 	.word	0x2000205c
 80109c4:	08019fe0 	.word	0x08019fe0
 80109c8:	08019ffc 	.word	0x08019ffc
 80109cc:	f3af 8000 	nop.w

080109d0 <bmk9_execute>:
 * loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk9_execute(void) {
 80109d0:	b500      	push	{lr}
 80109d2:	b085      	sub	sp, #20
  uint32_t n;
  static uint8_t ib[16];
  static input_queue_t iq;

  chIQObjectInit(&iq, ib, sizeof(ib), NULL, NULL);
 80109d4:	2300      	movs	r3, #0
 80109d6:	9300      	str	r3, [sp, #0]
 80109d8:	4822      	ldr	r0, [pc, #136]	; (8010a64 <bmk9_execute+0x94>)
 80109da:	4923      	ldr	r1, [pc, #140]	; (8010a68 <bmk9_execute+0x98>)
 80109dc:	2210      	movs	r2, #16
 80109de:	2300      	movs	r3, #0
 80109e0:	f7f2 fbde 	bl	80031a0 <chIQObjectInit>
  n = 0;
 80109e4:	2300      	movs	r3, #0
 80109e6:	9303      	str	r3, [sp, #12]
  test_wait_tick();
 80109e8:	f7fb fada 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 80109ec:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80109f0:	f7fb faf6 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 80109f4:	f7ff fbec 	bl	80101d0 <chSysLock>
    chIQPutI(&iq, 0);
 80109f8:	481a      	ldr	r0, [pc, #104]	; (8010a64 <bmk9_execute+0x94>)
 80109fa:	2100      	movs	r1, #0
 80109fc:	f7f2 fc10 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 1);
 8010a00:	4818      	ldr	r0, [pc, #96]	; (8010a64 <bmk9_execute+0x94>)
 8010a02:	2101      	movs	r1, #1
 8010a04:	f7f2 fc0c 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 2);
 8010a08:	4816      	ldr	r0, [pc, #88]	; (8010a64 <bmk9_execute+0x94>)
 8010a0a:	2102      	movs	r1, #2
 8010a0c:	f7f2 fc08 	bl	8003220 <chIQPutI>
    chIQPutI(&iq, 3);
 8010a10:	4814      	ldr	r0, [pc, #80]	; (8010a64 <bmk9_execute+0x94>)
 8010a12:	2103      	movs	r1, #3
 8010a14:	f7f2 fc04 	bl	8003220 <chIQPutI>
    chSysUnlock();
 8010a18:	f7ff fbe2 	bl	80101e0 <chSysUnlock>
    (void)chIQGet(&iq);
 8010a1c:	4811      	ldr	r0, [pc, #68]	; (8010a64 <bmk9_execute+0x94>)
 8010a1e:	f7ff fc0f 	bl	8010240 <chIQGet>
    (void)chIQGet(&iq);
 8010a22:	4810      	ldr	r0, [pc, #64]	; (8010a64 <bmk9_execute+0x94>)
 8010a24:	f7ff fc0c 	bl	8010240 <chIQGet>
    (void)chIQGet(&iq);
 8010a28:	480e      	ldr	r0, [pc, #56]	; (8010a64 <bmk9_execute+0x94>)
 8010a2a:	f7ff fc09 	bl	8010240 <chIQGet>
    (void)chIQGet(&iq);
 8010a2e:	480d      	ldr	r0, [pc, #52]	; (8010a64 <bmk9_execute+0x94>)
 8010a30:	f7ff fc06 	bl	8010240 <chIQGet>
    n++;
 8010a34:	9b03      	ldr	r3, [sp, #12]
 8010a36:	3301      	adds	r3, #1
 8010a38:	9303      	str	r3, [sp, #12]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010a3a:	4b0c      	ldr	r3, [pc, #48]	; (8010a6c <bmk9_execute+0x9c>)
 8010a3c:	781b      	ldrb	r3, [r3, #0]
 8010a3e:	f083 0301 	eor.w	r3, r3, #1
 8010a42:	b2db      	uxtb	r3, r3
 8010a44:	2b00      	cmp	r3, #0
 8010a46:	d1d5      	bne.n	80109f4 <bmk9_execute+0x24>
  test_print("--- Score : ");
 8010a48:	4809      	ldr	r0, [pc, #36]	; (8010a70 <bmk9_execute+0xa0>)
 8010a4a:	f7fb f971 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010a4e:	9b03      	ldr	r3, [sp, #12]
 8010a50:	009b      	lsls	r3, r3, #2
 8010a52:	4618      	mov	r0, r3
 8010a54:	f7fb f924 	bl	800bca0 <test_printn>
  test_println(" bytes/S");
 8010a58:	4806      	ldr	r0, [pc, #24]	; (8010a74 <bmk9_execute+0xa4>)
 8010a5a:	f7fb f989 	bl	800bd70 <test_println>
}
 8010a5e:	b005      	add	sp, #20
 8010a60:	f85d fb04 	ldr.w	pc, [sp], #4
 8010a64:	20001474 	.word	0x20001474
 8010a68:	20001498 	.word	0x20001498
 8010a6c:	20002059 	.word	0x20002059
 8010a70:	08019fe0 	.word	0x08019fe0
 8010a74:	0801a1a0 	.word	0x0801a1a0
 8010a78:	f3af 8000 	nop.w
 8010a7c:	f3af 8000 	nop.w

08010a80 <tmo>:
 * A virtual timer is set and immediately reset into a continuous loop.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void tmo(void *param) {(void)param;}
 8010a80:	b082      	sub	sp, #8
 8010a82:	9001      	str	r0, [sp, #4]
 8010a84:	b002      	add	sp, #8
 8010a86:	4770      	bx	lr
 8010a88:	f3af 8000 	nop.w
 8010a8c:	f3af 8000 	nop.w

08010a90 <bmk10_execute>:

static void bmk10_execute(void) {
 8010a90:	b500      	push	{lr}
 8010a92:	b083      	sub	sp, #12
  static virtual_timer_t vt1, vt2;
  uint32_t n = 0;
 8010a94:	2300      	movs	r3, #0
 8010a96:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010a98:	f7fb fa82 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010a9c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010aa0:	f7fb fa9e 	bl	800bfe0 <test_start_timer>
  do {
    chSysLock();
 8010aa4:	f7ff fb94 	bl	80101d0 <chSysLock>
    chVTDoSetI(&vt1, 1, tmo, NULL);
 8010aa8:	4816      	ldr	r0, [pc, #88]	; (8010b04 <bmk10_execute+0x74>)
 8010aaa:	2101      	movs	r1, #1
 8010aac:	4a16      	ldr	r2, [pc, #88]	; (8010b08 <bmk10_execute+0x78>)
 8010aae:	2300      	movs	r3, #0
 8010ab0:	f7ef ff6e 	bl	8000990 <chVTDoSetI>
    chVTDoSetI(&vt2, 10000, tmo, NULL);
 8010ab4:	4815      	ldr	r0, [pc, #84]	; (8010b0c <bmk10_execute+0x7c>)
 8010ab6:	f242 7110 	movw	r1, #10000	; 0x2710
 8010aba:	4a13      	ldr	r2, [pc, #76]	; (8010b08 <bmk10_execute+0x78>)
 8010abc:	2300      	movs	r3, #0
 8010abe:	f7ef ff67 	bl	8000990 <chVTDoSetI>
    chVTDoResetI(&vt1);
 8010ac2:	4810      	ldr	r0, [pc, #64]	; (8010b04 <bmk10_execute+0x74>)
 8010ac4:	f7ef ffa4 	bl	8000a10 <chVTDoResetI>
    chVTDoResetI(&vt2);
 8010ac8:	4810      	ldr	r0, [pc, #64]	; (8010b0c <bmk10_execute+0x7c>)
 8010aca:	f7ef ffa1 	bl	8000a10 <chVTDoResetI>
    chSysUnlock();
 8010ace:	f7ff fb87 	bl	80101e0 <chSysUnlock>
    n++;
 8010ad2:	9b01      	ldr	r3, [sp, #4]
 8010ad4:	3301      	adds	r3, #1
 8010ad6:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010ad8:	4b0d      	ldr	r3, [pc, #52]	; (8010b10 <bmk10_execute+0x80>)
 8010ada:	781b      	ldrb	r3, [r3, #0]
 8010adc:	f083 0301 	eor.w	r3, r3, #1
 8010ae0:	b2db      	uxtb	r3, r3
 8010ae2:	2b00      	cmp	r3, #0
 8010ae4:	d1de      	bne.n	8010aa4 <bmk10_execute+0x14>
  test_print("--- Score : ");
 8010ae6:	480b      	ldr	r0, [pc, #44]	; (8010b14 <bmk10_execute+0x84>)
 8010ae8:	f7fb f922 	bl	800bd30 <test_print>
  test_printn(n * 2);
 8010aec:	9b01      	ldr	r3, [sp, #4]
 8010aee:	005b      	lsls	r3, r3, #1
 8010af0:	4618      	mov	r0, r3
 8010af2:	f7fb f8d5 	bl	800bca0 <test_printn>
  test_println(" timers/S");
 8010af6:	4808      	ldr	r0, [pc, #32]	; (8010b18 <bmk10_execute+0x88>)
 8010af8:	f7fb f93a 	bl	800bd70 <test_println>
}
 8010afc:	b003      	add	sp, #12
 8010afe:	f85d fb04 	ldr.w	pc, [sp], #4
 8010b02:	bf00      	nop
 8010b04:	200014a8 	.word	0x200014a8
 8010b08:	08010a81 	.word	0x08010a81
 8010b0c:	200014bc 	.word	0x200014bc
 8010b10:	20002059 	.word	0x20002059
 8010b14:	08019fe0 	.word	0x08019fe0
 8010b18:	0801a1e0 	.word	0x0801a1e0
 8010b1c:	f3af 8000 	nop.w

08010b20 <bmk11_setup>:
 * Switch happens because the counter is always non negative.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk11_setup(void) {
 8010b20:	b508      	push	{r3, lr}

  chSemObjectInit(&sem1, 1);
 8010b22:	4802      	ldr	r0, [pc, #8]	; (8010b2c <bmk11_setup+0xc>)
 8010b24:	2101      	movs	r1, #1
 8010b26:	f7f0 ffcb 	bl	8001ac0 <chSemObjectInit>
}
 8010b2a:	bd08      	pop	{r3, pc}
 8010b2c:	20001458 	.word	0x20001458

08010b30 <bmk11_execute>:

static void bmk11_execute(void) {
 8010b30:	b500      	push	{lr}
 8010b32:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010b34:	2300      	movs	r3, #0
 8010b36:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010b38:	f7fb fa32 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010b3c:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010b40:	f7fb fa4e 	bl	800bfe0 <test_start_timer>
  do {
    chSemWait(&sem1);
 8010b44:	4817      	ldr	r0, [pc, #92]	; (8010ba4 <bmk11_execute+0x74>)
 8010b46:	f7f1 f803 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b4a:	4816      	ldr	r0, [pc, #88]	; (8010ba4 <bmk11_execute+0x74>)
 8010b4c:	f7f1 f880 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b50:	4814      	ldr	r0, [pc, #80]	; (8010ba4 <bmk11_execute+0x74>)
 8010b52:	f7f0 fffd 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b56:	4813      	ldr	r0, [pc, #76]	; (8010ba4 <bmk11_execute+0x74>)
 8010b58:	f7f1 f87a 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b5c:	4811      	ldr	r0, [pc, #68]	; (8010ba4 <bmk11_execute+0x74>)
 8010b5e:	f7f0 fff7 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b62:	4810      	ldr	r0, [pc, #64]	; (8010ba4 <bmk11_execute+0x74>)
 8010b64:	f7f1 f874 	bl	8001c50 <chSemSignal>
    chSemWait(&sem1);
 8010b68:	480e      	ldr	r0, [pc, #56]	; (8010ba4 <bmk11_execute+0x74>)
 8010b6a:	f7f0 fff1 	bl	8001b50 <chSemWait>
    chSemSignal(&sem1);
 8010b6e:	480d      	ldr	r0, [pc, #52]	; (8010ba4 <bmk11_execute+0x74>)
 8010b70:	f7f1 f86e 	bl	8001c50 <chSemSignal>
    n++;
 8010b74:	9b01      	ldr	r3, [sp, #4]
 8010b76:	3301      	adds	r3, #1
 8010b78:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010b7a:	4b0b      	ldr	r3, [pc, #44]	; (8010ba8 <bmk11_execute+0x78>)
 8010b7c:	781b      	ldrb	r3, [r3, #0]
 8010b7e:	f083 0301 	eor.w	r3, r3, #1
 8010b82:	b2db      	uxtb	r3, r3
 8010b84:	2b00      	cmp	r3, #0
 8010b86:	d1dd      	bne.n	8010b44 <bmk11_execute+0x14>
  test_print("--- Score : ");
 8010b88:	4808      	ldr	r0, [pc, #32]	; (8010bac <bmk11_execute+0x7c>)
 8010b8a:	f7fb f8d1 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010b8e:	9b01      	ldr	r3, [sp, #4]
 8010b90:	009b      	lsls	r3, r3, #2
 8010b92:	4618      	mov	r0, r3
 8010b94:	f7fb f884 	bl	800bca0 <test_printn>
  test_println(" wait+signal/S");
 8010b98:	4805      	ldr	r0, [pc, #20]	; (8010bb0 <bmk11_execute+0x80>)
 8010b9a:	f7fb f8e9 	bl	800bd70 <test_println>
}
 8010b9e:	b003      	add	sp, #12
 8010ba0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ba4:	20001458 	.word	0x20001458
 8010ba8:	20002059 	.word	0x20002059
 8010bac:	08019fe0 	.word	0x08019fe0
 8010bb0:	0801a220 	.word	0x0801a220
 8010bb4:	f3af 8000 	nop.w
 8010bb8:	f3af 8000 	nop.w
 8010bbc:	f3af 8000 	nop.w

08010bc0 <bmk12_setup>:
 * because there are no other threads asking for the mutex.<br>
 * The performance is calculated by measuring the number of iterations after
 * a second of continuous operations.
 */

static void bmk12_setup(void) {
 8010bc0:	b508      	push	{r3, lr}

  chMtxObjectInit(&mtx1);
 8010bc2:	4802      	ldr	r0, [pc, #8]	; (8010bcc <bmk12_setup+0xc>)
 8010bc4:	f7f1 f994 	bl	8001ef0 <chMtxObjectInit>
}
 8010bc8:	bd08      	pop	{r3, pc}
 8010bca:	bf00      	nop
 8010bcc:	20001464 	.word	0x20001464

08010bd0 <bmk12_execute>:

static void bmk12_execute(void) {
 8010bd0:	b500      	push	{lr}
 8010bd2:	b083      	sub	sp, #12
  uint32_t n = 0;
 8010bd4:	2300      	movs	r3, #0
 8010bd6:	9301      	str	r3, [sp, #4]

  test_wait_tick();
 8010bd8:	f7fb f9e2 	bl	800bfa0 <test_wait_tick>
  test_start_timer(1000);
 8010bdc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8010be0:	f7fb f9fe 	bl	800bfe0 <test_start_timer>
  do {
    chMtxLock(&mtx1);
 8010be4:	4817      	ldr	r0, [pc, #92]	; (8010c44 <bmk12_execute+0x74>)
 8010be6:	f7f1 f993 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010bea:	4816      	ldr	r0, [pc, #88]	; (8010c44 <bmk12_execute+0x74>)
 8010bec:	f7f1 fa38 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010bf0:	4814      	ldr	r0, [pc, #80]	; (8010c44 <bmk12_execute+0x74>)
 8010bf2:	f7f1 f98d 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010bf6:	4813      	ldr	r0, [pc, #76]	; (8010c44 <bmk12_execute+0x74>)
 8010bf8:	f7f1 fa32 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010bfc:	4811      	ldr	r0, [pc, #68]	; (8010c44 <bmk12_execute+0x74>)
 8010bfe:	f7f1 f987 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c02:	4810      	ldr	r0, [pc, #64]	; (8010c44 <bmk12_execute+0x74>)
 8010c04:	f7f1 fa2c 	bl	8002060 <chMtxUnlock>
    chMtxLock(&mtx1);
 8010c08:	480e      	ldr	r0, [pc, #56]	; (8010c44 <bmk12_execute+0x74>)
 8010c0a:	f7f1 f981 	bl	8001f10 <chMtxLock>
    chMtxUnlock(&mtx1);
 8010c0e:	480d      	ldr	r0, [pc, #52]	; (8010c44 <bmk12_execute+0x74>)
 8010c10:	f7f1 fa26 	bl	8002060 <chMtxUnlock>
    n++;
 8010c14:	9b01      	ldr	r3, [sp, #4]
 8010c16:	3301      	adds	r3, #1
 8010c18:	9301      	str	r3, [sp, #4]
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (!test_timer_done);
 8010c1a:	4b0b      	ldr	r3, [pc, #44]	; (8010c48 <bmk12_execute+0x78>)
 8010c1c:	781b      	ldrb	r3, [r3, #0]
 8010c1e:	f083 0301 	eor.w	r3, r3, #1
 8010c22:	b2db      	uxtb	r3, r3
 8010c24:	2b00      	cmp	r3, #0
 8010c26:	d1dd      	bne.n	8010be4 <bmk12_execute+0x14>
  test_print("--- Score : ");
 8010c28:	4808      	ldr	r0, [pc, #32]	; (8010c4c <bmk12_execute+0x7c>)
 8010c2a:	f7fb f881 	bl	800bd30 <test_print>
  test_printn(n * 4);
 8010c2e:	9b01      	ldr	r3, [sp, #4]
 8010c30:	009b      	lsls	r3, r3, #2
 8010c32:	4618      	mov	r0, r3
 8010c34:	f7fb f834 	bl	800bca0 <test_printn>
  test_println(" lock+unlock/S");
 8010c38:	4805      	ldr	r0, [pc, #20]	; (8010c50 <bmk12_execute+0x80>)
 8010c3a:	f7fb f899 	bl	800bd70 <test_println>
}
 8010c3e:	b003      	add	sp, #12
 8010c40:	f85d fb04 	ldr.w	pc, [sp], #4
 8010c44:	20001464 	.word	0x20001464
 8010c48:	20002059 	.word	0x20002059
 8010c4c:	08019fe0 	.word	0x08019fe0
 8010c50:	0801a264 	.word	0x0801a264
 8010c54:	f3af 8000 	nop.w
 8010c58:	f3af 8000 	nop.w
 8010c5c:	f3af 8000 	nop.w

08010c60 <bmk13_execute>:
 *
 * <h2>Description</h2>
 * The memory size of the various kernel objects is printed.
 */

static void bmk13_execute(void) {
 8010c60:	b508      	push	{r3, lr}

  test_print("--- System: ");
 8010c62:	482e      	ldr	r0, [pc, #184]	; (8010d1c <bmk13_execute+0xbc>)
 8010c64:	f7fb f864 	bl	800bd30 <test_print>
  test_printn(sizeof(ch_system_t));
 8010c68:	f44f 70a8 	mov.w	r0, #336	; 0x150
 8010c6c:	f7fb f818 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010c70:	482b      	ldr	r0, [pc, #172]	; (8010d20 <bmk13_execute+0xc0>)
 8010c72:	f7fb f87d 	bl	800bd70 <test_println>
  test_print("--- Thread: ");
 8010c76:	482b      	ldr	r0, [pc, #172]	; (8010d24 <bmk13_execute+0xc4>)
 8010c78:	f7fb f85a 	bl	800bd30 <test_print>
  test_printn(sizeof(thread_t));
 8010c7c:	2044      	movs	r0, #68	; 0x44
 8010c7e:	f7fb f80f 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010c82:	4827      	ldr	r0, [pc, #156]	; (8010d20 <bmk13_execute+0xc0>)
 8010c84:	f7fb f874 	bl	800bd70 <test_println>
  test_print("--- Timer : ");
 8010c88:	4827      	ldr	r0, [pc, #156]	; (8010d28 <bmk13_execute+0xc8>)
 8010c8a:	f7fb f851 	bl	800bd30 <test_print>
  test_printn(sizeof(virtual_timer_t));
 8010c8e:	2014      	movs	r0, #20
 8010c90:	f7fb f806 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010c94:	4822      	ldr	r0, [pc, #136]	; (8010d20 <bmk13_execute+0xc0>)
 8010c96:	f7fb f86b 	bl	800bd70 <test_println>
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
  test_print("--- Semaph: ");
 8010c9a:	4824      	ldr	r0, [pc, #144]	; (8010d2c <bmk13_execute+0xcc>)
 8010c9c:	f7fb f848 	bl	800bd30 <test_print>
  test_printn(sizeof(semaphore_t));
 8010ca0:	200c      	movs	r0, #12
 8010ca2:	f7fa fffd 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010ca6:	481e      	ldr	r0, [pc, #120]	; (8010d20 <bmk13_execute+0xc0>)
 8010ca8:	f7fb f862 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
  test_print("--- EventS: ");
 8010cac:	4820      	ldr	r0, [pc, #128]	; (8010d30 <bmk13_execute+0xd0>)
 8010cae:	f7fb f83f 	bl	800bd30 <test_print>
  test_printn(sizeof(event_source_t));
 8010cb2:	2004      	movs	r0, #4
 8010cb4:	f7fa fff4 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cb8:	4819      	ldr	r0, [pc, #100]	; (8010d20 <bmk13_execute+0xc0>)
 8010cba:	f7fb f859 	bl	800bd70 <test_println>
  test_print("--- EventL: ");
 8010cbe:	481d      	ldr	r0, [pc, #116]	; (8010d34 <bmk13_execute+0xd4>)
 8010cc0:	f7fb f836 	bl	800bd30 <test_print>
  test_printn(sizeof(event_listener_t));
 8010cc4:	2014      	movs	r0, #20
 8010cc6:	f7fa ffeb 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cca:	4815      	ldr	r0, [pc, #84]	; (8010d20 <bmk13_execute+0xc0>)
 8010ccc:	f7fb f850 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
  test_print("--- Mutex : ");
 8010cd0:	4819      	ldr	r0, [pc, #100]	; (8010d38 <bmk13_execute+0xd8>)
 8010cd2:	f7fb f82d 	bl	800bd30 <test_print>
  test_printn(sizeof(mutex_t));
 8010cd6:	2010      	movs	r0, #16
 8010cd8:	f7fa ffe2 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cdc:	4810      	ldr	r0, [pc, #64]	; (8010d20 <bmk13_execute+0xc0>)
 8010cde:	f7fb f847 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
  test_print("--- CondV.: ");
 8010ce2:	4816      	ldr	r0, [pc, #88]	; (8010d3c <bmk13_execute+0xdc>)
 8010ce4:	f7fb f824 	bl	800bd30 <test_print>
  test_printn(sizeof(condition_variable_t));
 8010ce8:	2008      	movs	r0, #8
 8010cea:	f7fa ffd9 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010cee:	480c      	ldr	r0, [pc, #48]	; (8010d20 <bmk13_execute+0xc0>)
 8010cf0:	f7fb f83e 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_QUEUES || defined(__DOXYGEN__)
  test_print("--- Queue : ");
 8010cf4:	4812      	ldr	r0, [pc, #72]	; (8010d40 <bmk13_execute+0xe0>)
 8010cf6:	f7fb f81b 	bl	800bd30 <test_print>
  test_printn(sizeof(io_queue_t));
 8010cfa:	2024      	movs	r0, #36	; 0x24
 8010cfc:	f7fa ffd0 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d00:	4807      	ldr	r0, [pc, #28]	; (8010d20 <bmk13_execute+0xc0>)
 8010d02:	f7fb f835 	bl	800bd70 <test_println>
#endif
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
  test_print("--- MailB.: ");
 8010d06:	480f      	ldr	r0, [pc, #60]	; (8010d44 <bmk13_execute+0xe4>)
 8010d08:	f7fb f812 	bl	800bd30 <test_print>
  test_printn(sizeof(mailbox_t));
 8010d0c:	2028      	movs	r0, #40	; 0x28
 8010d0e:	f7fa ffc7 	bl	800bca0 <test_printn>
  test_println(" bytes");
 8010d12:	4803      	ldr	r0, [pc, #12]	; (8010d20 <bmk13_execute+0xc0>)
 8010d14:	f7fb f82c 	bl	800bd70 <test_println>
#endif
}
 8010d18:	bd08      	pop	{r3, pc}
 8010d1a:	bf00      	nop
 8010d1c:	0801a2a4 	.word	0x0801a2a4
 8010d20:	0801a2b4 	.word	0x0801a2b4
 8010d24:	0801a2bc 	.word	0x0801a2bc
 8010d28:	0801a2cc 	.word	0x0801a2cc
 8010d2c:	0801a2dc 	.word	0x0801a2dc
 8010d30:	0801a2ec 	.word	0x0801a2ec
 8010d34:	0801a2fc 	.word	0x0801a2fc
 8010d38:	0801a30c 	.word	0x0801a30c
 8010d3c:	0801a31c 	.word	0x0801a31c
 8010d40:	0801a32c 	.word	0x0801a32c
 8010d44:	0801a33c 	.word	0x0801a33c
 8010d48:	f3af 8000 	nop.w
 8010d4c:	f3af 8000 	nop.w

08010d50 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8010d50:	b082      	sub	sp, #8
 8010d52:	2320      	movs	r3, #32
 8010d54:	9301      	str	r3, [sp, #4]
 8010d56:	9b01      	ldr	r3, [sp, #4]
 8010d58:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010d5c:	b002      	add	sp, #8
 8010d5e:	4770      	bx	lr

08010d60 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8010d60:	b082      	sub	sp, #8
 8010d62:	2300      	movs	r3, #0
 8010d64:	9301      	str	r3, [sp, #4]
 8010d66:	9b01      	ldr	r3, [sp, #4]
 8010d68:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 8010d6c:	b002      	add	sp, #8
 8010d6e:	4770      	bx	lr

08010d70 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @details In this port this function raises the base priority to kernel
 *          level.
 * @note    Same as @p port_lock() in this port.
 */
static inline void port_lock_from_isr(void) {
 8010d70:	b508      	push	{r3, lr}

  port_lock();
 8010d72:	f7ff ffed 	bl	8010d50 <port_lock>
}
 8010d76:	bd08      	pop	{r3, pc}
 8010d78:	f3af 8000 	nop.w
 8010d7c:	f3af 8000 	nop.w

08010d80 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @details In this port this function lowers the base priority to user
 *          level.
 * @note    Same as @p port_unlock() in this port.
 */
static inline void port_unlock_from_isr(void) {
 8010d80:	b508      	push	{r3, lr}

  port_unlock();
 8010d82:	f7ff ffed 	bl	8010d60 <port_unlock>
}
 8010d86:	bd08      	pop	{r3, pc}
 8010d88:	f3af 8000 	nop.w
 8010d8c:	f3af 8000 	nop.w

08010d90 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 8010d90:	b508      	push	{r3, lr}

  port_lock();
 8010d92:	f7ff ffdd 	bl	8010d50 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 8010d96:	bd08      	pop	{r3, pc}
 8010d98:	f3af 8000 	nop.w
 8010d9c:	f3af 8000 	nop.w

08010da0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 8010da0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 8010da2:	f7ff ffdd 	bl	8010d60 <port_unlock>
}
 8010da6:	bd08      	pop	{r3, pc}
 8010da8:	f3af 8000 	nop.w
 8010dac:	f3af 8000 	nop.w

08010db0 <chSysLockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysLockFromISR(void) {
 8010db0:	b508      	push	{r3, lr}

  port_lock_from_isr();
 8010db2:	f7ff ffdd 	bl	8010d70 <port_lock_from_isr>
  _stats_start_measure_crit_isr();
  _dbg_check_lock_from_isr();
}
 8010db6:	bd08      	pop	{r3, pc}
 8010db8:	f3af 8000 	nop.w
 8010dbc:	f3af 8000 	nop.w

08010dc0 <chSysUnlockFromISR>:
 *          syscall from an interrupt handler.
 * @note    This API must be invoked exclusively from interrupt handlers.
 *
 * @special
 */
static inline void chSysUnlockFromISR(void) {
 8010dc0:	b508      	push	{r3, lr}

  _dbg_check_unlock_from_isr();
  _stats_stop_measure_crit_isr();
  port_unlock_from_isr();
 8010dc2:	f7ff ffdd 	bl	8010d80 <port_unlock_from_isr>
}
 8010dc6:	bd08      	pop	{r3, pc}
 8010dc8:	f3af 8000 	nop.w
 8010dcc:	f3af 8000 	nop.w

08010dd0 <chVTObjectInit>:
 *
 * @param[out] vtp      the @p virtual_timer_t structure pointer
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {
 8010dd0:	b082      	sub	sp, #8
 8010dd2:	9001      	str	r0, [sp, #4]

  vtp->vt_func = NULL;
 8010dd4:	9b01      	ldr	r3, [sp, #4]
 8010dd6:	2200      	movs	r2, #0
 8010dd8:	60da      	str	r2, [r3, #12]
}
 8010dda:	b002      	add	sp, #8
 8010ddc:	4770      	bx	lr
 8010dde:	bf00      	nop

08010de0 <chVTIsArmedI>:
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 * @return              true if the timer is armed.
 *
 * @iclass
 */
static inline bool chVTIsArmedI(virtual_timer_t *vtp) {
 8010de0:	b082      	sub	sp, #8
 8010de2:	9001      	str	r0, [sp, #4]

  chDbgCheckClassI();

  return (bool)(vtp->vt_func != NULL);
 8010de4:	9b01      	ldr	r3, [sp, #4]
 8010de6:	68db      	ldr	r3, [r3, #12]
 8010de8:	2b00      	cmp	r3, #0
 8010dea:	bf0c      	ite	eq
 8010dec:	2300      	moveq	r3, #0
 8010dee:	2301      	movne	r3, #1
 8010df0:	b2db      	uxtb	r3, r3
}
 8010df2:	4618      	mov	r0, r3
 8010df4:	b002      	add	sp, #8
 8010df6:	4770      	bx	lr
 8010df8:	f3af 8000 	nop.w
 8010dfc:	f3af 8000 	nop.w

08010e00 <chVTResetI>:
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {
 8010e00:	b500      	push	{lr}
 8010e02:	b083      	sub	sp, #12
 8010e04:	9001      	str	r0, [sp, #4]

  if (chVTIsArmedI(vtp)) {
 8010e06:	9801      	ldr	r0, [sp, #4]
 8010e08:	f7ff ffea 	bl	8010de0 <chVTIsArmedI>
 8010e0c:	4603      	mov	r3, r0
 8010e0e:	2b00      	cmp	r3, #0
 8010e10:	d002      	beq.n	8010e18 <chVTResetI+0x18>
    chVTDoResetI(vtp);
 8010e12:	9801      	ldr	r0, [sp, #4]
 8010e14:	f7ef fdfc 	bl	8000a10 <chVTDoResetI>
  }
}
 8010e18:	b003      	add	sp, #12
 8010e1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e1e:	bf00      	nop

08010e20 <chVTSetI>:
 *                      function
 *
 * @iclass
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {
 8010e20:	b500      	push	{lr}
 8010e22:	b085      	sub	sp, #20
 8010e24:	9003      	str	r0, [sp, #12]
 8010e26:	9102      	str	r1, [sp, #8]
 8010e28:	9201      	str	r2, [sp, #4]
 8010e2a:	9300      	str	r3, [sp, #0]

  chVTResetI(vtp);
 8010e2c:	9803      	ldr	r0, [sp, #12]
 8010e2e:	f7ff ffe7 	bl	8010e00 <chVTResetI>
  chVTDoSetI(vtp, delay, vtfunc, par);
 8010e32:	9803      	ldr	r0, [sp, #12]
 8010e34:	9902      	ldr	r1, [sp, #8]
 8010e36:	9a01      	ldr	r2, [sp, #4]
 8010e38:	9b00      	ldr	r3, [sp, #0]
 8010e3a:	f7ef fda9 	bl	8000990 <chVTDoSetI>
}
 8010e3e:	b005      	add	sp, #20
 8010e40:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e44:	f3af 8000 	nop.w
 8010e48:	f3af 8000 	nop.w
 8010e4c:	f3af 8000 	nop.w

08010e50 <chVTSet>:
 *                      function
 *
 * @api
 */
static inline void chVTSet(virtual_timer_t *vtp, systime_t delay,
                           vtfunc_t vtfunc, void *par) {
 8010e50:	b500      	push	{lr}
 8010e52:	b085      	sub	sp, #20
 8010e54:	9003      	str	r0, [sp, #12]
 8010e56:	9102      	str	r1, [sp, #8]
 8010e58:	9201      	str	r2, [sp, #4]
 8010e5a:	9300      	str	r3, [sp, #0]

  chSysLock();
 8010e5c:	f7ff ff98 	bl	8010d90 <chSysLock>
  chVTSetI(vtp, delay, vtfunc, par);
 8010e60:	9803      	ldr	r0, [sp, #12]
 8010e62:	9902      	ldr	r1, [sp, #8]
 8010e64:	9a01      	ldr	r2, [sp, #4]
 8010e66:	9b00      	ldr	r3, [sp, #0]
 8010e68:	f7ff ffda 	bl	8010e20 <chVTSetI>
  chSysUnlock();
 8010e6c:	f7ff ff98 	bl	8010da0 <chSysUnlock>
}
 8010e70:	b005      	add	sp, #20
 8010e72:	f85d fb04 	ldr.w	pc, [sp], #4
 8010e76:	bf00      	nop
 8010e78:	f3af 8000 	nop.w
 8010e7c:	f3af 8000 	nop.w

08010e80 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8010e80:	b082      	sub	sp, #8
 8010e82:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8010e84:	9b01      	ldr	r3, [sp, #4]
 8010e86:	9a01      	ldr	r2, [sp, #4]
 8010e88:	601a      	str	r2, [r3, #0]
}
 8010e8a:	b002      	add	sp, #8
 8010e8c:	4770      	bx	lr
 8010e8e:	bf00      	nop

08010e90 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8010e90:	b500      	push	{lr}
 8010e92:	b083      	sub	sp, #12
 8010e94:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8010e96:	9801      	ldr	r0, [sp, #4]
 8010e98:	2100      	movs	r1, #0
 8010e9a:	f7f1 fbf1 	bl	8002680 <chEvtBroadcastFlagsI>
}
 8010e9e:	b003      	add	sp, #12
 8010ea0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ea4:	f3af 8000 	nop.w
 8010ea8:	f3af 8000 	nop.w
 8010eac:	f3af 8000 	nop.w

08010eb0 <tmrcb>:

/*===========================================================================*/
/* Module local functions.                                                   */
/*===========================================================================*/

static void tmrcb(void *p) {
 8010eb0:	b500      	push	{lr}
 8010eb2:	b085      	sub	sp, #20
 8010eb4:	9001      	str	r0, [sp, #4]
  event_timer_t *etp = p;
 8010eb6:	9b01      	ldr	r3, [sp, #4]
 8010eb8:	9303      	str	r3, [sp, #12]

  chSysLockFromISR();
 8010eba:	f7ff ff79 	bl	8010db0 <chSysLockFromISR>
  chEvtBroadcastI(&etp->et_es);
 8010ebe:	9b03      	ldr	r3, [sp, #12]
 8010ec0:	3314      	adds	r3, #20
 8010ec2:	4618      	mov	r0, r3
 8010ec4:	f7ff ffe4 	bl	8010e90 <chEvtBroadcastI>
  chVTDoSetI(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010ec8:	9a03      	ldr	r2, [sp, #12]
 8010eca:	9b03      	ldr	r3, [sp, #12]
 8010ecc:	699b      	ldr	r3, [r3, #24]
 8010ece:	4610      	mov	r0, r2
 8010ed0:	4619      	mov	r1, r3
 8010ed2:	4a04      	ldr	r2, [pc, #16]	; (8010ee4 <tmrcb+0x34>)
 8010ed4:	9b03      	ldr	r3, [sp, #12]
 8010ed6:	f7ef fd5b 	bl	8000990 <chVTDoSetI>
  chSysUnlockFromISR();
 8010eda:	f7ff ff71 	bl	8010dc0 <chSysUnlockFromISR>
}
 8010ede:	b005      	add	sp, #20
 8010ee0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010ee4:	08010eb1 	.word	0x08010eb1
 8010ee8:	f3af 8000 	nop.w
 8010eec:	f3af 8000 	nop.w

08010ef0 <evtObjectInit>:
 * @brief Initializes an @p event_timer_t structure.
 *
 * @param[out] etp      the @p event_timer_t structure to be initialized
 * @param[in] time      the interval in system ticks
 */
void evtObjectInit(event_timer_t *etp, systime_t time) {
 8010ef0:	b500      	push	{lr}
 8010ef2:	b083      	sub	sp, #12
 8010ef4:	9001      	str	r0, [sp, #4]
 8010ef6:	9100      	str	r1, [sp, #0]

  chEvtObjectInit(&etp->et_es);
 8010ef8:	9b01      	ldr	r3, [sp, #4]
 8010efa:	3314      	adds	r3, #20
 8010efc:	4618      	mov	r0, r3
 8010efe:	f7ff ffbf 	bl	8010e80 <chEvtObjectInit>
  chVTObjectInit(&etp->et_vt);
 8010f02:	9b01      	ldr	r3, [sp, #4]
 8010f04:	4618      	mov	r0, r3
 8010f06:	f7ff ff63 	bl	8010dd0 <chVTObjectInit>
  etp->et_interval = time;
 8010f0a:	9b01      	ldr	r3, [sp, #4]
 8010f0c:	9a00      	ldr	r2, [sp, #0]
 8010f0e:	619a      	str	r2, [r3, #24]
}
 8010f10:	b003      	add	sp, #12
 8010f12:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f16:	bf00      	nop
 8010f18:	f3af 8000 	nop.w
 8010f1c:	f3af 8000 	nop.w

08010f20 <evtStart>:
 * @brief   Starts the timer
 * @details If the timer was already running then the function has no effect.
 *
 * @param[in] etp       pointer to an initialized @p event_timer_t structure.
 */
void evtStart(event_timer_t *etp) {
 8010f20:	b500      	push	{lr}
 8010f22:	b083      	sub	sp, #12
 8010f24:	9001      	str	r0, [sp, #4]

  chVTSet(&etp->et_vt, etp->et_interval, tmrcb, etp);
 8010f26:	9a01      	ldr	r2, [sp, #4]
 8010f28:	9b01      	ldr	r3, [sp, #4]
 8010f2a:	699b      	ldr	r3, [r3, #24]
 8010f2c:	4610      	mov	r0, r2
 8010f2e:	4619      	mov	r1, r3
 8010f30:	4a03      	ldr	r2, [pc, #12]	; (8010f40 <evtStart+0x20>)
 8010f32:	9b01      	ldr	r3, [sp, #4]
 8010f34:	f7ff ff8c 	bl	8010e50 <chVTSet>
}
 8010f38:	b003      	add	sp, #12
 8010f3a:	f85d fb04 	ldr.w	pc, [sp], #4
 8010f3e:	bf00      	nop
 8010f40:	08010eb1 	.word	0x08010eb1
 8010f44:	f3af 8000 	nop.w
 8010f48:	f3af 8000 	nop.w
 8010f4c:	f3af 8000 	nop.w

08010f50 <writes>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static size_t writes(void *ip, const uint8_t *bp, size_t n) {
 8010f50:	b500      	push	{lr}
 8010f52:	b087      	sub	sp, #28
 8010f54:	9003      	str	r0, [sp, #12]
 8010f56:	9102      	str	r1, [sp, #8]
 8010f58:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 8010f5a:	9b03      	ldr	r3, [sp, #12]
 8010f5c:	9305      	str	r3, [sp, #20]

  if (msp->size - msp->eos < n)
 8010f5e:	9b05      	ldr	r3, [sp, #20]
 8010f60:	689a      	ldr	r2, [r3, #8]
 8010f62:	9b05      	ldr	r3, [sp, #20]
 8010f64:	68db      	ldr	r3, [r3, #12]
 8010f66:	1ad2      	subs	r2, r2, r3
 8010f68:	9b01      	ldr	r3, [sp, #4]
 8010f6a:	429a      	cmp	r2, r3
 8010f6c:	d205      	bcs.n	8010f7a <writes+0x2a>
    n = msp->size - msp->eos;
 8010f6e:	9b05      	ldr	r3, [sp, #20]
 8010f70:	689a      	ldr	r2, [r3, #8]
 8010f72:	9b05      	ldr	r3, [sp, #20]
 8010f74:	68db      	ldr	r3, [r3, #12]
 8010f76:	1ad3      	subs	r3, r2, r3
 8010f78:	9301      	str	r3, [sp, #4]
  memcpy(msp->buffer + msp->eos, bp, n);
 8010f7a:	9b05      	ldr	r3, [sp, #20]
 8010f7c:	685a      	ldr	r2, [r3, #4]
 8010f7e:	9b05      	ldr	r3, [sp, #20]
 8010f80:	68db      	ldr	r3, [r3, #12]
 8010f82:	4413      	add	r3, r2
 8010f84:	4618      	mov	r0, r3
 8010f86:	9902      	ldr	r1, [sp, #8]
 8010f88:	9a01      	ldr	r2, [sp, #4]
 8010f8a:	f005 fce1 	bl	8016950 <memcpy>
  msp->eos += n;
 8010f8e:	9b05      	ldr	r3, [sp, #20]
 8010f90:	68da      	ldr	r2, [r3, #12]
 8010f92:	9b01      	ldr	r3, [sp, #4]
 8010f94:	441a      	add	r2, r3
 8010f96:	9b05      	ldr	r3, [sp, #20]
 8010f98:	60da      	str	r2, [r3, #12]
  return n;
 8010f9a:	9b01      	ldr	r3, [sp, #4]
}
 8010f9c:	4618      	mov	r0, r3
 8010f9e:	b007      	add	sp, #28
 8010fa0:	f85d fb04 	ldr.w	pc, [sp], #4
 8010fa4:	f3af 8000 	nop.w
 8010fa8:	f3af 8000 	nop.w
 8010fac:	f3af 8000 	nop.w

08010fb0 <reads>:

static size_t reads(void *ip, uint8_t *bp, size_t n) {
 8010fb0:	b500      	push	{lr}
 8010fb2:	b087      	sub	sp, #28
 8010fb4:	9003      	str	r0, [sp, #12]
 8010fb6:	9102      	str	r1, [sp, #8]
 8010fb8:	9201      	str	r2, [sp, #4]
  MemoryStream *msp = ip;
 8010fba:	9b03      	ldr	r3, [sp, #12]
 8010fbc:	9305      	str	r3, [sp, #20]

  if (msp->eos - msp->offset < n)
 8010fbe:	9b05      	ldr	r3, [sp, #20]
 8010fc0:	68da      	ldr	r2, [r3, #12]
 8010fc2:	9b05      	ldr	r3, [sp, #20]
 8010fc4:	691b      	ldr	r3, [r3, #16]
 8010fc6:	1ad2      	subs	r2, r2, r3
 8010fc8:	9b01      	ldr	r3, [sp, #4]
 8010fca:	429a      	cmp	r2, r3
 8010fcc:	d205      	bcs.n	8010fda <reads+0x2a>
    n = msp->eos - msp->offset;
 8010fce:	9b05      	ldr	r3, [sp, #20]
 8010fd0:	68da      	ldr	r2, [r3, #12]
 8010fd2:	9b05      	ldr	r3, [sp, #20]
 8010fd4:	691b      	ldr	r3, [r3, #16]
 8010fd6:	1ad3      	subs	r3, r2, r3
 8010fd8:	9301      	str	r3, [sp, #4]
  memcpy(bp, msp->buffer + msp->offset, n);
 8010fda:	9b05      	ldr	r3, [sp, #20]
 8010fdc:	685a      	ldr	r2, [r3, #4]
 8010fde:	9b05      	ldr	r3, [sp, #20]
 8010fe0:	691b      	ldr	r3, [r3, #16]
 8010fe2:	4413      	add	r3, r2
 8010fe4:	9802      	ldr	r0, [sp, #8]
 8010fe6:	4619      	mov	r1, r3
 8010fe8:	9a01      	ldr	r2, [sp, #4]
 8010fea:	f005 fcb1 	bl	8016950 <memcpy>
  msp->offset += n;
 8010fee:	9b05      	ldr	r3, [sp, #20]
 8010ff0:	691a      	ldr	r2, [r3, #16]
 8010ff2:	9b01      	ldr	r3, [sp, #4]
 8010ff4:	441a      	add	r2, r3
 8010ff6:	9b05      	ldr	r3, [sp, #20]
 8010ff8:	611a      	str	r2, [r3, #16]
  return n;
 8010ffa:	9b01      	ldr	r3, [sp, #4]
}
 8010ffc:	4618      	mov	r0, r3
 8010ffe:	b007      	add	sp, #28
 8011000:	f85d fb04 	ldr.w	pc, [sp], #4
 8011004:	f3af 8000 	nop.w
 8011008:	f3af 8000 	nop.w
 801100c:	f3af 8000 	nop.w

08011010 <put>:

static msg_t put(void *ip, uint8_t b) {
 8011010:	b084      	sub	sp, #16
 8011012:	9001      	str	r0, [sp, #4]
 8011014:	460b      	mov	r3, r1
 8011016:	f88d 3003 	strb.w	r3, [sp, #3]
  MemoryStream *msp = ip;
 801101a:	9b01      	ldr	r3, [sp, #4]
 801101c:	9303      	str	r3, [sp, #12]

  if (msp->size - msp->eos <= 0)
 801101e:	9b03      	ldr	r3, [sp, #12]
 8011020:	689a      	ldr	r2, [r3, #8]
 8011022:	9b03      	ldr	r3, [sp, #12]
 8011024:	68db      	ldr	r3, [r3, #12]
 8011026:	429a      	cmp	r2, r3
 8011028:	d102      	bne.n	8011030 <put+0x20>
    return MSG_RESET;
 801102a:	f06f 0301 	mvn.w	r3, #1
 801102e:	e00d      	b.n	801104c <put+0x3c>
  *(msp->buffer + msp->eos) = b;
 8011030:	9b03      	ldr	r3, [sp, #12]
 8011032:	685a      	ldr	r2, [r3, #4]
 8011034:	9b03      	ldr	r3, [sp, #12]
 8011036:	68db      	ldr	r3, [r3, #12]
 8011038:	4413      	add	r3, r2
 801103a:	f89d 2003 	ldrb.w	r2, [sp, #3]
 801103e:	701a      	strb	r2, [r3, #0]
  msp->eos += 1;
 8011040:	9b03      	ldr	r3, [sp, #12]
 8011042:	68db      	ldr	r3, [r3, #12]
 8011044:	1c5a      	adds	r2, r3, #1
 8011046:	9b03      	ldr	r3, [sp, #12]
 8011048:	60da      	str	r2, [r3, #12]
  return MSG_OK;
 801104a:	2300      	movs	r3, #0
}
 801104c:	4618      	mov	r0, r3
 801104e:	b004      	add	sp, #16
 8011050:	4770      	bx	lr
 8011052:	bf00      	nop
 8011054:	f3af 8000 	nop.w
 8011058:	f3af 8000 	nop.w
 801105c:	f3af 8000 	nop.w

08011060 <get>:

static msg_t get(void *ip) {
 8011060:	b084      	sub	sp, #16
 8011062:	9001      	str	r0, [sp, #4]
  uint8_t b;
  MemoryStream *msp = ip;
 8011064:	9b01      	ldr	r3, [sp, #4]
 8011066:	9303      	str	r3, [sp, #12]

  if (msp->eos - msp->offset <= 0)
 8011068:	9b03      	ldr	r3, [sp, #12]
 801106a:	68da      	ldr	r2, [r3, #12]
 801106c:	9b03      	ldr	r3, [sp, #12]
 801106e:	691b      	ldr	r3, [r3, #16]
 8011070:	429a      	cmp	r2, r3
 8011072:	d102      	bne.n	801107a <get+0x1a>
    return MSG_RESET;
 8011074:	f06f 0301 	mvn.w	r3, #1
 8011078:	e00e      	b.n	8011098 <get+0x38>
  b = *(msp->buffer + msp->offset);
 801107a:	9b03      	ldr	r3, [sp, #12]
 801107c:	685a      	ldr	r2, [r3, #4]
 801107e:	9b03      	ldr	r3, [sp, #12]
 8011080:	691b      	ldr	r3, [r3, #16]
 8011082:	4413      	add	r3, r2
 8011084:	781b      	ldrb	r3, [r3, #0]
 8011086:	f88d 300b 	strb.w	r3, [sp, #11]
  msp->offset += 1;
 801108a:	9b03      	ldr	r3, [sp, #12]
 801108c:	691b      	ldr	r3, [r3, #16]
 801108e:	1c5a      	adds	r2, r3, #1
 8011090:	9b03      	ldr	r3, [sp, #12]
 8011092:	611a      	str	r2, [r3, #16]
  return b;
 8011094:	f89d 300b 	ldrb.w	r3, [sp, #11]
}
 8011098:	4618      	mov	r0, r3
 801109a:	b004      	add	sp, #16
 801109c:	4770      	bx	lr
 801109e:	bf00      	nop

080110a0 <msObjectInit>:
 * @param[in] eos       initial End Of Stream offset. Normally you need to
 *                      put this to zero for RAM buffers or equal to @p size
 *                      for ROM streams.
 */
void msObjectInit(MemoryStream *msp, uint8_t *buffer,
                  size_t size, size_t eos) {
 80110a0:	b084      	sub	sp, #16
 80110a2:	9003      	str	r0, [sp, #12]
 80110a4:	9102      	str	r1, [sp, #8]
 80110a6:	9201      	str	r2, [sp, #4]
 80110a8:	9300      	str	r3, [sp, #0]

  msp->vmt    = &vmt;
 80110aa:	9b03      	ldr	r3, [sp, #12]
 80110ac:	4a07      	ldr	r2, [pc, #28]	; (80110cc <msObjectInit+0x2c>)
 80110ae:	601a      	str	r2, [r3, #0]
  msp->buffer = buffer;
 80110b0:	9b03      	ldr	r3, [sp, #12]
 80110b2:	9a02      	ldr	r2, [sp, #8]
 80110b4:	605a      	str	r2, [r3, #4]
  msp->size   = size;
 80110b6:	9b03      	ldr	r3, [sp, #12]
 80110b8:	9a01      	ldr	r2, [sp, #4]
 80110ba:	609a      	str	r2, [r3, #8]
  msp->eos    = eos;
 80110bc:	9b03      	ldr	r3, [sp, #12]
 80110be:	9a00      	ldr	r2, [sp, #0]
 80110c0:	60da      	str	r2, [r3, #12]
  msp->offset = 0;
 80110c2:	9b03      	ldr	r3, [sp, #12]
 80110c4:	2200      	movs	r2, #0
 80110c6:	611a      	str	r2, [r3, #16]
}
 80110c8:	b004      	add	sp, #16
 80110ca:	4770      	bx	lr
 80110cc:	0801a3b0 	.word	0x0801a3b0

080110d0 <long_to_string_with_divisor>:
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
                                         long num,
                                         unsigned radix,
                                         long divisor) {
 80110d0:	b088      	sub	sp, #32
 80110d2:	9003      	str	r0, [sp, #12]
 80110d4:	9102      	str	r1, [sp, #8]
 80110d6:	9201      	str	r2, [sp, #4]
 80110d8:	9300      	str	r3, [sp, #0]
  int i;
  char *q;
  long l, ll;

  l = num;
 80110da:	9b02      	ldr	r3, [sp, #8]
 80110dc:	9305      	str	r3, [sp, #20]
  if (divisor == 0) {
 80110de:	9b00      	ldr	r3, [sp, #0]
 80110e0:	2b00      	cmp	r3, #0
 80110e2:	d102      	bne.n	80110ea <long_to_string_with_divisor+0x1a>
    ll = num;
 80110e4:	9b02      	ldr	r3, [sp, #8]
 80110e6:	9304      	str	r3, [sp, #16]
 80110e8:	e001      	b.n	80110ee <long_to_string_with_divisor+0x1e>
  } else {
    ll = divisor;
 80110ea:	9b00      	ldr	r3, [sp, #0]
 80110ec:	9304      	str	r3, [sp, #16]
  }

  q = p + MAX_FILLER;
 80110ee:	9b03      	ldr	r3, [sp, #12]
 80110f0:	330b      	adds	r3, #11
 80110f2:	9306      	str	r3, [sp, #24]
  do {
    i = (int)(l % radix);
 80110f4:	9b05      	ldr	r3, [sp, #20]
 80110f6:	9a01      	ldr	r2, [sp, #4]
 80110f8:	fbb3 f2f2 	udiv	r2, r3, r2
 80110fc:	9901      	ldr	r1, [sp, #4]
 80110fe:	fb01 f202 	mul.w	r2, r1, r2
 8011102:	1a9b      	subs	r3, r3, r2
 8011104:	9307      	str	r3, [sp, #28]
    i += '0';
 8011106:	9b07      	ldr	r3, [sp, #28]
 8011108:	3330      	adds	r3, #48	; 0x30
 801110a:	9307      	str	r3, [sp, #28]
    if (i > '9')
 801110c:	9b07      	ldr	r3, [sp, #28]
 801110e:	2b39      	cmp	r3, #57	; 0x39
 8011110:	dd02      	ble.n	8011118 <long_to_string_with_divisor+0x48>
      i += 'A' - '0' - 10;
 8011112:	9b07      	ldr	r3, [sp, #28]
 8011114:	3307      	adds	r3, #7
 8011116:	9307      	str	r3, [sp, #28]
    *--q = i;
 8011118:	9b06      	ldr	r3, [sp, #24]
 801111a:	3b01      	subs	r3, #1
 801111c:	9306      	str	r3, [sp, #24]
 801111e:	9b07      	ldr	r3, [sp, #28]
 8011120:	b2da      	uxtb	r2, r3
 8011122:	9b06      	ldr	r3, [sp, #24]
 8011124:	701a      	strb	r2, [r3, #0]
    l /= radix;
 8011126:	9a05      	ldr	r2, [sp, #20]
 8011128:	9b01      	ldr	r3, [sp, #4]
 801112a:	fbb2 f3f3 	udiv	r3, r2, r3
 801112e:	9305      	str	r3, [sp, #20]
  } while ((ll /= radix) != 0);
 8011130:	9a04      	ldr	r2, [sp, #16]
 8011132:	9b01      	ldr	r3, [sp, #4]
 8011134:	fbb2 f3f3 	udiv	r3, r2, r3
 8011138:	9304      	str	r3, [sp, #16]
 801113a:	9b04      	ldr	r3, [sp, #16]
 801113c:	2b00      	cmp	r3, #0
 801113e:	d1d9      	bne.n	80110f4 <long_to_string_with_divisor+0x24>

  i = (int)(p + MAX_FILLER - q);
 8011140:	9b03      	ldr	r3, [sp, #12]
 8011142:	330b      	adds	r3, #11
 8011144:	461a      	mov	r2, r3
 8011146:	9b06      	ldr	r3, [sp, #24]
 8011148:	1ad3      	subs	r3, r2, r3
 801114a:	9307      	str	r3, [sp, #28]
  do
    *p++ = *q++;
 801114c:	9b03      	ldr	r3, [sp, #12]
 801114e:	1c5a      	adds	r2, r3, #1
 8011150:	9203      	str	r2, [sp, #12]
 8011152:	9a06      	ldr	r2, [sp, #24]
 8011154:	1c51      	adds	r1, r2, #1
 8011156:	9106      	str	r1, [sp, #24]
 8011158:	7812      	ldrb	r2, [r2, #0]
 801115a:	701a      	strb	r2, [r3, #0]
  while (--i);
 801115c:	9b07      	ldr	r3, [sp, #28]
 801115e:	3b01      	subs	r3, #1
 8011160:	9307      	str	r3, [sp, #28]
 8011162:	9b07      	ldr	r3, [sp, #28]
 8011164:	2b00      	cmp	r3, #0
 8011166:	d1f1      	bne.n	801114c <long_to_string_with_divisor+0x7c>

  return p;
 8011168:	9b03      	ldr	r3, [sp, #12]
}
 801116a:	4618      	mov	r0, r3
 801116c:	b008      	add	sp, #32
 801116e:	4770      	bx	lr

08011170 <ch_ltoa>:

static char *ch_ltoa(char *p, long num, unsigned radix) {
 8011170:	b500      	push	{lr}
 8011172:	b085      	sub	sp, #20
 8011174:	9003      	str	r0, [sp, #12]
 8011176:	9102      	str	r1, [sp, #8]
 8011178:	9201      	str	r2, [sp, #4]

  return long_to_string_with_divisor(p, num, radix, 0);
 801117a:	9803      	ldr	r0, [sp, #12]
 801117c:	9902      	ldr	r1, [sp, #8]
 801117e:	9a01      	ldr	r2, [sp, #4]
 8011180:	2300      	movs	r3, #0
 8011182:	f7ff ffa5 	bl	80110d0 <long_to_string_with_divisor>
 8011186:	4603      	mov	r3, r0
}
 8011188:	4618      	mov	r0, r3
 801118a:	b005      	add	sp, #20
 801118c:	f85d fb04 	ldr.w	pc, [sp], #4

08011190 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8011190:	b500      	push	{lr}
 8011192:	b091      	sub	sp, #68	; 0x44
 8011194:	9003      	str	r0, [sp, #12]
 8011196:	9102      	str	r1, [sp, #8]
 8011198:	9201      	str	r2, [sp, #4]
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 801119a:	2300      	movs	r3, #0
 801119c:	9309      	str	r3, [sp, #36]	; 0x24
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (true) {
    c = *fmt++;
 801119e:	9b02      	ldr	r3, [sp, #8]
 80111a0:	1c5a      	adds	r2, r3, #1
 80111a2:	9202      	str	r2, [sp, #8]
 80111a4:	781b      	ldrb	r3, [r3, #0]
 80111a6:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    if (c == 0)
 80111aa:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80111ae:	2b00      	cmp	r3, #0
 80111b0:	d101      	bne.n	80111b6 <chvprintf+0x26>
      return n;
 80111b2:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80111b4:	e210      	b.n	80115d8 <chvprintf+0x448>
    if (c != '%') {
 80111b6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80111ba:	2b25      	cmp	r3, #37	; 0x25
 80111bc:	d00b      	beq.n	80111d6 <chvprintf+0x46>
      streamPut(chp, (uint8_t)c);
 80111be:	9b03      	ldr	r3, [sp, #12]
 80111c0:	681b      	ldr	r3, [r3, #0]
 80111c2:	689b      	ldr	r3, [r3, #8]
 80111c4:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 80111c8:	9803      	ldr	r0, [sp, #12]
 80111ca:	4611      	mov	r1, r2
 80111cc:	4798      	blx	r3
      n++;
 80111ce:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80111d0:	3301      	adds	r3, #1
 80111d2:	9309      	str	r3, [sp, #36]	; 0x24
      continue;
 80111d4:	e1ff      	b.n	80115d6 <chvprintf+0x446>
    }
    p = tmpbuf;
 80111d6:	ab04      	add	r3, sp, #16
 80111d8:	930f      	str	r3, [sp, #60]	; 0x3c
    s = tmpbuf;
 80111da:	ab04      	add	r3, sp, #16
 80111dc:	930e      	str	r3, [sp, #56]	; 0x38
    left_align = FALSE;
 80111de:	2300      	movs	r3, #0
 80111e0:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    if (*fmt == '-') {
 80111e4:	9b02      	ldr	r3, [sp, #8]
 80111e6:	781b      	ldrb	r3, [r3, #0]
 80111e8:	2b2d      	cmp	r3, #45	; 0x2d
 80111ea:	d105      	bne.n	80111f8 <chvprintf+0x68>
      fmt++;
 80111ec:	9b02      	ldr	r3, [sp, #8]
 80111ee:	3301      	adds	r3, #1
 80111f0:	9302      	str	r3, [sp, #8]
      left_align = TRUE;
 80111f2:	2301      	movs	r3, #1
 80111f4:	f88d 3022 	strb.w	r3, [sp, #34]	; 0x22
    }
    filler = ' ';
 80111f8:	2320      	movs	r3, #32
 80111fa:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    if (*fmt == '0') {
 80111fe:	9b02      	ldr	r3, [sp, #8]
 8011200:	781b      	ldrb	r3, [r3, #0]
 8011202:	2b30      	cmp	r3, #48	; 0x30
 8011204:	d105      	bne.n	8011212 <chvprintf+0x82>
      fmt++;
 8011206:	9b02      	ldr	r3, [sp, #8]
 8011208:	3301      	adds	r3, #1
 801120a:	9302      	str	r3, [sp, #8]
      filler = '0';
 801120c:	2330      	movs	r3, #48	; 0x30
 801120e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
    }
    width = 0;
 8011212:	2300      	movs	r3, #0
 8011214:	930a      	str	r3, [sp, #40]	; 0x28
    while (TRUE) {
      c = *fmt++;
 8011216:	9b02      	ldr	r3, [sp, #8]
 8011218:	1c5a      	adds	r2, r3, #1
 801121a:	9202      	str	r2, [sp, #8]
 801121c:	781b      	ldrb	r3, [r3, #0]
 801121e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      if (c >= '0' && c <= '9')
 8011222:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011226:	2b2f      	cmp	r3, #47	; 0x2f
 8011228:	d909      	bls.n	801123e <chvprintf+0xae>
 801122a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801122e:	2b39      	cmp	r3, #57	; 0x39
 8011230:	d805      	bhi.n	801123e <chvprintf+0xae>
        c -= '0';
 8011232:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011236:	3b30      	subs	r3, #48	; 0x30
 8011238:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 801123c:	e012      	b.n	8011264 <chvprintf+0xd4>
      else if (c == '*')
 801123e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011242:	2b2a      	cmp	r3, #42	; 0x2a
 8011244:	d106      	bne.n	8011254 <chvprintf+0xc4>
        c = va_arg(ap, int);
 8011246:	9b01      	ldr	r3, [sp, #4]
 8011248:	1d1a      	adds	r2, r3, #4
 801124a:	9201      	str	r2, [sp, #4]
 801124c:	681b      	ldr	r3, [r3, #0]
 801124e:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 8011252:	e007      	b.n	8011264 <chvprintf+0xd4>
      else
        break;
 8011254:	bf00      	nop
      width = width * 10 + c;
    }
    precision = 0;
 8011256:	2300      	movs	r3, #0
 8011258:	930b      	str	r3, [sp, #44]	; 0x2c
    if (c == '.') {
 801125a:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801125e:	2b2e      	cmp	r3, #46	; 0x2e
 8011260:	d137      	bne.n	80112d2 <chvprintf+0x142>
 8011262:	e00a      	b.n	801127a <chvprintf+0xea>
        c -= '0';
      else if (c == '*')
        c = va_arg(ap, int);
      else
        break;
      width = width * 10 + c;
 8011264:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 8011266:	4613      	mov	r3, r2
 8011268:	009b      	lsls	r3, r3, #2
 801126a:	4413      	add	r3, r2
 801126c:	005b      	lsls	r3, r3, #1
 801126e:	461a      	mov	r2, r3
 8011270:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011274:	4413      	add	r3, r2
 8011276:	930a      	str	r3, [sp, #40]	; 0x28
    }
 8011278:	e7cd      	b.n	8011216 <chvprintf+0x86>
    precision = 0;
    if (c == '.') {
      while (TRUE) {
        c = *fmt++;
 801127a:	9b02      	ldr	r3, [sp, #8]
 801127c:	1c5a      	adds	r2, r3, #1
 801127e:	9202      	str	r2, [sp, #8]
 8011280:	781b      	ldrb	r3, [r3, #0]
 8011282:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
        if (c >= '0' && c <= '9')
 8011286:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801128a:	2b2f      	cmp	r3, #47	; 0x2f
 801128c:	d909      	bls.n	80112a2 <chvprintf+0x112>
 801128e:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011292:	2b39      	cmp	r3, #57	; 0x39
 8011294:	d805      	bhi.n	80112a2 <chvprintf+0x112>
          c -= '0';
 8011296:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801129a:	3b30      	subs	r3, #48	; 0x30
 801129c:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112a0:	e00b      	b.n	80112ba <chvprintf+0x12a>
        else if (c == '*')
 80112a2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112a6:	2b2a      	cmp	r3, #42	; 0x2a
 80112a8:	d106      	bne.n	80112b8 <chvprintf+0x128>
          c = va_arg(ap, int);
 80112aa:	9b01      	ldr	r3, [sp, #4]
 80112ac:	1d1a      	adds	r2, r3, #4
 80112ae:	9201      	str	r2, [sp, #4]
 80112b0:	681b      	ldr	r3, [r3, #0]
 80112b2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
 80112b6:	e000      	b.n	80112ba <chvprintf+0x12a>
        else
          break;
 80112b8:	e00b      	b.n	80112d2 <chvprintf+0x142>
        precision *= 10;
 80112ba:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80112bc:	4613      	mov	r3, r2
 80112be:	009b      	lsls	r3, r3, #2
 80112c0:	4413      	add	r3, r2
 80112c2:	005b      	lsls	r3, r3, #1
 80112c4:	930b      	str	r3, [sp, #44]	; 0x2c
        precision += c;
 80112c6:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112ca:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80112cc:	4413      	add	r3, r2
 80112ce:	930b      	str	r3, [sp, #44]	; 0x2c
      }
 80112d0:	e7d3      	b.n	801127a <chvprintf+0xea>
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 80112d2:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112d6:	2b6c      	cmp	r3, #108	; 0x6c
 80112d8:	d003      	beq.n	80112e2 <chvprintf+0x152>
 80112da:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80112de:	2b4c      	cmp	r3, #76	; 0x4c
 80112e0:	d10e      	bne.n	8011300 <chvprintf+0x170>
      is_long = TRUE;
 80112e2:	2301      	movs	r3, #1
 80112e4:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
      if (*fmt)
 80112e8:	9b02      	ldr	r3, [sp, #8]
 80112ea:	781b      	ldrb	r3, [r3, #0]
 80112ec:	2b00      	cmp	r3, #0
 80112ee:	d006      	beq.n	80112fe <chvprintf+0x16e>
        c = *fmt++;
 80112f0:	9b02      	ldr	r3, [sp, #8]
 80112f2:	1c5a      	adds	r2, r3, #1
 80112f4:	9202      	str	r2, [sp, #8]
 80112f6:	781b      	ldrb	r3, [r3, #0]
 80112f8:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
      is_long = TRUE;
      if (*fmt)
 80112fc:	e013      	b.n	8011326 <chvprintf+0x196>
 80112fe:	e012      	b.n	8011326 <chvprintf+0x196>
        c = *fmt++;
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');
 8011300:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 8011304:	2b40      	cmp	r3, #64	; 0x40
 8011306:	d905      	bls.n	8011314 <chvprintf+0x184>
 8011308:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801130c:	2b5a      	cmp	r3, #90	; 0x5a
 801130e:	d801      	bhi.n	8011314 <chvprintf+0x184>
 8011310:	2301      	movs	r3, #1
 8011312:	e000      	b.n	8011316 <chvprintf+0x186>
 8011314:	2300      	movs	r3, #0
 8011316:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23
 801131a:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 801131e:	f003 0301 	and.w	r3, r3, #1
 8011322:	f88d 3023 	strb.w	r3, [sp, #35]	; 0x23

    /* Command decoding.*/
    switch (c) {
 8011326:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 801132a:	3b44      	subs	r3, #68	; 0x44
 801132c:	2b34      	cmp	r3, #52	; 0x34
 801132e:	f200 80e2 	bhi.w	80114f6 <chvprintf+0x366>
 8011332:	a201      	add	r2, pc, #4	; (adr r2, 8011338 <chvprintf+0x1a8>)
 8011334:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 8011338:	0801146f 	.word	0x0801146f
 801133c:	080114f7 	.word	0x080114f7
 8011340:	080114f7 	.word	0x080114f7
 8011344:	080114f7 	.word	0x080114f7
 8011348:	080114f7 	.word	0x080114f7
 801134c:	0801146f 	.word	0x0801146f
 8011350:	080114f7 	.word	0x080114f7
 8011354:	080114f7 	.word	0x080114f7
 8011358:	080114f7 	.word	0x080114f7
 801135c:	080114f7 	.word	0x080114f7
 8011360:	080114f7 	.word	0x080114f7
 8011364:	080114c1 	.word	0x080114c1
 8011368:	080114f7 	.word	0x080114f7
 801136c:	080114f7 	.word	0x080114f7
 8011370:	080114f7 	.word	0x080114f7
 8011374:	080114f7 	.word	0x080114f7
 8011378:	080114f7 	.word	0x080114f7
 801137c:	080114b9 	.word	0x080114b9
 8011380:	080114f7 	.word	0x080114f7
 8011384:	080114f7 	.word	0x080114f7
 8011388:	080114b1 	.word	0x080114b1
 801138c:	080114f7 	.word	0x080114f7
 8011390:	080114f7 	.word	0x080114f7
 8011394:	080114f7 	.word	0x080114f7
 8011398:	080114f7 	.word	0x080114f7
 801139c:	080114f7 	.word	0x080114f7
 80113a0:	080114f7 	.word	0x080114f7
 80113a4:	080114f7 	.word	0x080114f7
 80113a8:	080114f7 	.word	0x080114f7
 80113ac:	080114f7 	.word	0x080114f7
 80113b0:	080114f7 	.word	0x080114f7
 80113b4:	0801140d 	.word	0x0801140d
 80113b8:	0801146f 	.word	0x0801146f
 80113bc:	080114f7 	.word	0x080114f7
 80113c0:	080114f7 	.word	0x080114f7
 80113c4:	080114f7 	.word	0x080114f7
 80113c8:	080114f7 	.word	0x080114f7
 80113cc:	0801146f 	.word	0x0801146f
 80113d0:	080114f7 	.word	0x080114f7
 80113d4:	080114f7 	.word	0x080114f7
 80113d8:	080114f7 	.word	0x080114f7
 80113dc:	080114f7 	.word	0x080114f7
 80113e0:	080114f7 	.word	0x080114f7
 80113e4:	080114c1 	.word	0x080114c1
 80113e8:	080114f7 	.word	0x080114f7
 80113ec:	080114f7 	.word	0x080114f7
 80113f0:	080114f7 	.word	0x080114f7
 80113f4:	08011427 	.word	0x08011427
 80113f8:	080114f7 	.word	0x080114f7
 80113fc:	080114b9 	.word	0x080114b9
 8011400:	080114f7 	.word	0x080114f7
 8011404:	080114f7 	.word	0x080114f7
 8011408:	080114b1 	.word	0x080114b1
    case 'c':
      filler = ' ';
 801140c:	2320      	movs	r3, #32
 801140e:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      *p++ = va_arg(ap, int);
 8011412:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011414:	1c5a      	adds	r2, r3, #1
 8011416:	920f      	str	r2, [sp, #60]	; 0x3c
 8011418:	9a01      	ldr	r2, [sp, #4]
 801141a:	1d11      	adds	r1, r2, #4
 801141c:	9101      	str	r1, [sp, #4]
 801141e:	6812      	ldr	r2, [r2, #0]
 8011420:	b2d2      	uxtb	r2, r2
 8011422:	701a      	strb	r2, [r3, #0]
      break;
 8011424:	e06e      	b.n	8011504 <chvprintf+0x374>
    case 's':
      filler = ' ';
 8011426:	2320      	movs	r3, #32
 8011428:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
      if ((s = va_arg(ap, char *)) == 0)
 801142c:	9b01      	ldr	r3, [sp, #4]
 801142e:	1d1a      	adds	r2, r3, #4
 8011430:	9201      	str	r2, [sp, #4]
 8011432:	681b      	ldr	r3, [r3, #0]
 8011434:	930e      	str	r3, [sp, #56]	; 0x38
 8011436:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011438:	2b00      	cmp	r3, #0
 801143a:	d101      	bne.n	8011440 <chvprintf+0x2b0>
        s = "(null)";
 801143c:	4b68      	ldr	r3, [pc, #416]	; (80115e0 <chvprintf+0x450>)
 801143e:	930e      	str	r3, [sp, #56]	; 0x38
      if (precision == 0)
 8011440:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011442:	2b00      	cmp	r3, #0
 8011444:	d102      	bne.n	801144c <chvprintf+0x2bc>
        precision = 32767;
 8011446:	f647 73ff 	movw	r3, #32767	; 0x7fff
 801144a:	930b      	str	r3, [sp, #44]	; 0x2c
      for (p = s; *p && (--precision >= 0); p++)
 801144c:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801144e:	930f      	str	r3, [sp, #60]	; 0x3c
 8011450:	e002      	b.n	8011458 <chvprintf+0x2c8>
 8011452:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011454:	3301      	adds	r3, #1
 8011456:	930f      	str	r3, [sp, #60]	; 0x3c
 8011458:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 801145a:	781b      	ldrb	r3, [r3, #0]
 801145c:	2b00      	cmp	r3, #0
 801145e:	d005      	beq.n	801146c <chvprintf+0x2dc>
 8011460:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011462:	3b01      	subs	r3, #1
 8011464:	930b      	str	r3, [sp, #44]	; 0x2c
 8011466:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 8011468:	2b00      	cmp	r3, #0
 801146a:	daf2      	bge.n	8011452 <chvprintf+0x2c2>
        ;
      break;
 801146c:	e04a      	b.n	8011504 <chvprintf+0x374>
    case 'D':
    case 'd':
    case 'I':
    case 'i':
      if (is_long)
 801146e:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 8011472:	2b00      	cmp	r3, #0
 8011474:	d005      	beq.n	8011482 <chvprintf+0x2f2>
        l = va_arg(ap, long);
 8011476:	9b01      	ldr	r3, [sp, #4]
 8011478:	1d1a      	adds	r2, r3, #4
 801147a:	9201      	str	r2, [sp, #4]
 801147c:	681b      	ldr	r3, [r3, #0]
 801147e:	9307      	str	r3, [sp, #28]
 8011480:	e004      	b.n	801148c <chvprintf+0x2fc>
      else
        l = va_arg(ap, int);
 8011482:	9b01      	ldr	r3, [sp, #4]
 8011484:	1d1a      	adds	r2, r3, #4
 8011486:	9201      	str	r2, [sp, #4]
 8011488:	681b      	ldr	r3, [r3, #0]
 801148a:	9307      	str	r3, [sp, #28]
      if (l < 0) {
 801148c:	9b07      	ldr	r3, [sp, #28]
 801148e:	2b00      	cmp	r3, #0
 8011490:	da07      	bge.n	80114a2 <chvprintf+0x312>
        *p++ = '-';
 8011492:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 8011494:	1c5a      	adds	r2, r3, #1
 8011496:	920f      	str	r2, [sp, #60]	; 0x3c
 8011498:	222d      	movs	r2, #45	; 0x2d
 801149a:	701a      	strb	r2, [r3, #0]
        l = -l;
 801149c:	9b07      	ldr	r3, [sp, #28]
 801149e:	425b      	negs	r3, r3
 80114a0:	9307      	str	r3, [sp, #28]
      }
      p = ch_ltoa(p, l, 10);
 80114a2:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80114a4:	9907      	ldr	r1, [sp, #28]
 80114a6:	220a      	movs	r2, #10
 80114a8:	f7ff fe62 	bl	8011170 <ch_ltoa>
 80114ac:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 80114ae:	e029      	b.n	8011504 <chvprintf+0x374>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 80114b0:	2310      	movs	r3, #16
 80114b2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80114b6:	e006      	b.n	80114c6 <chvprintf+0x336>
    case 'U':
    case 'u':
      c = 10;
 80114b8:	230a      	movs	r3, #10
 80114ba:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
      goto unsigned_common;
 80114be:	e002      	b.n	80114c6 <chvprintf+0x336>
    case 'O':
    case 'o':
      c = 8;
 80114c0:	2308      	movs	r3, #8
 80114c2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
unsigned_common:
      if (is_long)
 80114c6:	f89d 3023 	ldrb.w	r3, [sp, #35]	; 0x23
 80114ca:	2b00      	cmp	r3, #0
 80114cc:	d005      	beq.n	80114da <chvprintf+0x34a>
        l = va_arg(ap, unsigned long);
 80114ce:	9b01      	ldr	r3, [sp, #4]
 80114d0:	1d1a      	adds	r2, r3, #4
 80114d2:	9201      	str	r2, [sp, #4]
 80114d4:	681b      	ldr	r3, [r3, #0]
 80114d6:	9307      	str	r3, [sp, #28]
 80114d8:	e004      	b.n	80114e4 <chvprintf+0x354>
      else
        l = va_arg(ap, unsigned int);
 80114da:	9b01      	ldr	r3, [sp, #4]
 80114dc:	1d1a      	adds	r2, r3, #4
 80114de:	9201      	str	r2, [sp, #4]
 80114e0:	681b      	ldr	r3, [r3, #0]
 80114e2:	9307      	str	r3, [sp, #28]
      p = ch_ltoa(p, l, c);
 80114e4:	f89d 3037 	ldrb.w	r3, [sp, #55]	; 0x37
 80114e8:	980f      	ldr	r0, [sp, #60]	; 0x3c
 80114ea:	9907      	ldr	r1, [sp, #28]
 80114ec:	461a      	mov	r2, r3
 80114ee:	f7ff fe3f 	bl	8011170 <ch_ltoa>
 80114f2:	900f      	str	r0, [sp, #60]	; 0x3c
      break;
 80114f4:	e006      	b.n	8011504 <chvprintf+0x374>
    default:
      *p++ = c;
 80114f6:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
 80114f8:	1c5a      	adds	r2, r3, #1
 80114fa:	920f      	str	r2, [sp, #60]	; 0x3c
 80114fc:	f89d 2037 	ldrb.w	r2, [sp, #55]	; 0x37
 8011500:	701a      	strb	r2, [r3, #0]
      break;
 8011502:	bf00      	nop
    }
    i = (int)(p - s);
 8011504:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 8011506:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011508:	1ad3      	subs	r3, r2, r3
 801150a:	930c      	str	r3, [sp, #48]	; 0x30
    if ((width -= i) < 0)
 801150c:	9a0a      	ldr	r2, [sp, #40]	; 0x28
 801150e:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011510:	1ad3      	subs	r3, r2, r3
 8011512:	930a      	str	r3, [sp, #40]	; 0x28
 8011514:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011516:	2b00      	cmp	r3, #0
 8011518:	da01      	bge.n	801151e <chvprintf+0x38e>
      width = 0;
 801151a:	2300      	movs	r3, #0
 801151c:	930a      	str	r3, [sp, #40]	; 0x28
    if (left_align == FALSE)
 801151e:	f89d 3022 	ldrb.w	r3, [sp, #34]	; 0x22
 8011522:	f083 0301 	eor.w	r3, r3, #1
 8011526:	b2db      	uxtb	r3, r3
 8011528:	2b00      	cmp	r3, #0
 801152a:	d002      	beq.n	8011532 <chvprintf+0x3a2>
      width = -width;
 801152c:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 801152e:	425b      	negs	r3, r3
 8011530:	930a      	str	r3, [sp, #40]	; 0x28
    if (width < 0) {
 8011532:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011534:	2b00      	cmp	r3, #0
 8011536:	da28      	bge.n	801158a <chvprintf+0x3fa>
      if (*s == '-' && filler == '0') {
 8011538:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 801153a:	781b      	ldrb	r3, [r3, #0]
 801153c:	2b2d      	cmp	r3, #45	; 0x2d
 801153e:	d113      	bne.n	8011568 <chvprintf+0x3d8>
 8011540:	f89d 3036 	ldrb.w	r3, [sp, #54]	; 0x36
 8011544:	2b30      	cmp	r3, #48	; 0x30
 8011546:	d10f      	bne.n	8011568 <chvprintf+0x3d8>
        streamPut(chp, (uint8_t)*s++);
 8011548:	9b03      	ldr	r3, [sp, #12]
 801154a:	681b      	ldr	r3, [r3, #0]
 801154c:	689a      	ldr	r2, [r3, #8]
 801154e:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011550:	1c59      	adds	r1, r3, #1
 8011552:	910e      	str	r1, [sp, #56]	; 0x38
 8011554:	781b      	ldrb	r3, [r3, #0]
 8011556:	9803      	ldr	r0, [sp, #12]
 8011558:	4619      	mov	r1, r3
 801155a:	4790      	blx	r2
        n++;
 801155c:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801155e:	3301      	adds	r3, #1
 8011560:	9309      	str	r3, [sp, #36]	; 0x24
        i--;
 8011562:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 8011564:	3b01      	subs	r3, #1
 8011566:	930c      	str	r3, [sp, #48]	; 0x30
      }
      do {
        streamPut(chp, (uint8_t)filler);
 8011568:	9b03      	ldr	r3, [sp, #12]
 801156a:	681b      	ldr	r3, [r3, #0]
 801156c:	689b      	ldr	r3, [r3, #8]
 801156e:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 8011572:	9803      	ldr	r0, [sp, #12]
 8011574:	4611      	mov	r1, r2
 8011576:	4798      	blx	r3
        n++;
 8011578:	9b09      	ldr	r3, [sp, #36]	; 0x24
 801157a:	3301      	adds	r3, #1
 801157c:	9309      	str	r3, [sp, #36]	; 0x24
      } while (++width != 0);
 801157e:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011580:	3301      	adds	r3, #1
 8011582:	930a      	str	r3, [sp, #40]	; 0x28
 8011584:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8011586:	2b00      	cmp	r3, #0
 8011588:	d1ee      	bne.n	8011568 <chvprintf+0x3d8>
    }
    while (--i >= 0) {
 801158a:	e00c      	b.n	80115a6 <chvprintf+0x416>
      streamPut(chp, (uint8_t)*s++);
 801158c:	9b03      	ldr	r3, [sp, #12]
 801158e:	681b      	ldr	r3, [r3, #0]
 8011590:	689a      	ldr	r2, [r3, #8]
 8011592:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 8011594:	1c59      	adds	r1, r3, #1
 8011596:	910e      	str	r1, [sp, #56]	; 0x38
 8011598:	781b      	ldrb	r3, [r3, #0]
 801159a:	9803      	ldr	r0, [sp, #12]
 801159c:	4619      	mov	r1, r3
 801159e:	4790      	blx	r2
      n++;
 80115a0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115a2:	3301      	adds	r3, #1
 80115a4:	9309      	str	r3, [sp, #36]	; 0x24
      do {
        streamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 80115a6:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115a8:	3b01      	subs	r3, #1
 80115aa:	930c      	str	r3, [sp, #48]	; 0x30
 80115ac:	9b0c      	ldr	r3, [sp, #48]	; 0x30
 80115ae:	2b00      	cmp	r3, #0
 80115b0:	daec      	bge.n	801158c <chvprintf+0x3fc>
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80115b2:	e00d      	b.n	80115d0 <chvprintf+0x440>
      streamPut(chp, (uint8_t)filler);
 80115b4:	9b03      	ldr	r3, [sp, #12]
 80115b6:	681b      	ldr	r3, [r3, #0]
 80115b8:	689b      	ldr	r3, [r3, #8]
 80115ba:	f89d 2036 	ldrb.w	r2, [sp, #54]	; 0x36
 80115be:	9803      	ldr	r0, [sp, #12]
 80115c0:	4611      	mov	r1, r2
 80115c2:	4798      	blx	r3
      n++;
 80115c4:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80115c6:	3301      	adds	r3, #1
 80115c8:	9309      	str	r3, [sp, #36]	; 0x24
      width--;
 80115ca:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115cc:	3b01      	subs	r3, #1
 80115ce:	930a      	str	r3, [sp, #40]	; 0x28
    while (--i >= 0) {
      streamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 80115d0:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 80115d2:	2b00      	cmp	r3, #0
 80115d4:	d1ee      	bne.n	80115b4 <chvprintf+0x424>
      streamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
 80115d6:	e5e2      	b.n	801119e <chvprintf+0xe>
}
 80115d8:	4618      	mov	r0, r3
 80115da:	b011      	add	sp, #68	; 0x44
 80115dc:	f85d fb04 	ldr.w	pc, [sp], #4
 80115e0:	0801a3c0 	.word	0x0801a3c0
 80115e4:	f3af 8000 	nop.w
 80115e8:	f3af 8000 	nop.w
 80115ec:	f3af 8000 	nop.w

080115f0 <chprintf>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 80115f0:	b40e      	push	{r1, r2, r3}
 80115f2:	b500      	push	{lr}
 80115f4:	b084      	sub	sp, #16
 80115f6:	9001      	str	r0, [sp, #4]
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 80115f8:	ab06      	add	r3, sp, #24
 80115fa:	9302      	str	r3, [sp, #8]
  formatted_bytes = chvprintf(chp, fmt, ap);
 80115fc:	9801      	ldr	r0, [sp, #4]
 80115fe:	9905      	ldr	r1, [sp, #20]
 8011600:	9a02      	ldr	r2, [sp, #8]
 8011602:	f7ff fdc5 	bl	8011190 <chvprintf>
 8011606:	9003      	str	r0, [sp, #12]
  va_end(ap);

  return formatted_bytes;
 8011608:	9b03      	ldr	r3, [sp, #12]
}
 801160a:	4618      	mov	r0, r3
 801160c:	b004      	add	sp, #16
 801160e:	f85d eb04 	ldr.w	lr, [sp], #4
 8011612:	b003      	add	sp, #12
 8011614:	4770      	bx	lr
 8011616:	bf00      	nop
 8011618:	f3af 8000 	nop.w
 801161c:	f3af 8000 	nop.w

08011620 <chsnprintf>:
 *                      terminating NUL byte) that would have been
 *                      stored in @p str if there was room.
 *
 * @api
 */
int chsnprintf(char *str, size_t size, const char *fmt, ...) {
 8011620:	b40c      	push	{r2, r3}
 8011622:	b500      	push	{lr}
 8011624:	b08d      	sub	sp, #52	; 0x34
 8011626:	9001      	str	r0, [sp, #4]
 8011628:	9100      	str	r1, [sp, #0]
  MemoryStream ms;
  BaseSequentialStream *chp;
  size_t size_wo_nul;
  int retval;

  if (size > 0)
 801162a:	9b00      	ldr	r3, [sp, #0]
 801162c:	2b00      	cmp	r3, #0
 801162e:	d003      	beq.n	8011638 <chsnprintf+0x18>
    size_wo_nul = size - 1;
 8011630:	9b00      	ldr	r3, [sp, #0]
 8011632:	3b01      	subs	r3, #1
 8011634:	930b      	str	r3, [sp, #44]	; 0x2c
 8011636:	e001      	b.n	801163c <chsnprintf+0x1c>
  else
    size_wo_nul = 0;
 8011638:	2300      	movs	r3, #0
 801163a:	930b      	str	r3, [sp, #44]	; 0x2c

  /* Memory stream object to be used as a string writer, reserving one
     byte for the final zero.*/
  msObjectInit(&ms, (uint8_t *)str, size_wo_nul, 0);
 801163c:	ab03      	add	r3, sp, #12
 801163e:	4618      	mov	r0, r3
 8011640:	9901      	ldr	r1, [sp, #4]
 8011642:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8011644:	2300      	movs	r3, #0
 8011646:	f7ff fd2b 	bl	80110a0 <msObjectInit>

  /* Performing the print operation using the common code.*/
  chp = (BaseSequentialStream *)(void *)&ms;
 801164a:	ab03      	add	r3, sp, #12
 801164c:	930a      	str	r3, [sp, #40]	; 0x28
  va_start(ap, fmt);
 801164e:	ab0f      	add	r3, sp, #60	; 0x3c
 8011650:	9308      	str	r3, [sp, #32]
  retval = chvprintf(chp, fmt, ap);
 8011652:	980a      	ldr	r0, [sp, #40]	; 0x28
 8011654:	990e      	ldr	r1, [sp, #56]	; 0x38
 8011656:	9a08      	ldr	r2, [sp, #32]
 8011658:	f7ff fd9a 	bl	8011190 <chvprintf>
 801165c:	9009      	str	r0, [sp, #36]	; 0x24
  va_end(ap);

  /* Terminate with a zero, unless size==0.*/
  if (ms.eos < size)
 801165e:	9a06      	ldr	r2, [sp, #24]
 8011660:	9b00      	ldr	r3, [sp, #0]
 8011662:	429a      	cmp	r2, r3
 8011664:	d204      	bcs.n	8011670 <chsnprintf+0x50>
      str[ms.eos] = 0;
 8011666:	9b06      	ldr	r3, [sp, #24]
 8011668:	9a01      	ldr	r2, [sp, #4]
 801166a:	4413      	add	r3, r2
 801166c:	2200      	movs	r2, #0
 801166e:	701a      	strb	r2, [r3, #0]

  /* Return number of bytes that would have been written.*/
  return retval;
 8011670:	9b09      	ldr	r3, [sp, #36]	; 0x24
}
 8011672:	4618      	mov	r0, r3
 8011674:	b00d      	add	sp, #52	; 0x34
 8011676:	f85d eb04 	ldr.w	lr, [sp], #4
 801167a:	b002      	add	sp, #8
 801167c:	4770      	bx	lr
 801167e:	bf00      	nop

08011680 <port_lock>:
/**
 * @brief   Kernel-lock action.
 * @details In this port this function raises the base priority to kernel
 *          level.
 */
static inline void port_lock(void) {
 8011680:	b082      	sub	sp, #8
 8011682:	2320      	movs	r3, #32
 8011684:	9301      	str	r3, [sp, #4]
 8011686:	9b01      	ldr	r3, [sp, #4]
 8011688:	f383 8811 	msr	BASEPRI, r3
#endif
#endif
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __disable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801168c:	b002      	add	sp, #8
 801168e:	4770      	bx	lr

08011690 <port_unlock>:
/**
 * @brief   Kernel-unlock action.
 * @details In this port this function lowers the base priority to user
 *          level.
 */
static inline void port_unlock(void) {
 8011690:	b082      	sub	sp, #8
 8011692:	2300      	movs	r3, #0
 8011694:	9301      	str	r3, [sp, #4]
 8011696:	9b01      	ldr	r3, [sp, #4]
 8011698:	f383 8811 	msr	BASEPRI, r3
#if CORTEX_SIMPLIFIED_PRIORITY == FALSE
  __set_BASEPRI(CORTEX_BASEPRI_DISABLED);
#else /* CORTEX_SIMPLIFIED_PRIORITY */
  __enable_irq();
#endif /* CORTEX_SIMPLIFIED_PRIORITY */
}
 801169c:	b002      	add	sp, #8
 801169e:	4770      	bx	lr

080116a0 <chSysLock>:
/**
 * @brief   Enters the kernel lock state.
 *
 * @special
 */
static inline void chSysLock(void) {
 80116a0:	b508      	push	{r3, lr}

  port_lock();
 80116a2:	f7ff ffed 	bl	8011680 <port_lock>
  _stats_start_measure_crit_thd();
  _dbg_check_lock();
}
 80116a6:	bd08      	pop	{r3, pc}
 80116a8:	f3af 8000 	nop.w
 80116ac:	f3af 8000 	nop.w

080116b0 <chSysUnlock>:
/**
 * @brief   Leaves the kernel lock state.
 *
 * @special
 */
static inline void chSysUnlock(void) {
 80116b0:	b508      	push	{r3, lr}
     the ready list.*/
  chDbgAssert((ch.rlist.r_queue.p_next == (thread_t *)&ch.rlist.r_queue) ||
              (ch.rlist.r_current->p_prio >= ch.rlist.r_queue.p_next->p_prio),
              "priority order violation");

  port_unlock();
 80116b2:	f7ff ffed 	bl	8011690 <port_unlock>
}
 80116b6:	bd08      	pop	{r3, pc}
 80116b8:	f3af 8000 	nop.w
 80116bc:	f3af 8000 	nop.w

080116c0 <chVTGetSystemTimeX>:
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 80116c0:	4b01      	ldr	r3, [pc, #4]	; (80116c8 <chVTGetSystemTimeX+0x8>)
 80116c2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  return port_timer_get_time();
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 80116c4:	4618      	mov	r0, r3
 80116c6:	4770      	bx	lr
 80116c8:	20001bc8 	.word	0x20001bc8
 80116cc:	f3af 8000 	nop.w

080116d0 <chVTGetSystemTime>:
 *
 * @return              The system time in ticks.
 *
 * @api
 */
static inline systime_t chVTGetSystemTime(void) {
 80116d0:	b500      	push	{lr}
 80116d2:	b083      	sub	sp, #12
  systime_t systime;

  chSysLock();
 80116d4:	f7ff ffe4 	bl	80116a0 <chSysLock>
  systime = chVTGetSystemTimeX();
 80116d8:	f7ff fff2 	bl	80116c0 <chVTGetSystemTimeX>
 80116dc:	9001      	str	r0, [sp, #4]
  chSysUnlock();
 80116de:	f7ff ffe7 	bl	80116b0 <chSysUnlock>

  return systime;
 80116e2:	9b01      	ldr	r3, [sp, #4]
}
 80116e4:	4618      	mov	r0, r3
 80116e6:	b003      	add	sp, #12
 80116e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80116ec:	f3af 8000 	nop.w

080116f0 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 80116f0:	b082      	sub	sp, #8
 80116f2:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 80116f4:	4b02      	ldr	r3, [pc, #8]	; (8011700 <chRegSetThreadName+0x10>)
 80116f6:	699b      	ldr	r3, [r3, #24]
 80116f8:	9a01      	ldr	r2, [sp, #4]
 80116fa:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 80116fc:	b002      	add	sp, #8
 80116fe:	4770      	bx	lr
 8011700:	20001bc8 	.word	0x20001bc8
 8011704:	f3af 8000 	nop.w
 8011708:	f3af 8000 	nop.w
 801170c:	f3af 8000 	nop.w

08011710 <chEvtObjectInit>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {
 8011710:	b082      	sub	sp, #8
 8011712:	9001      	str	r0, [sp, #4]

  esp->es_next = (event_listener_t *)esp;
 8011714:	9b01      	ldr	r3, [sp, #4]
 8011716:	9a01      	ldr	r2, [sp, #4]
 8011718:	601a      	str	r2, [r3, #0]
}
 801171a:	b002      	add	sp, #8
 801171c:	4770      	bx	lr
 801171e:	bf00      	nop

08011720 <chEvtBroadcastI>:
 *
 * @param[in] esp       pointer to the @p event_source_t structure
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {
 8011720:	b500      	push	{lr}
 8011722:	b083      	sub	sp, #12
 8011724:	9001      	str	r0, [sp, #4]

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8011726:	9801      	ldr	r0, [sp, #4]
 8011728:	2100      	movs	r1, #0
 801172a:	f7f0 ffa9 	bl	8002680 <chEvtBroadcastFlagsI>
}
 801172e:	b003      	add	sp, #12
 8011730:	f85d fb04 	ldr.w	pc, [sp], #4
 8011734:	f3af 8000 	nop.w
 8011738:	f3af 8000 	nop.w
 801173c:	f3af 8000 	nop.w

08011740 <_strtok>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 8011740:	b500      	push	{lr}
 8011742:	b087      	sub	sp, #28
 8011744:	9003      	str	r0, [sp, #12]
 8011746:	9102      	str	r1, [sp, #8]
 8011748:	9201      	str	r2, [sp, #4]
  char *token;
  if (str)
 801174a:	9b03      	ldr	r3, [sp, #12]
 801174c:	2b00      	cmp	r3, #0
 801174e:	d002      	beq.n	8011756 <_strtok+0x16>
    *saveptr = str;
 8011750:	9b01      	ldr	r3, [sp, #4]
 8011752:	9a03      	ldr	r2, [sp, #12]
 8011754:	601a      	str	r2, [r3, #0]
  token = *saveptr;
 8011756:	9b01      	ldr	r3, [sp, #4]
 8011758:	681b      	ldr	r3, [r3, #0]
 801175a:	9305      	str	r3, [sp, #20]

  if (!token)
 801175c:	9b05      	ldr	r3, [sp, #20]
 801175e:	2b00      	cmp	r3, #0
 8011760:	d101      	bne.n	8011766 <_strtok+0x26>
    return NULL;
 8011762:	2300      	movs	r3, #0
 8011764:	e020      	b.n	80117a8 <_strtok+0x68>

  token += strspn(token, delim);
 8011766:	9805      	ldr	r0, [sp, #20]
 8011768:	9902      	ldr	r1, [sp, #8]
 801176a:	f006 f891 	bl	8017890 <strspn>
 801176e:	4603      	mov	r3, r0
 8011770:	9a05      	ldr	r2, [sp, #20]
 8011772:	4413      	add	r3, r2
 8011774:	9305      	str	r3, [sp, #20]
  *saveptr = strpbrk(token, delim);
 8011776:	9805      	ldr	r0, [sp, #20]
 8011778:	9902      	ldr	r1, [sp, #8]
 801177a:	f006 f861 	bl	8017840 <strpbrk>
 801177e:	4602      	mov	r2, r0
 8011780:	9b01      	ldr	r3, [sp, #4]
 8011782:	601a      	str	r2, [r3, #0]
  if (*saveptr)
 8011784:	9b01      	ldr	r3, [sp, #4]
 8011786:	681b      	ldr	r3, [r3, #0]
 8011788:	2b00      	cmp	r3, #0
 801178a:	d006      	beq.n	801179a <_strtok+0x5a>
    *(*saveptr)++ = '\0';
 801178c:	9b01      	ldr	r3, [sp, #4]
 801178e:	681b      	ldr	r3, [r3, #0]
 8011790:	1c59      	adds	r1, r3, #1
 8011792:	9a01      	ldr	r2, [sp, #4]
 8011794:	6011      	str	r1, [r2, #0]
 8011796:	2200      	movs	r2, #0
 8011798:	701a      	strb	r2, [r3, #0]

  return *token ? token : NULL;
 801179a:	9b05      	ldr	r3, [sp, #20]
 801179c:	781b      	ldrb	r3, [r3, #0]
 801179e:	2b00      	cmp	r3, #0
 80117a0:	d001      	beq.n	80117a6 <_strtok+0x66>
 80117a2:	9b05      	ldr	r3, [sp, #20]
 80117a4:	e000      	b.n	80117a8 <_strtok+0x68>
 80117a6:	2300      	movs	r3, #0
}
 80117a8:	4618      	mov	r0, r3
 80117aa:	b007      	add	sp, #28
 80117ac:	f85d fb04 	ldr.w	pc, [sp], #4

080117b0 <usage>:

static void usage(BaseSequentialStream *chp, char *p) {
 80117b0:	b500      	push	{lr}
 80117b2:	b083      	sub	sp, #12
 80117b4:	9001      	str	r0, [sp, #4]
 80117b6:	9100      	str	r1, [sp, #0]

  chprintf(chp, "Usage: %s\r\n", p);
 80117b8:	9801      	ldr	r0, [sp, #4]
 80117ba:	4903      	ldr	r1, [pc, #12]	; (80117c8 <usage+0x18>)
 80117bc:	9a00      	ldr	r2, [sp, #0]
 80117be:	f7ff ff17 	bl	80115f0 <chprintf>
}
 80117c2:	b003      	add	sp, #12
 80117c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80117c8:	0801a3d0 	.word	0x0801a3d0
 80117cc:	f3af 8000 	nop.w

080117d0 <list_commands>:

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {
 80117d0:	b500      	push	{lr}
 80117d2:	b083      	sub	sp, #12
 80117d4:	9001      	str	r0, [sp, #4]
 80117d6:	9100      	str	r1, [sp, #0]

  while (scp->sc_name != NULL) {
 80117d8:	e009      	b.n	80117ee <list_commands+0x1e>
    chprintf(chp, "%s ", scp->sc_name);
 80117da:	9b00      	ldr	r3, [sp, #0]
 80117dc:	681b      	ldr	r3, [r3, #0]
 80117de:	9801      	ldr	r0, [sp, #4]
 80117e0:	4906      	ldr	r1, [pc, #24]	; (80117fc <list_commands+0x2c>)
 80117e2:	461a      	mov	r2, r3
 80117e4:	f7ff ff04 	bl	80115f0 <chprintf>
    scp++;
 80117e8:	9b00      	ldr	r3, [sp, #0]
 80117ea:	3308      	adds	r3, #8
 80117ec:	9300      	str	r3, [sp, #0]
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 80117ee:	9b00      	ldr	r3, [sp, #0]
 80117f0:	681b      	ldr	r3, [r3, #0]
 80117f2:	2b00      	cmp	r3, #0
 80117f4:	d1f1      	bne.n	80117da <list_commands+0xa>
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}
 80117f6:	b003      	add	sp, #12
 80117f8:	f85d fb04 	ldr.w	pc, [sp], #4
 80117fc:	0801a3dc 	.word	0x0801a3dc

08011800 <cmd_info>:

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8011800:	b500      	push	{lr}
 8011802:	b087      	sub	sp, #28
 8011804:	9005      	str	r0, [sp, #20]
 8011806:	9104      	str	r1, [sp, #16]
 8011808:	9203      	str	r2, [sp, #12]

  (void)argv;
  if (argc > 0) {
 801180a:	9b04      	ldr	r3, [sp, #16]
 801180c:	2b00      	cmp	r3, #0
 801180e:	dd04      	ble.n	801181a <cmd_info+0x1a>
    usage(chp, "info");
 8011810:	9805      	ldr	r0, [sp, #20]
 8011812:	4919      	ldr	r1, [pc, #100]	; (8011878 <cmd_info+0x78>)
 8011814:	f7ff ffcc 	bl	80117b0 <usage>
    return;
 8011818:	e02a      	b.n	8011870 <cmd_info+0x70>
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 801181a:	9805      	ldr	r0, [sp, #20]
 801181c:	4917      	ldr	r1, [pc, #92]	; (801187c <cmd_info+0x7c>)
 801181e:	4a18      	ldr	r2, [pc, #96]	; (8011880 <cmd_info+0x80>)
 8011820:	f7ff fee6 	bl	80115f0 <chprintf>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8011824:	9805      	ldr	r0, [sp, #20]
 8011826:	4917      	ldr	r1, [pc, #92]	; (8011884 <cmd_info+0x84>)
 8011828:	4a17      	ldr	r2, [pc, #92]	; (8011888 <cmd_info+0x88>)
 801182a:	f7ff fee1 	bl	80115f0 <chprintf>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 801182e:	9805      	ldr	r0, [sp, #20]
 8011830:	4916      	ldr	r1, [pc, #88]	; (801188c <cmd_info+0x8c>)
 8011832:	4a17      	ldr	r2, [pc, #92]	; (8011890 <cmd_info+0x90>)
 8011834:	f7ff fedc 	bl	80115f0 <chprintf>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8011838:	9805      	ldr	r0, [sp, #20]
 801183a:	4916      	ldr	r1, [pc, #88]	; (8011894 <cmd_info+0x94>)
 801183c:	4a16      	ldr	r2, [pc, #88]	; (8011898 <cmd_info+0x98>)
 801183e:	f7ff fed7 	bl	80115f0 <chprintf>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8011842:	9805      	ldr	r0, [sp, #20]
 8011844:	4915      	ldr	r1, [pc, #84]	; (801189c <cmd_info+0x9c>)
 8011846:	4a16      	ldr	r2, [pc, #88]	; (80118a0 <cmd_info+0xa0>)
 8011848:	f7ff fed2 	bl	80115f0 <chprintf>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 801184c:	9805      	ldr	r0, [sp, #20]
 801184e:	4915      	ldr	r1, [pc, #84]	; (80118a4 <cmd_info+0xa4>)
 8011850:	4a15      	ldr	r2, [pc, #84]	; (80118a8 <cmd_info+0xa8>)
 8011852:	f7ff fecd 	bl	80115f0 <chprintf>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8011856:	9805      	ldr	r0, [sp, #20]
 8011858:	4914      	ldr	r1, [pc, #80]	; (80118ac <cmd_info+0xac>)
 801185a:	4a15      	ldr	r2, [pc, #84]	; (80118b0 <cmd_info+0xb0>)
 801185c:	f7ff fec8 	bl	80115f0 <chprintf>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8011860:	4b14      	ldr	r3, [pc, #80]	; (80118b4 <cmd_info+0xb4>)
 8011862:	9300      	str	r3, [sp, #0]
 8011864:	9805      	ldr	r0, [sp, #20]
 8011866:	4914      	ldr	r1, [pc, #80]	; (80118b8 <cmd_info+0xb8>)
 8011868:	4a14      	ldr	r2, [pc, #80]	; (80118bc <cmd_info+0xbc>)
 801186a:	4b15      	ldr	r3, [pc, #84]	; (80118c0 <cmd_info+0xc0>)
 801186c:	f7ff fec0 	bl	80115f0 <chprintf>
#endif
#endif
}
 8011870:	b007      	add	sp, #28
 8011872:	f85d fb04 	ldr.w	pc, [sp], #4
 8011876:	bf00      	nop
 8011878:	0801a3e0 	.word	0x0801a3e0
 801187c:	0801a3e8 	.word	0x0801a3e8
 8011880:	0801a3fc 	.word	0x0801a3fc
 8011884:	0801a404 	.word	0x0801a404
 8011888:	0801a418 	.word	0x0801a418
 801188c:	0801a460 	.word	0x0801a460
 8011890:	0801a474 	.word	0x0801a474
 8011894:	0801a480 	.word	0x0801a480
 8011898:	0801a494 	.word	0x0801a494
 801189c:	0801a4a0 	.word	0x0801a4a0
 80118a0:	0801a4b4 	.word	0x0801a4b4
 80118a4:	0801a4cc 	.word	0x0801a4cc
 80118a8:	0801a4e0 	.word	0x0801a4e0
 80118ac:	0801a4fc 	.word	0x0801a4fc
 80118b0:	0801a510 	.word	0x0801a510
 80118b4:	0801a548 	.word	0x0801a548
 80118b8:	0801a520 	.word	0x0801a520
 80118bc:	0801a538 	.word	0x0801a538
 80118c0:	0801a544 	.word	0x0801a544
 80118c4:	f3af 8000 	nop.w
 80118c8:	f3af 8000 	nop.w
 80118cc:	f3af 8000 	nop.w

080118d0 <cmd_systime>:

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {
 80118d0:	b500      	push	{lr}
 80118d2:	b085      	sub	sp, #20
 80118d4:	9003      	str	r0, [sp, #12]
 80118d6:	9102      	str	r1, [sp, #8]
 80118d8:	9201      	str	r2, [sp, #4]

  (void)argv;
  if (argc > 0) {
 80118da:	9b02      	ldr	r3, [sp, #8]
 80118dc:	2b00      	cmp	r3, #0
 80118de:	dd04      	ble.n	80118ea <cmd_systime+0x1a>
    usage(chp, "systime");
 80118e0:	9803      	ldr	r0, [sp, #12]
 80118e2:	4907      	ldr	r1, [pc, #28]	; (8011900 <cmd_systime+0x30>)
 80118e4:	f7ff ff64 	bl	80117b0 <usage>
    return;
 80118e8:	e007      	b.n	80118fa <cmd_systime+0x2a>
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 80118ea:	f7ff fef1 	bl	80116d0 <chVTGetSystemTime>
 80118ee:	4603      	mov	r3, r0
 80118f0:	9803      	ldr	r0, [sp, #12]
 80118f2:	4904      	ldr	r1, [pc, #16]	; (8011904 <cmd_systime+0x34>)
 80118f4:	461a      	mov	r2, r3
 80118f6:	f7ff fe7b 	bl	80115f0 <chprintf>
}
 80118fa:	b005      	add	sp, #20
 80118fc:	f85d fb04 	ldr.w	pc, [sp], #4
 8011900:	0801a554 	.word	0x0801a554
 8011904:	0801a55c 	.word	0x0801a55c
 8011908:	f3af 8000 	nop.w
 801190c:	f3af 8000 	nop.w

08011910 <cmdexec>:
  {"systime", cmd_systime},
  {NULL, NULL}
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {
 8011910:	b500      	push	{lr}
 8011912:	b085      	sub	sp, #20
 8011914:	9003      	str	r0, [sp, #12]
 8011916:	9102      	str	r1, [sp, #8]
 8011918:	9201      	str	r2, [sp, #4]
 801191a:	9300      	str	r3, [sp, #0]

  while (scp->sc_name != NULL) {
 801191c:	e013      	b.n	8011946 <cmdexec+0x36>
    if (strcmp(scp->sc_name, name) == 0) {
 801191e:	9b03      	ldr	r3, [sp, #12]
 8011920:	681b      	ldr	r3, [r3, #0]
 8011922:	4618      	mov	r0, r3
 8011924:	9901      	ldr	r1, [sp, #4]
 8011926:	f005 f8b3 	bl	8016a90 <strcmp>
 801192a:	4603      	mov	r3, r0
 801192c:	2b00      	cmp	r3, #0
 801192e:	d107      	bne.n	8011940 <cmdexec+0x30>
      scp->sc_function(chp, argc, argv);
 8011930:	9b03      	ldr	r3, [sp, #12]
 8011932:	685b      	ldr	r3, [r3, #4]
 8011934:	9802      	ldr	r0, [sp, #8]
 8011936:	9900      	ldr	r1, [sp, #0]
 8011938:	9a06      	ldr	r2, [sp, #24]
 801193a:	4798      	blx	r3
      return false;
 801193c:	2300      	movs	r3, #0
 801193e:	e007      	b.n	8011950 <cmdexec+0x40>
    }
    scp++;
 8011940:	9b03      	ldr	r3, [sp, #12]
 8011942:	3308      	adds	r3, #8
 8011944:	9303      	str	r3, [sp, #12]
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8011946:	9b03      	ldr	r3, [sp, #12]
 8011948:	681b      	ldr	r3, [r3, #0]
 801194a:	2b00      	cmp	r3, #0
 801194c:	d1e7      	bne.n	801191e <cmdexec+0xe>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
  }
  return true;
 801194e:	2301      	movs	r3, #1
}
 8011950:	4618      	mov	r0, r3
 8011952:	b005      	add	sp, #20
 8011954:	f85d fb04 	ldr.w	pc, [sp], #4
 8011958:	f3af 8000 	nop.w
 801195c:	f3af 8000 	nop.w

08011960 <shell_thread>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8011960:	b500      	push	{lr}
 8011962:	b0a1      	sub	sp, #132	; 0x84
 8011964:	9003      	str	r0, [sp, #12]
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
 8011966:	9b03      	ldr	r3, [sp, #12]
 8011968:	681b      	ldr	r3, [r3, #0]
 801196a:	931d      	str	r3, [sp, #116]	; 0x74
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 801196c:	9b03      	ldr	r3, [sp, #12]
 801196e:	685b      	ldr	r3, [r3, #4]
 8011970:	931c      	str	r3, [sp, #112]	; 0x70
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
 8011972:	4855      	ldr	r0, [pc, #340]	; (8011ac8 <shell_thread+0x168>)
 8011974:	f7ff febc 	bl	80116f0 <chRegSetThreadName>
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8011978:	981d      	ldr	r0, [sp, #116]	; 0x74
 801197a:	4954      	ldr	r1, [pc, #336]	; (8011acc <shell_thread+0x16c>)
 801197c:	f7ff fe38 	bl	80115f0 <chprintf>
  while (true) {
    chprintf(chp, "ch> ");
 8011980:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011982:	4953      	ldr	r1, [pc, #332]	; (8011ad0 <shell_thread+0x170>)
 8011984:	f7ff fe34 	bl	80115f0 <chprintf>
    if (shellGetLine(chp, line, sizeof(line))) {
 8011988:	ab0a      	add	r3, sp, #40	; 0x28
 801198a:	981d      	ldr	r0, [sp, #116]	; 0x74
 801198c:	4619      	mov	r1, r3
 801198e:	2240      	movs	r2, #64	; 0x40
 8011990:	f000 f8fe 	bl	8011b90 <shellGetLine>
 8011994:	4603      	mov	r3, r0
 8011996:	2b00      	cmp	r3, #0
 8011998:	d004      	beq.n	80119a4 <shell_thread+0x44>
      chprintf(chp, "\r\nlogout");
 801199a:	981d      	ldr	r0, [sp, #116]	; 0x74
 801199c:	494d      	ldr	r1, [pc, #308]	; (8011ad4 <shell_thread+0x174>)
 801199e:	f7ff fe27 	bl	80115f0 <chprintf>
      break;
 80119a2:	e08a      	b.n	8011aba <shell_thread+0x15a>
    }
    lp = _strtok(line, " \t", &tokp);
 80119a4:	aa0a      	add	r2, sp, #40	; 0x28
 80119a6:	ab1a      	add	r3, sp, #104	; 0x68
 80119a8:	4610      	mov	r0, r2
 80119aa:	494b      	ldr	r1, [pc, #300]	; (8011ad8 <shell_thread+0x178>)
 80119ac:	461a      	mov	r2, r3
 80119ae:	f7ff fec7 	bl	8011740 <_strtok>
 80119b2:	901b      	str	r0, [sp, #108]	; 0x6c
    cmd = lp;
 80119b4:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80119b6:	931e      	str	r3, [sp, #120]	; 0x78
    n = 0;
 80119b8:	2300      	movs	r3, #0
 80119ba:	931f      	str	r3, [sp, #124]	; 0x7c
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80119bc:	e012      	b.n	80119e4 <shell_thread+0x84>
      if (n >= SHELL_MAX_ARGUMENTS) {
 80119be:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80119c0:	2b03      	cmp	r3, #3
 80119c2:	dd06      	ble.n	80119d2 <shell_thread+0x72>
        chprintf(chp, "too many arguments\r\n");
 80119c4:	981d      	ldr	r0, [sp, #116]	; 0x74
 80119c6:	4945      	ldr	r1, [pc, #276]	; (8011adc <shell_thread+0x17c>)
 80119c8:	f7ff fe12 	bl	80115f0 <chprintf>
        cmd = NULL;
 80119cc:	2300      	movs	r3, #0
 80119ce:	931e      	str	r3, [sp, #120]	; 0x78
        break;
 80119d0:	e012      	b.n	80119f8 <shell_thread+0x98>
      }
      args[n++] = lp;
 80119d2:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80119d4:	1c5a      	adds	r2, r3, #1
 80119d6:	921f      	str	r2, [sp, #124]	; 0x7c
 80119d8:	009b      	lsls	r3, r3, #2
 80119da:	aa20      	add	r2, sp, #128	; 0x80
 80119dc:	4413      	add	r3, r2
 80119de:	9a1b      	ldr	r2, [sp, #108]	; 0x6c
 80119e0:	f843 2c6c 	str.w	r2, [r3, #-108]
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 80119e4:	ab1a      	add	r3, sp, #104	; 0x68
 80119e6:	2000      	movs	r0, #0
 80119e8:	493b      	ldr	r1, [pc, #236]	; (8011ad8 <shell_thread+0x178>)
 80119ea:	461a      	mov	r2, r3
 80119ec:	f7ff fea8 	bl	8011740 <_strtok>
 80119f0:	901b      	str	r0, [sp, #108]	; 0x6c
 80119f2:	9b1b      	ldr	r3, [sp, #108]	; 0x6c
 80119f4:	2b00      	cmp	r3, #0
 80119f6:	d1e2      	bne.n	80119be <shell_thread+0x5e>
        cmd = NULL;
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 80119f8:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 80119fa:	009b      	lsls	r3, r3, #2
 80119fc:	aa20      	add	r2, sp, #128	; 0x80
 80119fe:	4413      	add	r3, r2
 8011a00:	2200      	movs	r2, #0
 8011a02:	f843 2c6c 	str.w	r2, [r3, #-108]
    if (cmd != NULL) {
 8011a06:	9b1e      	ldr	r3, [sp, #120]	; 0x78
 8011a08:	2b00      	cmp	r3, #0
 8011a0a:	d055      	beq.n	8011ab8 <shell_thread+0x158>
      if (strcmp(cmd, "exit") == 0) {
 8011a0c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011a0e:	4934      	ldr	r1, [pc, #208]	; (8011ae0 <shell_thread+0x180>)
 8011a10:	f005 f83e 	bl	8016a90 <strcmp>
 8011a14:	4603      	mov	r3, r0
 8011a16:	2b00      	cmp	r3, #0
 8011a18:	d108      	bne.n	8011a2c <shell_thread+0xcc>
        if (n > 0) {
 8011a1a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a1c:	2b00      	cmp	r3, #0
 8011a1e:	dd04      	ble.n	8011a2a <shell_thread+0xca>
          usage(chp, "exit");
 8011a20:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a22:	492f      	ldr	r1, [pc, #188]	; (8011ae0 <shell_thread+0x180>)
 8011a24:	f7ff fec4 	bl	80117b0 <usage>
          continue;
 8011a28:	e046      	b.n	8011ab8 <shell_thread+0x158>
        }
        break;
 8011a2a:	e046      	b.n	8011aba <shell_thread+0x15a>
      }
      else if (strcmp(cmd, "help") == 0) {
 8011a2c:	981e      	ldr	r0, [sp, #120]	; 0x78
 8011a2e:	492d      	ldr	r1, [pc, #180]	; (8011ae4 <shell_thread+0x184>)
 8011a30:	f005 f82e 	bl	8016a90 <strcmp>
 8011a34:	4603      	mov	r3, r0
 8011a36:	2b00      	cmp	r3, #0
 8011a38:	d11b      	bne.n	8011a72 <shell_thread+0x112>
        if (n > 0) {
 8011a3a:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a3c:	2b00      	cmp	r3, #0
 8011a3e:	dd04      	ble.n	8011a4a <shell_thread+0xea>
          usage(chp, "help");
 8011a40:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a42:	4928      	ldr	r1, [pc, #160]	; (8011ae4 <shell_thread+0x184>)
 8011a44:	f7ff feb4 	bl	80117b0 <usage>
          continue;
 8011a48:	e036      	b.n	8011ab8 <shell_thread+0x158>
        }
        chprintf(chp, "Commands: help exit ");
 8011a4a:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a4c:	4926      	ldr	r1, [pc, #152]	; (8011ae8 <shell_thread+0x188>)
 8011a4e:	f7ff fdcf 	bl	80115f0 <chprintf>
        list_commands(chp, local_commands);
 8011a52:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a54:	4925      	ldr	r1, [pc, #148]	; (8011aec <shell_thread+0x18c>)
 8011a56:	f7ff febb 	bl	80117d0 <list_commands>
        if (scp != NULL)
 8011a5a:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011a5c:	2b00      	cmp	r3, #0
 8011a5e:	d003      	beq.n	8011a68 <shell_thread+0x108>
          list_commands(chp, scp);
 8011a60:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a62:	991c      	ldr	r1, [sp, #112]	; 0x70
 8011a64:	f7ff feb4 	bl	80117d0 <list_commands>
        chprintf(chp, "\r\n");
 8011a68:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011a6a:	4921      	ldr	r1, [pc, #132]	; (8011af0 <shell_thread+0x190>)
 8011a6c:	f7ff fdc0 	bl	80115f0 <chprintf>
 8011a70:	e022      	b.n	8011ab8 <shell_thread+0x158>
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8011a72:	ab05      	add	r3, sp, #20
 8011a74:	9300      	str	r3, [sp, #0]
 8011a76:	481d      	ldr	r0, [pc, #116]	; (8011aec <shell_thread+0x18c>)
 8011a78:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011a7a:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011a7c:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a7e:	f7ff ff47 	bl	8011910 <cmdexec>
 8011a82:	4603      	mov	r3, r0
 8011a84:	2b00      	cmp	r3, #0
 8011a86:	d017      	beq.n	8011ab8 <shell_thread+0x158>
 8011a88:	9b1c      	ldr	r3, [sp, #112]	; 0x70
 8011a8a:	2b00      	cmp	r3, #0
 8011a8c:	d00a      	beq.n	8011aa4 <shell_thread+0x144>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
 8011a8e:	ab05      	add	r3, sp, #20
 8011a90:	9300      	str	r3, [sp, #0]
 8011a92:	981c      	ldr	r0, [sp, #112]	; 0x70
 8011a94:	991d      	ldr	r1, [sp, #116]	; 0x74
 8011a96:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011a98:	9b1f      	ldr	r3, [sp, #124]	; 0x7c
 8011a9a:	f7ff ff39 	bl	8011910 <cmdexec>
 8011a9e:	4603      	mov	r3, r0
 8011aa0:	2b00      	cmp	r3, #0
 8011aa2:	d009      	beq.n	8011ab8 <shell_thread+0x158>
        chprintf(chp, "%s", cmd);
 8011aa4:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011aa6:	4913      	ldr	r1, [pc, #76]	; (8011af4 <shell_thread+0x194>)
 8011aa8:	9a1e      	ldr	r2, [sp, #120]	; 0x78
 8011aaa:	f7ff fda1 	bl	80115f0 <chprintf>
        chprintf(chp, " ?\r\n");
 8011aae:	981d      	ldr	r0, [sp, #116]	; 0x74
 8011ab0:	4911      	ldr	r1, [pc, #68]	; (8011af8 <shell_thread+0x198>)
 8011ab2:	f7ff fd9d 	bl	80115f0 <chprintf>
      }
    }
  }
 8011ab6:	e763      	b.n	8011980 <shell_thread+0x20>
 8011ab8:	e762      	b.n	8011980 <shell_thread+0x20>
  shellExit(MSG_OK);
 8011aba:	2000      	movs	r0, #0
 8011abc:	f000 f828 	bl	8011b10 <shellExit>
}
 8011ac0:	b021      	add	sp, #132	; 0x84
 8011ac2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011ac6:	bf00      	nop
 8011ac8:	0801a57c 	.word	0x0801a57c
 8011acc:	0801a584 	.word	0x0801a584
 8011ad0:	0801a59c 	.word	0x0801a59c
 8011ad4:	0801a5a4 	.word	0x0801a5a4
 8011ad8:	0801a5b0 	.word	0x0801a5b0
 8011adc:	0801a5b4 	.word	0x0801a5b4
 8011ae0:	0801a5cc 	.word	0x0801a5cc
 8011ae4:	0801a5d4 	.word	0x0801a5d4
 8011ae8:	0801a5dc 	.word	0x0801a5dc
 8011aec:	0801a564 	.word	0x0801a564
 8011af0:	0801a5f4 	.word	0x0801a5f4
 8011af4:	0801a5f8 	.word	0x0801a5f8
 8011af8:	0801a5fc 	.word	0x0801a5fc
 8011afc:	f3af 8000 	nop.w

08011b00 <shellInit>:
/**
 * @brief   Shell manager initialization.
 *
 * @api
 */
void shellInit(void) {
 8011b00:	b508      	push	{r3, lr}

  chEvtObjectInit(&shell_terminated);
 8011b02:	4802      	ldr	r0, [pc, #8]	; (8011b0c <shellInit+0xc>)
 8011b04:	f7ff fe04 	bl	8011710 <chEvtObjectInit>
}
 8011b08:	bd08      	pop	{r3, pc}
 8011b0a:	bf00      	nop
 8011b0c:	200026d8 	.word	0x200026d8

08011b10 <shellExit>:
 *
 * @param[in] msg       shell exit code
 *
 * @api
 */
void shellExit(msg_t msg) {
 8011b10:	b500      	push	{lr}
 8011b12:	b083      	sub	sp, #12
 8011b14:	9001      	str	r0, [sp, #4]

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
 8011b16:	f7ff fdc3 	bl	80116a0 <chSysLock>
  chEvtBroadcastI(&shell_terminated);
 8011b1a:	4804      	ldr	r0, [pc, #16]	; (8011b2c <shellExit+0x1c>)
 8011b1c:	f7ff fe00 	bl	8011720 <chEvtBroadcastI>
  chThdExitS(msg);
 8011b20:	9801      	ldr	r0, [sp, #4]
 8011b22:	f7ef fc35 	bl	8001390 <chThdExitS>
}
 8011b26:	b003      	add	sp, #12
 8011b28:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b2c:	200026d8 	.word	0x200026d8

08011b30 <shellCreate>:
 * @retval NULL         thread creation failed because memory allocation.
 *
 * @api
 */
#if CH_CFG_USE_HEAP && CH_CFG_USE_DYNAMIC
thread_t *shellCreate(const ShellConfig *scp, size_t size, tprio_t prio) {
 8011b30:	b500      	push	{lr}
 8011b32:	b087      	sub	sp, #28
 8011b34:	9005      	str	r0, [sp, #20]
 8011b36:	9104      	str	r1, [sp, #16]
 8011b38:	9203      	str	r2, [sp, #12]

  return chThdCreateFromHeap(NULL, size, prio, shell_thread, (void *)scp);
 8011b3a:	9b05      	ldr	r3, [sp, #20]
 8011b3c:	9300      	str	r3, [sp, #0]
 8011b3e:	2000      	movs	r0, #0
 8011b40:	9904      	ldr	r1, [sp, #16]
 8011b42:	9a03      	ldr	r2, [sp, #12]
 8011b44:	4b03      	ldr	r3, [pc, #12]	; (8011b54 <shellCreate+0x24>)
 8011b46:	f7ef fe83 	bl	8001850 <chThdCreateFromHeap>
 8011b4a:	4603      	mov	r3, r0
}
 8011b4c:	4618      	mov	r0, r3
 8011b4e:	b007      	add	sp, #28
 8011b50:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b54:	08011961 	.word	0x08011961
 8011b58:	f3af 8000 	nop.w
 8011b5c:	f3af 8000 	nop.w

08011b60 <shellCreateStatic>:
 * @return              A pointer to the shell thread.
 *
 * @api
 */
thread_t *shellCreateStatic(const ShellConfig *scp, void *wsp,
                            size_t size, tprio_t prio) {
 8011b60:	b500      	push	{lr}
 8011b62:	b087      	sub	sp, #28
 8011b64:	9005      	str	r0, [sp, #20]
 8011b66:	9104      	str	r1, [sp, #16]
 8011b68:	9203      	str	r2, [sp, #12]
 8011b6a:	9302      	str	r3, [sp, #8]

  return chThdCreateStatic(wsp, size, prio, shell_thread, (void *)scp);
 8011b6c:	9b05      	ldr	r3, [sp, #20]
 8011b6e:	9300      	str	r3, [sp, #0]
 8011b70:	9804      	ldr	r0, [sp, #16]
 8011b72:	9903      	ldr	r1, [sp, #12]
 8011b74:	9a02      	ldr	r2, [sp, #8]
 8011b76:	4b04      	ldr	r3, [pc, #16]	; (8011b88 <shellCreateStatic+0x28>)
 8011b78:	f7ef fb32 	bl	80011e0 <chThdCreateStatic>
 8011b7c:	4603      	mov	r3, r0
}
 8011b7e:	4618      	mov	r0, r3
 8011b80:	b007      	add	sp, #28
 8011b82:	f85d fb04 	ldr.w	pc, [sp], #4
 8011b86:	bf00      	nop
 8011b88:	08011961 	.word	0x08011961
 8011b8c:	f3af 8000 	nop.w

08011b90 <shellGetLine>:
 * @retval true         the channel was reset or CTRL-D pressed.
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
 8011b90:	b500      	push	{lr}
 8011b92:	b087      	sub	sp, #28
 8011b94:	9003      	str	r0, [sp, #12]
 8011b96:	9102      	str	r1, [sp, #8]
 8011b98:	9201      	str	r2, [sp, #4]
  char *p = line;
 8011b9a:	9b02      	ldr	r3, [sp, #8]
 8011b9c:	9305      	str	r3, [sp, #20]

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8011b9e:	9b03      	ldr	r3, [sp, #12]
 8011ba0:	681b      	ldr	r3, [r3, #0]
 8011ba2:	685b      	ldr	r3, [r3, #4]
 8011ba4:	f10d 0213 	add.w	r2, sp, #19
 8011ba8:	9803      	ldr	r0, [sp, #12]
 8011baa:	4611      	mov	r1, r2
 8011bac:	2201      	movs	r2, #1
 8011bae:	4798      	blx	r3
 8011bb0:	4603      	mov	r3, r0
 8011bb2:	2b00      	cmp	r3, #0
 8011bb4:	d101      	bne.n	8011bba <shellGetLine+0x2a>
      return true;
 8011bb6:	2301      	movs	r3, #1
 8011bb8:	e055      	b.n	8011c66 <shellGetLine+0xd6>
    if (c == 4) {
 8011bba:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011bbe:	2b04      	cmp	r3, #4
 8011bc0:	d105      	bne.n	8011bce <shellGetLine+0x3e>
      chprintf(chp, "^D");
 8011bc2:	9803      	ldr	r0, [sp, #12]
 8011bc4:	492a      	ldr	r1, [pc, #168]	; (8011c70 <shellGetLine+0xe0>)
 8011bc6:	f7ff fd13 	bl	80115f0 <chprintf>
      return true;
 8011bca:	2301      	movs	r3, #1
 8011bcc:	e04b      	b.n	8011c66 <shellGetLine+0xd6>
    }
    if ((c == 8) || (c == 127)) {
 8011bce:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011bd2:	2b08      	cmp	r3, #8
 8011bd4:	d003      	beq.n	8011bde <shellGetLine+0x4e>
 8011bd6:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011bda:	2b7f      	cmp	r3, #127	; 0x7f
 8011bdc:	d11a      	bne.n	8011c14 <shellGetLine+0x84>
      if (p != line) {
 8011bde:	9a05      	ldr	r2, [sp, #20]
 8011be0:	9b02      	ldr	r3, [sp, #8]
 8011be2:	429a      	cmp	r2, r3
 8011be4:	d015      	beq.n	8011c12 <shellGetLine+0x82>
        chSequentialStreamPut(chp, 0x08);
 8011be6:	9b03      	ldr	r3, [sp, #12]
 8011be8:	681b      	ldr	r3, [r3, #0]
 8011bea:	689b      	ldr	r3, [r3, #8]
 8011bec:	9803      	ldr	r0, [sp, #12]
 8011bee:	2108      	movs	r1, #8
 8011bf0:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8011bf2:	9b03      	ldr	r3, [sp, #12]
 8011bf4:	681b      	ldr	r3, [r3, #0]
 8011bf6:	689b      	ldr	r3, [r3, #8]
 8011bf8:	9803      	ldr	r0, [sp, #12]
 8011bfa:	2120      	movs	r1, #32
 8011bfc:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x08);
 8011bfe:	9b03      	ldr	r3, [sp, #12]
 8011c00:	681b      	ldr	r3, [r3, #0]
 8011c02:	689b      	ldr	r3, [r3, #8]
 8011c04:	9803      	ldr	r0, [sp, #12]
 8011c06:	2108      	movs	r1, #8
 8011c08:	4798      	blx	r3
        p--;
 8011c0a:	9b05      	ldr	r3, [sp, #20]
 8011c0c:	3b01      	subs	r3, #1
 8011c0e:	9305      	str	r3, [sp, #20]
      }
      continue;
 8011c10:	e028      	b.n	8011c64 <shellGetLine+0xd4>
 8011c12:	e027      	b.n	8011c64 <shellGetLine+0xd4>
    }
    if (c == '\r') {
 8011c14:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c18:	2b0d      	cmp	r3, #13
 8011c1a:	d108      	bne.n	8011c2e <shellGetLine+0x9e>
      chprintf(chp, "\r\n");
 8011c1c:	9803      	ldr	r0, [sp, #12]
 8011c1e:	4915      	ldr	r1, [pc, #84]	; (8011c74 <shellGetLine+0xe4>)
 8011c20:	f7ff fce6 	bl	80115f0 <chprintf>
      *p = 0;
 8011c24:	9b05      	ldr	r3, [sp, #20]
 8011c26:	2200      	movs	r2, #0
 8011c28:	701a      	strb	r2, [r3, #0]
      return false;
 8011c2a:	2300      	movs	r3, #0
 8011c2c:	e01b      	b.n	8011c66 <shellGetLine+0xd6>
    }
    if (c < 0x20)
 8011c2e:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011c32:	2b1f      	cmp	r3, #31
 8011c34:	d800      	bhi.n	8011c38 <shellGetLine+0xa8>
      continue;
 8011c36:	e015      	b.n	8011c64 <shellGetLine+0xd4>
    if (p < line + size - 1) {
 8011c38:	9b01      	ldr	r3, [sp, #4]
 8011c3a:	3b01      	subs	r3, #1
 8011c3c:	9a02      	ldr	r2, [sp, #8]
 8011c3e:	441a      	add	r2, r3
 8011c40:	9b05      	ldr	r3, [sp, #20]
 8011c42:	429a      	cmp	r2, r3
 8011c44:	d90e      	bls.n	8011c64 <shellGetLine+0xd4>
      chSequentialStreamPut(chp, c);
 8011c46:	9b03      	ldr	r3, [sp, #12]
 8011c48:	681b      	ldr	r3, [r3, #0]
 8011c4a:	689b      	ldr	r3, [r3, #8]
 8011c4c:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011c50:	9803      	ldr	r0, [sp, #12]
 8011c52:	4611      	mov	r1, r2
 8011c54:	4798      	blx	r3
      *p++ = (char)c;
 8011c56:	9b05      	ldr	r3, [sp, #20]
 8011c58:	1c5a      	adds	r2, r3, #1
 8011c5a:	9205      	str	r2, [sp, #20]
 8011c5c:	f89d 2013 	ldrb.w	r2, [sp, #19]
 8011c60:	701a      	strb	r2, [r3, #0]
    }
  }
 8011c62:	e79c      	b.n	8011b9e <shellGetLine+0xe>
 8011c64:	e79b      	b.n	8011b9e <shellGetLine+0xe>
}
 8011c66:	4618      	mov	r0, r3
 8011c68:	b007      	add	sp, #28
 8011c6a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011c6e:	bf00      	nop
 8011c70:	0801a604 	.word	0x0801a604
 8011c74:	0801a5f4 	.word	0x0801a5f4
 8011c78:	f3af 8000 	nop.w
 8011c7c:	f3af 8000 	nop.w

08011c80 <_read_r>:

/***************************************************************************/

__attribute__((used))
int _read_r(struct _reent *r, int file, char * ptr, int len)
{
 8011c80:	b084      	sub	sp, #16
 8011c82:	9003      	str	r0, [sp, #12]
 8011c84:	9102      	str	r1, [sp, #8]
 8011c86:	9201      	str	r2, [sp, #4]
 8011c88:	9300      	str	r3, [sp, #0]
  return len;
#else
  (void)file;
  (void)ptr;
  (void)len;
  __errno_r(r) = EINVAL;
 8011c8a:	9b03      	ldr	r3, [sp, #12]
 8011c8c:	2216      	movs	r2, #22
 8011c8e:	601a      	str	r2, [r3, #0]
  return -1;
 8011c90:	f04f 33ff 	mov.w	r3, #4294967295
#endif
}
 8011c94:	4618      	mov	r0, r3
 8011c96:	b004      	add	sp, #16
 8011c98:	4770      	bx	lr
 8011c9a:	bf00      	nop
 8011c9c:	f3af 8000 	nop.w

08011ca0 <_lseek_r>:

/***************************************************************************/

__attribute__((used))
int _lseek_r(struct _reent *r, int file, int ptr, int dir)
{
 8011ca0:	b084      	sub	sp, #16
 8011ca2:	9003      	str	r0, [sp, #12]
 8011ca4:	9102      	str	r1, [sp, #8]
 8011ca6:	9201      	str	r2, [sp, #4]
 8011ca8:	9300      	str	r3, [sp, #0]
  (void)r;
  (void)file;
  (void)ptr;
  (void)dir;

  return 0;
 8011caa:	2300      	movs	r3, #0
}
 8011cac:	4618      	mov	r0, r3
 8011cae:	b004      	add	sp, #16
 8011cb0:	4770      	bx	lr
 8011cb2:	bf00      	nop
 8011cb4:	f3af 8000 	nop.w
 8011cb8:	f3af 8000 	nop.w
 8011cbc:	f3af 8000 	nop.w

08011cc0 <_write_r>:

/***************************************************************************/

__attribute__((used))
int _write_r(struct _reent *r, int file, char * ptr, int len)
{
 8011cc0:	b084      	sub	sp, #16
 8011cc2:	9003      	str	r0, [sp, #12]
 8011cc4:	9102      	str	r1, [sp, #8]
 8011cc6:	9201      	str	r2, [sp, #4]
 8011cc8:	9300      	str	r3, [sp, #0]
    __errno_r(r) = EINVAL;
    return -1;
  }
  sdWrite(&STDOUT_SD, (uint8_t *)ptr, (size_t)len);
#endif
  return len;
 8011cca:	9b00      	ldr	r3, [sp, #0]
}
 8011ccc:	4618      	mov	r0, r3
 8011cce:	b004      	add	sp, #16
 8011cd0:	4770      	bx	lr
 8011cd2:	bf00      	nop
 8011cd4:	f3af 8000 	nop.w
 8011cd8:	f3af 8000 	nop.w
 8011cdc:	f3af 8000 	nop.w

08011ce0 <_close_r>:

/***************************************************************************/

__attribute__((used))
int _close_r(struct _reent *r, int file)
{
 8011ce0:	b082      	sub	sp, #8
 8011ce2:	9001      	str	r0, [sp, #4]
 8011ce4:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)file;

  return 0;
 8011ce6:	2300      	movs	r3, #0
}
 8011ce8:	4618      	mov	r0, r3
 8011cea:	b002      	add	sp, #8
 8011cec:	4770      	bx	lr
 8011cee:	bf00      	nop

08011cf0 <_sbrk_r>:

/***************************************************************************/

__attribute__((used))
caddr_t _sbrk_r(struct _reent *r, int incr)
{
 8011cf0:	b500      	push	{lr}
 8011cf2:	b085      	sub	sp, #20
 8011cf4:	9001      	str	r0, [sp, #4]
 8011cf6:	9100      	str	r1, [sp, #0]
#if CH_CFG_USE_MEMCORE
  void *p;

  chDbgCheck(incr >= 0);

  p = chCoreAlloc((size_t)incr);
 8011cf8:	9b00      	ldr	r3, [sp, #0]
 8011cfa:	4618      	mov	r0, r3
 8011cfc:	f7f1 fcb0 	bl	8003660 <chCoreAlloc>
 8011d00:	9003      	str	r0, [sp, #12]
  if (p == NULL) {
 8011d02:	9b03      	ldr	r3, [sp, #12]
 8011d04:	2b00      	cmp	r3, #0
 8011d06:	d105      	bne.n	8011d14 <_sbrk_r+0x24>
    __errno_r(r) = ENOMEM;
 8011d08:	9b01      	ldr	r3, [sp, #4]
 8011d0a:	220c      	movs	r2, #12
 8011d0c:	601a      	str	r2, [r3, #0]
    return (caddr_t)-1;
 8011d0e:	f04f 33ff 	mov.w	r3, #4294967295
 8011d12:	e000      	b.n	8011d16 <_sbrk_r+0x26>
  }
  return (caddr_t)p;
 8011d14:	9b03      	ldr	r3, [sp, #12]
#else
  (void)incr;
  __errno_r(r) = ENOMEM;
  return (caddr_t)-1;
#endif
}
 8011d16:	4618      	mov	r0, r3
 8011d18:	b005      	add	sp, #20
 8011d1a:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d1e:	bf00      	nop

08011d20 <_fstat_r>:

/***************************************************************************/

__attribute__((used))
int _fstat_r(struct _reent *r, int file, struct stat * st)
{
 8011d20:	b500      	push	{lr}
 8011d22:	b085      	sub	sp, #20
 8011d24:	9003      	str	r0, [sp, #12]
 8011d26:	9102      	str	r1, [sp, #8]
 8011d28:	9201      	str	r2, [sp, #4]
  (void)r;
  (void)file;

  memset(st, 0, sizeof(*st));
 8011d2a:	9801      	ldr	r0, [sp, #4]
 8011d2c:	2100      	movs	r1, #0
 8011d2e:	223c      	movs	r2, #60	; 0x3c
 8011d30:	f004 ffee 	bl	8016d10 <memset>
  st->st_mode = S_IFCHR;
 8011d34:	9b01      	ldr	r3, [sp, #4]
 8011d36:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8011d3a:	605a      	str	r2, [r3, #4]
  return 0;
 8011d3c:	2300      	movs	r3, #0
}
 8011d3e:	4618      	mov	r0, r3
 8011d40:	b005      	add	sp, #20
 8011d42:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d46:	bf00      	nop
 8011d48:	f3af 8000 	nop.w
 8011d4c:	f3af 8000 	nop.w

08011d50 <_isatty_r>:

/***************************************************************************/

__attribute__((used))
int _isatty_r(struct _reent *r, int fd)
{
 8011d50:	b082      	sub	sp, #8
 8011d52:	9001      	str	r0, [sp, #4]
 8011d54:	9100      	str	r1, [sp, #0]
  (void)r;
  (void)fd;

  return 1;
 8011d56:	2301      	movs	r3, #1
}
 8011d58:	4618      	mov	r0, r3
 8011d5a:	b002      	add	sp, #8
 8011d5c:	4770      	bx	lr
 8011d5e:	bf00      	nop

08011d60 <LSM303AGR_ACC_Init>:
/************** Generic Function  *******************/


/* Enable 3 wire SPI mode on the LSM303AGR */

status_t LSM303AGR_ACC_Init(void) {
 8011d60:	b500      	push	{lr}
 8011d62:	b083      	sub	sp, #12
  uint8_t value = LSM303AGR_ACC_SIM_3_WIRES;
 8011d64:	2301      	movs	r3, #1
 8011d66:	f88d 3007 	strb.w	r3, [sp, #7]
  LSM303AGR_ACC_WriteReg(NULL,LSM303AGR_ACC_CTRL_REG4,&value,1);
 8011d6a:	f10d 0307 	add.w	r3, sp, #7
 8011d6e:	2000      	movs	r0, #0
 8011d70:	2123      	movs	r1, #35	; 0x23
 8011d72:	461a      	mov	r2, r3
 8011d74:	2301      	movs	r3, #1
 8011d76:	f000 f80b 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
  return MEMS_SUCCESS;
 8011d7a:	2301      	movs	r3, #1
}
 8011d7c:	4618      	mov	r0, r3
 8011d7e:	b003      	add	sp, #12
 8011d80:	f85d fb04 	ldr.w	pc, [sp], #4
 8011d84:	f3af 8000 	nop.w
 8011d88:	f3af 8000 	nop.w
 8011d8c:	f3af 8000 	nop.w

08011d90 <LSM303AGR_ACC_WriteReg>:
* Input       : Register Address, ptr to buffer to be written,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_WriteReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 8011d90:	b500      	push	{lr}
 8011d92:	b087      	sub	sp, #28
 8011d94:	9005      	str	r0, [sp, #20]
 8011d96:	9203      	str	r2, [sp, #12]
 8011d98:	460a      	mov	r2, r1
 8011d9a:	f88d 2013 	strb.w	r2, [sp, #19]
 8011d9e:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Write(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 8011da2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011da6:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 8011daa:	9200      	str	r2, [sp, #0]
 8011dac:	4807      	ldr	r0, [pc, #28]	; (8011dcc <LSM303AGR_ACC_WriteReg+0x3c>)
 8011dae:	4908      	ldr	r1, [pc, #32]	; (8011dd0 <LSM303AGR_ACC_WriteReg+0x40>)
 8011db0:	461a      	mov	r2, r3
 8011db2:	9b03      	ldr	r3, [sp, #12]
 8011db4:	f003 ffdc 	bl	8015d70 <Sensor_IO_SPI_Write>
 8011db8:	4603      	mov	r3, r0
 8011dba:	2b00      	cmp	r3, #0
 8011dbc:	d001      	beq.n	8011dc2 <LSM303AGR_ACC_WriteReg+0x32>
  {
    return MEMS_ERROR;
 8011dbe:	2300      	movs	r3, #0
 8011dc0:	e000      	b.n	8011dc4 <LSM303AGR_ACC_WriteReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 8011dc2:	2301      	movs	r3, #1
  }
}
 8011dc4:	4618      	mov	r0, r3
 8011dc6:	b007      	add	sp, #28
 8011dc8:	f85d fb04 	ldr.w	pc, [sp], #4
 8011dcc:	20001fa8 	.word	0x20001fa8
 8011dd0:	200008f0 	.word	0x200008f0
 8011dd4:	f3af 8000 	nop.w
 8011dd8:	f3af 8000 	nop.w
 8011ddc:	f3af 8000 	nop.w

08011de0 <LSM303AGR_ACC_ReadReg>:
* Input       : Register Address, ptr to buffer to be read,
*                                 length of buffer
* Output      : None
* Return      : None
*******************************************************************************/
status_t LSM303AGR_ACC_ReadReg(void *handle, u8_t Reg, u8_t *Bufp, u16_t len) {
 8011de0:	b500      	push	{lr}
 8011de2:	b087      	sub	sp, #28
 8011de4:	9005      	str	r0, [sp, #20]
 8011de6:	9203      	str	r2, [sp, #12]
 8011de8:	460a      	mov	r2, r1
 8011dea:	f88d 2013 	strb.w	r2, [sp, #19]
 8011dee:	f8ad 3010 	strh.w	r3, [sp, #16]
  UNUSED(handle);
  if (Sensor_IO_SPI_Read(&SENSOR_PORT, &lsm303ad_accel_cfg, Reg, Bufp, len))
 8011df2:	f89d 3013 	ldrb.w	r3, [sp, #19]
 8011df6:	f8bd 2010 	ldrh.w	r2, [sp, #16]
 8011dfa:	9200      	str	r2, [sp, #0]
 8011dfc:	4807      	ldr	r0, [pc, #28]	; (8011e1c <LSM303AGR_ACC_ReadReg+0x3c>)
 8011dfe:	4908      	ldr	r1, [pc, #32]	; (8011e20 <LSM303AGR_ACC_ReadReg+0x40>)
 8011e00:	461a      	mov	r2, r3
 8011e02:	9b03      	ldr	r3, [sp, #12]
 8011e04:	f004 f814 	bl	8015e30 <Sensor_IO_SPI_Read>
 8011e08:	4603      	mov	r3, r0
 8011e0a:	2b00      	cmp	r3, #0
 8011e0c:	d001      	beq.n	8011e12 <LSM303AGR_ACC_ReadReg+0x32>
  {
    return MEMS_ERROR;
 8011e0e:	2300      	movs	r3, #0
 8011e10:	e000      	b.n	8011e14 <LSM303AGR_ACC_ReadReg+0x34>
  }
  else
  {
    return MEMS_SUCCESS;
 8011e12:	2301      	movs	r3, #1
  }
}
 8011e14:	4618      	mov	r0, r3
 8011e16:	b007      	add	sp, #28
 8011e18:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e1c:	20001fa8 	.word	0x20001fa8
 8011e20:	200008f0 	.word	0x200008f0
 8011e24:	f3af 8000 	nop.w
 8011e28:	f3af 8000 	nop.w
 8011e2c:	f3af 8000 	nop.w

08011e30 <LSM303AGR_ACC_R_WHO_AM_I>:
* Input          : Pointer to u8_t
* Output         : Status of WHO_AM_I
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WHO_AM_I(void *handle, u8_t *value)
{
 8011e30:	b500      	push	{lr}
 8011e32:	b083      	sub	sp, #12
 8011e34:	9001      	str	r0, [sp, #4]
 8011e36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_WHO_AM_I_REG, value, 1) )
 8011e38:	9801      	ldr	r0, [sp, #4]
 8011e3a:	210f      	movs	r1, #15
 8011e3c:	9a00      	ldr	r2, [sp, #0]
 8011e3e:	2301      	movs	r3, #1
 8011e40:	f7ff ffce 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011e44:	4603      	mov	r3, r0
 8011e46:	2b00      	cmp	r3, #0
 8011e48:	d101      	bne.n	8011e4e <LSM303AGR_ACC_R_WHO_AM_I+0x1e>
    return MEMS_ERROR;
 8011e4a:	2300      	movs	r3, #0
 8011e4c:	e000      	b.n	8011e50 <LSM303AGR_ACC_R_WHO_AM_I+0x20>

  /* *value &= LSM303AGR_ACC_WHO_AM_I_MASK; //coerce */
  /* *value = *value >> LSM303AGR_ACC_WHO_AM_I_POSITION; //mask */

  return MEMS_SUCCESS;
 8011e4e:	2301      	movs	r3, #1
}
 8011e50:	4618      	mov	r0, r3
 8011e52:	b003      	add	sp, #12
 8011e54:	f85d fb04 	ldr.w	pc, [sp], #4
 8011e58:	f3af 8000 	nop.w
 8011e5c:	f3af 8000 	nop.w

08011e60 <LSM303AGR_ACC_W_BlockDataUpdate>:
* Input          : LSM303AGR_ACC_BDU_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t newValue)
{
 8011e60:	b500      	push	{lr}
 8011e62:	b085      	sub	sp, #20
 8011e64:	9001      	str	r0, [sp, #4]
 8011e66:	460b      	mov	r3, r1
 8011e68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8011e6c:	f10d 030f 	add.w	r3, sp, #15
 8011e70:	9801      	ldr	r0, [sp, #4]
 8011e72:	2123      	movs	r1, #35	; 0x23
 8011e74:	461a      	mov	r2, r3
 8011e76:	2301      	movs	r3, #1
 8011e78:	f7ff ffb2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011e7c:	4603      	mov	r3, r0
 8011e7e:	2b00      	cmp	r3, #0
 8011e80:	d101      	bne.n	8011e86 <LSM303AGR_ACC_W_BlockDataUpdate+0x26>
    return MEMS_ERROR;
 8011e82:	2300      	movs	r3, #0
 8011e84:	e01c      	b.n	8011ec0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  value &= ~LSM303AGR_ACC_BDU_MASK;
 8011e86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011e8a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8011e8e:	b2db      	uxtb	r3, r3
 8011e90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011e94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011e98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011e9c:	4313      	orrs	r3, r2
 8011e9e:	b2db      	uxtb	r3, r3
 8011ea0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8011ea4:	f10d 030f 	add.w	r3, sp, #15
 8011ea8:	9801      	ldr	r0, [sp, #4]
 8011eaa:	2123      	movs	r1, #35	; 0x23
 8011eac:	461a      	mov	r2, r3
 8011eae:	2301      	movs	r3, #1
 8011eb0:	f7ff ff6e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8011eb4:	4603      	mov	r3, r0
 8011eb6:	2b00      	cmp	r3, #0
 8011eb8:	d101      	bne.n	8011ebe <LSM303AGR_ACC_W_BlockDataUpdate+0x5e>
    return MEMS_ERROR;
 8011eba:	2300      	movs	r3, #0
 8011ebc:	e000      	b.n	8011ec0 <LSM303AGR_ACC_W_BlockDataUpdate+0x60>

  return MEMS_SUCCESS;
 8011ebe:	2301      	movs	r3, #1
}
 8011ec0:	4618      	mov	r0, r3
 8011ec2:	b005      	add	sp, #20
 8011ec4:	f85d fb04 	ldr.w	pc, [sp], #4
 8011ec8:	f3af 8000 	nop.w
 8011ecc:	f3af 8000 	nop.w

08011ed0 <LSM303AGR_ACC_R_BlockDataUpdate>:
* Input          : Pointer to LSM303AGR_ACC_BDU_t
* Output         : Status of BDU see LSM303AGR_ACC_BDU_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_BlockDataUpdate(void *handle, LSM303AGR_ACC_BDU_t *value)
{
 8011ed0:	b500      	push	{lr}
 8011ed2:	b083      	sub	sp, #12
 8011ed4:	9001      	str	r0, [sp, #4]
 8011ed6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8011ed8:	9801      	ldr	r0, [sp, #4]
 8011eda:	2123      	movs	r1, #35	; 0x23
 8011edc:	9a00      	ldr	r2, [sp, #0]
 8011ede:	2301      	movs	r3, #1
 8011ee0:	f7ff ff7e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011ee4:	4603      	mov	r3, r0
 8011ee6:	2b00      	cmp	r3, #0
 8011ee8:	d101      	bne.n	8011eee <LSM303AGR_ACC_R_BlockDataUpdate+0x1e>
    return MEMS_ERROR;
 8011eea:	2300      	movs	r3, #0
 8011eec:	e007      	b.n	8011efe <LSM303AGR_ACC_R_BlockDataUpdate+0x2e>

  *value &= LSM303AGR_ACC_BDU_MASK; //mask
 8011eee:	9b00      	ldr	r3, [sp, #0]
 8011ef0:	781b      	ldrb	r3, [r3, #0]
 8011ef2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8011ef6:	b2da      	uxtb	r2, r3
 8011ef8:	9b00      	ldr	r3, [sp, #0]
 8011efa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011efc:	2301      	movs	r3, #1
}
 8011efe:	4618      	mov	r0, r3
 8011f00:	b003      	add	sp, #12
 8011f02:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f06:	bf00      	nop
 8011f08:	f3af 8000 	nop.w
 8011f0c:	f3af 8000 	nop.w

08011f10 <LSM303AGR_ACC_W_FullScale>:
* Input          : LSM303AGR_ACC_FS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FullScale(void *handle, LSM303AGR_ACC_FS_t newValue)
{
 8011f10:	b500      	push	{lr}
 8011f12:	b085      	sub	sp, #20
 8011f14:	9001      	str	r0, [sp, #4]
 8011f16:	460b      	mov	r3, r1
 8011f18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8011f1c:	f10d 030f 	add.w	r3, sp, #15
 8011f20:	9801      	ldr	r0, [sp, #4]
 8011f22:	2123      	movs	r1, #35	; 0x23
 8011f24:	461a      	mov	r2, r3
 8011f26:	2301      	movs	r3, #1
 8011f28:	f7ff ff5a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011f2c:	4603      	mov	r3, r0
 8011f2e:	2b00      	cmp	r3, #0
 8011f30:	d101      	bne.n	8011f36 <LSM303AGR_ACC_W_FullScale+0x26>
    return MEMS_ERROR;
 8011f32:	2300      	movs	r3, #0
 8011f34:	e01c      	b.n	8011f70 <LSM303AGR_ACC_W_FullScale+0x60>

  value &= ~LSM303AGR_ACC_FS_MASK;
 8011f36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8011f3a:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8011f3e:	b2db      	uxtb	r3, r3
 8011f40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8011f44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8011f48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8011f4c:	4313      	orrs	r3, r2
 8011f4e:	b2db      	uxtb	r3, r3
 8011f50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8011f54:	f10d 030f 	add.w	r3, sp, #15
 8011f58:	9801      	ldr	r0, [sp, #4]
 8011f5a:	2123      	movs	r1, #35	; 0x23
 8011f5c:	461a      	mov	r2, r3
 8011f5e:	2301      	movs	r3, #1
 8011f60:	f7ff ff16 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8011f64:	4603      	mov	r3, r0
 8011f66:	2b00      	cmp	r3, #0
 8011f68:	d101      	bne.n	8011f6e <LSM303AGR_ACC_W_FullScale+0x5e>
    return MEMS_ERROR;
 8011f6a:	2300      	movs	r3, #0
 8011f6c:	e000      	b.n	8011f70 <LSM303AGR_ACC_W_FullScale+0x60>

  return MEMS_SUCCESS;
 8011f6e:	2301      	movs	r3, #1
}
 8011f70:	4618      	mov	r0, r3
 8011f72:	b005      	add	sp, #20
 8011f74:	f85d fb04 	ldr.w	pc, [sp], #4
 8011f78:	f3af 8000 	nop.w
 8011f7c:	f3af 8000 	nop.w

08011f80 <LSM303AGR_ACC_R_FullScale>:
* Input          : Pointer to LSM303AGR_ACC_FS_t
* Output         : Status of FS see LSM303AGR_ACC_FS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FullScale(void *handle, LSM303AGR_ACC_FS_t *value)
{
 8011f80:	b500      	push	{lr}
 8011f82:	b083      	sub	sp, #12
 8011f84:	9001      	str	r0, [sp, #4]
 8011f86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8011f88:	9801      	ldr	r0, [sp, #4]
 8011f8a:	2123      	movs	r1, #35	; 0x23
 8011f8c:	9a00      	ldr	r2, [sp, #0]
 8011f8e:	2301      	movs	r3, #1
 8011f90:	f7ff ff26 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011f94:	4603      	mov	r3, r0
 8011f96:	2b00      	cmp	r3, #0
 8011f98:	d101      	bne.n	8011f9e <LSM303AGR_ACC_R_FullScale+0x1e>
    return MEMS_ERROR;
 8011f9a:	2300      	movs	r3, #0
 8011f9c:	e007      	b.n	8011fae <LSM303AGR_ACC_R_FullScale+0x2e>

  *value &= LSM303AGR_ACC_FS_MASK; //mask
 8011f9e:	9b00      	ldr	r3, [sp, #0]
 8011fa0:	781b      	ldrb	r3, [r3, #0]
 8011fa2:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8011fa6:	b2da      	uxtb	r2, r3
 8011fa8:	9b00      	ldr	r3, [sp, #0]
 8011faa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8011fac:	2301      	movs	r3, #1
}
 8011fae:	4618      	mov	r0, r3
 8011fb0:	b003      	add	sp, #12
 8011fb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8011fb6:	bf00      	nop
 8011fb8:	f3af 8000 	nop.w
 8011fbc:	f3af 8000 	nop.w

08011fc0 <LSM303AGR_ACC_Get_Raw_Acceleration>:
* Input          : pointer to [u8_t]
* Output         : Acceleration buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Raw_Acceleration(void *handle, u8_t *buff)
{
 8011fc0:	b500      	push	{lr}
 8011fc2:	b083      	sub	sp, #12
 8011fc4:	9001      	str	r0, [sp, #4]
 8011fc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_X_L, buff, 6 ) )
 8011fc8:	9801      	ldr	r0, [sp, #4]
 8011fca:	2128      	movs	r1, #40	; 0x28
 8011fcc:	9a00      	ldr	r2, [sp, #0]
 8011fce:	2306      	movs	r3, #6
 8011fd0:	f7ff ff06 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8011fd4:	4603      	mov	r3, r0
 8011fd6:	2b00      	cmp	r3, #0
 8011fd8:	d101      	bne.n	8011fde <LSM303AGR_ACC_Get_Raw_Acceleration+0x1e>
    return MEMS_ERROR;
 8011fda:	2300      	movs	r3, #0
 8011fdc:	e000      	b.n	8011fe0 <LSM303AGR_ACC_Get_Raw_Acceleration+0x20>

  return MEMS_SUCCESS;
 8011fde:	2301      	movs	r3, #1
}
 8011fe0:	4618      	mov	r0, r3
 8011fe2:	b003      	add	sp, #12
 8011fe4:	f85d fb04 	ldr.w	pc, [sp], #4
 8011fe8:	f3af 8000 	nop.w
 8011fec:	f3af 8000 	nop.w

08011ff0 <LSM303AGR_ACC_Get_Acceleration>:
    62520,  /* FS @8g */
    187580, /* FS @16g */
  },
};
status_t LSM303AGR_ACC_Get_Acceleration(void *handle, int *buff)
{
 8011ff0:	b570      	push	{r4, r5, r6, lr}
 8011ff2:	b086      	sub	sp, #24
 8011ff4:	9001      	str	r0, [sp, #4]
 8011ff6:	9100      	str	r1, [sp, #0]
  Type3Axis16bit_U raw_data_tmp;
  u8_t op_mode = 0, fs_mode = 0, shift = 0;
 8011ff8:	2300      	movs	r3, #0
 8011ffa:	f88d 3017 	strb.w	r3, [sp, #23]
 8011ffe:	2300      	movs	r3, #0
 8012000:	f88d 3016 	strb.w	r3, [sp, #22]
 8012004:	2300      	movs	r3, #0
 8012006:	f88d 3015 	strb.w	r3, [sp, #21]
  LSM303AGR_ACC_LPEN_t lp;
  LSM303AGR_ACC_HR_t hr;
  LSM303AGR_ACC_FS_t fs;

  /* Determine which operational mode the acc is set */
  LSM303AGR_ACC_R_HiRes(handle, &hr);
 801200a:	f10d 030a 	add.w	r3, sp, #10
 801200e:	9801      	ldr	r0, [sp, #4]
 8012010:	4619      	mov	r1, r3
 8012012:	f001 f9dd 	bl	80133d0 <LSM303AGR_ACC_R_HiRes>
  LSM303AGR_ACC_R_LOWPWR_EN(handle, &lp);
 8012016:	f10d 030b 	add.w	r3, sp, #11
 801201a:	9801      	ldr	r0, [sp, #4]
 801201c:	4619      	mov	r1, r3
 801201e:	f000 fc57 	bl	80128d0 <LSM303AGR_ACC_R_LOWPWR_EN>

  if (lp == LSM303AGR_ACC_LPEN_ENABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8012022:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012026:	2b08      	cmp	r3, #8
 8012028:	d10a      	bne.n	8012040 <LSM303AGR_ACC_Get_Acceleration+0x50>
 801202a:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801202e:	2b00      	cmp	r3, #0
 8012030:	d106      	bne.n	8012040 <LSM303AGR_ACC_Get_Acceleration+0x50>
  {
    /* op mode is LP 8-bit */
    op_mode = 2;
 8012032:	2302      	movs	r3, #2
 8012034:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 8;
 8012038:	2308      	movs	r3, #8
 801203a:	f88d 3015 	strb.w	r3, [sp, #21]
 801203e:	e01f      	b.n	8012080 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_DISABLED)
 8012040:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012044:	2b00      	cmp	r3, #0
 8012046:	d10a      	bne.n	801205e <LSM303AGR_ACC_Get_Acceleration+0x6e>
 8012048:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801204c:	2b00      	cmp	r3, #0
 801204e:	d106      	bne.n	801205e <LSM303AGR_ACC_Get_Acceleration+0x6e>
  {
    /* op mode is Normal 10-bit */
    op_mode = 1;
 8012050:	2301      	movs	r3, #1
 8012052:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 6;
 8012056:	2306      	movs	r3, #6
 8012058:	f88d 3015 	strb.w	r3, [sp, #21]
 801205c:	e010      	b.n	8012080 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else if (lp == LSM303AGR_ACC_LPEN_DISABLED && hr == LSM303AGR_ACC_HR_ENABLED)
 801205e:	f89d 300b 	ldrb.w	r3, [sp, #11]
 8012062:	2b00      	cmp	r3, #0
 8012064:	d10a      	bne.n	801207c <LSM303AGR_ACC_Get_Acceleration+0x8c>
 8012066:	f89d 300a 	ldrb.w	r3, [sp, #10]
 801206a:	2b08      	cmp	r3, #8
 801206c:	d106      	bne.n	801207c <LSM303AGR_ACC_Get_Acceleration+0x8c>
  {
    /* op mode is HR 12-bit */
    op_mode = 0;
 801206e:	2300      	movs	r3, #0
 8012070:	f88d 3017 	strb.w	r3, [sp, #23]
    shift = 4;
 8012074:	2304      	movs	r3, #4
 8012076:	f88d 3015 	strb.w	r3, [sp, #21]
 801207a:	e001      	b.n	8012080 <LSM303AGR_ACC_Get_Acceleration+0x90>
  }
  else
    return MEMS_ERROR;
 801207c:	2300      	movs	r3, #0
 801207e:	e0b8      	b.n	80121f2 <LSM303AGR_ACC_Get_Acceleration+0x202>

  /* Determine the Full Scale the acc is set */
  LSM303AGR_ACC_R_FullScale(handle, &fs);
 8012080:	f10d 0309 	add.w	r3, sp, #9
 8012084:	9801      	ldr	r0, [sp, #4]
 8012086:	4619      	mov	r1, r3
 8012088:	f7ff ff7a 	bl	8011f80 <LSM303AGR_ACC_R_FullScale>
  switch (fs)
 801208c:	f89d 3009 	ldrb.w	r3, [sp, #9]
 8012090:	2b10      	cmp	r3, #16
 8012092:	d00d      	beq.n	80120b0 <LSM303AGR_ACC_Get_Acceleration+0xc0>
 8012094:	2b10      	cmp	r3, #16
 8012096:	dc02      	bgt.n	801209e <LSM303AGR_ACC_Get_Acceleration+0xae>
 8012098:	2b00      	cmp	r3, #0
 801209a:	d005      	beq.n	80120a8 <LSM303AGR_ACC_Get_Acceleration+0xb8>
 801209c:	e014      	b.n	80120c8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
 801209e:	2b20      	cmp	r3, #32
 80120a0:	d00a      	beq.n	80120b8 <LSM303AGR_ACC_Get_Acceleration+0xc8>
 80120a2:	2b30      	cmp	r3, #48	; 0x30
 80120a4:	d00c      	beq.n	80120c0 <LSM303AGR_ACC_Get_Acceleration+0xd0>
 80120a6:	e00f      	b.n	80120c8 <LSM303AGR_ACC_Get_Acceleration+0xd8>
  {
    case LSM303AGR_ACC_FS_2G:
      fs_mode = 0;
 80120a8:	2300      	movs	r3, #0
 80120aa:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80120ae:	e00b      	b.n	80120c8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_4G:
      fs_mode = 1;
 80120b0:	2301      	movs	r3, #1
 80120b2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80120b6:	e007      	b.n	80120c8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_8G:
      fs_mode = 2;
 80120b8:	2302      	movs	r3, #2
 80120ba:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80120be:	e003      	b.n	80120c8 <LSM303AGR_ACC_Get_Acceleration+0xd8>

    case LSM303AGR_ACC_FS_16G:
      fs_mode = 3;
 80120c0:	2303      	movs	r3, #3
 80120c2:	f88d 3016 	strb.w	r3, [sp, #22]
      break;
 80120c6:	bf00      	nop
  }

  /* Read out raw accelerometer samples */
  LSM303AGR_ACC_Get_Raw_Acceleration(handle, raw_data_tmp.u8bit);
 80120c8:	ab03      	add	r3, sp, #12
 80120ca:	9801      	ldr	r0, [sp, #4]
 80120cc:	4619      	mov	r1, r3
 80120ce:	f7ff ff77 	bl	8011fc0 <LSM303AGR_ACC_Get_Raw_Acceleration>

  /* Apply proper shift and sensitivity */
  buff[0] = ((raw_data_tmp.i16bit[0] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 80120d2:	f8bd 300c 	ldrh.w	r3, [sp, #12]
 80120d6:	b21a      	sxth	r2, r3
 80120d8:	f89d 3015 	ldrb.w	r3, [sp, #21]
 80120dc:	fa42 f303 	asr.w	r3, r2, r3
 80120e0:	4618      	mov	r0, r3
 80120e2:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80120e6:	f89d 4017 	ldrb.w	r4, [sp, #23]
 80120ea:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80120ee:	4a42      	ldr	r2, [pc, #264]	; (80121f8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80120f0:	00a4      	lsls	r4, r4, #2
 80120f2:	4423      	add	r3, r4
 80120f4:	00db      	lsls	r3, r3, #3
 80120f6:	4413      	add	r3, r2
 80120f8:	e9d3 2300 	ldrd	r2, r3, [r3]
 80120fc:	fb02 f501 	mul.w	r5, r2, r1
 8012100:	fb00 f403 	mul.w	r4, r0, r3
 8012104:	442c      	add	r4, r5
 8012106:	fba0 2302 	umull	r2, r3, r0, r2
 801210a:	18e1      	adds	r1, r4, r3
 801210c:	460b      	mov	r3, r1
 801210e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8012112:	f143 0300 	adc.w	r3, r3, #0
 8012116:	4610      	mov	r0, r2
 8012118:	4619      	mov	r1, r3
 801211a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801211e:	f04f 0300 	mov.w	r3, #0
 8012122:	f004 f925 	bl	8016370 <__aeabi_ldivmod>
 8012126:	4602      	mov	r2, r0
 8012128:	460b      	mov	r3, r1
 801212a:	9b00      	ldr	r3, [sp, #0]
 801212c:	601a      	str	r2, [r3, #0]
  buff[1] = ((raw_data_tmp.i16bit[1] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801212e:	9b00      	ldr	r3, [sp, #0]
 8012130:	1d1c      	adds	r4, r3, #4
 8012132:	f8bd 300e 	ldrh.w	r3, [sp, #14]
 8012136:	b21a      	sxth	r2, r3
 8012138:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801213c:	fa42 f303 	asr.w	r3, r2, r3
 8012140:	4618      	mov	r0, r3
 8012142:	ea4f 71e0 	mov.w	r1, r0, asr #31
 8012146:	f89d 5017 	ldrb.w	r5, [sp, #23]
 801214a:	f89d 3016 	ldrb.w	r3, [sp, #22]
 801214e:	4a2a      	ldr	r2, [pc, #168]	; (80121f8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 8012150:	00ad      	lsls	r5, r5, #2
 8012152:	442b      	add	r3, r5
 8012154:	00db      	lsls	r3, r3, #3
 8012156:	4413      	add	r3, r2
 8012158:	e9d3 2300 	ldrd	r2, r3, [r3]
 801215c:	fb02 f601 	mul.w	r6, r2, r1
 8012160:	fb00 f503 	mul.w	r5, r0, r3
 8012164:	4435      	add	r5, r6
 8012166:	fba0 2302 	umull	r2, r3, r0, r2
 801216a:	18e9      	adds	r1, r5, r3
 801216c:	460b      	mov	r3, r1
 801216e:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 8012172:	f143 0300 	adc.w	r3, r3, #0
 8012176:	4610      	mov	r0, r2
 8012178:	4619      	mov	r1, r3
 801217a:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 801217e:	f04f 0300 	mov.w	r3, #0
 8012182:	f004 f8f5 	bl	8016370 <__aeabi_ldivmod>
 8012186:	4602      	mov	r2, r0
 8012188:	460b      	mov	r3, r1
 801218a:	4613      	mov	r3, r2
 801218c:	6023      	str	r3, [r4, #0]
  buff[2] = ((raw_data_tmp.i16bit[2] >> shift) * LSM303AGR_ACC_Sensitivity_List[op_mode][fs_mode] + 500) / 1000;
 801218e:	9b00      	ldr	r3, [sp, #0]
 8012190:	f103 0408 	add.w	r4, r3, #8
 8012194:	f8bd 3010 	ldrh.w	r3, [sp, #16]
 8012198:	b21a      	sxth	r2, r3
 801219a:	f89d 3015 	ldrb.w	r3, [sp, #21]
 801219e:	fa42 f303 	asr.w	r3, r2, r3
 80121a2:	4618      	mov	r0, r3
 80121a4:	ea4f 71e0 	mov.w	r1, r0, asr #31
 80121a8:	f89d 5017 	ldrb.w	r5, [sp, #23]
 80121ac:	f89d 3016 	ldrb.w	r3, [sp, #22]
 80121b0:	4a11      	ldr	r2, [pc, #68]	; (80121f8 <LSM303AGR_ACC_Get_Acceleration+0x208>)
 80121b2:	00ad      	lsls	r5, r5, #2
 80121b4:	442b      	add	r3, r5
 80121b6:	00db      	lsls	r3, r3, #3
 80121b8:	4413      	add	r3, r2
 80121ba:	e9d3 2300 	ldrd	r2, r3, [r3]
 80121be:	fb02 f601 	mul.w	r6, r2, r1
 80121c2:	fb00 f503 	mul.w	r5, r0, r3
 80121c6:	4435      	add	r5, r6
 80121c8:	fba0 2302 	umull	r2, r3, r0, r2
 80121cc:	18e9      	adds	r1, r5, r3
 80121ce:	460b      	mov	r3, r1
 80121d0:	f512 72fa 	adds.w	r2, r2, #500	; 0x1f4
 80121d4:	f143 0300 	adc.w	r3, r3, #0
 80121d8:	4610      	mov	r0, r2
 80121da:	4619      	mov	r1, r3
 80121dc:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80121e0:	f04f 0300 	mov.w	r3, #0
 80121e4:	f004 f8c4 	bl	8016370 <__aeabi_ldivmod>
 80121e8:	4602      	mov	r2, r0
 80121ea:	460b      	mov	r3, r1
 80121ec:	4613      	mov	r3, r2
 80121ee:	6023      	str	r3, [r4, #0]

  return MEMS_SUCCESS;
 80121f0:	2301      	movs	r3, #1
}
 80121f2:	4618      	mov	r0, r3
 80121f4:	b006      	add	sp, #24
 80121f6:	bd70      	pop	{r4, r5, r6, pc}
 80121f8:	0801a610 	.word	0x0801a610
 80121fc:	f3af 8000 	nop.w

08012200 <LSM303AGR_ACC_W_ODR>:
* Input          : LSM303AGR_ACC_ODR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ODR(void *handle, LSM303AGR_ACC_ODR_t newValue)
{
 8012200:	b500      	push	{lr}
 8012202:	b085      	sub	sp, #20
 8012204:	9001      	str	r0, [sp, #4]
 8012206:	460b      	mov	r3, r1
 8012208:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801220c:	f10d 030f 	add.w	r3, sp, #15
 8012210:	9801      	ldr	r0, [sp, #4]
 8012212:	2120      	movs	r1, #32
 8012214:	461a      	mov	r2, r3
 8012216:	2301      	movs	r3, #1
 8012218:	f7ff fde2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801221c:	4603      	mov	r3, r0
 801221e:	2b00      	cmp	r3, #0
 8012220:	d101      	bne.n	8012226 <LSM303AGR_ACC_W_ODR+0x26>
    return MEMS_ERROR;
 8012222:	2300      	movs	r3, #0
 8012224:	e01c      	b.n	8012260 <LSM303AGR_ACC_W_ODR+0x60>

  value &= ~LSM303AGR_ACC_ODR_MASK;
 8012226:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801222a:	f003 030f 	and.w	r3, r3, #15
 801222e:	b2db      	uxtb	r3, r3
 8012230:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012234:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012238:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801223c:	4313      	orrs	r3, r2
 801223e:	b2db      	uxtb	r3, r3
 8012240:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012244:	f10d 030f 	add.w	r3, sp, #15
 8012248:	9801      	ldr	r0, [sp, #4]
 801224a:	2120      	movs	r1, #32
 801224c:	461a      	mov	r2, r3
 801224e:	2301      	movs	r3, #1
 8012250:	f7ff fd9e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012254:	4603      	mov	r3, r0
 8012256:	2b00      	cmp	r3, #0
 8012258:	d101      	bne.n	801225e <LSM303AGR_ACC_W_ODR+0x5e>
    return MEMS_ERROR;
 801225a:	2300      	movs	r3, #0
 801225c:	e000      	b.n	8012260 <LSM303AGR_ACC_W_ODR+0x60>

  return MEMS_SUCCESS;
 801225e:	2301      	movs	r3, #1
}
 8012260:	4618      	mov	r0, r3
 8012262:	b005      	add	sp, #20
 8012264:	f85d fb04 	ldr.w	pc, [sp], #4
 8012268:	f3af 8000 	nop.w
 801226c:	f3af 8000 	nop.w

08012270 <LSM303AGR_ACC_R_ODR>:
* Input          : Pointer to LSM303AGR_ACC_ODR_t
* Output         : Status of ODR see LSM303AGR_ACC_ODR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ODR(void *handle, LSM303AGR_ACC_ODR_t *value)
{
 8012270:	b500      	push	{lr}
 8012272:	b083      	sub	sp, #12
 8012274:	9001      	str	r0, [sp, #4]
 8012276:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012278:	9801      	ldr	r0, [sp, #4]
 801227a:	2120      	movs	r1, #32
 801227c:	9a00      	ldr	r2, [sp, #0]
 801227e:	2301      	movs	r3, #1
 8012280:	f7ff fdae 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012284:	4603      	mov	r3, r0
 8012286:	2b00      	cmp	r3, #0
 8012288:	d101      	bne.n	801228e <LSM303AGR_ACC_R_ODR+0x1e>
    return MEMS_ERROR;
 801228a:	2300      	movs	r3, #0
 801228c:	e007      	b.n	801229e <LSM303AGR_ACC_R_ODR+0x2e>

  *value &= LSM303AGR_ACC_ODR_MASK; //mask
 801228e:	9b00      	ldr	r3, [sp, #0]
 8012290:	781b      	ldrb	r3, [r3, #0]
 8012292:	f023 030f 	bic.w	r3, r3, #15
 8012296:	b2da      	uxtb	r2, r3
 8012298:	9b00      	ldr	r3, [sp, #0]
 801229a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801229c:	2301      	movs	r3, #1
}
 801229e:	4618      	mov	r0, r3
 80122a0:	b003      	add	sp, #12
 80122a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80122a6:	bf00      	nop
 80122a8:	f3af 8000 	nop.w
 80122ac:	f3af 8000 	nop.w

080122b0 <LSM303AGR_ACC_R_x_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_1DA_t
* Output         : Status of 1DA see LSM303AGR_ACC_1DA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_x_data_avail(void *handle, LSM303AGR_ACC_1DA_t *value)
{
 80122b0:	b500      	push	{lr}
 80122b2:	b083      	sub	sp, #12
 80122b4:	9001      	str	r0, [sp, #4]
 80122b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80122b8:	9801      	ldr	r0, [sp, #4]
 80122ba:	2107      	movs	r1, #7
 80122bc:	9a00      	ldr	r2, [sp, #0]
 80122be:	2301      	movs	r3, #1
 80122c0:	f7ff fd8e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80122c4:	4603      	mov	r3, r0
 80122c6:	2b00      	cmp	r3, #0
 80122c8:	d101      	bne.n	80122ce <LSM303AGR_ACC_R_x_data_avail+0x1e>
    return MEMS_ERROR;
 80122ca:	2300      	movs	r3, #0
 80122cc:	e007      	b.n	80122de <LSM303AGR_ACC_R_x_data_avail+0x2e>

  *value &= LSM303AGR_ACC_1DA_MASK; //mask
 80122ce:	9b00      	ldr	r3, [sp, #0]
 80122d0:	781b      	ldrb	r3, [r3, #0]
 80122d2:	f003 0301 	and.w	r3, r3, #1
 80122d6:	b2da      	uxtb	r2, r3
 80122d8:	9b00      	ldr	r3, [sp, #0]
 80122da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80122dc:	2301      	movs	r3, #1
}
 80122de:	4618      	mov	r0, r3
 80122e0:	b003      	add	sp, #12
 80122e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80122e6:	bf00      	nop
 80122e8:	f3af 8000 	nop.w
 80122ec:	f3af 8000 	nop.w

080122f0 <LSM303AGR_ACC_R_y_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_2DA__t
* Output         : Status of 2DA_ see LSM303AGR_ACC_2DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_y_data_avail(void *handle, LSM303AGR_ACC_2DA__t *value)
{
 80122f0:	b500      	push	{lr}
 80122f2:	b083      	sub	sp, #12
 80122f4:	9001      	str	r0, [sp, #4]
 80122f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80122f8:	9801      	ldr	r0, [sp, #4]
 80122fa:	2107      	movs	r1, #7
 80122fc:	9a00      	ldr	r2, [sp, #0]
 80122fe:	2301      	movs	r3, #1
 8012300:	f7ff fd6e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012304:	4603      	mov	r3, r0
 8012306:	2b00      	cmp	r3, #0
 8012308:	d101      	bne.n	801230e <LSM303AGR_ACC_R_y_data_avail+0x1e>
    return MEMS_ERROR;
 801230a:	2300      	movs	r3, #0
 801230c:	e007      	b.n	801231e <LSM303AGR_ACC_R_y_data_avail+0x2e>

  *value &= LSM303AGR_ACC_2DA__MASK; //mask
 801230e:	9b00      	ldr	r3, [sp, #0]
 8012310:	781b      	ldrb	r3, [r3, #0]
 8012312:	f003 0302 	and.w	r3, r3, #2
 8012316:	b2da      	uxtb	r2, r3
 8012318:	9b00      	ldr	r3, [sp, #0]
 801231a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801231c:	2301      	movs	r3, #1
}
 801231e:	4618      	mov	r0, r3
 8012320:	b003      	add	sp, #12
 8012322:	f85d fb04 	ldr.w	pc, [sp], #4
 8012326:	bf00      	nop
 8012328:	f3af 8000 	nop.w
 801232c:	f3af 8000 	nop.w

08012330 <LSM303AGR_ACC_R_z_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_3DA__t
* Output         : Status of 3DA_ see LSM303AGR_ACC_3DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_z_data_avail(void *handle, LSM303AGR_ACC_3DA__t *value)
{
 8012330:	b500      	push	{lr}
 8012332:	b083      	sub	sp, #12
 8012334:	9001      	str	r0, [sp, #4]
 8012336:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012338:	9801      	ldr	r0, [sp, #4]
 801233a:	2107      	movs	r1, #7
 801233c:	9a00      	ldr	r2, [sp, #0]
 801233e:	2301      	movs	r3, #1
 8012340:	f7ff fd4e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012344:	4603      	mov	r3, r0
 8012346:	2b00      	cmp	r3, #0
 8012348:	d101      	bne.n	801234e <LSM303AGR_ACC_R_z_data_avail+0x1e>
    return MEMS_ERROR;
 801234a:	2300      	movs	r3, #0
 801234c:	e007      	b.n	801235e <LSM303AGR_ACC_R_z_data_avail+0x2e>

  *value &= LSM303AGR_ACC_3DA__MASK; //mask
 801234e:	9b00      	ldr	r3, [sp, #0]
 8012350:	781b      	ldrb	r3, [r3, #0]
 8012352:	f003 0304 	and.w	r3, r3, #4
 8012356:	b2da      	uxtb	r2, r3
 8012358:	9b00      	ldr	r3, [sp, #0]
 801235a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801235c:	2301      	movs	r3, #1
}
 801235e:	4618      	mov	r0, r3
 8012360:	b003      	add	sp, #12
 8012362:	f85d fb04 	ldr.w	pc, [sp], #4
 8012366:	bf00      	nop
 8012368:	f3af 8000 	nop.w
 801236c:	f3af 8000 	nop.w

08012370 <LSM303AGR_ACC_R_xyz_data_avail>:
* Input          : Pointer to LSM303AGR_ACC_321DA__t
* Output         : Status of 321DA_ see LSM303AGR_ACC_321DA__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_xyz_data_avail(void *handle, LSM303AGR_ACC_321DA__t *value)
{
 8012370:	b500      	push	{lr}
 8012372:	b083      	sub	sp, #12
 8012374:	9001      	str	r0, [sp, #4]
 8012376:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012378:	9801      	ldr	r0, [sp, #4]
 801237a:	2107      	movs	r1, #7
 801237c:	9a00      	ldr	r2, [sp, #0]
 801237e:	2301      	movs	r3, #1
 8012380:	f7ff fd2e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012384:	4603      	mov	r3, r0
 8012386:	2b00      	cmp	r3, #0
 8012388:	d101      	bne.n	801238e <LSM303AGR_ACC_R_xyz_data_avail+0x1e>
    return MEMS_ERROR;
 801238a:	2300      	movs	r3, #0
 801238c:	e007      	b.n	801239e <LSM303AGR_ACC_R_xyz_data_avail+0x2e>

  *value &= LSM303AGR_ACC_321DA__MASK; //mask
 801238e:	9b00      	ldr	r3, [sp, #0]
 8012390:	781b      	ldrb	r3, [r3, #0]
 8012392:	f003 0308 	and.w	r3, r3, #8
 8012396:	b2da      	uxtb	r2, r3
 8012398:	9b00      	ldr	r3, [sp, #0]
 801239a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801239c:	2301      	movs	r3, #1
}
 801239e:	4618      	mov	r0, r3
 80123a0:	b003      	add	sp, #12
 80123a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80123a6:	bf00      	nop
 80123a8:	f3af 8000 	nop.w
 80123ac:	f3af 8000 	nop.w

080123b0 <LSM303AGR_ACC_R_DataXOverrun>:
* Input          : Pointer to LSM303AGR_ACC_1OR__t
* Output         : Status of 1OR_ see LSM303AGR_ACC_1OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXOverrun(void *handle, LSM303AGR_ACC_1OR__t *value)
{
 80123b0:	b500      	push	{lr}
 80123b2:	b083      	sub	sp, #12
 80123b4:	9001      	str	r0, [sp, #4]
 80123b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80123b8:	9801      	ldr	r0, [sp, #4]
 80123ba:	2107      	movs	r1, #7
 80123bc:	9a00      	ldr	r2, [sp, #0]
 80123be:	2301      	movs	r3, #1
 80123c0:	f7ff fd0e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80123c4:	4603      	mov	r3, r0
 80123c6:	2b00      	cmp	r3, #0
 80123c8:	d101      	bne.n	80123ce <LSM303AGR_ACC_R_DataXOverrun+0x1e>
    return MEMS_ERROR;
 80123ca:	2300      	movs	r3, #0
 80123cc:	e007      	b.n	80123de <LSM303AGR_ACC_R_DataXOverrun+0x2e>

  *value &= LSM303AGR_ACC_1OR__MASK; //mask
 80123ce:	9b00      	ldr	r3, [sp, #0]
 80123d0:	781b      	ldrb	r3, [r3, #0]
 80123d2:	f003 0310 	and.w	r3, r3, #16
 80123d6:	b2da      	uxtb	r2, r3
 80123d8:	9b00      	ldr	r3, [sp, #0]
 80123da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80123dc:	2301      	movs	r3, #1
}
 80123de:	4618      	mov	r0, r3
 80123e0:	b003      	add	sp, #12
 80123e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80123e6:	bf00      	nop
 80123e8:	f3af 8000 	nop.w
 80123ec:	f3af 8000 	nop.w

080123f0 <LSM303AGR_ACC_R_DataYOverrun>:
* Input          : Pointer to LSM303AGR_ACC_2OR__t
* Output         : Status of 2OR_ see LSM303AGR_ACC_2OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataYOverrun(void *handle, LSM303AGR_ACC_2OR__t *value)
{
 80123f0:	b500      	push	{lr}
 80123f2:	b083      	sub	sp, #12
 80123f4:	9001      	str	r0, [sp, #4]
 80123f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 80123f8:	9801      	ldr	r0, [sp, #4]
 80123fa:	2107      	movs	r1, #7
 80123fc:	9a00      	ldr	r2, [sp, #0]
 80123fe:	2301      	movs	r3, #1
 8012400:	f7ff fcee 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012404:	4603      	mov	r3, r0
 8012406:	2b00      	cmp	r3, #0
 8012408:	d101      	bne.n	801240e <LSM303AGR_ACC_R_DataYOverrun+0x1e>
    return MEMS_ERROR;
 801240a:	2300      	movs	r3, #0
 801240c:	e007      	b.n	801241e <LSM303AGR_ACC_R_DataYOverrun+0x2e>

  *value &= LSM303AGR_ACC_2OR__MASK; //mask
 801240e:	9b00      	ldr	r3, [sp, #0]
 8012410:	781b      	ldrb	r3, [r3, #0]
 8012412:	f003 0320 	and.w	r3, r3, #32
 8012416:	b2da      	uxtb	r2, r3
 8012418:	9b00      	ldr	r3, [sp, #0]
 801241a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801241c:	2301      	movs	r3, #1
}
 801241e:	4618      	mov	r0, r3
 8012420:	b003      	add	sp, #12
 8012422:	f85d fb04 	ldr.w	pc, [sp], #4
 8012426:	bf00      	nop
 8012428:	f3af 8000 	nop.w
 801242c:	f3af 8000 	nop.w

08012430 <LSM303AGR_ACC_R_DataZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_3OR__t
* Output         : Status of 3OR_ see LSM303AGR_ACC_3OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataZOverrun(void *handle, LSM303AGR_ACC_3OR__t *value)
{
 8012430:	b500      	push	{lr}
 8012432:	b083      	sub	sp, #12
 8012434:	9001      	str	r0, [sp, #4]
 8012436:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012438:	9801      	ldr	r0, [sp, #4]
 801243a:	2107      	movs	r1, #7
 801243c:	9a00      	ldr	r2, [sp, #0]
 801243e:	2301      	movs	r3, #1
 8012440:	f7ff fcce 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012444:	4603      	mov	r3, r0
 8012446:	2b00      	cmp	r3, #0
 8012448:	d101      	bne.n	801244e <LSM303AGR_ACC_R_DataZOverrun+0x1e>
    return MEMS_ERROR;
 801244a:	2300      	movs	r3, #0
 801244c:	e007      	b.n	801245e <LSM303AGR_ACC_R_DataZOverrun+0x2e>

  *value &= LSM303AGR_ACC_3OR__MASK; //mask
 801244e:	9b00      	ldr	r3, [sp, #0]
 8012450:	781b      	ldrb	r3, [r3, #0]
 8012452:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012456:	b2da      	uxtb	r2, r3
 8012458:	9b00      	ldr	r3, [sp, #0]
 801245a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801245c:	2301      	movs	r3, #1
}
 801245e:	4618      	mov	r0, r3
 8012460:	b003      	add	sp, #12
 8012462:	f85d fb04 	ldr.w	pc, [sp], #4
 8012466:	bf00      	nop
 8012468:	f3af 8000 	nop.w
 801246c:	f3af 8000 	nop.w

08012470 <LSM303AGR_ACC_R_DataXYZOverrun>:
* Input          : Pointer to LSM303AGR_ACC_321OR__t
* Output         : Status of 321OR_ see LSM303AGR_ACC_321OR__t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DataXYZOverrun(void *handle, LSM303AGR_ACC_321OR__t *value)
{
 8012470:	b500      	push	{lr}
 8012472:	b083      	sub	sp, #12
 8012474:	9001      	str	r0, [sp, #4]
 8012476:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG_AUX, (u8_t *)value, 1) )
 8012478:	9801      	ldr	r0, [sp, #4]
 801247a:	2107      	movs	r1, #7
 801247c:	9a00      	ldr	r2, [sp, #0]
 801247e:	2301      	movs	r3, #1
 8012480:	f7ff fcae 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012484:	4603      	mov	r3, r0
 8012486:	2b00      	cmp	r3, #0
 8012488:	d101      	bne.n	801248e <LSM303AGR_ACC_R_DataXYZOverrun+0x1e>
    return MEMS_ERROR;
 801248a:	2300      	movs	r3, #0
 801248c:	e007      	b.n	801249e <LSM303AGR_ACC_R_DataXYZOverrun+0x2e>

  *value &= LSM303AGR_ACC_321OR__MASK; //mask
 801248e:	9b00      	ldr	r3, [sp, #0]
 8012490:	781b      	ldrb	r3, [r3, #0]
 8012492:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012496:	b2da      	uxtb	r2, r3
 8012498:	9b00      	ldr	r3, [sp, #0]
 801249a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801249c:	2301      	movs	r3, #1
}
 801249e:	4618      	mov	r0, r3
 80124a0:	b003      	add	sp, #12
 80124a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80124a6:	bf00      	nop
 80124a8:	f3af 8000 	nop.w
 80124ac:	f3af 8000 	nop.w

080124b0 <LSM303AGR_ACC_R_int_counter>:
* Input          : Pointer to u8_t
* Output         : Status of IC
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_int_counter(void *handle, u8_t *value)
{
 80124b0:	b500      	push	{lr}
 80124b2:	b083      	sub	sp, #12
 80124b4:	9001      	str	r0, [sp, #4]
 80124b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT_COUNTER_REG, (u8_t *)value, 1) )
 80124b8:	9801      	ldr	r0, [sp, #4]
 80124ba:	210e      	movs	r1, #14
 80124bc:	9a00      	ldr	r2, [sp, #0]
 80124be:	2301      	movs	r3, #1
 80124c0:	f7ff fc8e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80124c4:	4603      	mov	r3, r0
 80124c6:	2b00      	cmp	r3, #0
 80124c8:	d101      	bne.n	80124ce <LSM303AGR_ACC_R_int_counter+0x1e>
    return MEMS_ERROR;
 80124ca:	2300      	movs	r3, #0
 80124cc:	e008      	b.n	80124e0 <LSM303AGR_ACC_R_int_counter+0x30>

  *value &= LSM303AGR_ACC_IC_MASK; //coerce
 80124ce:	9b00      	ldr	r3, [sp, #0]
 80124d0:	781a      	ldrb	r2, [r3, #0]
 80124d2:	9b00      	ldr	r3, [sp, #0]
 80124d4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_IC_POSITION; //mask
 80124d6:	9b00      	ldr	r3, [sp, #0]
 80124d8:	781a      	ldrb	r2, [r3, #0]
 80124da:	9b00      	ldr	r3, [sp, #0]
 80124dc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80124de:	2301      	movs	r3, #1
}
 80124e0:	4618      	mov	r0, r3
 80124e2:	b003      	add	sp, #12
 80124e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80124e8:	f3af 8000 	nop.w
 80124ec:	f3af 8000 	nop.w

080124f0 <LSM303AGR_ACC_W_TEMP_EN_bits>:
* Input          : LSM303AGR_ACC_TEMP_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t newValue)
{
 80124f0:	b500      	push	{lr}
 80124f2:	b085      	sub	sp, #20
 80124f4:	9001      	str	r0, [sp, #4]
 80124f6:	460b      	mov	r3, r1
 80124f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 80124fc:	f10d 030f 	add.w	r3, sp, #15
 8012500:	9801      	ldr	r0, [sp, #4]
 8012502:	211f      	movs	r1, #31
 8012504:	461a      	mov	r2, r3
 8012506:	2301      	movs	r3, #1
 8012508:	f7ff fc6a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801250c:	4603      	mov	r3, r0
 801250e:	2b00      	cmp	r3, #0
 8012510:	d101      	bne.n	8012516 <LSM303AGR_ACC_W_TEMP_EN_bits+0x26>
    return MEMS_ERROR;
 8012512:	2300      	movs	r3, #0
 8012514:	e01c      	b.n	8012550 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  value &= ~LSM303AGR_ACC_TEMP_EN_MASK;
 8012516:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801251a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801251e:	b2db      	uxtb	r3, r3
 8012520:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012524:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012528:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801252c:	4313      	orrs	r3, r2
 801252e:	b2db      	uxtb	r3, r3
 8012530:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 8012534:	f10d 030f 	add.w	r3, sp, #15
 8012538:	9801      	ldr	r0, [sp, #4]
 801253a:	211f      	movs	r1, #31
 801253c:	461a      	mov	r2, r3
 801253e:	2301      	movs	r3, #1
 8012540:	f7ff fc26 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012544:	4603      	mov	r3, r0
 8012546:	2b00      	cmp	r3, #0
 8012548:	d101      	bne.n	801254e <LSM303AGR_ACC_W_TEMP_EN_bits+0x5e>
    return MEMS_ERROR;
 801254a:	2300      	movs	r3, #0
 801254c:	e000      	b.n	8012550 <LSM303AGR_ACC_W_TEMP_EN_bits+0x60>

  return MEMS_SUCCESS;
 801254e:	2301      	movs	r3, #1
}
 8012550:	4618      	mov	r0, r3
 8012552:	b005      	add	sp, #20
 8012554:	f85d fb04 	ldr.w	pc, [sp], #4
 8012558:	f3af 8000 	nop.w
 801255c:	f3af 8000 	nop.w

08012560 <LSM303AGR_ACC_R_TEMP_EN_bits>:
* Input          : Pointer to LSM303AGR_ACC_TEMP_EN_t
* Output         : Status of TEMP_EN see LSM303AGR_ACC_TEMP_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TEMP_EN_bits(void *handle, LSM303AGR_ACC_TEMP_EN_t *value)
{
 8012560:	b500      	push	{lr}
 8012562:	b083      	sub	sp, #12
 8012564:	9001      	str	r0, [sp, #4]
 8012566:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8012568:	9801      	ldr	r0, [sp, #4]
 801256a:	211f      	movs	r1, #31
 801256c:	9a00      	ldr	r2, [sp, #0]
 801256e:	2301      	movs	r3, #1
 8012570:	f7ff fc36 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012574:	4603      	mov	r3, r0
 8012576:	2b00      	cmp	r3, #0
 8012578:	d101      	bne.n	801257e <LSM303AGR_ACC_R_TEMP_EN_bits+0x1e>
    return MEMS_ERROR;
 801257a:	2300      	movs	r3, #0
 801257c:	e007      	b.n	801258e <LSM303AGR_ACC_R_TEMP_EN_bits+0x2e>

  *value &= LSM303AGR_ACC_TEMP_EN_MASK; //mask
 801257e:	9b00      	ldr	r3, [sp, #0]
 8012580:	781b      	ldrb	r3, [r3, #0]
 8012582:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8012586:	b2da      	uxtb	r2, r3
 8012588:	9b00      	ldr	r3, [sp, #0]
 801258a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801258c:	2301      	movs	r3, #1
}
 801258e:	4618      	mov	r0, r3
 8012590:	b003      	add	sp, #12
 8012592:	f85d fb04 	ldr.w	pc, [sp], #4
 8012596:	bf00      	nop
 8012598:	f3af 8000 	nop.w
 801259c:	f3af 8000 	nop.w

080125a0 <LSM303AGR_ACC_W_ADC_PD>:
* Input          : LSM303AGR_ACC_ADC_PD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t newValue)
{
 80125a0:	b500      	push	{lr}
 80125a2:	b085      	sub	sp, #20
 80125a4:	9001      	str	r0, [sp, #4]
 80125a6:	460b      	mov	r3, r1
 80125a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 80125ac:	f10d 030f 	add.w	r3, sp, #15
 80125b0:	9801      	ldr	r0, [sp, #4]
 80125b2:	211f      	movs	r1, #31
 80125b4:	461a      	mov	r2, r3
 80125b6:	2301      	movs	r3, #1
 80125b8:	f7ff fc12 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80125bc:	4603      	mov	r3, r0
 80125be:	2b00      	cmp	r3, #0
 80125c0:	d101      	bne.n	80125c6 <LSM303AGR_ACC_W_ADC_PD+0x26>
    return MEMS_ERROR;
 80125c2:	2300      	movs	r3, #0
 80125c4:	e01c      	b.n	8012600 <LSM303AGR_ACC_W_ADC_PD+0x60>

  value &= ~LSM303AGR_ACC_ADC_PD_MASK;
 80125c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80125ca:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80125ce:	b2db      	uxtb	r3, r3
 80125d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80125d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80125d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80125dc:	4313      	orrs	r3, r2
 80125de:	b2db      	uxtb	r3, r3
 80125e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, &value, 1) )
 80125e4:	f10d 030f 	add.w	r3, sp, #15
 80125e8:	9801      	ldr	r0, [sp, #4]
 80125ea:	211f      	movs	r1, #31
 80125ec:	461a      	mov	r2, r3
 80125ee:	2301      	movs	r3, #1
 80125f0:	f7ff fbce 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80125f4:	4603      	mov	r3, r0
 80125f6:	2b00      	cmp	r3, #0
 80125f8:	d101      	bne.n	80125fe <LSM303AGR_ACC_W_ADC_PD+0x5e>
    return MEMS_ERROR;
 80125fa:	2300      	movs	r3, #0
 80125fc:	e000      	b.n	8012600 <LSM303AGR_ACC_W_ADC_PD+0x60>

  return MEMS_SUCCESS;
 80125fe:	2301      	movs	r3, #1
}
 8012600:	4618      	mov	r0, r3
 8012602:	b005      	add	sp, #20
 8012604:	f85d fb04 	ldr.w	pc, [sp], #4
 8012608:	f3af 8000 	nop.w
 801260c:	f3af 8000 	nop.w

08012610 <LSM303AGR_ACC_R_ADC_PD>:
* Input          : Pointer to LSM303AGR_ACC_ADC_PD_t
* Output         : Status of ADC_PD see LSM303AGR_ACC_ADC_PD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ADC_PD(void *handle, LSM303AGR_ACC_ADC_PD_t *value)
{
 8012610:	b500      	push	{lr}
 8012612:	b083      	sub	sp, #12
 8012614:	9001      	str	r0, [sp, #4]
 8012616:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TEMP_CFG_REG, (u8_t *)value, 1) )
 8012618:	9801      	ldr	r0, [sp, #4]
 801261a:	211f      	movs	r1, #31
 801261c:	9a00      	ldr	r2, [sp, #0]
 801261e:	2301      	movs	r3, #1
 8012620:	f7ff fbde 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012624:	4603      	mov	r3, r0
 8012626:	2b00      	cmp	r3, #0
 8012628:	d101      	bne.n	801262e <LSM303AGR_ACC_R_ADC_PD+0x1e>
    return MEMS_ERROR;
 801262a:	2300      	movs	r3, #0
 801262c:	e007      	b.n	801263e <LSM303AGR_ACC_R_ADC_PD+0x2e>

  *value &= LSM303AGR_ACC_ADC_PD_MASK; //mask
 801262e:	9b00      	ldr	r3, [sp, #0]
 8012630:	781b      	ldrb	r3, [r3, #0]
 8012632:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8012636:	b2da      	uxtb	r2, r3
 8012638:	9b00      	ldr	r3, [sp, #0]
 801263a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801263c:	2301      	movs	r3, #1
}
 801263e:	4618      	mov	r0, r3
 8012640:	b003      	add	sp, #12
 8012642:	f85d fb04 	ldr.w	pc, [sp], #4
 8012646:	bf00      	nop
 8012648:	f3af 8000 	nop.w
 801264c:	f3af 8000 	nop.w

08012650 <LSM303AGR_ACC_W_XEN>:
* Input          : LSM303AGR_ACC_XEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XEN(void *handle, LSM303AGR_ACC_XEN_t newValue)
{
 8012650:	b500      	push	{lr}
 8012652:	b085      	sub	sp, #20
 8012654:	9001      	str	r0, [sp, #4]
 8012656:	460b      	mov	r3, r1
 8012658:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801265c:	f10d 030f 	add.w	r3, sp, #15
 8012660:	9801      	ldr	r0, [sp, #4]
 8012662:	2120      	movs	r1, #32
 8012664:	461a      	mov	r2, r3
 8012666:	2301      	movs	r3, #1
 8012668:	f7ff fbba 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801266c:	4603      	mov	r3, r0
 801266e:	2b00      	cmp	r3, #0
 8012670:	d101      	bne.n	8012676 <LSM303AGR_ACC_W_XEN+0x26>
    return MEMS_ERROR;
 8012672:	2300      	movs	r3, #0
 8012674:	e01c      	b.n	80126b0 <LSM303AGR_ACC_W_XEN+0x60>

  value &= ~LSM303AGR_ACC_XEN_MASK;
 8012676:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801267a:	f023 0301 	bic.w	r3, r3, #1
 801267e:	b2db      	uxtb	r3, r3
 8012680:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012684:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012688:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801268c:	4313      	orrs	r3, r2
 801268e:	b2db      	uxtb	r3, r3
 8012690:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012694:	f10d 030f 	add.w	r3, sp, #15
 8012698:	9801      	ldr	r0, [sp, #4]
 801269a:	2120      	movs	r1, #32
 801269c:	461a      	mov	r2, r3
 801269e:	2301      	movs	r3, #1
 80126a0:	f7ff fb76 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80126a4:	4603      	mov	r3, r0
 80126a6:	2b00      	cmp	r3, #0
 80126a8:	d101      	bne.n	80126ae <LSM303AGR_ACC_W_XEN+0x5e>
    return MEMS_ERROR;
 80126aa:	2300      	movs	r3, #0
 80126ac:	e000      	b.n	80126b0 <LSM303AGR_ACC_W_XEN+0x60>

  return MEMS_SUCCESS;
 80126ae:	2301      	movs	r3, #1
}
 80126b0:	4618      	mov	r0, r3
 80126b2:	b005      	add	sp, #20
 80126b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80126b8:	f3af 8000 	nop.w
 80126bc:	f3af 8000 	nop.w

080126c0 <LSM303AGR_ACC_R_XEN>:
* Input          : Pointer to LSM303AGR_ACC_XEN_t
* Output         : Status of XEN see LSM303AGR_ACC_XEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XEN(void *handle, LSM303AGR_ACC_XEN_t *value)
{
 80126c0:	b500      	push	{lr}
 80126c2:	b083      	sub	sp, #12
 80126c4:	9001      	str	r0, [sp, #4]
 80126c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 80126c8:	9801      	ldr	r0, [sp, #4]
 80126ca:	2120      	movs	r1, #32
 80126cc:	9a00      	ldr	r2, [sp, #0]
 80126ce:	2301      	movs	r3, #1
 80126d0:	f7ff fb86 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80126d4:	4603      	mov	r3, r0
 80126d6:	2b00      	cmp	r3, #0
 80126d8:	d101      	bne.n	80126de <LSM303AGR_ACC_R_XEN+0x1e>
    return MEMS_ERROR;
 80126da:	2300      	movs	r3, #0
 80126dc:	e007      	b.n	80126ee <LSM303AGR_ACC_R_XEN+0x2e>

  *value &= LSM303AGR_ACC_XEN_MASK; //mask
 80126de:	9b00      	ldr	r3, [sp, #0]
 80126e0:	781b      	ldrb	r3, [r3, #0]
 80126e2:	f003 0301 	and.w	r3, r3, #1
 80126e6:	b2da      	uxtb	r2, r3
 80126e8:	9b00      	ldr	r3, [sp, #0]
 80126ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80126ec:	2301      	movs	r3, #1
}
 80126ee:	4618      	mov	r0, r3
 80126f0:	b003      	add	sp, #12
 80126f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80126f6:	bf00      	nop
 80126f8:	f3af 8000 	nop.w
 80126fc:	f3af 8000 	nop.w

08012700 <LSM303AGR_ACC_W_YEN>:
* Input          : LSM303AGR_ACC_YEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YEN(void *handle, LSM303AGR_ACC_YEN_t newValue)
{
 8012700:	b500      	push	{lr}
 8012702:	b085      	sub	sp, #20
 8012704:	9001      	str	r0, [sp, #4]
 8012706:	460b      	mov	r3, r1
 8012708:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801270c:	f10d 030f 	add.w	r3, sp, #15
 8012710:	9801      	ldr	r0, [sp, #4]
 8012712:	2120      	movs	r1, #32
 8012714:	461a      	mov	r2, r3
 8012716:	2301      	movs	r3, #1
 8012718:	f7ff fb62 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801271c:	4603      	mov	r3, r0
 801271e:	2b00      	cmp	r3, #0
 8012720:	d101      	bne.n	8012726 <LSM303AGR_ACC_W_YEN+0x26>
    return MEMS_ERROR;
 8012722:	2300      	movs	r3, #0
 8012724:	e01c      	b.n	8012760 <LSM303AGR_ACC_W_YEN+0x60>

  value &= ~LSM303AGR_ACC_YEN_MASK;
 8012726:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801272a:	f023 0302 	bic.w	r3, r3, #2
 801272e:	b2db      	uxtb	r3, r3
 8012730:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012734:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012738:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801273c:	4313      	orrs	r3, r2
 801273e:	b2db      	uxtb	r3, r3
 8012740:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 8012744:	f10d 030f 	add.w	r3, sp, #15
 8012748:	9801      	ldr	r0, [sp, #4]
 801274a:	2120      	movs	r1, #32
 801274c:	461a      	mov	r2, r3
 801274e:	2301      	movs	r3, #1
 8012750:	f7ff fb1e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012754:	4603      	mov	r3, r0
 8012756:	2b00      	cmp	r3, #0
 8012758:	d101      	bne.n	801275e <LSM303AGR_ACC_W_YEN+0x5e>
    return MEMS_ERROR;
 801275a:	2300      	movs	r3, #0
 801275c:	e000      	b.n	8012760 <LSM303AGR_ACC_W_YEN+0x60>

  return MEMS_SUCCESS;
 801275e:	2301      	movs	r3, #1
}
 8012760:	4618      	mov	r0, r3
 8012762:	b005      	add	sp, #20
 8012764:	f85d fb04 	ldr.w	pc, [sp], #4
 8012768:	f3af 8000 	nop.w
 801276c:	f3af 8000 	nop.w

08012770 <LSM303AGR_ACC_R_YEN>:
* Input          : Pointer to LSM303AGR_ACC_YEN_t
* Output         : Status of YEN see LSM303AGR_ACC_YEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YEN(void *handle, LSM303AGR_ACC_YEN_t *value)
{
 8012770:	b500      	push	{lr}
 8012772:	b083      	sub	sp, #12
 8012774:	9001      	str	r0, [sp, #4]
 8012776:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012778:	9801      	ldr	r0, [sp, #4]
 801277a:	2120      	movs	r1, #32
 801277c:	9a00      	ldr	r2, [sp, #0]
 801277e:	2301      	movs	r3, #1
 8012780:	f7ff fb2e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012784:	4603      	mov	r3, r0
 8012786:	2b00      	cmp	r3, #0
 8012788:	d101      	bne.n	801278e <LSM303AGR_ACC_R_YEN+0x1e>
    return MEMS_ERROR;
 801278a:	2300      	movs	r3, #0
 801278c:	e007      	b.n	801279e <LSM303AGR_ACC_R_YEN+0x2e>

  *value &= LSM303AGR_ACC_YEN_MASK; //mask
 801278e:	9b00      	ldr	r3, [sp, #0]
 8012790:	781b      	ldrb	r3, [r3, #0]
 8012792:	f003 0302 	and.w	r3, r3, #2
 8012796:	b2da      	uxtb	r2, r3
 8012798:	9b00      	ldr	r3, [sp, #0]
 801279a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801279c:	2301      	movs	r3, #1
}
 801279e:	4618      	mov	r0, r3
 80127a0:	b003      	add	sp, #12
 80127a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80127a6:	bf00      	nop
 80127a8:	f3af 8000 	nop.w
 80127ac:	f3af 8000 	nop.w

080127b0 <LSM303AGR_ACC_W_ZEN>:
* Input          : LSM303AGR_ACC_ZEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZEN(void *handle, LSM303AGR_ACC_ZEN_t newValue)
{
 80127b0:	b500      	push	{lr}
 80127b2:	b085      	sub	sp, #20
 80127b4:	9001      	str	r0, [sp, #4]
 80127b6:	460b      	mov	r3, r1
 80127b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80127bc:	f10d 030f 	add.w	r3, sp, #15
 80127c0:	9801      	ldr	r0, [sp, #4]
 80127c2:	2120      	movs	r1, #32
 80127c4:	461a      	mov	r2, r3
 80127c6:	2301      	movs	r3, #1
 80127c8:	f7ff fb0a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80127cc:	4603      	mov	r3, r0
 80127ce:	2b00      	cmp	r3, #0
 80127d0:	d101      	bne.n	80127d6 <LSM303AGR_ACC_W_ZEN+0x26>
    return MEMS_ERROR;
 80127d2:	2300      	movs	r3, #0
 80127d4:	e01c      	b.n	8012810 <LSM303AGR_ACC_W_ZEN+0x60>

  value &= ~LSM303AGR_ACC_ZEN_MASK;
 80127d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80127da:	f023 0304 	bic.w	r3, r3, #4
 80127de:	b2db      	uxtb	r3, r3
 80127e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80127e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80127e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80127ec:	4313      	orrs	r3, r2
 80127ee:	b2db      	uxtb	r3, r3
 80127f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80127f4:	f10d 030f 	add.w	r3, sp, #15
 80127f8:	9801      	ldr	r0, [sp, #4]
 80127fa:	2120      	movs	r1, #32
 80127fc:	461a      	mov	r2, r3
 80127fe:	2301      	movs	r3, #1
 8012800:	f7ff fac6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012804:	4603      	mov	r3, r0
 8012806:	2b00      	cmp	r3, #0
 8012808:	d101      	bne.n	801280e <LSM303AGR_ACC_W_ZEN+0x5e>
    return MEMS_ERROR;
 801280a:	2300      	movs	r3, #0
 801280c:	e000      	b.n	8012810 <LSM303AGR_ACC_W_ZEN+0x60>

  return MEMS_SUCCESS;
 801280e:	2301      	movs	r3, #1
}
 8012810:	4618      	mov	r0, r3
 8012812:	b005      	add	sp, #20
 8012814:	f85d fb04 	ldr.w	pc, [sp], #4
 8012818:	f3af 8000 	nop.w
 801281c:	f3af 8000 	nop.w

08012820 <LSM303AGR_ACC_R_ZEN>:
* Input          : Pointer to LSM303AGR_ACC_ZEN_t
* Output         : Status of ZEN see LSM303AGR_ACC_ZEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZEN(void *handle, LSM303AGR_ACC_ZEN_t *value)
{
 8012820:	b500      	push	{lr}
 8012822:	b083      	sub	sp, #12
 8012824:	9001      	str	r0, [sp, #4]
 8012826:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 8012828:	9801      	ldr	r0, [sp, #4]
 801282a:	2120      	movs	r1, #32
 801282c:	9a00      	ldr	r2, [sp, #0]
 801282e:	2301      	movs	r3, #1
 8012830:	f7ff fad6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012834:	4603      	mov	r3, r0
 8012836:	2b00      	cmp	r3, #0
 8012838:	d101      	bne.n	801283e <LSM303AGR_ACC_R_ZEN+0x1e>
    return MEMS_ERROR;
 801283a:	2300      	movs	r3, #0
 801283c:	e007      	b.n	801284e <LSM303AGR_ACC_R_ZEN+0x2e>

  *value &= LSM303AGR_ACC_ZEN_MASK; //mask
 801283e:	9b00      	ldr	r3, [sp, #0]
 8012840:	781b      	ldrb	r3, [r3, #0]
 8012842:	f003 0304 	and.w	r3, r3, #4
 8012846:	b2da      	uxtb	r2, r3
 8012848:	9b00      	ldr	r3, [sp, #0]
 801284a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801284c:	2301      	movs	r3, #1
}
 801284e:	4618      	mov	r0, r3
 8012850:	b003      	add	sp, #12
 8012852:	f85d fb04 	ldr.w	pc, [sp], #4
 8012856:	bf00      	nop
 8012858:	f3af 8000 	nop.w
 801285c:	f3af 8000 	nop.w

08012860 <LSM303AGR_ACC_W_LOWPWR_EN>:
* Input          : LSM303AGR_ACC_LPEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t newValue)
{
 8012860:	b500      	push	{lr}
 8012862:	b085      	sub	sp, #20
 8012864:	9001      	str	r0, [sp, #4]
 8012866:	460b      	mov	r3, r1
 8012868:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 801286c:	f10d 030f 	add.w	r3, sp, #15
 8012870:	9801      	ldr	r0, [sp, #4]
 8012872:	2120      	movs	r1, #32
 8012874:	461a      	mov	r2, r3
 8012876:	2301      	movs	r3, #1
 8012878:	f7ff fab2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801287c:	4603      	mov	r3, r0
 801287e:	2b00      	cmp	r3, #0
 8012880:	d101      	bne.n	8012886 <LSM303AGR_ACC_W_LOWPWR_EN+0x26>
    return MEMS_ERROR;
 8012882:	2300      	movs	r3, #0
 8012884:	e01c      	b.n	80128c0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  value &= ~LSM303AGR_ACC_LPEN_MASK;
 8012886:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801288a:	f023 0308 	bic.w	r3, r3, #8
 801288e:	b2db      	uxtb	r3, r3
 8012890:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012894:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012898:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801289c:	4313      	orrs	r3, r2
 801289e:	b2db      	uxtb	r3, r3
 80128a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG1, &value, 1) )
 80128a4:	f10d 030f 	add.w	r3, sp, #15
 80128a8:	9801      	ldr	r0, [sp, #4]
 80128aa:	2120      	movs	r1, #32
 80128ac:	461a      	mov	r2, r3
 80128ae:	2301      	movs	r3, #1
 80128b0:	f7ff fa6e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80128b4:	4603      	mov	r3, r0
 80128b6:	2b00      	cmp	r3, #0
 80128b8:	d101      	bne.n	80128be <LSM303AGR_ACC_W_LOWPWR_EN+0x5e>
    return MEMS_ERROR;
 80128ba:	2300      	movs	r3, #0
 80128bc:	e000      	b.n	80128c0 <LSM303AGR_ACC_W_LOWPWR_EN+0x60>

  return MEMS_SUCCESS;
 80128be:	2301      	movs	r3, #1
}
 80128c0:	4618      	mov	r0, r3
 80128c2:	b005      	add	sp, #20
 80128c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80128c8:	f3af 8000 	nop.w
 80128cc:	f3af 8000 	nop.w

080128d0 <LSM303AGR_ACC_R_LOWPWR_EN>:
* Input          : Pointer to LSM303AGR_ACC_LPEN_t
* Output         : Status of LPEN see LSM303AGR_ACC_LPEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LOWPWR_EN(void *handle, LSM303AGR_ACC_LPEN_t *value)
{
 80128d0:	b500      	push	{lr}
 80128d2:	b083      	sub	sp, #12
 80128d4:	9001      	str	r0, [sp, #4]
 80128d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG1, (u8_t *)value, 1) )
 80128d8:	9801      	ldr	r0, [sp, #4]
 80128da:	2120      	movs	r1, #32
 80128dc:	9a00      	ldr	r2, [sp, #0]
 80128de:	2301      	movs	r3, #1
 80128e0:	f7ff fa7e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80128e4:	4603      	mov	r3, r0
 80128e6:	2b00      	cmp	r3, #0
 80128e8:	d101      	bne.n	80128ee <LSM303AGR_ACC_R_LOWPWR_EN+0x1e>
    return MEMS_ERROR;
 80128ea:	2300      	movs	r3, #0
 80128ec:	e007      	b.n	80128fe <LSM303AGR_ACC_R_LOWPWR_EN+0x2e>

  *value &= LSM303AGR_ACC_LPEN_MASK; //mask
 80128ee:	9b00      	ldr	r3, [sp, #0]
 80128f0:	781b      	ldrb	r3, [r3, #0]
 80128f2:	f003 0308 	and.w	r3, r3, #8
 80128f6:	b2da      	uxtb	r2, r3
 80128f8:	9b00      	ldr	r3, [sp, #0]
 80128fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80128fc:	2301      	movs	r3, #1
}
 80128fe:	4618      	mov	r0, r3
 8012900:	b003      	add	sp, #12
 8012902:	f85d fb04 	ldr.w	pc, [sp], #4
 8012906:	bf00      	nop
 8012908:	f3af 8000 	nop.w
 801290c:	f3af 8000 	nop.w

08012910 <LSM303AGR_ACC_W_hpf_aoi_en_int1>:
* Input          : LSM303AGR_ACC_HPIS1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t newValue)
{
 8012910:	b500      	push	{lr}
 8012912:	b085      	sub	sp, #20
 8012914:	9001      	str	r0, [sp, #4]
 8012916:	460b      	mov	r3, r1
 8012918:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 801291c:	f10d 030f 	add.w	r3, sp, #15
 8012920:	9801      	ldr	r0, [sp, #4]
 8012922:	2121      	movs	r1, #33	; 0x21
 8012924:	461a      	mov	r2, r3
 8012926:	2301      	movs	r3, #1
 8012928:	f7ff fa5a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801292c:	4603      	mov	r3, r0
 801292e:	2b00      	cmp	r3, #0
 8012930:	d101      	bne.n	8012936 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x26>
    return MEMS_ERROR;
 8012932:	2300      	movs	r3, #0
 8012934:	e01c      	b.n	8012970 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  value &= ~LSM303AGR_ACC_HPIS1_MASK;
 8012936:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801293a:	f023 0301 	bic.w	r3, r3, #1
 801293e:	b2db      	uxtb	r3, r3
 8012940:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012944:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012948:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801294c:	4313      	orrs	r3, r2
 801294e:	b2db      	uxtb	r3, r3
 8012950:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012954:	f10d 030f 	add.w	r3, sp, #15
 8012958:	9801      	ldr	r0, [sp, #4]
 801295a:	2121      	movs	r1, #33	; 0x21
 801295c:	461a      	mov	r2, r3
 801295e:	2301      	movs	r3, #1
 8012960:	f7ff fa16 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012964:	4603      	mov	r3, r0
 8012966:	2b00      	cmp	r3, #0
 8012968:	d101      	bne.n	801296e <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x5e>
    return MEMS_ERROR;
 801296a:	2300      	movs	r3, #0
 801296c:	e000      	b.n	8012970 <LSM303AGR_ACC_W_hpf_aoi_en_int1+0x60>

  return MEMS_SUCCESS;
 801296e:	2301      	movs	r3, #1
}
 8012970:	4618      	mov	r0, r3
 8012972:	b005      	add	sp, #20
 8012974:	f85d fb04 	ldr.w	pc, [sp], #4
 8012978:	f3af 8000 	nop.w
 801297c:	f3af 8000 	nop.w

08012980 <LSM303AGR_ACC_R_hpf_aoi_en_int1>:
* Input          : Pointer to LSM303AGR_ACC_HPIS1_t
* Output         : Status of HPIS1 see LSM303AGR_ACC_HPIS1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int1(void *handle, LSM303AGR_ACC_HPIS1_t *value)
{
 8012980:	b500      	push	{lr}
 8012982:	b083      	sub	sp, #12
 8012984:	9001      	str	r0, [sp, #4]
 8012986:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012988:	9801      	ldr	r0, [sp, #4]
 801298a:	2121      	movs	r1, #33	; 0x21
 801298c:	9a00      	ldr	r2, [sp, #0]
 801298e:	2301      	movs	r3, #1
 8012990:	f7ff fa26 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012994:	4603      	mov	r3, r0
 8012996:	2b00      	cmp	r3, #0
 8012998:	d101      	bne.n	801299e <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x1e>
    return MEMS_ERROR;
 801299a:	2300      	movs	r3, #0
 801299c:	e007      	b.n	80129ae <LSM303AGR_ACC_R_hpf_aoi_en_int1+0x2e>

  *value &= LSM303AGR_ACC_HPIS1_MASK; //mask
 801299e:	9b00      	ldr	r3, [sp, #0]
 80129a0:	781b      	ldrb	r3, [r3, #0]
 80129a2:	f003 0301 	and.w	r3, r3, #1
 80129a6:	b2da      	uxtb	r2, r3
 80129a8:	9b00      	ldr	r3, [sp, #0]
 80129aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80129ac:	2301      	movs	r3, #1
}
 80129ae:	4618      	mov	r0, r3
 80129b0:	b003      	add	sp, #12
 80129b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80129b6:	bf00      	nop
 80129b8:	f3af 8000 	nop.w
 80129bc:	f3af 8000 	nop.w

080129c0 <LSM303AGR_ACC_W_hpf_aoi_en_int2>:
* Input          : LSM303AGR_ACC_HPIS2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t newValue)
{
 80129c0:	b500      	push	{lr}
 80129c2:	b085      	sub	sp, #20
 80129c4:	9001      	str	r0, [sp, #4]
 80129c6:	460b      	mov	r3, r1
 80129c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 80129cc:	f10d 030f 	add.w	r3, sp, #15
 80129d0:	9801      	ldr	r0, [sp, #4]
 80129d2:	2121      	movs	r1, #33	; 0x21
 80129d4:	461a      	mov	r2, r3
 80129d6:	2301      	movs	r3, #1
 80129d8:	f7ff fa02 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80129dc:	4603      	mov	r3, r0
 80129de:	2b00      	cmp	r3, #0
 80129e0:	d101      	bne.n	80129e6 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x26>
    return MEMS_ERROR;
 80129e2:	2300      	movs	r3, #0
 80129e4:	e01c      	b.n	8012a20 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  value &= ~LSM303AGR_ACC_HPIS2_MASK;
 80129e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80129ea:	f023 0302 	bic.w	r3, r3, #2
 80129ee:	b2db      	uxtb	r3, r3
 80129f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80129f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80129f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80129fc:	4313      	orrs	r3, r2
 80129fe:	b2db      	uxtb	r3, r3
 8012a00:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012a04:	f10d 030f 	add.w	r3, sp, #15
 8012a08:	9801      	ldr	r0, [sp, #4]
 8012a0a:	2121      	movs	r1, #33	; 0x21
 8012a0c:	461a      	mov	r2, r3
 8012a0e:	2301      	movs	r3, #1
 8012a10:	f7ff f9be 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012a14:	4603      	mov	r3, r0
 8012a16:	2b00      	cmp	r3, #0
 8012a18:	d101      	bne.n	8012a1e <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x5e>
    return MEMS_ERROR;
 8012a1a:	2300      	movs	r3, #0
 8012a1c:	e000      	b.n	8012a20 <LSM303AGR_ACC_W_hpf_aoi_en_int2+0x60>

  return MEMS_SUCCESS;
 8012a1e:	2301      	movs	r3, #1
}
 8012a20:	4618      	mov	r0, r3
 8012a22:	b005      	add	sp, #20
 8012a24:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a28:	f3af 8000 	nop.w
 8012a2c:	f3af 8000 	nop.w

08012a30 <LSM303AGR_ACC_R_hpf_aoi_en_int2>:
* Input          : Pointer to LSM303AGR_ACC_HPIS2_t
* Output         : Status of HPIS2 see LSM303AGR_ACC_HPIS2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_aoi_en_int2(void *handle, LSM303AGR_ACC_HPIS2_t *value)
{
 8012a30:	b500      	push	{lr}
 8012a32:	b083      	sub	sp, #12
 8012a34:	9001      	str	r0, [sp, #4]
 8012a36:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012a38:	9801      	ldr	r0, [sp, #4]
 8012a3a:	2121      	movs	r1, #33	; 0x21
 8012a3c:	9a00      	ldr	r2, [sp, #0]
 8012a3e:	2301      	movs	r3, #1
 8012a40:	f7ff f9ce 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012a44:	4603      	mov	r3, r0
 8012a46:	2b00      	cmp	r3, #0
 8012a48:	d101      	bne.n	8012a4e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x1e>
    return MEMS_ERROR;
 8012a4a:	2300      	movs	r3, #0
 8012a4c:	e007      	b.n	8012a5e <LSM303AGR_ACC_R_hpf_aoi_en_int2+0x2e>

  *value &= LSM303AGR_ACC_HPIS2_MASK; //mask
 8012a4e:	9b00      	ldr	r3, [sp, #0]
 8012a50:	781b      	ldrb	r3, [r3, #0]
 8012a52:	f003 0302 	and.w	r3, r3, #2
 8012a56:	b2da      	uxtb	r2, r3
 8012a58:	9b00      	ldr	r3, [sp, #0]
 8012a5a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012a5c:	2301      	movs	r3, #1
}
 8012a5e:	4618      	mov	r0, r3
 8012a60:	b003      	add	sp, #12
 8012a62:	f85d fb04 	ldr.w	pc, [sp], #4
 8012a66:	bf00      	nop
 8012a68:	f3af 8000 	nop.w
 8012a6c:	f3af 8000 	nop.w

08012a70 <LSM303AGR_ACC_W_hpf_click_en>:
* Input          : LSM303AGR_ACC_HPCLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t newValue)
{
 8012a70:	b500      	push	{lr}
 8012a72:	b085      	sub	sp, #20
 8012a74:	9001      	str	r0, [sp, #4]
 8012a76:	460b      	mov	r3, r1
 8012a78:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012a7c:	f10d 030f 	add.w	r3, sp, #15
 8012a80:	9801      	ldr	r0, [sp, #4]
 8012a82:	2121      	movs	r1, #33	; 0x21
 8012a84:	461a      	mov	r2, r3
 8012a86:	2301      	movs	r3, #1
 8012a88:	f7ff f9aa 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012a8c:	4603      	mov	r3, r0
 8012a8e:	2b00      	cmp	r3, #0
 8012a90:	d101      	bne.n	8012a96 <LSM303AGR_ACC_W_hpf_click_en+0x26>
    return MEMS_ERROR;
 8012a92:	2300      	movs	r3, #0
 8012a94:	e01c      	b.n	8012ad0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  value &= ~LSM303AGR_ACC_HPCLICK_MASK;
 8012a96:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012a9a:	f023 0304 	bic.w	r3, r3, #4
 8012a9e:	b2db      	uxtb	r3, r3
 8012aa0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012aa4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012aa8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012aac:	4313      	orrs	r3, r2
 8012aae:	b2db      	uxtb	r3, r3
 8012ab0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012ab4:	f10d 030f 	add.w	r3, sp, #15
 8012ab8:	9801      	ldr	r0, [sp, #4]
 8012aba:	2121      	movs	r1, #33	; 0x21
 8012abc:	461a      	mov	r2, r3
 8012abe:	2301      	movs	r3, #1
 8012ac0:	f7ff f966 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012ac4:	4603      	mov	r3, r0
 8012ac6:	2b00      	cmp	r3, #0
 8012ac8:	d101      	bne.n	8012ace <LSM303AGR_ACC_W_hpf_click_en+0x5e>
    return MEMS_ERROR;
 8012aca:	2300      	movs	r3, #0
 8012acc:	e000      	b.n	8012ad0 <LSM303AGR_ACC_W_hpf_click_en+0x60>

  return MEMS_SUCCESS;
 8012ace:	2301      	movs	r3, #1
}
 8012ad0:	4618      	mov	r0, r3
 8012ad2:	b005      	add	sp, #20
 8012ad4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ad8:	f3af 8000 	nop.w
 8012adc:	f3af 8000 	nop.w

08012ae0 <LSM303AGR_ACC_R_hpf_click_en>:
* Input          : Pointer to LSM303AGR_ACC_HPCLICK_t
* Output         : Status of HPCLICK see LSM303AGR_ACC_HPCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_click_en(void *handle, LSM303AGR_ACC_HPCLICK_t *value)
{
 8012ae0:	b500      	push	{lr}
 8012ae2:	b083      	sub	sp, #12
 8012ae4:	9001      	str	r0, [sp, #4]
 8012ae6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012ae8:	9801      	ldr	r0, [sp, #4]
 8012aea:	2121      	movs	r1, #33	; 0x21
 8012aec:	9a00      	ldr	r2, [sp, #0]
 8012aee:	2301      	movs	r3, #1
 8012af0:	f7ff f976 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012af4:	4603      	mov	r3, r0
 8012af6:	2b00      	cmp	r3, #0
 8012af8:	d101      	bne.n	8012afe <LSM303AGR_ACC_R_hpf_click_en+0x1e>
    return MEMS_ERROR;
 8012afa:	2300      	movs	r3, #0
 8012afc:	e007      	b.n	8012b0e <LSM303AGR_ACC_R_hpf_click_en+0x2e>

  *value &= LSM303AGR_ACC_HPCLICK_MASK; //mask
 8012afe:	9b00      	ldr	r3, [sp, #0]
 8012b00:	781b      	ldrb	r3, [r3, #0]
 8012b02:	f003 0304 	and.w	r3, r3, #4
 8012b06:	b2da      	uxtb	r2, r3
 8012b08:	9b00      	ldr	r3, [sp, #0]
 8012b0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012b0c:	2301      	movs	r3, #1
}
 8012b0e:	4618      	mov	r0, r3
 8012b10:	b003      	add	sp, #12
 8012b12:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b16:	bf00      	nop
 8012b18:	f3af 8000 	nop.w
 8012b1c:	f3af 8000 	nop.w

08012b20 <LSM303AGR_ACC_W_Data_Filter>:
* Input          : LSM303AGR_ACC_FDS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t newValue)
{
 8012b20:	b500      	push	{lr}
 8012b22:	b085      	sub	sp, #20
 8012b24:	9001      	str	r0, [sp, #4]
 8012b26:	460b      	mov	r3, r1
 8012b28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012b2c:	f10d 030f 	add.w	r3, sp, #15
 8012b30:	9801      	ldr	r0, [sp, #4]
 8012b32:	2121      	movs	r1, #33	; 0x21
 8012b34:	461a      	mov	r2, r3
 8012b36:	2301      	movs	r3, #1
 8012b38:	f7ff f952 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012b3c:	4603      	mov	r3, r0
 8012b3e:	2b00      	cmp	r3, #0
 8012b40:	d101      	bne.n	8012b46 <LSM303AGR_ACC_W_Data_Filter+0x26>
    return MEMS_ERROR;
 8012b42:	2300      	movs	r3, #0
 8012b44:	e01c      	b.n	8012b80 <LSM303AGR_ACC_W_Data_Filter+0x60>

  value &= ~LSM303AGR_ACC_FDS_MASK;
 8012b46:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012b4a:	f023 0308 	bic.w	r3, r3, #8
 8012b4e:	b2db      	uxtb	r3, r3
 8012b50:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012b54:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012b58:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012b5c:	4313      	orrs	r3, r2
 8012b5e:	b2db      	uxtb	r3, r3
 8012b60:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012b64:	f10d 030f 	add.w	r3, sp, #15
 8012b68:	9801      	ldr	r0, [sp, #4]
 8012b6a:	2121      	movs	r1, #33	; 0x21
 8012b6c:	461a      	mov	r2, r3
 8012b6e:	2301      	movs	r3, #1
 8012b70:	f7ff f90e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012b74:	4603      	mov	r3, r0
 8012b76:	2b00      	cmp	r3, #0
 8012b78:	d101      	bne.n	8012b7e <LSM303AGR_ACC_W_Data_Filter+0x5e>
    return MEMS_ERROR;
 8012b7a:	2300      	movs	r3, #0
 8012b7c:	e000      	b.n	8012b80 <LSM303AGR_ACC_W_Data_Filter+0x60>

  return MEMS_SUCCESS;
 8012b7e:	2301      	movs	r3, #1
}
 8012b80:	4618      	mov	r0, r3
 8012b82:	b005      	add	sp, #20
 8012b84:	f85d fb04 	ldr.w	pc, [sp], #4
 8012b88:	f3af 8000 	nop.w
 8012b8c:	f3af 8000 	nop.w

08012b90 <LSM303AGR_ACC_R_Data_Filter>:
* Input          : Pointer to LSM303AGR_ACC_FDS_t
* Output         : Status of FDS see LSM303AGR_ACC_FDS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Data_Filter(void *handle, LSM303AGR_ACC_FDS_t *value)
{
 8012b90:	b500      	push	{lr}
 8012b92:	b083      	sub	sp, #12
 8012b94:	9001      	str	r0, [sp, #4]
 8012b96:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012b98:	9801      	ldr	r0, [sp, #4]
 8012b9a:	2121      	movs	r1, #33	; 0x21
 8012b9c:	9a00      	ldr	r2, [sp, #0]
 8012b9e:	2301      	movs	r3, #1
 8012ba0:	f7ff f91e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012ba4:	4603      	mov	r3, r0
 8012ba6:	2b00      	cmp	r3, #0
 8012ba8:	d101      	bne.n	8012bae <LSM303AGR_ACC_R_Data_Filter+0x1e>
    return MEMS_ERROR;
 8012baa:	2300      	movs	r3, #0
 8012bac:	e007      	b.n	8012bbe <LSM303AGR_ACC_R_Data_Filter+0x2e>

  *value &= LSM303AGR_ACC_FDS_MASK; //mask
 8012bae:	9b00      	ldr	r3, [sp, #0]
 8012bb0:	781b      	ldrb	r3, [r3, #0]
 8012bb2:	f003 0308 	and.w	r3, r3, #8
 8012bb6:	b2da      	uxtb	r2, r3
 8012bb8:	9b00      	ldr	r3, [sp, #0]
 8012bba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012bbc:	2301      	movs	r3, #1
}
 8012bbe:	4618      	mov	r0, r3
 8012bc0:	b003      	add	sp, #12
 8012bc2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012bc6:	bf00      	nop
 8012bc8:	f3af 8000 	nop.w
 8012bcc:	f3af 8000 	nop.w

08012bd0 <LSM303AGR_ACC_W_hpf_cutoff_freq>:
* Input          : LSM303AGR_ACC_HPCF_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t newValue)
{
 8012bd0:	b500      	push	{lr}
 8012bd2:	b085      	sub	sp, #20
 8012bd4:	9001      	str	r0, [sp, #4]
 8012bd6:	460b      	mov	r3, r1
 8012bd8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012bdc:	f10d 030f 	add.w	r3, sp, #15
 8012be0:	9801      	ldr	r0, [sp, #4]
 8012be2:	2121      	movs	r1, #33	; 0x21
 8012be4:	461a      	mov	r2, r3
 8012be6:	2301      	movs	r3, #1
 8012be8:	f7ff f8fa 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012bec:	4603      	mov	r3, r0
 8012bee:	2b00      	cmp	r3, #0
 8012bf0:	d101      	bne.n	8012bf6 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x26>
    return MEMS_ERROR;
 8012bf2:	2300      	movs	r3, #0
 8012bf4:	e01c      	b.n	8012c30 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  value &= ~LSM303AGR_ACC_HPCF_MASK;
 8012bf6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012bfa:	f023 0330 	bic.w	r3, r3, #48	; 0x30
 8012bfe:	b2db      	uxtb	r3, r3
 8012c00:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012c04:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012c08:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012c0c:	4313      	orrs	r3, r2
 8012c0e:	b2db      	uxtb	r3, r3
 8012c10:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012c14:	f10d 030f 	add.w	r3, sp, #15
 8012c18:	9801      	ldr	r0, [sp, #4]
 8012c1a:	2121      	movs	r1, #33	; 0x21
 8012c1c:	461a      	mov	r2, r3
 8012c1e:	2301      	movs	r3, #1
 8012c20:	f7ff f8b6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012c24:	4603      	mov	r3, r0
 8012c26:	2b00      	cmp	r3, #0
 8012c28:	d101      	bne.n	8012c2e <LSM303AGR_ACC_W_hpf_cutoff_freq+0x5e>
    return MEMS_ERROR;
 8012c2a:	2300      	movs	r3, #0
 8012c2c:	e000      	b.n	8012c30 <LSM303AGR_ACC_W_hpf_cutoff_freq+0x60>

  return MEMS_SUCCESS;
 8012c2e:	2301      	movs	r3, #1
}
 8012c30:	4618      	mov	r0, r3
 8012c32:	b005      	add	sp, #20
 8012c34:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c38:	f3af 8000 	nop.w
 8012c3c:	f3af 8000 	nop.w

08012c40 <LSM303AGR_ACC_R_hpf_cutoff_freq>:
* Input          : Pointer to LSM303AGR_ACC_HPCF_t
* Output         : Status of HPCF see LSM303AGR_ACC_HPCF_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_cutoff_freq(void *handle, LSM303AGR_ACC_HPCF_t *value)
{
 8012c40:	b500      	push	{lr}
 8012c42:	b083      	sub	sp, #12
 8012c44:	9001      	str	r0, [sp, #4]
 8012c46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012c48:	9801      	ldr	r0, [sp, #4]
 8012c4a:	2121      	movs	r1, #33	; 0x21
 8012c4c:	9a00      	ldr	r2, [sp, #0]
 8012c4e:	2301      	movs	r3, #1
 8012c50:	f7ff f8c6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012c54:	4603      	mov	r3, r0
 8012c56:	2b00      	cmp	r3, #0
 8012c58:	d101      	bne.n	8012c5e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x1e>
    return MEMS_ERROR;
 8012c5a:	2300      	movs	r3, #0
 8012c5c:	e007      	b.n	8012c6e <LSM303AGR_ACC_R_hpf_cutoff_freq+0x2e>

  *value &= LSM303AGR_ACC_HPCF_MASK; //mask
 8012c5e:	9b00      	ldr	r3, [sp, #0]
 8012c60:	781b      	ldrb	r3, [r3, #0]
 8012c62:	f003 0330 	and.w	r3, r3, #48	; 0x30
 8012c66:	b2da      	uxtb	r2, r3
 8012c68:	9b00      	ldr	r3, [sp, #0]
 8012c6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012c6c:	2301      	movs	r3, #1
}
 8012c6e:	4618      	mov	r0, r3
 8012c70:	b003      	add	sp, #12
 8012c72:	f85d fb04 	ldr.w	pc, [sp], #4
 8012c76:	bf00      	nop
 8012c78:	f3af 8000 	nop.w
 8012c7c:	f3af 8000 	nop.w

08012c80 <LSM303AGR_ACC_W_hpf_mode>:
* Input          : LSM303AGR_ACC_HPM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t newValue)
{
 8012c80:	b500      	push	{lr}
 8012c82:	b085      	sub	sp, #20
 8012c84:	9001      	str	r0, [sp, #4]
 8012c86:	460b      	mov	r3, r1
 8012c88:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012c8c:	f10d 030f 	add.w	r3, sp, #15
 8012c90:	9801      	ldr	r0, [sp, #4]
 8012c92:	2121      	movs	r1, #33	; 0x21
 8012c94:	461a      	mov	r2, r3
 8012c96:	2301      	movs	r3, #1
 8012c98:	f7ff f8a2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012c9c:	4603      	mov	r3, r0
 8012c9e:	2b00      	cmp	r3, #0
 8012ca0:	d101      	bne.n	8012ca6 <LSM303AGR_ACC_W_hpf_mode+0x26>
    return MEMS_ERROR;
 8012ca2:	2300      	movs	r3, #0
 8012ca4:	e01c      	b.n	8012ce0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  value &= ~LSM303AGR_ACC_HPM_MASK;
 8012ca6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012caa:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8012cae:	b2db      	uxtb	r3, r3
 8012cb0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012cb4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012cb8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012cbc:	4313      	orrs	r3, r2
 8012cbe:	b2db      	uxtb	r3, r3
 8012cc0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG2, &value, 1) )
 8012cc4:	f10d 030f 	add.w	r3, sp, #15
 8012cc8:	9801      	ldr	r0, [sp, #4]
 8012cca:	2121      	movs	r1, #33	; 0x21
 8012ccc:	461a      	mov	r2, r3
 8012cce:	2301      	movs	r3, #1
 8012cd0:	f7ff f85e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012cd4:	4603      	mov	r3, r0
 8012cd6:	2b00      	cmp	r3, #0
 8012cd8:	d101      	bne.n	8012cde <LSM303AGR_ACC_W_hpf_mode+0x5e>
    return MEMS_ERROR;
 8012cda:	2300      	movs	r3, #0
 8012cdc:	e000      	b.n	8012ce0 <LSM303AGR_ACC_W_hpf_mode+0x60>

  return MEMS_SUCCESS;
 8012cde:	2301      	movs	r3, #1
}
 8012ce0:	4618      	mov	r0, r3
 8012ce2:	b005      	add	sp, #20
 8012ce4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ce8:	f3af 8000 	nop.w
 8012cec:	f3af 8000 	nop.w

08012cf0 <LSM303AGR_ACC_R_hpf_mode>:
* Input          : Pointer to LSM303AGR_ACC_HPM_t
* Output         : Status of HPM see LSM303AGR_ACC_HPM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_hpf_mode(void *handle, LSM303AGR_ACC_HPM_t *value)
{
 8012cf0:	b500      	push	{lr}
 8012cf2:	b083      	sub	sp, #12
 8012cf4:	9001      	str	r0, [sp, #4]
 8012cf6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG2, (u8_t *)value, 1) )
 8012cf8:	9801      	ldr	r0, [sp, #4]
 8012cfa:	2121      	movs	r1, #33	; 0x21
 8012cfc:	9a00      	ldr	r2, [sp, #0]
 8012cfe:	2301      	movs	r3, #1
 8012d00:	f7ff f86e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012d04:	4603      	mov	r3, r0
 8012d06:	2b00      	cmp	r3, #0
 8012d08:	d101      	bne.n	8012d0e <LSM303AGR_ACC_R_hpf_mode+0x1e>
    return MEMS_ERROR;
 8012d0a:	2300      	movs	r3, #0
 8012d0c:	e007      	b.n	8012d1e <LSM303AGR_ACC_R_hpf_mode+0x2e>

  *value &= LSM303AGR_ACC_HPM_MASK; //mask
 8012d0e:	9b00      	ldr	r3, [sp, #0]
 8012d10:	781b      	ldrb	r3, [r3, #0]
 8012d12:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 8012d16:	b2da      	uxtb	r2, r3
 8012d18:	9b00      	ldr	r3, [sp, #0]
 8012d1a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012d1c:	2301      	movs	r3, #1
}
 8012d1e:	4618      	mov	r0, r3
 8012d20:	b003      	add	sp, #12
 8012d22:	f85d fb04 	ldr.w	pc, [sp], #4
 8012d26:	bf00      	nop
 8012d28:	f3af 8000 	nop.w
 8012d2c:	f3af 8000 	nop.w

08012d30 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1>:
* Input          : LSM303AGR_ACC_I1_OVERRUN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t newValue)
{
 8012d30:	b500      	push	{lr}
 8012d32:	b085      	sub	sp, #20
 8012d34:	9001      	str	r0, [sp, #4]
 8012d36:	460b      	mov	r3, r1
 8012d38:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012d3c:	f10d 030f 	add.w	r3, sp, #15
 8012d40:	9801      	ldr	r0, [sp, #4]
 8012d42:	2122      	movs	r1, #34	; 0x22
 8012d44:	461a      	mov	r2, r3
 8012d46:	2301      	movs	r3, #1
 8012d48:	f7ff f84a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012d4c:	4603      	mov	r3, r0
 8012d4e:	2b00      	cmp	r3, #0
 8012d50:	d101      	bne.n	8012d56 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x26>
    return MEMS_ERROR;
 8012d52:	2300      	movs	r3, #0
 8012d54:	e01c      	b.n	8012d90 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_OVERRUN_MASK;
 8012d56:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012d5a:	f023 0302 	bic.w	r3, r3, #2
 8012d5e:	b2db      	uxtb	r3, r3
 8012d60:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012d64:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012d68:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012d6c:	4313      	orrs	r3, r2
 8012d6e:	b2db      	uxtb	r3, r3
 8012d70:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012d74:	f10d 030f 	add.w	r3, sp, #15
 8012d78:	9801      	ldr	r0, [sp, #4]
 8012d7a:	2122      	movs	r1, #34	; 0x22
 8012d7c:	461a      	mov	r2, r3
 8012d7e:	2301      	movs	r3, #1
 8012d80:	f7ff f806 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012d84:	4603      	mov	r3, r0
 8012d86:	2b00      	cmp	r3, #0
 8012d88:	d101      	bne.n	8012d8e <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x5e>
    return MEMS_ERROR;
 8012d8a:	2300      	movs	r3, #0
 8012d8c:	e000      	b.n	8012d90 <LSM303AGR_ACC_W_FIFO_Overrun_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012d8e:	2301      	movs	r3, #1
}
 8012d90:	4618      	mov	r0, r3
 8012d92:	b005      	add	sp, #20
 8012d94:	f85d fb04 	ldr.w	pc, [sp], #4
 8012d98:	f3af 8000 	nop.w
 8012d9c:	f3af 8000 	nop.w

08012da0 <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_OVERRUN_t
* Output         : Status of I1_OVERRUN see LSM303AGR_ACC_I1_OVERRUN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Overrun_on_INT1(void *handle, LSM303AGR_ACC_I1_OVERRUN_t *value)
{
 8012da0:	b500      	push	{lr}
 8012da2:	b083      	sub	sp, #12
 8012da4:	9001      	str	r0, [sp, #4]
 8012da6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012da8:	9801      	ldr	r0, [sp, #4]
 8012daa:	2122      	movs	r1, #34	; 0x22
 8012dac:	9a00      	ldr	r2, [sp, #0]
 8012dae:	2301      	movs	r3, #1
 8012db0:	f7ff f816 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012db4:	4603      	mov	r3, r0
 8012db6:	2b00      	cmp	r3, #0
 8012db8:	d101      	bne.n	8012dbe <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x1e>
    return MEMS_ERROR;
 8012dba:	2300      	movs	r3, #0
 8012dbc:	e007      	b.n	8012dce <LSM303AGR_ACC_R_FIFO_Overrun_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_OVERRUN_MASK; //mask
 8012dbe:	9b00      	ldr	r3, [sp, #0]
 8012dc0:	781b      	ldrb	r3, [r3, #0]
 8012dc2:	f003 0302 	and.w	r3, r3, #2
 8012dc6:	b2da      	uxtb	r2, r3
 8012dc8:	9b00      	ldr	r3, [sp, #0]
 8012dca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012dcc:	2301      	movs	r3, #1
}
 8012dce:	4618      	mov	r0, r3
 8012dd0:	b003      	add	sp, #12
 8012dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012dd6:	bf00      	nop
 8012dd8:	f3af 8000 	nop.w
 8012ddc:	f3af 8000 	nop.w

08012de0 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1>:
* Input          : LSM303AGR_ACC_I1_WTM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t newValue)
{
 8012de0:	b500      	push	{lr}
 8012de2:	b085      	sub	sp, #20
 8012de4:	9001      	str	r0, [sp, #4]
 8012de6:	460b      	mov	r3, r1
 8012de8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012dec:	f10d 030f 	add.w	r3, sp, #15
 8012df0:	9801      	ldr	r0, [sp, #4]
 8012df2:	2122      	movs	r1, #34	; 0x22
 8012df4:	461a      	mov	r2, r3
 8012df6:	2301      	movs	r3, #1
 8012df8:	f7fe fff2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012dfc:	4603      	mov	r3, r0
 8012dfe:	2b00      	cmp	r3, #0
 8012e00:	d101      	bne.n	8012e06 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x26>
    return MEMS_ERROR;
 8012e02:	2300      	movs	r3, #0
 8012e04:	e01c      	b.n	8012e40 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_WTM_MASK;
 8012e06:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012e0a:	f023 0304 	bic.w	r3, r3, #4
 8012e0e:	b2db      	uxtb	r3, r3
 8012e10:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012e14:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012e18:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012e1c:	4313      	orrs	r3, r2
 8012e1e:	b2db      	uxtb	r3, r3
 8012e20:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012e24:	f10d 030f 	add.w	r3, sp, #15
 8012e28:	9801      	ldr	r0, [sp, #4]
 8012e2a:	2122      	movs	r1, #34	; 0x22
 8012e2c:	461a      	mov	r2, r3
 8012e2e:	2301      	movs	r3, #1
 8012e30:	f7fe ffae 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012e34:	4603      	mov	r3, r0
 8012e36:	2b00      	cmp	r3, #0
 8012e38:	d101      	bne.n	8012e3e <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x5e>
    return MEMS_ERROR;
 8012e3a:	2300      	movs	r3, #0
 8012e3c:	e000      	b.n	8012e40 <LSM303AGR_ACC_W_FIFO_Watermark_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012e3e:	2301      	movs	r3, #1
}
 8012e40:	4618      	mov	r0, r3
 8012e42:	b005      	add	sp, #20
 8012e44:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e48:	f3af 8000 	nop.w
 8012e4c:	f3af 8000 	nop.w

08012e50 <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_WTM_t
* Output         : Status of I1_WTM see LSM303AGR_ACC_I1_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Watermark_on_INT1(void *handle, LSM303AGR_ACC_I1_WTM_t *value)
{
 8012e50:	b500      	push	{lr}
 8012e52:	b083      	sub	sp, #12
 8012e54:	9001      	str	r0, [sp, #4]
 8012e56:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012e58:	9801      	ldr	r0, [sp, #4]
 8012e5a:	2122      	movs	r1, #34	; 0x22
 8012e5c:	9a00      	ldr	r2, [sp, #0]
 8012e5e:	2301      	movs	r3, #1
 8012e60:	f7fe ffbe 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012e64:	4603      	mov	r3, r0
 8012e66:	2b00      	cmp	r3, #0
 8012e68:	d101      	bne.n	8012e6e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x1e>
    return MEMS_ERROR;
 8012e6a:	2300      	movs	r3, #0
 8012e6c:	e007      	b.n	8012e7e <LSM303AGR_ACC_R_FIFO_Watermark_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_WTM_MASK; //mask
 8012e6e:	9b00      	ldr	r3, [sp, #0]
 8012e70:	781b      	ldrb	r3, [r3, #0]
 8012e72:	f003 0304 	and.w	r3, r3, #4
 8012e76:	b2da      	uxtb	r2, r3
 8012e78:	9b00      	ldr	r3, [sp, #0]
 8012e7a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012e7c:	2301      	movs	r3, #1
}
 8012e7e:	4618      	mov	r0, r3
 8012e80:	b003      	add	sp, #12
 8012e82:	f85d fb04 	ldr.w	pc, [sp], #4
 8012e86:	bf00      	nop
 8012e88:	f3af 8000 	nop.w
 8012e8c:	f3af 8000 	nop.w

08012e90 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t newValue)
{
 8012e90:	b500      	push	{lr}
 8012e92:	b085      	sub	sp, #20
 8012e94:	9001      	str	r0, [sp, #4]
 8012e96:	460b      	mov	r3, r1
 8012e98:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012e9c:	f10d 030f 	add.w	r3, sp, #15
 8012ea0:	9801      	ldr	r0, [sp, #4]
 8012ea2:	2122      	movs	r1, #34	; 0x22
 8012ea4:	461a      	mov	r2, r3
 8012ea6:	2301      	movs	r3, #1
 8012ea8:	f7fe ff9a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012eac:	4603      	mov	r3, r0
 8012eae:	2b00      	cmp	r3, #0
 8012eb0:	d101      	bne.n	8012eb6 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x26>
    return MEMS_ERROR;
 8012eb2:	2300      	movs	r3, #0
 8012eb4:	e01c      	b.n	8012ef0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY2_MASK;
 8012eb6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012eba:	f023 0308 	bic.w	r3, r3, #8
 8012ebe:	b2db      	uxtb	r3, r3
 8012ec0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012ec4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012ec8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012ecc:	4313      	orrs	r3, r2
 8012ece:	b2db      	uxtb	r3, r3
 8012ed0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012ed4:	f10d 030f 	add.w	r3, sp, #15
 8012ed8:	9801      	ldr	r0, [sp, #4]
 8012eda:	2122      	movs	r1, #34	; 0x22
 8012edc:	461a      	mov	r2, r3
 8012ede:	2301      	movs	r3, #1
 8012ee0:	f7fe ff56 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012ee4:	4603      	mov	r3, r0
 8012ee6:	2b00      	cmp	r3, #0
 8012ee8:	d101      	bne.n	8012eee <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x5e>
    return MEMS_ERROR;
 8012eea:	2300      	movs	r3, #0
 8012eec:	e000      	b.n	8012ef0 <LSM303AGR_ACC_W_FIFO_DRDY2_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012eee:	2301      	movs	r3, #1
}
 8012ef0:	4618      	mov	r0, r3
 8012ef2:	b005      	add	sp, #20
 8012ef4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012ef8:	f3af 8000 	nop.w
 8012efc:	f3af 8000 	nop.w

08012f00 <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY2_t
* Output         : Status of I1_DRDY2 see LSM303AGR_ACC_I1_DRDY2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY2_t *value)
{
 8012f00:	b500      	push	{lr}
 8012f02:	b083      	sub	sp, #12
 8012f04:	9001      	str	r0, [sp, #4]
 8012f06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012f08:	9801      	ldr	r0, [sp, #4]
 8012f0a:	2122      	movs	r1, #34	; 0x22
 8012f0c:	9a00      	ldr	r2, [sp, #0]
 8012f0e:	2301      	movs	r3, #1
 8012f10:	f7fe ff66 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012f14:	4603      	mov	r3, r0
 8012f16:	2b00      	cmp	r3, #0
 8012f18:	d101      	bne.n	8012f1e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x1e>
    return MEMS_ERROR;
 8012f1a:	2300      	movs	r3, #0
 8012f1c:	e007      	b.n	8012f2e <LSM303AGR_ACC_R_FIFO_DRDY2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY2_MASK; //mask
 8012f1e:	9b00      	ldr	r3, [sp, #0]
 8012f20:	781b      	ldrb	r3, [r3, #0]
 8012f22:	f003 0308 	and.w	r3, r3, #8
 8012f26:	b2da      	uxtb	r2, r3
 8012f28:	9b00      	ldr	r3, [sp, #0]
 8012f2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012f2c:	2301      	movs	r3, #1
}
 8012f2e:	4618      	mov	r0, r3
 8012f30:	b003      	add	sp, #12
 8012f32:	f85d fb04 	ldr.w	pc, [sp], #4
 8012f36:	bf00      	nop
 8012f38:	f3af 8000 	nop.w
 8012f3c:	f3af 8000 	nop.w

08012f40 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_DRDY1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t newValue)
{
 8012f40:	b500      	push	{lr}
 8012f42:	b085      	sub	sp, #20
 8012f44:	9001      	str	r0, [sp, #4]
 8012f46:	460b      	mov	r3, r1
 8012f48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012f4c:	f10d 030f 	add.w	r3, sp, #15
 8012f50:	9801      	ldr	r0, [sp, #4]
 8012f52:	2122      	movs	r1, #34	; 0x22
 8012f54:	461a      	mov	r2, r3
 8012f56:	2301      	movs	r3, #1
 8012f58:	f7fe ff42 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012f5c:	4603      	mov	r3, r0
 8012f5e:	2b00      	cmp	r3, #0
 8012f60:	d101      	bne.n	8012f66 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x26>
    return MEMS_ERROR;
 8012f62:	2300      	movs	r3, #0
 8012f64:	e01c      	b.n	8012fa0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_DRDY1_MASK;
 8012f66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8012f6a:	f023 0310 	bic.w	r3, r3, #16
 8012f6e:	b2db      	uxtb	r3, r3
 8012f70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8012f74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8012f78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8012f7c:	4313      	orrs	r3, r2
 8012f7e:	b2db      	uxtb	r3, r3
 8012f80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012f84:	f10d 030f 	add.w	r3, sp, #15
 8012f88:	9801      	ldr	r0, [sp, #4]
 8012f8a:	2122      	movs	r1, #34	; 0x22
 8012f8c:	461a      	mov	r2, r3
 8012f8e:	2301      	movs	r3, #1
 8012f90:	f7fe fefe 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8012f94:	4603      	mov	r3, r0
 8012f96:	2b00      	cmp	r3, #0
 8012f98:	d101      	bne.n	8012f9e <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x5e>
    return MEMS_ERROR;
 8012f9a:	2300      	movs	r3, #0
 8012f9c:	e000      	b.n	8012fa0 <LSM303AGR_ACC_W_FIFO_DRDY1_on_INT1+0x60>

  return MEMS_SUCCESS;
 8012f9e:	2301      	movs	r3, #1
}
 8012fa0:	4618      	mov	r0, r3
 8012fa2:	b005      	add	sp, #20
 8012fa4:	f85d fb04 	ldr.w	pc, [sp], #4
 8012fa8:	f3af 8000 	nop.w
 8012fac:	f3af 8000 	nop.w

08012fb0 <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_DRDY1_t
* Output         : Status of I1_DRDY1 see LSM303AGR_ACC_I1_DRDY1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1(void *handle, LSM303AGR_ACC_I1_DRDY1_t *value)
{
 8012fb0:	b500      	push	{lr}
 8012fb2:	b083      	sub	sp, #12
 8012fb4:	9001      	str	r0, [sp, #4]
 8012fb6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8012fb8:	9801      	ldr	r0, [sp, #4]
 8012fba:	2122      	movs	r1, #34	; 0x22
 8012fbc:	9a00      	ldr	r2, [sp, #0]
 8012fbe:	2301      	movs	r3, #1
 8012fc0:	f7fe ff0e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8012fc4:	4603      	mov	r3, r0
 8012fc6:	2b00      	cmp	r3, #0
 8012fc8:	d101      	bne.n	8012fce <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x1e>
    return MEMS_ERROR;
 8012fca:	2300      	movs	r3, #0
 8012fcc:	e007      	b.n	8012fde <LSM303AGR_ACC_R_FIFO_DRDY1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_DRDY1_MASK; //mask
 8012fce:	9b00      	ldr	r3, [sp, #0]
 8012fd0:	781b      	ldrb	r3, [r3, #0]
 8012fd2:	f003 0310 	and.w	r3, r3, #16
 8012fd6:	b2da      	uxtb	r2, r3
 8012fd8:	9b00      	ldr	r3, [sp, #0]
 8012fda:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8012fdc:	2301      	movs	r3, #1
}
 8012fde:	4618      	mov	r0, r3
 8012fe0:	b003      	add	sp, #12
 8012fe2:	f85d fb04 	ldr.w	pc, [sp], #4
 8012fe6:	bf00      	nop
 8012fe8:	f3af 8000 	nop.w
 8012fec:	f3af 8000 	nop.w

08012ff0 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t newValue)
{
 8012ff0:	b500      	push	{lr}
 8012ff2:	b085      	sub	sp, #20
 8012ff4:	9001      	str	r0, [sp, #4]
 8012ff6:	460b      	mov	r3, r1
 8012ff8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8012ffc:	f10d 030f 	add.w	r3, sp, #15
 8013000:	9801      	ldr	r0, [sp, #4]
 8013002:	2122      	movs	r1, #34	; 0x22
 8013004:	461a      	mov	r2, r3
 8013006:	2301      	movs	r3, #1
 8013008:	f7fe feea 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801300c:	4603      	mov	r3, r0
 801300e:	2b00      	cmp	r3, #0
 8013010:	d101      	bne.n	8013016 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x26>
    return MEMS_ERROR;
 8013012:	2300      	movs	r3, #0
 8013014:	e01c      	b.n	8013050 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI2_MASK;
 8013016:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801301a:	f023 0320 	bic.w	r3, r3, #32
 801301e:	b2db      	uxtb	r3, r3
 8013020:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013024:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013028:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801302c:	4313      	orrs	r3, r2
 801302e:	b2db      	uxtb	r3, r3
 8013030:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013034:	f10d 030f 	add.w	r3, sp, #15
 8013038:	9801      	ldr	r0, [sp, #4]
 801303a:	2122      	movs	r1, #34	; 0x22
 801303c:	461a      	mov	r2, r3
 801303e:	2301      	movs	r3, #1
 8013040:	f7fe fea6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013044:	4603      	mov	r3, r0
 8013046:	2b00      	cmp	r3, #0
 8013048:	d101      	bne.n	801304e <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x5e>
    return MEMS_ERROR;
 801304a:	2300      	movs	r3, #0
 801304c:	e000      	b.n	8013050 <LSM303AGR_ACC_W_FIFO_AOL2_on_INT1+0x60>

  return MEMS_SUCCESS;
 801304e:	2301      	movs	r3, #1
}
 8013050:	4618      	mov	r0, r3
 8013052:	b005      	add	sp, #20
 8013054:	f85d fb04 	ldr.w	pc, [sp], #4
 8013058:	f3af 8000 	nop.w
 801305c:	f3af 8000 	nop.w

08013060 <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI2_t
* Output         : Status of I1_AOI2 see LSM303AGR_ACC_I1_AOI2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL2_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI2_t *value)
{
 8013060:	b500      	push	{lr}
 8013062:	b083      	sub	sp, #12
 8013064:	9001      	str	r0, [sp, #4]
 8013066:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013068:	9801      	ldr	r0, [sp, #4]
 801306a:	2122      	movs	r1, #34	; 0x22
 801306c:	9a00      	ldr	r2, [sp, #0]
 801306e:	2301      	movs	r3, #1
 8013070:	f7fe feb6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013074:	4603      	mov	r3, r0
 8013076:	2b00      	cmp	r3, #0
 8013078:	d101      	bne.n	801307e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x1e>
    return MEMS_ERROR;
 801307a:	2300      	movs	r3, #0
 801307c:	e007      	b.n	801308e <LSM303AGR_ACC_R_FIFO_AOL2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI2_MASK; //mask
 801307e:	9b00      	ldr	r3, [sp, #0]
 8013080:	781b      	ldrb	r3, [r3, #0]
 8013082:	f003 0320 	and.w	r3, r3, #32
 8013086:	b2da      	uxtb	r2, r3
 8013088:	9b00      	ldr	r3, [sp, #0]
 801308a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801308c:	2301      	movs	r3, #1
}
 801308e:	4618      	mov	r0, r3
 8013090:	b003      	add	sp, #12
 8013092:	f85d fb04 	ldr.w	pc, [sp], #4
 8013096:	bf00      	nop
 8013098:	f3af 8000 	nop.w
 801309c:	f3af 8000 	nop.w

080130a0 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1>:
* Input          : LSM303AGR_ACC_I1_AOI1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t newValue)
{
 80130a0:	b500      	push	{lr}
 80130a2:	b085      	sub	sp, #20
 80130a4:	9001      	str	r0, [sp, #4]
 80130a6:	460b      	mov	r3, r1
 80130a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80130ac:	f10d 030f 	add.w	r3, sp, #15
 80130b0:	9801      	ldr	r0, [sp, #4]
 80130b2:	2122      	movs	r1, #34	; 0x22
 80130b4:	461a      	mov	r2, r3
 80130b6:	2301      	movs	r3, #1
 80130b8:	f7fe fe92 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80130bc:	4603      	mov	r3, r0
 80130be:	2b00      	cmp	r3, #0
 80130c0:	d101      	bne.n	80130c6 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x26>
    return MEMS_ERROR;
 80130c2:	2300      	movs	r3, #0
 80130c4:	e01c      	b.n	8013100 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_AOI1_MASK;
 80130c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80130ca:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80130ce:	b2db      	uxtb	r3, r3
 80130d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80130d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80130d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80130dc:	4313      	orrs	r3, r2
 80130de:	b2db      	uxtb	r3, r3
 80130e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 80130e4:	f10d 030f 	add.w	r3, sp, #15
 80130e8:	9801      	ldr	r0, [sp, #4]
 80130ea:	2122      	movs	r1, #34	; 0x22
 80130ec:	461a      	mov	r2, r3
 80130ee:	2301      	movs	r3, #1
 80130f0:	f7fe fe4e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80130f4:	4603      	mov	r3, r0
 80130f6:	2b00      	cmp	r3, #0
 80130f8:	d101      	bne.n	80130fe <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x5e>
    return MEMS_ERROR;
 80130fa:	2300      	movs	r3, #0
 80130fc:	e000      	b.n	8013100 <LSM303AGR_ACC_W_FIFO_AOL1_on_INT1+0x60>

  return MEMS_SUCCESS;
 80130fe:	2301      	movs	r3, #1
}
 8013100:	4618      	mov	r0, r3
 8013102:	b005      	add	sp, #20
 8013104:	f85d fb04 	ldr.w	pc, [sp], #4
 8013108:	f3af 8000 	nop.w
 801310c:	f3af 8000 	nop.w

08013110 <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_AOI1_t
* Output         : Status of I1_AOI1 see LSM303AGR_ACC_I1_AOI1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_AOL1_on_INT1(void *handle, LSM303AGR_ACC_I1_AOI1_t *value)
{
 8013110:	b500      	push	{lr}
 8013112:	b083      	sub	sp, #12
 8013114:	9001      	str	r0, [sp, #4]
 8013116:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 8013118:	9801      	ldr	r0, [sp, #4]
 801311a:	2122      	movs	r1, #34	; 0x22
 801311c:	9a00      	ldr	r2, [sp, #0]
 801311e:	2301      	movs	r3, #1
 8013120:	f7fe fe5e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013124:	4603      	mov	r3, r0
 8013126:	2b00      	cmp	r3, #0
 8013128:	d101      	bne.n	801312e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x1e>
    return MEMS_ERROR;
 801312a:	2300      	movs	r3, #0
 801312c:	e007      	b.n	801313e <LSM303AGR_ACC_R_FIFO_AOL1_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_AOI1_MASK; //mask
 801312e:	9b00      	ldr	r3, [sp, #0]
 8013130:	781b      	ldrb	r3, [r3, #0]
 8013132:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013136:	b2da      	uxtb	r2, r3
 8013138:	9b00      	ldr	r3, [sp, #0]
 801313a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801313c:	2301      	movs	r3, #1
}
 801313e:	4618      	mov	r0, r3
 8013140:	b003      	add	sp, #12
 8013142:	f85d fb04 	ldr.w	pc, [sp], #4
 8013146:	bf00      	nop
 8013148:	f3af 8000 	nop.w
 801314c:	f3af 8000 	nop.w

08013150 <LSM303AGR_ACC_W_FIFO_Click_on_INT1>:
* Input          : LSM303AGR_ACC_I1_CLICK_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t newValue)
{
 8013150:	b500      	push	{lr}
 8013152:	b085      	sub	sp, #20
 8013154:	9001      	str	r0, [sp, #4]
 8013156:	460b      	mov	r3, r1
 8013158:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 801315c:	f10d 030f 	add.w	r3, sp, #15
 8013160:	9801      	ldr	r0, [sp, #4]
 8013162:	2122      	movs	r1, #34	; 0x22
 8013164:	461a      	mov	r2, r3
 8013166:	2301      	movs	r3, #1
 8013168:	f7fe fe3a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801316c:	4603      	mov	r3, r0
 801316e:	2b00      	cmp	r3, #0
 8013170:	d101      	bne.n	8013176 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x26>
    return MEMS_ERROR;
 8013172:	2300      	movs	r3, #0
 8013174:	e01c      	b.n	80131b0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I1_CLICK_MASK;
 8013176:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801317a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801317e:	b2db      	uxtb	r3, r3
 8013180:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013184:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013188:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801318c:	4313      	orrs	r3, r2
 801318e:	b2db      	uxtb	r3, r3
 8013190:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG3, &value, 1) )
 8013194:	f10d 030f 	add.w	r3, sp, #15
 8013198:	9801      	ldr	r0, [sp, #4]
 801319a:	2122      	movs	r1, #34	; 0x22
 801319c:	461a      	mov	r2, r3
 801319e:	2301      	movs	r3, #1
 80131a0:	f7fe fdf6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80131a4:	4603      	mov	r3, r0
 80131a6:	2b00      	cmp	r3, #0
 80131a8:	d101      	bne.n	80131ae <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x5e>
    return MEMS_ERROR;
 80131aa:	2300      	movs	r3, #0
 80131ac:	e000      	b.n	80131b0 <LSM303AGR_ACC_W_FIFO_Click_on_INT1+0x60>

  return MEMS_SUCCESS;
 80131ae:	2301      	movs	r3, #1
}
 80131b0:	4618      	mov	r0, r3
 80131b2:	b005      	add	sp, #20
 80131b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80131b8:	f3af 8000 	nop.w
 80131bc:	f3af 8000 	nop.w

080131c0 <LSM303AGR_ACC_R_FIFO_Click_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I1_CLICK_t
* Output         : Status of I1_CLICK see LSM303AGR_ACC_I1_CLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_Click_on_INT1(void *handle, LSM303AGR_ACC_I1_CLICK_t *value)
{
 80131c0:	b500      	push	{lr}
 80131c2:	b083      	sub	sp, #12
 80131c4:	9001      	str	r0, [sp, #4]
 80131c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG3, (u8_t *)value, 1) )
 80131c8:	9801      	ldr	r0, [sp, #4]
 80131ca:	2122      	movs	r1, #34	; 0x22
 80131cc:	9a00      	ldr	r2, [sp, #0]
 80131ce:	2301      	movs	r3, #1
 80131d0:	f7fe fe06 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80131d4:	4603      	mov	r3, r0
 80131d6:	2b00      	cmp	r3, #0
 80131d8:	d101      	bne.n	80131de <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x1e>
    return MEMS_ERROR;
 80131da:	2300      	movs	r3, #0
 80131dc:	e007      	b.n	80131ee <LSM303AGR_ACC_R_FIFO_Click_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I1_CLICK_MASK; //mask
 80131de:	9b00      	ldr	r3, [sp, #0]
 80131e0:	781b      	ldrb	r3, [r3, #0]
 80131e2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80131e6:	b2da      	uxtb	r2, r3
 80131e8:	9b00      	ldr	r3, [sp, #0]
 80131ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80131ec:	2301      	movs	r3, #1
}
 80131ee:	4618      	mov	r0, r3
 80131f0:	b003      	add	sp, #12
 80131f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80131f6:	bf00      	nop
 80131f8:	f3af 8000 	nop.w
 80131fc:	f3af 8000 	nop.w

08013200 <LSM303AGR_ACC_W_SPI_mode>:
* Input          : LSM303AGR_ACC_SIM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t newValue)
{
 8013200:	b500      	push	{lr}
 8013202:	b085      	sub	sp, #20
 8013204:	9001      	str	r0, [sp, #4]
 8013206:	460b      	mov	r3, r1
 8013208:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801320c:	f10d 030f 	add.w	r3, sp, #15
 8013210:	9801      	ldr	r0, [sp, #4]
 8013212:	2123      	movs	r1, #35	; 0x23
 8013214:	461a      	mov	r2, r3
 8013216:	2301      	movs	r3, #1
 8013218:	f7fe fde2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801321c:	4603      	mov	r3, r0
 801321e:	2b00      	cmp	r3, #0
 8013220:	d101      	bne.n	8013226 <LSM303AGR_ACC_W_SPI_mode+0x26>
    return MEMS_ERROR;
 8013222:	2300      	movs	r3, #0
 8013224:	e01c      	b.n	8013260 <LSM303AGR_ACC_W_SPI_mode+0x60>

  value &= ~LSM303AGR_ACC_SIM_MASK;
 8013226:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801322a:	f023 0301 	bic.w	r3, r3, #1
 801322e:	b2db      	uxtb	r3, r3
 8013230:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013234:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013238:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801323c:	4313      	orrs	r3, r2
 801323e:	b2db      	uxtb	r3, r3
 8013240:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013244:	f10d 030f 	add.w	r3, sp, #15
 8013248:	9801      	ldr	r0, [sp, #4]
 801324a:	2123      	movs	r1, #35	; 0x23
 801324c:	461a      	mov	r2, r3
 801324e:	2301      	movs	r3, #1
 8013250:	f7fe fd9e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013254:	4603      	mov	r3, r0
 8013256:	2b00      	cmp	r3, #0
 8013258:	d101      	bne.n	801325e <LSM303AGR_ACC_W_SPI_mode+0x5e>
    return MEMS_ERROR;
 801325a:	2300      	movs	r3, #0
 801325c:	e000      	b.n	8013260 <LSM303AGR_ACC_W_SPI_mode+0x60>

  return MEMS_SUCCESS;
 801325e:	2301      	movs	r3, #1
}
 8013260:	4618      	mov	r0, r3
 8013262:	b005      	add	sp, #20
 8013264:	f85d fb04 	ldr.w	pc, [sp], #4
 8013268:	f3af 8000 	nop.w
 801326c:	f3af 8000 	nop.w

08013270 <LSM303AGR_ACC_R_SPI_mode>:
* Input          : Pointer to LSM303AGR_ACC_SIM_t
* Output         : Status of SIM see LSM303AGR_ACC_SIM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SPI_mode(void *handle, LSM303AGR_ACC_SIM_t *value)
{
 8013270:	b500      	push	{lr}
 8013272:	b083      	sub	sp, #12
 8013274:	9001      	str	r0, [sp, #4]
 8013276:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013278:	9801      	ldr	r0, [sp, #4]
 801327a:	2123      	movs	r1, #35	; 0x23
 801327c:	9a00      	ldr	r2, [sp, #0]
 801327e:	2301      	movs	r3, #1
 8013280:	f7fe fdae 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013284:	4603      	mov	r3, r0
 8013286:	2b00      	cmp	r3, #0
 8013288:	d101      	bne.n	801328e <LSM303AGR_ACC_R_SPI_mode+0x1e>
    return MEMS_ERROR;
 801328a:	2300      	movs	r3, #0
 801328c:	e007      	b.n	801329e <LSM303AGR_ACC_R_SPI_mode+0x2e>

  *value &= LSM303AGR_ACC_SIM_MASK; //mask
 801328e:	9b00      	ldr	r3, [sp, #0]
 8013290:	781b      	ldrb	r3, [r3, #0]
 8013292:	f003 0301 	and.w	r3, r3, #1
 8013296:	b2da      	uxtb	r2, r3
 8013298:	9b00      	ldr	r3, [sp, #0]
 801329a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801329c:	2301      	movs	r3, #1
}
 801329e:	4618      	mov	r0, r3
 80132a0:	b003      	add	sp, #12
 80132a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80132a6:	bf00      	nop
 80132a8:	f3af 8000 	nop.w
 80132ac:	f3af 8000 	nop.w

080132b0 <LSM303AGR_ACC_W_SelfTest>:
* Input          : LSM303AGR_ACC_ST_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_SelfTest(void *handle, LSM303AGR_ACC_ST_t newValue)
{
 80132b0:	b500      	push	{lr}
 80132b2:	b085      	sub	sp, #20
 80132b4:	9001      	str	r0, [sp, #4]
 80132b6:	460b      	mov	r3, r1
 80132b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80132bc:	f10d 030f 	add.w	r3, sp, #15
 80132c0:	9801      	ldr	r0, [sp, #4]
 80132c2:	2123      	movs	r1, #35	; 0x23
 80132c4:	461a      	mov	r2, r3
 80132c6:	2301      	movs	r3, #1
 80132c8:	f7fe fd8a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80132cc:	4603      	mov	r3, r0
 80132ce:	2b00      	cmp	r3, #0
 80132d0:	d101      	bne.n	80132d6 <LSM303AGR_ACC_W_SelfTest+0x26>
    return MEMS_ERROR;
 80132d2:	2300      	movs	r3, #0
 80132d4:	e01c      	b.n	8013310 <LSM303AGR_ACC_W_SelfTest+0x60>

  value &= ~LSM303AGR_ACC_ST_MASK;
 80132d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80132da:	f023 0306 	bic.w	r3, r3, #6
 80132de:	b2db      	uxtb	r3, r3
 80132e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80132e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80132e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80132ec:	4313      	orrs	r3, r2
 80132ee:	b2db      	uxtb	r3, r3
 80132f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80132f4:	f10d 030f 	add.w	r3, sp, #15
 80132f8:	9801      	ldr	r0, [sp, #4]
 80132fa:	2123      	movs	r1, #35	; 0x23
 80132fc:	461a      	mov	r2, r3
 80132fe:	2301      	movs	r3, #1
 8013300:	f7fe fd46 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013304:	4603      	mov	r3, r0
 8013306:	2b00      	cmp	r3, #0
 8013308:	d101      	bne.n	801330e <LSM303AGR_ACC_W_SelfTest+0x5e>
    return MEMS_ERROR;
 801330a:	2300      	movs	r3, #0
 801330c:	e000      	b.n	8013310 <LSM303AGR_ACC_W_SelfTest+0x60>

  return MEMS_SUCCESS;
 801330e:	2301      	movs	r3, #1
}
 8013310:	4618      	mov	r0, r3
 8013312:	b005      	add	sp, #20
 8013314:	f85d fb04 	ldr.w	pc, [sp], #4
 8013318:	f3af 8000 	nop.w
 801331c:	f3af 8000 	nop.w

08013320 <LSM303AGR_ACC_R_SelfTest>:
* Input          : Pointer to LSM303AGR_ACC_ST_t
* Output         : Status of ST see LSM303AGR_ACC_ST_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SelfTest(void *handle, LSM303AGR_ACC_ST_t *value)
{
 8013320:	b500      	push	{lr}
 8013322:	b083      	sub	sp, #12
 8013324:	9001      	str	r0, [sp, #4]
 8013326:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013328:	9801      	ldr	r0, [sp, #4]
 801332a:	2123      	movs	r1, #35	; 0x23
 801332c:	9a00      	ldr	r2, [sp, #0]
 801332e:	2301      	movs	r3, #1
 8013330:	f7fe fd56 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013334:	4603      	mov	r3, r0
 8013336:	2b00      	cmp	r3, #0
 8013338:	d101      	bne.n	801333e <LSM303AGR_ACC_R_SelfTest+0x1e>
    return MEMS_ERROR;
 801333a:	2300      	movs	r3, #0
 801333c:	e007      	b.n	801334e <LSM303AGR_ACC_R_SelfTest+0x2e>

  *value &= LSM303AGR_ACC_ST_MASK; //mask
 801333e:	9b00      	ldr	r3, [sp, #0]
 8013340:	781b      	ldrb	r3, [r3, #0]
 8013342:	f003 0306 	and.w	r3, r3, #6
 8013346:	b2da      	uxtb	r2, r3
 8013348:	9b00      	ldr	r3, [sp, #0]
 801334a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801334c:	2301      	movs	r3, #1
}
 801334e:	4618      	mov	r0, r3
 8013350:	b003      	add	sp, #12
 8013352:	f85d fb04 	ldr.w	pc, [sp], #4
 8013356:	bf00      	nop
 8013358:	f3af 8000 	nop.w
 801335c:	f3af 8000 	nop.w

08013360 <LSM303AGR_ACC_W_HiRes>:
* Input          : LSM303AGR_ACC_HR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_HiRes(void *handle, LSM303AGR_ACC_HR_t newValue)
{
 8013360:	b500      	push	{lr}
 8013362:	b085      	sub	sp, #20
 8013364:	9001      	str	r0, [sp, #4]
 8013366:	460b      	mov	r3, r1
 8013368:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801336c:	f10d 030f 	add.w	r3, sp, #15
 8013370:	9801      	ldr	r0, [sp, #4]
 8013372:	2123      	movs	r1, #35	; 0x23
 8013374:	461a      	mov	r2, r3
 8013376:	2301      	movs	r3, #1
 8013378:	f7fe fd32 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801337c:	4603      	mov	r3, r0
 801337e:	2b00      	cmp	r3, #0
 8013380:	d101      	bne.n	8013386 <LSM303AGR_ACC_W_HiRes+0x26>
    return MEMS_ERROR;
 8013382:	2300      	movs	r3, #0
 8013384:	e01c      	b.n	80133c0 <LSM303AGR_ACC_W_HiRes+0x60>

  value &= ~LSM303AGR_ACC_HR_MASK;
 8013386:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801338a:	f023 0308 	bic.w	r3, r3, #8
 801338e:	b2db      	uxtb	r3, r3
 8013390:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013394:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013398:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801339c:	4313      	orrs	r3, r2
 801339e:	b2db      	uxtb	r3, r3
 80133a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 80133a4:	f10d 030f 	add.w	r3, sp, #15
 80133a8:	9801      	ldr	r0, [sp, #4]
 80133aa:	2123      	movs	r1, #35	; 0x23
 80133ac:	461a      	mov	r2, r3
 80133ae:	2301      	movs	r3, #1
 80133b0:	f7fe fcee 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80133b4:	4603      	mov	r3, r0
 80133b6:	2b00      	cmp	r3, #0
 80133b8:	d101      	bne.n	80133be <LSM303AGR_ACC_W_HiRes+0x5e>
    return MEMS_ERROR;
 80133ba:	2300      	movs	r3, #0
 80133bc:	e000      	b.n	80133c0 <LSM303AGR_ACC_W_HiRes+0x60>

  return MEMS_SUCCESS;
 80133be:	2301      	movs	r3, #1
}
 80133c0:	4618      	mov	r0, r3
 80133c2:	b005      	add	sp, #20
 80133c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80133c8:	f3af 8000 	nop.w
 80133cc:	f3af 8000 	nop.w

080133d0 <LSM303AGR_ACC_R_HiRes>:
* Input          : Pointer to LSM303AGR_ACC_HR_t
* Output         : Status of HR see LSM303AGR_ACC_HR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_HiRes(void *handle, LSM303AGR_ACC_HR_t *value)
{
 80133d0:	b500      	push	{lr}
 80133d2:	b083      	sub	sp, #12
 80133d4:	9001      	str	r0, [sp, #4]
 80133d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 80133d8:	9801      	ldr	r0, [sp, #4]
 80133da:	2123      	movs	r1, #35	; 0x23
 80133dc:	9a00      	ldr	r2, [sp, #0]
 80133de:	2301      	movs	r3, #1
 80133e0:	f7fe fcfe 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80133e4:	4603      	mov	r3, r0
 80133e6:	2b00      	cmp	r3, #0
 80133e8:	d101      	bne.n	80133ee <LSM303AGR_ACC_R_HiRes+0x1e>
    return MEMS_ERROR;
 80133ea:	2300      	movs	r3, #0
 80133ec:	e007      	b.n	80133fe <LSM303AGR_ACC_R_HiRes+0x2e>

  *value &= LSM303AGR_ACC_HR_MASK; //mask
 80133ee:	9b00      	ldr	r3, [sp, #0]
 80133f0:	781b      	ldrb	r3, [r3, #0]
 80133f2:	f003 0308 	and.w	r3, r3, #8
 80133f6:	b2da      	uxtb	r2, r3
 80133f8:	9b00      	ldr	r3, [sp, #0]
 80133fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80133fc:	2301      	movs	r3, #1
}
 80133fe:	4618      	mov	r0, r3
 8013400:	b003      	add	sp, #12
 8013402:	f85d fb04 	ldr.w	pc, [sp], #4
 8013406:	bf00      	nop
 8013408:	f3af 8000 	nop.w
 801340c:	f3af 8000 	nop.w

08013410 <LSM303AGR_ACC_W_LittleBigEndian>:
* Input          : LSM303AGR_ACC_BLE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t newValue)
{
 8013410:	b500      	push	{lr}
 8013412:	b085      	sub	sp, #20
 8013414:	9001      	str	r0, [sp, #4]
 8013416:	460b      	mov	r3, r1
 8013418:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 801341c:	f10d 030f 	add.w	r3, sp, #15
 8013420:	9801      	ldr	r0, [sp, #4]
 8013422:	2123      	movs	r1, #35	; 0x23
 8013424:	461a      	mov	r2, r3
 8013426:	2301      	movs	r3, #1
 8013428:	f7fe fcda 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801342c:	4603      	mov	r3, r0
 801342e:	2b00      	cmp	r3, #0
 8013430:	d101      	bne.n	8013436 <LSM303AGR_ACC_W_LittleBigEndian+0x26>
    return MEMS_ERROR;
 8013432:	2300      	movs	r3, #0
 8013434:	e01c      	b.n	8013470 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  value &= ~LSM303AGR_ACC_BLE_MASK;
 8013436:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801343a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801343e:	b2db      	uxtb	r3, r3
 8013440:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013444:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013448:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801344c:	4313      	orrs	r3, r2
 801344e:	b2db      	uxtb	r3, r3
 8013450:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG4, &value, 1) )
 8013454:	f10d 030f 	add.w	r3, sp, #15
 8013458:	9801      	ldr	r0, [sp, #4]
 801345a:	2123      	movs	r1, #35	; 0x23
 801345c:	461a      	mov	r2, r3
 801345e:	2301      	movs	r3, #1
 8013460:	f7fe fc96 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013464:	4603      	mov	r3, r0
 8013466:	2b00      	cmp	r3, #0
 8013468:	d101      	bne.n	801346e <LSM303AGR_ACC_W_LittleBigEndian+0x5e>
    return MEMS_ERROR;
 801346a:	2300      	movs	r3, #0
 801346c:	e000      	b.n	8013470 <LSM303AGR_ACC_W_LittleBigEndian+0x60>

  return MEMS_SUCCESS;
 801346e:	2301      	movs	r3, #1
}
 8013470:	4618      	mov	r0, r3
 8013472:	b005      	add	sp, #20
 8013474:	f85d fb04 	ldr.w	pc, [sp], #4
 8013478:	f3af 8000 	nop.w
 801347c:	f3af 8000 	nop.w

08013480 <LSM303AGR_ACC_R_LittleBigEndian>:
* Input          : Pointer to LSM303AGR_ACC_BLE_t
* Output         : Status of BLE see LSM303AGR_ACC_BLE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LittleBigEndian(void *handle, LSM303AGR_ACC_BLE_t *value)
{
 8013480:	b500      	push	{lr}
 8013482:	b083      	sub	sp, #12
 8013484:	9001      	str	r0, [sp, #4]
 8013486:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG4, (u8_t *)value, 1) )
 8013488:	9801      	ldr	r0, [sp, #4]
 801348a:	2123      	movs	r1, #35	; 0x23
 801348c:	9a00      	ldr	r2, [sp, #0]
 801348e:	2301      	movs	r3, #1
 8013490:	f7fe fca6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013494:	4603      	mov	r3, r0
 8013496:	2b00      	cmp	r3, #0
 8013498:	d101      	bne.n	801349e <LSM303AGR_ACC_R_LittleBigEndian+0x1e>
    return MEMS_ERROR;
 801349a:	2300      	movs	r3, #0
 801349c:	e007      	b.n	80134ae <LSM303AGR_ACC_R_LittleBigEndian+0x2e>

  *value &= LSM303AGR_ACC_BLE_MASK; //mask
 801349e:	9b00      	ldr	r3, [sp, #0]
 80134a0:	781b      	ldrb	r3, [r3, #0]
 80134a2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 80134a6:	b2da      	uxtb	r2, r3
 80134a8:	9b00      	ldr	r3, [sp, #0]
 80134aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80134ac:	2301      	movs	r3, #1
}
 80134ae:	4618      	mov	r0, r3
 80134b0:	b003      	add	sp, #12
 80134b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80134b6:	bf00      	nop
 80134b8:	f3af 8000 	nop.w
 80134bc:	f3af 8000 	nop.w

080134c0 <LSM303AGR_ACC_W_4D_on_INT2>:
* Input          : LSM303AGR_ACC_D4D_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t newValue)
{
 80134c0:	b500      	push	{lr}
 80134c2:	b085      	sub	sp, #20
 80134c4:	9001      	str	r0, [sp, #4]
 80134c6:	460b      	mov	r3, r1
 80134c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80134cc:	f10d 030f 	add.w	r3, sp, #15
 80134d0:	9801      	ldr	r0, [sp, #4]
 80134d2:	2124      	movs	r1, #36	; 0x24
 80134d4:	461a      	mov	r2, r3
 80134d6:	2301      	movs	r3, #1
 80134d8:	f7fe fc82 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80134dc:	4603      	mov	r3, r0
 80134de:	2b00      	cmp	r3, #0
 80134e0:	d101      	bne.n	80134e6 <LSM303AGR_ACC_W_4D_on_INT2+0x26>
    return MEMS_ERROR;
 80134e2:	2300      	movs	r3, #0
 80134e4:	e01c      	b.n	8013520 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT2_MASK;
 80134e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80134ea:	f023 0301 	bic.w	r3, r3, #1
 80134ee:	b2db      	uxtb	r3, r3
 80134f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80134f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80134f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80134fc:	4313      	orrs	r3, r2
 80134fe:	b2db      	uxtb	r3, r3
 8013500:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013504:	f10d 030f 	add.w	r3, sp, #15
 8013508:	9801      	ldr	r0, [sp, #4]
 801350a:	2124      	movs	r1, #36	; 0x24
 801350c:	461a      	mov	r2, r3
 801350e:	2301      	movs	r3, #1
 8013510:	f7fe fc3e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013514:	4603      	mov	r3, r0
 8013516:	2b00      	cmp	r3, #0
 8013518:	d101      	bne.n	801351e <LSM303AGR_ACC_W_4D_on_INT2+0x5e>
    return MEMS_ERROR;
 801351a:	2300      	movs	r3, #0
 801351c:	e000      	b.n	8013520 <LSM303AGR_ACC_W_4D_on_INT2+0x60>

  return MEMS_SUCCESS;
 801351e:	2301      	movs	r3, #1
}
 8013520:	4618      	mov	r0, r3
 8013522:	b005      	add	sp, #20
 8013524:	f85d fb04 	ldr.w	pc, [sp], #4
 8013528:	f3af 8000 	nop.w
 801352c:	f3af 8000 	nop.w

08013530 <LSM303AGR_ACC_R_4D_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT2_t
* Output         : Status of D4D_INT2 see LSM303AGR_ACC_D4D_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT2(void *handle, LSM303AGR_ACC_D4D_INT2_t *value)
{
 8013530:	b500      	push	{lr}
 8013532:	b083      	sub	sp, #12
 8013534:	9001      	str	r0, [sp, #4]
 8013536:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013538:	9801      	ldr	r0, [sp, #4]
 801353a:	2124      	movs	r1, #36	; 0x24
 801353c:	9a00      	ldr	r2, [sp, #0]
 801353e:	2301      	movs	r3, #1
 8013540:	f7fe fc4e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013544:	4603      	mov	r3, r0
 8013546:	2b00      	cmp	r3, #0
 8013548:	d101      	bne.n	801354e <LSM303AGR_ACC_R_4D_on_INT2+0x1e>
    return MEMS_ERROR;
 801354a:	2300      	movs	r3, #0
 801354c:	e007      	b.n	801355e <LSM303AGR_ACC_R_4D_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT2_MASK; //mask
 801354e:	9b00      	ldr	r3, [sp, #0]
 8013550:	781b      	ldrb	r3, [r3, #0]
 8013552:	f003 0301 	and.w	r3, r3, #1
 8013556:	b2da      	uxtb	r2, r3
 8013558:	9b00      	ldr	r3, [sp, #0]
 801355a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801355c:	2301      	movs	r3, #1
}
 801355e:	4618      	mov	r0, r3
 8013560:	b003      	add	sp, #12
 8013562:	f85d fb04 	ldr.w	pc, [sp], #4
 8013566:	bf00      	nop
 8013568:	f3af 8000 	nop.w
 801356c:	f3af 8000 	nop.w

08013570 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2>:
* Input          : LSM303AGR_ACC_LIR_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t newValue)
{
 8013570:	b500      	push	{lr}
 8013572:	b085      	sub	sp, #20
 8013574:	9001      	str	r0, [sp, #4]
 8013576:	460b      	mov	r3, r1
 8013578:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801357c:	f10d 030f 	add.w	r3, sp, #15
 8013580:	9801      	ldr	r0, [sp, #4]
 8013582:	2124      	movs	r1, #36	; 0x24
 8013584:	461a      	mov	r2, r3
 8013586:	2301      	movs	r3, #1
 8013588:	f7fe fc2a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801358c:	4603      	mov	r3, r0
 801358e:	2b00      	cmp	r3, #0
 8013590:	d101      	bne.n	8013596 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x26>
    return MEMS_ERROR;
 8013592:	2300      	movs	r3, #0
 8013594:	e01c      	b.n	80135d0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT2_MASK;
 8013596:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801359a:	f023 0302 	bic.w	r3, r3, #2
 801359e:	b2db      	uxtb	r3, r3
 80135a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80135a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80135a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80135ac:	4313      	orrs	r3, r2
 80135ae:	b2db      	uxtb	r3, r3
 80135b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80135b4:	f10d 030f 	add.w	r3, sp, #15
 80135b8:	9801      	ldr	r0, [sp, #4]
 80135ba:	2124      	movs	r1, #36	; 0x24
 80135bc:	461a      	mov	r2, r3
 80135be:	2301      	movs	r3, #1
 80135c0:	f7fe fbe6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80135c4:	4603      	mov	r3, r0
 80135c6:	2b00      	cmp	r3, #0
 80135c8:	d101      	bne.n	80135ce <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x5e>
    return MEMS_ERROR;
 80135ca:	2300      	movs	r3, #0
 80135cc:	e000      	b.n	80135d0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT2+0x60>

  return MEMS_SUCCESS;
 80135ce:	2301      	movs	r3, #1
}
 80135d0:	4618      	mov	r0, r3
 80135d2:	b005      	add	sp, #20
 80135d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80135d8:	f3af 8000 	nop.w
 80135dc:	f3af 8000 	nop.w

080135e0 <LSM303AGR_ACC_R_LatchInterrupt_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT2_t
* Output         : Status of LIR_INT2 see LSM303AGR_ACC_LIR_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT2(void *handle, LSM303AGR_ACC_LIR_INT2_t *value)
{
 80135e0:	b500      	push	{lr}
 80135e2:	b083      	sub	sp, #12
 80135e4:	9001      	str	r0, [sp, #4]
 80135e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 80135e8:	9801      	ldr	r0, [sp, #4]
 80135ea:	2124      	movs	r1, #36	; 0x24
 80135ec:	9a00      	ldr	r2, [sp, #0]
 80135ee:	2301      	movs	r3, #1
 80135f0:	f7fe fbf6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80135f4:	4603      	mov	r3, r0
 80135f6:	2b00      	cmp	r3, #0
 80135f8:	d101      	bne.n	80135fe <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x1e>
    return MEMS_ERROR;
 80135fa:	2300      	movs	r3, #0
 80135fc:	e007      	b.n	801360e <LSM303AGR_ACC_R_LatchInterrupt_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT2_MASK; //mask
 80135fe:	9b00      	ldr	r3, [sp, #0]
 8013600:	781b      	ldrb	r3, [r3, #0]
 8013602:	f003 0302 	and.w	r3, r3, #2
 8013606:	b2da      	uxtb	r2, r3
 8013608:	9b00      	ldr	r3, [sp, #0]
 801360a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801360c:	2301      	movs	r3, #1
}
 801360e:	4618      	mov	r0, r3
 8013610:	b003      	add	sp, #12
 8013612:	f85d fb04 	ldr.w	pc, [sp], #4
 8013616:	bf00      	nop
 8013618:	f3af 8000 	nop.w
 801361c:	f3af 8000 	nop.w

08013620 <LSM303AGR_ACC_W_4D_on_INT1>:
* Input          : LSM303AGR_ACC_D4D_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t newValue)
{
 8013620:	b500      	push	{lr}
 8013622:	b085      	sub	sp, #20
 8013624:	9001      	str	r0, [sp, #4]
 8013626:	460b      	mov	r3, r1
 8013628:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801362c:	f10d 030f 	add.w	r3, sp, #15
 8013630:	9801      	ldr	r0, [sp, #4]
 8013632:	2124      	movs	r1, #36	; 0x24
 8013634:	461a      	mov	r2, r3
 8013636:	2301      	movs	r3, #1
 8013638:	f7fe fbd2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801363c:	4603      	mov	r3, r0
 801363e:	2b00      	cmp	r3, #0
 8013640:	d101      	bne.n	8013646 <LSM303AGR_ACC_W_4D_on_INT1+0x26>
    return MEMS_ERROR;
 8013642:	2300      	movs	r3, #0
 8013644:	e01c      	b.n	8013680 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_D4D_INT1_MASK;
 8013646:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801364a:	f023 0304 	bic.w	r3, r3, #4
 801364e:	b2db      	uxtb	r3, r3
 8013650:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013654:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013658:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801365c:	4313      	orrs	r3, r2
 801365e:	b2db      	uxtb	r3, r3
 8013660:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013664:	f10d 030f 	add.w	r3, sp, #15
 8013668:	9801      	ldr	r0, [sp, #4]
 801366a:	2124      	movs	r1, #36	; 0x24
 801366c:	461a      	mov	r2, r3
 801366e:	2301      	movs	r3, #1
 8013670:	f7fe fb8e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013674:	4603      	mov	r3, r0
 8013676:	2b00      	cmp	r3, #0
 8013678:	d101      	bne.n	801367e <LSM303AGR_ACC_W_4D_on_INT1+0x5e>
    return MEMS_ERROR;
 801367a:	2300      	movs	r3, #0
 801367c:	e000      	b.n	8013680 <LSM303AGR_ACC_W_4D_on_INT1+0x60>

  return MEMS_SUCCESS;
 801367e:	2301      	movs	r3, #1
}
 8013680:	4618      	mov	r0, r3
 8013682:	b005      	add	sp, #20
 8013684:	f85d fb04 	ldr.w	pc, [sp], #4
 8013688:	f3af 8000 	nop.w
 801368c:	f3af 8000 	nop.w

08013690 <LSM303AGR_ACC_R_4D_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_D4D_INT1_t
* Output         : Status of D4D_INT1 see LSM303AGR_ACC_D4D_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_4D_on_INT1(void *handle, LSM303AGR_ACC_D4D_INT1_t *value)
{
 8013690:	b500      	push	{lr}
 8013692:	b083      	sub	sp, #12
 8013694:	9001      	str	r0, [sp, #4]
 8013696:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013698:	9801      	ldr	r0, [sp, #4]
 801369a:	2124      	movs	r1, #36	; 0x24
 801369c:	9a00      	ldr	r2, [sp, #0]
 801369e:	2301      	movs	r3, #1
 80136a0:	f7fe fb9e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80136a4:	4603      	mov	r3, r0
 80136a6:	2b00      	cmp	r3, #0
 80136a8:	d101      	bne.n	80136ae <LSM303AGR_ACC_R_4D_on_INT1+0x1e>
    return MEMS_ERROR;
 80136aa:	2300      	movs	r3, #0
 80136ac:	e007      	b.n	80136be <LSM303AGR_ACC_R_4D_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_D4D_INT1_MASK; //mask
 80136ae:	9b00      	ldr	r3, [sp, #0]
 80136b0:	781b      	ldrb	r3, [r3, #0]
 80136b2:	f003 0304 	and.w	r3, r3, #4
 80136b6:	b2da      	uxtb	r2, r3
 80136b8:	9b00      	ldr	r3, [sp, #0]
 80136ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80136bc:	2301      	movs	r3, #1
}
 80136be:	4618      	mov	r0, r3
 80136c0:	b003      	add	sp, #12
 80136c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80136c6:	bf00      	nop
 80136c8:	f3af 8000 	nop.w
 80136cc:	f3af 8000 	nop.w

080136d0 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1>:
* Input          : LSM303AGR_ACC_LIR_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t newValue)
{
 80136d0:	b500      	push	{lr}
 80136d2:	b085      	sub	sp, #20
 80136d4:	9001      	str	r0, [sp, #4]
 80136d6:	460b      	mov	r3, r1
 80136d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80136dc:	f10d 030f 	add.w	r3, sp, #15
 80136e0:	9801      	ldr	r0, [sp, #4]
 80136e2:	2124      	movs	r1, #36	; 0x24
 80136e4:	461a      	mov	r2, r3
 80136e6:	2301      	movs	r3, #1
 80136e8:	f7fe fb7a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80136ec:	4603      	mov	r3, r0
 80136ee:	2b00      	cmp	r3, #0
 80136f0:	d101      	bne.n	80136f6 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x26>
    return MEMS_ERROR;
 80136f2:	2300      	movs	r3, #0
 80136f4:	e01c      	b.n	8013730 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_LIR_INT1_MASK;
 80136f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80136fa:	f023 0308 	bic.w	r3, r3, #8
 80136fe:	b2db      	uxtb	r3, r3
 8013700:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013704:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013708:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801370c:	4313      	orrs	r3, r2
 801370e:	b2db      	uxtb	r3, r3
 8013710:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013714:	f10d 030f 	add.w	r3, sp, #15
 8013718:	9801      	ldr	r0, [sp, #4]
 801371a:	2124      	movs	r1, #36	; 0x24
 801371c:	461a      	mov	r2, r3
 801371e:	2301      	movs	r3, #1
 8013720:	f7fe fb36 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013724:	4603      	mov	r3, r0
 8013726:	2b00      	cmp	r3, #0
 8013728:	d101      	bne.n	801372e <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x5e>
    return MEMS_ERROR;
 801372a:	2300      	movs	r3, #0
 801372c:	e000      	b.n	8013730 <LSM303AGR_ACC_W_LatchInterrupt_on_INT1+0x60>

  return MEMS_SUCCESS;
 801372e:	2301      	movs	r3, #1
}
 8013730:	4618      	mov	r0, r3
 8013732:	b005      	add	sp, #20
 8013734:	f85d fb04 	ldr.w	pc, [sp], #4
 8013738:	f3af 8000 	nop.w
 801373c:	f3af 8000 	nop.w

08013740 <LSM303AGR_ACC_R_LatchInterrupt_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_LIR_INT1_t
* Output         : Status of LIR_INT1 see LSM303AGR_ACC_LIR_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_LatchInterrupt_on_INT1(void *handle, LSM303AGR_ACC_LIR_INT1_t *value)
{
 8013740:	b500      	push	{lr}
 8013742:	b083      	sub	sp, #12
 8013744:	9001      	str	r0, [sp, #4]
 8013746:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 8013748:	9801      	ldr	r0, [sp, #4]
 801374a:	2124      	movs	r1, #36	; 0x24
 801374c:	9a00      	ldr	r2, [sp, #0]
 801374e:	2301      	movs	r3, #1
 8013750:	f7fe fb46 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013754:	4603      	mov	r3, r0
 8013756:	2b00      	cmp	r3, #0
 8013758:	d101      	bne.n	801375e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x1e>
    return MEMS_ERROR;
 801375a:	2300      	movs	r3, #0
 801375c:	e007      	b.n	801376e <LSM303AGR_ACC_R_LatchInterrupt_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_LIR_INT1_MASK; //mask
 801375e:	9b00      	ldr	r3, [sp, #0]
 8013760:	781b      	ldrb	r3, [r3, #0]
 8013762:	f003 0308 	and.w	r3, r3, #8
 8013766:	b2da      	uxtb	r2, r3
 8013768:	9b00      	ldr	r3, [sp, #0]
 801376a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801376c:	2301      	movs	r3, #1
}
 801376e:	4618      	mov	r0, r3
 8013770:	b003      	add	sp, #12
 8013772:	f85d fb04 	ldr.w	pc, [sp], #4
 8013776:	bf00      	nop
 8013778:	f3af 8000 	nop.w
 801377c:	f3af 8000 	nop.w

08013780 <LSM303AGR_ACC_W_FIFO_EN>:
* Input          : LSM303AGR_ACC_FIFO_EN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t newValue)
{
 8013780:	b500      	push	{lr}
 8013782:	b085      	sub	sp, #20
 8013784:	9001      	str	r0, [sp, #4]
 8013786:	460b      	mov	r3, r1
 8013788:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801378c:	f10d 030f 	add.w	r3, sp, #15
 8013790:	9801      	ldr	r0, [sp, #4]
 8013792:	2124      	movs	r1, #36	; 0x24
 8013794:	461a      	mov	r2, r3
 8013796:	2301      	movs	r3, #1
 8013798:	f7fe fb22 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801379c:	4603      	mov	r3, r0
 801379e:	2b00      	cmp	r3, #0
 80137a0:	d101      	bne.n	80137a6 <LSM303AGR_ACC_W_FIFO_EN+0x26>
    return MEMS_ERROR;
 80137a2:	2300      	movs	r3, #0
 80137a4:	e01c      	b.n	80137e0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  value &= ~LSM303AGR_ACC_FIFO_EN_MASK;
 80137a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80137aa:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 80137ae:	b2db      	uxtb	r3, r3
 80137b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80137b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80137b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80137bc:	4313      	orrs	r3, r2
 80137be:	b2db      	uxtb	r3, r3
 80137c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 80137c4:	f10d 030f 	add.w	r3, sp, #15
 80137c8:	9801      	ldr	r0, [sp, #4]
 80137ca:	2124      	movs	r1, #36	; 0x24
 80137cc:	461a      	mov	r2, r3
 80137ce:	2301      	movs	r3, #1
 80137d0:	f7fe fade 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80137d4:	4603      	mov	r3, r0
 80137d6:	2b00      	cmp	r3, #0
 80137d8:	d101      	bne.n	80137de <LSM303AGR_ACC_W_FIFO_EN+0x5e>
    return MEMS_ERROR;
 80137da:	2300      	movs	r3, #0
 80137dc:	e000      	b.n	80137e0 <LSM303AGR_ACC_W_FIFO_EN+0x60>

  return MEMS_SUCCESS;
 80137de:	2301      	movs	r3, #1
}
 80137e0:	4618      	mov	r0, r3
 80137e2:	b005      	add	sp, #20
 80137e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80137e8:	f3af 8000 	nop.w
 80137ec:	f3af 8000 	nop.w

080137f0 <LSM303AGR_ACC_R_FIFO_EN>:
* Input          : Pointer to LSM303AGR_ACC_FIFO_EN_t
* Output         : Status of FIFO_EN see LSM303AGR_ACC_FIFO_EN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FIFO_EN(void *handle, LSM303AGR_ACC_FIFO_EN_t *value)
{
 80137f0:	b500      	push	{lr}
 80137f2:	b083      	sub	sp, #12
 80137f4:	9001      	str	r0, [sp, #4]
 80137f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 80137f8:	9801      	ldr	r0, [sp, #4]
 80137fa:	2124      	movs	r1, #36	; 0x24
 80137fc:	9a00      	ldr	r2, [sp, #0]
 80137fe:	2301      	movs	r3, #1
 8013800:	f7fe faee 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013804:	4603      	mov	r3, r0
 8013806:	2b00      	cmp	r3, #0
 8013808:	d101      	bne.n	801380e <LSM303AGR_ACC_R_FIFO_EN+0x1e>
    return MEMS_ERROR;
 801380a:	2300      	movs	r3, #0
 801380c:	e007      	b.n	801381e <LSM303AGR_ACC_R_FIFO_EN+0x2e>

  *value &= LSM303AGR_ACC_FIFO_EN_MASK; //mask
 801380e:	9b00      	ldr	r3, [sp, #0]
 8013810:	781b      	ldrb	r3, [r3, #0]
 8013812:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013816:	b2da      	uxtb	r2, r3
 8013818:	9b00      	ldr	r3, [sp, #0]
 801381a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801381c:	2301      	movs	r3, #1
}
 801381e:	4618      	mov	r0, r3
 8013820:	b003      	add	sp, #12
 8013822:	f85d fb04 	ldr.w	pc, [sp], #4
 8013826:	bf00      	nop
 8013828:	f3af 8000 	nop.w
 801382c:	f3af 8000 	nop.w

08013830 <LSM303AGR_ACC_W_RebootMemory>:
* Input          : LSM303AGR_ACC_BOOT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t newValue)
{
 8013830:	b500      	push	{lr}
 8013832:	b085      	sub	sp, #20
 8013834:	9001      	str	r0, [sp, #4]
 8013836:	460b      	mov	r3, r1
 8013838:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 801383c:	f10d 030f 	add.w	r3, sp, #15
 8013840:	9801      	ldr	r0, [sp, #4]
 8013842:	2124      	movs	r1, #36	; 0x24
 8013844:	461a      	mov	r2, r3
 8013846:	2301      	movs	r3, #1
 8013848:	f7fe faca 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801384c:	4603      	mov	r3, r0
 801384e:	2b00      	cmp	r3, #0
 8013850:	d101      	bne.n	8013856 <LSM303AGR_ACC_W_RebootMemory+0x26>
    return MEMS_ERROR;
 8013852:	2300      	movs	r3, #0
 8013854:	e01c      	b.n	8013890 <LSM303AGR_ACC_W_RebootMemory+0x60>

  value &= ~LSM303AGR_ACC_BOOT_MASK;
 8013856:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801385a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 801385e:	b2db      	uxtb	r3, r3
 8013860:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013864:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013868:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801386c:	4313      	orrs	r3, r2
 801386e:	b2db      	uxtb	r3, r3
 8013870:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG5, &value, 1) )
 8013874:	f10d 030f 	add.w	r3, sp, #15
 8013878:	9801      	ldr	r0, [sp, #4]
 801387a:	2124      	movs	r1, #36	; 0x24
 801387c:	461a      	mov	r2, r3
 801387e:	2301      	movs	r3, #1
 8013880:	f7fe fa86 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013884:	4603      	mov	r3, r0
 8013886:	2b00      	cmp	r3, #0
 8013888:	d101      	bne.n	801388e <LSM303AGR_ACC_W_RebootMemory+0x5e>
    return MEMS_ERROR;
 801388a:	2300      	movs	r3, #0
 801388c:	e000      	b.n	8013890 <LSM303AGR_ACC_W_RebootMemory+0x60>

  return MEMS_SUCCESS;
 801388e:	2301      	movs	r3, #1
}
 8013890:	4618      	mov	r0, r3
 8013892:	b005      	add	sp, #20
 8013894:	f85d fb04 	ldr.w	pc, [sp], #4
 8013898:	f3af 8000 	nop.w
 801389c:	f3af 8000 	nop.w

080138a0 <LSM303AGR_ACC_R_RebootMemory>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_t
* Output         : Status of BOOT see LSM303AGR_ACC_BOOT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_RebootMemory(void *handle, LSM303AGR_ACC_BOOT_t *value)
{
 80138a0:	b500      	push	{lr}
 80138a2:	b083      	sub	sp, #12
 80138a4:	9001      	str	r0, [sp, #4]
 80138a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG5, (u8_t *)value, 1) )
 80138a8:	9801      	ldr	r0, [sp, #4]
 80138aa:	2124      	movs	r1, #36	; 0x24
 80138ac:	9a00      	ldr	r2, [sp, #0]
 80138ae:	2301      	movs	r3, #1
 80138b0:	f7fe fa96 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80138b4:	4603      	mov	r3, r0
 80138b6:	2b00      	cmp	r3, #0
 80138b8:	d101      	bne.n	80138be <LSM303AGR_ACC_R_RebootMemory+0x1e>
    return MEMS_ERROR;
 80138ba:	2300      	movs	r3, #0
 80138bc:	e007      	b.n	80138ce <LSM303AGR_ACC_R_RebootMemory+0x2e>

  *value &= LSM303AGR_ACC_BOOT_MASK; //mask
 80138be:	9b00      	ldr	r3, [sp, #0]
 80138c0:	781b      	ldrb	r3, [r3, #0]
 80138c2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80138c6:	b2da      	uxtb	r2, r3
 80138c8:	9b00      	ldr	r3, [sp, #0]
 80138ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80138cc:	2301      	movs	r3, #1
}
 80138ce:	4618      	mov	r0, r3
 80138d0:	b003      	add	sp, #12
 80138d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80138d6:	bf00      	nop
 80138d8:	f3af 8000 	nop.w
 80138dc:	f3af 8000 	nop.w

080138e0 <LSM303AGR_ACC_W_IntActive>:
* Input          : LSM303AGR_ACC_H_LACTIVE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t newValue)
{
 80138e0:	b500      	push	{lr}
 80138e2:	b085      	sub	sp, #20
 80138e4:	9001      	str	r0, [sp, #4]
 80138e6:	460b      	mov	r3, r1
 80138e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80138ec:	f10d 030f 	add.w	r3, sp, #15
 80138f0:	9801      	ldr	r0, [sp, #4]
 80138f2:	2125      	movs	r1, #37	; 0x25
 80138f4:	461a      	mov	r2, r3
 80138f6:	2301      	movs	r3, #1
 80138f8:	f7fe fa72 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80138fc:	4603      	mov	r3, r0
 80138fe:	2b00      	cmp	r3, #0
 8013900:	d101      	bne.n	8013906 <LSM303AGR_ACC_W_IntActive+0x26>
    return MEMS_ERROR;
 8013902:	2300      	movs	r3, #0
 8013904:	e01c      	b.n	8013940 <LSM303AGR_ACC_W_IntActive+0x60>

  value &= ~LSM303AGR_ACC_H_LACTIVE_MASK;
 8013906:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801390a:	f023 0302 	bic.w	r3, r3, #2
 801390e:	b2db      	uxtb	r3, r3
 8013910:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013914:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013918:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801391c:	4313      	orrs	r3, r2
 801391e:	b2db      	uxtb	r3, r3
 8013920:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013924:	f10d 030f 	add.w	r3, sp, #15
 8013928:	9801      	ldr	r0, [sp, #4]
 801392a:	2125      	movs	r1, #37	; 0x25
 801392c:	461a      	mov	r2, r3
 801392e:	2301      	movs	r3, #1
 8013930:	f7fe fa2e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013934:	4603      	mov	r3, r0
 8013936:	2b00      	cmp	r3, #0
 8013938:	d101      	bne.n	801393e <LSM303AGR_ACC_W_IntActive+0x5e>
    return MEMS_ERROR;
 801393a:	2300      	movs	r3, #0
 801393c:	e000      	b.n	8013940 <LSM303AGR_ACC_W_IntActive+0x60>

  return MEMS_SUCCESS;
 801393e:	2301      	movs	r3, #1
}
 8013940:	4618      	mov	r0, r3
 8013942:	b005      	add	sp, #20
 8013944:	f85d fb04 	ldr.w	pc, [sp], #4
 8013948:	f3af 8000 	nop.w
 801394c:	f3af 8000 	nop.w

08013950 <LSM303AGR_ACC_R_IntActive>:
* Input          : Pointer to LSM303AGR_ACC_H_LACTIVE_t
* Output         : Status of H_LACTIVE see LSM303AGR_ACC_H_LACTIVE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_IntActive(void *handle, LSM303AGR_ACC_H_LACTIVE_t *value)
{
 8013950:	b500      	push	{lr}
 8013952:	b083      	sub	sp, #12
 8013954:	9001      	str	r0, [sp, #4]
 8013956:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013958:	9801      	ldr	r0, [sp, #4]
 801395a:	2125      	movs	r1, #37	; 0x25
 801395c:	9a00      	ldr	r2, [sp, #0]
 801395e:	2301      	movs	r3, #1
 8013960:	f7fe fa3e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013964:	4603      	mov	r3, r0
 8013966:	2b00      	cmp	r3, #0
 8013968:	d101      	bne.n	801396e <LSM303AGR_ACC_R_IntActive+0x1e>
    return MEMS_ERROR;
 801396a:	2300      	movs	r3, #0
 801396c:	e007      	b.n	801397e <LSM303AGR_ACC_R_IntActive+0x2e>

  *value &= LSM303AGR_ACC_H_LACTIVE_MASK; //mask
 801396e:	9b00      	ldr	r3, [sp, #0]
 8013970:	781b      	ldrb	r3, [r3, #0]
 8013972:	f003 0302 	and.w	r3, r3, #2
 8013976:	b2da      	uxtb	r2, r3
 8013978:	9b00      	ldr	r3, [sp, #0]
 801397a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801397c:	2301      	movs	r3, #1
}
 801397e:	4618      	mov	r0, r3
 8013980:	b003      	add	sp, #12
 8013982:	f85d fb04 	ldr.w	pc, [sp], #4
 8013986:	bf00      	nop
 8013988:	f3af 8000 	nop.w
 801398c:	f3af 8000 	nop.w

08013990 <LSM303AGR_ACC_W_P2_ACT>:
* Input          : LSM303AGR_ACC_P2_ACT_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t newValue)
{
 8013990:	b500      	push	{lr}
 8013992:	b085      	sub	sp, #20
 8013994:	9001      	str	r0, [sp, #4]
 8013996:	460b      	mov	r3, r1
 8013998:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 801399c:	f10d 030f 	add.w	r3, sp, #15
 80139a0:	9801      	ldr	r0, [sp, #4]
 80139a2:	2125      	movs	r1, #37	; 0x25
 80139a4:	461a      	mov	r2, r3
 80139a6:	2301      	movs	r3, #1
 80139a8:	f7fe fa1a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80139ac:	4603      	mov	r3, r0
 80139ae:	2b00      	cmp	r3, #0
 80139b0:	d101      	bne.n	80139b6 <LSM303AGR_ACC_W_P2_ACT+0x26>
    return MEMS_ERROR;
 80139b2:	2300      	movs	r3, #0
 80139b4:	e01c      	b.n	80139f0 <LSM303AGR_ACC_W_P2_ACT+0x60>

  value &= ~LSM303AGR_ACC_P2_ACT_MASK;
 80139b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80139ba:	f023 0308 	bic.w	r3, r3, #8
 80139be:	b2db      	uxtb	r3, r3
 80139c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80139c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80139c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80139cc:	4313      	orrs	r3, r2
 80139ce:	b2db      	uxtb	r3, r3
 80139d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 80139d4:	f10d 030f 	add.w	r3, sp, #15
 80139d8:	9801      	ldr	r0, [sp, #4]
 80139da:	2125      	movs	r1, #37	; 0x25
 80139dc:	461a      	mov	r2, r3
 80139de:	2301      	movs	r3, #1
 80139e0:	f7fe f9d6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80139e4:	4603      	mov	r3, r0
 80139e6:	2b00      	cmp	r3, #0
 80139e8:	d101      	bne.n	80139ee <LSM303AGR_ACC_W_P2_ACT+0x5e>
    return MEMS_ERROR;
 80139ea:	2300      	movs	r3, #0
 80139ec:	e000      	b.n	80139f0 <LSM303AGR_ACC_W_P2_ACT+0x60>

  return MEMS_SUCCESS;
 80139ee:	2301      	movs	r3, #1
}
 80139f0:	4618      	mov	r0, r3
 80139f2:	b005      	add	sp, #20
 80139f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80139f8:	f3af 8000 	nop.w
 80139fc:	f3af 8000 	nop.w

08013a00 <LSM303AGR_ACC_R_P2_ACT>:
* Input          : Pointer to LSM303AGR_ACC_P2_ACT_t
* Output         : Status of P2_ACT see LSM303AGR_ACC_P2_ACT_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_P2_ACT(void *handle, LSM303AGR_ACC_P2_ACT_t *value)
{
 8013a00:	b500      	push	{lr}
 8013a02:	b083      	sub	sp, #12
 8013a04:	9001      	str	r0, [sp, #4]
 8013a06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013a08:	9801      	ldr	r0, [sp, #4]
 8013a0a:	2125      	movs	r1, #37	; 0x25
 8013a0c:	9a00      	ldr	r2, [sp, #0]
 8013a0e:	2301      	movs	r3, #1
 8013a10:	f7fe f9e6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013a14:	4603      	mov	r3, r0
 8013a16:	2b00      	cmp	r3, #0
 8013a18:	d101      	bne.n	8013a1e <LSM303AGR_ACC_R_P2_ACT+0x1e>
    return MEMS_ERROR;
 8013a1a:	2300      	movs	r3, #0
 8013a1c:	e007      	b.n	8013a2e <LSM303AGR_ACC_R_P2_ACT+0x2e>

  *value &= LSM303AGR_ACC_P2_ACT_MASK; //mask
 8013a1e:	9b00      	ldr	r3, [sp, #0]
 8013a20:	781b      	ldrb	r3, [r3, #0]
 8013a22:	f003 0308 	and.w	r3, r3, #8
 8013a26:	b2da      	uxtb	r2, r3
 8013a28:	9b00      	ldr	r3, [sp, #0]
 8013a2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013a2c:	2301      	movs	r3, #1
}
 8013a2e:	4618      	mov	r0, r3
 8013a30:	b003      	add	sp, #12
 8013a32:	f85d fb04 	ldr.w	pc, [sp], #4
 8013a36:	bf00      	nop
 8013a38:	f3af 8000 	nop.w
 8013a3c:	f3af 8000 	nop.w

08013a40 <LSM303AGR_ACC_W_Boot_on_INT2>:
* Input          : LSM303AGR_ACC_BOOT_I1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t newValue)
{
 8013a40:	b500      	push	{lr}
 8013a42:	b085      	sub	sp, #20
 8013a44:	9001      	str	r0, [sp, #4]
 8013a46:	460b      	mov	r3, r1
 8013a48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013a4c:	f10d 030f 	add.w	r3, sp, #15
 8013a50:	9801      	ldr	r0, [sp, #4]
 8013a52:	2125      	movs	r1, #37	; 0x25
 8013a54:	461a      	mov	r2, r3
 8013a56:	2301      	movs	r3, #1
 8013a58:	f7fe f9c2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013a5c:	4603      	mov	r3, r0
 8013a5e:	2b00      	cmp	r3, #0
 8013a60:	d101      	bne.n	8013a66 <LSM303AGR_ACC_W_Boot_on_INT2+0x26>
    return MEMS_ERROR;
 8013a62:	2300      	movs	r3, #0
 8013a64:	e01c      	b.n	8013aa0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_BOOT_I1_MASK;
 8013a66:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013a6a:	f023 0310 	bic.w	r3, r3, #16
 8013a6e:	b2db      	uxtb	r3, r3
 8013a70:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013a74:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013a78:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013a7c:	4313      	orrs	r3, r2
 8013a7e:	b2db      	uxtb	r3, r3
 8013a80:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013a84:	f10d 030f 	add.w	r3, sp, #15
 8013a88:	9801      	ldr	r0, [sp, #4]
 8013a8a:	2125      	movs	r1, #37	; 0x25
 8013a8c:	461a      	mov	r2, r3
 8013a8e:	2301      	movs	r3, #1
 8013a90:	f7fe f97e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013a94:	4603      	mov	r3, r0
 8013a96:	2b00      	cmp	r3, #0
 8013a98:	d101      	bne.n	8013a9e <LSM303AGR_ACC_W_Boot_on_INT2+0x5e>
    return MEMS_ERROR;
 8013a9a:	2300      	movs	r3, #0
 8013a9c:	e000      	b.n	8013aa0 <LSM303AGR_ACC_W_Boot_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013a9e:	2301      	movs	r3, #1
}
 8013aa0:	4618      	mov	r0, r3
 8013aa2:	b005      	add	sp, #20
 8013aa4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013aa8:	f3af 8000 	nop.w
 8013aac:	f3af 8000 	nop.w

08013ab0 <LSM303AGR_ACC_R_Boot_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_BOOT_I1_t
* Output         : Status of BOOT_I1 see LSM303AGR_ACC_BOOT_I1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Boot_on_INT2(void *handle, LSM303AGR_ACC_BOOT_I1_t *value)
{
 8013ab0:	b500      	push	{lr}
 8013ab2:	b083      	sub	sp, #12
 8013ab4:	9001      	str	r0, [sp, #4]
 8013ab6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013ab8:	9801      	ldr	r0, [sp, #4]
 8013aba:	2125      	movs	r1, #37	; 0x25
 8013abc:	9a00      	ldr	r2, [sp, #0]
 8013abe:	2301      	movs	r3, #1
 8013ac0:	f7fe f98e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013ac4:	4603      	mov	r3, r0
 8013ac6:	2b00      	cmp	r3, #0
 8013ac8:	d101      	bne.n	8013ace <LSM303AGR_ACC_R_Boot_on_INT2+0x1e>
    return MEMS_ERROR;
 8013aca:	2300      	movs	r3, #0
 8013acc:	e007      	b.n	8013ade <LSM303AGR_ACC_R_Boot_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_BOOT_I1_MASK; //mask
 8013ace:	9b00      	ldr	r3, [sp, #0]
 8013ad0:	781b      	ldrb	r3, [r3, #0]
 8013ad2:	f003 0310 	and.w	r3, r3, #16
 8013ad6:	b2da      	uxtb	r2, r3
 8013ad8:	9b00      	ldr	r3, [sp, #0]
 8013ada:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013adc:	2301      	movs	r3, #1
}
 8013ade:	4618      	mov	r0, r3
 8013ae0:	b003      	add	sp, #12
 8013ae2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ae6:	bf00      	nop
 8013ae8:	f3af 8000 	nop.w
 8013aec:	f3af 8000 	nop.w

08013af0 <LSM303AGR_ACC_W_I2_on_INT2>:
* Input          : LSM303AGR_ACC_I2_INT2_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t newValue)
{
 8013af0:	b500      	push	{lr}
 8013af2:	b085      	sub	sp, #20
 8013af4:	9001      	str	r0, [sp, #4]
 8013af6:	460b      	mov	r3, r1
 8013af8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013afc:	f10d 030f 	add.w	r3, sp, #15
 8013b00:	9801      	ldr	r0, [sp, #4]
 8013b02:	2125      	movs	r1, #37	; 0x25
 8013b04:	461a      	mov	r2, r3
 8013b06:	2301      	movs	r3, #1
 8013b08:	f7fe f96a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013b0c:	4603      	mov	r3, r0
 8013b0e:	2b00      	cmp	r3, #0
 8013b10:	d101      	bne.n	8013b16 <LSM303AGR_ACC_W_I2_on_INT2+0x26>
    return MEMS_ERROR;
 8013b12:	2300      	movs	r3, #0
 8013b14:	e01c      	b.n	8013b50 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_INT2_MASK;
 8013b16:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013b1a:	f023 0320 	bic.w	r3, r3, #32
 8013b1e:	b2db      	uxtb	r3, r3
 8013b20:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013b24:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013b28:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013b2c:	4313      	orrs	r3, r2
 8013b2e:	b2db      	uxtb	r3, r3
 8013b30:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013b34:	f10d 030f 	add.w	r3, sp, #15
 8013b38:	9801      	ldr	r0, [sp, #4]
 8013b3a:	2125      	movs	r1, #37	; 0x25
 8013b3c:	461a      	mov	r2, r3
 8013b3e:	2301      	movs	r3, #1
 8013b40:	f7fe f926 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013b44:	4603      	mov	r3, r0
 8013b46:	2b00      	cmp	r3, #0
 8013b48:	d101      	bne.n	8013b4e <LSM303AGR_ACC_W_I2_on_INT2+0x5e>
    return MEMS_ERROR;
 8013b4a:	2300      	movs	r3, #0
 8013b4c:	e000      	b.n	8013b50 <LSM303AGR_ACC_W_I2_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013b4e:	2301      	movs	r3, #1
}
 8013b50:	4618      	mov	r0, r3
 8013b52:	b005      	add	sp, #20
 8013b54:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b58:	f3af 8000 	nop.w
 8013b5c:	f3af 8000 	nop.w

08013b60 <LSM303AGR_ACC_R_I2_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT2_t
* Output         : Status of I2_INT2 see LSM303AGR_ACC_I2_INT2_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT2(void *handle, LSM303AGR_ACC_I2_INT2_t *value)
{
 8013b60:	b500      	push	{lr}
 8013b62:	b083      	sub	sp, #12
 8013b64:	9001      	str	r0, [sp, #4]
 8013b66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013b68:	9801      	ldr	r0, [sp, #4]
 8013b6a:	2125      	movs	r1, #37	; 0x25
 8013b6c:	9a00      	ldr	r2, [sp, #0]
 8013b6e:	2301      	movs	r3, #1
 8013b70:	f7fe f936 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013b74:	4603      	mov	r3, r0
 8013b76:	2b00      	cmp	r3, #0
 8013b78:	d101      	bne.n	8013b7e <LSM303AGR_ACC_R_I2_on_INT2+0x1e>
    return MEMS_ERROR;
 8013b7a:	2300      	movs	r3, #0
 8013b7c:	e007      	b.n	8013b8e <LSM303AGR_ACC_R_I2_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_INT2_MASK; //mask
 8013b7e:	9b00      	ldr	r3, [sp, #0]
 8013b80:	781b      	ldrb	r3, [r3, #0]
 8013b82:	f003 0320 	and.w	r3, r3, #32
 8013b86:	b2da      	uxtb	r2, r3
 8013b88:	9b00      	ldr	r3, [sp, #0]
 8013b8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013b8c:	2301      	movs	r3, #1
}
 8013b8e:	4618      	mov	r0, r3
 8013b90:	b003      	add	sp, #12
 8013b92:	f85d fb04 	ldr.w	pc, [sp], #4
 8013b96:	bf00      	nop
 8013b98:	f3af 8000 	nop.w
 8013b9c:	f3af 8000 	nop.w

08013ba0 <LSM303AGR_ACC_W_I2_on_INT1>:
* Input          : LSM303AGR_ACC_I2_INT1_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t newValue)
{
 8013ba0:	b500      	push	{lr}
 8013ba2:	b085      	sub	sp, #20
 8013ba4:	9001      	str	r0, [sp, #4]
 8013ba6:	460b      	mov	r3, r1
 8013ba8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013bac:	f10d 030f 	add.w	r3, sp, #15
 8013bb0:	9801      	ldr	r0, [sp, #4]
 8013bb2:	2125      	movs	r1, #37	; 0x25
 8013bb4:	461a      	mov	r2, r3
 8013bb6:	2301      	movs	r3, #1
 8013bb8:	f7fe f912 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013bbc:	4603      	mov	r3, r0
 8013bbe:	2b00      	cmp	r3, #0
 8013bc0:	d101      	bne.n	8013bc6 <LSM303AGR_ACC_W_I2_on_INT1+0x26>
    return MEMS_ERROR;
 8013bc2:	2300      	movs	r3, #0
 8013bc4:	e01c      	b.n	8013c00 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  value &= ~LSM303AGR_ACC_I2_INT1_MASK;
 8013bc6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013bca:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8013bce:	b2db      	uxtb	r3, r3
 8013bd0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013bd4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013bd8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013bdc:	4313      	orrs	r3, r2
 8013bde:	b2db      	uxtb	r3, r3
 8013be0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013be4:	f10d 030f 	add.w	r3, sp, #15
 8013be8:	9801      	ldr	r0, [sp, #4]
 8013bea:	2125      	movs	r1, #37	; 0x25
 8013bec:	461a      	mov	r2, r3
 8013bee:	2301      	movs	r3, #1
 8013bf0:	f7fe f8ce 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013bf4:	4603      	mov	r3, r0
 8013bf6:	2b00      	cmp	r3, #0
 8013bf8:	d101      	bne.n	8013bfe <LSM303AGR_ACC_W_I2_on_INT1+0x5e>
    return MEMS_ERROR;
 8013bfa:	2300      	movs	r3, #0
 8013bfc:	e000      	b.n	8013c00 <LSM303AGR_ACC_W_I2_on_INT1+0x60>

  return MEMS_SUCCESS;
 8013bfe:	2301      	movs	r3, #1
}
 8013c00:	4618      	mov	r0, r3
 8013c02:	b005      	add	sp, #20
 8013c04:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c08:	f3af 8000 	nop.w
 8013c0c:	f3af 8000 	nop.w

08013c10 <LSM303AGR_ACC_R_I2_on_INT1>:
* Input          : Pointer to LSM303AGR_ACC_I2_INT1_t
* Output         : Status of I2_INT1 see LSM303AGR_ACC_I2_INT1_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_I2_on_INT1(void *handle, LSM303AGR_ACC_I2_INT1_t *value)
{
 8013c10:	b500      	push	{lr}
 8013c12:	b083      	sub	sp, #12
 8013c14:	9001      	str	r0, [sp, #4]
 8013c16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013c18:	9801      	ldr	r0, [sp, #4]
 8013c1a:	2125      	movs	r1, #37	; 0x25
 8013c1c:	9a00      	ldr	r2, [sp, #0]
 8013c1e:	2301      	movs	r3, #1
 8013c20:	f7fe f8de 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013c24:	4603      	mov	r3, r0
 8013c26:	2b00      	cmp	r3, #0
 8013c28:	d101      	bne.n	8013c2e <LSM303AGR_ACC_R_I2_on_INT1+0x1e>
    return MEMS_ERROR;
 8013c2a:	2300      	movs	r3, #0
 8013c2c:	e007      	b.n	8013c3e <LSM303AGR_ACC_R_I2_on_INT1+0x2e>

  *value &= LSM303AGR_ACC_I2_INT1_MASK; //mask
 8013c2e:	9b00      	ldr	r3, [sp, #0]
 8013c30:	781b      	ldrb	r3, [r3, #0]
 8013c32:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013c36:	b2da      	uxtb	r2, r3
 8013c38:	9b00      	ldr	r3, [sp, #0]
 8013c3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013c3c:	2301      	movs	r3, #1
}
 8013c3e:	4618      	mov	r0, r3
 8013c40:	b003      	add	sp, #12
 8013c42:	f85d fb04 	ldr.w	pc, [sp], #4
 8013c46:	bf00      	nop
 8013c48:	f3af 8000 	nop.w
 8013c4c:	f3af 8000 	nop.w

08013c50 <LSM303AGR_ACC_W_Click_on_INT2>:
* Input          : LSM303AGR_ACC_I2_CLICKEN_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t newValue)
{
 8013c50:	b500      	push	{lr}
 8013c52:	b085      	sub	sp, #20
 8013c54:	9001      	str	r0, [sp, #4]
 8013c56:	460b      	mov	r3, r1
 8013c58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013c5c:	f10d 030f 	add.w	r3, sp, #15
 8013c60:	9801      	ldr	r0, [sp, #4]
 8013c62:	2125      	movs	r1, #37	; 0x25
 8013c64:	461a      	mov	r2, r3
 8013c66:	2301      	movs	r3, #1
 8013c68:	f7fe f8ba 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013c6c:	4603      	mov	r3, r0
 8013c6e:	2b00      	cmp	r3, #0
 8013c70:	d101      	bne.n	8013c76 <LSM303AGR_ACC_W_Click_on_INT2+0x26>
    return MEMS_ERROR;
 8013c72:	2300      	movs	r3, #0
 8013c74:	e01c      	b.n	8013cb0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  value &= ~LSM303AGR_ACC_I2_CLICKEN_MASK;
 8013c76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013c7a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8013c7e:	b2db      	uxtb	r3, r3
 8013c80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013c84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013c88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013c8c:	4313      	orrs	r3, r2
 8013c8e:	b2db      	uxtb	r3, r3
 8013c90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CTRL_REG6, &value, 1) )
 8013c94:	f10d 030f 	add.w	r3, sp, #15
 8013c98:	9801      	ldr	r0, [sp, #4]
 8013c9a:	2125      	movs	r1, #37	; 0x25
 8013c9c:	461a      	mov	r2, r3
 8013c9e:	2301      	movs	r3, #1
 8013ca0:	f7fe f876 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013ca4:	4603      	mov	r3, r0
 8013ca6:	2b00      	cmp	r3, #0
 8013ca8:	d101      	bne.n	8013cae <LSM303AGR_ACC_W_Click_on_INT2+0x5e>
    return MEMS_ERROR;
 8013caa:	2300      	movs	r3, #0
 8013cac:	e000      	b.n	8013cb0 <LSM303AGR_ACC_W_Click_on_INT2+0x60>

  return MEMS_SUCCESS;
 8013cae:	2301      	movs	r3, #1
}
 8013cb0:	4618      	mov	r0, r3
 8013cb2:	b005      	add	sp, #20
 8013cb4:	f85d fb04 	ldr.w	pc, [sp], #4
 8013cb8:	f3af 8000 	nop.w
 8013cbc:	f3af 8000 	nop.w

08013cc0 <LSM303AGR_ACC_R_Click_on_INT2>:
* Input          : Pointer to LSM303AGR_ACC_I2_CLICKEN_t
* Output         : Status of I2_CLICKEN see LSM303AGR_ACC_I2_CLICKEN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Click_on_INT2(void *handle, LSM303AGR_ACC_I2_CLICKEN_t *value)
{
 8013cc0:	b500      	push	{lr}
 8013cc2:	b083      	sub	sp, #12
 8013cc4:	9001      	str	r0, [sp, #4]
 8013cc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CTRL_REG6, (u8_t *)value, 1) )
 8013cc8:	9801      	ldr	r0, [sp, #4]
 8013cca:	2125      	movs	r1, #37	; 0x25
 8013ccc:	9a00      	ldr	r2, [sp, #0]
 8013cce:	2301      	movs	r3, #1
 8013cd0:	f7fe f886 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013cd4:	4603      	mov	r3, r0
 8013cd6:	2b00      	cmp	r3, #0
 8013cd8:	d101      	bne.n	8013cde <LSM303AGR_ACC_R_Click_on_INT2+0x1e>
    return MEMS_ERROR;
 8013cda:	2300      	movs	r3, #0
 8013cdc:	e007      	b.n	8013cee <LSM303AGR_ACC_R_Click_on_INT2+0x2e>

  *value &= LSM303AGR_ACC_I2_CLICKEN_MASK; //mask
 8013cde:	9b00      	ldr	r3, [sp, #0]
 8013ce0:	781b      	ldrb	r3, [r3, #0]
 8013ce2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013ce6:	b2da      	uxtb	r2, r3
 8013ce8:	9b00      	ldr	r3, [sp, #0]
 8013cea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013cec:	2301      	movs	r3, #1
}
 8013cee:	4618      	mov	r0, r3
 8013cf0:	b003      	add	sp, #12
 8013cf2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013cf6:	bf00      	nop
 8013cf8:	f3af 8000 	nop.w
 8013cfc:	f3af 8000 	nop.w

08013d00 <LSM303AGR_ACC_W_ReferenceVal>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ReferenceVal(void *handle, u8_t newValue)
{
 8013d00:	b500      	push	{lr}
 8013d02:	b085      	sub	sp, #20
 8013d04:	9001      	str	r0, [sp, #4]
 8013d06:	460b      	mov	r3, r1
 8013d08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_REF_POSITION; //mask
  newValue &= LSM303AGR_ACC_REF_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 8013d0c:	f10d 030f 	add.w	r3, sp, #15
 8013d10:	9801      	ldr	r0, [sp, #4]
 8013d12:	2126      	movs	r1, #38	; 0x26
 8013d14:	461a      	mov	r2, r3
 8013d16:	2301      	movs	r3, #1
 8013d18:	f7fe f862 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013d1c:	4603      	mov	r3, r0
 8013d1e:	2b00      	cmp	r3, #0
 8013d20:	d101      	bne.n	8013d26 <LSM303AGR_ACC_W_ReferenceVal+0x26>
    return MEMS_ERROR;
 8013d22:	2300      	movs	r3, #0
 8013d24:	e018      	b.n	8013d58 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  value &= (u8_t)~LSM303AGR_ACC_REF_MASK;
 8013d26:	2300      	movs	r3, #0
 8013d28:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013d2c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013d30:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013d34:	4313      	orrs	r3, r2
 8013d36:	b2db      	uxtb	r3, r3
 8013d38:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_REFERENCE, &value, 1) )
 8013d3c:	f10d 030f 	add.w	r3, sp, #15
 8013d40:	9801      	ldr	r0, [sp, #4]
 8013d42:	2126      	movs	r1, #38	; 0x26
 8013d44:	461a      	mov	r2, r3
 8013d46:	2301      	movs	r3, #1
 8013d48:	f7fe f822 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8013d4c:	4603      	mov	r3, r0
 8013d4e:	2b00      	cmp	r3, #0
 8013d50:	d101      	bne.n	8013d56 <LSM303AGR_ACC_W_ReferenceVal+0x56>
    return MEMS_ERROR;
 8013d52:	2300      	movs	r3, #0
 8013d54:	e000      	b.n	8013d58 <LSM303AGR_ACC_W_ReferenceVal+0x58>

  return MEMS_SUCCESS;
 8013d56:	2301      	movs	r3, #1
}
 8013d58:	4618      	mov	r0, r3
 8013d5a:	b005      	add	sp, #20
 8013d5c:	f85d fb04 	ldr.w	pc, [sp], #4

08013d60 <LSM303AGR_ACC_R_ReferenceVal>:
* Input          : Pointer to u8_t
* Output         : Status of REF
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ReferenceVal(void *handle, u8_t *value)
{
 8013d60:	b500      	push	{lr}
 8013d62:	b083      	sub	sp, #12
 8013d64:	9001      	str	r0, [sp, #4]
 8013d66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_REFERENCE, (u8_t *)value, 1) )
 8013d68:	9801      	ldr	r0, [sp, #4]
 8013d6a:	2126      	movs	r1, #38	; 0x26
 8013d6c:	9a00      	ldr	r2, [sp, #0]
 8013d6e:	2301      	movs	r3, #1
 8013d70:	f7fe f836 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013d74:	4603      	mov	r3, r0
 8013d76:	2b00      	cmp	r3, #0
 8013d78:	d101      	bne.n	8013d7e <LSM303AGR_ACC_R_ReferenceVal+0x1e>
    return MEMS_ERROR;
 8013d7a:	2300      	movs	r3, #0
 8013d7c:	e008      	b.n	8013d90 <LSM303AGR_ACC_R_ReferenceVal+0x30>

  *value &= LSM303AGR_ACC_REF_MASK; //coerce
 8013d7e:	9b00      	ldr	r3, [sp, #0]
 8013d80:	781a      	ldrb	r2, [r3, #0]
 8013d82:	9b00      	ldr	r3, [sp, #0]
 8013d84:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_REF_POSITION; //mask
 8013d86:	9b00      	ldr	r3, [sp, #0]
 8013d88:	781a      	ldrb	r2, [r3, #0]
 8013d8a:	9b00      	ldr	r3, [sp, #0]
 8013d8c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013d8e:	2301      	movs	r3, #1
}
 8013d90:	4618      	mov	r0, r3
 8013d92:	b003      	add	sp, #12
 8013d94:	f85d fb04 	ldr.w	pc, [sp], #4
 8013d98:	f3af 8000 	nop.w
 8013d9c:	f3af 8000 	nop.w

08013da0 <LSM303AGR_ACC_R_XDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_XDA_t
* Output         : Status of XDA see LSM303AGR_ACC_XDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataAvail(void *handle, LSM303AGR_ACC_XDA_t *value)
{
 8013da0:	b500      	push	{lr}
 8013da2:	b083      	sub	sp, #12
 8013da4:	9001      	str	r0, [sp, #4]
 8013da6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013da8:	9801      	ldr	r0, [sp, #4]
 8013daa:	2127      	movs	r1, #39	; 0x27
 8013dac:	9a00      	ldr	r2, [sp, #0]
 8013dae:	2301      	movs	r3, #1
 8013db0:	f7fe f816 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013db4:	4603      	mov	r3, r0
 8013db6:	2b00      	cmp	r3, #0
 8013db8:	d101      	bne.n	8013dbe <LSM303AGR_ACC_R_XDataAvail+0x1e>
    return MEMS_ERROR;
 8013dba:	2300      	movs	r3, #0
 8013dbc:	e007      	b.n	8013dce <LSM303AGR_ACC_R_XDataAvail+0x2e>

  *value &= LSM303AGR_ACC_XDA_MASK; //mask
 8013dbe:	9b00      	ldr	r3, [sp, #0]
 8013dc0:	781b      	ldrb	r3, [r3, #0]
 8013dc2:	f003 0301 	and.w	r3, r3, #1
 8013dc6:	b2da      	uxtb	r2, r3
 8013dc8:	9b00      	ldr	r3, [sp, #0]
 8013dca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013dcc:	2301      	movs	r3, #1
}
 8013dce:	4618      	mov	r0, r3
 8013dd0:	b003      	add	sp, #12
 8013dd2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013dd6:	bf00      	nop
 8013dd8:	f3af 8000 	nop.w
 8013ddc:	f3af 8000 	nop.w

08013de0 <LSM303AGR_ACC_R_YDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_YDA_t
* Output         : Status of YDA see LSM303AGR_ACC_YDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataAvail(void *handle, LSM303AGR_ACC_YDA_t *value)
{
 8013de0:	b500      	push	{lr}
 8013de2:	b083      	sub	sp, #12
 8013de4:	9001      	str	r0, [sp, #4]
 8013de6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013de8:	9801      	ldr	r0, [sp, #4]
 8013dea:	2127      	movs	r1, #39	; 0x27
 8013dec:	9a00      	ldr	r2, [sp, #0]
 8013dee:	2301      	movs	r3, #1
 8013df0:	f7fd fff6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013df4:	4603      	mov	r3, r0
 8013df6:	2b00      	cmp	r3, #0
 8013df8:	d101      	bne.n	8013dfe <LSM303AGR_ACC_R_YDataAvail+0x1e>
    return MEMS_ERROR;
 8013dfa:	2300      	movs	r3, #0
 8013dfc:	e007      	b.n	8013e0e <LSM303AGR_ACC_R_YDataAvail+0x2e>

  *value &= LSM303AGR_ACC_YDA_MASK; //mask
 8013dfe:	9b00      	ldr	r3, [sp, #0]
 8013e00:	781b      	ldrb	r3, [r3, #0]
 8013e02:	f003 0302 	and.w	r3, r3, #2
 8013e06:	b2da      	uxtb	r2, r3
 8013e08:	9b00      	ldr	r3, [sp, #0]
 8013e0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013e0c:	2301      	movs	r3, #1
}
 8013e0e:	4618      	mov	r0, r3
 8013e10:	b003      	add	sp, #12
 8013e12:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e16:	bf00      	nop
 8013e18:	f3af 8000 	nop.w
 8013e1c:	f3af 8000 	nop.w

08013e20 <LSM303AGR_ACC_R_ZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZDA_t
* Output         : Status of ZDA see LSM303AGR_ACC_ZDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataAvail(void *handle, LSM303AGR_ACC_ZDA_t *value)
{
 8013e20:	b500      	push	{lr}
 8013e22:	b083      	sub	sp, #12
 8013e24:	9001      	str	r0, [sp, #4]
 8013e26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013e28:	9801      	ldr	r0, [sp, #4]
 8013e2a:	2127      	movs	r1, #39	; 0x27
 8013e2c:	9a00      	ldr	r2, [sp, #0]
 8013e2e:	2301      	movs	r3, #1
 8013e30:	f7fd ffd6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013e34:	4603      	mov	r3, r0
 8013e36:	2b00      	cmp	r3, #0
 8013e38:	d101      	bne.n	8013e3e <LSM303AGR_ACC_R_ZDataAvail+0x1e>
    return MEMS_ERROR;
 8013e3a:	2300      	movs	r3, #0
 8013e3c:	e007      	b.n	8013e4e <LSM303AGR_ACC_R_ZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZDA_MASK; //mask
 8013e3e:	9b00      	ldr	r3, [sp, #0]
 8013e40:	781b      	ldrb	r3, [r3, #0]
 8013e42:	f003 0304 	and.w	r3, r3, #4
 8013e46:	b2da      	uxtb	r2, r3
 8013e48:	9b00      	ldr	r3, [sp, #0]
 8013e4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013e4c:	2301      	movs	r3, #1
}
 8013e4e:	4618      	mov	r0, r3
 8013e50:	b003      	add	sp, #12
 8013e52:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e56:	bf00      	nop
 8013e58:	f3af 8000 	nop.w
 8013e5c:	f3af 8000 	nop.w

08013e60 <LSM303AGR_ACC_R_XYZDataAvail>:
* Input          : Pointer to LSM303AGR_ACC_ZYXDA_t
* Output         : Status of ZYXDA see LSM303AGR_ACC_ZYXDA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataAvail(void *handle, LSM303AGR_ACC_ZYXDA_t *value)
{
 8013e60:	b500      	push	{lr}
 8013e62:	b083      	sub	sp, #12
 8013e64:	9001      	str	r0, [sp, #4]
 8013e66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013e68:	9801      	ldr	r0, [sp, #4]
 8013e6a:	2127      	movs	r1, #39	; 0x27
 8013e6c:	9a00      	ldr	r2, [sp, #0]
 8013e6e:	2301      	movs	r3, #1
 8013e70:	f7fd ffb6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013e74:	4603      	mov	r3, r0
 8013e76:	2b00      	cmp	r3, #0
 8013e78:	d101      	bne.n	8013e7e <LSM303AGR_ACC_R_XYZDataAvail+0x1e>
    return MEMS_ERROR;
 8013e7a:	2300      	movs	r3, #0
 8013e7c:	e007      	b.n	8013e8e <LSM303AGR_ACC_R_XYZDataAvail+0x2e>

  *value &= LSM303AGR_ACC_ZYXDA_MASK; //mask
 8013e7e:	9b00      	ldr	r3, [sp, #0]
 8013e80:	781b      	ldrb	r3, [r3, #0]
 8013e82:	f003 0308 	and.w	r3, r3, #8
 8013e86:	b2da      	uxtb	r2, r3
 8013e88:	9b00      	ldr	r3, [sp, #0]
 8013e8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013e8c:	2301      	movs	r3, #1
}
 8013e8e:	4618      	mov	r0, r3
 8013e90:	b003      	add	sp, #12
 8013e92:	f85d fb04 	ldr.w	pc, [sp], #4
 8013e96:	bf00      	nop
 8013e98:	f3af 8000 	nop.w
 8013e9c:	f3af 8000 	nop.w

08013ea0 <LSM303AGR_ACC_R_XDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_XOR_t
* Output         : Status of XOR see LSM303AGR_ACC_XOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDataOverrun(void *handle, LSM303AGR_ACC_XOR_t *value)
{
 8013ea0:	b500      	push	{lr}
 8013ea2:	b083      	sub	sp, #12
 8013ea4:	9001      	str	r0, [sp, #4]
 8013ea6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013ea8:	9801      	ldr	r0, [sp, #4]
 8013eaa:	2127      	movs	r1, #39	; 0x27
 8013eac:	9a00      	ldr	r2, [sp, #0]
 8013eae:	2301      	movs	r3, #1
 8013eb0:	f7fd ff96 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013eb4:	4603      	mov	r3, r0
 8013eb6:	2b00      	cmp	r3, #0
 8013eb8:	d101      	bne.n	8013ebe <LSM303AGR_ACC_R_XDataOverrun+0x1e>
    return MEMS_ERROR;
 8013eba:	2300      	movs	r3, #0
 8013ebc:	e007      	b.n	8013ece <LSM303AGR_ACC_R_XDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_XOR_MASK; //mask
 8013ebe:	9b00      	ldr	r3, [sp, #0]
 8013ec0:	781b      	ldrb	r3, [r3, #0]
 8013ec2:	f003 0310 	and.w	r3, r3, #16
 8013ec6:	b2da      	uxtb	r2, r3
 8013ec8:	9b00      	ldr	r3, [sp, #0]
 8013eca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013ecc:	2301      	movs	r3, #1
}
 8013ece:	4618      	mov	r0, r3
 8013ed0:	b003      	add	sp, #12
 8013ed2:	f85d fb04 	ldr.w	pc, [sp], #4
 8013ed6:	bf00      	nop
 8013ed8:	f3af 8000 	nop.w
 8013edc:	f3af 8000 	nop.w

08013ee0 <LSM303AGR_ACC_R_YDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_YOR_t
* Output         : Status of YOR see LSM303AGR_ACC_YOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDataOverrun(void *handle, LSM303AGR_ACC_YOR_t *value)
{
 8013ee0:	b500      	push	{lr}
 8013ee2:	b083      	sub	sp, #12
 8013ee4:	9001      	str	r0, [sp, #4]
 8013ee6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013ee8:	9801      	ldr	r0, [sp, #4]
 8013eea:	2127      	movs	r1, #39	; 0x27
 8013eec:	9a00      	ldr	r2, [sp, #0]
 8013eee:	2301      	movs	r3, #1
 8013ef0:	f7fd ff76 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013ef4:	4603      	mov	r3, r0
 8013ef6:	2b00      	cmp	r3, #0
 8013ef8:	d101      	bne.n	8013efe <LSM303AGR_ACC_R_YDataOverrun+0x1e>
    return MEMS_ERROR;
 8013efa:	2300      	movs	r3, #0
 8013efc:	e007      	b.n	8013f0e <LSM303AGR_ACC_R_YDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_YOR_MASK; //mask
 8013efe:	9b00      	ldr	r3, [sp, #0]
 8013f00:	781b      	ldrb	r3, [r3, #0]
 8013f02:	f003 0320 	and.w	r3, r3, #32
 8013f06:	b2da      	uxtb	r2, r3
 8013f08:	9b00      	ldr	r3, [sp, #0]
 8013f0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f0c:	2301      	movs	r3, #1
}
 8013f0e:	4618      	mov	r0, r3
 8013f10:	b003      	add	sp, #12
 8013f12:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f16:	bf00      	nop
 8013f18:	f3af 8000 	nop.w
 8013f1c:	f3af 8000 	nop.w

08013f20 <LSM303AGR_ACC_R_ZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZOR_t
* Output         : Status of ZOR see LSM303AGR_ACC_ZOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDataOverrun(void *handle, LSM303AGR_ACC_ZOR_t *value)
{
 8013f20:	b500      	push	{lr}
 8013f22:	b083      	sub	sp, #12
 8013f24:	9001      	str	r0, [sp, #4]
 8013f26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013f28:	9801      	ldr	r0, [sp, #4]
 8013f2a:	2127      	movs	r1, #39	; 0x27
 8013f2c:	9a00      	ldr	r2, [sp, #0]
 8013f2e:	2301      	movs	r3, #1
 8013f30:	f7fd ff56 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013f34:	4603      	mov	r3, r0
 8013f36:	2b00      	cmp	r3, #0
 8013f38:	d101      	bne.n	8013f3e <LSM303AGR_ACC_R_ZDataOverrun+0x1e>
    return MEMS_ERROR;
 8013f3a:	2300      	movs	r3, #0
 8013f3c:	e007      	b.n	8013f4e <LSM303AGR_ACC_R_ZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZOR_MASK; //mask
 8013f3e:	9b00      	ldr	r3, [sp, #0]
 8013f40:	781b      	ldrb	r3, [r3, #0]
 8013f42:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8013f46:	b2da      	uxtb	r2, r3
 8013f48:	9b00      	ldr	r3, [sp, #0]
 8013f4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f4c:	2301      	movs	r3, #1
}
 8013f4e:	4618      	mov	r0, r3
 8013f50:	b003      	add	sp, #12
 8013f52:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f56:	bf00      	nop
 8013f58:	f3af 8000 	nop.w
 8013f5c:	f3af 8000 	nop.w

08013f60 <LSM303AGR_ACC_R_XYZDataOverrun>:
* Input          : Pointer to LSM303AGR_ACC_ZYXOR_t
* Output         : Status of ZYXOR see LSM303AGR_ACC_ZYXOR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XYZDataOverrun(void *handle, LSM303AGR_ACC_ZYXOR_t *value)
{
 8013f60:	b500      	push	{lr}
 8013f62:	b083      	sub	sp, #12
 8013f64:	9001      	str	r0, [sp, #4]
 8013f66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_STATUS_REG2, (u8_t *)value, 1) )
 8013f68:	9801      	ldr	r0, [sp, #4]
 8013f6a:	2127      	movs	r1, #39	; 0x27
 8013f6c:	9a00      	ldr	r2, [sp, #0]
 8013f6e:	2301      	movs	r3, #1
 8013f70:	f7fd ff36 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013f74:	4603      	mov	r3, r0
 8013f76:	2b00      	cmp	r3, #0
 8013f78:	d101      	bne.n	8013f7e <LSM303AGR_ACC_R_XYZDataOverrun+0x1e>
    return MEMS_ERROR;
 8013f7a:	2300      	movs	r3, #0
 8013f7c:	e007      	b.n	8013f8e <LSM303AGR_ACC_R_XYZDataOverrun+0x2e>

  *value &= LSM303AGR_ACC_ZYXOR_MASK; //mask
 8013f7e:	9b00      	ldr	r3, [sp, #0]
 8013f80:	781b      	ldrb	r3, [r3, #0]
 8013f82:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8013f86:	b2da      	uxtb	r2, r3
 8013f88:	9b00      	ldr	r3, [sp, #0]
 8013f8a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8013f8c:	2301      	movs	r3, #1
}
 8013f8e:	4618      	mov	r0, r3
 8013f90:	b003      	add	sp, #12
 8013f92:	f85d fb04 	ldr.w	pc, [sp], #4
 8013f96:	bf00      	nop
 8013f98:	f3af 8000 	nop.w
 8013f9c:	f3af 8000 	nop.w

08013fa0 <LSM303AGR_ACC_W_FifoThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoThreshold(void *handle, u8_t newValue)
{
 8013fa0:	b500      	push	{lr}
 8013fa2:	b085      	sub	sp, #20
 8013fa4:	9001      	str	r0, [sp, #4]
 8013fa6:	460b      	mov	r3, r1
 8013fa8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_FTH_POSITION; //mask
  newValue &= LSM303AGR_ACC_FTH_MASK; //coerce
 8013fac:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013fb0:	f003 031f 	and.w	r3, r3, #31
 8013fb4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8013fb8:	f10d 030f 	add.w	r3, sp, #15
 8013fbc:	9801      	ldr	r0, [sp, #4]
 8013fbe:	212e      	movs	r1, #46	; 0x2e
 8013fc0:	461a      	mov	r2, r3
 8013fc2:	2301      	movs	r3, #1
 8013fc4:	f7fd ff0c 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8013fc8:	4603      	mov	r3, r0
 8013fca:	2b00      	cmp	r3, #0
 8013fcc:	d101      	bne.n	8013fd2 <LSM303AGR_ACC_W_FifoThreshold+0x32>
    return MEMS_ERROR;
 8013fce:	2300      	movs	r3, #0
 8013fd0:	e01c      	b.n	801400c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  value &= ~LSM303AGR_ACC_FTH_MASK;
 8013fd2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8013fd6:	f023 031f 	bic.w	r3, r3, #31
 8013fda:	b2db      	uxtb	r3, r3
 8013fdc:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8013fe0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8013fe4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8013fe8:	4313      	orrs	r3, r2
 8013fea:	b2db      	uxtb	r3, r3
 8013fec:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8013ff0:	f10d 030f 	add.w	r3, sp, #15
 8013ff4:	9801      	ldr	r0, [sp, #4]
 8013ff6:	212e      	movs	r1, #46	; 0x2e
 8013ff8:	461a      	mov	r2, r3
 8013ffa:	2301      	movs	r3, #1
 8013ffc:	f7fd fec8 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014000:	4603      	mov	r3, r0
 8014002:	2b00      	cmp	r3, #0
 8014004:	d101      	bne.n	801400a <LSM303AGR_ACC_W_FifoThreshold+0x6a>
    return MEMS_ERROR;
 8014006:	2300      	movs	r3, #0
 8014008:	e000      	b.n	801400c <LSM303AGR_ACC_W_FifoThreshold+0x6c>

  return MEMS_SUCCESS;
 801400a:	2301      	movs	r3, #1
}
 801400c:	4618      	mov	r0, r3
 801400e:	b005      	add	sp, #20
 8014010:	f85d fb04 	ldr.w	pc, [sp], #4
 8014014:	f3af 8000 	nop.w
 8014018:	f3af 8000 	nop.w
 801401c:	f3af 8000 	nop.w

08014020 <LSM303AGR_ACC_R_FifoThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of FTH
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoThreshold(void *handle, u8_t *value)
{
 8014020:	b500      	push	{lr}
 8014022:	b083      	sub	sp, #12
 8014024:	9001      	str	r0, [sp, #4]
 8014026:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8014028:	9801      	ldr	r0, [sp, #4]
 801402a:	212e      	movs	r1, #46	; 0x2e
 801402c:	9a00      	ldr	r2, [sp, #0]
 801402e:	2301      	movs	r3, #1
 8014030:	f7fd fed6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014034:	4603      	mov	r3, r0
 8014036:	2b00      	cmp	r3, #0
 8014038:	d101      	bne.n	801403e <LSM303AGR_ACC_R_FifoThreshold+0x1e>
    return MEMS_ERROR;
 801403a:	2300      	movs	r3, #0
 801403c:	e00b      	b.n	8014056 <LSM303AGR_ACC_R_FifoThreshold+0x36>

  *value &= LSM303AGR_ACC_FTH_MASK; //coerce
 801403e:	9b00      	ldr	r3, [sp, #0]
 8014040:	781b      	ldrb	r3, [r3, #0]
 8014042:	f003 031f 	and.w	r3, r3, #31
 8014046:	b2da      	uxtb	r2, r3
 8014048:	9b00      	ldr	r3, [sp, #0]
 801404a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FTH_POSITION; //mask
 801404c:	9b00      	ldr	r3, [sp, #0]
 801404e:	781a      	ldrb	r2, [r3, #0]
 8014050:	9b00      	ldr	r3, [sp, #0]
 8014052:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014054:	2301      	movs	r3, #1
}
 8014056:	4618      	mov	r0, r3
 8014058:	b003      	add	sp, #12
 801405a:	f85d fb04 	ldr.w	pc, [sp], #4
 801405e:	bf00      	nop

08014060 <LSM303AGR_ACC_W_TriggerSel>:
* Input          : LSM303AGR_ACC_TR_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_TriggerSel(void *handle, LSM303AGR_ACC_TR_t newValue)
{
 8014060:	b500      	push	{lr}
 8014062:	b085      	sub	sp, #20
 8014064:	9001      	str	r0, [sp, #4]
 8014066:	460b      	mov	r3, r1
 8014068:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801406c:	f10d 030f 	add.w	r3, sp, #15
 8014070:	9801      	ldr	r0, [sp, #4]
 8014072:	212e      	movs	r1, #46	; 0x2e
 8014074:	461a      	mov	r2, r3
 8014076:	2301      	movs	r3, #1
 8014078:	f7fd feb2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801407c:	4603      	mov	r3, r0
 801407e:	2b00      	cmp	r3, #0
 8014080:	d101      	bne.n	8014086 <LSM303AGR_ACC_W_TriggerSel+0x26>
    return MEMS_ERROR;
 8014082:	2300      	movs	r3, #0
 8014084:	e01c      	b.n	80140c0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  value &= ~LSM303AGR_ACC_TR_MASK;
 8014086:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801408a:	f023 0320 	bic.w	r3, r3, #32
 801408e:	b2db      	uxtb	r3, r3
 8014090:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014094:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014098:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801409c:	4313      	orrs	r3, r2
 801409e:	b2db      	uxtb	r3, r3
 80140a0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 80140a4:	f10d 030f 	add.w	r3, sp, #15
 80140a8:	9801      	ldr	r0, [sp, #4]
 80140aa:	212e      	movs	r1, #46	; 0x2e
 80140ac:	461a      	mov	r2, r3
 80140ae:	2301      	movs	r3, #1
 80140b0:	f7fd fe6e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80140b4:	4603      	mov	r3, r0
 80140b6:	2b00      	cmp	r3, #0
 80140b8:	d101      	bne.n	80140be <LSM303AGR_ACC_W_TriggerSel+0x5e>
    return MEMS_ERROR;
 80140ba:	2300      	movs	r3, #0
 80140bc:	e000      	b.n	80140c0 <LSM303AGR_ACC_W_TriggerSel+0x60>

  return MEMS_SUCCESS;
 80140be:	2301      	movs	r3, #1
}
 80140c0:	4618      	mov	r0, r3
 80140c2:	b005      	add	sp, #20
 80140c4:	f85d fb04 	ldr.w	pc, [sp], #4
 80140c8:	f3af 8000 	nop.w
 80140cc:	f3af 8000 	nop.w

080140d0 <LSM303AGR_ACC_R_TriggerSel>:
* Input          : Pointer to LSM303AGR_ACC_TR_t
* Output         : Status of TR see LSM303AGR_ACC_TR_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_TriggerSel(void *handle, LSM303AGR_ACC_TR_t *value)
{
 80140d0:	b500      	push	{lr}
 80140d2:	b083      	sub	sp, #12
 80140d4:	9001      	str	r0, [sp, #4]
 80140d6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 80140d8:	9801      	ldr	r0, [sp, #4]
 80140da:	212e      	movs	r1, #46	; 0x2e
 80140dc:	9a00      	ldr	r2, [sp, #0]
 80140de:	2301      	movs	r3, #1
 80140e0:	f7fd fe7e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80140e4:	4603      	mov	r3, r0
 80140e6:	2b00      	cmp	r3, #0
 80140e8:	d101      	bne.n	80140ee <LSM303AGR_ACC_R_TriggerSel+0x1e>
    return MEMS_ERROR;
 80140ea:	2300      	movs	r3, #0
 80140ec:	e007      	b.n	80140fe <LSM303AGR_ACC_R_TriggerSel+0x2e>

  *value &= LSM303AGR_ACC_TR_MASK; //mask
 80140ee:	9b00      	ldr	r3, [sp, #0]
 80140f0:	781b      	ldrb	r3, [r3, #0]
 80140f2:	f003 0320 	and.w	r3, r3, #32
 80140f6:	b2da      	uxtb	r2, r3
 80140f8:	9b00      	ldr	r3, [sp, #0]
 80140fa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80140fc:	2301      	movs	r3, #1
}
 80140fe:	4618      	mov	r0, r3
 8014100:	b003      	add	sp, #12
 8014102:	f85d fb04 	ldr.w	pc, [sp], #4
 8014106:	bf00      	nop
 8014108:	f3af 8000 	nop.w
 801410c:	f3af 8000 	nop.w

08014110 <LSM303AGR_ACC_W_FifoMode>:
* Input          : LSM303AGR_ACC_FM_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_FifoMode(void *handle, LSM303AGR_ACC_FM_t newValue)
{
 8014110:	b500      	push	{lr}
 8014112:	b085      	sub	sp, #20
 8014114:	9001      	str	r0, [sp, #4]
 8014116:	460b      	mov	r3, r1
 8014118:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 801411c:	f10d 030f 	add.w	r3, sp, #15
 8014120:	9801      	ldr	r0, [sp, #4]
 8014122:	212e      	movs	r1, #46	; 0x2e
 8014124:	461a      	mov	r2, r3
 8014126:	2301      	movs	r3, #1
 8014128:	f7fd fe5a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801412c:	4603      	mov	r3, r0
 801412e:	2b00      	cmp	r3, #0
 8014130:	d101      	bne.n	8014136 <LSM303AGR_ACC_W_FifoMode+0x26>
    return MEMS_ERROR;
 8014132:	2300      	movs	r3, #0
 8014134:	e01c      	b.n	8014170 <LSM303AGR_ACC_W_FifoMode+0x60>

  value &= ~LSM303AGR_ACC_FM_MASK;
 8014136:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801413a:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 801413e:	b2db      	uxtb	r3, r3
 8014140:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014144:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014148:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801414c:	4313      	orrs	r3, r2
 801414e:	b2db      	uxtb	r3, r3
 8014150:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, &value, 1) )
 8014154:	f10d 030f 	add.w	r3, sp, #15
 8014158:	9801      	ldr	r0, [sp, #4]
 801415a:	212e      	movs	r1, #46	; 0x2e
 801415c:	461a      	mov	r2, r3
 801415e:	2301      	movs	r3, #1
 8014160:	f7fd fe16 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014164:	4603      	mov	r3, r0
 8014166:	2b00      	cmp	r3, #0
 8014168:	d101      	bne.n	801416e <LSM303AGR_ACC_W_FifoMode+0x5e>
    return MEMS_ERROR;
 801416a:	2300      	movs	r3, #0
 801416c:	e000      	b.n	8014170 <LSM303AGR_ACC_W_FifoMode+0x60>

  return MEMS_SUCCESS;
 801416e:	2301      	movs	r3, #1
}
 8014170:	4618      	mov	r0, r3
 8014172:	b005      	add	sp, #20
 8014174:	f85d fb04 	ldr.w	pc, [sp], #4
 8014178:	f3af 8000 	nop.w
 801417c:	f3af 8000 	nop.w

08014180 <LSM303AGR_ACC_R_FifoMode>:
* Input          : Pointer to LSM303AGR_ACC_FM_t
* Output         : Status of FM see LSM303AGR_ACC_FM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoMode(void *handle, LSM303AGR_ACC_FM_t *value)
{
 8014180:	b500      	push	{lr}
 8014182:	b083      	sub	sp, #12
 8014184:	9001      	str	r0, [sp, #4]
 8014186:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_CTRL_REG, (u8_t *)value, 1) )
 8014188:	9801      	ldr	r0, [sp, #4]
 801418a:	212e      	movs	r1, #46	; 0x2e
 801418c:	9a00      	ldr	r2, [sp, #0]
 801418e:	2301      	movs	r3, #1
 8014190:	f7fd fe26 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014194:	4603      	mov	r3, r0
 8014196:	2b00      	cmp	r3, #0
 8014198:	d101      	bne.n	801419e <LSM303AGR_ACC_R_FifoMode+0x1e>
    return MEMS_ERROR;
 801419a:	2300      	movs	r3, #0
 801419c:	e007      	b.n	80141ae <LSM303AGR_ACC_R_FifoMode+0x2e>

  *value &= LSM303AGR_ACC_FM_MASK; //mask
 801419e:	9b00      	ldr	r3, [sp, #0]
 80141a0:	781b      	ldrb	r3, [r3, #0]
 80141a2:	f023 033f 	bic.w	r3, r3, #63	; 0x3f
 80141a6:	b2da      	uxtb	r2, r3
 80141a8:	9b00      	ldr	r3, [sp, #0]
 80141aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80141ac:	2301      	movs	r3, #1
}
 80141ae:	4618      	mov	r0, r3
 80141b0:	b003      	add	sp, #12
 80141b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80141b6:	bf00      	nop
 80141b8:	f3af 8000 	nop.w
 80141bc:	f3af 8000 	nop.w

080141c0 <LSM303AGR_ACC_R_FifoSamplesAvail>:
* Input          : Pointer to u8_t
* Output         : Status of FSS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoSamplesAvail(void *handle, u8_t *value)
{
 80141c0:	b500      	push	{lr}
 80141c2:	b083      	sub	sp, #12
 80141c4:	9001      	str	r0, [sp, #4]
 80141c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 80141c8:	9801      	ldr	r0, [sp, #4]
 80141ca:	212f      	movs	r1, #47	; 0x2f
 80141cc:	9a00      	ldr	r2, [sp, #0]
 80141ce:	2301      	movs	r3, #1
 80141d0:	f7fd fe06 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80141d4:	4603      	mov	r3, r0
 80141d6:	2b00      	cmp	r3, #0
 80141d8:	d101      	bne.n	80141de <LSM303AGR_ACC_R_FifoSamplesAvail+0x1e>
    return MEMS_ERROR;
 80141da:	2300      	movs	r3, #0
 80141dc:	e00b      	b.n	80141f6 <LSM303AGR_ACC_R_FifoSamplesAvail+0x36>

  *value &= LSM303AGR_ACC_FSS_MASK; //coerce
 80141de:	9b00      	ldr	r3, [sp, #0]
 80141e0:	781b      	ldrb	r3, [r3, #0]
 80141e2:	f003 031f 	and.w	r3, r3, #31
 80141e6:	b2da      	uxtb	r2, r3
 80141e8:	9b00      	ldr	r3, [sp, #0]
 80141ea:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_FSS_POSITION; //mask
 80141ec:	9b00      	ldr	r3, [sp, #0]
 80141ee:	781a      	ldrb	r2, [r3, #0]
 80141f0:	9b00      	ldr	r3, [sp, #0]
 80141f2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80141f4:	2301      	movs	r3, #1
}
 80141f6:	4618      	mov	r0, r3
 80141f8:	b003      	add	sp, #12
 80141fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80141fe:	bf00      	nop

08014200 <LSM303AGR_ACC_R_FifoEmpty>:
* Input          : Pointer to LSM303AGR_ACC_EMPTY_t
* Output         : Status of EMPTY see LSM303AGR_ACC_EMPTY_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoEmpty(void *handle, LSM303AGR_ACC_EMPTY_t *value)
{
 8014200:	b500      	push	{lr}
 8014202:	b083      	sub	sp, #12
 8014204:	9001      	str	r0, [sp, #4]
 8014206:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8014208:	9801      	ldr	r0, [sp, #4]
 801420a:	212f      	movs	r1, #47	; 0x2f
 801420c:	9a00      	ldr	r2, [sp, #0]
 801420e:	2301      	movs	r3, #1
 8014210:	f7fd fde6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014214:	4603      	mov	r3, r0
 8014216:	2b00      	cmp	r3, #0
 8014218:	d101      	bne.n	801421e <LSM303AGR_ACC_R_FifoEmpty+0x1e>
    return MEMS_ERROR;
 801421a:	2300      	movs	r3, #0
 801421c:	e007      	b.n	801422e <LSM303AGR_ACC_R_FifoEmpty+0x2e>

  *value &= LSM303AGR_ACC_EMPTY_MASK; //mask
 801421e:	9b00      	ldr	r3, [sp, #0]
 8014220:	781b      	ldrb	r3, [r3, #0]
 8014222:	f003 0320 	and.w	r3, r3, #32
 8014226:	b2da      	uxtb	r2, r3
 8014228:	9b00      	ldr	r3, [sp, #0]
 801422a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801422c:	2301      	movs	r3, #1
}
 801422e:	4618      	mov	r0, r3
 8014230:	b003      	add	sp, #12
 8014232:	f85d fb04 	ldr.w	pc, [sp], #4
 8014236:	bf00      	nop
 8014238:	f3af 8000 	nop.w
 801423c:	f3af 8000 	nop.w

08014240 <LSM303AGR_ACC_R_FifoOverrun>:
* Input          : Pointer to LSM303AGR_ACC_OVRN_FIFO_t
* Output         : Status of OVRN_FIFO see LSM303AGR_ACC_OVRN_FIFO_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_FifoOverrun(void *handle, LSM303AGR_ACC_OVRN_FIFO_t *value)
{
 8014240:	b500      	push	{lr}
 8014242:	b083      	sub	sp, #12
 8014244:	9001      	str	r0, [sp, #4]
 8014246:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8014248:	9801      	ldr	r0, [sp, #4]
 801424a:	212f      	movs	r1, #47	; 0x2f
 801424c:	9a00      	ldr	r2, [sp, #0]
 801424e:	2301      	movs	r3, #1
 8014250:	f7fd fdc6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014254:	4603      	mov	r3, r0
 8014256:	2b00      	cmp	r3, #0
 8014258:	d101      	bne.n	801425e <LSM303AGR_ACC_R_FifoOverrun+0x1e>
    return MEMS_ERROR;
 801425a:	2300      	movs	r3, #0
 801425c:	e007      	b.n	801426e <LSM303AGR_ACC_R_FifoOverrun+0x2e>

  *value &= LSM303AGR_ACC_OVRN_FIFO_MASK; //mask
 801425e:	9b00      	ldr	r3, [sp, #0]
 8014260:	781b      	ldrb	r3, [r3, #0]
 8014262:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014266:	b2da      	uxtb	r2, r3
 8014268:	9b00      	ldr	r3, [sp, #0]
 801426a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801426c:	2301      	movs	r3, #1
}
 801426e:	4618      	mov	r0, r3
 8014270:	b003      	add	sp, #12
 8014272:	f85d fb04 	ldr.w	pc, [sp], #4
 8014276:	bf00      	nop
 8014278:	f3af 8000 	nop.w
 801427c:	f3af 8000 	nop.w

08014280 <LSM303AGR_ACC_R_WatermarkLevel>:
* Input          : Pointer to LSM303AGR_ACC_WTM_t
* Output         : Status of WTM see LSM303AGR_ACC_WTM_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_WatermarkLevel(void *handle, LSM303AGR_ACC_WTM_t *value)
{
 8014280:	b500      	push	{lr}
 8014282:	b083      	sub	sp, #12
 8014284:	9001      	str	r0, [sp, #4]
 8014286:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_FIFO_SRC_REG, (u8_t *)value, 1) )
 8014288:	9801      	ldr	r0, [sp, #4]
 801428a:	212f      	movs	r1, #47	; 0x2f
 801428c:	9a00      	ldr	r2, [sp, #0]
 801428e:	2301      	movs	r3, #1
 8014290:	f7fd fda6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014294:	4603      	mov	r3, r0
 8014296:	2b00      	cmp	r3, #0
 8014298:	d101      	bne.n	801429e <LSM303AGR_ACC_R_WatermarkLevel+0x1e>
    return MEMS_ERROR;
 801429a:	2300      	movs	r3, #0
 801429c:	e007      	b.n	80142ae <LSM303AGR_ACC_R_WatermarkLevel+0x2e>

  *value &= LSM303AGR_ACC_WTM_MASK; //mask
 801429e:	9b00      	ldr	r3, [sp, #0]
 80142a0:	781b      	ldrb	r3, [r3, #0]
 80142a2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80142a6:	b2da      	uxtb	r2, r3
 80142a8:	9b00      	ldr	r3, [sp, #0]
 80142aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80142ac:	2301      	movs	r3, #1
}
 80142ae:	4618      	mov	r0, r3
 80142b0:	b003      	add	sp, #12
 80142b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80142b6:	bf00      	nop
 80142b8:	f3af 8000 	nop.w
 80142bc:	f3af 8000 	nop.w

080142c0 <LSM303AGR_ACC_W_Int1EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 80142c0:	b500      	push	{lr}
 80142c2:	b085      	sub	sp, #20
 80142c4:	9001      	str	r0, [sp, #4]
 80142c6:	460b      	mov	r3, r1
 80142c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80142cc:	f10d 030f 	add.w	r3, sp, #15
 80142d0:	9801      	ldr	r0, [sp, #4]
 80142d2:	2130      	movs	r1, #48	; 0x30
 80142d4:	461a      	mov	r2, r3
 80142d6:	2301      	movs	r3, #1
 80142d8:	f7fd fd82 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80142dc:	4603      	mov	r3, r0
 80142de:	2b00      	cmp	r3, #0
 80142e0:	d101      	bne.n	80142e6 <LSM303AGR_ACC_W_Int1EnXLo+0x26>
    return MEMS_ERROR;
 80142e2:	2300      	movs	r3, #0
 80142e4:	e01c      	b.n	8014320 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 80142e6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80142ea:	f023 0301 	bic.w	r3, r3, #1
 80142ee:	b2db      	uxtb	r3, r3
 80142f0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80142f4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80142f8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80142fc:	4313      	orrs	r3, r2
 80142fe:	b2db      	uxtb	r3, r3
 8014300:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014304:	f10d 030f 	add.w	r3, sp, #15
 8014308:	9801      	ldr	r0, [sp, #4]
 801430a:	2130      	movs	r1, #48	; 0x30
 801430c:	461a      	mov	r2, r3
 801430e:	2301      	movs	r3, #1
 8014310:	f7fd fd3e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014314:	4603      	mov	r3, r0
 8014316:	2b00      	cmp	r3, #0
 8014318:	d101      	bne.n	801431e <LSM303AGR_ACC_W_Int1EnXLo+0x5e>
    return MEMS_ERROR;
 801431a:	2300      	movs	r3, #0
 801431c:	e000      	b.n	8014320 <LSM303AGR_ACC_W_Int1EnXLo+0x60>

  return MEMS_SUCCESS;
 801431e:	2301      	movs	r3, #1
}
 8014320:	4618      	mov	r0, r3
 8014322:	b005      	add	sp, #20
 8014324:	f85d fb04 	ldr.w	pc, [sp], #4
 8014328:	f3af 8000 	nop.w
 801432c:	f3af 8000 	nop.w

08014330 <LSM303AGR_ACC_R_Int1EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 8014330:	b500      	push	{lr}
 8014332:	b083      	sub	sp, #12
 8014334:	9001      	str	r0, [sp, #4]
 8014336:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014338:	9801      	ldr	r0, [sp, #4]
 801433a:	2130      	movs	r1, #48	; 0x30
 801433c:	9a00      	ldr	r2, [sp, #0]
 801433e:	2301      	movs	r3, #1
 8014340:	f7fd fd4e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014344:	4603      	mov	r3, r0
 8014346:	2b00      	cmp	r3, #0
 8014348:	d101      	bne.n	801434e <LSM303AGR_ACC_R_Int1EnXLo+0x1e>
    return MEMS_ERROR;
 801434a:	2300      	movs	r3, #0
 801434c:	e007      	b.n	801435e <LSM303AGR_ACC_R_Int1EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 801434e:	9b00      	ldr	r3, [sp, #0]
 8014350:	781b      	ldrb	r3, [r3, #0]
 8014352:	f003 0301 	and.w	r3, r3, #1
 8014356:	b2da      	uxtb	r2, r3
 8014358:	9b00      	ldr	r3, [sp, #0]
 801435a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801435c:	2301      	movs	r3, #1
}
 801435e:	4618      	mov	r0, r3
 8014360:	b003      	add	sp, #12
 8014362:	f85d fb04 	ldr.w	pc, [sp], #4
 8014366:	bf00      	nop
 8014368:	f3af 8000 	nop.w
 801436c:	f3af 8000 	nop.w

08014370 <LSM303AGR_ACC_W_Int1EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 8014370:	b500      	push	{lr}
 8014372:	b085      	sub	sp, #20
 8014374:	9001      	str	r0, [sp, #4]
 8014376:	460b      	mov	r3, r1
 8014378:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801437c:	f10d 030f 	add.w	r3, sp, #15
 8014380:	9801      	ldr	r0, [sp, #4]
 8014382:	2130      	movs	r1, #48	; 0x30
 8014384:	461a      	mov	r2, r3
 8014386:	2301      	movs	r3, #1
 8014388:	f7fd fd2a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801438c:	4603      	mov	r3, r0
 801438e:	2b00      	cmp	r3, #0
 8014390:	d101      	bne.n	8014396 <LSM303AGR_ACC_W_Int1EnXHi+0x26>
    return MEMS_ERROR;
 8014392:	2300      	movs	r3, #0
 8014394:	e01c      	b.n	80143d0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8014396:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801439a:	f023 0302 	bic.w	r3, r3, #2
 801439e:	b2db      	uxtb	r3, r3
 80143a0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80143a4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80143a8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80143ac:	4313      	orrs	r3, r2
 80143ae:	b2db      	uxtb	r3, r3
 80143b0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80143b4:	f10d 030f 	add.w	r3, sp, #15
 80143b8:	9801      	ldr	r0, [sp, #4]
 80143ba:	2130      	movs	r1, #48	; 0x30
 80143bc:	461a      	mov	r2, r3
 80143be:	2301      	movs	r3, #1
 80143c0:	f7fd fce6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80143c4:	4603      	mov	r3, r0
 80143c6:	2b00      	cmp	r3, #0
 80143c8:	d101      	bne.n	80143ce <LSM303AGR_ACC_W_Int1EnXHi+0x5e>
    return MEMS_ERROR;
 80143ca:	2300      	movs	r3, #0
 80143cc:	e000      	b.n	80143d0 <LSM303AGR_ACC_W_Int1EnXHi+0x60>

  return MEMS_SUCCESS;
 80143ce:	2301      	movs	r3, #1
}
 80143d0:	4618      	mov	r0, r3
 80143d2:	b005      	add	sp, #20
 80143d4:	f85d fb04 	ldr.w	pc, [sp], #4
 80143d8:	f3af 8000 	nop.w
 80143dc:	f3af 8000 	nop.w

080143e0 <LSM303AGR_ACC_R_Int1EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 80143e0:	b500      	push	{lr}
 80143e2:	b083      	sub	sp, #12
 80143e4:	9001      	str	r0, [sp, #4]
 80143e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80143e8:	9801      	ldr	r0, [sp, #4]
 80143ea:	2130      	movs	r1, #48	; 0x30
 80143ec:	9a00      	ldr	r2, [sp, #0]
 80143ee:	2301      	movs	r3, #1
 80143f0:	f7fd fcf6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80143f4:	4603      	mov	r3, r0
 80143f6:	2b00      	cmp	r3, #0
 80143f8:	d101      	bne.n	80143fe <LSM303AGR_ACC_R_Int1EnXHi+0x1e>
    return MEMS_ERROR;
 80143fa:	2300      	movs	r3, #0
 80143fc:	e007      	b.n	801440e <LSM303AGR_ACC_R_Int1EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 80143fe:	9b00      	ldr	r3, [sp, #0]
 8014400:	781b      	ldrb	r3, [r3, #0]
 8014402:	f003 0302 	and.w	r3, r3, #2
 8014406:	b2da      	uxtb	r2, r3
 8014408:	9b00      	ldr	r3, [sp, #0]
 801440a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801440c:	2301      	movs	r3, #1
}
 801440e:	4618      	mov	r0, r3
 8014410:	b003      	add	sp, #12
 8014412:	f85d fb04 	ldr.w	pc, [sp], #4
 8014416:	bf00      	nop
 8014418:	f3af 8000 	nop.w
 801441c:	f3af 8000 	nop.w

08014420 <LSM303AGR_ACC_W_Int1EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 8014420:	b500      	push	{lr}
 8014422:	b085      	sub	sp, #20
 8014424:	9001      	str	r0, [sp, #4]
 8014426:	460b      	mov	r3, r1
 8014428:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801442c:	f10d 030f 	add.w	r3, sp, #15
 8014430:	9801      	ldr	r0, [sp, #4]
 8014432:	2130      	movs	r1, #48	; 0x30
 8014434:	461a      	mov	r2, r3
 8014436:	2301      	movs	r3, #1
 8014438:	f7fd fcd2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801443c:	4603      	mov	r3, r0
 801443e:	2b00      	cmp	r3, #0
 8014440:	d101      	bne.n	8014446 <LSM303AGR_ACC_W_Int1EnYLo+0x26>
    return MEMS_ERROR;
 8014442:	2300      	movs	r3, #0
 8014444:	e01c      	b.n	8014480 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 8014446:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801444a:	f023 0304 	bic.w	r3, r3, #4
 801444e:	b2db      	uxtb	r3, r3
 8014450:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014454:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014458:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801445c:	4313      	orrs	r3, r2
 801445e:	b2db      	uxtb	r3, r3
 8014460:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014464:	f10d 030f 	add.w	r3, sp, #15
 8014468:	9801      	ldr	r0, [sp, #4]
 801446a:	2130      	movs	r1, #48	; 0x30
 801446c:	461a      	mov	r2, r3
 801446e:	2301      	movs	r3, #1
 8014470:	f7fd fc8e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014474:	4603      	mov	r3, r0
 8014476:	2b00      	cmp	r3, #0
 8014478:	d101      	bne.n	801447e <LSM303AGR_ACC_W_Int1EnYLo+0x5e>
    return MEMS_ERROR;
 801447a:	2300      	movs	r3, #0
 801447c:	e000      	b.n	8014480 <LSM303AGR_ACC_W_Int1EnYLo+0x60>

  return MEMS_SUCCESS;
 801447e:	2301      	movs	r3, #1
}
 8014480:	4618      	mov	r0, r3
 8014482:	b005      	add	sp, #20
 8014484:	f85d fb04 	ldr.w	pc, [sp], #4
 8014488:	f3af 8000 	nop.w
 801448c:	f3af 8000 	nop.w

08014490 <LSM303AGR_ACC_R_Int1EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8014490:	b500      	push	{lr}
 8014492:	b083      	sub	sp, #12
 8014494:	9001      	str	r0, [sp, #4]
 8014496:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014498:	9801      	ldr	r0, [sp, #4]
 801449a:	2130      	movs	r1, #48	; 0x30
 801449c:	9a00      	ldr	r2, [sp, #0]
 801449e:	2301      	movs	r3, #1
 80144a0:	f7fd fc9e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80144a4:	4603      	mov	r3, r0
 80144a6:	2b00      	cmp	r3, #0
 80144a8:	d101      	bne.n	80144ae <LSM303AGR_ACC_R_Int1EnYLo+0x1e>
    return MEMS_ERROR;
 80144aa:	2300      	movs	r3, #0
 80144ac:	e007      	b.n	80144be <LSM303AGR_ACC_R_Int1EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 80144ae:	9b00      	ldr	r3, [sp, #0]
 80144b0:	781b      	ldrb	r3, [r3, #0]
 80144b2:	f003 0304 	and.w	r3, r3, #4
 80144b6:	b2da      	uxtb	r2, r3
 80144b8:	9b00      	ldr	r3, [sp, #0]
 80144ba:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80144bc:	2301      	movs	r3, #1
}
 80144be:	4618      	mov	r0, r3
 80144c0:	b003      	add	sp, #12
 80144c2:	f85d fb04 	ldr.w	pc, [sp], #4
 80144c6:	bf00      	nop
 80144c8:	f3af 8000 	nop.w
 80144cc:	f3af 8000 	nop.w

080144d0 <LSM303AGR_ACC_W_Int1EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 80144d0:	b500      	push	{lr}
 80144d2:	b085      	sub	sp, #20
 80144d4:	9001      	str	r0, [sp, #4]
 80144d6:	460b      	mov	r3, r1
 80144d8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80144dc:	f10d 030f 	add.w	r3, sp, #15
 80144e0:	9801      	ldr	r0, [sp, #4]
 80144e2:	2130      	movs	r1, #48	; 0x30
 80144e4:	461a      	mov	r2, r3
 80144e6:	2301      	movs	r3, #1
 80144e8:	f7fd fc7a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80144ec:	4603      	mov	r3, r0
 80144ee:	2b00      	cmp	r3, #0
 80144f0:	d101      	bne.n	80144f6 <LSM303AGR_ACC_W_Int1EnYHi+0x26>
    return MEMS_ERROR;
 80144f2:	2300      	movs	r3, #0
 80144f4:	e01c      	b.n	8014530 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 80144f6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80144fa:	f023 0308 	bic.w	r3, r3, #8
 80144fe:	b2db      	uxtb	r3, r3
 8014500:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014504:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014508:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801450c:	4313      	orrs	r3, r2
 801450e:	b2db      	uxtb	r3, r3
 8014510:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014514:	f10d 030f 	add.w	r3, sp, #15
 8014518:	9801      	ldr	r0, [sp, #4]
 801451a:	2130      	movs	r1, #48	; 0x30
 801451c:	461a      	mov	r2, r3
 801451e:	2301      	movs	r3, #1
 8014520:	f7fd fc36 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014524:	4603      	mov	r3, r0
 8014526:	2b00      	cmp	r3, #0
 8014528:	d101      	bne.n	801452e <LSM303AGR_ACC_W_Int1EnYHi+0x5e>
    return MEMS_ERROR;
 801452a:	2300      	movs	r3, #0
 801452c:	e000      	b.n	8014530 <LSM303AGR_ACC_W_Int1EnYHi+0x60>

  return MEMS_SUCCESS;
 801452e:	2301      	movs	r3, #1
}
 8014530:	4618      	mov	r0, r3
 8014532:	b005      	add	sp, #20
 8014534:	f85d fb04 	ldr.w	pc, [sp], #4
 8014538:	f3af 8000 	nop.w
 801453c:	f3af 8000 	nop.w

08014540 <LSM303AGR_ACC_R_Int1EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8014540:	b500      	push	{lr}
 8014542:	b083      	sub	sp, #12
 8014544:	9001      	str	r0, [sp, #4]
 8014546:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014548:	9801      	ldr	r0, [sp, #4]
 801454a:	2130      	movs	r1, #48	; 0x30
 801454c:	9a00      	ldr	r2, [sp, #0]
 801454e:	2301      	movs	r3, #1
 8014550:	f7fd fc46 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014554:	4603      	mov	r3, r0
 8014556:	2b00      	cmp	r3, #0
 8014558:	d101      	bne.n	801455e <LSM303AGR_ACC_R_Int1EnYHi+0x1e>
    return MEMS_ERROR;
 801455a:	2300      	movs	r3, #0
 801455c:	e007      	b.n	801456e <LSM303AGR_ACC_R_Int1EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 801455e:	9b00      	ldr	r3, [sp, #0]
 8014560:	781b      	ldrb	r3, [r3, #0]
 8014562:	f003 0308 	and.w	r3, r3, #8
 8014566:	b2da      	uxtb	r2, r3
 8014568:	9b00      	ldr	r3, [sp, #0]
 801456a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801456c:	2301      	movs	r3, #1
}
 801456e:	4618      	mov	r0, r3
 8014570:	b003      	add	sp, #12
 8014572:	f85d fb04 	ldr.w	pc, [sp], #4
 8014576:	bf00      	nop
 8014578:	f3af 8000 	nop.w
 801457c:	f3af 8000 	nop.w

08014580 <LSM303AGR_ACC_W_Int1EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8014580:	b500      	push	{lr}
 8014582:	b085      	sub	sp, #20
 8014584:	9001      	str	r0, [sp, #4]
 8014586:	460b      	mov	r3, r1
 8014588:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801458c:	f10d 030f 	add.w	r3, sp, #15
 8014590:	9801      	ldr	r0, [sp, #4]
 8014592:	2130      	movs	r1, #48	; 0x30
 8014594:	461a      	mov	r2, r3
 8014596:	2301      	movs	r3, #1
 8014598:	f7fd fc22 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801459c:	4603      	mov	r3, r0
 801459e:	2b00      	cmp	r3, #0
 80145a0:	d101      	bne.n	80145a6 <LSM303AGR_ACC_W_Int1EnZLo+0x26>
    return MEMS_ERROR;
 80145a2:	2300      	movs	r3, #0
 80145a4:	e01c      	b.n	80145e0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 80145a6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80145aa:	f023 0310 	bic.w	r3, r3, #16
 80145ae:	b2db      	uxtb	r3, r3
 80145b0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80145b4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80145b8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80145bc:	4313      	orrs	r3, r2
 80145be:	b2db      	uxtb	r3, r3
 80145c0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80145c4:	f10d 030f 	add.w	r3, sp, #15
 80145c8:	9801      	ldr	r0, [sp, #4]
 80145ca:	2130      	movs	r1, #48	; 0x30
 80145cc:	461a      	mov	r2, r3
 80145ce:	2301      	movs	r3, #1
 80145d0:	f7fd fbde 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80145d4:	4603      	mov	r3, r0
 80145d6:	2b00      	cmp	r3, #0
 80145d8:	d101      	bne.n	80145de <LSM303AGR_ACC_W_Int1EnZLo+0x5e>
    return MEMS_ERROR;
 80145da:	2300      	movs	r3, #0
 80145dc:	e000      	b.n	80145e0 <LSM303AGR_ACC_W_Int1EnZLo+0x60>

  return MEMS_SUCCESS;
 80145de:	2301      	movs	r3, #1
}
 80145e0:	4618      	mov	r0, r3
 80145e2:	b005      	add	sp, #20
 80145e4:	f85d fb04 	ldr.w	pc, [sp], #4
 80145e8:	f3af 8000 	nop.w
 80145ec:	f3af 8000 	nop.w

080145f0 <LSM303AGR_ACC_R_Int1EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 80145f0:	b500      	push	{lr}
 80145f2:	b083      	sub	sp, #12
 80145f4:	9001      	str	r0, [sp, #4]
 80145f6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80145f8:	9801      	ldr	r0, [sp, #4]
 80145fa:	2130      	movs	r1, #48	; 0x30
 80145fc:	9a00      	ldr	r2, [sp, #0]
 80145fe:	2301      	movs	r3, #1
 8014600:	f7fd fbee 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014604:	4603      	mov	r3, r0
 8014606:	2b00      	cmp	r3, #0
 8014608:	d101      	bne.n	801460e <LSM303AGR_ACC_R_Int1EnZLo+0x1e>
    return MEMS_ERROR;
 801460a:	2300      	movs	r3, #0
 801460c:	e007      	b.n	801461e <LSM303AGR_ACC_R_Int1EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 801460e:	9b00      	ldr	r3, [sp, #0]
 8014610:	781b      	ldrb	r3, [r3, #0]
 8014612:	f003 0310 	and.w	r3, r3, #16
 8014616:	b2da      	uxtb	r2, r3
 8014618:	9b00      	ldr	r3, [sp, #0]
 801461a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801461c:	2301      	movs	r3, #1
}
 801461e:	4618      	mov	r0, r3
 8014620:	b003      	add	sp, #12
 8014622:	f85d fb04 	ldr.w	pc, [sp], #4
 8014626:	bf00      	nop
 8014628:	f3af 8000 	nop.w
 801462c:	f3af 8000 	nop.w

08014630 <LSM303AGR_ACC_W_Int1EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8014630:	b500      	push	{lr}
 8014632:	b085      	sub	sp, #20
 8014634:	9001      	str	r0, [sp, #4]
 8014636:	460b      	mov	r3, r1
 8014638:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801463c:	f10d 030f 	add.w	r3, sp, #15
 8014640:	9801      	ldr	r0, [sp, #4]
 8014642:	2130      	movs	r1, #48	; 0x30
 8014644:	461a      	mov	r2, r3
 8014646:	2301      	movs	r3, #1
 8014648:	f7fd fbca 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801464c:	4603      	mov	r3, r0
 801464e:	2b00      	cmp	r3, #0
 8014650:	d101      	bne.n	8014656 <LSM303AGR_ACC_W_Int1EnZHi+0x26>
    return MEMS_ERROR;
 8014652:	2300      	movs	r3, #0
 8014654:	e01c      	b.n	8014690 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8014656:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801465a:	f023 0320 	bic.w	r3, r3, #32
 801465e:	b2db      	uxtb	r3, r3
 8014660:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014664:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014668:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801466c:	4313      	orrs	r3, r2
 801466e:	b2db      	uxtb	r3, r3
 8014670:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014674:	f10d 030f 	add.w	r3, sp, #15
 8014678:	9801      	ldr	r0, [sp, #4]
 801467a:	2130      	movs	r1, #48	; 0x30
 801467c:	461a      	mov	r2, r3
 801467e:	2301      	movs	r3, #1
 8014680:	f7fd fb86 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014684:	4603      	mov	r3, r0
 8014686:	2b00      	cmp	r3, #0
 8014688:	d101      	bne.n	801468e <LSM303AGR_ACC_W_Int1EnZHi+0x5e>
    return MEMS_ERROR;
 801468a:	2300      	movs	r3, #0
 801468c:	e000      	b.n	8014690 <LSM303AGR_ACC_W_Int1EnZHi+0x60>

  return MEMS_SUCCESS;
 801468e:	2301      	movs	r3, #1
}
 8014690:	4618      	mov	r0, r3
 8014692:	b005      	add	sp, #20
 8014694:	f85d fb04 	ldr.w	pc, [sp], #4
 8014698:	f3af 8000 	nop.w
 801469c:	f3af 8000 	nop.w

080146a0 <LSM303AGR_ACC_R_Int1EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 80146a0:	b500      	push	{lr}
 80146a2:	b083      	sub	sp, #12
 80146a4:	9001      	str	r0, [sp, #4]
 80146a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 80146a8:	9801      	ldr	r0, [sp, #4]
 80146aa:	2130      	movs	r1, #48	; 0x30
 80146ac:	9a00      	ldr	r2, [sp, #0]
 80146ae:	2301      	movs	r3, #1
 80146b0:	f7fd fb96 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80146b4:	4603      	mov	r3, r0
 80146b6:	2b00      	cmp	r3, #0
 80146b8:	d101      	bne.n	80146be <LSM303AGR_ACC_R_Int1EnZHi+0x1e>
    return MEMS_ERROR;
 80146ba:	2300      	movs	r3, #0
 80146bc:	e007      	b.n	80146ce <LSM303AGR_ACC_R_Int1EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 80146be:	9b00      	ldr	r3, [sp, #0]
 80146c0:	781b      	ldrb	r3, [r3, #0]
 80146c2:	f003 0320 	and.w	r3, r3, #32
 80146c6:	b2da      	uxtb	r2, r3
 80146c8:	9b00      	ldr	r3, [sp, #0]
 80146ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80146cc:	2301      	movs	r3, #1
}
 80146ce:	4618      	mov	r0, r3
 80146d0:	b003      	add	sp, #12
 80146d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80146d6:	bf00      	nop
 80146d8:	f3af 8000 	nop.w
 80146dc:	f3af 8000 	nop.w

080146e0 <LSM303AGR_ACC_W_Int1_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 80146e0:	b500      	push	{lr}
 80146e2:	b085      	sub	sp, #20
 80146e4:	9001      	str	r0, [sp, #4]
 80146e6:	460b      	mov	r3, r1
 80146e8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80146ec:	f10d 030f 	add.w	r3, sp, #15
 80146f0:	9801      	ldr	r0, [sp, #4]
 80146f2:	2130      	movs	r1, #48	; 0x30
 80146f4:	461a      	mov	r2, r3
 80146f6:	2301      	movs	r3, #1
 80146f8:	f7fd fb72 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80146fc:	4603      	mov	r3, r0
 80146fe:	2b00      	cmp	r3, #0
 8014700:	d101      	bne.n	8014706 <LSM303AGR_ACC_W_Int1_6D+0x26>
    return MEMS_ERROR;
 8014702:	2300      	movs	r3, #0
 8014704:	e01c      	b.n	8014740 <LSM303AGR_ACC_W_Int1_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8014706:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801470a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 801470e:	b2db      	uxtb	r3, r3
 8014710:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014714:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014718:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801471c:	4313      	orrs	r3, r2
 801471e:	b2db      	uxtb	r3, r3
 8014720:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 8014724:	f10d 030f 	add.w	r3, sp, #15
 8014728:	9801      	ldr	r0, [sp, #4]
 801472a:	2130      	movs	r1, #48	; 0x30
 801472c:	461a      	mov	r2, r3
 801472e:	2301      	movs	r3, #1
 8014730:	f7fd fb2e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014734:	4603      	mov	r3, r0
 8014736:	2b00      	cmp	r3, #0
 8014738:	d101      	bne.n	801473e <LSM303AGR_ACC_W_Int1_6D+0x5e>
    return MEMS_ERROR;
 801473a:	2300      	movs	r3, #0
 801473c:	e000      	b.n	8014740 <LSM303AGR_ACC_W_Int1_6D+0x60>

  return MEMS_SUCCESS;
 801473e:	2301      	movs	r3, #1
}
 8014740:	4618      	mov	r0, r3
 8014742:	b005      	add	sp, #20
 8014744:	f85d fb04 	ldr.w	pc, [sp], #4
 8014748:	f3af 8000 	nop.w
 801474c:	f3af 8000 	nop.w

08014750 <LSM303AGR_ACC_R_Int1_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8014750:	b500      	push	{lr}
 8014752:	b083      	sub	sp, #12
 8014754:	9001      	str	r0, [sp, #4]
 8014756:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014758:	9801      	ldr	r0, [sp, #4]
 801475a:	2130      	movs	r1, #48	; 0x30
 801475c:	9a00      	ldr	r2, [sp, #0]
 801475e:	2301      	movs	r3, #1
 8014760:	f7fd fb3e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014764:	4603      	mov	r3, r0
 8014766:	2b00      	cmp	r3, #0
 8014768:	d101      	bne.n	801476e <LSM303AGR_ACC_R_Int1_6D+0x1e>
    return MEMS_ERROR;
 801476a:	2300      	movs	r3, #0
 801476c:	e007      	b.n	801477e <LSM303AGR_ACC_R_Int1_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 801476e:	9b00      	ldr	r3, [sp, #0]
 8014770:	781b      	ldrb	r3, [r3, #0]
 8014772:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014776:	b2da      	uxtb	r2, r3
 8014778:	9b00      	ldr	r3, [sp, #0]
 801477a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801477c:	2301      	movs	r3, #1
}
 801477e:	4618      	mov	r0, r3
 8014780:	b003      	add	sp, #12
 8014782:	f85d fb04 	ldr.w	pc, [sp], #4
 8014786:	bf00      	nop
 8014788:	f3af 8000 	nop.w
 801478c:	f3af 8000 	nop.w

08014790 <LSM303AGR_ACC_W_Int1_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8014790:	b500      	push	{lr}
 8014792:	b085      	sub	sp, #20
 8014794:	9001      	str	r0, [sp, #4]
 8014796:	460b      	mov	r3, r1
 8014798:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 801479c:	f10d 030f 	add.w	r3, sp, #15
 80147a0:	9801      	ldr	r0, [sp, #4]
 80147a2:	2130      	movs	r1, #48	; 0x30
 80147a4:	461a      	mov	r2, r3
 80147a6:	2301      	movs	r3, #1
 80147a8:	f7fd fb1a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80147ac:	4603      	mov	r3, r0
 80147ae:	2b00      	cmp	r3, #0
 80147b0:	d101      	bne.n	80147b6 <LSM303AGR_ACC_W_Int1_AOI+0x26>
    return MEMS_ERROR;
 80147b2:	2300      	movs	r3, #0
 80147b4:	e01c      	b.n	80147f0 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 80147b6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80147ba:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80147be:	b2db      	uxtb	r3, r3
 80147c0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80147c4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80147c8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80147cc:	4313      	orrs	r3, r2
 80147ce:	b2db      	uxtb	r3, r3
 80147d0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_CFG, &value, 1) )
 80147d4:	f10d 030f 	add.w	r3, sp, #15
 80147d8:	9801      	ldr	r0, [sp, #4]
 80147da:	2130      	movs	r1, #48	; 0x30
 80147dc:	461a      	mov	r2, r3
 80147de:	2301      	movs	r3, #1
 80147e0:	f7fd fad6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80147e4:	4603      	mov	r3, r0
 80147e6:	2b00      	cmp	r3, #0
 80147e8:	d101      	bne.n	80147ee <LSM303AGR_ACC_W_Int1_AOI+0x5e>
    return MEMS_ERROR;
 80147ea:	2300      	movs	r3, #0
 80147ec:	e000      	b.n	80147f0 <LSM303AGR_ACC_W_Int1_AOI+0x60>

  return MEMS_SUCCESS;
 80147ee:	2301      	movs	r3, #1
}
 80147f0:	4618      	mov	r0, r3
 80147f2:	b005      	add	sp, #20
 80147f4:	f85d fb04 	ldr.w	pc, [sp], #4
 80147f8:	f3af 8000 	nop.w
 80147fc:	f3af 8000 	nop.w

08014800 <LSM303AGR_ACC_R_Int1_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8014800:	b500      	push	{lr}
 8014802:	b083      	sub	sp, #12
 8014804:	9001      	str	r0, [sp, #4]
 8014806:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_CFG, (u8_t *)value, 1) )
 8014808:	9801      	ldr	r0, [sp, #4]
 801480a:	2130      	movs	r1, #48	; 0x30
 801480c:	9a00      	ldr	r2, [sp, #0]
 801480e:	2301      	movs	r3, #1
 8014810:	f7fd fae6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014814:	4603      	mov	r3, r0
 8014816:	2b00      	cmp	r3, #0
 8014818:	d101      	bne.n	801481e <LSM303AGR_ACC_R_Int1_AOI+0x1e>
    return MEMS_ERROR;
 801481a:	2300      	movs	r3, #0
 801481c:	e007      	b.n	801482e <LSM303AGR_ACC_R_Int1_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 801481e:	9b00      	ldr	r3, [sp, #0]
 8014820:	781b      	ldrb	r3, [r3, #0]
 8014822:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014826:	b2da      	uxtb	r2, r3
 8014828:	9b00      	ldr	r3, [sp, #0]
 801482a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801482c:	2301      	movs	r3, #1
}
 801482e:	4618      	mov	r0, r3
 8014830:	b003      	add	sp, #12
 8014832:	f85d fb04 	ldr.w	pc, [sp], #4
 8014836:	bf00      	nop
 8014838:	f3af 8000 	nop.w
 801483c:	f3af 8000 	nop.w

08014840 <LSM303AGR_ACC_W_Int2EnXLo>:
* Input          : LSM303AGR_ACC_XLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t newValue)
{
 8014840:	b500      	push	{lr}
 8014842:	b085      	sub	sp, #20
 8014844:	9001      	str	r0, [sp, #4]
 8014846:	460b      	mov	r3, r1
 8014848:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 801484c:	f10d 030f 	add.w	r3, sp, #15
 8014850:	9801      	ldr	r0, [sp, #4]
 8014852:	2134      	movs	r1, #52	; 0x34
 8014854:	461a      	mov	r2, r3
 8014856:	2301      	movs	r3, #1
 8014858:	f7fd fac2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801485c:	4603      	mov	r3, r0
 801485e:	2b00      	cmp	r3, #0
 8014860:	d101      	bne.n	8014866 <LSM303AGR_ACC_W_Int2EnXLo+0x26>
    return MEMS_ERROR;
 8014862:	2300      	movs	r3, #0
 8014864:	e01c      	b.n	80148a0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  value &= ~LSM303AGR_ACC_XLIE_MASK;
 8014866:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801486a:	f023 0301 	bic.w	r3, r3, #1
 801486e:	b2db      	uxtb	r3, r3
 8014870:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014874:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014878:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801487c:	4313      	orrs	r3, r2
 801487e:	b2db      	uxtb	r3, r3
 8014880:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014884:	f10d 030f 	add.w	r3, sp, #15
 8014888:	9801      	ldr	r0, [sp, #4]
 801488a:	2134      	movs	r1, #52	; 0x34
 801488c:	461a      	mov	r2, r3
 801488e:	2301      	movs	r3, #1
 8014890:	f7fd fa7e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014894:	4603      	mov	r3, r0
 8014896:	2b00      	cmp	r3, #0
 8014898:	d101      	bne.n	801489e <LSM303AGR_ACC_W_Int2EnXLo+0x5e>
    return MEMS_ERROR;
 801489a:	2300      	movs	r3, #0
 801489c:	e000      	b.n	80148a0 <LSM303AGR_ACC_W_Int2EnXLo+0x60>

  return MEMS_SUCCESS;
 801489e:	2301      	movs	r3, #1
}
 80148a0:	4618      	mov	r0, r3
 80148a2:	b005      	add	sp, #20
 80148a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80148a8:	f3af 8000 	nop.w
 80148ac:	f3af 8000 	nop.w

080148b0 <LSM303AGR_ACC_R_Int2EnXLo>:
* Input          : Pointer to LSM303AGR_ACC_XLIE_t
* Output         : Status of XLIE see LSM303AGR_ACC_XLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXLo(void *handle, LSM303AGR_ACC_XLIE_t *value)
{
 80148b0:	b500      	push	{lr}
 80148b2:	b083      	sub	sp, #12
 80148b4:	9001      	str	r0, [sp, #4]
 80148b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 80148b8:	9801      	ldr	r0, [sp, #4]
 80148ba:	2134      	movs	r1, #52	; 0x34
 80148bc:	9a00      	ldr	r2, [sp, #0]
 80148be:	2301      	movs	r3, #1
 80148c0:	f7fd fa8e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80148c4:	4603      	mov	r3, r0
 80148c6:	2b00      	cmp	r3, #0
 80148c8:	d101      	bne.n	80148ce <LSM303AGR_ACC_R_Int2EnXLo+0x1e>
    return MEMS_ERROR;
 80148ca:	2300      	movs	r3, #0
 80148cc:	e007      	b.n	80148de <LSM303AGR_ACC_R_Int2EnXLo+0x2e>

  *value &= LSM303AGR_ACC_XLIE_MASK; //mask
 80148ce:	9b00      	ldr	r3, [sp, #0]
 80148d0:	781b      	ldrb	r3, [r3, #0]
 80148d2:	f003 0301 	and.w	r3, r3, #1
 80148d6:	b2da      	uxtb	r2, r3
 80148d8:	9b00      	ldr	r3, [sp, #0]
 80148da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80148dc:	2301      	movs	r3, #1
}
 80148de:	4618      	mov	r0, r3
 80148e0:	b003      	add	sp, #12
 80148e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80148e6:	bf00      	nop
 80148e8:	f3af 8000 	nop.w
 80148ec:	f3af 8000 	nop.w

080148f0 <LSM303AGR_ACC_W_Int2EnXHi>:
* Input          : LSM303AGR_ACC_XHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t newValue)
{
 80148f0:	b500      	push	{lr}
 80148f2:	b085      	sub	sp, #20
 80148f4:	9001      	str	r0, [sp, #4]
 80148f6:	460b      	mov	r3, r1
 80148f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80148fc:	f10d 030f 	add.w	r3, sp, #15
 8014900:	9801      	ldr	r0, [sp, #4]
 8014902:	2134      	movs	r1, #52	; 0x34
 8014904:	461a      	mov	r2, r3
 8014906:	2301      	movs	r3, #1
 8014908:	f7fd fa6a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801490c:	4603      	mov	r3, r0
 801490e:	2b00      	cmp	r3, #0
 8014910:	d101      	bne.n	8014916 <LSM303AGR_ACC_W_Int2EnXHi+0x26>
    return MEMS_ERROR;
 8014912:	2300      	movs	r3, #0
 8014914:	e01c      	b.n	8014950 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  value &= ~LSM303AGR_ACC_XHIE_MASK;
 8014916:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801491a:	f023 0302 	bic.w	r3, r3, #2
 801491e:	b2db      	uxtb	r3, r3
 8014920:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014924:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014928:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801492c:	4313      	orrs	r3, r2
 801492e:	b2db      	uxtb	r3, r3
 8014930:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014934:	f10d 030f 	add.w	r3, sp, #15
 8014938:	9801      	ldr	r0, [sp, #4]
 801493a:	2134      	movs	r1, #52	; 0x34
 801493c:	461a      	mov	r2, r3
 801493e:	2301      	movs	r3, #1
 8014940:	f7fd fa26 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014944:	4603      	mov	r3, r0
 8014946:	2b00      	cmp	r3, #0
 8014948:	d101      	bne.n	801494e <LSM303AGR_ACC_W_Int2EnXHi+0x5e>
    return MEMS_ERROR;
 801494a:	2300      	movs	r3, #0
 801494c:	e000      	b.n	8014950 <LSM303AGR_ACC_W_Int2EnXHi+0x60>

  return MEMS_SUCCESS;
 801494e:	2301      	movs	r3, #1
}
 8014950:	4618      	mov	r0, r3
 8014952:	b005      	add	sp, #20
 8014954:	f85d fb04 	ldr.w	pc, [sp], #4
 8014958:	f3af 8000 	nop.w
 801495c:	f3af 8000 	nop.w

08014960 <LSM303AGR_ACC_R_Int2EnXHi>:
* Input          : Pointer to LSM303AGR_ACC_XHIE_t
* Output         : Status of XHIE see LSM303AGR_ACC_XHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnXHi(void *handle, LSM303AGR_ACC_XHIE_t *value)
{
 8014960:	b500      	push	{lr}
 8014962:	b083      	sub	sp, #12
 8014964:	9001      	str	r0, [sp, #4]
 8014966:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014968:	9801      	ldr	r0, [sp, #4]
 801496a:	2134      	movs	r1, #52	; 0x34
 801496c:	9a00      	ldr	r2, [sp, #0]
 801496e:	2301      	movs	r3, #1
 8014970:	f7fd fa36 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014974:	4603      	mov	r3, r0
 8014976:	2b00      	cmp	r3, #0
 8014978:	d101      	bne.n	801497e <LSM303AGR_ACC_R_Int2EnXHi+0x1e>
    return MEMS_ERROR;
 801497a:	2300      	movs	r3, #0
 801497c:	e007      	b.n	801498e <LSM303AGR_ACC_R_Int2EnXHi+0x2e>

  *value &= LSM303AGR_ACC_XHIE_MASK; //mask
 801497e:	9b00      	ldr	r3, [sp, #0]
 8014980:	781b      	ldrb	r3, [r3, #0]
 8014982:	f003 0302 	and.w	r3, r3, #2
 8014986:	b2da      	uxtb	r2, r3
 8014988:	9b00      	ldr	r3, [sp, #0]
 801498a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801498c:	2301      	movs	r3, #1
}
 801498e:	4618      	mov	r0, r3
 8014990:	b003      	add	sp, #12
 8014992:	f85d fb04 	ldr.w	pc, [sp], #4
 8014996:	bf00      	nop
 8014998:	f3af 8000 	nop.w
 801499c:	f3af 8000 	nop.w

080149a0 <LSM303AGR_ACC_W_Int2EnYLo>:
* Input          : LSM303AGR_ACC_YLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t newValue)
{
 80149a0:	b500      	push	{lr}
 80149a2:	b085      	sub	sp, #20
 80149a4:	9001      	str	r0, [sp, #4]
 80149a6:	460b      	mov	r3, r1
 80149a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80149ac:	f10d 030f 	add.w	r3, sp, #15
 80149b0:	9801      	ldr	r0, [sp, #4]
 80149b2:	2134      	movs	r1, #52	; 0x34
 80149b4:	461a      	mov	r2, r3
 80149b6:	2301      	movs	r3, #1
 80149b8:	f7fd fa12 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80149bc:	4603      	mov	r3, r0
 80149be:	2b00      	cmp	r3, #0
 80149c0:	d101      	bne.n	80149c6 <LSM303AGR_ACC_W_Int2EnYLo+0x26>
    return MEMS_ERROR;
 80149c2:	2300      	movs	r3, #0
 80149c4:	e01c      	b.n	8014a00 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  value &= ~LSM303AGR_ACC_YLIE_MASK;
 80149c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80149ca:	f023 0304 	bic.w	r3, r3, #4
 80149ce:	b2db      	uxtb	r3, r3
 80149d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80149d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80149d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80149dc:	4313      	orrs	r3, r2
 80149de:	b2db      	uxtb	r3, r3
 80149e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 80149e4:	f10d 030f 	add.w	r3, sp, #15
 80149e8:	9801      	ldr	r0, [sp, #4]
 80149ea:	2134      	movs	r1, #52	; 0x34
 80149ec:	461a      	mov	r2, r3
 80149ee:	2301      	movs	r3, #1
 80149f0:	f7fd f9ce 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80149f4:	4603      	mov	r3, r0
 80149f6:	2b00      	cmp	r3, #0
 80149f8:	d101      	bne.n	80149fe <LSM303AGR_ACC_W_Int2EnYLo+0x5e>
    return MEMS_ERROR;
 80149fa:	2300      	movs	r3, #0
 80149fc:	e000      	b.n	8014a00 <LSM303AGR_ACC_W_Int2EnYLo+0x60>

  return MEMS_SUCCESS;
 80149fe:	2301      	movs	r3, #1
}
 8014a00:	4618      	mov	r0, r3
 8014a02:	b005      	add	sp, #20
 8014a04:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a08:	f3af 8000 	nop.w
 8014a0c:	f3af 8000 	nop.w

08014a10 <LSM303AGR_ACC_R_Int2EnYLo>:
* Input          : Pointer to LSM303AGR_ACC_YLIE_t
* Output         : Status of YLIE see LSM303AGR_ACC_YLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYLo(void *handle, LSM303AGR_ACC_YLIE_t *value)
{
 8014a10:	b500      	push	{lr}
 8014a12:	b083      	sub	sp, #12
 8014a14:	9001      	str	r0, [sp, #4]
 8014a16:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014a18:	9801      	ldr	r0, [sp, #4]
 8014a1a:	2134      	movs	r1, #52	; 0x34
 8014a1c:	9a00      	ldr	r2, [sp, #0]
 8014a1e:	2301      	movs	r3, #1
 8014a20:	f7fd f9de 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014a24:	4603      	mov	r3, r0
 8014a26:	2b00      	cmp	r3, #0
 8014a28:	d101      	bne.n	8014a2e <LSM303AGR_ACC_R_Int2EnYLo+0x1e>
    return MEMS_ERROR;
 8014a2a:	2300      	movs	r3, #0
 8014a2c:	e007      	b.n	8014a3e <LSM303AGR_ACC_R_Int2EnYLo+0x2e>

  *value &= LSM303AGR_ACC_YLIE_MASK; //mask
 8014a2e:	9b00      	ldr	r3, [sp, #0]
 8014a30:	781b      	ldrb	r3, [r3, #0]
 8014a32:	f003 0304 	and.w	r3, r3, #4
 8014a36:	b2da      	uxtb	r2, r3
 8014a38:	9b00      	ldr	r3, [sp, #0]
 8014a3a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014a3c:	2301      	movs	r3, #1
}
 8014a3e:	4618      	mov	r0, r3
 8014a40:	b003      	add	sp, #12
 8014a42:	f85d fb04 	ldr.w	pc, [sp], #4
 8014a46:	bf00      	nop
 8014a48:	f3af 8000 	nop.w
 8014a4c:	f3af 8000 	nop.w

08014a50 <LSM303AGR_ACC_W_Int2EnYHi>:
* Input          : LSM303AGR_ACC_YHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t newValue)
{
 8014a50:	b500      	push	{lr}
 8014a52:	b085      	sub	sp, #20
 8014a54:	9001      	str	r0, [sp, #4]
 8014a56:	460b      	mov	r3, r1
 8014a58:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014a5c:	f10d 030f 	add.w	r3, sp, #15
 8014a60:	9801      	ldr	r0, [sp, #4]
 8014a62:	2134      	movs	r1, #52	; 0x34
 8014a64:	461a      	mov	r2, r3
 8014a66:	2301      	movs	r3, #1
 8014a68:	f7fd f9ba 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014a6c:	4603      	mov	r3, r0
 8014a6e:	2b00      	cmp	r3, #0
 8014a70:	d101      	bne.n	8014a76 <LSM303AGR_ACC_W_Int2EnYHi+0x26>
    return MEMS_ERROR;
 8014a72:	2300      	movs	r3, #0
 8014a74:	e01c      	b.n	8014ab0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  value &= ~LSM303AGR_ACC_YHIE_MASK;
 8014a76:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014a7a:	f023 0308 	bic.w	r3, r3, #8
 8014a7e:	b2db      	uxtb	r3, r3
 8014a80:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014a84:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014a88:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014a8c:	4313      	orrs	r3, r2
 8014a8e:	b2db      	uxtb	r3, r3
 8014a90:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014a94:	f10d 030f 	add.w	r3, sp, #15
 8014a98:	9801      	ldr	r0, [sp, #4]
 8014a9a:	2134      	movs	r1, #52	; 0x34
 8014a9c:	461a      	mov	r2, r3
 8014a9e:	2301      	movs	r3, #1
 8014aa0:	f7fd f976 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014aa4:	4603      	mov	r3, r0
 8014aa6:	2b00      	cmp	r3, #0
 8014aa8:	d101      	bne.n	8014aae <LSM303AGR_ACC_W_Int2EnYHi+0x5e>
    return MEMS_ERROR;
 8014aaa:	2300      	movs	r3, #0
 8014aac:	e000      	b.n	8014ab0 <LSM303AGR_ACC_W_Int2EnYHi+0x60>

  return MEMS_SUCCESS;
 8014aae:	2301      	movs	r3, #1
}
 8014ab0:	4618      	mov	r0, r3
 8014ab2:	b005      	add	sp, #20
 8014ab4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ab8:	f3af 8000 	nop.w
 8014abc:	f3af 8000 	nop.w

08014ac0 <LSM303AGR_ACC_R_Int2EnYHi>:
* Input          : Pointer to LSM303AGR_ACC_YHIE_t
* Output         : Status of YHIE see LSM303AGR_ACC_YHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnYHi(void *handle, LSM303AGR_ACC_YHIE_t *value)
{
 8014ac0:	b500      	push	{lr}
 8014ac2:	b083      	sub	sp, #12
 8014ac4:	9001      	str	r0, [sp, #4]
 8014ac6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014ac8:	9801      	ldr	r0, [sp, #4]
 8014aca:	2134      	movs	r1, #52	; 0x34
 8014acc:	9a00      	ldr	r2, [sp, #0]
 8014ace:	2301      	movs	r3, #1
 8014ad0:	f7fd f986 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014ad4:	4603      	mov	r3, r0
 8014ad6:	2b00      	cmp	r3, #0
 8014ad8:	d101      	bne.n	8014ade <LSM303AGR_ACC_R_Int2EnYHi+0x1e>
    return MEMS_ERROR;
 8014ada:	2300      	movs	r3, #0
 8014adc:	e007      	b.n	8014aee <LSM303AGR_ACC_R_Int2EnYHi+0x2e>

  *value &= LSM303AGR_ACC_YHIE_MASK; //mask
 8014ade:	9b00      	ldr	r3, [sp, #0]
 8014ae0:	781b      	ldrb	r3, [r3, #0]
 8014ae2:	f003 0308 	and.w	r3, r3, #8
 8014ae6:	b2da      	uxtb	r2, r3
 8014ae8:	9b00      	ldr	r3, [sp, #0]
 8014aea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014aec:	2301      	movs	r3, #1
}
 8014aee:	4618      	mov	r0, r3
 8014af0:	b003      	add	sp, #12
 8014af2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014af6:	bf00      	nop
 8014af8:	f3af 8000 	nop.w
 8014afc:	f3af 8000 	nop.w

08014b00 <LSM303AGR_ACC_W_Int2EnZLo>:
* Input          : LSM303AGR_ACC_ZLIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t newValue)
{
 8014b00:	b500      	push	{lr}
 8014b02:	b085      	sub	sp, #20
 8014b04:	9001      	str	r0, [sp, #4]
 8014b06:	460b      	mov	r3, r1
 8014b08:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014b0c:	f10d 030f 	add.w	r3, sp, #15
 8014b10:	9801      	ldr	r0, [sp, #4]
 8014b12:	2134      	movs	r1, #52	; 0x34
 8014b14:	461a      	mov	r2, r3
 8014b16:	2301      	movs	r3, #1
 8014b18:	f7fd f962 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014b1c:	4603      	mov	r3, r0
 8014b1e:	2b00      	cmp	r3, #0
 8014b20:	d101      	bne.n	8014b26 <LSM303AGR_ACC_W_Int2EnZLo+0x26>
    return MEMS_ERROR;
 8014b22:	2300      	movs	r3, #0
 8014b24:	e01c      	b.n	8014b60 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  value &= ~LSM303AGR_ACC_ZLIE_MASK;
 8014b26:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014b2a:	f023 0310 	bic.w	r3, r3, #16
 8014b2e:	b2db      	uxtb	r3, r3
 8014b30:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014b34:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014b38:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014b3c:	4313      	orrs	r3, r2
 8014b3e:	b2db      	uxtb	r3, r3
 8014b40:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014b44:	f10d 030f 	add.w	r3, sp, #15
 8014b48:	9801      	ldr	r0, [sp, #4]
 8014b4a:	2134      	movs	r1, #52	; 0x34
 8014b4c:	461a      	mov	r2, r3
 8014b4e:	2301      	movs	r3, #1
 8014b50:	f7fd f91e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014b54:	4603      	mov	r3, r0
 8014b56:	2b00      	cmp	r3, #0
 8014b58:	d101      	bne.n	8014b5e <LSM303AGR_ACC_W_Int2EnZLo+0x5e>
    return MEMS_ERROR;
 8014b5a:	2300      	movs	r3, #0
 8014b5c:	e000      	b.n	8014b60 <LSM303AGR_ACC_W_Int2EnZLo+0x60>

  return MEMS_SUCCESS;
 8014b5e:	2301      	movs	r3, #1
}
 8014b60:	4618      	mov	r0, r3
 8014b62:	b005      	add	sp, #20
 8014b64:	f85d fb04 	ldr.w	pc, [sp], #4
 8014b68:	f3af 8000 	nop.w
 8014b6c:	f3af 8000 	nop.w

08014b70 <LSM303AGR_ACC_R_Int2EnZLo>:
* Input          : Pointer to LSM303AGR_ACC_ZLIE_t
* Output         : Status of ZLIE see LSM303AGR_ACC_ZLIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZLo(void *handle, LSM303AGR_ACC_ZLIE_t *value)
{
 8014b70:	b500      	push	{lr}
 8014b72:	b083      	sub	sp, #12
 8014b74:	9001      	str	r0, [sp, #4]
 8014b76:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014b78:	9801      	ldr	r0, [sp, #4]
 8014b7a:	2134      	movs	r1, #52	; 0x34
 8014b7c:	9a00      	ldr	r2, [sp, #0]
 8014b7e:	2301      	movs	r3, #1
 8014b80:	f7fd f92e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014b84:	4603      	mov	r3, r0
 8014b86:	2b00      	cmp	r3, #0
 8014b88:	d101      	bne.n	8014b8e <LSM303AGR_ACC_R_Int2EnZLo+0x1e>
    return MEMS_ERROR;
 8014b8a:	2300      	movs	r3, #0
 8014b8c:	e007      	b.n	8014b9e <LSM303AGR_ACC_R_Int2EnZLo+0x2e>

  *value &= LSM303AGR_ACC_ZLIE_MASK; //mask
 8014b8e:	9b00      	ldr	r3, [sp, #0]
 8014b90:	781b      	ldrb	r3, [r3, #0]
 8014b92:	f003 0310 	and.w	r3, r3, #16
 8014b96:	b2da      	uxtb	r2, r3
 8014b98:	9b00      	ldr	r3, [sp, #0]
 8014b9a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014b9c:	2301      	movs	r3, #1
}
 8014b9e:	4618      	mov	r0, r3
 8014ba0:	b003      	add	sp, #12
 8014ba2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ba6:	bf00      	nop
 8014ba8:	f3af 8000 	nop.w
 8014bac:	f3af 8000 	nop.w

08014bb0 <LSM303AGR_ACC_W_Int2EnZHi>:
* Input          : LSM303AGR_ACC_ZHIE_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t newValue)
{
 8014bb0:	b500      	push	{lr}
 8014bb2:	b085      	sub	sp, #20
 8014bb4:	9001      	str	r0, [sp, #4]
 8014bb6:	460b      	mov	r3, r1
 8014bb8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014bbc:	f10d 030f 	add.w	r3, sp, #15
 8014bc0:	9801      	ldr	r0, [sp, #4]
 8014bc2:	2134      	movs	r1, #52	; 0x34
 8014bc4:	461a      	mov	r2, r3
 8014bc6:	2301      	movs	r3, #1
 8014bc8:	f7fd f90a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014bcc:	4603      	mov	r3, r0
 8014bce:	2b00      	cmp	r3, #0
 8014bd0:	d101      	bne.n	8014bd6 <LSM303AGR_ACC_W_Int2EnZHi+0x26>
    return MEMS_ERROR;
 8014bd2:	2300      	movs	r3, #0
 8014bd4:	e01c      	b.n	8014c10 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  value &= ~LSM303AGR_ACC_ZHIE_MASK;
 8014bd6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014bda:	f023 0320 	bic.w	r3, r3, #32
 8014bde:	b2db      	uxtb	r3, r3
 8014be0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014be4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014be8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014bec:	4313      	orrs	r3, r2
 8014bee:	b2db      	uxtb	r3, r3
 8014bf0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014bf4:	f10d 030f 	add.w	r3, sp, #15
 8014bf8:	9801      	ldr	r0, [sp, #4]
 8014bfa:	2134      	movs	r1, #52	; 0x34
 8014bfc:	461a      	mov	r2, r3
 8014bfe:	2301      	movs	r3, #1
 8014c00:	f7fd f8c6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014c04:	4603      	mov	r3, r0
 8014c06:	2b00      	cmp	r3, #0
 8014c08:	d101      	bne.n	8014c0e <LSM303AGR_ACC_W_Int2EnZHi+0x5e>
    return MEMS_ERROR;
 8014c0a:	2300      	movs	r3, #0
 8014c0c:	e000      	b.n	8014c10 <LSM303AGR_ACC_W_Int2EnZHi+0x60>

  return MEMS_SUCCESS;
 8014c0e:	2301      	movs	r3, #1
}
 8014c10:	4618      	mov	r0, r3
 8014c12:	b005      	add	sp, #20
 8014c14:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c18:	f3af 8000 	nop.w
 8014c1c:	f3af 8000 	nop.w

08014c20 <LSM303AGR_ACC_R_Int2EnZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZHIE_t
* Output         : Status of ZHIE see LSM303AGR_ACC_ZHIE_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2EnZHi(void *handle, LSM303AGR_ACC_ZHIE_t *value)
{
 8014c20:	b500      	push	{lr}
 8014c22:	b083      	sub	sp, #12
 8014c24:	9001      	str	r0, [sp, #4]
 8014c26:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014c28:	9801      	ldr	r0, [sp, #4]
 8014c2a:	2134      	movs	r1, #52	; 0x34
 8014c2c:	9a00      	ldr	r2, [sp, #0]
 8014c2e:	2301      	movs	r3, #1
 8014c30:	f7fd f8d6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014c34:	4603      	mov	r3, r0
 8014c36:	2b00      	cmp	r3, #0
 8014c38:	d101      	bne.n	8014c3e <LSM303AGR_ACC_R_Int2EnZHi+0x1e>
    return MEMS_ERROR;
 8014c3a:	2300      	movs	r3, #0
 8014c3c:	e007      	b.n	8014c4e <LSM303AGR_ACC_R_Int2EnZHi+0x2e>

  *value &= LSM303AGR_ACC_ZHIE_MASK; //mask
 8014c3e:	9b00      	ldr	r3, [sp, #0]
 8014c40:	781b      	ldrb	r3, [r3, #0]
 8014c42:	f003 0320 	and.w	r3, r3, #32
 8014c46:	b2da      	uxtb	r2, r3
 8014c48:	9b00      	ldr	r3, [sp, #0]
 8014c4a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014c4c:	2301      	movs	r3, #1
}
 8014c4e:	4618      	mov	r0, r3
 8014c50:	b003      	add	sp, #12
 8014c52:	f85d fb04 	ldr.w	pc, [sp], #4
 8014c56:	bf00      	nop
 8014c58:	f3af 8000 	nop.w
 8014c5c:	f3af 8000 	nop.w

08014c60 <LSM303AGR_ACC_W_Int2_6D>:
* Input          : LSM303AGR_ACC_6D_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_6D(void *handle, LSM303AGR_ACC_6D_t newValue)
{
 8014c60:	b500      	push	{lr}
 8014c62:	b085      	sub	sp, #20
 8014c64:	9001      	str	r0, [sp, #4]
 8014c66:	460b      	mov	r3, r1
 8014c68:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014c6c:	f10d 030f 	add.w	r3, sp, #15
 8014c70:	9801      	ldr	r0, [sp, #4]
 8014c72:	2134      	movs	r1, #52	; 0x34
 8014c74:	461a      	mov	r2, r3
 8014c76:	2301      	movs	r3, #1
 8014c78:	f7fd f8b2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014c7c:	4603      	mov	r3, r0
 8014c7e:	2b00      	cmp	r3, #0
 8014c80:	d101      	bne.n	8014c86 <LSM303AGR_ACC_W_Int2_6D+0x26>
    return MEMS_ERROR;
 8014c82:	2300      	movs	r3, #0
 8014c84:	e01c      	b.n	8014cc0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  value &= ~LSM303AGR_ACC_6D_MASK;
 8014c86:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014c8a:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8014c8e:	b2db      	uxtb	r3, r3
 8014c90:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014c94:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014c98:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014c9c:	4313      	orrs	r3, r2
 8014c9e:	b2db      	uxtb	r3, r3
 8014ca0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014ca4:	f10d 030f 	add.w	r3, sp, #15
 8014ca8:	9801      	ldr	r0, [sp, #4]
 8014caa:	2134      	movs	r1, #52	; 0x34
 8014cac:	461a      	mov	r2, r3
 8014cae:	2301      	movs	r3, #1
 8014cb0:	f7fd f86e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014cb4:	4603      	mov	r3, r0
 8014cb6:	2b00      	cmp	r3, #0
 8014cb8:	d101      	bne.n	8014cbe <LSM303AGR_ACC_W_Int2_6D+0x5e>
    return MEMS_ERROR;
 8014cba:	2300      	movs	r3, #0
 8014cbc:	e000      	b.n	8014cc0 <LSM303AGR_ACC_W_Int2_6D+0x60>

  return MEMS_SUCCESS;
 8014cbe:	2301      	movs	r3, #1
}
 8014cc0:	4618      	mov	r0, r3
 8014cc2:	b005      	add	sp, #20
 8014cc4:	f85d fb04 	ldr.w	pc, [sp], #4
 8014cc8:	f3af 8000 	nop.w
 8014ccc:	f3af 8000 	nop.w

08014cd0 <LSM303AGR_ACC_R_Int2_6D>:
* Input          : Pointer to LSM303AGR_ACC_6D_t
* Output         : Status of 6D see LSM303AGR_ACC_6D_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_6D(void *handle, LSM303AGR_ACC_6D_t *value)
{
 8014cd0:	b500      	push	{lr}
 8014cd2:	b083      	sub	sp, #12
 8014cd4:	9001      	str	r0, [sp, #4]
 8014cd6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014cd8:	9801      	ldr	r0, [sp, #4]
 8014cda:	2134      	movs	r1, #52	; 0x34
 8014cdc:	9a00      	ldr	r2, [sp, #0]
 8014cde:	2301      	movs	r3, #1
 8014ce0:	f7fd f87e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014ce4:	4603      	mov	r3, r0
 8014ce6:	2b00      	cmp	r3, #0
 8014ce8:	d101      	bne.n	8014cee <LSM303AGR_ACC_R_Int2_6D+0x1e>
    return MEMS_ERROR;
 8014cea:	2300      	movs	r3, #0
 8014cec:	e007      	b.n	8014cfe <LSM303AGR_ACC_R_Int2_6D+0x2e>

  *value &= LSM303AGR_ACC_6D_MASK; //mask
 8014cee:	9b00      	ldr	r3, [sp, #0]
 8014cf0:	781b      	ldrb	r3, [r3, #0]
 8014cf2:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014cf6:	b2da      	uxtb	r2, r3
 8014cf8:	9b00      	ldr	r3, [sp, #0]
 8014cfa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014cfc:	2301      	movs	r3, #1
}
 8014cfe:	4618      	mov	r0, r3
 8014d00:	b003      	add	sp, #12
 8014d02:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d06:	bf00      	nop
 8014d08:	f3af 8000 	nop.w
 8014d0c:	f3af 8000 	nop.w

08014d10 <LSM303AGR_ACC_W_Int2_AOI>:
* Input          : LSM303AGR_ACC_AOI_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t newValue)
{
 8014d10:	b500      	push	{lr}
 8014d12:	b085      	sub	sp, #20
 8014d14:	9001      	str	r0, [sp, #4]
 8014d16:	460b      	mov	r3, r1
 8014d18:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014d1c:	f10d 030f 	add.w	r3, sp, #15
 8014d20:	9801      	ldr	r0, [sp, #4]
 8014d22:	2134      	movs	r1, #52	; 0x34
 8014d24:	461a      	mov	r2, r3
 8014d26:	2301      	movs	r3, #1
 8014d28:	f7fd f85a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014d2c:	4603      	mov	r3, r0
 8014d2e:	2b00      	cmp	r3, #0
 8014d30:	d101      	bne.n	8014d36 <LSM303AGR_ACC_W_Int2_AOI+0x26>
    return MEMS_ERROR;
 8014d32:	2300      	movs	r3, #0
 8014d34:	e01c      	b.n	8014d70 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  value &= ~LSM303AGR_ACC_AOI_MASK;
 8014d36:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8014d3a:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8014d3e:	b2db      	uxtb	r3, r3
 8014d40:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8014d44:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8014d48:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8014d4c:	4313      	orrs	r3, r2
 8014d4e:	b2db      	uxtb	r3, r3
 8014d50:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_CFG, &value, 1) )
 8014d54:	f10d 030f 	add.w	r3, sp, #15
 8014d58:	9801      	ldr	r0, [sp, #4]
 8014d5a:	2134      	movs	r1, #52	; 0x34
 8014d5c:	461a      	mov	r2, r3
 8014d5e:	2301      	movs	r3, #1
 8014d60:	f7fd f816 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8014d64:	4603      	mov	r3, r0
 8014d66:	2b00      	cmp	r3, #0
 8014d68:	d101      	bne.n	8014d6e <LSM303AGR_ACC_W_Int2_AOI+0x5e>
    return MEMS_ERROR;
 8014d6a:	2300      	movs	r3, #0
 8014d6c:	e000      	b.n	8014d70 <LSM303AGR_ACC_W_Int2_AOI+0x60>

  return MEMS_SUCCESS;
 8014d6e:	2301      	movs	r3, #1
}
 8014d70:	4618      	mov	r0, r3
 8014d72:	b005      	add	sp, #20
 8014d74:	f85d fb04 	ldr.w	pc, [sp], #4
 8014d78:	f3af 8000 	nop.w
 8014d7c:	f3af 8000 	nop.w

08014d80 <LSM303AGR_ACC_R_Int2_AOI>:
* Input          : Pointer to LSM303AGR_ACC_AOI_t
* Output         : Status of AOI see LSM303AGR_ACC_AOI_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_AOI(void *handle, LSM303AGR_ACC_AOI_t *value)
{
 8014d80:	b500      	push	{lr}
 8014d82:	b083      	sub	sp, #12
 8014d84:	9001      	str	r0, [sp, #4]
 8014d86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_CFG, (u8_t *)value, 1) )
 8014d88:	9801      	ldr	r0, [sp, #4]
 8014d8a:	2134      	movs	r1, #52	; 0x34
 8014d8c:	9a00      	ldr	r2, [sp, #0]
 8014d8e:	2301      	movs	r3, #1
 8014d90:	f7fd f826 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014d94:	4603      	mov	r3, r0
 8014d96:	2b00      	cmp	r3, #0
 8014d98:	d101      	bne.n	8014d9e <LSM303AGR_ACC_R_Int2_AOI+0x1e>
    return MEMS_ERROR;
 8014d9a:	2300      	movs	r3, #0
 8014d9c:	e007      	b.n	8014dae <LSM303AGR_ACC_R_Int2_AOI+0x2e>

  *value &= LSM303AGR_ACC_AOI_MASK; //mask
 8014d9e:	9b00      	ldr	r3, [sp, #0]
 8014da0:	781b      	ldrb	r3, [r3, #0]
 8014da2:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8014da6:	b2da      	uxtb	r2, r3
 8014da8:	9b00      	ldr	r3, [sp, #0]
 8014daa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014dac:	2301      	movs	r3, #1
}
 8014dae:	4618      	mov	r0, r3
 8014db0:	b003      	add	sp, #12
 8014db2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014db6:	bf00      	nop
 8014db8:	f3af 8000 	nop.w
 8014dbc:	f3af 8000 	nop.w

08014dc0 <LSM303AGR_ACC_R_Int1_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 8014dc0:	b500      	push	{lr}
 8014dc2:	b083      	sub	sp, #12
 8014dc4:	9001      	str	r0, [sp, #4]
 8014dc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014dc8:	9801      	ldr	r0, [sp, #4]
 8014dca:	2131      	movs	r1, #49	; 0x31
 8014dcc:	9a00      	ldr	r2, [sp, #0]
 8014dce:	2301      	movs	r3, #1
 8014dd0:	f7fd f806 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014dd4:	4603      	mov	r3, r0
 8014dd6:	2b00      	cmp	r3, #0
 8014dd8:	d101      	bne.n	8014dde <LSM303AGR_ACC_R_Int1_Xlo+0x1e>
    return MEMS_ERROR;
 8014dda:	2300      	movs	r3, #0
 8014ddc:	e007      	b.n	8014dee <LSM303AGR_ACC_R_Int1_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 8014dde:	9b00      	ldr	r3, [sp, #0]
 8014de0:	781b      	ldrb	r3, [r3, #0]
 8014de2:	f003 0301 	and.w	r3, r3, #1
 8014de6:	b2da      	uxtb	r2, r3
 8014de8:	9b00      	ldr	r3, [sp, #0]
 8014dea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014dec:	2301      	movs	r3, #1
}
 8014dee:	4618      	mov	r0, r3
 8014df0:	b003      	add	sp, #12
 8014df2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014df6:	bf00      	nop
 8014df8:	f3af 8000 	nop.w
 8014dfc:	f3af 8000 	nop.w

08014e00 <LSM303AGR_ACC_R_Int1_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 8014e00:	b500      	push	{lr}
 8014e02:	b083      	sub	sp, #12
 8014e04:	9001      	str	r0, [sp, #4]
 8014e06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014e08:	9801      	ldr	r0, [sp, #4]
 8014e0a:	2131      	movs	r1, #49	; 0x31
 8014e0c:	9a00      	ldr	r2, [sp, #0]
 8014e0e:	2301      	movs	r3, #1
 8014e10:	f7fc ffe6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014e14:	4603      	mov	r3, r0
 8014e16:	2b00      	cmp	r3, #0
 8014e18:	d101      	bne.n	8014e1e <LSM303AGR_ACC_R_Int1_XHi+0x1e>
    return MEMS_ERROR;
 8014e1a:	2300      	movs	r3, #0
 8014e1c:	e007      	b.n	8014e2e <LSM303AGR_ACC_R_Int1_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 8014e1e:	9b00      	ldr	r3, [sp, #0]
 8014e20:	781b      	ldrb	r3, [r3, #0]
 8014e22:	f003 0302 	and.w	r3, r3, #2
 8014e26:	b2da      	uxtb	r2, r3
 8014e28:	9b00      	ldr	r3, [sp, #0]
 8014e2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e2c:	2301      	movs	r3, #1
}
 8014e2e:	4618      	mov	r0, r3
 8014e30:	b003      	add	sp, #12
 8014e32:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e36:	bf00      	nop
 8014e38:	f3af 8000 	nop.w
 8014e3c:	f3af 8000 	nop.w

08014e40 <LSM303AGR_ACC_R_Int1_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8014e40:	b500      	push	{lr}
 8014e42:	b083      	sub	sp, #12
 8014e44:	9001      	str	r0, [sp, #4]
 8014e46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014e48:	9801      	ldr	r0, [sp, #4]
 8014e4a:	2131      	movs	r1, #49	; 0x31
 8014e4c:	9a00      	ldr	r2, [sp, #0]
 8014e4e:	2301      	movs	r3, #1
 8014e50:	f7fc ffc6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014e54:	4603      	mov	r3, r0
 8014e56:	2b00      	cmp	r3, #0
 8014e58:	d101      	bne.n	8014e5e <LSM303AGR_ACC_R_Int1_YLo+0x1e>
    return MEMS_ERROR;
 8014e5a:	2300      	movs	r3, #0
 8014e5c:	e007      	b.n	8014e6e <LSM303AGR_ACC_R_Int1_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 8014e5e:	9b00      	ldr	r3, [sp, #0]
 8014e60:	781b      	ldrb	r3, [r3, #0]
 8014e62:	f003 0304 	and.w	r3, r3, #4
 8014e66:	b2da      	uxtb	r2, r3
 8014e68:	9b00      	ldr	r3, [sp, #0]
 8014e6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014e6c:	2301      	movs	r3, #1
}
 8014e6e:	4618      	mov	r0, r3
 8014e70:	b003      	add	sp, #12
 8014e72:	f85d fb04 	ldr.w	pc, [sp], #4
 8014e76:	bf00      	nop
 8014e78:	f3af 8000 	nop.w
 8014e7c:	f3af 8000 	nop.w

08014e80 <LSM303AGR_ACC_R_Int1_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8014e80:	b500      	push	{lr}
 8014e82:	b083      	sub	sp, #12
 8014e84:	9001      	str	r0, [sp, #4]
 8014e86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014e88:	9801      	ldr	r0, [sp, #4]
 8014e8a:	2131      	movs	r1, #49	; 0x31
 8014e8c:	9a00      	ldr	r2, [sp, #0]
 8014e8e:	2301      	movs	r3, #1
 8014e90:	f7fc ffa6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014e94:	4603      	mov	r3, r0
 8014e96:	2b00      	cmp	r3, #0
 8014e98:	d101      	bne.n	8014e9e <LSM303AGR_ACC_R_Int1_YHi+0x1e>
    return MEMS_ERROR;
 8014e9a:	2300      	movs	r3, #0
 8014e9c:	e007      	b.n	8014eae <LSM303AGR_ACC_R_Int1_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 8014e9e:	9b00      	ldr	r3, [sp, #0]
 8014ea0:	781b      	ldrb	r3, [r3, #0]
 8014ea2:	f003 0308 	and.w	r3, r3, #8
 8014ea6:	b2da      	uxtb	r2, r3
 8014ea8:	9b00      	ldr	r3, [sp, #0]
 8014eaa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014eac:	2301      	movs	r3, #1
}
 8014eae:	4618      	mov	r0, r3
 8014eb0:	b003      	add	sp, #12
 8014eb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014eb6:	bf00      	nop
 8014eb8:	f3af 8000 	nop.w
 8014ebc:	f3af 8000 	nop.w

08014ec0 <LSM303AGR_ACC_R_Int1_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 8014ec0:	b500      	push	{lr}
 8014ec2:	b083      	sub	sp, #12
 8014ec4:	9001      	str	r0, [sp, #4]
 8014ec6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014ec8:	9801      	ldr	r0, [sp, #4]
 8014eca:	2131      	movs	r1, #49	; 0x31
 8014ecc:	9a00      	ldr	r2, [sp, #0]
 8014ece:	2301      	movs	r3, #1
 8014ed0:	f7fc ff86 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014ed4:	4603      	mov	r3, r0
 8014ed6:	2b00      	cmp	r3, #0
 8014ed8:	d101      	bne.n	8014ede <LSM303AGR_ACC_R_Int1_Zlo+0x1e>
    return MEMS_ERROR;
 8014eda:	2300      	movs	r3, #0
 8014edc:	e007      	b.n	8014eee <LSM303AGR_ACC_R_Int1_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 8014ede:	9b00      	ldr	r3, [sp, #0]
 8014ee0:	781b      	ldrb	r3, [r3, #0]
 8014ee2:	f003 0310 	and.w	r3, r3, #16
 8014ee6:	b2da      	uxtb	r2, r3
 8014ee8:	9b00      	ldr	r3, [sp, #0]
 8014eea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014eec:	2301      	movs	r3, #1
}
 8014eee:	4618      	mov	r0, r3
 8014ef0:	b003      	add	sp, #12
 8014ef2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ef6:	bf00      	nop
 8014ef8:	f3af 8000 	nop.w
 8014efc:	f3af 8000 	nop.w

08014f00 <LSM303AGR_ACC_R_Int1_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 8014f00:	b500      	push	{lr}
 8014f02:	b083      	sub	sp, #12
 8014f04:	9001      	str	r0, [sp, #4]
 8014f06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014f08:	9801      	ldr	r0, [sp, #4]
 8014f0a:	2131      	movs	r1, #49	; 0x31
 8014f0c:	9a00      	ldr	r2, [sp, #0]
 8014f0e:	2301      	movs	r3, #1
 8014f10:	f7fc ff66 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014f14:	4603      	mov	r3, r0
 8014f16:	2b00      	cmp	r3, #0
 8014f18:	d101      	bne.n	8014f1e <LSM303AGR_ACC_R_Int1_ZHi+0x1e>
    return MEMS_ERROR;
 8014f1a:	2300      	movs	r3, #0
 8014f1c:	e007      	b.n	8014f2e <LSM303AGR_ACC_R_Int1_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 8014f1e:	9b00      	ldr	r3, [sp, #0]
 8014f20:	781b      	ldrb	r3, [r3, #0]
 8014f22:	f003 0320 	and.w	r3, r3, #32
 8014f26:	b2da      	uxtb	r2, r3
 8014f28:	9b00      	ldr	r3, [sp, #0]
 8014f2a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f2c:	2301      	movs	r3, #1
}
 8014f2e:	4618      	mov	r0, r3
 8014f30:	b003      	add	sp, #12
 8014f32:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f36:	bf00      	nop
 8014f38:	f3af 8000 	nop.w
 8014f3c:	f3af 8000 	nop.w

08014f40 <LSM303AGR_ACC_R_Int1_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8014f40:	b500      	push	{lr}
 8014f42:	b083      	sub	sp, #12
 8014f44:	9001      	str	r0, [sp, #4]
 8014f46:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_SOURCE, (u8_t *)value, 1) )
 8014f48:	9801      	ldr	r0, [sp, #4]
 8014f4a:	2131      	movs	r1, #49	; 0x31
 8014f4c:	9a00      	ldr	r2, [sp, #0]
 8014f4e:	2301      	movs	r3, #1
 8014f50:	f7fc ff46 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014f54:	4603      	mov	r3, r0
 8014f56:	2b00      	cmp	r3, #0
 8014f58:	d101      	bne.n	8014f5e <LSM303AGR_ACC_R_Int1_IA+0x1e>
    return MEMS_ERROR;
 8014f5a:	2300      	movs	r3, #0
 8014f5c:	e007      	b.n	8014f6e <LSM303AGR_ACC_R_Int1_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 8014f5e:	9b00      	ldr	r3, [sp, #0]
 8014f60:	781b      	ldrb	r3, [r3, #0]
 8014f62:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8014f66:	b2da      	uxtb	r2, r3
 8014f68:	9b00      	ldr	r3, [sp, #0]
 8014f6a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014f6c:	2301      	movs	r3, #1
}
 8014f6e:	4618      	mov	r0, r3
 8014f70:	b003      	add	sp, #12
 8014f72:	f85d fb04 	ldr.w	pc, [sp], #4
 8014f76:	bf00      	nop
 8014f78:	f3af 8000 	nop.w
 8014f7c:	f3af 8000 	nop.w

08014f80 <LSM303AGR_ACC_R_Int2_Xlo>:
* Input          : Pointer to LSM303AGR_ACC_XL_t
* Output         : Status of XL see LSM303AGR_ACC_XL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Xlo(void *handle, LSM303AGR_ACC_XL_t *value)
{
 8014f80:	b500      	push	{lr}
 8014f82:	b083      	sub	sp, #12
 8014f84:	9001      	str	r0, [sp, #4]
 8014f86:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014f88:	9801      	ldr	r0, [sp, #4]
 8014f8a:	2135      	movs	r1, #53	; 0x35
 8014f8c:	9a00      	ldr	r2, [sp, #0]
 8014f8e:	2301      	movs	r3, #1
 8014f90:	f7fc ff26 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014f94:	4603      	mov	r3, r0
 8014f96:	2b00      	cmp	r3, #0
 8014f98:	d101      	bne.n	8014f9e <LSM303AGR_ACC_R_Int2_Xlo+0x1e>
    return MEMS_ERROR;
 8014f9a:	2300      	movs	r3, #0
 8014f9c:	e007      	b.n	8014fae <LSM303AGR_ACC_R_Int2_Xlo+0x2e>

  *value &= LSM303AGR_ACC_XL_MASK; //mask
 8014f9e:	9b00      	ldr	r3, [sp, #0]
 8014fa0:	781b      	ldrb	r3, [r3, #0]
 8014fa2:	f003 0301 	and.w	r3, r3, #1
 8014fa6:	b2da      	uxtb	r2, r3
 8014fa8:	9b00      	ldr	r3, [sp, #0]
 8014faa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014fac:	2301      	movs	r3, #1
}
 8014fae:	4618      	mov	r0, r3
 8014fb0:	b003      	add	sp, #12
 8014fb2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014fb6:	bf00      	nop
 8014fb8:	f3af 8000 	nop.w
 8014fbc:	f3af 8000 	nop.w

08014fc0 <LSM303AGR_ACC_R_Int2_XHi>:
* Input          : Pointer to LSM303AGR_ACC_XH_t
* Output         : Status of XH see LSM303AGR_ACC_XH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_XHi(void *handle, LSM303AGR_ACC_XH_t *value)
{
 8014fc0:	b500      	push	{lr}
 8014fc2:	b083      	sub	sp, #12
 8014fc4:	9001      	str	r0, [sp, #4]
 8014fc6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8014fc8:	9801      	ldr	r0, [sp, #4]
 8014fca:	2135      	movs	r1, #53	; 0x35
 8014fcc:	9a00      	ldr	r2, [sp, #0]
 8014fce:	2301      	movs	r3, #1
 8014fd0:	f7fc ff06 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8014fd4:	4603      	mov	r3, r0
 8014fd6:	2b00      	cmp	r3, #0
 8014fd8:	d101      	bne.n	8014fde <LSM303AGR_ACC_R_Int2_XHi+0x1e>
    return MEMS_ERROR;
 8014fda:	2300      	movs	r3, #0
 8014fdc:	e007      	b.n	8014fee <LSM303AGR_ACC_R_Int2_XHi+0x2e>

  *value &= LSM303AGR_ACC_XH_MASK; //mask
 8014fde:	9b00      	ldr	r3, [sp, #0]
 8014fe0:	781b      	ldrb	r3, [r3, #0]
 8014fe2:	f003 0302 	and.w	r3, r3, #2
 8014fe6:	b2da      	uxtb	r2, r3
 8014fe8:	9b00      	ldr	r3, [sp, #0]
 8014fea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8014fec:	2301      	movs	r3, #1
}
 8014fee:	4618      	mov	r0, r3
 8014ff0:	b003      	add	sp, #12
 8014ff2:	f85d fb04 	ldr.w	pc, [sp], #4
 8014ff6:	bf00      	nop
 8014ff8:	f3af 8000 	nop.w
 8014ffc:	f3af 8000 	nop.w

08015000 <LSM303AGR_ACC_R_Int2_YLo>:
* Input          : Pointer to LSM303AGR_ACC_YL_t
* Output         : Status of YL see LSM303AGR_ACC_YL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YLo(void *handle, LSM303AGR_ACC_YL_t *value)
{
 8015000:	b500      	push	{lr}
 8015002:	b083      	sub	sp, #12
 8015004:	9001      	str	r0, [sp, #4]
 8015006:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015008:	9801      	ldr	r0, [sp, #4]
 801500a:	2135      	movs	r1, #53	; 0x35
 801500c:	9a00      	ldr	r2, [sp, #0]
 801500e:	2301      	movs	r3, #1
 8015010:	f7fc fee6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015014:	4603      	mov	r3, r0
 8015016:	2b00      	cmp	r3, #0
 8015018:	d101      	bne.n	801501e <LSM303AGR_ACC_R_Int2_YLo+0x1e>
    return MEMS_ERROR;
 801501a:	2300      	movs	r3, #0
 801501c:	e007      	b.n	801502e <LSM303AGR_ACC_R_Int2_YLo+0x2e>

  *value &= LSM303AGR_ACC_YL_MASK; //mask
 801501e:	9b00      	ldr	r3, [sp, #0]
 8015020:	781b      	ldrb	r3, [r3, #0]
 8015022:	f003 0304 	and.w	r3, r3, #4
 8015026:	b2da      	uxtb	r2, r3
 8015028:	9b00      	ldr	r3, [sp, #0]
 801502a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801502c:	2301      	movs	r3, #1
}
 801502e:	4618      	mov	r0, r3
 8015030:	b003      	add	sp, #12
 8015032:	f85d fb04 	ldr.w	pc, [sp], #4
 8015036:	bf00      	nop
 8015038:	f3af 8000 	nop.w
 801503c:	f3af 8000 	nop.w

08015040 <LSM303AGR_ACC_R_Int2_YHi>:
* Input          : Pointer to LSM303AGR_ACC_YH_t
* Output         : Status of YH see LSM303AGR_ACC_YH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_YHi(void *handle, LSM303AGR_ACC_YH_t *value)
{
 8015040:	b500      	push	{lr}
 8015042:	b083      	sub	sp, #12
 8015044:	9001      	str	r0, [sp, #4]
 8015046:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015048:	9801      	ldr	r0, [sp, #4]
 801504a:	2135      	movs	r1, #53	; 0x35
 801504c:	9a00      	ldr	r2, [sp, #0]
 801504e:	2301      	movs	r3, #1
 8015050:	f7fc fec6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015054:	4603      	mov	r3, r0
 8015056:	2b00      	cmp	r3, #0
 8015058:	d101      	bne.n	801505e <LSM303AGR_ACC_R_Int2_YHi+0x1e>
    return MEMS_ERROR;
 801505a:	2300      	movs	r3, #0
 801505c:	e007      	b.n	801506e <LSM303AGR_ACC_R_Int2_YHi+0x2e>

  *value &= LSM303AGR_ACC_YH_MASK; //mask
 801505e:	9b00      	ldr	r3, [sp, #0]
 8015060:	781b      	ldrb	r3, [r3, #0]
 8015062:	f003 0308 	and.w	r3, r3, #8
 8015066:	b2da      	uxtb	r2, r3
 8015068:	9b00      	ldr	r3, [sp, #0]
 801506a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801506c:	2301      	movs	r3, #1
}
 801506e:	4618      	mov	r0, r3
 8015070:	b003      	add	sp, #12
 8015072:	f85d fb04 	ldr.w	pc, [sp], #4
 8015076:	bf00      	nop
 8015078:	f3af 8000 	nop.w
 801507c:	f3af 8000 	nop.w

08015080 <LSM303AGR_ACC_R_Int2_Zlo>:
* Input          : Pointer to LSM303AGR_ACC_ZL_t
* Output         : Status of ZL see LSM303AGR_ACC_ZL_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Zlo(void *handle, LSM303AGR_ACC_ZL_t *value)
{
 8015080:	b500      	push	{lr}
 8015082:	b083      	sub	sp, #12
 8015084:	9001      	str	r0, [sp, #4]
 8015086:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015088:	9801      	ldr	r0, [sp, #4]
 801508a:	2135      	movs	r1, #53	; 0x35
 801508c:	9a00      	ldr	r2, [sp, #0]
 801508e:	2301      	movs	r3, #1
 8015090:	f7fc fea6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015094:	4603      	mov	r3, r0
 8015096:	2b00      	cmp	r3, #0
 8015098:	d101      	bne.n	801509e <LSM303AGR_ACC_R_Int2_Zlo+0x1e>
    return MEMS_ERROR;
 801509a:	2300      	movs	r3, #0
 801509c:	e007      	b.n	80150ae <LSM303AGR_ACC_R_Int2_Zlo+0x2e>

  *value &= LSM303AGR_ACC_ZL_MASK; //mask
 801509e:	9b00      	ldr	r3, [sp, #0]
 80150a0:	781b      	ldrb	r3, [r3, #0]
 80150a2:	f003 0310 	and.w	r3, r3, #16
 80150a6:	b2da      	uxtb	r2, r3
 80150a8:	9b00      	ldr	r3, [sp, #0]
 80150aa:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80150ac:	2301      	movs	r3, #1
}
 80150ae:	4618      	mov	r0, r3
 80150b0:	b003      	add	sp, #12
 80150b2:	f85d fb04 	ldr.w	pc, [sp], #4
 80150b6:	bf00      	nop
 80150b8:	f3af 8000 	nop.w
 80150bc:	f3af 8000 	nop.w

080150c0 <LSM303AGR_ACC_R_Int2_ZHi>:
* Input          : Pointer to LSM303AGR_ACC_ZH_t
* Output         : Status of ZH see LSM303AGR_ACC_ZH_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_ZHi(void *handle, LSM303AGR_ACC_ZH_t *value)
{
 80150c0:	b500      	push	{lr}
 80150c2:	b083      	sub	sp, #12
 80150c4:	9001      	str	r0, [sp, #4]
 80150c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 80150c8:	9801      	ldr	r0, [sp, #4]
 80150ca:	2135      	movs	r1, #53	; 0x35
 80150cc:	9a00      	ldr	r2, [sp, #0]
 80150ce:	2301      	movs	r3, #1
 80150d0:	f7fc fe86 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80150d4:	4603      	mov	r3, r0
 80150d6:	2b00      	cmp	r3, #0
 80150d8:	d101      	bne.n	80150de <LSM303AGR_ACC_R_Int2_ZHi+0x1e>
    return MEMS_ERROR;
 80150da:	2300      	movs	r3, #0
 80150dc:	e007      	b.n	80150ee <LSM303AGR_ACC_R_Int2_ZHi+0x2e>

  *value &= LSM303AGR_ACC_ZH_MASK; //mask
 80150de:	9b00      	ldr	r3, [sp, #0]
 80150e0:	781b      	ldrb	r3, [r3, #0]
 80150e2:	f003 0320 	and.w	r3, r3, #32
 80150e6:	b2da      	uxtb	r2, r3
 80150e8:	9b00      	ldr	r3, [sp, #0]
 80150ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80150ec:	2301      	movs	r3, #1
}
 80150ee:	4618      	mov	r0, r3
 80150f0:	b003      	add	sp, #12
 80150f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80150f6:	bf00      	nop
 80150f8:	f3af 8000 	nop.w
 80150fc:	f3af 8000 	nop.w

08015100 <LSM303AGR_ACC_R_Int2_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_IA(void *handle, LSM303AGR_ACC_IA_t *value)
{
 8015100:	b500      	push	{lr}
 8015102:	b083      	sub	sp, #12
 8015104:	9001      	str	r0, [sp, #4]
 8015106:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_SOURCE, (u8_t *)value, 1) )
 8015108:	9801      	ldr	r0, [sp, #4]
 801510a:	2135      	movs	r1, #53	; 0x35
 801510c:	9a00      	ldr	r2, [sp, #0]
 801510e:	2301      	movs	r3, #1
 8015110:	f7fc fe66 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015114:	4603      	mov	r3, r0
 8015116:	2b00      	cmp	r3, #0
 8015118:	d101      	bne.n	801511e <LSM303AGR_ACC_R_Int2_IA+0x1e>
    return MEMS_ERROR;
 801511a:	2300      	movs	r3, #0
 801511c:	e007      	b.n	801512e <LSM303AGR_ACC_R_Int2_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 801511e:	9b00      	ldr	r3, [sp, #0]
 8015120:	781b      	ldrb	r3, [r3, #0]
 8015122:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015126:	b2da      	uxtb	r2, r3
 8015128:	9b00      	ldr	r3, [sp, #0]
 801512a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801512c:	2301      	movs	r3, #1
}
 801512e:	4618      	mov	r0, r3
 8015130:	b003      	add	sp, #12
 8015132:	f85d fb04 	ldr.w	pc, [sp], #4
 8015136:	bf00      	nop
 8015138:	f3af 8000 	nop.w
 801513c:	f3af 8000 	nop.w

08015140 <LSM303AGR_ACC_W_Int1_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Threshold(void *handle, u8_t newValue)
{
 8015140:	b500      	push	{lr}
 8015142:	b085      	sub	sp, #20
 8015144:	9001      	str	r0, [sp, #4]
 8015146:	460b      	mov	r3, r1
 8015148:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801514c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015150:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015154:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8015158:	f10d 030f 	add.w	r3, sp, #15
 801515c:	9801      	ldr	r0, [sp, #4]
 801515e:	2132      	movs	r1, #50	; 0x32
 8015160:	461a      	mov	r2, r3
 8015162:	2301      	movs	r3, #1
 8015164:	f7fc fe3c 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015168:	4603      	mov	r3, r0
 801516a:	2b00      	cmp	r3, #0
 801516c:	d101      	bne.n	8015172 <LSM303AGR_ACC_W_Int1_Threshold+0x32>
    return MEMS_ERROR;
 801516e:	2300      	movs	r3, #0
 8015170:	e01c      	b.n	80151ac <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8015172:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015176:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801517a:	b2db      	uxtb	r3, r3
 801517c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015180:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015184:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015188:	4313      	orrs	r3, r2
 801518a:	b2db      	uxtb	r3, r3
 801518c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_THS, &value, 1) )
 8015190:	f10d 030f 	add.w	r3, sp, #15
 8015194:	9801      	ldr	r0, [sp, #4]
 8015196:	2132      	movs	r1, #50	; 0x32
 8015198:	461a      	mov	r2, r3
 801519a:	2301      	movs	r3, #1
 801519c:	f7fc fdf8 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80151a0:	4603      	mov	r3, r0
 80151a2:	2b00      	cmp	r3, #0
 80151a4:	d101      	bne.n	80151aa <LSM303AGR_ACC_W_Int1_Threshold+0x6a>
    return MEMS_ERROR;
 80151a6:	2300      	movs	r3, #0
 80151a8:	e000      	b.n	80151ac <LSM303AGR_ACC_W_Int1_Threshold+0x6c>

  return MEMS_SUCCESS;
 80151aa:	2301      	movs	r3, #1
}
 80151ac:	4618      	mov	r0, r3
 80151ae:	b005      	add	sp, #20
 80151b0:	f85d fb04 	ldr.w	pc, [sp], #4
 80151b4:	f3af 8000 	nop.w
 80151b8:	f3af 8000 	nop.w
 80151bc:	f3af 8000 	nop.w

080151c0 <LSM303AGR_ACC_R_Int1_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Threshold(void *handle, u8_t *value)
{
 80151c0:	b500      	push	{lr}
 80151c2:	b083      	sub	sp, #12
 80151c4:	9001      	str	r0, [sp, #4]
 80151c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_THS, (u8_t *)value, 1) )
 80151c8:	9801      	ldr	r0, [sp, #4]
 80151ca:	2132      	movs	r1, #50	; 0x32
 80151cc:	9a00      	ldr	r2, [sp, #0]
 80151ce:	2301      	movs	r3, #1
 80151d0:	f7fc fe06 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80151d4:	4603      	mov	r3, r0
 80151d6:	2b00      	cmp	r3, #0
 80151d8:	d101      	bne.n	80151de <LSM303AGR_ACC_R_Int1_Threshold+0x1e>
    return MEMS_ERROR;
 80151da:	2300      	movs	r3, #0
 80151dc:	e00b      	b.n	80151f6 <LSM303AGR_ACC_R_Int1_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 80151de:	9b00      	ldr	r3, [sp, #0]
 80151e0:	781b      	ldrb	r3, [r3, #0]
 80151e2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80151e6:	b2da      	uxtb	r2, r3
 80151e8:	9b00      	ldr	r3, [sp, #0]
 80151ea:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80151ec:	9b00      	ldr	r3, [sp, #0]
 80151ee:	781a      	ldrb	r2, [r3, #0]
 80151f0:	9b00      	ldr	r3, [sp, #0]
 80151f2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80151f4:	2301      	movs	r3, #1
}
 80151f6:	4618      	mov	r0, r3
 80151f8:	b003      	add	sp, #12
 80151fa:	f85d fb04 	ldr.w	pc, [sp], #4
 80151fe:	bf00      	nop

08015200 <LSM303AGR_ACC_W_Int2_Threshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Threshold(void *handle, u8_t newValue)
{
 8015200:	b500      	push	{lr}
 8015202:	b085      	sub	sp, #20
 8015204:	9001      	str	r0, [sp, #4]
 8015206:	460b      	mov	r3, r1
 8015208:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 801520c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015210:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015214:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8015218:	f10d 030f 	add.w	r3, sp, #15
 801521c:	9801      	ldr	r0, [sp, #4]
 801521e:	2136      	movs	r1, #54	; 0x36
 8015220:	461a      	mov	r2, r3
 8015222:	2301      	movs	r3, #1
 8015224:	f7fc fddc 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015228:	4603      	mov	r3, r0
 801522a:	2b00      	cmp	r3, #0
 801522c:	d101      	bne.n	8015232 <LSM303AGR_ACC_W_Int2_Threshold+0x32>
    return MEMS_ERROR;
 801522e:	2300      	movs	r3, #0
 8015230:	e01c      	b.n	801526c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8015232:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015236:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 801523a:	b2db      	uxtb	r3, r3
 801523c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015240:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015244:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015248:	4313      	orrs	r3, r2
 801524a:	b2db      	uxtb	r3, r3
 801524c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_THS, &value, 1) )
 8015250:	f10d 030f 	add.w	r3, sp, #15
 8015254:	9801      	ldr	r0, [sp, #4]
 8015256:	2136      	movs	r1, #54	; 0x36
 8015258:	461a      	mov	r2, r3
 801525a:	2301      	movs	r3, #1
 801525c:	f7fc fd98 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015260:	4603      	mov	r3, r0
 8015262:	2b00      	cmp	r3, #0
 8015264:	d101      	bne.n	801526a <LSM303AGR_ACC_W_Int2_Threshold+0x6a>
    return MEMS_ERROR;
 8015266:	2300      	movs	r3, #0
 8015268:	e000      	b.n	801526c <LSM303AGR_ACC_W_Int2_Threshold+0x6c>

  return MEMS_SUCCESS;
 801526a:	2301      	movs	r3, #1
}
 801526c:	4618      	mov	r0, r3
 801526e:	b005      	add	sp, #20
 8015270:	f85d fb04 	ldr.w	pc, [sp], #4
 8015274:	f3af 8000 	nop.w
 8015278:	f3af 8000 	nop.w
 801527c:	f3af 8000 	nop.w

08015280 <LSM303AGR_ACC_R_Int2_Threshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Threshold(void *handle, u8_t *value)
{
 8015280:	b500      	push	{lr}
 8015282:	b083      	sub	sp, #12
 8015284:	9001      	str	r0, [sp, #4]
 8015286:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_THS, (u8_t *)value, 1) )
 8015288:	9801      	ldr	r0, [sp, #4]
 801528a:	2136      	movs	r1, #54	; 0x36
 801528c:	9a00      	ldr	r2, [sp, #0]
 801528e:	2301      	movs	r3, #1
 8015290:	f7fc fda6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015294:	4603      	mov	r3, r0
 8015296:	2b00      	cmp	r3, #0
 8015298:	d101      	bne.n	801529e <LSM303AGR_ACC_R_Int2_Threshold+0x1e>
    return MEMS_ERROR;
 801529a:	2300      	movs	r3, #0
 801529c:	e00b      	b.n	80152b6 <LSM303AGR_ACC_R_Int2_Threshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 801529e:	9b00      	ldr	r3, [sp, #0]
 80152a0:	781b      	ldrb	r3, [r3, #0]
 80152a2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80152a6:	b2da      	uxtb	r2, r3
 80152a8:	9b00      	ldr	r3, [sp, #0]
 80152aa:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 80152ac:	9b00      	ldr	r3, [sp, #0]
 80152ae:	781a      	ldrb	r2, [r3, #0]
 80152b0:	9b00      	ldr	r3, [sp, #0]
 80152b2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80152b4:	2301      	movs	r3, #1
}
 80152b6:	4618      	mov	r0, r3
 80152b8:	b003      	add	sp, #12
 80152ba:	f85d fb04 	ldr.w	pc, [sp], #4
 80152be:	bf00      	nop

080152c0 <LSM303AGR_ACC_W_Int1_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int1_Duration(void *handle, u8_t newValue)
{
 80152c0:	b500      	push	{lr}
 80152c2:	b085      	sub	sp, #20
 80152c4:	9001      	str	r0, [sp, #4]
 80152c6:	460b      	mov	r3, r1
 80152c8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 80152cc:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80152d0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 80152d4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 80152d8:	f10d 030f 	add.w	r3, sp, #15
 80152dc:	9801      	ldr	r0, [sp, #4]
 80152de:	2133      	movs	r1, #51	; 0x33
 80152e0:	461a      	mov	r2, r3
 80152e2:	2301      	movs	r3, #1
 80152e4:	f7fc fd7c 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80152e8:	4603      	mov	r3, r0
 80152ea:	2b00      	cmp	r3, #0
 80152ec:	d101      	bne.n	80152f2 <LSM303AGR_ACC_W_Int1_Duration+0x32>
    return MEMS_ERROR;
 80152ee:	2300      	movs	r3, #0
 80152f0:	e01c      	b.n	801532c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80152f2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80152f6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80152fa:	b2db      	uxtb	r3, r3
 80152fc:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015300:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015304:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015308:	4313      	orrs	r3, r2
 801530a:	b2db      	uxtb	r3, r3
 801530c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT1_DURATION, &value, 1) )
 8015310:	f10d 030f 	add.w	r3, sp, #15
 8015314:	9801      	ldr	r0, [sp, #4]
 8015316:	2133      	movs	r1, #51	; 0x33
 8015318:	461a      	mov	r2, r3
 801531a:	2301      	movs	r3, #1
 801531c:	f7fc fd38 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015320:	4603      	mov	r3, r0
 8015322:	2b00      	cmp	r3, #0
 8015324:	d101      	bne.n	801532a <LSM303AGR_ACC_W_Int1_Duration+0x6a>
    return MEMS_ERROR;
 8015326:	2300      	movs	r3, #0
 8015328:	e000      	b.n	801532c <LSM303AGR_ACC_W_Int1_Duration+0x6c>

  return MEMS_SUCCESS;
 801532a:	2301      	movs	r3, #1
}
 801532c:	4618      	mov	r0, r3
 801532e:	b005      	add	sp, #20
 8015330:	f85d fb04 	ldr.w	pc, [sp], #4
 8015334:	f3af 8000 	nop.w
 8015338:	f3af 8000 	nop.w
 801533c:	f3af 8000 	nop.w

08015340 <LSM303AGR_ACC_R_Int1_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int1_Duration(void *handle, u8_t *value)
{
 8015340:	b500      	push	{lr}
 8015342:	b083      	sub	sp, #12
 8015344:	9001      	str	r0, [sp, #4]
 8015346:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT1_DURATION, (u8_t *)value, 1) )
 8015348:	9801      	ldr	r0, [sp, #4]
 801534a:	2133      	movs	r1, #51	; 0x33
 801534c:	9a00      	ldr	r2, [sp, #0]
 801534e:	2301      	movs	r3, #1
 8015350:	f7fc fd46 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015354:	4603      	mov	r3, r0
 8015356:	2b00      	cmp	r3, #0
 8015358:	d101      	bne.n	801535e <LSM303AGR_ACC_R_Int1_Duration+0x1e>
    return MEMS_ERROR;
 801535a:	2300      	movs	r3, #0
 801535c:	e00b      	b.n	8015376 <LSM303AGR_ACC_R_Int1_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801535e:	9b00      	ldr	r3, [sp, #0]
 8015360:	781b      	ldrb	r3, [r3, #0]
 8015362:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015366:	b2da      	uxtb	r2, r3
 8015368:	9b00      	ldr	r3, [sp, #0]
 801536a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801536c:	9b00      	ldr	r3, [sp, #0]
 801536e:	781a      	ldrb	r2, [r3, #0]
 8015370:	9b00      	ldr	r3, [sp, #0]
 8015372:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015374:	2301      	movs	r3, #1
}
 8015376:	4618      	mov	r0, r3
 8015378:	b003      	add	sp, #12
 801537a:	f85d fb04 	ldr.w	pc, [sp], #4
 801537e:	bf00      	nop

08015380 <LSM303AGR_ACC_W_Int2_Duration>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_Int2_Duration(void *handle, u8_t newValue)
{
 8015380:	b500      	push	{lr}
 8015382:	b085      	sub	sp, #20
 8015384:	9001      	str	r0, [sp, #4]
 8015386:	460b      	mov	r3, r1
 8015388:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_D_POSITION; //mask
  newValue &= LSM303AGR_ACC_D_MASK; //coerce
 801538c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015390:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015394:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 8015398:	f10d 030f 	add.w	r3, sp, #15
 801539c:	9801      	ldr	r0, [sp, #4]
 801539e:	2137      	movs	r1, #55	; 0x37
 80153a0:	461a      	mov	r2, r3
 80153a2:	2301      	movs	r3, #1
 80153a4:	f7fc fd1c 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80153a8:	4603      	mov	r3, r0
 80153aa:	2b00      	cmp	r3, #0
 80153ac:	d101      	bne.n	80153b2 <LSM303AGR_ACC_W_Int2_Duration+0x32>
    return MEMS_ERROR;
 80153ae:	2300      	movs	r3, #0
 80153b0:	e01c      	b.n	80153ec <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  value &= ~LSM303AGR_ACC_D_MASK;
 80153b2:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80153b6:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 80153ba:	b2db      	uxtb	r3, r3
 80153bc:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80153c0:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80153c4:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80153c8:	4313      	orrs	r3, r2
 80153ca:	b2db      	uxtb	r3, r3
 80153cc:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_INT2_DURATION, &value, 1) )
 80153d0:	f10d 030f 	add.w	r3, sp, #15
 80153d4:	9801      	ldr	r0, [sp, #4]
 80153d6:	2137      	movs	r1, #55	; 0x37
 80153d8:	461a      	mov	r2, r3
 80153da:	2301      	movs	r3, #1
 80153dc:	f7fc fcd8 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80153e0:	4603      	mov	r3, r0
 80153e2:	2b00      	cmp	r3, #0
 80153e4:	d101      	bne.n	80153ea <LSM303AGR_ACC_W_Int2_Duration+0x6a>
    return MEMS_ERROR;
 80153e6:	2300      	movs	r3, #0
 80153e8:	e000      	b.n	80153ec <LSM303AGR_ACC_W_Int2_Duration+0x6c>

  return MEMS_SUCCESS;
 80153ea:	2301      	movs	r3, #1
}
 80153ec:	4618      	mov	r0, r3
 80153ee:	b005      	add	sp, #20
 80153f0:	f85d fb04 	ldr.w	pc, [sp], #4
 80153f4:	f3af 8000 	nop.w
 80153f8:	f3af 8000 	nop.w
 80153fc:	f3af 8000 	nop.w

08015400 <LSM303AGR_ACC_R_Int2_Duration>:
* Input          : Pointer to u8_t
* Output         : Status of D
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_Int2_Duration(void *handle, u8_t *value)
{
 8015400:	b500      	push	{lr}
 8015402:	b083      	sub	sp, #12
 8015404:	9001      	str	r0, [sp, #4]
 8015406:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_INT2_DURATION, (u8_t *)value, 1) )
 8015408:	9801      	ldr	r0, [sp, #4]
 801540a:	2137      	movs	r1, #55	; 0x37
 801540c:	9a00      	ldr	r2, [sp, #0]
 801540e:	2301      	movs	r3, #1
 8015410:	f7fc fce6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015414:	4603      	mov	r3, r0
 8015416:	2b00      	cmp	r3, #0
 8015418:	d101      	bne.n	801541e <LSM303AGR_ACC_R_Int2_Duration+0x1e>
    return MEMS_ERROR;
 801541a:	2300      	movs	r3, #0
 801541c:	e00b      	b.n	8015436 <LSM303AGR_ACC_R_Int2_Duration+0x36>

  *value &= LSM303AGR_ACC_D_MASK; //coerce
 801541e:	9b00      	ldr	r3, [sp, #0]
 8015420:	781b      	ldrb	r3, [r3, #0]
 8015422:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015426:	b2da      	uxtb	r2, r3
 8015428:	9b00      	ldr	r3, [sp, #0]
 801542a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_D_POSITION; //mask
 801542c:	9b00      	ldr	r3, [sp, #0]
 801542e:	781a      	ldrb	r2, [r3, #0]
 8015430:	9b00      	ldr	r3, [sp, #0]
 8015432:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015434:	2301      	movs	r3, #1
}
 8015436:	4618      	mov	r0, r3
 8015438:	b003      	add	sp, #12
 801543a:	f85d fb04 	ldr.w	pc, [sp], #4
 801543e:	bf00      	nop

08015440 <LSM303AGR_ACC_W_XSingle>:
* Input          : LSM303AGR_ACC_XS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XSingle(void *handle, LSM303AGR_ACC_XS_t newValue)
{
 8015440:	b500      	push	{lr}
 8015442:	b085      	sub	sp, #20
 8015444:	9001      	str	r0, [sp, #4]
 8015446:	460b      	mov	r3, r1
 8015448:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801544c:	f10d 030f 	add.w	r3, sp, #15
 8015450:	9801      	ldr	r0, [sp, #4]
 8015452:	2138      	movs	r1, #56	; 0x38
 8015454:	461a      	mov	r2, r3
 8015456:	2301      	movs	r3, #1
 8015458:	f7fc fcc2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801545c:	4603      	mov	r3, r0
 801545e:	2b00      	cmp	r3, #0
 8015460:	d101      	bne.n	8015466 <LSM303AGR_ACC_W_XSingle+0x26>
    return MEMS_ERROR;
 8015462:	2300      	movs	r3, #0
 8015464:	e01c      	b.n	80154a0 <LSM303AGR_ACC_W_XSingle+0x60>

  value &= ~LSM303AGR_ACC_XS_MASK;
 8015466:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801546a:	f023 0301 	bic.w	r3, r3, #1
 801546e:	b2db      	uxtb	r3, r3
 8015470:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015474:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015478:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801547c:	4313      	orrs	r3, r2
 801547e:	b2db      	uxtb	r3, r3
 8015480:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015484:	f10d 030f 	add.w	r3, sp, #15
 8015488:	9801      	ldr	r0, [sp, #4]
 801548a:	2138      	movs	r1, #56	; 0x38
 801548c:	461a      	mov	r2, r3
 801548e:	2301      	movs	r3, #1
 8015490:	f7fc fc7e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015494:	4603      	mov	r3, r0
 8015496:	2b00      	cmp	r3, #0
 8015498:	d101      	bne.n	801549e <LSM303AGR_ACC_W_XSingle+0x5e>
    return MEMS_ERROR;
 801549a:	2300      	movs	r3, #0
 801549c:	e000      	b.n	80154a0 <LSM303AGR_ACC_W_XSingle+0x60>

  return MEMS_SUCCESS;
 801549e:	2301      	movs	r3, #1
}
 80154a0:	4618      	mov	r0, r3
 80154a2:	b005      	add	sp, #20
 80154a4:	f85d fb04 	ldr.w	pc, [sp], #4
 80154a8:	f3af 8000 	nop.w
 80154ac:	f3af 8000 	nop.w

080154b0 <LSM303AGR_ACC_R_XSingle>:
* Input          : Pointer to LSM303AGR_ACC_XS_t
* Output         : Status of XS see LSM303AGR_ACC_XS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XSingle(void *handle, LSM303AGR_ACC_XS_t *value)
{
 80154b0:	b500      	push	{lr}
 80154b2:	b083      	sub	sp, #12
 80154b4:	9001      	str	r0, [sp, #4]
 80154b6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80154b8:	9801      	ldr	r0, [sp, #4]
 80154ba:	2138      	movs	r1, #56	; 0x38
 80154bc:	9a00      	ldr	r2, [sp, #0]
 80154be:	2301      	movs	r3, #1
 80154c0:	f7fc fc8e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80154c4:	4603      	mov	r3, r0
 80154c6:	2b00      	cmp	r3, #0
 80154c8:	d101      	bne.n	80154ce <LSM303AGR_ACC_R_XSingle+0x1e>
    return MEMS_ERROR;
 80154ca:	2300      	movs	r3, #0
 80154cc:	e007      	b.n	80154de <LSM303AGR_ACC_R_XSingle+0x2e>

  *value &= LSM303AGR_ACC_XS_MASK; //mask
 80154ce:	9b00      	ldr	r3, [sp, #0]
 80154d0:	781b      	ldrb	r3, [r3, #0]
 80154d2:	f003 0301 	and.w	r3, r3, #1
 80154d6:	b2da      	uxtb	r2, r3
 80154d8:	9b00      	ldr	r3, [sp, #0]
 80154da:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80154dc:	2301      	movs	r3, #1
}
 80154de:	4618      	mov	r0, r3
 80154e0:	b003      	add	sp, #12
 80154e2:	f85d fb04 	ldr.w	pc, [sp], #4
 80154e6:	bf00      	nop
 80154e8:	f3af 8000 	nop.w
 80154ec:	f3af 8000 	nop.w

080154f0 <LSM303AGR_ACC_W_XDouble>:
* Input          : LSM303AGR_ACC_XD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_XDouble(void *handle, LSM303AGR_ACC_XD_t newValue)
{
 80154f0:	b500      	push	{lr}
 80154f2:	b085      	sub	sp, #20
 80154f4:	9001      	str	r0, [sp, #4]
 80154f6:	460b      	mov	r3, r1
 80154f8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80154fc:	f10d 030f 	add.w	r3, sp, #15
 8015500:	9801      	ldr	r0, [sp, #4]
 8015502:	2138      	movs	r1, #56	; 0x38
 8015504:	461a      	mov	r2, r3
 8015506:	2301      	movs	r3, #1
 8015508:	f7fc fc6a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801550c:	4603      	mov	r3, r0
 801550e:	2b00      	cmp	r3, #0
 8015510:	d101      	bne.n	8015516 <LSM303AGR_ACC_W_XDouble+0x26>
    return MEMS_ERROR;
 8015512:	2300      	movs	r3, #0
 8015514:	e01c      	b.n	8015550 <LSM303AGR_ACC_W_XDouble+0x60>

  value &= ~LSM303AGR_ACC_XD_MASK;
 8015516:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801551a:	f023 0302 	bic.w	r3, r3, #2
 801551e:	b2db      	uxtb	r3, r3
 8015520:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015524:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015528:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801552c:	4313      	orrs	r3, r2
 801552e:	b2db      	uxtb	r3, r3
 8015530:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015534:	f10d 030f 	add.w	r3, sp, #15
 8015538:	9801      	ldr	r0, [sp, #4]
 801553a:	2138      	movs	r1, #56	; 0x38
 801553c:	461a      	mov	r2, r3
 801553e:	2301      	movs	r3, #1
 8015540:	f7fc fc26 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015544:	4603      	mov	r3, r0
 8015546:	2b00      	cmp	r3, #0
 8015548:	d101      	bne.n	801554e <LSM303AGR_ACC_W_XDouble+0x5e>
    return MEMS_ERROR;
 801554a:	2300      	movs	r3, #0
 801554c:	e000      	b.n	8015550 <LSM303AGR_ACC_W_XDouble+0x60>

  return MEMS_SUCCESS;
 801554e:	2301      	movs	r3, #1
}
 8015550:	4618      	mov	r0, r3
 8015552:	b005      	add	sp, #20
 8015554:	f85d fb04 	ldr.w	pc, [sp], #4
 8015558:	f3af 8000 	nop.w
 801555c:	f3af 8000 	nop.w

08015560 <LSM303AGR_ACC_R_XDouble>:
* Input          : Pointer to LSM303AGR_ACC_XD_t
* Output         : Status of XD see LSM303AGR_ACC_XD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_XDouble(void *handle, LSM303AGR_ACC_XD_t *value)
{
 8015560:	b500      	push	{lr}
 8015562:	b083      	sub	sp, #12
 8015564:	9001      	str	r0, [sp, #4]
 8015566:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015568:	9801      	ldr	r0, [sp, #4]
 801556a:	2138      	movs	r1, #56	; 0x38
 801556c:	9a00      	ldr	r2, [sp, #0]
 801556e:	2301      	movs	r3, #1
 8015570:	f7fc fc36 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015574:	4603      	mov	r3, r0
 8015576:	2b00      	cmp	r3, #0
 8015578:	d101      	bne.n	801557e <LSM303AGR_ACC_R_XDouble+0x1e>
    return MEMS_ERROR;
 801557a:	2300      	movs	r3, #0
 801557c:	e007      	b.n	801558e <LSM303AGR_ACC_R_XDouble+0x2e>

  *value &= LSM303AGR_ACC_XD_MASK; //mask
 801557e:	9b00      	ldr	r3, [sp, #0]
 8015580:	781b      	ldrb	r3, [r3, #0]
 8015582:	f003 0302 	and.w	r3, r3, #2
 8015586:	b2da      	uxtb	r2, r3
 8015588:	9b00      	ldr	r3, [sp, #0]
 801558a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801558c:	2301      	movs	r3, #1
}
 801558e:	4618      	mov	r0, r3
 8015590:	b003      	add	sp, #12
 8015592:	f85d fb04 	ldr.w	pc, [sp], #4
 8015596:	bf00      	nop
 8015598:	f3af 8000 	nop.w
 801559c:	f3af 8000 	nop.w

080155a0 <LSM303AGR_ACC_W_YSingle>:
* Input          : LSM303AGR_ACC_YS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YSingle(void *handle, LSM303AGR_ACC_YS_t newValue)
{
 80155a0:	b500      	push	{lr}
 80155a2:	b085      	sub	sp, #20
 80155a4:	9001      	str	r0, [sp, #4]
 80155a6:	460b      	mov	r3, r1
 80155a8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80155ac:	f10d 030f 	add.w	r3, sp, #15
 80155b0:	9801      	ldr	r0, [sp, #4]
 80155b2:	2138      	movs	r1, #56	; 0x38
 80155b4:	461a      	mov	r2, r3
 80155b6:	2301      	movs	r3, #1
 80155b8:	f7fc fc12 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80155bc:	4603      	mov	r3, r0
 80155be:	2b00      	cmp	r3, #0
 80155c0:	d101      	bne.n	80155c6 <LSM303AGR_ACC_W_YSingle+0x26>
    return MEMS_ERROR;
 80155c2:	2300      	movs	r3, #0
 80155c4:	e01c      	b.n	8015600 <LSM303AGR_ACC_W_YSingle+0x60>

  value &= ~LSM303AGR_ACC_YS_MASK;
 80155c6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80155ca:	f023 0304 	bic.w	r3, r3, #4
 80155ce:	b2db      	uxtb	r3, r3
 80155d0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80155d4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80155d8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80155dc:	4313      	orrs	r3, r2
 80155de:	b2db      	uxtb	r3, r3
 80155e0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80155e4:	f10d 030f 	add.w	r3, sp, #15
 80155e8:	9801      	ldr	r0, [sp, #4]
 80155ea:	2138      	movs	r1, #56	; 0x38
 80155ec:	461a      	mov	r2, r3
 80155ee:	2301      	movs	r3, #1
 80155f0:	f7fc fbce 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80155f4:	4603      	mov	r3, r0
 80155f6:	2b00      	cmp	r3, #0
 80155f8:	d101      	bne.n	80155fe <LSM303AGR_ACC_W_YSingle+0x5e>
    return MEMS_ERROR;
 80155fa:	2300      	movs	r3, #0
 80155fc:	e000      	b.n	8015600 <LSM303AGR_ACC_W_YSingle+0x60>

  return MEMS_SUCCESS;
 80155fe:	2301      	movs	r3, #1
}
 8015600:	4618      	mov	r0, r3
 8015602:	b005      	add	sp, #20
 8015604:	f85d fb04 	ldr.w	pc, [sp], #4
 8015608:	f3af 8000 	nop.w
 801560c:	f3af 8000 	nop.w

08015610 <LSM303AGR_ACC_R_YSingle>:
* Input          : Pointer to LSM303AGR_ACC_YS_t
* Output         : Status of YS see LSM303AGR_ACC_YS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YSingle(void *handle, LSM303AGR_ACC_YS_t *value)
{
 8015610:	b500      	push	{lr}
 8015612:	b083      	sub	sp, #12
 8015614:	9001      	str	r0, [sp, #4]
 8015616:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015618:	9801      	ldr	r0, [sp, #4]
 801561a:	2138      	movs	r1, #56	; 0x38
 801561c:	9a00      	ldr	r2, [sp, #0]
 801561e:	2301      	movs	r3, #1
 8015620:	f7fc fbde 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015624:	4603      	mov	r3, r0
 8015626:	2b00      	cmp	r3, #0
 8015628:	d101      	bne.n	801562e <LSM303AGR_ACC_R_YSingle+0x1e>
    return MEMS_ERROR;
 801562a:	2300      	movs	r3, #0
 801562c:	e007      	b.n	801563e <LSM303AGR_ACC_R_YSingle+0x2e>

  *value &= LSM303AGR_ACC_YS_MASK; //mask
 801562e:	9b00      	ldr	r3, [sp, #0]
 8015630:	781b      	ldrb	r3, [r3, #0]
 8015632:	f003 0304 	and.w	r3, r3, #4
 8015636:	b2da      	uxtb	r2, r3
 8015638:	9b00      	ldr	r3, [sp, #0]
 801563a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801563c:	2301      	movs	r3, #1
}
 801563e:	4618      	mov	r0, r3
 8015640:	b003      	add	sp, #12
 8015642:	f85d fb04 	ldr.w	pc, [sp], #4
 8015646:	bf00      	nop
 8015648:	f3af 8000 	nop.w
 801564c:	f3af 8000 	nop.w

08015650 <LSM303AGR_ACC_W_YDouble>:
* Input          : LSM303AGR_ACC_YD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_YDouble(void *handle, LSM303AGR_ACC_YD_t newValue)
{
 8015650:	b500      	push	{lr}
 8015652:	b085      	sub	sp, #20
 8015654:	9001      	str	r0, [sp, #4]
 8015656:	460b      	mov	r3, r1
 8015658:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801565c:	f10d 030f 	add.w	r3, sp, #15
 8015660:	9801      	ldr	r0, [sp, #4]
 8015662:	2138      	movs	r1, #56	; 0x38
 8015664:	461a      	mov	r2, r3
 8015666:	2301      	movs	r3, #1
 8015668:	f7fc fbba 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801566c:	4603      	mov	r3, r0
 801566e:	2b00      	cmp	r3, #0
 8015670:	d101      	bne.n	8015676 <LSM303AGR_ACC_W_YDouble+0x26>
    return MEMS_ERROR;
 8015672:	2300      	movs	r3, #0
 8015674:	e01c      	b.n	80156b0 <LSM303AGR_ACC_W_YDouble+0x60>

  value &= ~LSM303AGR_ACC_YD_MASK;
 8015676:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801567a:	f023 0308 	bic.w	r3, r3, #8
 801567e:	b2db      	uxtb	r3, r3
 8015680:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015684:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015688:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801568c:	4313      	orrs	r3, r2
 801568e:	b2db      	uxtb	r3, r3
 8015690:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015694:	f10d 030f 	add.w	r3, sp, #15
 8015698:	9801      	ldr	r0, [sp, #4]
 801569a:	2138      	movs	r1, #56	; 0x38
 801569c:	461a      	mov	r2, r3
 801569e:	2301      	movs	r3, #1
 80156a0:	f7fc fb76 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 80156a4:	4603      	mov	r3, r0
 80156a6:	2b00      	cmp	r3, #0
 80156a8:	d101      	bne.n	80156ae <LSM303AGR_ACC_W_YDouble+0x5e>
    return MEMS_ERROR;
 80156aa:	2300      	movs	r3, #0
 80156ac:	e000      	b.n	80156b0 <LSM303AGR_ACC_W_YDouble+0x60>

  return MEMS_SUCCESS;
 80156ae:	2301      	movs	r3, #1
}
 80156b0:	4618      	mov	r0, r3
 80156b2:	b005      	add	sp, #20
 80156b4:	f85d fb04 	ldr.w	pc, [sp], #4
 80156b8:	f3af 8000 	nop.w
 80156bc:	f3af 8000 	nop.w

080156c0 <LSM303AGR_ACC_R_YDouble>:
* Input          : Pointer to LSM303AGR_ACC_YD_t
* Output         : Status of YD see LSM303AGR_ACC_YD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_YDouble(void *handle, LSM303AGR_ACC_YD_t *value)
{
 80156c0:	b500      	push	{lr}
 80156c2:	b083      	sub	sp, #12
 80156c4:	9001      	str	r0, [sp, #4]
 80156c6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 80156c8:	9801      	ldr	r0, [sp, #4]
 80156ca:	2138      	movs	r1, #56	; 0x38
 80156cc:	9a00      	ldr	r2, [sp, #0]
 80156ce:	2301      	movs	r3, #1
 80156d0:	f7fc fb86 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80156d4:	4603      	mov	r3, r0
 80156d6:	2b00      	cmp	r3, #0
 80156d8:	d101      	bne.n	80156de <LSM303AGR_ACC_R_YDouble+0x1e>
    return MEMS_ERROR;
 80156da:	2300      	movs	r3, #0
 80156dc:	e007      	b.n	80156ee <LSM303AGR_ACC_R_YDouble+0x2e>

  *value &= LSM303AGR_ACC_YD_MASK; //mask
 80156de:	9b00      	ldr	r3, [sp, #0]
 80156e0:	781b      	ldrb	r3, [r3, #0]
 80156e2:	f003 0308 	and.w	r3, r3, #8
 80156e6:	b2da      	uxtb	r2, r3
 80156e8:	9b00      	ldr	r3, [sp, #0]
 80156ea:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80156ec:	2301      	movs	r3, #1
}
 80156ee:	4618      	mov	r0, r3
 80156f0:	b003      	add	sp, #12
 80156f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80156f6:	bf00      	nop
 80156f8:	f3af 8000 	nop.w
 80156fc:	f3af 8000 	nop.w

08015700 <LSM303AGR_ACC_W_ZSingle>:
* Input          : LSM303AGR_ACC_ZS_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZSingle(void *handle, LSM303AGR_ACC_ZS_t newValue)
{
 8015700:	b500      	push	{lr}
 8015702:	b085      	sub	sp, #20
 8015704:	9001      	str	r0, [sp, #4]
 8015706:	460b      	mov	r3, r1
 8015708:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 801570c:	f10d 030f 	add.w	r3, sp, #15
 8015710:	9801      	ldr	r0, [sp, #4]
 8015712:	2138      	movs	r1, #56	; 0x38
 8015714:	461a      	mov	r2, r3
 8015716:	2301      	movs	r3, #1
 8015718:	f7fc fb62 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 801571c:	4603      	mov	r3, r0
 801571e:	2b00      	cmp	r3, #0
 8015720:	d101      	bne.n	8015726 <LSM303AGR_ACC_W_ZSingle+0x26>
    return MEMS_ERROR;
 8015722:	2300      	movs	r3, #0
 8015724:	e01c      	b.n	8015760 <LSM303AGR_ACC_W_ZSingle+0x60>

  value &= ~LSM303AGR_ACC_ZS_MASK;
 8015726:	f89d 300f 	ldrb.w	r3, [sp, #15]
 801572a:	f023 0310 	bic.w	r3, r3, #16
 801572e:	b2db      	uxtb	r3, r3
 8015730:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015734:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015738:	f89d 3003 	ldrb.w	r3, [sp, #3]
 801573c:	4313      	orrs	r3, r2
 801573e:	b2db      	uxtb	r3, r3
 8015740:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 8015744:	f10d 030f 	add.w	r3, sp, #15
 8015748:	9801      	ldr	r0, [sp, #4]
 801574a:	2138      	movs	r1, #56	; 0x38
 801574c:	461a      	mov	r2, r3
 801574e:	2301      	movs	r3, #1
 8015750:	f7fc fb1e 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015754:	4603      	mov	r3, r0
 8015756:	2b00      	cmp	r3, #0
 8015758:	d101      	bne.n	801575e <LSM303AGR_ACC_W_ZSingle+0x5e>
    return MEMS_ERROR;
 801575a:	2300      	movs	r3, #0
 801575c:	e000      	b.n	8015760 <LSM303AGR_ACC_W_ZSingle+0x60>

  return MEMS_SUCCESS;
 801575e:	2301      	movs	r3, #1
}
 8015760:	4618      	mov	r0, r3
 8015762:	b005      	add	sp, #20
 8015764:	f85d fb04 	ldr.w	pc, [sp], #4
 8015768:	f3af 8000 	nop.w
 801576c:	f3af 8000 	nop.w

08015770 <LSM303AGR_ACC_R_ZSingle>:
* Input          : Pointer to LSM303AGR_ACC_ZS_t
* Output         : Status of ZS see LSM303AGR_ACC_ZS_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZSingle(void *handle, LSM303AGR_ACC_ZS_t *value)
{
 8015770:	b500      	push	{lr}
 8015772:	b083      	sub	sp, #12
 8015774:	9001      	str	r0, [sp, #4]
 8015776:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015778:	9801      	ldr	r0, [sp, #4]
 801577a:	2138      	movs	r1, #56	; 0x38
 801577c:	9a00      	ldr	r2, [sp, #0]
 801577e:	2301      	movs	r3, #1
 8015780:	f7fc fb2e 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015784:	4603      	mov	r3, r0
 8015786:	2b00      	cmp	r3, #0
 8015788:	d101      	bne.n	801578e <LSM303AGR_ACC_R_ZSingle+0x1e>
    return MEMS_ERROR;
 801578a:	2300      	movs	r3, #0
 801578c:	e007      	b.n	801579e <LSM303AGR_ACC_R_ZSingle+0x2e>

  *value &= LSM303AGR_ACC_ZS_MASK; //mask
 801578e:	9b00      	ldr	r3, [sp, #0]
 8015790:	781b      	ldrb	r3, [r3, #0]
 8015792:	f003 0310 	and.w	r3, r3, #16
 8015796:	b2da      	uxtb	r2, r3
 8015798:	9b00      	ldr	r3, [sp, #0]
 801579a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801579c:	2301      	movs	r3, #1
}
 801579e:	4618      	mov	r0, r3
 80157a0:	b003      	add	sp, #12
 80157a2:	f85d fb04 	ldr.w	pc, [sp], #4
 80157a6:	bf00      	nop
 80157a8:	f3af 8000 	nop.w
 80157ac:	f3af 8000 	nop.w

080157b0 <LSM303AGR_ACC_W_ZDouble>:
* Input          : LSM303AGR_ACC_ZD_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ZDouble(void *handle, LSM303AGR_ACC_ZD_t newValue)
{
 80157b0:	b500      	push	{lr}
 80157b2:	b085      	sub	sp, #20
 80157b4:	9001      	str	r0, [sp, #4]
 80157b6:	460b      	mov	r3, r1
 80157b8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80157bc:	f10d 030f 	add.w	r3, sp, #15
 80157c0:	9801      	ldr	r0, [sp, #4]
 80157c2:	2138      	movs	r1, #56	; 0x38
 80157c4:	461a      	mov	r2, r3
 80157c6:	2301      	movs	r3, #1
 80157c8:	f7fc fb0a 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80157cc:	4603      	mov	r3, r0
 80157ce:	2b00      	cmp	r3, #0
 80157d0:	d101      	bne.n	80157d6 <LSM303AGR_ACC_W_ZDouble+0x26>
    return MEMS_ERROR;
 80157d2:	2300      	movs	r3, #0
 80157d4:	e01c      	b.n	8015810 <LSM303AGR_ACC_W_ZDouble+0x60>

  value &= ~LSM303AGR_ACC_ZD_MASK;
 80157d6:	f89d 300f 	ldrb.w	r3, [sp, #15]
 80157da:	f023 0320 	bic.w	r3, r3, #32
 80157de:	b2db      	uxtb	r3, r3
 80157e0:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 80157e4:	f89d 200f 	ldrb.w	r2, [sp, #15]
 80157e8:	f89d 3003 	ldrb.w	r3, [sp, #3]
 80157ec:	4313      	orrs	r3, r2
 80157ee:	b2db      	uxtb	r3, r3
 80157f0:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_CFG, &value, 1) )
 80157f4:	f10d 030f 	add.w	r3, sp, #15
 80157f8:	9801      	ldr	r0, [sp, #4]
 80157fa:	2138      	movs	r1, #56	; 0x38
 80157fc:	461a      	mov	r2, r3
 80157fe:	2301      	movs	r3, #1
 8015800:	f7fc fac6 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015804:	4603      	mov	r3, r0
 8015806:	2b00      	cmp	r3, #0
 8015808:	d101      	bne.n	801580e <LSM303AGR_ACC_W_ZDouble+0x5e>
    return MEMS_ERROR;
 801580a:	2300      	movs	r3, #0
 801580c:	e000      	b.n	8015810 <LSM303AGR_ACC_W_ZDouble+0x60>

  return MEMS_SUCCESS;
 801580e:	2301      	movs	r3, #1
}
 8015810:	4618      	mov	r0, r3
 8015812:	b005      	add	sp, #20
 8015814:	f85d fb04 	ldr.w	pc, [sp], #4
 8015818:	f3af 8000 	nop.w
 801581c:	f3af 8000 	nop.w

08015820 <LSM303AGR_ACC_R_ZDouble>:
* Input          : Pointer to LSM303AGR_ACC_ZD_t
* Output         : Status of ZD see LSM303AGR_ACC_ZD_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ZDouble(void *handle, LSM303AGR_ACC_ZD_t *value)
{
 8015820:	b500      	push	{lr}
 8015822:	b083      	sub	sp, #12
 8015824:	9001      	str	r0, [sp, #4]
 8015826:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_CFG, (u8_t *)value, 1) )
 8015828:	9801      	ldr	r0, [sp, #4]
 801582a:	2138      	movs	r1, #56	; 0x38
 801582c:	9a00      	ldr	r2, [sp, #0]
 801582e:	2301      	movs	r3, #1
 8015830:	f7fc fad6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015834:	4603      	mov	r3, r0
 8015836:	2b00      	cmp	r3, #0
 8015838:	d101      	bne.n	801583e <LSM303AGR_ACC_R_ZDouble+0x1e>
    return MEMS_ERROR;
 801583a:	2300      	movs	r3, #0
 801583c:	e007      	b.n	801584e <LSM303AGR_ACC_R_ZDouble+0x2e>

  *value &= LSM303AGR_ACC_ZD_MASK; //mask
 801583e:	9b00      	ldr	r3, [sp, #0]
 8015840:	781b      	ldrb	r3, [r3, #0]
 8015842:	f003 0320 	and.w	r3, r3, #32
 8015846:	b2da      	uxtb	r2, r3
 8015848:	9b00      	ldr	r3, [sp, #0]
 801584a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801584c:	2301      	movs	r3, #1
}
 801584e:	4618      	mov	r0, r3
 8015850:	b003      	add	sp, #12
 8015852:	f85d fb04 	ldr.w	pc, [sp], #4
 8015856:	bf00      	nop
 8015858:	f3af 8000 	nop.w
 801585c:	f3af 8000 	nop.w

08015860 <LSM303AGR_ACC_R_ClickX>:
* Input          : Pointer to LSM303AGR_ACC_X_t
* Output         : Status of X see LSM303AGR_ACC_X_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickX(void *handle, LSM303AGR_ACC_X_t *value)
{
 8015860:	b500      	push	{lr}
 8015862:	b083      	sub	sp, #12
 8015864:	9001      	str	r0, [sp, #4]
 8015866:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015868:	9801      	ldr	r0, [sp, #4]
 801586a:	2139      	movs	r1, #57	; 0x39
 801586c:	9a00      	ldr	r2, [sp, #0]
 801586e:	2301      	movs	r3, #1
 8015870:	f7fc fab6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015874:	4603      	mov	r3, r0
 8015876:	2b00      	cmp	r3, #0
 8015878:	d101      	bne.n	801587e <LSM303AGR_ACC_R_ClickX+0x1e>
    return MEMS_ERROR;
 801587a:	2300      	movs	r3, #0
 801587c:	e007      	b.n	801588e <LSM303AGR_ACC_R_ClickX+0x2e>

  *value &= LSM303AGR_ACC_X_MASK; //mask
 801587e:	9b00      	ldr	r3, [sp, #0]
 8015880:	781b      	ldrb	r3, [r3, #0]
 8015882:	f003 0301 	and.w	r3, r3, #1
 8015886:	b2da      	uxtb	r2, r3
 8015888:	9b00      	ldr	r3, [sp, #0]
 801588a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801588c:	2301      	movs	r3, #1
}
 801588e:	4618      	mov	r0, r3
 8015890:	b003      	add	sp, #12
 8015892:	f85d fb04 	ldr.w	pc, [sp], #4
 8015896:	bf00      	nop
 8015898:	f3af 8000 	nop.w
 801589c:	f3af 8000 	nop.w

080158a0 <LSM303AGR_ACC_R_ClickY>:
* Input          : Pointer to LSM303AGR_ACC_Y_t
* Output         : Status of Y see LSM303AGR_ACC_Y_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickY(void *handle, LSM303AGR_ACC_Y_t *value)
{
 80158a0:	b500      	push	{lr}
 80158a2:	b083      	sub	sp, #12
 80158a4:	9001      	str	r0, [sp, #4]
 80158a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 80158a8:	9801      	ldr	r0, [sp, #4]
 80158aa:	2139      	movs	r1, #57	; 0x39
 80158ac:	9a00      	ldr	r2, [sp, #0]
 80158ae:	2301      	movs	r3, #1
 80158b0:	f7fc fa96 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80158b4:	4603      	mov	r3, r0
 80158b6:	2b00      	cmp	r3, #0
 80158b8:	d101      	bne.n	80158be <LSM303AGR_ACC_R_ClickY+0x1e>
    return MEMS_ERROR;
 80158ba:	2300      	movs	r3, #0
 80158bc:	e007      	b.n	80158ce <LSM303AGR_ACC_R_ClickY+0x2e>

  *value &= LSM303AGR_ACC_Y_MASK; //mask
 80158be:	9b00      	ldr	r3, [sp, #0]
 80158c0:	781b      	ldrb	r3, [r3, #0]
 80158c2:	f003 0302 	and.w	r3, r3, #2
 80158c6:	b2da      	uxtb	r2, r3
 80158c8:	9b00      	ldr	r3, [sp, #0]
 80158ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80158cc:	2301      	movs	r3, #1
}
 80158ce:	4618      	mov	r0, r3
 80158d0:	b003      	add	sp, #12
 80158d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80158d6:	bf00      	nop
 80158d8:	f3af 8000 	nop.w
 80158dc:	f3af 8000 	nop.w

080158e0 <LSM303AGR_ACC_R_ClickZ>:
* Input          : Pointer to LSM303AGR_ACC_Z_t
* Output         : Status of Z see LSM303AGR_ACC_Z_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickZ(void *handle, LSM303AGR_ACC_Z_t *value)
{
 80158e0:	b500      	push	{lr}
 80158e2:	b083      	sub	sp, #12
 80158e4:	9001      	str	r0, [sp, #4]
 80158e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 80158e8:	9801      	ldr	r0, [sp, #4]
 80158ea:	2139      	movs	r1, #57	; 0x39
 80158ec:	9a00      	ldr	r2, [sp, #0]
 80158ee:	2301      	movs	r3, #1
 80158f0:	f7fc fa76 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80158f4:	4603      	mov	r3, r0
 80158f6:	2b00      	cmp	r3, #0
 80158f8:	d101      	bne.n	80158fe <LSM303AGR_ACC_R_ClickZ+0x1e>
    return MEMS_ERROR;
 80158fa:	2300      	movs	r3, #0
 80158fc:	e007      	b.n	801590e <LSM303AGR_ACC_R_ClickZ+0x2e>

  *value &= LSM303AGR_ACC_Z_MASK; //mask
 80158fe:	9b00      	ldr	r3, [sp, #0]
 8015900:	781b      	ldrb	r3, [r3, #0]
 8015902:	f003 0304 	and.w	r3, r3, #4
 8015906:	b2da      	uxtb	r2, r3
 8015908:	9b00      	ldr	r3, [sp, #0]
 801590a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801590c:	2301      	movs	r3, #1
}
 801590e:	4618      	mov	r0, r3
 8015910:	b003      	add	sp, #12
 8015912:	f85d fb04 	ldr.w	pc, [sp], #4
 8015916:	bf00      	nop
 8015918:	f3af 8000 	nop.w
 801591c:	f3af 8000 	nop.w

08015920 <LSM303AGR_ACC_R_ClickSign>:
* Input          : Pointer to LSM303AGR_ACC_SIGN_t
* Output         : Status of SIGN see LSM303AGR_ACC_SIGN_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickSign(void *handle, LSM303AGR_ACC_SIGN_t *value)
{
 8015920:	b500      	push	{lr}
 8015922:	b083      	sub	sp, #12
 8015924:	9001      	str	r0, [sp, #4]
 8015926:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015928:	9801      	ldr	r0, [sp, #4]
 801592a:	2139      	movs	r1, #57	; 0x39
 801592c:	9a00      	ldr	r2, [sp, #0]
 801592e:	2301      	movs	r3, #1
 8015930:	f7fc fa56 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015934:	4603      	mov	r3, r0
 8015936:	2b00      	cmp	r3, #0
 8015938:	d101      	bne.n	801593e <LSM303AGR_ACC_R_ClickSign+0x1e>
    return MEMS_ERROR;
 801593a:	2300      	movs	r3, #0
 801593c:	e007      	b.n	801594e <LSM303AGR_ACC_R_ClickSign+0x2e>

  *value &= LSM303AGR_ACC_SIGN_MASK; //mask
 801593e:	9b00      	ldr	r3, [sp, #0]
 8015940:	781b      	ldrb	r3, [r3, #0]
 8015942:	f003 0308 	and.w	r3, r3, #8
 8015946:	b2da      	uxtb	r2, r3
 8015948:	9b00      	ldr	r3, [sp, #0]
 801594a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801594c:	2301      	movs	r3, #1
}
 801594e:	4618      	mov	r0, r3
 8015950:	b003      	add	sp, #12
 8015952:	f85d fb04 	ldr.w	pc, [sp], #4
 8015956:	bf00      	nop
 8015958:	f3af 8000 	nop.w
 801595c:	f3af 8000 	nop.w

08015960 <LSM303AGR_ACC_R_SingleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_SCLICK_t
* Output         : Status of SCLICK see LSM303AGR_ACC_SCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_SingleCLICK(void *handle, LSM303AGR_ACC_SCLICK_t *value)
{
 8015960:	b500      	push	{lr}
 8015962:	b083      	sub	sp, #12
 8015964:	9001      	str	r0, [sp, #4]
 8015966:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 8015968:	9801      	ldr	r0, [sp, #4]
 801596a:	2139      	movs	r1, #57	; 0x39
 801596c:	9a00      	ldr	r2, [sp, #0]
 801596e:	2301      	movs	r3, #1
 8015970:	f7fc fa36 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015974:	4603      	mov	r3, r0
 8015976:	2b00      	cmp	r3, #0
 8015978:	d101      	bne.n	801597e <LSM303AGR_ACC_R_SingleCLICK+0x1e>
    return MEMS_ERROR;
 801597a:	2300      	movs	r3, #0
 801597c:	e007      	b.n	801598e <LSM303AGR_ACC_R_SingleCLICK+0x2e>

  *value &= LSM303AGR_ACC_SCLICK_MASK; //mask
 801597e:	9b00      	ldr	r3, [sp, #0]
 8015980:	781b      	ldrb	r3, [r3, #0]
 8015982:	f003 0310 	and.w	r3, r3, #16
 8015986:	b2da      	uxtb	r2, r3
 8015988:	9b00      	ldr	r3, [sp, #0]
 801598a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 801598c:	2301      	movs	r3, #1
}
 801598e:	4618      	mov	r0, r3
 8015990:	b003      	add	sp, #12
 8015992:	f85d fb04 	ldr.w	pc, [sp], #4
 8015996:	bf00      	nop
 8015998:	f3af 8000 	nop.w
 801599c:	f3af 8000 	nop.w

080159a0 <LSM303AGR_ACC_R_DoubleCLICK>:
* Input          : Pointer to LSM303AGR_ACC_DCLICK_t
* Output         : Status of DCLICK see LSM303AGR_ACC_DCLICK_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_DoubleCLICK(void *handle, LSM303AGR_ACC_DCLICK_t *value)
{
 80159a0:	b500      	push	{lr}
 80159a2:	b083      	sub	sp, #12
 80159a4:	9001      	str	r0, [sp, #4]
 80159a6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 80159a8:	9801      	ldr	r0, [sp, #4]
 80159aa:	2139      	movs	r1, #57	; 0x39
 80159ac:	9a00      	ldr	r2, [sp, #0]
 80159ae:	2301      	movs	r3, #1
 80159b0:	f7fc fa16 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80159b4:	4603      	mov	r3, r0
 80159b6:	2b00      	cmp	r3, #0
 80159b8:	d101      	bne.n	80159be <LSM303AGR_ACC_R_DoubleCLICK+0x1e>
    return MEMS_ERROR;
 80159ba:	2300      	movs	r3, #0
 80159bc:	e007      	b.n	80159ce <LSM303AGR_ACC_R_DoubleCLICK+0x2e>

  *value &= LSM303AGR_ACC_DCLICK_MASK; //mask
 80159be:	9b00      	ldr	r3, [sp, #0]
 80159c0:	781b      	ldrb	r3, [r3, #0]
 80159c2:	f003 0320 	and.w	r3, r3, #32
 80159c6:	b2da      	uxtb	r2, r3
 80159c8:	9b00      	ldr	r3, [sp, #0]
 80159ca:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 80159cc:	2301      	movs	r3, #1
}
 80159ce:	4618      	mov	r0, r3
 80159d0:	b003      	add	sp, #12
 80159d2:	f85d fb04 	ldr.w	pc, [sp], #4
 80159d6:	bf00      	nop
 80159d8:	f3af 8000 	nop.w
 80159dc:	f3af 8000 	nop.w

080159e0 <LSM303AGR_ACC_R_CLICK_IA>:
* Input          : Pointer to LSM303AGR_ACC_IA_t
* Output         : Status of IA see LSM303AGR_ACC_IA_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_CLICK_IA(void *handle, LSM303AGR_ACC_CLICK_IA_t *value)
{
 80159e0:	b500      	push	{lr}
 80159e2:	b083      	sub	sp, #12
 80159e4:	9001      	str	r0, [sp, #4]
 80159e6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_SRC, (u8_t *)value, 1) )
 80159e8:	9801      	ldr	r0, [sp, #4]
 80159ea:	2139      	movs	r1, #57	; 0x39
 80159ec:	9a00      	ldr	r2, [sp, #0]
 80159ee:	2301      	movs	r3, #1
 80159f0:	f7fc f9f6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 80159f4:	4603      	mov	r3, r0
 80159f6:	2b00      	cmp	r3, #0
 80159f8:	d101      	bne.n	80159fe <LSM303AGR_ACC_R_CLICK_IA+0x1e>
    return MEMS_ERROR;
 80159fa:	2300      	movs	r3, #0
 80159fc:	e007      	b.n	8015a0e <LSM303AGR_ACC_R_CLICK_IA+0x2e>

  *value &= LSM303AGR_ACC_IA_MASK; //mask
 80159fe:	9b00      	ldr	r3, [sp, #0]
 8015a00:	781b      	ldrb	r3, [r3, #0]
 8015a02:	f003 0340 	and.w	r3, r3, #64	; 0x40
 8015a06:	b2da      	uxtb	r2, r3
 8015a08:	9b00      	ldr	r3, [sp, #0]
 8015a0a:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015a0c:	2301      	movs	r3, #1
}
 8015a0e:	4618      	mov	r0, r3
 8015a10:	b003      	add	sp, #12
 8015a12:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a16:	bf00      	nop
 8015a18:	f3af 8000 	nop.w
 8015a1c:	f3af 8000 	nop.w

08015a20 <LSM303AGR_ACC_W_ClickThreshold>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickThreshold(void *handle, u8_t newValue)
{
 8015a20:	b500      	push	{lr}
 8015a22:	b085      	sub	sp, #20
 8015a24:	9001      	str	r0, [sp, #4]
 8015a26:	460b      	mov	r3, r1
 8015a28:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_THS_POSITION; //mask
  newValue &= LSM303AGR_ACC_THS_MASK; //coerce
 8015a2c:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a30:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015a34:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8015a38:	f10d 030f 	add.w	r3, sp, #15
 8015a3c:	9801      	ldr	r0, [sp, #4]
 8015a3e:	213a      	movs	r1, #58	; 0x3a
 8015a40:	461a      	mov	r2, r3
 8015a42:	2301      	movs	r3, #1
 8015a44:	f7fc f9cc 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015a48:	4603      	mov	r3, r0
 8015a4a:	2b00      	cmp	r3, #0
 8015a4c:	d101      	bne.n	8015a52 <LSM303AGR_ACC_W_ClickThreshold+0x32>
    return MEMS_ERROR;
 8015a4e:	2300      	movs	r3, #0
 8015a50:	e01c      	b.n	8015a8c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  value &= ~LSM303AGR_ACC_THS_MASK;
 8015a52:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015a56:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015a5a:	b2db      	uxtb	r3, r3
 8015a5c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015a60:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015a64:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015a68:	4313      	orrs	r3, r2
 8015a6a:	b2db      	uxtb	r3, r3
 8015a6c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_CLICK_THS, &value, 1) )
 8015a70:	f10d 030f 	add.w	r3, sp, #15
 8015a74:	9801      	ldr	r0, [sp, #4]
 8015a76:	213a      	movs	r1, #58	; 0x3a
 8015a78:	461a      	mov	r2, r3
 8015a7a:	2301      	movs	r3, #1
 8015a7c:	f7fc f988 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015a80:	4603      	mov	r3, r0
 8015a82:	2b00      	cmp	r3, #0
 8015a84:	d101      	bne.n	8015a8a <LSM303AGR_ACC_W_ClickThreshold+0x6a>
    return MEMS_ERROR;
 8015a86:	2300      	movs	r3, #0
 8015a88:	e000      	b.n	8015a8c <LSM303AGR_ACC_W_ClickThreshold+0x6c>

  return MEMS_SUCCESS;
 8015a8a:	2301      	movs	r3, #1
}
 8015a8c:	4618      	mov	r0, r3
 8015a8e:	b005      	add	sp, #20
 8015a90:	f85d fb04 	ldr.w	pc, [sp], #4
 8015a94:	f3af 8000 	nop.w
 8015a98:	f3af 8000 	nop.w
 8015a9c:	f3af 8000 	nop.w

08015aa0 <LSM303AGR_ACC_R_ClickThreshold>:
* Input          : Pointer to u8_t
* Output         : Status of THS
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickThreshold(void *handle, u8_t *value)
{
 8015aa0:	b500      	push	{lr}
 8015aa2:	b083      	sub	sp, #12
 8015aa4:	9001      	str	r0, [sp, #4]
 8015aa6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_CLICK_THS, (u8_t *)value, 1) )
 8015aa8:	9801      	ldr	r0, [sp, #4]
 8015aaa:	213a      	movs	r1, #58	; 0x3a
 8015aac:	9a00      	ldr	r2, [sp, #0]
 8015aae:	2301      	movs	r3, #1
 8015ab0:	f7fc f996 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015ab4:	4603      	mov	r3, r0
 8015ab6:	2b00      	cmp	r3, #0
 8015ab8:	d101      	bne.n	8015abe <LSM303AGR_ACC_R_ClickThreshold+0x1e>
    return MEMS_ERROR;
 8015aba:	2300      	movs	r3, #0
 8015abc:	e00b      	b.n	8015ad6 <LSM303AGR_ACC_R_ClickThreshold+0x36>

  *value &= LSM303AGR_ACC_THS_MASK; //coerce
 8015abe:	9b00      	ldr	r3, [sp, #0]
 8015ac0:	781b      	ldrb	r3, [r3, #0]
 8015ac2:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015ac6:	b2da      	uxtb	r2, r3
 8015ac8:	9b00      	ldr	r3, [sp, #0]
 8015aca:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_THS_POSITION; //mask
 8015acc:	9b00      	ldr	r3, [sp, #0]
 8015ace:	781a      	ldrb	r2, [r3, #0]
 8015ad0:	9b00      	ldr	r3, [sp, #0]
 8015ad2:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015ad4:	2301      	movs	r3, #1
}
 8015ad6:	4618      	mov	r0, r3
 8015ad8:	b003      	add	sp, #12
 8015ada:	f85d fb04 	ldr.w	pc, [sp], #4
 8015ade:	bf00      	nop

08015ae0 <LSM303AGR_ACC_W_ClickTimeLimit>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLimit(void *handle, u8_t newValue)
{
 8015ae0:	b500      	push	{lr}
 8015ae2:	b085      	sub	sp, #20
 8015ae4:	9001      	str	r0, [sp, #4]
 8015ae6:	460b      	mov	r3, r1
 8015ae8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLI_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLI_MASK; //coerce
 8015aec:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015af0:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015af4:	f88d 3003 	strb.w	r3, [sp, #3]

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8015af8:	f10d 030f 	add.w	r3, sp, #15
 8015afc:	9801      	ldr	r0, [sp, #4]
 8015afe:	213b      	movs	r1, #59	; 0x3b
 8015b00:	461a      	mov	r2, r3
 8015b02:	2301      	movs	r3, #1
 8015b04:	f7fc f96c 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015b08:	4603      	mov	r3, r0
 8015b0a:	2b00      	cmp	r3, #0
 8015b0c:	d101      	bne.n	8015b12 <LSM303AGR_ACC_W_ClickTimeLimit+0x32>
    return MEMS_ERROR;
 8015b0e:	2300      	movs	r3, #0
 8015b10:	e01c      	b.n	8015b4c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  value &= ~LSM303AGR_ACC_TLI_MASK;
 8015b12:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015b16:	f023 037f 	bic.w	r3, r3, #127	; 0x7f
 8015b1a:	b2db      	uxtb	r3, r3
 8015b1c:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015b20:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015b24:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015b28:	4313      	orrs	r3, r2
 8015b2a:	b2db      	uxtb	r3, r3
 8015b2c:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LIMIT, &value, 1) )
 8015b30:	f10d 030f 	add.w	r3, sp, #15
 8015b34:	9801      	ldr	r0, [sp, #4]
 8015b36:	213b      	movs	r1, #59	; 0x3b
 8015b38:	461a      	mov	r2, r3
 8015b3a:	2301      	movs	r3, #1
 8015b3c:	f7fc f928 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015b40:	4603      	mov	r3, r0
 8015b42:	2b00      	cmp	r3, #0
 8015b44:	d101      	bne.n	8015b4a <LSM303AGR_ACC_W_ClickTimeLimit+0x6a>
    return MEMS_ERROR;
 8015b46:	2300      	movs	r3, #0
 8015b48:	e000      	b.n	8015b4c <LSM303AGR_ACC_W_ClickTimeLimit+0x6c>

  return MEMS_SUCCESS;
 8015b4a:	2301      	movs	r3, #1
}
 8015b4c:	4618      	mov	r0, r3
 8015b4e:	b005      	add	sp, #20
 8015b50:	f85d fb04 	ldr.w	pc, [sp], #4
 8015b54:	f3af 8000 	nop.w
 8015b58:	f3af 8000 	nop.w
 8015b5c:	f3af 8000 	nop.w

08015b60 <LSM303AGR_ACC_R_ClickTimeLimit>:
* Input          : Pointer to u8_t
* Output         : Status of TLI
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLimit(void *handle, u8_t *value)
{
 8015b60:	b500      	push	{lr}
 8015b62:	b083      	sub	sp, #12
 8015b64:	9001      	str	r0, [sp, #4]
 8015b66:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LIMIT, (u8_t *)value, 1) )
 8015b68:	9801      	ldr	r0, [sp, #4]
 8015b6a:	213b      	movs	r1, #59	; 0x3b
 8015b6c:	9a00      	ldr	r2, [sp, #0]
 8015b6e:	2301      	movs	r3, #1
 8015b70:	f7fc f936 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015b74:	4603      	mov	r3, r0
 8015b76:	2b00      	cmp	r3, #0
 8015b78:	d101      	bne.n	8015b7e <LSM303AGR_ACC_R_ClickTimeLimit+0x1e>
    return MEMS_ERROR;
 8015b7a:	2300      	movs	r3, #0
 8015b7c:	e00b      	b.n	8015b96 <LSM303AGR_ACC_R_ClickTimeLimit+0x36>

  *value &= LSM303AGR_ACC_TLI_MASK; //coerce
 8015b7e:	9b00      	ldr	r3, [sp, #0]
 8015b80:	781b      	ldrb	r3, [r3, #0]
 8015b82:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015b86:	b2da      	uxtb	r2, r3
 8015b88:	9b00      	ldr	r3, [sp, #0]
 8015b8a:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLI_POSITION; //mask
 8015b8c:	9b00      	ldr	r3, [sp, #0]
 8015b8e:	781a      	ldrb	r2, [r3, #0]
 8015b90:	9b00      	ldr	r3, [sp, #0]
 8015b92:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015b94:	2301      	movs	r3, #1
}
 8015b96:	4618      	mov	r0, r3
 8015b98:	b003      	add	sp, #12
 8015b9a:	f85d fb04 	ldr.w	pc, [sp], #4
 8015b9e:	bf00      	nop

08015ba0 <LSM303AGR_ACC_W_ClickTimeLatency>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeLatency(void *handle, u8_t newValue)
{
 8015ba0:	b500      	push	{lr}
 8015ba2:	b085      	sub	sp, #20
 8015ba4:	9001      	str	r0, [sp, #4]
 8015ba6:	460b      	mov	r3, r1
 8015ba8:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TLA_POSITION; //mask
  newValue &= LSM303AGR_ACC_TLA_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 8015bac:	f10d 030f 	add.w	r3, sp, #15
 8015bb0:	9801      	ldr	r0, [sp, #4]
 8015bb2:	213c      	movs	r1, #60	; 0x3c
 8015bb4:	461a      	mov	r2, r3
 8015bb6:	2301      	movs	r3, #1
 8015bb8:	f7fc f912 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015bbc:	4603      	mov	r3, r0
 8015bbe:	2b00      	cmp	r3, #0
 8015bc0:	d101      	bne.n	8015bc6 <LSM303AGR_ACC_W_ClickTimeLatency+0x26>
    return MEMS_ERROR;
 8015bc2:	2300      	movs	r3, #0
 8015bc4:	e018      	b.n	8015bf8 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TLA_MASK;
 8015bc6:	2300      	movs	r3, #0
 8015bc8:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015bcc:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015bd0:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015bd4:	4313      	orrs	r3, r2
 8015bd6:	b2db      	uxtb	r3, r3
 8015bd8:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_LATENCY, &value, 1) )
 8015bdc:	f10d 030f 	add.w	r3, sp, #15
 8015be0:	9801      	ldr	r0, [sp, #4]
 8015be2:	213c      	movs	r1, #60	; 0x3c
 8015be4:	461a      	mov	r2, r3
 8015be6:	2301      	movs	r3, #1
 8015be8:	f7fc f8d2 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015bec:	4603      	mov	r3, r0
 8015bee:	2b00      	cmp	r3, #0
 8015bf0:	d101      	bne.n	8015bf6 <LSM303AGR_ACC_W_ClickTimeLatency+0x56>
    return MEMS_ERROR;
 8015bf2:	2300      	movs	r3, #0
 8015bf4:	e000      	b.n	8015bf8 <LSM303AGR_ACC_W_ClickTimeLatency+0x58>

  return MEMS_SUCCESS;
 8015bf6:	2301      	movs	r3, #1
}
 8015bf8:	4618      	mov	r0, r3
 8015bfa:	b005      	add	sp, #20
 8015bfc:	f85d fb04 	ldr.w	pc, [sp], #4

08015c00 <LSM303AGR_ACC_R_ClickTimeLatency>:
* Input          : Pointer to u8_t
* Output         : Status of TLA
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeLatency(void *handle, u8_t *value)
{
 8015c00:	b500      	push	{lr}
 8015c02:	b083      	sub	sp, #12
 8015c04:	9001      	str	r0, [sp, #4]
 8015c06:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_LATENCY, (u8_t *)value, 1) )
 8015c08:	9801      	ldr	r0, [sp, #4]
 8015c0a:	213c      	movs	r1, #60	; 0x3c
 8015c0c:	9a00      	ldr	r2, [sp, #0]
 8015c0e:	2301      	movs	r3, #1
 8015c10:	f7fc f8e6 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015c14:	4603      	mov	r3, r0
 8015c16:	2b00      	cmp	r3, #0
 8015c18:	d101      	bne.n	8015c1e <LSM303AGR_ACC_R_ClickTimeLatency+0x1e>
    return MEMS_ERROR;
 8015c1a:	2300      	movs	r3, #0
 8015c1c:	e008      	b.n	8015c30 <LSM303AGR_ACC_R_ClickTimeLatency+0x30>

  *value &= LSM303AGR_ACC_TLA_MASK; //coerce
 8015c1e:	9b00      	ldr	r3, [sp, #0]
 8015c20:	781a      	ldrb	r2, [r3, #0]
 8015c22:	9b00      	ldr	r3, [sp, #0]
 8015c24:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TLA_POSITION; //mask
 8015c26:	9b00      	ldr	r3, [sp, #0]
 8015c28:	781a      	ldrb	r2, [r3, #0]
 8015c2a:	9b00      	ldr	r3, [sp, #0]
 8015c2c:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015c2e:	2301      	movs	r3, #1
}
 8015c30:	4618      	mov	r0, r3
 8015c32:	b003      	add	sp, #12
 8015c34:	f85d fb04 	ldr.w	pc, [sp], #4
 8015c38:	f3af 8000 	nop.w
 8015c3c:	f3af 8000 	nop.w

08015c40 <LSM303AGR_ACC_W_ClickTimeWindow>:
* Input          : u8_t
* Output         : None
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t  LSM303AGR_ACC_W_ClickTimeWindow(void *handle, u8_t newValue)
{
 8015c40:	b500      	push	{lr}
 8015c42:	b085      	sub	sp, #20
 8015c44:	9001      	str	r0, [sp, #4]
 8015c46:	460b      	mov	r3, r1
 8015c48:	f88d 3003 	strb.w	r3, [sp, #3]
  u8_t value;

  newValue = newValue << LSM303AGR_ACC_TW_POSITION; //mask
  newValue &= LSM303AGR_ACC_TW_MASK; //coerce

  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 8015c4c:	f10d 030f 	add.w	r3, sp, #15
 8015c50:	9801      	ldr	r0, [sp, #4]
 8015c52:	213d      	movs	r1, #61	; 0x3d
 8015c54:	461a      	mov	r2, r3
 8015c56:	2301      	movs	r3, #1
 8015c58:	f7fc f8c2 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015c5c:	4603      	mov	r3, r0
 8015c5e:	2b00      	cmp	r3, #0
 8015c60:	d101      	bne.n	8015c66 <LSM303AGR_ACC_W_ClickTimeWindow+0x26>
    return MEMS_ERROR;
 8015c62:	2300      	movs	r3, #0
 8015c64:	e018      	b.n	8015c98 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  value &= (u8_t)~LSM303AGR_ACC_TW_MASK;
 8015c66:	2300      	movs	r3, #0
 8015c68:	f88d 300f 	strb.w	r3, [sp, #15]
  value |= newValue;
 8015c6c:	f89d 200f 	ldrb.w	r2, [sp, #15]
 8015c70:	f89d 3003 	ldrb.w	r3, [sp, #3]
 8015c74:	4313      	orrs	r3, r2
 8015c76:	b2db      	uxtb	r3, r3
 8015c78:	f88d 300f 	strb.w	r3, [sp, #15]

  if( !LSM303AGR_ACC_WriteReg( handle, LSM303AGR_ACC_TIME_WINDOW, &value, 1) )
 8015c7c:	f10d 030f 	add.w	r3, sp, #15
 8015c80:	9801      	ldr	r0, [sp, #4]
 8015c82:	213d      	movs	r1, #61	; 0x3d
 8015c84:	461a      	mov	r2, r3
 8015c86:	2301      	movs	r3, #1
 8015c88:	f7fc f882 	bl	8011d90 <LSM303AGR_ACC_WriteReg>
 8015c8c:	4603      	mov	r3, r0
 8015c8e:	2b00      	cmp	r3, #0
 8015c90:	d101      	bne.n	8015c96 <LSM303AGR_ACC_W_ClickTimeWindow+0x56>
    return MEMS_ERROR;
 8015c92:	2300      	movs	r3, #0
 8015c94:	e000      	b.n	8015c98 <LSM303AGR_ACC_W_ClickTimeWindow+0x58>

  return MEMS_SUCCESS;
 8015c96:	2301      	movs	r3, #1
}
 8015c98:	4618      	mov	r0, r3
 8015c9a:	b005      	add	sp, #20
 8015c9c:	f85d fb04 	ldr.w	pc, [sp], #4

08015ca0 <LSM303AGR_ACC_R_ClickTimeWindow>:
* Input          : Pointer to u8_t
* Output         : Status of TW
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_R_ClickTimeWindow(void *handle, u8_t *value)
{
 8015ca0:	b500      	push	{lr}
 8015ca2:	b083      	sub	sp, #12
 8015ca4:	9001      	str	r0, [sp, #4]
 8015ca6:	9100      	str	r1, [sp, #0]
  if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_TIME_WINDOW, (u8_t *)value, 1) )
 8015ca8:	9801      	ldr	r0, [sp, #4]
 8015caa:	213d      	movs	r1, #61	; 0x3d
 8015cac:	9a00      	ldr	r2, [sp, #0]
 8015cae:	2301      	movs	r3, #1
 8015cb0:	f7fc f896 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015cb4:	4603      	mov	r3, r0
 8015cb6:	2b00      	cmp	r3, #0
 8015cb8:	d101      	bne.n	8015cbe <LSM303AGR_ACC_R_ClickTimeWindow+0x1e>
    return MEMS_ERROR;
 8015cba:	2300      	movs	r3, #0
 8015cbc:	e008      	b.n	8015cd0 <LSM303AGR_ACC_R_ClickTimeWindow+0x30>

  *value &= LSM303AGR_ACC_TW_MASK; //coerce
 8015cbe:	9b00      	ldr	r3, [sp, #0]
 8015cc0:	781a      	ldrb	r2, [r3, #0]
 8015cc2:	9b00      	ldr	r3, [sp, #0]
 8015cc4:	701a      	strb	r2, [r3, #0]
  *value = *value >> LSM303AGR_ACC_TW_POSITION; //mask
 8015cc6:	9b00      	ldr	r3, [sp, #0]
 8015cc8:	781a      	ldrb	r2, [r3, #0]
 8015cca:	9b00      	ldr	r3, [sp, #0]
 8015ccc:	701a      	strb	r2, [r3, #0]

  return MEMS_SUCCESS;
 8015cce:	2301      	movs	r3, #1
}
 8015cd0:	4618      	mov	r0, r3
 8015cd2:	b003      	add	sp, #12
 8015cd4:	f85d fb04 	ldr.w	pc, [sp], #4
 8015cd8:	f3af 8000 	nop.w
 8015cdc:	f3af 8000 	nop.w

08015ce0 <LSM303AGR_ACC_Get_Voltage_ADC>:
* Input          : pointer to [u8_t]
* Output         : Voltage_ADC buffer u8_t
* Return         : Status [MEMS_ERROR, MEMS_SUCCESS]
*******************************************************************************/
status_t LSM303AGR_ACC_Get_Voltage_ADC(void *handle, u8_t *buff)
{
 8015ce0:	b500      	push	{lr}
 8015ce2:	b085      	sub	sp, #20
 8015ce4:	9001      	str	r0, [sp, #4]
 8015ce6:	9100      	str	r1, [sp, #0]
  u8_t i, j, k;
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;
 8015ce8:	2302      	movs	r3, #2
 8015cea:	f88d 300c 	strb.w	r3, [sp, #12]

  k = 0;
 8015cee:	2300      	movs	r3, #0
 8015cf0:	f88d 300d 	strb.w	r3, [sp, #13]
  for (i = 0; i < 3; i++ )
 8015cf4:	2300      	movs	r3, #0
 8015cf6:	f88d 300f 	strb.w	r3, [sp, #15]
 8015cfa:	e02b      	b.n	8015d54 <LSM303AGR_ACC_Get_Voltage_ADC+0x74>
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8015cfc:	2300      	movs	r3, #0
 8015cfe:	f88d 300e 	strb.w	r3, [sp, #14]
 8015d02:	e01c      	b.n	8015d3e <LSM303AGR_ACC_Get_Voltage_ADC+0x5e>
    {
      if( !LSM303AGR_ACC_ReadReg( handle, LSM303AGR_ACC_OUT_ADC1_L + k, &buff[k], 1 ))
 8015d04:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8015d08:	3308      	adds	r3, #8
 8015d0a:	b2da      	uxtb	r2, r3
 8015d0c:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8015d10:	9900      	ldr	r1, [sp, #0]
 8015d12:	440b      	add	r3, r1
 8015d14:	9801      	ldr	r0, [sp, #4]
 8015d16:	4611      	mov	r1, r2
 8015d18:	461a      	mov	r2, r3
 8015d1a:	2301      	movs	r3, #1
 8015d1c:	f7fc f860 	bl	8011de0 <LSM303AGR_ACC_ReadReg>
 8015d20:	4603      	mov	r3, r0
 8015d22:	2b00      	cmp	r3, #0
 8015d24:	d101      	bne.n	8015d2a <LSM303AGR_ACC_Get_Voltage_ADC+0x4a>
        return MEMS_ERROR;
 8015d26:	2300      	movs	r3, #0
 8015d28:	e019      	b.n	8015d5e <LSM303AGR_ACC_Get_Voltage_ADC+0x7e>
      k++;
 8015d2a:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8015d2e:	3301      	adds	r3, #1
 8015d30:	f88d 300d 	strb.w	r3, [sp, #13]
  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
  {
    for (j = 0; j < numberOfByteForDimension; j++ )
 8015d34:	f89d 300e 	ldrb.w	r3, [sp, #14]
 8015d38:	3301      	adds	r3, #1
 8015d3a:	f88d 300e 	strb.w	r3, [sp, #14]
 8015d3e:	f89d 200e 	ldrb.w	r2, [sp, #14]
 8015d42:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8015d46:	429a      	cmp	r2, r3
 8015d48:	d3dc      	bcc.n	8015d04 <LSM303AGR_ACC_Get_Voltage_ADC+0x24>
  u8_t numberOfByteForDimension;

  numberOfByteForDimension = 6 / 3;

  k = 0;
  for (i = 0; i < 3; i++ )
 8015d4a:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015d4e:	3301      	adds	r3, #1
 8015d50:	f88d 300f 	strb.w	r3, [sp, #15]
 8015d54:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8015d58:	2b02      	cmp	r3, #2
 8015d5a:	d9cf      	bls.n	8015cfc <LSM303AGR_ACC_Get_Voltage_ADC+0x1c>
        return MEMS_ERROR;
      k++;
    }
  }

  return MEMS_SUCCESS;
 8015d5c:	2301      	movs	r3, #1
}
 8015d5e:	4618      	mov	r0, r3
 8015d60:	b005      	add	sp, #20
 8015d62:	f85d fb04 	ldr.w	pc, [sp], #4
 8015d66:	bf00      	nop
 8015d68:	f3af 8000 	nop.w
 8015d6c:	f3af 8000 	nop.w

08015d70 <Sensor_IO_SPI_Write>:
#define SPI_1LINE_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 |= SPI_CR1_SPE)
#define SPI_1LINE_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR1 &= (~SPI_CR1_SPE))
#define SPI_DMA_DISABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 &= (~(SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN)))
#define SPI_DMA_ENABLE(__HANDLE__) ((__HANDLE__)->spi->CR2 |= (SPI_CR2_RXDMAEN|SPI_CR2_TXDMAEN))

uint8_t Sensor_IO_SPI_Write(SPIDriver *bus, SPIConfig *cfg, uint8_t WriteAddr, uint8_t *pBuffer, uint16_t nBytesToWrite ) {
 8015d70:	b500      	push	{lr}
 8015d72:	b087      	sub	sp, #28
 8015d74:	9003      	str	r0, [sp, #12]
 8015d76:	9102      	str	r1, [sp, #8]
 8015d78:	9300      	str	r3, [sp, #0]
 8015d7a:	4613      	mov	r3, r2
 8015d7c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;

  if (nBytesToWrite > 1) {                /* Set bit 6 of the address if multiple bytes will be sent. */
 8015d80:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8015d84:	2b01      	cmp	r3, #1
 8015d86:	d905      	bls.n	8015d94 <Sensor_IO_SPI_Write+0x24>
    WriteAddr |= 0x40;
 8015d88:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015d8c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015d90:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  WriteAddr = WriteAddr & (~0x80);        /* Clear the write bit (bit 7)      */
 8015d94:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015d98:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8015d9c:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 8015da0:	9803      	ldr	r0, [sp, #12]
 8015da2:	f7f0 fc95 	bl	80066d0 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 8015da6:	9803      	ldr	r0, [sp, #12]
 8015da8:	9902      	ldr	r1, [sp, #8]
 8015daa:	f7f0 fb71 	bl	8006490 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 8015dae:	9b03      	ldr	r3, [sp, #12]
 8015db0:	69db      	ldr	r3, [r3, #28]
 8015db2:	9a03      	ldr	r2, [sp, #12]
 8015db4:	69d2      	ldr	r2, [r2, #28]
 8015db6:	6852      	ldr	r2, [r2, #4]
 8015db8:	f022 0203 	bic.w	r2, r2, #3
 8015dbc:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 8015dbe:	9b03      	ldr	r3, [sp, #12]
 8015dc0:	69db      	ldr	r3, [r3, #28]
 8015dc2:	9a03      	ldr	r2, [sp, #12]
 8015dc4:	69d2      	ldr	r2, [r2, #28]
 8015dc6:	6812      	ldr	r2, [r2, #0]
 8015dc8:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8015dcc:	601a      	str	r2, [r3, #0]
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
 8015dce:	9b03      	ldr	r3, [sp, #12]
 8015dd0:	69db      	ldr	r3, [r3, #28]
 8015dd2:	9a03      	ldr	r2, [sp, #12]
 8015dd4:	69d2      	ldr	r2, [r2, #28]
 8015dd6:	6812      	ldr	r2, [r2, #0]
 8015dd8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8015ddc:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 8015dde:	9803      	ldr	r0, [sp, #12]
 8015de0:	f7f0 fb7e 	bl	80064e0 <spiSelect>
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
 8015de4:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015de8:	9803      	ldr	r0, [sp, #12]
 8015dea:	4619      	mov	r1, r3
 8015dec:	f7f5 fc28 	bl	800b640 <spi_lld_polled_tx>
  for(i=0;i<nBytesToWrite;i++) {
 8015df0:	2300      	movs	r3, #0
 8015df2:	9305      	str	r3, [sp, #20]
 8015df4:	e00a      	b.n	8015e0c <Sensor_IO_SPI_Write+0x9c>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
 8015df6:	9b00      	ldr	r3, [sp, #0]
 8015df8:	1c5a      	adds	r2, r3, #1
 8015dfa:	9200      	str	r2, [sp, #0]
 8015dfc:	781b      	ldrb	r3, [r3, #0]
 8015dfe:	9803      	ldr	r0, [sp, #12]
 8015e00:	4619      	mov	r1, r3
 8015e02:	f7f5 fc1d 	bl	800b640 <spi_lld_polled_tx>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
  SPI_1LINE_ENABLE(bus);
  SPI_1LINE_TX(bus);                      /* Make sure that the MOSI pin is output */
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, WriteAddr);            /* Send the address byte            */
  for(i=0;i<nBytesToWrite;i++) {
 8015e06:	9b05      	ldr	r3, [sp, #20]
 8015e08:	3301      	adds	r3, #1
 8015e0a:	9305      	str	r3, [sp, #20]
 8015e0c:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8015e10:	9b05      	ldr	r3, [sp, #20]
 8015e12:	429a      	cmp	r2, r3
 8015e14:	dcef      	bgt.n	8015df6 <Sensor_IO_SPI_Write+0x86>
    spiPolledTx(bus, *pBuffer++);         /* Send the address byte            */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 8015e16:	9803      	ldr	r0, [sp, #12]
 8015e18:	f7f0 fb72 	bl	8006500 <spiUnselect>
  spiReleaseBus(bus);                     /* Ownership release.               */
 8015e1c:	9803      	ldr	r0, [sp, #12]
 8015e1e:	f7f0 fc67 	bl	80066f0 <spiReleaseBus>
  return 0;
 8015e22:	2300      	movs	r3, #0
}
 8015e24:	4618      	mov	r0, r3
 8015e26:	b007      	add	sp, #28
 8015e28:	f85d fb04 	ldr.w	pc, [sp], #4
 8015e2c:	f3af 8000 	nop.w

08015e30 <Sensor_IO_SPI_Read>:

uint8_t Sensor_IO_SPI_Read(SPIDriver *bus, SPIConfig *cfg, uint8_t ReadAddr, uint8_t *pBuffer, uint16_t nBytesToRead ) {
 8015e30:	b510      	push	{r4, lr}
 8015e32:	b086      	sub	sp, #24
 8015e34:	9003      	str	r0, [sp, #12]
 8015e36:	9102      	str	r1, [sp, #8]
 8015e38:	9300      	str	r3, [sp, #0]
 8015e3a:	4613      	mov	r3, r2
 8015e3c:	f88d 3007 	strb.w	r3, [sp, #7]
  int i;
  if (nBytesToRead > 1) {                  /* Set bit 6 of the address if multiple bytes will be sent. */
 8015e40:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8015e44:	2b01      	cmp	r3, #1
 8015e46:	d905      	bls.n	8015e54 <Sensor_IO_SPI_Read+0x24>
    ReadAddr |= 0x40;
 8015e48:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015e4c:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8015e50:	f88d 3007 	strb.w	r3, [sp, #7]
  }
  ReadAddr = ReadAddr | 0x80;             /* Set the read bit (bit 7)         */
 8015e54:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015e58:	f063 037f 	orn	r3, r3, #127	; 0x7f
 8015e5c:	f88d 3007 	strb.w	r3, [sp, #7]
  spiAcquireBus(bus);                     /* Acquire ownership of the bus.    */
 8015e60:	9803      	ldr	r0, [sp, #12]
 8015e62:	f7f0 fc35 	bl	80066d0 <spiAcquireBus>
  spiStart(bus, cfg);                     /* Setup transfer parameters.       */
 8015e66:	9803      	ldr	r0, [sp, #12]
 8015e68:	9902      	ldr	r1, [sp, #8]
 8015e6a:	f7f0 fb11 	bl	8006490 <spiStart>
  SPI_DMA_DISABLE(bus);                   /* Turn off the DMA interrupt since this bus is polled */
 8015e6e:	9b03      	ldr	r3, [sp, #12]
 8015e70:	69db      	ldr	r3, [r3, #28]
 8015e72:	9a03      	ldr	r2, [sp, #12]
 8015e74:	69d2      	ldr	r2, [r2, #28]
 8015e76:	6852      	ldr	r2, [r2, #4]
 8015e78:	f022 0203 	bic.w	r2, r2, #3
 8015e7c:	605a      	str	r2, [r3, #4]
  SPI_1LINE_ENABLE(bus);
 8015e7e:	9b03      	ldr	r3, [sp, #12]
 8015e80:	69db      	ldr	r3, [r3, #28]
 8015e82:	9a03      	ldr	r2, [sp, #12]
 8015e84:	69d2      	ldr	r2, [r2, #28]
 8015e86:	6812      	ldr	r2, [r2, #0]
 8015e88:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8015e8c:	601a      	str	r2, [r3, #0]
  spiSelect(bus);                         /* Slave Select assertion.          */
 8015e8e:	9803      	ldr	r0, [sp, #12]
 8015e90:	f7f0 fb26 	bl	80064e0 <spiSelect>
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
 8015e94:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8015e98:	9803      	ldr	r0, [sp, #12]
 8015e9a:	4619      	mov	r1, r3
 8015e9c:	f7f5 fbd0 	bl	800b640 <spi_lld_polled_tx>
  SPI_1LINE_DISABLE(bus);
 8015ea0:	9b03      	ldr	r3, [sp, #12]
 8015ea2:	69db      	ldr	r3, [r3, #28]
 8015ea4:	9a03      	ldr	r2, [sp, #12]
 8015ea6:	69d2      	ldr	r2, [r2, #28]
 8015ea8:	6812      	ldr	r2, [r2, #0]
 8015eaa:	f022 0240 	bic.w	r2, r2, #64	; 0x40
 8015eae:	601a      	str	r2, [r3, #0]
  SPI_1LINE_RX(bus);
 8015eb0:	9b03      	ldr	r3, [sp, #12]
 8015eb2:	69db      	ldr	r3, [r3, #28]
 8015eb4:	9a03      	ldr	r2, [sp, #12]
 8015eb6:	69d2      	ldr	r2, [r2, #28]
 8015eb8:	6812      	ldr	r2, [r2, #0]
 8015eba:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8015ebe:	601a      	str	r2, [r3, #0]
  for(i=0;i<nBytesToRead;i++) {
 8015ec0:	2300      	movs	r3, #0
 8015ec2:	9305      	str	r3, [sp, #20]
 8015ec4:	e00b      	b.n	8015ede <Sensor_IO_SPI_Read+0xae>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
 8015ec6:	9c00      	ldr	r4, [sp, #0]
 8015ec8:	1c63      	adds	r3, r4, #1
 8015eca:	9300      	str	r3, [sp, #0]
 8015ecc:	9803      	ldr	r0, [sp, #12]
 8015ece:	f7f5 fbe7 	bl	800b6a0 <spi_lld_polled_rx>
 8015ed2:	4603      	mov	r3, r0
 8015ed4:	b2db      	uxtb	r3, r3
 8015ed6:	7023      	strb	r3, [r4, #0]
  SPI_1LINE_ENABLE(bus);
  spiSelect(bus);                         /* Slave Select assertion.          */
  spiPolledTx(bus, ReadAddr);             /* Send the address byte            */
  SPI_1LINE_DISABLE(bus);
  SPI_1LINE_RX(bus);
  for(i=0;i<nBytesToRead;i++) {
 8015ed8:	9b05      	ldr	r3, [sp, #20]
 8015eda:	3301      	adds	r3, #1
 8015edc:	9305      	str	r3, [sp, #20]
 8015ede:	f8bd 2020 	ldrh.w	r2, [sp, #32]
 8015ee2:	9b05      	ldr	r3, [sp, #20]
 8015ee4:	429a      	cmp	r2, r3
 8015ee6:	dcee      	bgt.n	8015ec6 <Sensor_IO_SPI_Read+0x96>
    *pBuffer++ = spiPolledRx(bus);     /* Receive data from the wire       */
  }
  spiUnselect(bus);                       /* Slave Select de-assertion.       */
 8015ee8:	9803      	ldr	r0, [sp, #12]
 8015eea:	f7f0 fb09 	bl	8006500 <spiUnselect>
  SPI_1LINE_TX(bus);
 8015eee:	9b03      	ldr	r3, [sp, #12]
 8015ef0:	69db      	ldr	r3, [r3, #28]
 8015ef2:	9a03      	ldr	r2, [sp, #12]
 8015ef4:	69d2      	ldr	r2, [r2, #28]
 8015ef6:	6812      	ldr	r2, [r2, #0]
 8015ef8:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8015efc:	601a      	str	r2, [r3, #0]
  spiReleaseBus(bus);                     /* Ownership release.               */
 8015efe:	9803      	ldr	r0, [sp, #12]
 8015f00:	f7f0 fbf6 	bl	80066f0 <spiReleaseBus>
  return 0;
 8015f04:	2300      	movs	r3, #0
}
 8015f06:	4618      	mov	r0, r3
 8015f08:	b006      	add	sp, #24
 8015f0a:	bd10      	pop	{r4, pc}
 8015f0c:	f3af 8000 	nop.w

08015f10 <chThdTerminatedX>:
 * @retval true         thread terminated.
 * @retval false        thread not terminated.
 *
 * @xclass
 */
static inline bool chThdTerminatedX(thread_t *tp) {
 8015f10:	b082      	sub	sp, #8
 8015f12:	9001      	str	r0, [sp, #4]

  return (bool)(tp->p_state == CH_STATE_FINAL);
 8015f14:	9b01      	ldr	r3, [sp, #4]
 8015f16:	7f1b      	ldrb	r3, [r3, #28]
 8015f18:	2b0f      	cmp	r3, #15
 8015f1a:	bf14      	ite	ne
 8015f1c:	2300      	movne	r3, #0
 8015f1e:	2301      	moveq	r3, #1
 8015f20:	b2db      	uxtb	r3, r3
}
 8015f22:	4618      	mov	r0, r3
 8015f24:	b002      	add	sp, #8
 8015f26:	4770      	bx	lr
 8015f28:	f3af 8000 	nop.w
 8015f2c:	f3af 8000 	nop.w

08015f30 <chRegSetThreadName>:
 *
 * @param[in] name      thread name as a zero terminated string
 *
 * @api
 */
static inline void chRegSetThreadName(const char *name) {
 8015f30:	b082      	sub	sp, #8
 8015f32:	9001      	str	r0, [sp, #4]

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8015f34:	4b02      	ldr	r3, [pc, #8]	; (8015f40 <chRegSetThreadName+0x10>)
 8015f36:	699b      	ldr	r3, [r3, #24]
 8015f38:	9a01      	ldr	r2, [sp, #4]
 8015f3a:	619a      	str	r2, [r3, #24]
#else
  (void)name;
#endif
}
 8015f3c:	b002      	add	sp, #8
 8015f3e:	4770      	bx	lr
 8015f40:	20001bc8 	.word	0x20001bc8
 8015f44:	f3af 8000 	nop.w
 8015f48:	f3af 8000 	nop.w
 8015f4c:	f3af 8000 	nop.w

08015f50 <counterThread>:
void saveTimeStamp(RTCDateTime timespec);
void slowSensor(void);

/* Thread that blinks North LED as an "alive" indicator */
static THD_WORKING_AREA(waCounterThread,128);
static THD_FUNCTION(counterThread,arg) {
 8015f50:	b500      	push	{lr}
 8015f52:	b083      	sub	sp, #12
 8015f54:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("blinker");
 8015f56:	480a      	ldr	r0, [pc, #40]	; (8015f80 <counterThread+0x30>)
 8015f58:	f7ff ffea 	bl	8015f30 <chRegSetThreadName>
  while (TRUE) {
    palSetLine(BOARD_LED);   
 8015f5c:	4b09      	ldr	r3, [pc, #36]	; (8015f84 <counterThread+0x34>)
 8015f5e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8015f62:	831a      	strh	r2, [r3, #24]
    chThdSleepMilliseconds(500);
 8015f64:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8015f68:	f7eb f9b2 	bl	80012d0 <chThdSleep>
    palClearLine(BOARD_LED);   
 8015f6c:	4b05      	ldr	r3, [pc, #20]	; (8015f84 <counterThread+0x34>)
 8015f6e:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8015f72:	835a      	strh	r2, [r3, #26]
    chThdSleepMilliseconds(500);
 8015f74:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8015f78:	f7eb f9aa 	bl	80012d0 <chThdSleep>
  }
 8015f7c:	e7ee      	b.n	8015f5c <counterThread+0xc>
 8015f7e:	bf00      	nop
 8015f80:	0801a670 	.word	0x0801a670
 8015f84:	48001800 	.word	0x48001800
 8015f88:	f3af 8000 	nop.w
 8015f8c:	f3af 8000 	nop.w

08015f90 <accelTestThread>:
}

static THD_WORKING_AREA(waAccelTestThread,128);
static THD_FUNCTION(accelTestThread,arg) {
 8015f90:	b500      	push	{lr}
 8015f92:	b089      	sub	sp, #36	; 0x24
 8015f94:	9003      	str	r0, [sp, #12]
  UNUSED(arg);
  int accel[3];
  chRegSetThreadName("test");
 8015f96:	480a      	ldr	r0, [pc, #40]	; (8015fc0 <accelTestThread+0x30>)
 8015f98:	f7ff ffca 	bl	8015f30 <chRegSetThreadName>
  while(TRUE) {
    // Test Accel
    LSM303AGR_ACC_Get_Acceleration(NULL,accel);
 8015f9c:	ab05      	add	r3, sp, #20
 8015f9e:	2000      	movs	r0, #0
 8015fa0:	4619      	mov	r1, r3
 8015fa2:	f7fc f825 	bl	8011ff0 <LSM303AGR_ACC_Get_Acceleration>
    chprintf((BaseSequentialStream*)&SD5,"Accel: %4d,%4d,%4d \n\r",accel[0],accel[1],accel[2]);
 8015fa6:	9a05      	ldr	r2, [sp, #20]
 8015fa8:	9b06      	ldr	r3, [sp, #24]
 8015faa:	9907      	ldr	r1, [sp, #28]
 8015fac:	9100      	str	r1, [sp, #0]
 8015fae:	4805      	ldr	r0, [pc, #20]	; (8015fc4 <accelTestThread+0x34>)
 8015fb0:	4905      	ldr	r1, [pc, #20]	; (8015fc8 <accelTestThread+0x38>)
 8015fb2:	f7fb fb1d 	bl	80115f0 <chprintf>
    chThdSleepMilliseconds(500);
 8015fb6:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8015fba:	f7eb f989 	bl	80012d0 <chThdSleep>
  }
 8015fbe:	e7ed      	b.n	8015f9c <accelTestThread+0xc>
 8015fc0:	0801a678 	.word	0x0801a678
 8015fc4:	20001fd8 	.word	0x20001fd8
 8015fc8:	0801a680 	.word	0x0801a680
 8015fcc:	f3af 8000 	nop.w

08015fd0 <timerThread>:
}

static THD_WORKING_AREA(waTimerThread,128);
static THD_FUNCTION(timerThread,arg) {
 8015fd0:	b500      	push	{lr}
 8015fd2:	b085      	sub	sp, #20
 8015fd4:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("timer");
 8015fd6:	4816      	ldr	r0, [pc, #88]	; (8016030 <timerThread+0x60>)
 8015fd8:	f7ff ffaa 	bl	8015f30 <chRegSetThreadName>
  while(TRUE) {
    /* SLEEP for 1 minute */
    chThdSleepMilliseconds(1000*10);
 8015fdc:	f242 7010 	movw	r0, #10000	; 0x2710
 8015fe0:	f7eb f976 	bl	80012d0 <chThdSleep>
    /* SAVE Data if steps have been detected */
    if (current_steps != 0) {
 8015fe4:	4b13      	ldr	r3, [pc, #76]	; (8016034 <timerThread+0x64>)
 8015fe6:	681b      	ldr	r3, [r3, #0]
 8015fe8:	2b00      	cmp	r3, #0
 8015fea:	d01f      	beq.n	801602c <timerThread+0x5c>
      /* SAVE timestamp and current steps */
      saveTimeStamp(getTimeStamp());
 8015fec:	ab02      	add	r3, sp, #8
 8015fee:	4618      	mov	r0, r3
 8015ff0:	f000 f956 	bl	80162a0 <getTimeStamp>
 8015ff4:	ab02      	add	r3, sp, #8
 8015ff6:	e893 0003 	ldmia.w	r3, {r0, r1}
 8015ffa:	f000 f969 	bl	80162d0 <saveTimeStamp>
      step_data[total_logs] = current_steps;
 8015ffe:	4b0e      	ldr	r3, [pc, #56]	; (8016038 <timerThread+0x68>)
 8016000:	681a      	ldr	r2, [r3, #0]
 8016002:	4b0c      	ldr	r3, [pc, #48]	; (8016034 <timerThread+0x64>)
 8016004:	6819      	ldr	r1, [r3, #0]
 8016006:	4b0d      	ldr	r3, [pc, #52]	; (801603c <timerThread+0x6c>)
 8016008:	f843 1022 	str.w	r1, [r3, r2, lsl #2]
      /* INCREMENT total logs which is the index of the data arrays */
      total_logs += 1;
 801600c:	4b0a      	ldr	r3, [pc, #40]	; (8016038 <timerThread+0x68>)
 801600e:	681b      	ldr	r3, [r3, #0]
 8016010:	1c5a      	adds	r2, r3, #1
 8016012:	4b09      	ldr	r3, [pc, #36]	; (8016038 <timerThread+0x68>)
 8016014:	601a      	str	r2, [r3, #0]
      /* ADD current steps to the total steps */
      total_steps += current_steps;
 8016016:	4b0a      	ldr	r3, [pc, #40]	; (8016040 <timerThread+0x70>)
 8016018:	681a      	ldr	r2, [r3, #0]
 801601a:	4b06      	ldr	r3, [pc, #24]	; (8016034 <timerThread+0x64>)
 801601c:	681b      	ldr	r3, [r3, #0]
 801601e:	441a      	add	r2, r3
 8016020:	4b07      	ldr	r3, [pc, #28]	; (8016040 <timerThread+0x70>)
 8016022:	601a      	str	r2, [r3, #0]
      /* RESET current steps */
      current_steps = 0;
 8016024:	4b03      	ldr	r3, [pc, #12]	; (8016034 <timerThread+0x64>)
 8016026:	2200      	movs	r2, #0
 8016028:	601a      	str	r2, [r3, #0]
    }
  }
 801602a:	e7d7      	b.n	8015fdc <timerThread+0xc>
 801602c:	e7d6      	b.n	8015fdc <timerThread+0xc>
 801602e:	bf00      	nop
 8016030:	0801a698 	.word	0x0801a698
 8016034:	200014d0 	.word	0x200014d0
 8016038:	200014d8 	.word	0x200014d8
 801603c:	200026dc 	.word	0x200026dc
 8016040:	200014d4 	.word	0x200014d4
 8016044:	f3af 8000 	nop.w
 8016048:	f3af 8000 	nop.w
 801604c:	f3af 8000 	nop.w

08016050 <stepCounterThread>:
}

static THD_WORKING_AREA(waStepCounterThread,512);
static THD_FUNCTION(stepCounterThread,arg) {
 8016050:	b500      	push	{lr}
 8016052:	b083      	sub	sp, #12
 8016054:	9001      	str	r0, [sp, #4]
  UNUSED(arg);
  chRegSetThreadName("stepCounter");
 8016056:	480a      	ldr	r0, [pc, #40]	; (8016080 <stepCounterThread+0x30>)
 8016058:	f7ff ff6a 	bl	8015f30 <chRegSetThreadName>
  while(TRUE) {
    /* CHECK if Above Threshold! */
    if (accelAboveThreshold()) {
 801605c:	f000 f858 	bl	8016110 <accelAboveThreshold>
 8016060:	4603      	mov	r3, r0
 8016062:	2b00      	cmp	r3, #0
 8016064:	d008      	beq.n	8016078 <stepCounterThread+0x28>
      current_steps += 1;
 8016066:	4b07      	ldr	r3, [pc, #28]	; (8016084 <stepCounterThread+0x34>)
 8016068:	681b      	ldr	r3, [r3, #0]
 801606a:	1c5a      	adds	r2, r3, #1
 801606c:	4b05      	ldr	r3, [pc, #20]	; (8016084 <stepCounterThread+0x34>)
 801606e:	601a      	str	r2, [r3, #0]
      chThdSleepMilliseconds(3000);
 8016070:	f640 30b8 	movw	r0, #3000	; 0xbb8
 8016074:	f7eb f92c 	bl	80012d0 <chThdSleep>
    }
    chThdSleepMilliseconds(100);
 8016078:	2064      	movs	r0, #100	; 0x64
 801607a:	f7eb f929 	bl	80012d0 <chThdSleep>
  }
 801607e:	e7ed      	b.n	801605c <stepCounterThread+0xc>
 8016080:	0801a6a0 	.word	0x0801a6a0
 8016084:	200014d0 	.word	0x200014d0
 8016088:	f3af 8000 	nop.w
 801608c:	f3af 8000 	nop.w

08016090 <cmd_display_count>:
}

/* Display Count functionality */
static void cmd_display_count(BaseSequentialStream *chp, int argc, char *argv[]) {
 8016090:	b500      	push	{lr}
 8016092:	b099      	sub	sp, #100	; 0x64
 8016094:	9003      	str	r0, [sp, #12]
 8016096:	9102      	str	r1, [sp, #8]
 8016098:	9201      	str	r2, [sp, #4]
  UNUSED(argv);
  UNUSED(argc);
  UNUSED(chp);
  int i = 0;
 801609a:	2300      	movs	r3, #0
 801609c:	9317      	str	r3, [sp, #92]	; 0x5c
  struct tm timp;
  uint32_t tv_msec;
  char buf[26];
  // Read & Print Accel Data
  for (i = 0; i < total_logs; i++) {
 801609e:	2300      	movs	r3, #0
 80160a0:	9317      	str	r3, [sp, #92]	; 0x5c
 80160a2:	e020      	b.n	80160e6 <cmd_display_count+0x56>
    rtcConvertDateTimeToStructTm(&time_data[i],&timp,&tv_msec);
 80160a4:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80160a6:	00da      	lsls	r2, r3, #3
 80160a8:	4b13      	ldr	r3, [pc, #76]	; (80160f8 <cmd_display_count+0x68>)
 80160aa:	18d1      	adds	r1, r2, r3
 80160ac:	aa0e      	add	r2, sp, #56	; 0x38
 80160ae:	ab0d      	add	r3, sp, #52	; 0x34
 80160b0:	4608      	mov	r0, r1
 80160b2:	4611      	mov	r1, r2
 80160b4:	461a      	mov	r2, r3
 80160b6:	f7ef f823 	bl	8005100 <rtcConvertDateTimeToStructTm>
    time_t aTime = mktime(&timp);
 80160ba:	ab0e      	add	r3, sp, #56	; 0x38
 80160bc:	4618      	mov	r0, r3
 80160be:	f000 ff87 	bl	8016fd0 <mktime>
 80160c2:	4603      	mov	r3, r0
 80160c4:	9305      	str	r3, [sp, #20]
    ctime_r(&aTime, buf);
 80160c6:	aa05      	add	r2, sp, #20
 80160c8:	ab06      	add	r3, sp, #24
 80160ca:	4610      	mov	r0, r2
 80160cc:	4619      	mov	r1, r3
 80160ce:	f000 fe07 	bl	8016ce0 <ctime_r>
    chprintf((BaseSequentialStream*)&SD5,"Count: %4d | %s \n\r",total_steps,buf);
 80160d2:	4b0a      	ldr	r3, [pc, #40]	; (80160fc <cmd_display_count+0x6c>)
 80160d4:	681a      	ldr	r2, [r3, #0]
 80160d6:	ab06      	add	r3, sp, #24
 80160d8:	4809      	ldr	r0, [pc, #36]	; (8016100 <cmd_display_count+0x70>)
 80160da:	490a      	ldr	r1, [pc, #40]	; (8016104 <cmd_display_count+0x74>)
 80160dc:	f7fb fa88 	bl	80115f0 <chprintf>
  int i = 0;
  struct tm timp;
  uint32_t tv_msec;
  char buf[26];
  // Read & Print Accel Data
  for (i = 0; i < total_logs; i++) {
 80160e0:	9b17      	ldr	r3, [sp, #92]	; 0x5c
 80160e2:	3301      	adds	r3, #1
 80160e4:	9317      	str	r3, [sp, #92]	; 0x5c
 80160e6:	4b08      	ldr	r3, [pc, #32]	; (8016108 <cmd_display_count+0x78>)
 80160e8:	681b      	ldr	r3, [r3, #0]
 80160ea:	9a17      	ldr	r2, [sp, #92]	; 0x5c
 80160ec:	429a      	cmp	r2, r3
 80160ee:	dbd9      	blt.n	80160a4 <cmd_display_count+0x14>
    rtcConvertDateTimeToStructTm(&time_data[i],&timp,&tv_msec);
    time_t aTime = mktime(&timp);
    ctime_r(&aTime, buf);
    chprintf((BaseSequentialStream*)&SD5,"Count: %4d | %s \n\r",total_steps,buf);
  }
}
 80160f0:	b019      	add	sp, #100	; 0x64
 80160f2:	f85d fb04 	ldr.w	pc, [sp], #4
 80160f6:	bf00      	nop
 80160f8:	2000367c 	.word	0x2000367c
 80160fc:	200014d4 	.word	0x200014d4
 8016100:	20001fd8 	.word	0x20001fd8
 8016104:	0801a6ac 	.word	0x0801a6ac
 8016108:	200014d8 	.word	0x200014d8
 801610c:	f3af 8000 	nop.w

08016110 <accelAboveThreshold>:

uint8_t accelAboveThreshold() {
 8016110:	b500      	push	{lr}
 8016112:	b085      	sub	sp, #20
  int accel[3];
  // Read Accel Data
  LSM303AGR_ACC_Get_Acceleration(NULL,accel);
 8016114:	ab01      	add	r3, sp, #4
 8016116:	2000      	movs	r0, #0
 8016118:	4619      	mov	r1, r3
 801611a:	f7fb ff69 	bl	8011ff0 <LSM303AGR_ACC_Get_Acceleration>
  if (accel[2] > threshold) {
 801611e:	9b03      	ldr	r3, [sp, #12]
 8016120:	f5b3 7f7a 	cmp.w	r3, #1000	; 0x3e8
 8016124:	dd01      	ble.n	801612a <accelAboveThreshold+0x1a>
    // Is above Threshold
    return TRUE;
 8016126:	2301      	movs	r3, #1
 8016128:	e000      	b.n	801612c <accelAboveThreshold+0x1c>
  } else {
    // Is below Threshold
    return FALSE;
 801612a:	2300      	movs	r3, #0
  }
}
 801612c:	4618      	mov	r0, r3
 801612e:	b005      	add	sp, #20
 8016130:	f85d fb04 	ldr.w	pc, [sp], #4
 8016134:	f3af 8000 	nop.w
 8016138:	f3af 8000 	nop.w
 801613c:	f3af 8000 	nop.w

08016140 <cmd_myecho>:

/* Given commands */
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
 8016140:	b500      	push	{lr}
 8016142:	b087      	sub	sp, #28
 8016144:	9003      	str	r0, [sp, #12]
 8016146:	9102      	str	r1, [sp, #8]
 8016148:	9201      	str	r2, [sp, #4]
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 801614a:	2300      	movs	r3, #0
 801614c:	9305      	str	r3, [sp, #20]
 801614e:	e00c      	b.n	801616a <cmd_myecho+0x2a>
    chprintf(chp, "%s\n\r", argv[i]);
 8016150:	9b05      	ldr	r3, [sp, #20]
 8016152:	009b      	lsls	r3, r3, #2
 8016154:	9a01      	ldr	r2, [sp, #4]
 8016156:	4413      	add	r3, r2
 8016158:	681b      	ldr	r3, [r3, #0]
 801615a:	9803      	ldr	r0, [sp, #12]
 801615c:	4906      	ldr	r1, [pc, #24]	; (8016178 <cmd_myecho+0x38>)
 801615e:	461a      	mov	r2, r3
 8016160:	f7fb fa46 	bl	80115f0 <chprintf>

/* Given commands */
static void cmd_myecho(BaseSequentialStream *chp, int argc, char *argv[]) {
  int32_t i;
  (void)argv;
  for (i=0;i<argc;i++) {
 8016164:	9b05      	ldr	r3, [sp, #20]
 8016166:	3301      	adds	r3, #1
 8016168:	9305      	str	r3, [sp, #20]
 801616a:	9a05      	ldr	r2, [sp, #20]
 801616c:	9b02      	ldr	r3, [sp, #8]
 801616e:	429a      	cmp	r2, r3
 8016170:	dbee      	blt.n	8016150 <cmd_myecho+0x10>
    chprintf(chp, "%s\n\r", argv[i]);
  }
}
 8016172:	b007      	add	sp, #28
 8016174:	f85d fb04 	ldr.w	pc, [sp], #4
 8016178:	0801a6c0 	.word	0x0801a6c0
 801617c:	f3af 8000 	nop.w

08016180 <main>:
  (BaseSequentialStream *)&SD5,
  commands
};

/* Application entry point. */
int main(void) {
 8016180:	b500      	push	{lr}
 8016182:	b083      	sub	sp, #12
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  static thread_t *shelltp = NULL;

  halInit();
 8016184:	f7ed fd24 	bl	8003bd0 <halInit>
  chSysInit();
 8016188:	f7ea fa8a 	bl	80006a0 <chSysInit>
  rtcInit();
 801618c:	f7ee ff68 	bl	8005060 <rtcInit>
  //setStartingRTCTime();
  
  LSM303AGR_ACC_Init();
 8016190:	f7fb fde6 	bl	8011d60 <LSM303AGR_ACC_Init>
  LSM303AGR_ACC_W_ODR(NULL, LSM303AGR_ACC_ODR_DO_1_25KHz);
 8016194:	2000      	movs	r0, #0
 8016196:	2190      	movs	r1, #144	; 0x90
 8016198:	f7fc f832 	bl	8012200 <LSM303AGR_ACC_W_ODR>

  /* Activates the serial driver 5 using the driver default configuration. */
  /* PC12(TX) and PD2(RX). The default baud rate is 38400. */
  sdStart(&SD5, NULL);
 801619c:	481f      	ldr	r0, [pc, #124]	; (801621c <main+0x9c>)
 801619e:	2100      	movs	r1, #0
 80161a0:	f7f0 f836 	bl	8006210 <sdStart>
  chprintf((BaseSequentialStream*)&SD5, "\n\rUp and Running\n\r");
 80161a4:	481d      	ldr	r0, [pc, #116]	; (801621c <main+0x9c>)
 80161a6:	491e      	ldr	r1, [pc, #120]	; (8016220 <main+0xa0>)
 80161a8:	f7fb fa22 	bl	80115f0 <chprintf>

  /* Initialize the command shell */ 
  shellInit();
 80161ac:	f7fb fca8 	bl	8011b00 <shellInit>
  //chThdCreateStatic(waCounterThread, sizeof(waCounterThread), NORMALPRIO+1, counterThread, NULL);
  /* Initialize the timer thread and stepCounter thread*/
  chThdCreateStatic(waTimerThread, sizeof(waTimerThread), NORMALPRIO+1, timerThread, NULL);
 80161b0:	2300      	movs	r3, #0
 80161b2:	9300      	str	r3, [sp, #0]
 80161b4:	481b      	ldr	r0, [pc, #108]	; (8016224 <main+0xa4>)
 80161b6:	f44f 71a4 	mov.w	r1, #328	; 0x148
 80161ba:	2241      	movs	r2, #65	; 0x41
 80161bc:	4b1a      	ldr	r3, [pc, #104]	; (8016228 <main+0xa8>)
 80161be:	f7eb f80f 	bl	80011e0 <chThdCreateStatic>
  chThdCreateStatic(waStepCounterThread, sizeof(waStepCounterThread), NORMALPRIO+1, stepCounterThread, NULL);
 80161c2:	2300      	movs	r3, #0
 80161c4:	9300      	str	r3, [sp, #0]
 80161c6:	4819      	ldr	r0, [pc, #100]	; (801622c <main+0xac>)
 80161c8:	f44f 7132 	mov.w	r1, #712	; 0x2c8
 80161cc:	2241      	movs	r2, #65	; 0x41
 80161ce:	4b18      	ldr	r3, [pc, #96]	; (8016230 <main+0xb0>)
 80161d0:	f7eb f806 	bl	80011e0 <chThdCreateStatic>
  //chThdCreateStatic(waAccelTestThread, sizeof(waAccelTestThread), NORMALPRIO+1, accelTestThread, NULL);
  while (TRUE) {
    if (!shelltp) {
 80161d4:	4b17      	ldr	r3, [pc, #92]	; (8016234 <main+0xb4>)
 80161d6:	681b      	ldr	r3, [r3, #0]
 80161d8:	2b00      	cmp	r3, #0
 80161da:	d109      	bne.n	80161f0 <main+0x70>
      shelltp = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
 80161dc:	4816      	ldr	r0, [pc, #88]	; (8016238 <main+0xb8>)
 80161de:	f640 01c8 	movw	r1, #2248	; 0x8c8
 80161e2:	2240      	movs	r2, #64	; 0x40
 80161e4:	f7fb fca4 	bl	8011b30 <shellCreate>
 80161e8:	4602      	mov	r2, r0
 80161ea:	4b12      	ldr	r3, [pc, #72]	; (8016234 <main+0xb4>)
 80161ec:	601a      	str	r2, [r3, #0]
 80161ee:	e00f      	b.n	8016210 <main+0x90>
    }
    else if (chThdTerminatedX(shelltp)) {
 80161f0:	4b10      	ldr	r3, [pc, #64]	; (8016234 <main+0xb4>)
 80161f2:	681b      	ldr	r3, [r3, #0]
 80161f4:	4618      	mov	r0, r3
 80161f6:	f7ff fe8b 	bl	8015f10 <chThdTerminatedX>
 80161fa:	4603      	mov	r3, r0
 80161fc:	2b00      	cmp	r3, #0
 80161fe:	d007      	beq.n	8016210 <main+0x90>
      chThdRelease(shelltp);    /* Recovers memory of the previous shell.   */
 8016200:	4b0c      	ldr	r3, [pc, #48]	; (8016234 <main+0xb4>)
 8016202:	681b      	ldr	r3, [r3, #0]
 8016204:	4618      	mov	r0, r3
 8016206:	f7eb fadb 	bl	80017c0 <chThdRelease>
      shelltp = NULL;           /* Triggers spawning of a new shell.        */
 801620a:	4b0a      	ldr	r3, [pc, #40]	; (8016234 <main+0xb4>)
 801620c:	2200      	movs	r2, #0
 801620e:	601a      	str	r2, [r3, #0]
    }
    chThdSleepMilliseconds(1000);
 8016210:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8016214:	f7eb f85c 	bl	80012d0 <chThdSleep>
  }
 8016218:	e7dc      	b.n	80161d4 <main+0x54>
 801621a:	bf00      	nop
 801621c:	20001fd8 	.word	0x20001fd8
 8016220:	0801a700 	.word	0x0801a700
 8016224:	20001770 	.word	0x20001770
 8016228:	08015fd1 	.word	0x08015fd1
 801622c:	200018b8 	.word	0x200018b8
 8016230:	08016051 	.word	0x08016051
 8016234:	20001b80 	.word	0x20001b80
 8016238:	0801a6f8 	.word	0x0801a6f8
 801623c:	f3af 8000 	nop.w

08016240 <setStartingRTCTime>:
}

void setStartingRTCTime() {
 8016240:	b500      	push	{lr}
 8016242:	b083      	sub	sp, #12
  RTCDateTime timespec;
  timespec.year = 37;  /* Years since 1980. */
 8016244:	f89d 3000 	ldrb.w	r3, [sp]
 8016248:	2225      	movs	r2, #37	; 0x25
 801624a:	f362 0307 	bfi	r3, r2, #0, #8
 801624e:	f88d 3000 	strb.w	r3, [sp]
  timespec.month = 4;
 8016252:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8016256:	2204      	movs	r2, #4
 8016258:	f362 0303 	bfi	r3, r2, #0, #4
 801625c:	f88d 3001 	strb.w	r3, [sp, #1]
  timespec.dayofweek = 5; 
 8016260:	f89d 3001 	ldrb.w	r3, [sp, #1]
 8016264:	2205      	movs	r2, #5
 8016266:	f362 1347 	bfi	r3, r2, #5, #3
 801626a:	f88d 3001 	strb.w	r3, [sp, #1]
  timespec.day = 14;
 801626e:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8016272:	220e      	movs	r2, #14
 8016274:	f362 0304 	bfi	r3, r2, #0, #5
 8016278:	f88d 3002 	strb.w	r3, [sp, #2]
  timespec.millisecond = 1000 * 60 * 60 * 13 + 1000 * 60 * 20;
 801627c:	9b01      	ldr	r3, [sp, #4]
 801627e:	4a06      	ldr	r2, [pc, #24]	; (8016298 <setStartingRTCTime+0x58>)
 8016280:	f362 031a 	bfi	r3, r2, #0, #27
 8016284:	9301      	str	r3, [sp, #4]
  rtcSetTime(&RTCD1, &timespec);
 8016286:	466b      	mov	r3, sp
 8016288:	4804      	ldr	r0, [pc, #16]	; (801629c <setStartingRTCTime+0x5c>)
 801628a:	4619      	mov	r1, r3
 801628c:	f7ee fef8 	bl	8005080 <rtcSetTime>
}
 8016290:	b003      	add	sp, #12
 8016292:	f85d fb04 	ldr.w	pc, [sp], #4
 8016296:	bf00      	nop
 8016298:	02dc6c00 	.word	0x02dc6c00
 801629c:	20001f58 	.word	0x20001f58

080162a0 <getTimeStamp>:

RTCDateTime getTimeStamp() {
 80162a0:	b500      	push	{lr}
 80162a2:	b085      	sub	sp, #20
 80162a4:	9001      	str	r0, [sp, #4]
  RTCDateTime timespec;
  rtcGetTime(&RTCD1, &timespec);
 80162a6:	ab02      	add	r3, sp, #8
 80162a8:	4806      	ldr	r0, [pc, #24]	; (80162c4 <getTimeStamp+0x24>)
 80162aa:	4619      	mov	r1, r3
 80162ac:	f7ee fef8 	bl	80050a0 <rtcGetTime>
  return timespec;
 80162b0:	9b01      	ldr	r3, [sp, #4]
 80162b2:	aa02      	add	r2, sp, #8
 80162b4:	e892 0003 	ldmia.w	r2, {r0, r1}
 80162b8:	e883 0003 	stmia.w	r3, {r0, r1}
}
 80162bc:	9801      	ldr	r0, [sp, #4]
 80162be:	b005      	add	sp, #20
 80162c0:	f85d fb04 	ldr.w	pc, [sp], #4
 80162c4:	20001f58 	.word	0x20001f58
 80162c8:	f3af 8000 	nop.w
 80162cc:	f3af 8000 	nop.w

080162d0 <saveTimeStamp>:

void saveTimeStamp(RTCDateTime timespec) {
 80162d0:	b082      	sub	sp, #8
 80162d2:	466b      	mov	r3, sp
 80162d4:	e883 0003 	stmia.w	r3, {r0, r1}
  time_data[total_logs].year = timespec.year;
 80162d8:	4b21      	ldr	r3, [pc, #132]	; (8016360 <saveTimeStamp+0x90>)
 80162da:	6819      	ldr	r1, [r3, #0]
 80162dc:	f89d 0000 	ldrb.w	r0, [sp]
 80162e0:	4a20      	ldr	r2, [pc, #128]	; (8016364 <saveTimeStamp+0x94>)
 80162e2:	f812 3031 	ldrb.w	r3, [r2, r1, lsl #3]
 80162e6:	f360 0307 	bfi	r3, r0, #0, #8
 80162ea:	f802 3031 	strb.w	r3, [r2, r1, lsl #3]
  time_data[total_logs].month = timespec.month;
 80162ee:	4b1c      	ldr	r3, [pc, #112]	; (8016360 <saveTimeStamp+0x90>)
 80162f0:	681b      	ldr	r3, [r3, #0]
 80162f2:	f89d 2001 	ldrb.w	r2, [sp, #1]
 80162f6:	f3c2 0203 	ubfx	r2, r2, #0, #4
 80162fa:	b2d1      	uxtb	r1, r2
 80162fc:	4a19      	ldr	r2, [pc, #100]	; (8016364 <saveTimeStamp+0x94>)
 80162fe:	00db      	lsls	r3, r3, #3
 8016300:	4413      	add	r3, r2
 8016302:	785a      	ldrb	r2, [r3, #1]
 8016304:	f361 0203 	bfi	r2, r1, #0, #4
 8016308:	705a      	strb	r2, [r3, #1]
  time_data[total_logs].day = timespec.day;
 801630a:	4b15      	ldr	r3, [pc, #84]	; (8016360 <saveTimeStamp+0x90>)
 801630c:	681b      	ldr	r3, [r3, #0]
 801630e:	f89d 2002 	ldrb.w	r2, [sp, #2]
 8016312:	f3c2 0204 	ubfx	r2, r2, #0, #5
 8016316:	b2d1      	uxtb	r1, r2
 8016318:	4a12      	ldr	r2, [pc, #72]	; (8016364 <saveTimeStamp+0x94>)
 801631a:	00db      	lsls	r3, r3, #3
 801631c:	4413      	add	r3, r2
 801631e:	789a      	ldrb	r2, [r3, #2]
 8016320:	f361 0204 	bfi	r2, r1, #0, #5
 8016324:	709a      	strb	r2, [r3, #2]
  time_data[total_logs].dayofweek = timespec.dayofweek;
 8016326:	4b0e      	ldr	r3, [pc, #56]	; (8016360 <saveTimeStamp+0x90>)
 8016328:	681b      	ldr	r3, [r3, #0]
 801632a:	f89d 2001 	ldrb.w	r2, [sp, #1]
 801632e:	f3c2 1242 	ubfx	r2, r2, #5, #3
 8016332:	b2d1      	uxtb	r1, r2
 8016334:	4a0b      	ldr	r2, [pc, #44]	; (8016364 <saveTimeStamp+0x94>)
 8016336:	00db      	lsls	r3, r3, #3
 8016338:	4413      	add	r3, r2
 801633a:	785a      	ldrb	r2, [r3, #1]
 801633c:	f361 1247 	bfi	r2, r1, #5, #3
 8016340:	705a      	strb	r2, [r3, #1]
  time_data[total_logs].millisecond = timespec.millisecond;
 8016342:	4b07      	ldr	r3, [pc, #28]	; (8016360 <saveTimeStamp+0x90>)
 8016344:	681b      	ldr	r3, [r3, #0]
 8016346:	9a01      	ldr	r2, [sp, #4]
 8016348:	f3c2 011a 	ubfx	r1, r2, #0, #27
 801634c:	4a05      	ldr	r2, [pc, #20]	; (8016364 <saveTimeStamp+0x94>)
 801634e:	00db      	lsls	r3, r3, #3
 8016350:	4413      	add	r3, r2
 8016352:	685a      	ldr	r2, [r3, #4]
 8016354:	f361 021a 	bfi	r2, r1, #0, #27
 8016358:	605a      	str	r2, [r3, #4]
}
 801635a:	b002      	add	sp, #8
 801635c:	4770      	bx	lr
 801635e:	bf00      	nop
 8016360:	200014d8 	.word	0x200014d8
 8016364:	2000367c 	.word	0x2000367c
 8016368:	f3af 8000 	nop.w
 801636c:	f3af 8000 	nop.w

08016370 <__aeabi_ldivmod>:
 8016370:	b973      	cbnz	r3, 8016390 <__aeabi_ldivmod+0x20>
 8016372:	b96a      	cbnz	r2, 8016390 <__aeabi_ldivmod+0x20>
 8016374:	2900      	cmp	r1, #0
 8016376:	bf08      	it	eq
 8016378:	2800      	cmpeq	r0, #0
 801637a:	bfbc      	itt	lt
 801637c:	2000      	movlt	r0, #0
 801637e:	f04f 4100 	movlt.w	r1, #2147483648	; 0x80000000
 8016382:	bfc4      	itt	gt
 8016384:	f06f 4100 	mvngt.w	r1, #2147483648	; 0x80000000
 8016388:	f04f 30ff 	movgt.w	r0, #4294967295
 801638c:	f000 b840 	b.w	8016410 <__aeabi_idiv0>
 8016390:	b082      	sub	sp, #8
 8016392:	46ec      	mov	ip, sp
 8016394:	e92d 5000 	stmdb	sp!, {ip, lr}
 8016398:	f000 f80a 	bl	80163b0 <__gnu_ldivmod_helper>
 801639c:	f8dd e004 	ldr.w	lr, [sp, #4]
 80163a0:	b002      	add	sp, #8
 80163a2:	bc0c      	pop	{r2, r3}
 80163a4:	4770      	bx	lr
 80163a6:	bf00      	nop
	...

080163b0 <__gnu_ldivmod_helper>:
 80163b0:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 80163b4:	9e06      	ldr	r6, [sp, #24]
 80163b6:	4614      	mov	r4, r2
 80163b8:	461d      	mov	r5, r3
 80163ba:	4680      	mov	r8, r0
 80163bc:	4689      	mov	r9, r1
 80163be:	f000 f82f 	bl	8016420 <__divdi3>
 80163c2:	fb04 f301 	mul.w	r3, r4, r1
 80163c6:	fb00 3305 	mla	r3, r0, r5, r3
 80163ca:	fba4 4500 	umull	r4, r5, r4, r0
 80163ce:	441d      	add	r5, r3
 80163d0:	ebb8 0404 	subs.w	r4, r8, r4
 80163d4:	eb69 0505 	sbc.w	r5, r9, r5
 80163d8:	e9c6 4500 	strd	r4, r5, [r6]
 80163dc:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

080163e0 <__gnu_uldivmod_helper>:
 80163e0:	e92d 4370 	stmdb	sp!, {r4, r5, r6, r8, r9, lr}
 80163e4:	9e06      	ldr	r6, [sp, #24]
 80163e6:	4614      	mov	r4, r2
 80163e8:	4680      	mov	r8, r0
 80163ea:	4689      	mov	r9, r1
 80163ec:	461d      	mov	r5, r3
 80163ee:	f000 f967 	bl	80166c0 <__udivdi3>
 80163f2:	fb00 f505 	mul.w	r5, r0, r5
 80163f6:	fb04 5301 	mla	r3, r4, r1, r5
 80163fa:	fba0 4504 	umull	r4, r5, r0, r4
 80163fe:	441d      	add	r5, r3
 8016400:	ebb8 0404 	subs.w	r4, r8, r4
 8016404:	eb69 0505 	sbc.w	r5, r9, r5
 8016408:	e9c6 4500 	strd	r4, r5, [r6]
 801640c:	e8bd 8370 	ldmia.w	sp!, {r4, r5, r6, r8, r9, pc}

08016410 <__aeabi_idiv0>:
 8016410:	4770      	bx	lr
 8016412:	bf00      	nop
	...

08016420 <__divdi3>:
 8016420:	2900      	cmp	r1, #0
 8016422:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016426:	f2c0 809f 	blt.w	8016568 <__divdi3+0x148>
 801642a:	2400      	movs	r4, #0
 801642c:	2b00      	cmp	r3, #0
 801642e:	f2c0 8096 	blt.w	801655e <__divdi3+0x13e>
 8016432:	4615      	mov	r5, r2
 8016434:	4606      	mov	r6, r0
 8016436:	460f      	mov	r7, r1
 8016438:	2b00      	cmp	r3, #0
 801643a:	d13e      	bne.n	80164ba <__divdi3+0x9a>
 801643c:	428a      	cmp	r2, r1
 801643e:	d957      	bls.n	80164f0 <__divdi3+0xd0>
 8016440:	fab2 f382 	clz	r3, r2
 8016444:	b14b      	cbz	r3, 801645a <__divdi3+0x3a>
 8016446:	f1c3 0220 	rsb	r2, r3, #32
 801644a:	fa01 f703 	lsl.w	r7, r1, r3
 801644e:	fa20 f202 	lsr.w	r2, r0, r2
 8016452:	409d      	lsls	r5, r3
 8016454:	4317      	orrs	r7, r2
 8016456:	fa00 f603 	lsl.w	r6, r0, r3
 801645a:	0c29      	lsrs	r1, r5, #16
 801645c:	fbb7 f2f1 	udiv	r2, r7, r1
 8016460:	0c33      	lsrs	r3, r6, #16
 8016462:	fb01 7c12 	mls	ip, r1, r2, r7
 8016466:	b2a8      	uxth	r0, r5
 8016468:	ea43 470c 	orr.w	r7, r3, ip, lsl #16
 801646c:	fb00 f302 	mul.w	r3, r0, r2
 8016470:	42bb      	cmp	r3, r7
 8016472:	d909      	bls.n	8016488 <__divdi3+0x68>
 8016474:	197f      	adds	r7, r7, r5
 8016476:	f102 3cff 	add.w	ip, r2, #4294967295
 801647a:	f080 8101 	bcs.w	8016680 <__divdi3+0x260>
 801647e:	42bb      	cmp	r3, r7
 8016480:	f240 80fe 	bls.w	8016680 <__divdi3+0x260>
 8016484:	3a02      	subs	r2, #2
 8016486:	442f      	add	r7, r5
 8016488:	1aff      	subs	r7, r7, r3
 801648a:	fbb7 f3f1 	udiv	r3, r7, r1
 801648e:	b2b6      	uxth	r6, r6
 8016490:	fb01 7113 	mls	r1, r1, r3, r7
 8016494:	ea46 4101 	orr.w	r1, r6, r1, lsl #16
 8016498:	fb00 f003 	mul.w	r0, r0, r3
 801649c:	4288      	cmp	r0, r1
 801649e:	d908      	bls.n	80164b2 <__divdi3+0x92>
 80164a0:	1949      	adds	r1, r1, r5
 80164a2:	f103 37ff 	add.w	r7, r3, #4294967295
 80164a6:	f080 80ed 	bcs.w	8016684 <__divdi3+0x264>
 80164aa:	4288      	cmp	r0, r1
 80164ac:	f240 80ea 	bls.w	8016684 <__divdi3+0x264>
 80164b0:	3b02      	subs	r3, #2
 80164b2:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80164b6:	2300      	movs	r3, #0
 80164b8:	e003      	b.n	80164c2 <__divdi3+0xa2>
 80164ba:	428b      	cmp	r3, r1
 80164bc:	d90a      	bls.n	80164d4 <__divdi3+0xb4>
 80164be:	2300      	movs	r3, #0
 80164c0:	461a      	mov	r2, r3
 80164c2:	4610      	mov	r0, r2
 80164c4:	4619      	mov	r1, r3
 80164c6:	b114      	cbz	r4, 80164ce <__divdi3+0xae>
 80164c8:	4240      	negs	r0, r0
 80164ca:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80164ce:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80164d2:	4770      	bx	lr
 80164d4:	fab3 f883 	clz	r8, r3
 80164d8:	f1b8 0f00 	cmp.w	r8, #0
 80164dc:	f040 8084 	bne.w	80165e8 <__divdi3+0x1c8>
 80164e0:	428b      	cmp	r3, r1
 80164e2:	d302      	bcc.n	80164ea <__divdi3+0xca>
 80164e4:	4282      	cmp	r2, r0
 80164e6:	f200 80de 	bhi.w	80166a6 <__divdi3+0x286>
 80164ea:	2300      	movs	r3, #0
 80164ec:	2201      	movs	r2, #1
 80164ee:	e7e8      	b.n	80164c2 <__divdi3+0xa2>
 80164f0:	b912      	cbnz	r2, 80164f8 <__divdi3+0xd8>
 80164f2:	2301      	movs	r3, #1
 80164f4:	fbb3 f5f2 	udiv	r5, r3, r2
 80164f8:	fab5 f285 	clz	r2, r5
 80164fc:	2a00      	cmp	r2, #0
 80164fe:	d139      	bne.n	8016574 <__divdi3+0x154>
 8016500:	1b7f      	subs	r7, r7, r5
 8016502:	0c28      	lsrs	r0, r5, #16
 8016504:	fa1f fc85 	uxth.w	ip, r5
 8016508:	2301      	movs	r3, #1
 801650a:	fbb7 f1f0 	udiv	r1, r7, r0
 801650e:	0c32      	lsrs	r2, r6, #16
 8016510:	fb00 7711 	mls	r7, r0, r1, r7
 8016514:	ea42 4707 	orr.w	r7, r2, r7, lsl #16
 8016518:	fb0c f201 	mul.w	r2, ip, r1
 801651c:	42ba      	cmp	r2, r7
 801651e:	d907      	bls.n	8016530 <__divdi3+0x110>
 8016520:	197f      	adds	r7, r7, r5
 8016522:	f101 38ff 	add.w	r8, r1, #4294967295
 8016526:	d202      	bcs.n	801652e <__divdi3+0x10e>
 8016528:	42ba      	cmp	r2, r7
 801652a:	f200 80c1 	bhi.w	80166b0 <__divdi3+0x290>
 801652e:	4641      	mov	r1, r8
 8016530:	1abf      	subs	r7, r7, r2
 8016532:	fbb7 f2f0 	udiv	r2, r7, r0
 8016536:	b2b6      	uxth	r6, r6
 8016538:	fb00 7012 	mls	r0, r0, r2, r7
 801653c:	ea46 4000 	orr.w	r0, r6, r0, lsl #16
 8016540:	fb0c fc02 	mul.w	ip, ip, r2
 8016544:	4584      	cmp	ip, r0
 8016546:	d907      	bls.n	8016558 <__divdi3+0x138>
 8016548:	1940      	adds	r0, r0, r5
 801654a:	f102 37ff 	add.w	r7, r2, #4294967295
 801654e:	d202      	bcs.n	8016556 <__divdi3+0x136>
 8016550:	4584      	cmp	ip, r0
 8016552:	f200 80ab 	bhi.w	80166ac <__divdi3+0x28c>
 8016556:	463a      	mov	r2, r7
 8016558:	ea42 4201 	orr.w	r2, r2, r1, lsl #16
 801655c:	e7b1      	b.n	80164c2 <__divdi3+0xa2>
 801655e:	43e4      	mvns	r4, r4
 8016560:	4252      	negs	r2, r2
 8016562:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8016566:	e764      	b.n	8016432 <__divdi3+0x12>
 8016568:	4240      	negs	r0, r0
 801656a:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 801656e:	f04f 34ff 	mov.w	r4, #4294967295
 8016572:	e75b      	b.n	801642c <__divdi3+0xc>
 8016574:	4095      	lsls	r5, r2
 8016576:	f1c2 0320 	rsb	r3, r2, #32
 801657a:	fa27 f103 	lsr.w	r1, r7, r3
 801657e:	0c28      	lsrs	r0, r5, #16
 8016580:	fa26 f303 	lsr.w	r3, r6, r3
 8016584:	4097      	lsls	r7, r2
 8016586:	fbb1 f8f0 	udiv	r8, r1, r0
 801658a:	431f      	orrs	r7, r3
 801658c:	0c3b      	lsrs	r3, r7, #16
 801658e:	fb00 1118 	mls	r1, r0, r8, r1
 8016592:	fa1f fc85 	uxth.w	ip, r5
 8016596:	ea43 4101 	orr.w	r1, r3, r1, lsl #16
 801659a:	fb0c f308 	mul.w	r3, ip, r8
 801659e:	428b      	cmp	r3, r1
 80165a0:	fa06 f602 	lsl.w	r6, r6, r2
 80165a4:	d908      	bls.n	80165b8 <__divdi3+0x198>
 80165a6:	1949      	adds	r1, r1, r5
 80165a8:	f108 32ff 	add.w	r2, r8, #4294967295
 80165ac:	d279      	bcs.n	80166a2 <__divdi3+0x282>
 80165ae:	428b      	cmp	r3, r1
 80165b0:	d977      	bls.n	80166a2 <__divdi3+0x282>
 80165b2:	f1a8 0802 	sub.w	r8, r8, #2
 80165b6:	4429      	add	r1, r5
 80165b8:	1ac9      	subs	r1, r1, r3
 80165ba:	fbb1 f3f0 	udiv	r3, r1, r0
 80165be:	b2bf      	uxth	r7, r7
 80165c0:	fb00 1113 	mls	r1, r0, r3, r1
 80165c4:	ea47 4701 	orr.w	r7, r7, r1, lsl #16
 80165c8:	fb0c f203 	mul.w	r2, ip, r3
 80165cc:	42ba      	cmp	r2, r7
 80165ce:	d907      	bls.n	80165e0 <__divdi3+0x1c0>
 80165d0:	197f      	adds	r7, r7, r5
 80165d2:	f103 31ff 	add.w	r1, r3, #4294967295
 80165d6:	d260      	bcs.n	801669a <__divdi3+0x27a>
 80165d8:	42ba      	cmp	r2, r7
 80165da:	d95e      	bls.n	801669a <__divdi3+0x27a>
 80165dc:	3b02      	subs	r3, #2
 80165de:	442f      	add	r7, r5
 80165e0:	1abf      	subs	r7, r7, r2
 80165e2:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80165e6:	e790      	b.n	801650a <__divdi3+0xea>
 80165e8:	f1c8 0220 	rsb	r2, r8, #32
 80165ec:	fa03 fc08 	lsl.w	ip, r3, r8
 80165f0:	fa25 f302 	lsr.w	r3, r5, r2
 80165f4:	ea43 0c0c 	orr.w	ip, r3, ip
 80165f8:	ea4f 491c 	mov.w	r9, ip, lsr #16
 80165fc:	fa21 f302 	lsr.w	r3, r1, r2
 8016600:	fa01 f708 	lsl.w	r7, r1, r8
 8016604:	fa20 f202 	lsr.w	r2, r0, r2
 8016608:	fbb3 f1f9 	udiv	r1, r3, r9
 801660c:	4317      	orrs	r7, r2
 801660e:	fb09 3311 	mls	r3, r9, r1, r3
 8016612:	0c3a      	lsrs	r2, r7, #16
 8016614:	fa1f fb8c 	uxth.w	fp, ip
 8016618:	ea42 4303 	orr.w	r3, r2, r3, lsl #16
 801661c:	fb0b fa01 	mul.w	sl, fp, r1
 8016620:	459a      	cmp	sl, r3
 8016622:	fa05 f008 	lsl.w	r0, r5, r8
 8016626:	d908      	bls.n	801663a <__divdi3+0x21a>
 8016628:	eb13 030c 	adds.w	r3, r3, ip
 801662c:	f101 32ff 	add.w	r2, r1, #4294967295
 8016630:	d235      	bcs.n	801669e <__divdi3+0x27e>
 8016632:	459a      	cmp	sl, r3
 8016634:	d933      	bls.n	801669e <__divdi3+0x27e>
 8016636:	3902      	subs	r1, #2
 8016638:	4463      	add	r3, ip
 801663a:	ebca 0303 	rsb	r3, sl, r3
 801663e:	fbb3 f2f9 	udiv	r2, r3, r9
 8016642:	fb09 3312 	mls	r3, r9, r2, r3
 8016646:	b2bf      	uxth	r7, r7
 8016648:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 801664c:	fb0b f902 	mul.w	r9, fp, r2
 8016650:	45b9      	cmp	r9, r7
 8016652:	d908      	bls.n	8016666 <__divdi3+0x246>
 8016654:	eb17 070c 	adds.w	r7, r7, ip
 8016658:	f102 33ff 	add.w	r3, r2, #4294967295
 801665c:	d21b      	bcs.n	8016696 <__divdi3+0x276>
 801665e:	45b9      	cmp	r9, r7
 8016660:	d919      	bls.n	8016696 <__divdi3+0x276>
 8016662:	3a02      	subs	r2, #2
 8016664:	4467      	add	r7, ip
 8016666:	ea42 4501 	orr.w	r5, r2, r1, lsl #16
 801666a:	fba5 0100 	umull	r0, r1, r5, r0
 801666e:	ebc9 0707 	rsb	r7, r9, r7
 8016672:	428f      	cmp	r7, r1
 8016674:	f04f 0300 	mov.w	r3, #0
 8016678:	d30a      	bcc.n	8016690 <__divdi3+0x270>
 801667a:	d005      	beq.n	8016688 <__divdi3+0x268>
 801667c:	462a      	mov	r2, r5
 801667e:	e720      	b.n	80164c2 <__divdi3+0xa2>
 8016680:	4662      	mov	r2, ip
 8016682:	e701      	b.n	8016488 <__divdi3+0x68>
 8016684:	463b      	mov	r3, r7
 8016686:	e714      	b.n	80164b2 <__divdi3+0x92>
 8016688:	fa06 f608 	lsl.w	r6, r6, r8
 801668c:	4286      	cmp	r6, r0
 801668e:	d2f5      	bcs.n	801667c <__divdi3+0x25c>
 8016690:	1e6a      	subs	r2, r5, #1
 8016692:	2300      	movs	r3, #0
 8016694:	e715      	b.n	80164c2 <__divdi3+0xa2>
 8016696:	461a      	mov	r2, r3
 8016698:	e7e5      	b.n	8016666 <__divdi3+0x246>
 801669a:	460b      	mov	r3, r1
 801669c:	e7a0      	b.n	80165e0 <__divdi3+0x1c0>
 801669e:	4611      	mov	r1, r2
 80166a0:	e7cb      	b.n	801663a <__divdi3+0x21a>
 80166a2:	4690      	mov	r8, r2
 80166a4:	e788      	b.n	80165b8 <__divdi3+0x198>
 80166a6:	4643      	mov	r3, r8
 80166a8:	4642      	mov	r2, r8
 80166aa:	e70a      	b.n	80164c2 <__divdi3+0xa2>
 80166ac:	3a02      	subs	r2, #2
 80166ae:	e753      	b.n	8016558 <__divdi3+0x138>
 80166b0:	3902      	subs	r1, #2
 80166b2:	442f      	add	r7, r5
 80166b4:	e73c      	b.n	8016530 <__divdi3+0x110>
 80166b6:	bf00      	nop
	...

080166c0 <__udivdi3>:
 80166c0:	e92d 0ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80166c4:	4614      	mov	r4, r2
 80166c6:	4605      	mov	r5, r0
 80166c8:	460e      	mov	r6, r1
 80166ca:	2b00      	cmp	r3, #0
 80166cc:	d143      	bne.n	8016756 <__udivdi3+0x96>
 80166ce:	428a      	cmp	r2, r1
 80166d0:	d953      	bls.n	801677a <__udivdi3+0xba>
 80166d2:	fab2 f782 	clz	r7, r2
 80166d6:	b157      	cbz	r7, 80166ee <__udivdi3+0x2e>
 80166d8:	f1c7 0620 	rsb	r6, r7, #32
 80166dc:	fa20 f606 	lsr.w	r6, r0, r6
 80166e0:	fa01 f307 	lsl.w	r3, r1, r7
 80166e4:	fa02 f407 	lsl.w	r4, r2, r7
 80166e8:	431e      	orrs	r6, r3
 80166ea:	fa00 f507 	lsl.w	r5, r0, r7
 80166ee:	0c21      	lsrs	r1, r4, #16
 80166f0:	fbb6 f2f1 	udiv	r2, r6, r1
 80166f4:	0c2b      	lsrs	r3, r5, #16
 80166f6:	fb01 6712 	mls	r7, r1, r2, r6
 80166fa:	b2a0      	uxth	r0, r4
 80166fc:	ea43 4607 	orr.w	r6, r3, r7, lsl #16
 8016700:	fb00 f302 	mul.w	r3, r0, r2
 8016704:	42b3      	cmp	r3, r6
 8016706:	d909      	bls.n	801671c <__udivdi3+0x5c>
 8016708:	1936      	adds	r6, r6, r4
 801670a:	f102 37ff 	add.w	r7, r2, #4294967295
 801670e:	f080 80f6 	bcs.w	80168fe <__udivdi3+0x23e>
 8016712:	42b3      	cmp	r3, r6
 8016714:	f240 80f3 	bls.w	80168fe <__udivdi3+0x23e>
 8016718:	3a02      	subs	r2, #2
 801671a:	4426      	add	r6, r4
 801671c:	1af6      	subs	r6, r6, r3
 801671e:	fbb6 f3f1 	udiv	r3, r6, r1
 8016722:	b2ad      	uxth	r5, r5
 8016724:	fb01 6113 	mls	r1, r1, r3, r6
 8016728:	ea45 4101 	orr.w	r1, r5, r1, lsl #16
 801672c:	fb00 f003 	mul.w	r0, r0, r3
 8016730:	4288      	cmp	r0, r1
 8016732:	d908      	bls.n	8016746 <__udivdi3+0x86>
 8016734:	1909      	adds	r1, r1, r4
 8016736:	f103 36ff 	add.w	r6, r3, #4294967295
 801673a:	f080 80e2 	bcs.w	8016902 <__udivdi3+0x242>
 801673e:	4288      	cmp	r0, r1
 8016740:	f240 80df 	bls.w	8016902 <__udivdi3+0x242>
 8016744:	3b02      	subs	r3, #2
 8016746:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 801674a:	2300      	movs	r3, #0
 801674c:	4610      	mov	r0, r2
 801674e:	4619      	mov	r1, r3
 8016750:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016754:	4770      	bx	lr
 8016756:	428b      	cmp	r3, r1
 8016758:	d84a      	bhi.n	80167f0 <__udivdi3+0x130>
 801675a:	fab3 f683 	clz	r6, r3
 801675e:	2e00      	cmp	r6, #0
 8016760:	d14d      	bne.n	80167fe <__udivdi3+0x13e>
 8016762:	428b      	cmp	r3, r1
 8016764:	d302      	bcc.n	801676c <__udivdi3+0xac>
 8016766:	4282      	cmp	r2, r0
 8016768:	f200 80d6 	bhi.w	8016918 <__udivdi3+0x258>
 801676c:	2300      	movs	r3, #0
 801676e:	2201      	movs	r2, #1
 8016770:	4610      	mov	r0, r2
 8016772:	4619      	mov	r1, r3
 8016774:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 8016778:	4770      	bx	lr
 801677a:	b912      	cbnz	r2, 8016782 <__udivdi3+0xc2>
 801677c:	2401      	movs	r4, #1
 801677e:	fbb4 f4f2 	udiv	r4, r4, r2
 8016782:	fab4 f284 	clz	r2, r4
 8016786:	2a00      	cmp	r2, #0
 8016788:	d17c      	bne.n	8016884 <__udivdi3+0x1c4>
 801678a:	1b09      	subs	r1, r1, r4
 801678c:	0c26      	lsrs	r6, r4, #16
 801678e:	b2a7      	uxth	r7, r4
 8016790:	2301      	movs	r3, #1
 8016792:	fbb1 f0f6 	udiv	r0, r1, r6
 8016796:	0c2a      	lsrs	r2, r5, #16
 8016798:	fb06 1110 	mls	r1, r6, r0, r1
 801679c:	ea42 4101 	orr.w	r1, r2, r1, lsl #16
 80167a0:	fb07 f200 	mul.w	r2, r7, r0
 80167a4:	428a      	cmp	r2, r1
 80167a6:	d907      	bls.n	80167b8 <__udivdi3+0xf8>
 80167a8:	1909      	adds	r1, r1, r4
 80167aa:	f100 3cff 	add.w	ip, r0, #4294967295
 80167ae:	d202      	bcs.n	80167b6 <__udivdi3+0xf6>
 80167b0:	428a      	cmp	r2, r1
 80167b2:	f200 80c3 	bhi.w	801693c <__udivdi3+0x27c>
 80167b6:	4660      	mov	r0, ip
 80167b8:	1a89      	subs	r1, r1, r2
 80167ba:	fbb1 f2f6 	udiv	r2, r1, r6
 80167be:	b2ad      	uxth	r5, r5
 80167c0:	fb06 1112 	mls	r1, r6, r2, r1
 80167c4:	ea45 4501 	orr.w	r5, r5, r1, lsl #16
 80167c8:	fb07 f702 	mul.w	r7, r7, r2
 80167cc:	42af      	cmp	r7, r5
 80167ce:	d908      	bls.n	80167e2 <__udivdi3+0x122>
 80167d0:	192c      	adds	r4, r5, r4
 80167d2:	f102 31ff 	add.w	r1, r2, #4294967295
 80167d6:	f080 8096 	bcs.w	8016906 <__udivdi3+0x246>
 80167da:	42a7      	cmp	r7, r4
 80167dc:	f240 8093 	bls.w	8016906 <__udivdi3+0x246>
 80167e0:	3a02      	subs	r2, #2
 80167e2:	ea42 4200 	orr.w	r2, r2, r0, lsl #16
 80167e6:	4610      	mov	r0, r2
 80167e8:	4619      	mov	r1, r3
 80167ea:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80167ee:	4770      	bx	lr
 80167f0:	2300      	movs	r3, #0
 80167f2:	461a      	mov	r2, r3
 80167f4:	4610      	mov	r0, r2
 80167f6:	4619      	mov	r1, r3
 80167f8:	e8bd 0ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp}
 80167fc:	4770      	bx	lr
 80167fe:	f1c6 0520 	rsb	r5, r6, #32
 8016802:	fa22 f405 	lsr.w	r4, r2, r5
 8016806:	40b3      	lsls	r3, r6
 8016808:	431c      	orrs	r4, r3
 801680a:	ea4f 4814 	mov.w	r8, r4, lsr #16
 801680e:	fa21 f305 	lsr.w	r3, r1, r5
 8016812:	fa01 f706 	lsl.w	r7, r1, r6
 8016816:	fa20 f505 	lsr.w	r5, r0, r5
 801681a:	fbb3 fcf8 	udiv	ip, r3, r8
 801681e:	432f      	orrs	r7, r5
 8016820:	fb08 331c 	mls	r3, r8, ip, r3
 8016824:	0c3d      	lsrs	r5, r7, #16
 8016826:	fa1f fa84 	uxth.w	sl, r4
 801682a:	ea45 4303 	orr.w	r3, r5, r3, lsl #16
 801682e:	fb0a f90c 	mul.w	r9, sl, ip
 8016832:	4599      	cmp	r9, r3
 8016834:	fa02 fb06 	lsl.w	fp, r2, r6
 8016838:	d904      	bls.n	8016844 <__udivdi3+0x184>
 801683a:	191b      	adds	r3, r3, r4
 801683c:	f10c 32ff 	add.w	r2, ip, #4294967295
 8016840:	d36d      	bcc.n	801691e <__udivdi3+0x25e>
 8016842:	4694      	mov	ip, r2
 8016844:	ebc9 0303 	rsb	r3, r9, r3
 8016848:	fbb3 f5f8 	udiv	r5, r3, r8
 801684c:	fb08 3315 	mls	r3, r8, r5, r3
 8016850:	b2bf      	uxth	r7, r7
 8016852:	ea47 4703 	orr.w	r7, r7, r3, lsl #16
 8016856:	fb0a f805 	mul.w	r8, sl, r5
 801685a:	45b8      	cmp	r8, r7
 801685c:	d904      	bls.n	8016868 <__udivdi3+0x1a8>
 801685e:	193f      	adds	r7, r7, r4
 8016860:	f105 33ff 	add.w	r3, r5, #4294967295
 8016864:	d361      	bcc.n	801692a <__udivdi3+0x26a>
 8016866:	461d      	mov	r5, r3
 8016868:	ea45 4c0c 	orr.w	ip, r5, ip, lsl #16
 801686c:	fbac 230b 	umull	r2, r3, ip, fp
 8016870:	ebc8 0707 	rsb	r7, r8, r7
 8016874:	429f      	cmp	r7, r3
 8016876:	f04f 0500 	mov.w	r5, #0
 801687a:	d349      	bcc.n	8016910 <__udivdi3+0x250>
 801687c:	d045      	beq.n	801690a <__udivdi3+0x24a>
 801687e:	4662      	mov	r2, ip
 8016880:	462b      	mov	r3, r5
 8016882:	e763      	b.n	801674c <__udivdi3+0x8c>
 8016884:	4094      	lsls	r4, r2
 8016886:	f1c2 0320 	rsb	r3, r2, #32
 801688a:	fa21 fc03 	lsr.w	ip, r1, r3
 801688e:	0c26      	lsrs	r6, r4, #16
 8016890:	fa20 f303 	lsr.w	r3, r0, r3
 8016894:	fa01 f502 	lsl.w	r5, r1, r2
 8016898:	fbbc f8f6 	udiv	r8, ip, r6
 801689c:	ea43 0105 	orr.w	r1, r3, r5
 80168a0:	0c0b      	lsrs	r3, r1, #16
 80168a2:	fb06 cc18 	mls	ip, r6, r8, ip
 80168a6:	b2a7      	uxth	r7, r4
 80168a8:	ea43 4c0c 	orr.w	ip, r3, ip, lsl #16
 80168ac:	fb07 f308 	mul.w	r3, r7, r8
 80168b0:	4563      	cmp	r3, ip
 80168b2:	fa00 f502 	lsl.w	r5, r0, r2
 80168b6:	d909      	bls.n	80168cc <__udivdi3+0x20c>
 80168b8:	eb1c 0c04 	adds.w	ip, ip, r4
 80168bc:	f108 32ff 	add.w	r2, r8, #4294967295
 80168c0:	d23a      	bcs.n	8016938 <__udivdi3+0x278>
 80168c2:	4563      	cmp	r3, ip
 80168c4:	d938      	bls.n	8016938 <__udivdi3+0x278>
 80168c6:	f1a8 0802 	sub.w	r8, r8, #2
 80168ca:	44a4      	add	ip, r4
 80168cc:	ebc3 0c0c 	rsb	ip, r3, ip
 80168d0:	fbbc f3f6 	udiv	r3, ip, r6
 80168d4:	b289      	uxth	r1, r1
 80168d6:	fb06 cc13 	mls	ip, r6, r3, ip
 80168da:	ea41 410c 	orr.w	r1, r1, ip, lsl #16
 80168de:	fb07 f203 	mul.w	r2, r7, r3
 80168e2:	428a      	cmp	r2, r1
 80168e4:	d907      	bls.n	80168f6 <__udivdi3+0x236>
 80168e6:	1909      	adds	r1, r1, r4
 80168e8:	f103 30ff 	add.w	r0, r3, #4294967295
 80168ec:	d222      	bcs.n	8016934 <__udivdi3+0x274>
 80168ee:	428a      	cmp	r2, r1
 80168f0:	d920      	bls.n	8016934 <__udivdi3+0x274>
 80168f2:	3b02      	subs	r3, #2
 80168f4:	4421      	add	r1, r4
 80168f6:	1a89      	subs	r1, r1, r2
 80168f8:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 80168fc:	e749      	b.n	8016792 <__udivdi3+0xd2>
 80168fe:	463a      	mov	r2, r7
 8016900:	e70c      	b.n	801671c <__udivdi3+0x5c>
 8016902:	4633      	mov	r3, r6
 8016904:	e71f      	b.n	8016746 <__udivdi3+0x86>
 8016906:	460a      	mov	r2, r1
 8016908:	e76b      	b.n	80167e2 <__udivdi3+0x122>
 801690a:	40b0      	lsls	r0, r6
 801690c:	4290      	cmp	r0, r2
 801690e:	d2b6      	bcs.n	801687e <__udivdi3+0x1be>
 8016910:	f10c 32ff 	add.w	r2, ip, #4294967295
 8016914:	2300      	movs	r3, #0
 8016916:	e719      	b.n	801674c <__udivdi3+0x8c>
 8016918:	4633      	mov	r3, r6
 801691a:	4632      	mov	r2, r6
 801691c:	e716      	b.n	801674c <__udivdi3+0x8c>
 801691e:	4599      	cmp	r9, r3
 8016920:	d98f      	bls.n	8016842 <__udivdi3+0x182>
 8016922:	f1ac 0c02 	sub.w	ip, ip, #2
 8016926:	4423      	add	r3, r4
 8016928:	e78c      	b.n	8016844 <__udivdi3+0x184>
 801692a:	45b8      	cmp	r8, r7
 801692c:	d99b      	bls.n	8016866 <__udivdi3+0x1a6>
 801692e:	3d02      	subs	r5, #2
 8016930:	4427      	add	r7, r4
 8016932:	e799      	b.n	8016868 <__udivdi3+0x1a8>
 8016934:	4603      	mov	r3, r0
 8016936:	e7de      	b.n	80168f6 <__udivdi3+0x236>
 8016938:	4690      	mov	r8, r2
 801693a:	e7c7      	b.n	80168cc <__udivdi3+0x20c>
 801693c:	3802      	subs	r0, #2
 801693e:	4421      	add	r1, r4
 8016940:	e73a      	b.n	80167b8 <__udivdi3+0xf8>
 8016942:	bf00      	nop
	...

08016950 <memcpy>:
 8016950:	4684      	mov	ip, r0
 8016952:	ea41 0300 	orr.w	r3, r1, r0
 8016956:	f013 0303 	ands.w	r3, r3, #3
 801695a:	d16d      	bne.n	8016a38 <memcpy+0xe8>
 801695c:	3a40      	subs	r2, #64	; 0x40
 801695e:	d341      	bcc.n	80169e4 <memcpy+0x94>
 8016960:	f851 3b04 	ldr.w	r3, [r1], #4
 8016964:	f840 3b04 	str.w	r3, [r0], #4
 8016968:	f851 3b04 	ldr.w	r3, [r1], #4
 801696c:	f840 3b04 	str.w	r3, [r0], #4
 8016970:	f851 3b04 	ldr.w	r3, [r1], #4
 8016974:	f840 3b04 	str.w	r3, [r0], #4
 8016978:	f851 3b04 	ldr.w	r3, [r1], #4
 801697c:	f840 3b04 	str.w	r3, [r0], #4
 8016980:	f851 3b04 	ldr.w	r3, [r1], #4
 8016984:	f840 3b04 	str.w	r3, [r0], #4
 8016988:	f851 3b04 	ldr.w	r3, [r1], #4
 801698c:	f840 3b04 	str.w	r3, [r0], #4
 8016990:	f851 3b04 	ldr.w	r3, [r1], #4
 8016994:	f840 3b04 	str.w	r3, [r0], #4
 8016998:	f851 3b04 	ldr.w	r3, [r1], #4
 801699c:	f840 3b04 	str.w	r3, [r0], #4
 80169a0:	f851 3b04 	ldr.w	r3, [r1], #4
 80169a4:	f840 3b04 	str.w	r3, [r0], #4
 80169a8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169ac:	f840 3b04 	str.w	r3, [r0], #4
 80169b0:	f851 3b04 	ldr.w	r3, [r1], #4
 80169b4:	f840 3b04 	str.w	r3, [r0], #4
 80169b8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169bc:	f840 3b04 	str.w	r3, [r0], #4
 80169c0:	f851 3b04 	ldr.w	r3, [r1], #4
 80169c4:	f840 3b04 	str.w	r3, [r0], #4
 80169c8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169cc:	f840 3b04 	str.w	r3, [r0], #4
 80169d0:	f851 3b04 	ldr.w	r3, [r1], #4
 80169d4:	f840 3b04 	str.w	r3, [r0], #4
 80169d8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169dc:	f840 3b04 	str.w	r3, [r0], #4
 80169e0:	3a40      	subs	r2, #64	; 0x40
 80169e2:	d2bd      	bcs.n	8016960 <memcpy+0x10>
 80169e4:	3230      	adds	r2, #48	; 0x30
 80169e6:	d311      	bcc.n	8016a0c <memcpy+0xbc>
 80169e8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169ec:	f840 3b04 	str.w	r3, [r0], #4
 80169f0:	f851 3b04 	ldr.w	r3, [r1], #4
 80169f4:	f840 3b04 	str.w	r3, [r0], #4
 80169f8:	f851 3b04 	ldr.w	r3, [r1], #4
 80169fc:	f840 3b04 	str.w	r3, [r0], #4
 8016a00:	f851 3b04 	ldr.w	r3, [r1], #4
 8016a04:	f840 3b04 	str.w	r3, [r0], #4
 8016a08:	3a10      	subs	r2, #16
 8016a0a:	d2ed      	bcs.n	80169e8 <memcpy+0x98>
 8016a0c:	320c      	adds	r2, #12
 8016a0e:	d305      	bcc.n	8016a1c <memcpy+0xcc>
 8016a10:	f851 3b04 	ldr.w	r3, [r1], #4
 8016a14:	f840 3b04 	str.w	r3, [r0], #4
 8016a18:	3a04      	subs	r2, #4
 8016a1a:	d2f9      	bcs.n	8016a10 <memcpy+0xc0>
 8016a1c:	3204      	adds	r2, #4
 8016a1e:	d008      	beq.n	8016a32 <memcpy+0xe2>
 8016a20:	07d2      	lsls	r2, r2, #31
 8016a22:	bf1c      	itt	ne
 8016a24:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8016a28:	f800 3b01 	strbne.w	r3, [r0], #1
 8016a2c:	d301      	bcc.n	8016a32 <memcpy+0xe2>
 8016a2e:	880b      	ldrh	r3, [r1, #0]
 8016a30:	8003      	strh	r3, [r0, #0]
 8016a32:	4660      	mov	r0, ip
 8016a34:	4770      	bx	lr
 8016a36:	bf00      	nop
 8016a38:	2a08      	cmp	r2, #8
 8016a3a:	d313      	bcc.n	8016a64 <memcpy+0x114>
 8016a3c:	078b      	lsls	r3, r1, #30
 8016a3e:	d08d      	beq.n	801695c <memcpy+0xc>
 8016a40:	f010 0303 	ands.w	r3, r0, #3
 8016a44:	d08a      	beq.n	801695c <memcpy+0xc>
 8016a46:	f1c3 0304 	rsb	r3, r3, #4
 8016a4a:	1ad2      	subs	r2, r2, r3
 8016a4c:	07db      	lsls	r3, r3, #31
 8016a4e:	bf1c      	itt	ne
 8016a50:	f811 3b01 	ldrbne.w	r3, [r1], #1
 8016a54:	f800 3b01 	strbne.w	r3, [r0], #1
 8016a58:	d380      	bcc.n	801695c <memcpy+0xc>
 8016a5a:	f831 3b02 	ldrh.w	r3, [r1], #2
 8016a5e:	f820 3b02 	strh.w	r3, [r0], #2
 8016a62:	e77b      	b.n	801695c <memcpy+0xc>
 8016a64:	3a04      	subs	r2, #4
 8016a66:	d3d9      	bcc.n	8016a1c <memcpy+0xcc>
 8016a68:	3a01      	subs	r2, #1
 8016a6a:	f811 3b01 	ldrb.w	r3, [r1], #1
 8016a6e:	f800 3b01 	strb.w	r3, [r0], #1
 8016a72:	d2f9      	bcs.n	8016a68 <memcpy+0x118>
 8016a74:	780b      	ldrb	r3, [r1, #0]
 8016a76:	7003      	strb	r3, [r0, #0]
 8016a78:	784b      	ldrb	r3, [r1, #1]
 8016a7a:	7043      	strb	r3, [r0, #1]
 8016a7c:	788b      	ldrb	r3, [r1, #2]
 8016a7e:	7083      	strb	r3, [r0, #2]
 8016a80:	4660      	mov	r0, ip
 8016a82:	4770      	bx	lr
	...

08016a90 <strcmp>:
 8016a90:	ea40 0c01 	orr.w	ip, r0, r1
 8016a94:	f01c 0f07 	tst.w	ip, #7
 8016a98:	d123      	bne.n	8016ae2 <strcmp+0x52>
 8016a9a:	f1bd 0d10 	subs.w	sp, sp, #16
 8016a9e:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8016aa2:	e9cd 6700 	strd	r6, r7, [sp]
 8016aa6:	f06f 0600 	mvn.w	r6, #0
 8016aaa:	f04f 0700 	mov.w	r7, #0
 8016aae:	bf00      	nop
 8016ab0:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8016ab4:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8016ab8:	42a2      	cmp	r2, r4
 8016aba:	fa82 fc46 	uadd8	ip, r2, r6
 8016abe:	faa7 fc86 	sel	ip, r7, r6
 8016ac2:	bf08      	it	eq
 8016ac4:	f1bc 0f00 	cmpeq.w	ip, #0
 8016ac8:	f040 80d7 	bne.w	8016c7a <strcmp+0x1ea>
 8016acc:	42ab      	cmp	r3, r5
 8016ace:	fa83 fc46 	uadd8	ip, r3, r6
 8016ad2:	faa7 fc86 	sel	ip, r7, r6
 8016ad6:	bf08      	it	eq
 8016ad8:	f1bc 0f00 	cmpeq.w	ip, #0
 8016adc:	f040 80ca 	bne.w	8016c74 <strcmp+0x1e4>
 8016ae0:	e7e6      	b.n	8016ab0 <strcmp+0x20>
 8016ae2:	f010 0c03 	ands.w	ip, r0, #3
 8016ae6:	d021      	beq.n	8016b2c <strcmp+0x9c>
 8016ae8:	f020 0003 	bic.w	r0, r0, #3
 8016aec:	f850 2b04 	ldr.w	r2, [r0], #4
 8016af0:	ea5f 7ccc 	movs.w	ip, ip, lsl #31
 8016af4:	d008      	beq.n	8016b08 <strcmp+0x78>
 8016af6:	d20f      	bcs.n	8016b18 <strcmp+0x88>
 8016af8:	f811 cb01 	ldrb.w	ip, [r1], #1
 8016afc:	fa5f f392 	uxtb.w	r3, r2, ror #8
 8016b00:	ebb3 0c0c 	subs.w	ip, r3, ip
 8016b04:	d110      	bne.n	8016b28 <strcmp+0x98>
 8016b06:	b17b      	cbz	r3, 8016b28 <strcmp+0x98>
 8016b08:	f811 cb01 	ldrb.w	ip, [r1], #1
 8016b0c:	fa5f f3a2 	uxtb.w	r3, r2, ror #16
 8016b10:	ebb3 0c0c 	subs.w	ip, r3, ip
 8016b14:	d108      	bne.n	8016b28 <strcmp+0x98>
 8016b16:	b13b      	cbz	r3, 8016b28 <strcmp+0x98>
 8016b18:	f811 cb01 	ldrb.w	ip, [r1], #1
 8016b1c:	fa5f f3b2 	uxtb.w	r3, r2, ror #24
 8016b20:	ebb3 0c0c 	subs.w	ip, r3, ip
 8016b24:	d100      	bne.n	8016b28 <strcmp+0x98>
 8016b26:	b90b      	cbnz	r3, 8016b2c <strcmp+0x9c>
 8016b28:	4660      	mov	r0, ip
 8016b2a:	4770      	bx	lr
 8016b2c:	f1bd 0d10 	subs.w	sp, sp, #16
 8016b30:	e9cd 4502 	strd	r4, r5, [sp, #8]
 8016b34:	e9cd 6700 	strd	r6, r7, [sp]
 8016b38:	f06f 0600 	mvn.w	r6, #0
 8016b3c:	f04f 0700 	mov.w	r7, #0
 8016b40:	f011 0c03 	ands.w	ip, r1, #3
 8016b44:	d12d      	bne.n	8016ba2 <strcmp+0x112>
 8016b46:	f010 0f04 	tst.w	r0, #4
 8016b4a:	d00d      	beq.n	8016b68 <strcmp+0xd8>
 8016b4c:	f850 2b04 	ldr.w	r2, [r0], #4
 8016b50:	f851 4b04 	ldr.w	r4, [r1], #4
 8016b54:	42a2      	cmp	r2, r4
 8016b56:	fa82 fc46 	uadd8	ip, r2, r6
 8016b5a:	faa7 fc86 	sel	ip, r7, r6
 8016b5e:	bf08      	it	eq
 8016b60:	f1bc 0f00 	cmpeq.w	ip, #0
 8016b64:	f040 8089 	bne.w	8016c7a <strcmp+0x1ea>
 8016b68:	f011 0f04 	tst.w	r1, #4
 8016b6c:	d09f      	beq.n	8016aae <strcmp+0x1e>
 8016b6e:	f851 5b04 	ldr.w	r5, [r1], #4
 8016b72:	bf00      	nop
 8016b74:	e8f0 2302 	ldrd	r2, r3, [r0], #8
 8016b78:	42aa      	cmp	r2, r5
 8016b7a:	fa82 fc46 	uadd8	ip, r2, r6
 8016b7e:	faa7 fc86 	sel	ip, r7, r6
 8016b82:	bf08      	it	eq
 8016b84:	f1bc 0f00 	cmpeq.w	ip, #0
 8016b88:	d171      	bne.n	8016c6e <strcmp+0x1de>
 8016b8a:	e8f1 4502 	ldrd	r4, r5, [r1], #8
 8016b8e:	42a3      	cmp	r3, r4
 8016b90:	fa83 fc46 	uadd8	ip, r3, r6
 8016b94:	faa7 fc86 	sel	ip, r7, r6
 8016b98:	bf08      	it	eq
 8016b9a:	f1bc 0f00 	cmpeq.w	ip, #0
 8016b9e:	d163      	bne.n	8016c68 <strcmp+0x1d8>
 8016ba0:	e7e8      	b.n	8016b74 <strcmp+0xe4>
 8016ba2:	f021 0103 	bic.w	r1, r1, #3
 8016ba6:	f1bc 0f02 	cmp.w	ip, #2
 8016baa:	d01e      	beq.n	8016bea <strcmp+0x15a>
 8016bac:	da3b      	bge.n	8016c26 <strcmp+0x196>
 8016bae:	f851 5b04 	ldr.w	r5, [r1], #4
 8016bb2:	bf00      	nop
 8016bb4:	f850 3b04 	ldr.w	r3, [r0], #4
 8016bb8:	ea4f 2515 	mov.w	r5, r5, lsr #8
 8016bbc:	fa83 fc46 	uadd8	ip, r3, r6
 8016bc0:	faa7 fc86 	sel	ip, r7, r6
 8016bc4:	ebb7 2f0c 	cmp.w	r7, ip, lsl #8
 8016bc8:	ea03 2216 	and.w	r2, r3, r6, lsr #8
 8016bcc:	bf08      	it	eq
 8016bce:	42aa      	cmpeq	r2, r5
 8016bd0:	d14d      	bne.n	8016c6e <strcmp+0x1de>
 8016bd2:	f851 5b04 	ldr.w	r5, [r1], #4
 8016bd6:	f1bc 0f00 	cmp.w	ip, #0
 8016bda:	ea82 0303 	eor.w	r3, r2, r3
 8016bde:	ea4f 6205 	mov.w	r2, r5, lsl #24
 8016be2:	bf08      	it	eq
 8016be4:	4293      	cmpeq	r3, r2
 8016be6:	d13c      	bne.n	8016c62 <strcmp+0x1d2>
 8016be8:	e7e4      	b.n	8016bb4 <strcmp+0x124>
 8016bea:	f851 5b04 	ldr.w	r5, [r1], #4
 8016bee:	bf00      	nop
 8016bf0:	f850 3b04 	ldr.w	r3, [r0], #4
 8016bf4:	ea4f 4515 	mov.w	r5, r5, lsr #16
 8016bf8:	fa83 fc46 	uadd8	ip, r3, r6
 8016bfc:	faa7 fc86 	sel	ip, r7, r6
 8016c00:	ebb7 4f0c 	cmp.w	r7, ip, lsl #16
 8016c04:	ea03 4216 	and.w	r2, r3, r6, lsr #16
 8016c08:	bf08      	it	eq
 8016c0a:	42aa      	cmpeq	r2, r5
 8016c0c:	d12f      	bne.n	8016c6e <strcmp+0x1de>
 8016c0e:	f851 5b04 	ldr.w	r5, [r1], #4
 8016c12:	f1bc 0f00 	cmp.w	ip, #0
 8016c16:	ea82 0303 	eor.w	r3, r2, r3
 8016c1a:	ea4f 4205 	mov.w	r2, r5, lsl #16
 8016c1e:	bf08      	it	eq
 8016c20:	4293      	cmpeq	r3, r2
 8016c22:	d11e      	bne.n	8016c62 <strcmp+0x1d2>
 8016c24:	e7e4      	b.n	8016bf0 <strcmp+0x160>
 8016c26:	f851 5b04 	ldr.w	r5, [r1], #4
 8016c2a:	bf00      	nop
 8016c2c:	f850 3b04 	ldr.w	r3, [r0], #4
 8016c30:	ea4f 6515 	mov.w	r5, r5, lsr #24
 8016c34:	fa83 fc46 	uadd8	ip, r3, r6
 8016c38:	faa7 fc86 	sel	ip, r7, r6
 8016c3c:	ebb7 6f0c 	cmp.w	r7, ip, lsl #24
 8016c40:	ea03 6216 	and.w	r2, r3, r6, lsr #24
 8016c44:	bf08      	it	eq
 8016c46:	42aa      	cmpeq	r2, r5
 8016c48:	d111      	bne.n	8016c6e <strcmp+0x1de>
 8016c4a:	f851 5b04 	ldr.w	r5, [r1], #4
 8016c4e:	f1bc 0f00 	cmp.w	ip, #0
 8016c52:	ea82 0303 	eor.w	r3, r2, r3
 8016c56:	ea4f 2205 	mov.w	r2, r5, lsl #8
 8016c5a:	bf08      	it	eq
 8016c5c:	4293      	cmpeq	r3, r2
 8016c5e:	d100      	bne.n	8016c62 <strcmp+0x1d2>
 8016c60:	e7e4      	b.n	8016c2c <strcmp+0x19c>
 8016c62:	ba19      	rev	r1, r3
 8016c64:	ba12      	rev	r2, r2
 8016c66:	e00a      	b.n	8016c7e <strcmp+0x1ee>
 8016c68:	ba19      	rev	r1, r3
 8016c6a:	ba22      	rev	r2, r4
 8016c6c:	e007      	b.n	8016c7e <strcmp+0x1ee>
 8016c6e:	ba11      	rev	r1, r2
 8016c70:	ba2a      	rev	r2, r5
 8016c72:	e004      	b.n	8016c7e <strcmp+0x1ee>
 8016c74:	ba19      	rev	r1, r3
 8016c76:	ba2a      	rev	r2, r5
 8016c78:	e001      	b.n	8016c7e <strcmp+0x1ee>
 8016c7a:	ba11      	rev	r1, r2
 8016c7c:	ba22      	rev	r2, r4
 8016c7e:	fa9c f08c 	rev.w	r0, ip
 8016c82:	e9dd 6700 	ldrd	r6, r7, [sp]
 8016c86:	e9dd 4502 	ldrd	r4, r5, [sp, #8]
 8016c8a:	f11d 0d10 	adds.w	sp, sp, #16
 8016c8e:	b138      	cbz	r0, 8016ca0 <strcmp+0x210>
 8016c90:	fab0 f080 	clz	r0, r0
 8016c94:	f1c0 0018 	rsb	r0, r0, #24
 8016c98:	fa21 f100 	lsr.w	r1, r1, r0
 8016c9c:	fa22 f200 	lsr.w	r2, r2, r0
 8016ca0:	2001      	movs	r0, #1
 8016ca2:	4291      	cmp	r1, r2
 8016ca4:	bf98      	it	ls
 8016ca6:	4180      	sbcls	r0, r0
 8016ca8:	4770      	bx	lr
 8016caa:	bf00      	nop
 8016cac:	0000      	movs	r0, r0
	...

08016cb0 <__aeabi_uldivmod>:
 8016cb0:	b94b      	cbnz	r3, 8016cc6 <__aeabi_uldivmod+0x16>
 8016cb2:	b942      	cbnz	r2, 8016cc6 <__aeabi_uldivmod+0x16>
 8016cb4:	2900      	cmp	r1, #0
 8016cb6:	bf08      	it	eq
 8016cb8:	2800      	cmpeq	r0, #0
 8016cba:	d002      	beq.n	8016cc2 <__aeabi_uldivmod+0x12>
 8016cbc:	f04f 31ff 	mov.w	r1, #4294967295
 8016cc0:	4608      	mov	r0, r1
 8016cc2:	f7ff bba5 	b.w	8016410 <__aeabi_idiv0>
 8016cc6:	b082      	sub	sp, #8
 8016cc8:	46ec      	mov	ip, sp
 8016cca:	e92d 5000 	stmdb	sp!, {ip, lr}
 8016cce:	f7ff fb87 	bl	80163e0 <__gnu_uldivmod_helper>
 8016cd2:	f8dd e004 	ldr.w	lr, [sp, #4]
 8016cd6:	b002      	add	sp, #8
 8016cd8:	bc0c      	pop	{r2, r3}
 8016cda:	4770      	bx	lr
 8016cdc:	0000      	movs	r0, r0
	...

08016ce0 <ctime_r>:
 8016ce0:	b510      	push	{r4, lr}
 8016ce2:	b08a      	sub	sp, #40	; 0x28
 8016ce4:	460c      	mov	r4, r1
 8016ce6:	a901      	add	r1, sp, #4
 8016ce8:	f000 f80a 	bl	8016d00 <localtime_r>
 8016cec:	4621      	mov	r1, r4
 8016cee:	f000 fdff 	bl	80178f0 <asctime_r>
 8016cf2:	b00a      	add	sp, #40	; 0x28
 8016cf4:	bd10      	pop	{r4, pc}
 8016cf6:	bf00      	nop
	...

08016d00 <localtime_r>:
 8016d00:	2200      	movs	r2, #0
 8016d02:	f000 bbed 	b.w	80174e0 <_mktm_r>
 8016d06:	bf00      	nop
	...

08016d10 <memset>:
 8016d10:	b4f0      	push	{r4, r5, r6, r7}
 8016d12:	0784      	lsls	r4, r0, #30
 8016d14:	d043      	beq.n	8016d9e <memset+0x8e>
 8016d16:	1e54      	subs	r4, r2, #1
 8016d18:	2a00      	cmp	r2, #0
 8016d1a:	d03e      	beq.n	8016d9a <memset+0x8a>
 8016d1c:	b2cd      	uxtb	r5, r1
 8016d1e:	4603      	mov	r3, r0
 8016d20:	e003      	b.n	8016d2a <memset+0x1a>
 8016d22:	1e62      	subs	r2, r4, #1
 8016d24:	2c00      	cmp	r4, #0
 8016d26:	d038      	beq.n	8016d9a <memset+0x8a>
 8016d28:	4614      	mov	r4, r2
 8016d2a:	f803 5b01 	strb.w	r5, [r3], #1
 8016d2e:	079a      	lsls	r2, r3, #30
 8016d30:	d1f7      	bne.n	8016d22 <memset+0x12>
 8016d32:	2c03      	cmp	r4, #3
 8016d34:	d92a      	bls.n	8016d8c <memset+0x7c>
 8016d36:	b2cd      	uxtb	r5, r1
 8016d38:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8016d3c:	2c0f      	cmp	r4, #15
 8016d3e:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8016d42:	d915      	bls.n	8016d70 <memset+0x60>
 8016d44:	f1a4 0710 	sub.w	r7, r4, #16
 8016d48:	093f      	lsrs	r7, r7, #4
 8016d4a:	f103 0610 	add.w	r6, r3, #16
 8016d4e:	eb06 1607 	add.w	r6, r6, r7, lsl #4
 8016d52:	461a      	mov	r2, r3
 8016d54:	6015      	str	r5, [r2, #0]
 8016d56:	6055      	str	r5, [r2, #4]
 8016d58:	6095      	str	r5, [r2, #8]
 8016d5a:	60d5      	str	r5, [r2, #12]
 8016d5c:	3210      	adds	r2, #16
 8016d5e:	42b2      	cmp	r2, r6
 8016d60:	d1f8      	bne.n	8016d54 <memset+0x44>
 8016d62:	f004 040f 	and.w	r4, r4, #15
 8016d66:	3701      	adds	r7, #1
 8016d68:	2c03      	cmp	r4, #3
 8016d6a:	eb03 1307 	add.w	r3, r3, r7, lsl #4
 8016d6e:	d90d      	bls.n	8016d8c <memset+0x7c>
 8016d70:	461e      	mov	r6, r3
 8016d72:	4622      	mov	r2, r4
 8016d74:	3a04      	subs	r2, #4
 8016d76:	2a03      	cmp	r2, #3
 8016d78:	f846 5b04 	str.w	r5, [r6], #4
 8016d7c:	d8fa      	bhi.n	8016d74 <memset+0x64>
 8016d7e:	1f22      	subs	r2, r4, #4
 8016d80:	f022 0203 	bic.w	r2, r2, #3
 8016d84:	3204      	adds	r2, #4
 8016d86:	4413      	add	r3, r2
 8016d88:	f004 0403 	and.w	r4, r4, #3
 8016d8c:	b12c      	cbz	r4, 8016d9a <memset+0x8a>
 8016d8e:	b2c9      	uxtb	r1, r1
 8016d90:	441c      	add	r4, r3
 8016d92:	f803 1b01 	strb.w	r1, [r3], #1
 8016d96:	42a3      	cmp	r3, r4
 8016d98:	d1fb      	bne.n	8016d92 <memset+0x82>
 8016d9a:	bcf0      	pop	{r4, r5, r6, r7}
 8016d9c:	4770      	bx	lr
 8016d9e:	4614      	mov	r4, r2
 8016da0:	4603      	mov	r3, r0
 8016da2:	e7c6      	b.n	8016d32 <memset+0x22>
	...

08016db0 <validate_structure>:
 8016db0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8016db4:	6801      	ldr	r1, [r0, #0]
 8016db6:	293b      	cmp	r1, #59	; 0x3b
 8016db8:	b082      	sub	sp, #8
 8016dba:	4604      	mov	r4, r0
 8016dbc:	f200 80c1 	bhi.w	8016f42 <validate_structure+0x192>
 8016dc0:	6841      	ldr	r1, [r0, #4]
 8016dc2:	293b      	cmp	r1, #59	; 0x3b
 8016dc4:	f200 8090 	bhi.w	8016ee8 <validate_structure+0x138>
 8016dc8:	68a1      	ldr	r1, [r4, #8]
 8016dca:	2917      	cmp	r1, #23
 8016dcc:	f200 809b 	bhi.w	8016f06 <validate_structure+0x156>
 8016dd0:	6925      	ldr	r5, [r4, #16]
 8016dd2:	2d0b      	cmp	r5, #11
 8016dd4:	f200 80a7 	bhi.w	8016f26 <validate_structure+0x176>
 8016dd8:	6963      	ldr	r3, [r4, #20]
 8016dda:	079f      	lsls	r7, r3, #30
 8016ddc:	d135      	bne.n	8016e4a <validate_structure+0x9a>
 8016dde:	4a7a      	ldr	r2, [pc, #488]	; (8016fc8 <validate_structure+0x218>)
 8016de0:	17d9      	asrs	r1, r3, #31
 8016de2:	fb82 6003 	smull	r6, r0, r2, r3
 8016de6:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 8016dea:	2064      	movs	r0, #100	; 0x64
 8016dec:	fb00 3111 	mls	r1, r0, r1, r3
 8016df0:	2900      	cmp	r1, #0
 8016df2:	d069      	beq.n	8016ec8 <validate_structure+0x118>
 8016df4:	68e2      	ldr	r2, [r4, #12]
 8016df6:	4f75      	ldr	r7, [pc, #468]	; (8016fcc <validate_structure+0x21c>)
 8016df8:	2a00      	cmp	r2, #0
 8016dfa:	f04f 061d 	mov.w	r6, #29
 8016dfe:	dc29      	bgt.n	8016e54 <validate_structure+0xa4>
 8016e00:	4629      	mov	r1, r5
 8016e02:	f8df c1c4 	ldr.w	ip, [pc, #452]	; 8016fc8 <validate_structure+0x218>
 8016e06:	2564      	movs	r5, #100	; 0x64
 8016e08:	f44f 78c8 	mov.w	r8, #400	; 0x190
 8016e0c:	e008      	b.n	8016e20 <validate_structure+0x70>
 8016e0e:	2b01      	cmp	r3, #1
 8016e10:	f000 80a4 	beq.w	8016f5c <validate_structure+0x1ac>
 8016e14:	f857 0023 	ldr.w	r0, [r7, r3, lsl #2]
 8016e18:	4619      	mov	r1, r3
 8016e1a:	4402      	add	r2, r0
 8016e1c:	2a00      	cmp	r2, #0
 8016e1e:	dc39      	bgt.n	8016e94 <validate_structure+0xe4>
 8016e20:	1e4b      	subs	r3, r1, #1
 8016e22:	2900      	cmp	r1, #0
 8016e24:	d1f3      	bne.n	8016e0e <validate_structure+0x5e>
 8016e26:	6961      	ldr	r1, [r4, #20]
 8016e28:	1e4b      	subs	r3, r1, #1
 8016e2a:	079e      	lsls	r6, r3, #30
 8016e2c:	6163      	str	r3, [r4, #20]
 8016e2e:	f040 8098 	bne.w	8016f62 <validate_structure+0x1b2>
 8016e32:	fb8c 0603 	smull	r0, r6, ip, r3
 8016e36:	17d8      	asrs	r0, r3, #31
 8016e38:	ebc0 1066 	rsb	r0, r0, r6, asr #5
 8016e3c:	fb05 3310 	mls	r3, r5, r0, r3
 8016e40:	2b00      	cmp	r3, #0
 8016e42:	f000 8091 	beq.w	8016f68 <validate_structure+0x1b8>
 8016e46:	261d      	movs	r6, #29
 8016e48:	e08c      	b.n	8016f64 <validate_structure+0x1b4>
 8016e4a:	261c      	movs	r6, #28
 8016e4c:	68e2      	ldr	r2, [r4, #12]
 8016e4e:	4f5f      	ldr	r7, [pc, #380]	; (8016fcc <validate_structure+0x21c>)
 8016e50:	2a00      	cmp	r2, #0
 8016e52:	ddd5      	ble.n	8016e00 <validate_structure+0x50>
 8016e54:	f8df 8170 	ldr.w	r8, [pc, #368]	; 8016fc8 <validate_structure+0x218>
 8016e58:	f04f 0c00 	mov.w	ip, #0
 8016e5c:	f04f 0964 	mov.w	r9, #100	; 0x64
 8016e60:	f44f 7ac8 	mov.w	sl, #400	; 0x190
 8016e64:	1c6b      	adds	r3, r5, #1
 8016e66:	2100      	movs	r1, #0
 8016e68:	eb07 0585 	add.w	r5, r7, r5, lsl #2
 8016e6c:	e00a      	b.n	8016e84 <validate_structure+0xd4>
 8016e6e:	5868      	ldr	r0, [r5, r1]
 8016e70:	4290      	cmp	r0, r2
 8016e72:	ebc0 0202 	rsb	r2, r0, r2
 8016e76:	da0f      	bge.n	8016e98 <validate_structure+0xe8>
 8016e78:	2b0c      	cmp	r3, #12
 8016e7a:	60e2      	str	r2, [r4, #12]
 8016e7c:	6123      	str	r3, [r4, #16]
 8016e7e:	d00e      	beq.n	8016e9e <validate_structure+0xee>
 8016e80:	3301      	adds	r3, #1
 8016e82:	3104      	adds	r1, #4
 8016e84:	2b02      	cmp	r3, #2
 8016e86:	d1f2      	bne.n	8016e6e <validate_structure+0xbe>
 8016e88:	4296      	cmp	r6, r2
 8016e8a:	da05      	bge.n	8016e98 <validate_structure+0xe8>
 8016e8c:	1b92      	subs	r2, r2, r6
 8016e8e:	60e2      	str	r2, [r4, #12]
 8016e90:	6123      	str	r3, [r4, #16]
 8016e92:	e7f5      	b.n	8016e80 <validate_structure+0xd0>
 8016e94:	6123      	str	r3, [r4, #16]
 8016e96:	60e2      	str	r2, [r4, #12]
 8016e98:	b002      	add	sp, #8
 8016e9a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8016e9e:	6961      	ldr	r1, [r4, #20]
 8016ea0:	f8c4 c010 	str.w	ip, [r4, #16]
 8016ea4:	1c4b      	adds	r3, r1, #1
 8016ea6:	0798      	lsls	r0, r3, #30
 8016ea8:	6163      	str	r3, [r4, #20]
 8016eaa:	d002      	beq.n	8016eb2 <validate_structure+0x102>
 8016eac:	261c      	movs	r6, #28
 8016eae:	2500      	movs	r5, #0
 8016eb0:	e7d8      	b.n	8016e64 <validate_structure+0xb4>
 8016eb2:	fb88 6503 	smull	r6, r5, r8, r3
 8016eb6:	17d8      	asrs	r0, r3, #31
 8016eb8:	ebc0 1065 	rsb	r0, r0, r5, asr #5
 8016ebc:	fb09 3310 	mls	r3, r9, r0, r3
 8016ec0:	2b00      	cmp	r3, #0
 8016ec2:	d05f      	beq.n	8016f84 <validate_structure+0x1d4>
 8016ec4:	261d      	movs	r6, #29
 8016ec6:	e7f2      	b.n	8016eae <validate_structure+0xfe>
 8016ec8:	f203 736c 	addw	r3, r3, #1900	; 0x76c
 8016ecc:	17d9      	asrs	r1, r3, #31
 8016ece:	fb82 0203 	smull	r0, r2, r2, r3
 8016ed2:	ebc1 12e2 	rsb	r2, r1, r2, asr #7
 8016ed6:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8016eda:	fb01 3312 	mls	r3, r1, r2, r3
 8016ede:	2b00      	cmp	r3, #0
 8016ee0:	bf0c      	ite	eq
 8016ee2:	261d      	moveq	r6, #29
 8016ee4:	261c      	movne	r6, #28
 8016ee6:	e7b1      	b.n	8016e4c <validate_structure+0x9c>
 8016ee8:	223c      	movs	r2, #60	; 0x3c
 8016eea:	4668      	mov	r0, sp
 8016eec:	f000 fd28 	bl	8017940 <div>
 8016ef0:	68a2      	ldr	r2, [r4, #8]
 8016ef2:	9900      	ldr	r1, [sp, #0]
 8016ef4:	9b01      	ldr	r3, [sp, #4]
 8016ef6:	4411      	add	r1, r2
 8016ef8:	2b00      	cmp	r3, #0
 8016efa:	60a1      	str	r1, [r4, #8]
 8016efc:	db5f      	blt.n	8016fbe <validate_structure+0x20e>
 8016efe:	2917      	cmp	r1, #23
 8016f00:	6063      	str	r3, [r4, #4]
 8016f02:	f67f af65 	bls.w	8016dd0 <validate_structure+0x20>
 8016f06:	2218      	movs	r2, #24
 8016f08:	4668      	mov	r0, sp
 8016f0a:	f000 fd19 	bl	8017940 <div>
 8016f0e:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8016f12:	68e1      	ldr	r1, [r4, #12]
 8016f14:	2b00      	cmp	r3, #0
 8016f16:	440a      	add	r2, r1
 8016f18:	60e2      	str	r2, [r4, #12]
 8016f1a:	db41      	blt.n	8016fa0 <validate_structure+0x1f0>
 8016f1c:	6925      	ldr	r5, [r4, #16]
 8016f1e:	60a3      	str	r3, [r4, #8]
 8016f20:	2d0b      	cmp	r5, #11
 8016f22:	f67f af59 	bls.w	8016dd8 <validate_structure+0x28>
 8016f26:	4629      	mov	r1, r5
 8016f28:	220c      	movs	r2, #12
 8016f2a:	4668      	mov	r0, sp
 8016f2c:	f000 fd08 	bl	8017940 <div>
 8016f30:	e89d 0028 	ldmia.w	sp, {r3, r5}
 8016f34:	6962      	ldr	r2, [r4, #20]
 8016f36:	2d00      	cmp	r5, #0
 8016f38:	4413      	add	r3, r2
 8016f3a:	6163      	str	r3, [r4, #20]
 8016f3c:	db35      	blt.n	8016faa <validate_structure+0x1fa>
 8016f3e:	6125      	str	r5, [r4, #16]
 8016f40:	e74b      	b.n	8016dda <validate_structure+0x2a>
 8016f42:	223c      	movs	r2, #60	; 0x3c
 8016f44:	4668      	mov	r0, sp
 8016f46:	f000 fcfb 	bl	8017940 <div>
 8016f4a:	e89d 000c 	ldmia.w	sp, {r2, r3}
 8016f4e:	6861      	ldr	r1, [r4, #4]
 8016f50:	2b00      	cmp	r3, #0
 8016f52:	4411      	add	r1, r2
 8016f54:	6061      	str	r1, [r4, #4]
 8016f56:	db2d      	blt.n	8016fb4 <validate_structure+0x204>
 8016f58:	6023      	str	r3, [r4, #0]
 8016f5a:	e732      	b.n	8016dc2 <validate_structure+0x12>
 8016f5c:	4630      	mov	r0, r6
 8016f5e:	4619      	mov	r1, r3
 8016f60:	e75b      	b.n	8016e1a <validate_structure+0x6a>
 8016f62:	261c      	movs	r6, #28
 8016f64:	230b      	movs	r3, #11
 8016f66:	e755      	b.n	8016e14 <validate_structure+0x64>
 8016f68:	f201 716b 	addw	r1, r1, #1899	; 0x76b
 8016f6c:	fb8c 3001 	smull	r3, r0, ip, r1
 8016f70:	17cb      	asrs	r3, r1, #31
 8016f72:	ebc3 13e0 	rsb	r3, r3, r0, asr #7
 8016f76:	fb08 1113 	mls	r1, r8, r3, r1
 8016f7a:	2900      	cmp	r1, #0
 8016f7c:	bf0c      	ite	eq
 8016f7e:	261d      	moveq	r6, #29
 8016f80:	261c      	movne	r6, #28
 8016f82:	e7ef      	b.n	8016f64 <validate_structure+0x1b4>
 8016f84:	f201 716d 	addw	r1, r1, #1901	; 0x76d
 8016f88:	fb88 3001 	smull	r3, r0, r8, r1
 8016f8c:	17cb      	asrs	r3, r1, #31
 8016f8e:	ebc3 13e0 	rsb	r3, r3, r0, asr #7
 8016f92:	fb0a 1113 	mls	r1, sl, r3, r1
 8016f96:	2900      	cmp	r1, #0
 8016f98:	bf0c      	ite	eq
 8016f9a:	261d      	moveq	r6, #29
 8016f9c:	261c      	movne	r6, #28
 8016f9e:	e786      	b.n	8016eae <validate_structure+0xfe>
 8016fa0:	3318      	adds	r3, #24
 8016fa2:	3a01      	subs	r2, #1
 8016fa4:	60a3      	str	r3, [r4, #8]
 8016fa6:	60e2      	str	r2, [r4, #12]
 8016fa8:	e712      	b.n	8016dd0 <validate_structure+0x20>
 8016faa:	350c      	adds	r5, #12
 8016fac:	3b01      	subs	r3, #1
 8016fae:	6125      	str	r5, [r4, #16]
 8016fb0:	6163      	str	r3, [r4, #20]
 8016fb2:	e712      	b.n	8016dda <validate_structure+0x2a>
 8016fb4:	333c      	adds	r3, #60	; 0x3c
 8016fb6:	3901      	subs	r1, #1
 8016fb8:	6023      	str	r3, [r4, #0]
 8016fba:	6061      	str	r1, [r4, #4]
 8016fbc:	e701      	b.n	8016dc2 <validate_structure+0x12>
 8016fbe:	333c      	adds	r3, #60	; 0x3c
 8016fc0:	3901      	subs	r1, #1
 8016fc2:	6063      	str	r3, [r4, #4]
 8016fc4:	60a1      	str	r1, [r4, #8]
 8016fc6:	e700      	b.n	8016dca <validate_structure+0x1a>
 8016fc8:	51eb851f 	.word	0x51eb851f
 8016fcc:	0801a750 	.word	0x0801a750

08016fd0 <mktime>:
 8016fd0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8016fd4:	b083      	sub	sp, #12
 8016fd6:	4606      	mov	r6, r0
 8016fd8:	f000 fcd2 	bl	8017980 <__gettzinfo>
 8016fdc:	4681      	mov	r9, r0
 8016fde:	4630      	mov	r0, r6
 8016fe0:	f7ff fee6 	bl	8016db0 <validate_structure>
 8016fe4:	6872      	ldr	r2, [r6, #4]
 8016fe6:	6933      	ldr	r3, [r6, #16]
 8016fe8:	4ccb      	ldr	r4, [pc, #812]	; (8017318 <mktime+0x348>)
 8016fea:	6835      	ldr	r5, [r6, #0]
 8016fec:	68f0      	ldr	r0, [r6, #12]
 8016fee:	68b1      	ldr	r1, [r6, #8]
 8016ff0:	f854 7023 	ldr.w	r7, [r4, r3, lsl #2]
 8016ff4:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 8016ff8:	eb05 0582 	add.w	r5, r5, r2, lsl #2
 8016ffc:	f44f 6261 	mov.w	r2, #3600	; 0xe10
 8017000:	fb02 5201 	mla	r2, r2, r1, r5
 8017004:	1e44      	subs	r4, r0, #1
 8017006:	2b01      	cmp	r3, #1
 8017008:	9201      	str	r2, [sp, #4]
 801700a:	443c      	add	r4, r7
 801700c:	6975      	ldr	r5, [r6, #20]
 801700e:	dd02      	ble.n	8017016 <mktime+0x46>
 8017010:	07ab      	lsls	r3, r5, #30
 8017012:	f000 80c5 	beq.w	80171a0 <mktime+0x1d0>
 8017016:	f505 531c 	add.w	r3, r5, #9984	; 0x2700
 801701a:	3310      	adds	r3, #16
 801701c:	f644 6220 	movw	r2, #20000	; 0x4e20
 8017020:	4293      	cmp	r3, r2
 8017022:	61f4      	str	r4, [r6, #28]
 8017024:	f200 8152 	bhi.w	80172cc <mktime+0x2fc>
 8017028:	2d46      	cmp	r5, #70	; 0x46
 801702a:	f300 808e 	bgt.w	801714a <mktime+0x17a>
 801702e:	d052      	beq.n	80170d6 <mktime+0x106>
 8017030:	2d45      	cmp	r5, #69	; 0x45
 8017032:	d04d      	beq.n	80170d0 <mktime+0x100>
 8017034:	49b9      	ldr	r1, [pc, #740]	; (801731c <mktime+0x34c>)
 8017036:	2345      	movs	r3, #69	; 0x45
 8017038:	f240 1b6d 	movw	fp, #365	; 0x16d
 801703c:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8017040:	f44f 78c8 	mov.w	r8, #400	; 0x190
 8017044:	e01a      	b.n	801707c <mktime+0xac>
 8017046:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 801704a:	fb81 ec02 	smull	lr, ip, r1, r2
 801704e:	ebc0 1067 	rsb	r0, r0, r7, asr #5
 8017052:	ea4f 7ee2 	mov.w	lr, r2, asr #31
 8017056:	ebce 1eec 	rsb	lr, lr, ip, asr #7
 801705a:	fb0a 3010 	mls	r0, sl, r0, r3
 801705e:	fb08 221e 	mls	r2, r8, lr, r2
 8017062:	2800      	cmp	r0, #0
 8017064:	f040 8111 	bne.w	801728a <mktime+0x2ba>
 8017068:	2a00      	cmp	r2, #0
 801706a:	bf0c      	ite	eq
 801706c:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 8017070:	465a      	movne	r2, fp
 8017072:	3b01      	subs	r3, #1
 8017074:	42ab      	cmp	r3, r5
 8017076:	ebc2 0404 	rsb	r4, r2, r4
 801707a:	d00d      	beq.n	8017098 <mktime+0xc8>
 801707c:	f013 0f03 	tst.w	r3, #3
 8017080:	fb81 e703 	smull	lr, r7, r1, r3
 8017084:	ea4f 70e3 	mov.w	r0, r3, asr #31
 8017088:	d0dd      	beq.n	8017046 <mktime+0x76>
 801708a:	3b01      	subs	r3, #1
 801708c:	f240 126d 	movw	r2, #365	; 0x16d
 8017090:	42ab      	cmp	r3, r5
 8017092:	ebc2 0404 	rsb	r4, r2, r4
 8017096:	d1f1      	bne.n	801707c <mktime+0xac>
 8017098:	07af      	lsls	r7, r5, #30
 801709a:	d119      	bne.n	80170d0 <mktime+0x100>
 801709c:	4b9f      	ldr	r3, [pc, #636]	; (801731c <mktime+0x34c>)
 801709e:	17ea      	asrs	r2, r5, #31
 80170a0:	fb83 0105 	smull	r0, r1, r3, r5
 80170a4:	ebc2 1261 	rsb	r2, r2, r1, asr #5
 80170a8:	2164      	movs	r1, #100	; 0x64
 80170aa:	fb01 5212 	mls	r2, r1, r2, r5
 80170ae:	2a00      	cmp	r2, #0
 80170b0:	f040 8102 	bne.w	80172b8 <mktime+0x2e8>
 80170b4:	f205 726c 	addw	r2, r5, #1900	; 0x76c
 80170b8:	fb83 1302 	smull	r1, r3, r3, r2
 80170bc:	17d1      	asrs	r1, r2, #31
 80170be:	ebc1 13e3 	rsb	r3, r1, r3, asr #7
 80170c2:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80170c6:	fb01 2213 	mls	r2, r1, r3, r2
 80170ca:	2a00      	cmp	r2, #0
 80170cc:	f000 80f4 	beq.w	80172b8 <mktime+0x2e8>
 80170d0:	f240 136d 	movw	r3, #365	; 0x16d
 80170d4:	1ae4      	subs	r4, r4, r3
 80170d6:	9a01      	ldr	r2, [sp, #4]
 80170d8:	4f91      	ldr	r7, [pc, #580]	; (8017320 <mktime+0x350>)
 80170da:	fb07 2704 	mla	r7, r7, r4, r2
 80170de:	f000 fbf7 	bl	80178d0 <__tz_lock>
 80170e2:	4b90      	ldr	r3, [pc, #576]	; (8017324 <mktime+0x354>)
 80170e4:	681b      	ldr	r3, [r3, #0]
 80170e6:	2b00      	cmp	r3, #0
 80170e8:	f000 80ca 	beq.w	8017280 <mktime+0x2b0>
 80170ec:	6970      	ldr	r0, [r6, #20]
 80170ee:	6a32      	ldr	r2, [r6, #32]
 80170f0:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80170f4:	f200 706c 	addw	r0, r0, #1900	; 0x76c
 80170f8:	2a01      	cmp	r2, #1
 80170fa:	bfb4      	ite	lt
 80170fc:	4692      	movlt	sl, r2
 80170fe:	f04f 0a01 	movge.w	sl, #1
 8017102:	4283      	cmp	r3, r0
 8017104:	d05c      	beq.n	80171c0 <mktime+0x1f0>
 8017106:	f000 f923 	bl	8017350 <__tzcalc_limits>
 801710a:	2800      	cmp	r0, #0
 801710c:	d158      	bne.n	80171c0 <mktime+0x1f0>
 801710e:	46d0      	mov	r8, sl
 8017110:	f1b8 0f01 	cmp.w	r8, #1
 8017114:	f040 80b5 	bne.w	8017282 <mktime+0x2b2>
 8017118:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 801711c:	441f      	add	r7, r3
 801711e:	f000 fbdf 	bl	80178e0 <__tz_unlock>
 8017122:	4a81      	ldr	r2, [pc, #516]	; (8017328 <mktime+0x358>)
 8017124:	f8c6 8020 	str.w	r8, [r6, #32]
 8017128:	3404      	adds	r4, #4
 801712a:	fb84 2302 	smull	r2, r3, r4, r2
 801712e:	18e2      	adds	r2, r4, r3
 8017130:	17e3      	asrs	r3, r4, #31
 8017132:	ebc3 03a2 	rsb	r3, r3, r2, asr #2
 8017136:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
 801713a:	1ae3      	subs	r3, r4, r3
 801713c:	bf48      	it	mi
 801713e:	3307      	addmi	r3, #7
 8017140:	61b3      	str	r3, [r6, #24]
 8017142:	4638      	mov	r0, r7
 8017144:	b003      	add	sp, #12
 8017146:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801714a:	4974      	ldr	r1, [pc, #464]	; (801731c <mktime+0x34c>)
 801714c:	2346      	movs	r3, #70	; 0x46
 801714e:	f240 1b6d 	movw	fp, #365	; 0x16d
 8017152:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8017156:	f44f 70c8 	mov.w	r0, #400	; 0x190
 801715a:	e017      	b.n	801718c <mktime+0x1bc>
 801715c:	f203 726c 	addw	r2, r3, #1900	; 0x76c
 8017160:	fb81 c802 	smull	ip, r8, r1, r2
 8017164:	ebc7 176e 	rsb	r7, r7, lr, asr #5
 8017168:	ea4f 7ce2 	mov.w	ip, r2, asr #31
 801716c:	ebcc 1ce8 	rsb	ip, ip, r8, asr #7
 8017170:	fb0a 3717 	mls	r7, sl, r7, r3
 8017174:	fb00 221c 	mls	r2, r0, ip, r2
 8017178:	b9ff      	cbnz	r7, 80171ba <mktime+0x1ea>
 801717a:	2a00      	cmp	r2, #0
 801717c:	bf0c      	ite	eq
 801717e:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 8017182:	465a      	movne	r2, fp
 8017184:	3301      	adds	r3, #1
 8017186:	42ab      	cmp	r3, r5
 8017188:	4414      	add	r4, r2
 801718a:	d0a4      	beq.n	80170d6 <mktime+0x106>
 801718c:	f013 0f03 	tst.w	r3, #3
 8017190:	fb81 2e03 	smull	r2, lr, r1, r3
 8017194:	ea4f 77e3 	mov.w	r7, r3, asr #31
 8017198:	d0e0      	beq.n	801715c <mktime+0x18c>
 801719a:	f240 126d 	movw	r2, #365	; 0x16d
 801719e:	e7f1      	b.n	8017184 <mktime+0x1b4>
 80171a0:	4b5e      	ldr	r3, [pc, #376]	; (801731c <mktime+0x34c>)
 80171a2:	17ea      	asrs	r2, r5, #31
 80171a4:	fb83 0105 	smull	r0, r1, r3, r5
 80171a8:	ebc2 1261 	rsb	r2, r2, r1, asr #5
 80171ac:	2164      	movs	r1, #100	; 0x64
 80171ae:	fb01 5212 	mls	r2, r1, r2, r5
 80171b2:	2a00      	cmp	r2, #0
 80171b4:	d06c      	beq.n	8017290 <mktime+0x2c0>
 80171b6:	3401      	adds	r4, #1
 80171b8:	e72d      	b.n	8017016 <mktime+0x46>
 80171ba:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 80171be:	e7e1      	b.n	8017184 <mktime+0x1b4>
 80171c0:	f8d9 1038 	ldr.w	r1, [r9, #56]	; 0x38
 80171c4:	f8d9 0020 	ldr.w	r0, [r9, #32]
 80171c8:	f8d9 303c 	ldr.w	r3, [r9, #60]	; 0x3c
 80171cc:	f8d9 201c 	ldr.w	r2, [r9, #28]
 80171d0:	ebc0 0801 	rsb	r8, r0, r1
 80171d4:	4547      	cmp	r7, r8
 80171d6:	ebc3 0202 	rsb	r2, r3, r2
 80171da:	db02      	blt.n	80171e2 <mktime+0x212>
 80171dc:	1ac9      	subs	r1, r1, r3
 80171de:	428f      	cmp	r7, r1
 80171e0:	db95      	blt.n	801710e <mktime+0x13e>
 80171e2:	f8d9 1000 	ldr.w	r1, [r9]
 80171e6:	2900      	cmp	r1, #0
 80171e8:	d061      	beq.n	80172ae <mktime+0x2de>
 80171ea:	4297      	cmp	r7, r2
 80171ec:	da67      	bge.n	80172be <mktime+0x2ee>
 80171ee:	f04f 0800 	mov.w	r8, #0
 80171f2:	f1ba 0f00 	cmp.w	sl, #0
 80171f6:	db8b      	blt.n	8017110 <mktime+0x140>
 80171f8:	ea88 0a0a 	eor.w	sl, r8, sl
 80171fc:	f1ba 0f01 	cmp.w	sl, #1
 8017200:	d186      	bne.n	8017110 <mktime+0x140>
 8017202:	1ac3      	subs	r3, r0, r3
 8017204:	f1b8 0f00 	cmp.w	r8, #0
 8017208:	d100      	bne.n	801720c <mktime+0x23c>
 801720a:	425b      	negs	r3, r3
 801720c:	6832      	ldr	r2, [r6, #0]
 801720e:	f8d6 a00c 	ldr.w	sl, [r6, #12]
 8017212:	441a      	add	r2, r3
 8017214:	6032      	str	r2, [r6, #0]
 8017216:	4630      	mov	r0, r6
 8017218:	441f      	add	r7, r3
 801721a:	f7ff fdc9 	bl	8016db0 <validate_structure>
 801721e:	68f3      	ldr	r3, [r6, #12]
 8017220:	ebb3 030a 	subs.w	r3, r3, sl
 8017224:	f43f af74 	beq.w	8017110 <mktime+0x140>
 8017228:	2b01      	cmp	r3, #1
 801722a:	dd7f      	ble.n	801732c <mktime+0x35c>
 801722c:	f04f 33ff 	mov.w	r3, #4294967295
 8017230:	69f2      	ldr	r2, [r6, #28]
 8017232:	441c      	add	r4, r3
 8017234:	189b      	adds	r3, r3, r2
 8017236:	d44f      	bmi.n	80172d8 <mktime+0x308>
 8017238:	07aa      	lsls	r2, r5, #30
 801723a:	d14a      	bne.n	80172d2 <mktime+0x302>
 801723c:	4a37      	ldr	r2, [pc, #220]	; (801731c <mktime+0x34c>)
 801723e:	17e9      	asrs	r1, r5, #31
 8017240:	fb82 c005 	smull	ip, r0, r2, r5
 8017244:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 8017248:	2064      	movs	r0, #100	; 0x64
 801724a:	fb00 5111 	mls	r1, r0, r1, r5
 801724e:	2900      	cmp	r1, #0
 8017250:	d170      	bne.n	8017334 <mktime+0x364>
 8017252:	f205 756c 	addw	r5, r5, #1900	; 0x76c
 8017256:	17e9      	asrs	r1, r5, #31
 8017258:	fb82 e205 	smull	lr, r2, r2, r5
 801725c:	ebc1 12e2 	rsb	r2, r1, r2, asr #7
 8017260:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8017264:	fb01 5512 	mls	r5, r1, r2, r5
 8017268:	2d00      	cmp	r5, #0
 801726a:	f240 126d 	movw	r2, #365	; 0x16d
 801726e:	bf08      	it	eq
 8017270:	f44f 72b7 	moveq.w	r2, #366	; 0x16e
 8017274:	429a      	cmp	r2, r3
 8017276:	bfd8      	it	le
 8017278:	ebc2 0303 	rsble	r3, r2, r3
 801727c:	61f3      	str	r3, [r6, #28]
 801727e:	e747      	b.n	8017110 <mktime+0x140>
 8017280:	4698      	mov	r8, r3
 8017282:	f8d9 3020 	ldr.w	r3, [r9, #32]
 8017286:	441f      	add	r7, r3
 8017288:	e749      	b.n	801711e <mktime+0x14e>
 801728a:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 801728e:	e6f0      	b.n	8017072 <mktime+0xa2>
 8017290:	f205 726c 	addw	r2, r5, #1900	; 0x76c
 8017294:	fb83 1302 	smull	r1, r3, r3, r2
 8017298:	17d1      	asrs	r1, r2, #31
 801729a:	ebc1 13e3 	rsb	r3, r1, r3, asr #7
 801729e:	f44f 71c8 	mov.w	r1, #400	; 0x190
 80172a2:	fb01 2213 	mls	r2, r1, r3, r2
 80172a6:	2a00      	cmp	r2, #0
 80172a8:	f47f aeb5 	bne.w	8017016 <mktime+0x46>
 80172ac:	e783      	b.n	80171b6 <mktime+0x1e6>
 80172ae:	4297      	cmp	r7, r2
 80172b0:	db05      	blt.n	80172be <mktime+0x2ee>
 80172b2:	f04f 0801 	mov.w	r8, #1
 80172b6:	e79c      	b.n	80171f2 <mktime+0x222>
 80172b8:	f44f 73b7 	mov.w	r3, #366	; 0x16e
 80172bc:	e70a      	b.n	80170d4 <mktime+0x104>
 80172be:	4547      	cmp	r7, r8
 80172c0:	bfac      	ite	ge
 80172c2:	f04f 0800 	movge.w	r8, #0
 80172c6:	f04f 0801 	movlt.w	r8, #1
 80172ca:	e792      	b.n	80171f2 <mktime+0x222>
 80172cc:	f04f 30ff 	mov.w	r0, #4294967295
 80172d0:	e738      	b.n	8017144 <mktime+0x174>
 80172d2:	f240 126d 	movw	r2, #365	; 0x16d
 80172d6:	e7cd      	b.n	8017274 <mktime+0x2a4>
 80172d8:	1e6b      	subs	r3, r5, #1
 80172da:	0799      	lsls	r1, r3, #30
 80172dc:	d12d      	bne.n	801733a <mktime+0x36a>
 80172de:	4a0f      	ldr	r2, [pc, #60]	; (801731c <mktime+0x34c>)
 80172e0:	17d9      	asrs	r1, r3, #31
 80172e2:	fb82 c003 	smull	ip, r0, r2, r3
 80172e6:	ebc1 1160 	rsb	r1, r1, r0, asr #5
 80172ea:	2064      	movs	r0, #100	; 0x64
 80172ec:	fb00 3311 	mls	r3, r0, r1, r3
 80172f0:	bb33      	cbnz	r3, 8017340 <mktime+0x370>
 80172f2:	f205 756b 	addw	r5, r5, #1899	; 0x76b
 80172f6:	fb82 e205 	smull	lr, r2, r2, r5
 80172fa:	17eb      	asrs	r3, r5, #31
 80172fc:	ebc3 13e2 	rsb	r3, r3, r2, asr #7
 8017300:	f44f 72c8 	mov.w	r2, #400	; 0x190
 8017304:	fb02 5513 	mls	r5, r2, r3, r5
 8017308:	2d00      	cmp	r5, #0
 801730a:	f240 136d 	movw	r3, #365	; 0x16d
 801730e:	bf18      	it	ne
 8017310:	f44f 73b6 	movne.w	r3, #364	; 0x16c
 8017314:	e7b2      	b.n	801727c <mktime+0x2ac>
 8017316:	bf00      	nop
 8017318:	0801a720 	.word	0x0801a720
 801731c:	51eb851f 	.word	0x51eb851f
 8017320:	00015180 	.word	0x00015180
 8017324:	20001b88 	.word	0x20001b88
 8017328:	92492493 	.word	0x92492493
 801732c:	1c98      	adds	r0, r3, #2
 801732e:	bfd8      	it	le
 8017330:	2301      	movle	r3, #1
 8017332:	e77d      	b.n	8017230 <mktime+0x260>
 8017334:	f44f 72b7 	mov.w	r2, #366	; 0x16e
 8017338:	e79c      	b.n	8017274 <mktime+0x2a4>
 801733a:	f44f 73b6 	mov.w	r3, #364	; 0x16c
 801733e:	e79d      	b.n	801727c <mktime+0x2ac>
 8017340:	f240 136d 	movw	r3, #365	; 0x16d
 8017344:	e79a      	b.n	801727c <mktime+0x2ac>
 8017346:	bf00      	nop
	...

08017350 <__tzcalc_limits>:
 8017350:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017354:	b083      	sub	sp, #12
 8017356:	4604      	mov	r4, r0
 8017358:	f000 fb12 	bl	8017980 <__gettzinfo>
 801735c:	f240 73b1 	movw	r3, #1969	; 0x7b1
 8017360:	429c      	cmp	r4, r3
 8017362:	f340 8095 	ble.w	8017490 <__tzcalc_limits+0x140>
 8017366:	4b5a      	ldr	r3, [pc, #360]	; (80174d0 <__tzcalc_limits+0x180>)
 8017368:	6044      	str	r4, [r0, #4]
 801736a:	f46f 62f6 	mvn.w	r2, #1968	; 0x7b0
 801736e:	18a5      	adds	r5, r4, r2
 8017370:	f2a4 7a6d 	subw	sl, r4, #1901	; 0x76d
 8017374:	fb83 180a 	smull	r1, r8, r3, sl
 8017378:	fb83 2704 	smull	r2, r7, r3, r4
 801737c:	f2a4 76b2 	subw	r6, r4, #1970	; 0x7b2
 8017380:	17e2      	asrs	r2, r4, #31
 8017382:	f240 196d 	movw	r9, #365	; 0x16d
 8017386:	10ad      	asrs	r5, r5, #2
 8017388:	f46f 61c8 	mvn.w	r1, #1600	; 0x640
 801738c:	fb09 5506 	mla	r5, r9, r6, r5
 8017390:	1861      	adds	r1, r4, r1
 8017392:	ebc2 1be7 	rsb	fp, r2, r7, asr #7
 8017396:	ea4f 7aea 	mov.w	sl, sl, asr #31
 801739a:	f44f 79c8 	mov.w	r9, #400	; 0x190
 801739e:	ebaa 1a68 	sub.w	sl, sl, r8, asr #5
 80173a2:	fb83 6301 	smull	r6, r3, r3, r1
 80173a6:	ebc2 1767 	rsb	r7, r2, r7, asr #5
 80173aa:	fb09 4b1b 	mls	fp, r9, fp, r4
 80173ae:	17c9      	asrs	r1, r1, #31
 80173b0:	2264      	movs	r2, #100	; 0x64
 80173b2:	44aa      	add	sl, r5
 80173b4:	fb02 4717 	mls	r7, r2, r7, r4
 80173b8:	ebc1 13e3 	rsb	r3, r1, r3, asr #7
 80173bc:	f004 0403 	and.w	r4, r4, #3
 80173c0:	f1db 0b01 	rsbs	fp, fp, #1
 80173c4:	f8df c114 	ldr.w	ip, [pc, #276]	; 80174dc <__tzcalc_limits+0x18c>
 80173c8:	9401      	str	r4, [sp, #4]
 80173ca:	eb0a 0803 	add.w	r8, sl, r3
 80173ce:	bf38      	it	cc
 80173d0:	f04f 0b00 	movcc.w	fp, #0
 80173d4:	4604      	mov	r4, r0
 80173d6:	2500      	movs	r5, #0
 80173d8:	46ba      	mov	sl, r7
 80173da:	7a23      	ldrb	r3, [r4, #8]
 80173dc:	2b4a      	cmp	r3, #74	; 0x4a
 80173de:	d05b      	beq.n	8017498 <__tzcalc_limits+0x148>
 80173e0:	2b44      	cmp	r3, #68	; 0x44
 80173e2:	d06d      	beq.n	80174c0 <__tzcalc_limits+0x170>
 80173e4:	9901      	ldr	r1, [sp, #4]
 80173e6:	2900      	cmp	r1, #0
 80173e8:	d04c      	beq.n	8017484 <__tzcalc_limits+0x134>
 80173ea:	465b      	mov	r3, fp
 80173ec:	68e7      	ldr	r7, [r4, #12]
 80173ee:	4a39      	ldr	r2, [pc, #228]	; (80174d4 <__tzcalc_limits+0x184>)
 80173f0:	005e      	lsls	r6, r3, #1
 80173f2:	441e      	add	r6, r3
 80173f4:	2f01      	cmp	r7, #1
 80173f6:	eb02 1606 	add.w	r6, r2, r6, lsl #4
 80173fa:	dd64      	ble.n	80174c6 <__tzcalc_limits+0x176>
 80173fc:	00bf      	lsls	r7, r7, #2
 80173fe:	f1a6 0908 	sub.w	r9, r6, #8
 8017402:	44b9      	add	r9, r7
 8017404:	1f33      	subs	r3, r6, #4
 8017406:	4641      	mov	r1, r8
 8017408:	f853 2f04 	ldr.w	r2, [r3, #4]!
 801740c:	454b      	cmp	r3, r9
 801740e:	4411      	add	r1, r2
 8017410:	d1fa      	bne.n	8017408 <__tzcalc_limits+0xb8>
 8017412:	3f04      	subs	r7, #4
 8017414:	9700      	str	r7, [sp, #0]
 8017416:	4f30      	ldr	r7, [pc, #192]	; (80174d8 <__tzcalc_limits+0x188>)
 8017418:	f101 0904 	add.w	r9, r1, #4
 801741c:	fb89 2307 	smull	r2, r3, r9, r7
 8017420:	eb09 0203 	add.w	r2, r9, r3
 8017424:	ea4f 73e9 	mov.w	r3, r9, asr #31
 8017428:	ebc3 02a2 	rsb	r2, r3, r2, asr #2
 801742c:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 8017430:	ebc2 0909 	rsb	r9, r2, r9
 8017434:	6963      	ldr	r3, [r4, #20]
 8017436:	6922      	ldr	r2, [r4, #16]
 8017438:	9f00      	ldr	r7, [sp, #0]
 801743a:	ebb3 0309 	subs.w	r3, r3, r9
 801743e:	f102 32ff 	add.w	r2, r2, #4294967295
 8017442:	bf48      	it	mi
 8017444:	3307      	addmi	r3, #7
 8017446:	59f6      	ldr	r6, [r6, r7]
 8017448:	ebc2 02c2 	rsb	r2, r2, r2, lsl #3
 801744c:	4413      	add	r3, r2
 801744e:	42b3      	cmp	r3, r6
 8017450:	db02      	blt.n	8017458 <__tzcalc_limits+0x108>
 8017452:	3b07      	subs	r3, #7
 8017454:	42b3      	cmp	r3, r6
 8017456:	dafc      	bge.n	8017452 <__tzcalc_limits+0x102>
 8017458:	440b      	add	r3, r1
 801745a:	69a6      	ldr	r6, [r4, #24]
 801745c:	6a22      	ldr	r2, [r4, #32]
 801745e:	fb0c 6603 	mla	r6, ip, r3, r6
 8017462:	3501      	adds	r5, #1
 8017464:	4432      	add	r2, r6
 8017466:	2d02      	cmp	r5, #2
 8017468:	f844 2f1c 	str.w	r2, [r4, #28]!
 801746c:	d1b5      	bne.n	80173da <__tzcalc_limits+0x8a>
 801746e:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8017470:	69c2      	ldr	r2, [r0, #28]
 8017472:	429a      	cmp	r2, r3
 8017474:	bfac      	ite	ge
 8017476:	2300      	movge	r3, #0
 8017478:	2301      	movlt	r3, #1
 801747a:	6003      	str	r3, [r0, #0]
 801747c:	2001      	movs	r0, #1
 801747e:	b003      	add	sp, #12
 8017480:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017484:	f1ba 0f00 	cmp.w	sl, #0
 8017488:	bf0c      	ite	eq
 801748a:	465b      	moveq	r3, fp
 801748c:	2301      	movne	r3, #1
 801748e:	e7ad      	b.n	80173ec <__tzcalc_limits+0x9c>
 8017490:	2000      	movs	r0, #0
 8017492:	b003      	add	sp, #12
 8017494:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017498:	6962      	ldr	r2, [r4, #20]
 801749a:	9f01      	ldr	r7, [sp, #4]
 801749c:	eb02 0308 	add.w	r3, r2, r8
 80174a0:	b94f      	cbnz	r7, 80174b6 <__tzcalc_limits+0x166>
 80174a2:	f1ba 0f00 	cmp.w	sl, #0
 80174a6:	d006      	beq.n	80174b6 <__tzcalc_limits+0x166>
 80174a8:	2a3b      	cmp	r2, #59	; 0x3b
 80174aa:	bfd4      	ite	le
 80174ac:	2200      	movle	r2, #0
 80174ae:	2201      	movgt	r2, #1
 80174b0:	4413      	add	r3, r2
 80174b2:	3b01      	subs	r3, #1
 80174b4:	e7d1      	b.n	801745a <__tzcalc_limits+0x10a>
 80174b6:	f1bb 0f00 	cmp.w	fp, #0
 80174ba:	d1f5      	bne.n	80174a8 <__tzcalc_limits+0x158>
 80174bc:	465a      	mov	r2, fp
 80174be:	e7f7      	b.n	80174b0 <__tzcalc_limits+0x160>
 80174c0:	6963      	ldr	r3, [r4, #20]
 80174c2:	4443      	add	r3, r8
 80174c4:	e7c9      	b.n	801745a <__tzcalc_limits+0x10a>
 80174c6:	2300      	movs	r3, #0
 80174c8:	4641      	mov	r1, r8
 80174ca:	9300      	str	r3, [sp, #0]
 80174cc:	e7a3      	b.n	8017416 <__tzcalc_limits+0xc6>
 80174ce:	bf00      	nop
 80174d0:	51eb851f 	.word	0x51eb851f
 80174d4:	0801a780 	.word	0x0801a780
 80174d8:	92492493 	.word	0x92492493
 80174dc:	00015180 	.word	0x00015180

080174e0 <_mktm_r>:
 80174e0:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80174e4:	4680      	mov	r8, r0
 80174e6:	460e      	mov	r6, r1
 80174e8:	4617      	mov	r7, r2
 80174ea:	f000 fa49 	bl	8017980 <__gettzinfo>
 80174ee:	f8d8 2000 	ldr.w	r2, [r8]
 80174f2:	4bb2      	ldr	r3, [pc, #712]	; (80177bc <_mktm_r+0x2dc>)
 80174f4:	4db2      	ldr	r5, [pc, #712]	; (80177c0 <_mktm_r+0x2e0>)
 80174f6:	4681      	mov	r9, r0
 80174f8:	fb83 0302 	smull	r0, r3, r3, r2
 80174fc:	4413      	add	r3, r2
 80174fe:	17d1      	asrs	r1, r2, #31
 8017500:	ebc1 4323 	rsb	r3, r1, r3, asr #16
 8017504:	fb05 2513 	mls	r5, r5, r3, r2
 8017508:	2d00      	cmp	r5, #0
 801750a:	da04      	bge.n	8017516 <_mktm_r+0x36>
 801750c:	f505 35a8 	add.w	r5, r5, #86016	; 0x15000
 8017510:	f505 75c0 	add.w	r5, r5, #384	; 0x180
 8017514:	3b01      	subs	r3, #1
 8017516:	49ab      	ldr	r1, [pc, #684]	; (80177c4 <_mktm_r+0x2e4>)
 8017518:	4aab      	ldr	r2, [pc, #684]	; (80177c8 <_mktm_r+0x2e8>)
 801751a:	4cac      	ldr	r4, [pc, #688]	; (80177cc <_mktm_r+0x2ec>)
 801751c:	fb81 bc05 	smull	fp, ip, r1, r5
 8017520:	44ac      	add	ip, r5
 8017522:	17e9      	asrs	r1, r5, #31
 8017524:	ebc1 2cec 	rsb	ip, r1, ip, asr #11
 8017528:	f44f 6161 	mov.w	r1, #3600	; 0xe10
 801752c:	fb01 511c 	mls	r1, r1, ip, r5
 8017530:	fb82 0a01 	smull	r0, sl, r2, r1
 8017534:	1d1a      	adds	r2, r3, #4
 8017536:	448a      	add	sl, r1
 8017538:	17c8      	asrs	r0, r1, #31
 801753a:	fb82 4504 	smull	r4, r5, r2, r4
 801753e:	ebc0 146a 	rsb	r4, r0, sl, asr #5
 8017542:	eb02 0a05 	add.w	sl, r2, r5
 8017546:	17d0      	asrs	r0, r2, #31
 8017548:	ebc0 00aa 	rsb	r0, r0, sl, asr #2
 801754c:	ebc0 00c0 	rsb	r0, r0, r0, lsl #3
 8017550:	1a10      	subs	r0, r2, r0
 8017552:	ebc4 1504 	rsb	r5, r4, r4, lsl #4
 8017556:	bf48      	it	mi
 8017558:	3007      	addmi	r0, #7
 801755a:	eba1 0185 	sub.w	r1, r1, r5, lsl #2
 801755e:	2b00      	cmp	r3, #0
 8017560:	e886 1012 	stmia.w	r6, {r1, r4, ip}
 8017564:	61b0      	str	r0, [r6, #24]
 8017566:	4d9a      	ldr	r5, [pc, #616]	; (80177d0 <_mktm_r+0x2f0>)
 8017568:	489a      	ldr	r0, [pc, #616]	; (80177d4 <_mktm_r+0x2f4>)
 801756a:	f240 74b2 	movw	r4, #1970	; 0x7b2
 801756e:	f44f 7cc8 	mov.w	ip, #400	; 0x190
 8017572:	f04f 0a64 	mov.w	sl, #100	; 0x64
 8017576:	da0c      	bge.n	8017592 <_mktm_r+0xb2>
 8017578:	e04a      	b.n	8017610 <_mktm_r+0x130>
 801757a:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 801757e:	fb0a 4111 	mls	r1, sl, r1, r4
 8017582:	b169      	cbz	r1, 80175a0 <_mktm_r+0xc0>
 8017584:	2201      	movs	r2, #1
 8017586:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 801758a:	428b      	cmp	r3, r1
 801758c:	db16      	blt.n	80175bc <_mktm_r+0xdc>
 801758e:	3401      	adds	r4, #1
 8017590:	1a5b      	subs	r3, r3, r1
 8017592:	f014 0f03 	tst.w	r4, #3
 8017596:	ea4f 72e4 	mov.w	r2, r4, asr #31
 801759a:	fb80 b104 	smull	fp, r1, r0, r4
 801759e:	d0ec      	beq.n	801757a <_mktm_r+0x9a>
 80175a0:	fb80 b104 	smull	fp, r1, r0, r4
 80175a4:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 80175a8:	fb0c 4212 	mls	r2, ip, r2, r4
 80175ac:	f1d2 0201 	rsbs	r2, r2, #1
 80175b0:	bf38      	it	cc
 80175b2:	2200      	movcc	r2, #0
 80175b4:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 80175b8:	428b      	cmp	r3, r1
 80175ba:	dae8      	bge.n	801758e <_mktm_r+0xae>
 80175bc:	0055      	lsls	r5, r2, #1
 80175be:	4415      	add	r5, r2
 80175c0:	012d      	lsls	r5, r5, #4
 80175c2:	2200      	movs	r2, #0
 80175c4:	4984      	ldr	r1, [pc, #528]	; (80177d8 <_mktm_r+0x2f8>)
 80175c6:	61f3      	str	r3, [r6, #28]
 80175c8:	f2a4 706c 	subw	r0, r4, #1900	; 0x76c
 80175cc:	6170      	str	r0, [r6, #20]
 80175ce:	6132      	str	r2, [r6, #16]
 80175d0:	594a      	ldr	r2, [r1, r5]
 80175d2:	4293      	cmp	r3, r2
 80175d4:	440d      	add	r5, r1
 80175d6:	db09      	blt.n	80175ec <_mktm_r+0x10c>
 80175d8:	4628      	mov	r0, r5
 80175da:	2101      	movs	r1, #1
 80175dc:	6131      	str	r1, [r6, #16]
 80175de:	1a9b      	subs	r3, r3, r2
 80175e0:	f850 2f04 	ldr.w	r2, [r0, #4]!
 80175e4:	429a      	cmp	r2, r3
 80175e6:	f101 0101 	add.w	r1, r1, #1
 80175ea:	ddf7      	ble.n	80175dc <_mktm_r+0xfc>
 80175ec:	3301      	adds	r3, #1
 80175ee:	60f3      	str	r3, [r6, #12]
 80175f0:	b30f      	cbz	r7, 8017636 <_mktm_r+0x156>
 80175f2:	2300      	movs	r3, #0
 80175f4:	6233      	str	r3, [r6, #32]
 80175f6:	4630      	mov	r0, r6
 80175f8:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80175fc:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 8017600:	fb0a 4111 	mls	r1, sl, r1, r4
 8017604:	b161      	cbz	r1, 8017620 <_mktm_r+0x140>
 8017606:	2201      	movs	r2, #1
 8017608:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 801760c:	185b      	adds	r3, r3, r1
 801760e:	d5d5      	bpl.n	80175bc <_mktm_r+0xdc>
 8017610:	3c01      	subs	r4, #1
 8017612:	f014 0f03 	tst.w	r4, #3
 8017616:	ea4f 72e4 	mov.w	r2, r4, asr #31
 801761a:	fb80 b104 	smull	fp, r1, r0, r4
 801761e:	d0ed      	beq.n	80175fc <_mktm_r+0x11c>
 8017620:	fb80 b104 	smull	fp, r1, r0, r4
 8017624:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 8017628:	fb0c 4212 	mls	r2, ip, r2, r4
 801762c:	f1d2 0201 	rsbs	r2, r2, #1
 8017630:	bf38      	it	cc
 8017632:	2200      	movcc	r2, #0
 8017634:	e7e8      	b.n	8017608 <_mktm_r+0x128>
 8017636:	f000 f94b 	bl	80178d0 <__tz_lock>
 801763a:	4b68      	ldr	r3, [pc, #416]	; (80177dc <_mktm_r+0x2fc>)
 801763c:	681b      	ldr	r3, [r3, #0]
 801763e:	2b00      	cmp	r3, #0
 8017640:	d15a      	bne.n	80176f8 <_mktm_r+0x218>
 8017642:	6237      	str	r7, [r6, #32]
 8017644:	f8d9 1020 	ldr.w	r1, [r9, #32]
 8017648:	4c5e      	ldr	r4, [pc, #376]	; (80177c4 <_mktm_r+0x2e4>)
 801764a:	485f      	ldr	r0, [pc, #380]	; (80177c8 <_mktm_r+0x2e8>)
 801764c:	fb81 2304 	smull	r2, r3, r1, r4
 8017650:	18cf      	adds	r7, r1, r3
 8017652:	ea4f 79e1 	mov.w	r9, r1, asr #31
 8017656:	ebc9 27e7 	rsb	r7, r9, r7, asr #11
 801765a:	f44f 6361 	mov.w	r3, #3600	; 0xe10
 801765e:	fb03 1717 	mls	r7, r3, r7, r1
 8017662:	fb87 2300 	smull	r2, r3, r7, r0
 8017666:	18fa      	adds	r2, r7, r3
 8017668:	17fb      	asrs	r3, r7, #31
 801766a:	fb84 e801 	smull	lr, r8, r4, r1
 801766e:	ebc3 1262 	rsb	r2, r3, r2, asr #5
 8017672:	fb80 4c07 	smull	r4, ip, r0, r7
 8017676:	eb08 0e01 	add.w	lr, r8, r1
 801767a:	68b0      	ldr	r0, [r6, #8]
 801767c:	6831      	ldr	r1, [r6, #0]
 801767e:	ebc2 1202 	rsb	r2, r2, r2, lsl #4
 8017682:	44bc      	add	ip, r7
 8017684:	ebc9 29ee 	rsb	r9, r9, lr, asr #11
 8017688:	eba7 0782 	sub.w	r7, r7, r2, lsl #2
 801768c:	6872      	ldr	r2, [r6, #4]
 801768e:	ebc9 0400 	rsb	r4, r9, r0
 8017692:	ebc3 136c 	rsb	r3, r3, ip, asr #5
 8017696:	1bc8      	subs	r0, r1, r7
 8017698:	283b      	cmp	r0, #59	; 0x3b
 801769a:	ebc3 0102 	rsb	r1, r3, r2
 801769e:	e886 0013 	stmia.w	r6, {r0, r1, r4}
 80176a2:	dd45      	ble.n	8017730 <_mktm_r+0x250>
 80176a4:	3101      	adds	r1, #1
 80176a6:	383c      	subs	r0, #60	; 0x3c
 80176a8:	e886 0003 	stmia.w	r6, {r0, r1}
 80176ac:	293b      	cmp	r1, #59	; 0x3b
 80176ae:	dd5f      	ble.n	8017770 <_mktm_r+0x290>
 80176b0:	3401      	adds	r4, #1
 80176b2:	393c      	subs	r1, #60	; 0x3c
 80176b4:	60b4      	str	r4, [r6, #8]
 80176b6:	6071      	str	r1, [r6, #4]
 80176b8:	2c17      	cmp	r4, #23
 80176ba:	dd40      	ble.n	801773e <_mktm_r+0x25e>
 80176bc:	69b3      	ldr	r3, [r6, #24]
 80176be:	69f2      	ldr	r2, [r6, #28]
 80176c0:	3301      	adds	r3, #1
 80176c2:	2b06      	cmp	r3, #6
 80176c4:	bfc8      	it	gt
 80176c6:	2300      	movgt	r3, #0
 80176c8:	61b3      	str	r3, [r6, #24]
 80176ca:	68f3      	ldr	r3, [r6, #12]
 80176cc:	3201      	adds	r2, #1
 80176ce:	61f2      	str	r2, [r6, #28]
 80176d0:	3301      	adds	r3, #1
 80176d2:	6932      	ldr	r2, [r6, #16]
 80176d4:	60f3      	str	r3, [r6, #12]
 80176d6:	3c18      	subs	r4, #24
 80176d8:	60b4      	str	r4, [r6, #8]
 80176da:	f855 1022 	ldr.w	r1, [r5, r2, lsl #2]
 80176de:	428b      	cmp	r3, r1
 80176e0:	dd05      	ble.n	80176ee <_mktm_r+0x20e>
 80176e2:	3201      	adds	r2, #1
 80176e4:	1a5b      	subs	r3, r3, r1
 80176e6:	2a0c      	cmp	r2, #12
 80176e8:	60f3      	str	r3, [r6, #12]
 80176ea:	d05f      	beq.n	80177ac <_mktm_r+0x2cc>
 80176ec:	6132      	str	r2, [r6, #16]
 80176ee:	f000 f8f7 	bl	80178e0 <__tz_unlock>
 80176f2:	4630      	mov	r0, r6
 80176f4:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80176f8:	f8d9 3004 	ldr.w	r3, [r9, #4]
 80176fc:	42a3      	cmp	r3, r4
 80176fe:	d004      	beq.n	801770a <_mktm_r+0x22a>
 8017700:	4620      	mov	r0, r4
 8017702:	f7ff fe25 	bl	8017350 <__tzcalc_limits>
 8017706:	2800      	cmp	r0, #0
 8017708:	d049      	beq.n	801779e <_mktm_r+0x2be>
 801770a:	f8d9 3000 	ldr.w	r3, [r9]
 801770e:	2b00      	cmp	r3, #0
 8017710:	d035      	beq.n	801777e <_mktm_r+0x29e>
 8017712:	f8d8 3000 	ldr.w	r3, [r8]
 8017716:	f8d9 201c 	ldr.w	r2, [r9, #28]
 801771a:	4293      	cmp	r3, r2
 801771c:	db43      	blt.n	80177a6 <_mktm_r+0x2c6>
 801771e:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
 8017722:	4293      	cmp	r3, r2
 8017724:	da3f      	bge.n	80177a6 <_mktm_r+0x2c6>
 8017726:	2301      	movs	r3, #1
 8017728:	6233      	str	r3, [r6, #32]
 801772a:	f8d9 103c 	ldr.w	r1, [r9, #60]	; 0x3c
 801772e:	e78b      	b.n	8017648 <_mktm_r+0x168>
 8017730:	2800      	cmp	r0, #0
 8017732:	dabb      	bge.n	80176ac <_mktm_r+0x1cc>
 8017734:	3901      	subs	r1, #1
 8017736:	303c      	adds	r0, #60	; 0x3c
 8017738:	e886 0003 	stmia.w	r6, {r0, r1}
 801773c:	e7b6      	b.n	80176ac <_mktm_r+0x1cc>
 801773e:	2c00      	cmp	r4, #0
 8017740:	dad5      	bge.n	80176ee <_mktm_r+0x20e>
 8017742:	69b3      	ldr	r3, [r6, #24]
 8017744:	69f2      	ldr	r2, [r6, #28]
 8017746:	3b01      	subs	r3, #1
 8017748:	bf48      	it	mi
 801774a:	2306      	movmi	r3, #6
 801774c:	61b3      	str	r3, [r6, #24]
 801774e:	68f3      	ldr	r3, [r6, #12]
 8017750:	3a01      	subs	r2, #1
 8017752:	3418      	adds	r4, #24
 8017754:	3b01      	subs	r3, #1
 8017756:	61f2      	str	r2, [r6, #28]
 8017758:	60b4      	str	r4, [r6, #8]
 801775a:	60f3      	str	r3, [r6, #12]
 801775c:	2b00      	cmp	r3, #0
 801775e:	d1c6      	bne.n	80176ee <_mktm_r+0x20e>
 8017760:	6933      	ldr	r3, [r6, #16]
 8017762:	3b01      	subs	r3, #1
 8017764:	d43c      	bmi.n	80177e0 <_mktm_r+0x300>
 8017766:	6133      	str	r3, [r6, #16]
 8017768:	009b      	lsls	r3, r3, #2
 801776a:	58eb      	ldr	r3, [r5, r3]
 801776c:	60f3      	str	r3, [r6, #12]
 801776e:	e7be      	b.n	80176ee <_mktm_r+0x20e>
 8017770:	2900      	cmp	r1, #0
 8017772:	daa1      	bge.n	80176b8 <_mktm_r+0x1d8>
 8017774:	3c01      	subs	r4, #1
 8017776:	313c      	adds	r1, #60	; 0x3c
 8017778:	60b4      	str	r4, [r6, #8]
 801777a:	6071      	str	r1, [r6, #4]
 801777c:	e79c      	b.n	80176b8 <_mktm_r+0x1d8>
 801777e:	f8d8 3000 	ldr.w	r3, [r8]
 8017782:	f8d9 201c 	ldr.w	r2, [r9, #28]
 8017786:	4293      	cmp	r3, r2
 8017788:	dacd      	bge.n	8017726 <_mktm_r+0x246>
 801778a:	f8d9 2038 	ldr.w	r2, [r9, #56]	; 0x38
 801778e:	4293      	cmp	r3, r2
 8017790:	bfac      	ite	ge
 8017792:	2300      	movge	r3, #0
 8017794:	2301      	movlt	r3, #1
 8017796:	6233      	str	r3, [r6, #32]
 8017798:	2b00      	cmp	r3, #0
 801779a:	d1c6      	bne.n	801772a <_mktm_r+0x24a>
 801779c:	e752      	b.n	8017644 <_mktm_r+0x164>
 801779e:	f04f 33ff 	mov.w	r3, #4294967295
 80177a2:	6233      	str	r3, [r6, #32]
 80177a4:	e74e      	b.n	8017644 <_mktm_r+0x164>
 80177a6:	2300      	movs	r3, #0
 80177a8:	6233      	str	r3, [r6, #32]
 80177aa:	e74b      	b.n	8017644 <_mktm_r+0x164>
 80177ac:	6972      	ldr	r2, [r6, #20]
 80177ae:	2300      	movs	r3, #0
 80177b0:	3201      	adds	r2, #1
 80177b2:	6172      	str	r2, [r6, #20]
 80177b4:	6133      	str	r3, [r6, #16]
 80177b6:	61f3      	str	r3, [r6, #28]
 80177b8:	e799      	b.n	80176ee <_mktm_r+0x20e>
 80177ba:	bf00      	nop
 80177bc:	c22e4507 	.word	0xc22e4507
 80177c0:	00015180 	.word	0x00015180
 80177c4:	91a2b3c5 	.word	0x91a2b3c5
 80177c8:	88888889 	.word	0x88888889
 80177cc:	92492493 	.word	0x92492493
 80177d0:	0801a7e0 	.word	0x0801a7e0
 80177d4:	51eb851f 	.word	0x51eb851f
 80177d8:	0801a780 	.word	0x0801a780
 80177dc:	20001b88 	.word	0x20001b88
 80177e0:	6973      	ldr	r3, [r6, #20]
 80177e2:	1e5a      	subs	r2, r3, #1
 80177e4:	210b      	movs	r1, #11
 80177e6:	6172      	str	r2, [r6, #20]
 80177e8:	0792      	lsls	r2, r2, #30
 80177ea:	6131      	str	r1, [r6, #16]
 80177ec:	d014      	beq.n	8017818 <_mktm_r+0x338>
 80177ee:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 80177f2:	17da      	asrs	r2, r3, #31
 80177f4:	4910      	ldr	r1, [pc, #64]	; (8017838 <_mktm_r+0x358>)
 80177f6:	fb81 b103 	smull	fp, r1, r1, r3
 80177fa:	ebc2 12e1 	rsb	r2, r2, r1, asr #7
 80177fe:	f44f 71c8 	mov.w	r1, #400	; 0x190
 8017802:	fb01 3312 	mls	r3, r1, r2, r3
 8017806:	f1d3 0301 	rsbs	r3, r3, #1
 801780a:	bf38      	it	cc
 801780c:	2300      	movcc	r3, #0
 801780e:	f503 73b6 	add.w	r3, r3, #364	; 0x16c
 8017812:	61f3      	str	r3, [r6, #28]
 8017814:	232c      	movs	r3, #44	; 0x2c
 8017816:	e7a8      	b.n	801776a <_mktm_r+0x28a>
 8017818:	4907      	ldr	r1, [pc, #28]	; (8017838 <_mktm_r+0x358>)
 801781a:	f203 736b 	addw	r3, r3, #1899	; 0x76b
 801781e:	fb81 4103 	smull	r4, r1, r1, r3
 8017822:	17da      	asrs	r2, r3, #31
 8017824:	ebc2 1161 	rsb	r1, r2, r1, asr #5
 8017828:	2064      	movs	r0, #100	; 0x64
 801782a:	fb00 3111 	mls	r1, r0, r1, r3
 801782e:	2900      	cmp	r1, #0
 8017830:	d0e0      	beq.n	80177f4 <_mktm_r+0x314>
 8017832:	f240 136d 	movw	r3, #365	; 0x16d
 8017836:	e7ec      	b.n	8017812 <_mktm_r+0x332>
 8017838:	51eb851f 	.word	0x51eb851f
 801783c:	00000000 	.word	0x00000000

08017840 <strpbrk>:
 8017840:	b4f0      	push	{r4, r5, r6, r7}
 8017842:	7804      	ldrb	r4, [r0, #0]
 8017844:	b30c      	cbz	r4, 801788a <strpbrk+0x4a>
 8017846:	780e      	ldrb	r6, [r1, #0]
 8017848:	4607      	mov	r7, r0
 801784a:	b1c6      	cbz	r6, 801787e <strpbrk+0x3e>
 801784c:	42a6      	cmp	r6, r4
 801784e:	d010      	beq.n	8017872 <strpbrk+0x32>
 8017850:	1c4b      	adds	r3, r1, #1
 8017852:	e001      	b.n	8017858 <strpbrk+0x18>
 8017854:	4294      	cmp	r4, r2
 8017856:	d00b      	beq.n	8017870 <strpbrk+0x30>
 8017858:	461d      	mov	r5, r3
 801785a:	f813 2b01 	ldrb.w	r2, [r3], #1
 801785e:	2a00      	cmp	r2, #0
 8017860:	d1f8      	bne.n	8017854 <strpbrk+0x14>
 8017862:	7844      	ldrb	r4, [r0, #1]
 8017864:	3001      	adds	r0, #1
 8017866:	2c00      	cmp	r4, #0
 8017868:	d1ee      	bne.n	8017848 <strpbrk+0x8>
 801786a:	782e      	ldrb	r6, [r5, #0]
 801786c:	4607      	mov	r7, r0
 801786e:	e000      	b.n	8017872 <strpbrk+0x32>
 8017870:	4626      	mov	r6, r4
 8017872:	2e00      	cmp	r6, #0
 8017874:	bf14      	ite	ne
 8017876:	4638      	movne	r0, r7
 8017878:	2000      	moveq	r0, #0
 801787a:	bcf0      	pop	{r4, r5, r6, r7}
 801787c:	4770      	bx	lr
 801787e:	7844      	ldrb	r4, [r0, #1]
 8017880:	460d      	mov	r5, r1
 8017882:	3001      	adds	r0, #1
 8017884:	2c00      	cmp	r4, #0
 8017886:	d1df      	bne.n	8017848 <strpbrk+0x8>
 8017888:	e7ef      	b.n	801786a <strpbrk+0x2a>
 801788a:	4620      	mov	r0, r4
 801788c:	bcf0      	pop	{r4, r5, r6, r7}
 801788e:	4770      	bx	lr

08017890 <strspn>:
 8017890:	b4f0      	push	{r4, r5, r6, r7}
 8017892:	7804      	ldrb	r4, [r0, #0]
 8017894:	b1cc      	cbz	r4, 80178ca <strspn+0x3a>
 8017896:	780e      	ldrb	r6, [r1, #0]
 8017898:	4607      	mov	r7, r0
 801789a:	b19e      	cbz	r6, 80178c4 <strspn+0x34>
 801789c:	4605      	mov	r5, r0
 801789e:	42b4      	cmp	r4, r6
 80178a0:	d00a      	beq.n	80178b8 <strspn+0x28>
 80178a2:	460a      	mov	r2, r1
 80178a4:	e001      	b.n	80178aa <strspn+0x1a>
 80178a6:	429c      	cmp	r4, r3
 80178a8:	d006      	beq.n	80178b8 <strspn+0x28>
 80178aa:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 80178ae:	2b00      	cmp	r3, #0
 80178b0:	d1f9      	bne.n	80178a6 <strspn+0x16>
 80178b2:	1a28      	subs	r0, r5, r0
 80178b4:	bcf0      	pop	{r4, r5, r6, r7}
 80178b6:	4770      	bx	lr
 80178b8:	786c      	ldrb	r4, [r5, #1]
 80178ba:	1c7d      	adds	r5, r7, #1
 80178bc:	2c00      	cmp	r4, #0
 80178be:	d0f8      	beq.n	80178b2 <strspn+0x22>
 80178c0:	462f      	mov	r7, r5
 80178c2:	e7ec      	b.n	801789e <strspn+0xe>
 80178c4:	4630      	mov	r0, r6
 80178c6:	bcf0      	pop	{r4, r5, r6, r7}
 80178c8:	4770      	bx	lr
 80178ca:	4620      	mov	r0, r4
 80178cc:	e7f2      	b.n	80178b4 <strspn+0x24>
 80178ce:	bf00      	nop

080178d0 <__tz_lock>:
 80178d0:	4770      	bx	lr
 80178d2:	bf00      	nop
	...

080178e0 <__tz_unlock>:
 80178e0:	4770      	bx	lr
 80178e2:	bf00      	nop
	...

080178f0 <asctime_r>:
 80178f0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80178f2:	f8d0 c014 	ldr.w	ip, [r0, #20]
 80178f6:	6986      	ldr	r6, [r0, #24]
 80178f8:	6905      	ldr	r5, [r0, #16]
 80178fa:	68c4      	ldr	r4, [r0, #12]
 80178fc:	4a0d      	ldr	r2, [pc, #52]	; (8017934 <asctime_r+0x44>)
 80178fe:	4b0e      	ldr	r3, [pc, #56]	; (8017938 <asctime_r+0x48>)
 8017900:	e890 4081 	ldmia.w	r0, {r0, r7, lr}
 8017904:	b087      	sub	sp, #28
 8017906:	eb06 0646 	add.w	r6, r6, r6, lsl #1
 801790a:	9400      	str	r4, [sp, #0]
 801790c:	eb05 0545 	add.w	r5, r5, r5, lsl #1
 8017910:	460c      	mov	r4, r1
 8017912:	f20c 716c 	addw	r1, ip, #1900	; 0x76c
 8017916:	9104      	str	r1, [sp, #16]
 8017918:	9003      	str	r0, [sp, #12]
 801791a:	4432      	add	r2, r6
 801791c:	442b      	add	r3, r5
 801791e:	f8cd e004 	str.w	lr, [sp, #4]
 8017922:	9702      	str	r7, [sp, #8]
 8017924:	4620      	mov	r0, r4
 8017926:	4905      	ldr	r1, [pc, #20]	; (801793c <asctime_r+0x4c>)
 8017928:	f000 f85a 	bl	80179e0 <siprintf>
 801792c:	4620      	mov	r0, r4
 801792e:	b007      	add	sp, #28
 8017930:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8017932:	bf00      	nop
 8017934:	0801a800 	.word	0x0801a800
 8017938:	0801a840 	.word	0x0801a840
 801793c:	0801a820 	.word	0x0801a820

08017940 <div>:
 8017940:	b410      	push	{r4}
 8017942:	2900      	cmp	r1, #0
 8017944:	fb91 f4f2 	sdiv	r4, r1, r2
 8017948:	fb02 1314 	mls	r3, r2, r4, r1
 801794c:	db06      	blt.n	801795c <div+0x1c>
 801794e:	2b00      	cmp	r3, #0
 8017950:	db0e      	blt.n	8017970 <div+0x30>
 8017952:	6004      	str	r4, [r0, #0]
 8017954:	6043      	str	r3, [r0, #4]
 8017956:	f85d 4b04 	ldr.w	r4, [sp], #4
 801795a:	4770      	bx	lr
 801795c:	2b00      	cmp	r3, #0
 801795e:	bfc4      	itt	gt
 8017960:	f104 34ff 	addgt.w	r4, r4, #4294967295
 8017964:	189b      	addgt	r3, r3, r2
 8017966:	6004      	str	r4, [r0, #0]
 8017968:	6043      	str	r3, [r0, #4]
 801796a:	f85d 4b04 	ldr.w	r4, [sp], #4
 801796e:	4770      	bx	lr
 8017970:	3401      	adds	r4, #1
 8017972:	1a9b      	subs	r3, r3, r2
 8017974:	6004      	str	r4, [r0, #0]
 8017976:	6043      	str	r3, [r0, #4]
 8017978:	f85d 4b04 	ldr.w	r4, [sp], #4
 801797c:	4770      	bx	lr
 801797e:	bf00      	nop

08017980 <__gettzinfo>:
 8017980:	4800      	ldr	r0, [pc, #0]	; (8017984 <__gettzinfo+0x4>)
 8017982:	4770      	bx	lr
 8017984:	20000908 	.word	0x20000908
	...

08017990 <_siprintf_r>:
 8017990:	b40c      	push	{r2, r3}
 8017992:	b5f0      	push	{r4, r5, r6, r7, lr}
 8017994:	b09d      	sub	sp, #116	; 0x74
 8017996:	ac22      	add	r4, sp, #136	; 0x88
 8017998:	460e      	mov	r6, r1
 801799a:	f854 2b04 	ldr.w	r2, [r4], #4
 801799e:	9102      	str	r1, [sp, #8]
 80179a0:	4623      	mov	r3, r4
 80179a2:	f44f 7e02 	mov.w	lr, #520	; 0x208
 80179a6:	f06f 4500 	mvn.w	r5, #2147483648	; 0x80000000
 80179aa:	f64f 77ff 	movw	r7, #65535	; 0xffff
 80179ae:	a902      	add	r1, sp, #8
 80179b0:	9606      	str	r6, [sp, #24]
 80179b2:	9401      	str	r4, [sp, #4]
 80179b4:	f8ad e014 	strh.w	lr, [sp, #20]
 80179b8:	9504      	str	r5, [sp, #16]
 80179ba:	9507      	str	r5, [sp, #28]
 80179bc:	f8ad 7016 	strh.w	r7, [sp, #22]
 80179c0:	f000 f8b6 	bl	8017b30 <_svfiprintf_r>
 80179c4:	9b02      	ldr	r3, [sp, #8]
 80179c6:	2200      	movs	r2, #0
 80179c8:	701a      	strb	r2, [r3, #0]
 80179ca:	b01d      	add	sp, #116	; 0x74
 80179cc:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80179d0:	b002      	add	sp, #8
 80179d2:	4770      	bx	lr
	...

080179e0 <siprintf>:
 80179e0:	b40e      	push	{r1, r2, r3}
 80179e2:	b5f0      	push	{r4, r5, r6, r7, lr}
 80179e4:	b09c      	sub	sp, #112	; 0x70
 80179e6:	ab21      	add	r3, sp, #132	; 0x84
 80179e8:	490f      	ldr	r1, [pc, #60]	; (8017a28 <siprintf+0x48>)
 80179ea:	f853 2b04 	ldr.w	r2, [r3], #4
 80179ee:	9301      	str	r3, [sp, #4]
 80179f0:	4605      	mov	r5, r0
 80179f2:	f06f 4400 	mvn.w	r4, #2147483648	; 0x80000000
 80179f6:	6808      	ldr	r0, [r1, #0]
 80179f8:	9502      	str	r5, [sp, #8]
 80179fa:	f44f 7702 	mov.w	r7, #520	; 0x208
 80179fe:	f64f 76ff 	movw	r6, #65535	; 0xffff
 8017a02:	a902      	add	r1, sp, #8
 8017a04:	9506      	str	r5, [sp, #24]
 8017a06:	f8ad 7014 	strh.w	r7, [sp, #20]
 8017a0a:	9404      	str	r4, [sp, #16]
 8017a0c:	9407      	str	r4, [sp, #28]
 8017a0e:	f8ad 6016 	strh.w	r6, [sp, #22]
 8017a12:	f000 f88d 	bl	8017b30 <_svfiprintf_r>
 8017a16:	9b02      	ldr	r3, [sp, #8]
 8017a18:	2200      	movs	r2, #0
 8017a1a:	701a      	strb	r2, [r3, #0]
 8017a1c:	b01c      	add	sp, #112	; 0x70
 8017a1e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 8017a22:	b003      	add	sp, #12
 8017a24:	4770      	bx	lr
 8017a26:	bf00      	nop
 8017a28:	20000d70 	.word	0x20000d70
 8017a2c:	00000000 	.word	0x00000000

08017a30 <__ssprint_r>:
 8017a30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017a34:	6894      	ldr	r4, [r2, #8]
 8017a36:	6816      	ldr	r6, [r2, #0]
 8017a38:	b083      	sub	sp, #12
 8017a3a:	4692      	mov	sl, r2
 8017a3c:	4680      	mov	r8, r0
 8017a3e:	460d      	mov	r5, r1
 8017a40:	2c00      	cmp	r4, #0
 8017a42:	d06f      	beq.n	8017b24 <__ssprint_r+0xf4>
 8017a44:	f04f 0b00 	mov.w	fp, #0
 8017a48:	6808      	ldr	r0, [r1, #0]
 8017a4a:	688b      	ldr	r3, [r1, #8]
 8017a4c:	465c      	mov	r4, fp
 8017a4e:	2c00      	cmp	r4, #0
 8017a50:	d043      	beq.n	8017ada <__ssprint_r+0xaa>
 8017a52:	429c      	cmp	r4, r3
 8017a54:	461f      	mov	r7, r3
 8017a56:	d345      	bcc.n	8017ae4 <__ssprint_r+0xb4>
 8017a58:	89ab      	ldrh	r3, [r5, #12]
 8017a5a:	f413 6f90 	tst.w	r3, #1152	; 0x480
 8017a5e:	d044      	beq.n	8017aea <__ssprint_r+0xba>
 8017a60:	696f      	ldr	r7, [r5, #20]
 8017a62:	6929      	ldr	r1, [r5, #16]
 8017a64:	eb07 0747 	add.w	r7, r7, r7, lsl #1
 8017a68:	eb07 77d7 	add.w	r7, r7, r7, lsr #31
 8017a6c:	ebc1 0900 	rsb	r9, r1, r0
 8017a70:	1c62      	adds	r2, r4, #1
 8017a72:	107f      	asrs	r7, r7, #1
 8017a74:	444a      	add	r2, r9
 8017a76:	4297      	cmp	r7, r2
 8017a78:	bf34      	ite	cc
 8017a7a:	4617      	movcc	r7, r2
 8017a7c:	463a      	movcs	r2, r7
 8017a7e:	055b      	lsls	r3, r3, #21
 8017a80:	d535      	bpl.n	8017aee <__ssprint_r+0xbe>
 8017a82:	4611      	mov	r1, r2
 8017a84:	4640      	mov	r0, r8
 8017a86:	f000 ff13 	bl	80188b0 <_malloc_r>
 8017a8a:	2800      	cmp	r0, #0
 8017a8c:	d039      	beq.n	8017b02 <__ssprint_r+0xd2>
 8017a8e:	6929      	ldr	r1, [r5, #16]
 8017a90:	9001      	str	r0, [sp, #4]
 8017a92:	464a      	mov	r2, r9
 8017a94:	f7fe ff5c 	bl	8016950 <memcpy>
 8017a98:	89aa      	ldrh	r2, [r5, #12]
 8017a9a:	9b01      	ldr	r3, [sp, #4]
 8017a9c:	f422 6290 	bic.w	r2, r2, #1152	; 0x480
 8017aa0:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 8017aa4:	81aa      	strh	r2, [r5, #12]
 8017aa6:	ebc9 0207 	rsb	r2, r9, r7
 8017aaa:	eb03 0009 	add.w	r0, r3, r9
 8017aae:	616f      	str	r7, [r5, #20]
 8017ab0:	612b      	str	r3, [r5, #16]
 8017ab2:	6028      	str	r0, [r5, #0]
 8017ab4:	60aa      	str	r2, [r5, #8]
 8017ab6:	4627      	mov	r7, r4
 8017ab8:	46a1      	mov	r9, r4
 8017aba:	464a      	mov	r2, r9
 8017abc:	4659      	mov	r1, fp
 8017abe:	f001 f9df 	bl	8018e80 <memmove>
 8017ac2:	f8da 2008 	ldr.w	r2, [sl, #8]
 8017ac6:	68ab      	ldr	r3, [r5, #8]
 8017ac8:	6828      	ldr	r0, [r5, #0]
 8017aca:	1bdb      	subs	r3, r3, r7
 8017acc:	4448      	add	r0, r9
 8017ace:	1b14      	subs	r4, r2, r4
 8017ad0:	60ab      	str	r3, [r5, #8]
 8017ad2:	6028      	str	r0, [r5, #0]
 8017ad4:	f8ca 4008 	str.w	r4, [sl, #8]
 8017ad8:	b324      	cbz	r4, 8017b24 <__ssprint_r+0xf4>
 8017ada:	f8d6 b000 	ldr.w	fp, [r6]
 8017ade:	6874      	ldr	r4, [r6, #4]
 8017ae0:	3608      	adds	r6, #8
 8017ae2:	e7b4      	b.n	8017a4e <__ssprint_r+0x1e>
 8017ae4:	4627      	mov	r7, r4
 8017ae6:	46a1      	mov	r9, r4
 8017ae8:	e7e7      	b.n	8017aba <__ssprint_r+0x8a>
 8017aea:	46b9      	mov	r9, r7
 8017aec:	e7e5      	b.n	8017aba <__ssprint_r+0x8a>
 8017aee:	4640      	mov	r0, r8
 8017af0:	f001 fa36 	bl	8018f60 <_realloc_r>
 8017af4:	4603      	mov	r3, r0
 8017af6:	2800      	cmp	r0, #0
 8017af8:	d1d5      	bne.n	8017aa6 <__ssprint_r+0x76>
 8017afa:	4640      	mov	r0, r8
 8017afc:	6929      	ldr	r1, [r5, #16]
 8017afe:	f000 fe07 	bl	8018710 <_free_r>
 8017b02:	89aa      	ldrh	r2, [r5, #12]
 8017b04:	230c      	movs	r3, #12
 8017b06:	f8c8 3000 	str.w	r3, [r8]
 8017b0a:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8017b0e:	2300      	movs	r3, #0
 8017b10:	f04f 30ff 	mov.w	r0, #4294967295
 8017b14:	81aa      	strh	r2, [r5, #12]
 8017b16:	f8ca 3008 	str.w	r3, [sl, #8]
 8017b1a:	f8ca 3004 	str.w	r3, [sl, #4]
 8017b1e:	b003      	add	sp, #12
 8017b20:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8017b24:	4620      	mov	r0, r4
 8017b26:	f8ca 4004 	str.w	r4, [sl, #4]
 8017b2a:	b003      	add	sp, #12
 8017b2c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

08017b30 <_svfiprintf_r>:
 8017b30:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8017b34:	4690      	mov	r8, r2
 8017b36:	898a      	ldrh	r2, [r1, #12]
 8017b38:	b0b1      	sub	sp, #196	; 0xc4
 8017b3a:	468a      	mov	sl, r1
 8017b3c:	0611      	lsls	r1, r2, #24
 8017b3e:	9309      	str	r3, [sp, #36]	; 0x24
 8017b40:	9002      	str	r0, [sp, #8]
 8017b42:	d504      	bpl.n	8017b4e <_svfiprintf_r+0x1e>
 8017b44:	f8da 3010 	ldr.w	r3, [sl, #16]
 8017b48:	2b00      	cmp	r3, #0
 8017b4a:	f000 854c 	beq.w	80185e6 <_svfiprintf_r+0xab6>
 8017b4e:	2300      	movs	r3, #0
 8017b50:	af20      	add	r7, sp, #128	; 0x80
 8017b52:	930b      	str	r3, [sp, #44]	; 0x2c
 8017b54:	9315      	str	r3, [sp, #84]	; 0x54
 8017b56:	9314      	str	r3, [sp, #80]	; 0x50
 8017b58:	9308      	str	r3, [sp, #32]
 8017b5a:	9713      	str	r7, [sp, #76]	; 0x4c
 8017b5c:	463e      	mov	r6, r7
 8017b5e:	f898 3000 	ldrb.w	r3, [r8]
 8017b62:	2b00      	cmp	r3, #0
 8017b64:	f000 839e 	beq.w	80182a4 <_svfiprintf_r+0x774>
 8017b68:	2b25      	cmp	r3, #37	; 0x25
 8017b6a:	f000 839b 	beq.w	80182a4 <_svfiprintf_r+0x774>
 8017b6e:	f108 0201 	add.w	r2, r8, #1
 8017b72:	e001      	b.n	8017b78 <_svfiprintf_r+0x48>
 8017b74:	2b25      	cmp	r3, #37	; 0x25
 8017b76:	d004      	beq.n	8017b82 <_svfiprintf_r+0x52>
 8017b78:	4614      	mov	r4, r2
 8017b7a:	3201      	adds	r2, #1
 8017b7c:	7823      	ldrb	r3, [r4, #0]
 8017b7e:	2b00      	cmp	r3, #0
 8017b80:	d1f8      	bne.n	8017b74 <_svfiprintf_r+0x44>
 8017b82:	ebc8 0504 	rsb	r5, r8, r4
 8017b86:	b17d      	cbz	r5, 8017ba8 <_svfiprintf_r+0x78>
 8017b88:	9b14      	ldr	r3, [sp, #80]	; 0x50
 8017b8a:	9a15      	ldr	r2, [sp, #84]	; 0x54
 8017b8c:	f8c6 8000 	str.w	r8, [r6]
 8017b90:	3301      	adds	r3, #1
 8017b92:	442a      	add	r2, r5
 8017b94:	2b07      	cmp	r3, #7
 8017b96:	6075      	str	r5, [r6, #4]
 8017b98:	9215      	str	r2, [sp, #84]	; 0x54
 8017b9a:	9314      	str	r3, [sp, #80]	; 0x50
 8017b9c:	f300 842d 	bgt.w	80183fa <_svfiprintf_r+0x8ca>
 8017ba0:	3608      	adds	r6, #8
 8017ba2:	9808      	ldr	r0, [sp, #32]
 8017ba4:	4428      	add	r0, r5
 8017ba6:	9008      	str	r0, [sp, #32]
 8017ba8:	7823      	ldrb	r3, [r4, #0]
 8017baa:	2b00      	cmp	r3, #0
 8017bac:	f000 83c7 	beq.w	801833e <_svfiprintf_r+0x80e>
 8017bb0:	2100      	movs	r1, #0
 8017bb2:	f04f 0200 	mov.w	r2, #0
 8017bb6:	f104 0801 	add.w	r8, r4, #1
 8017bba:	7863      	ldrb	r3, [r4, #1]
 8017bbc:	f88d 2047 	strb.w	r2, [sp, #71]	; 0x47
 8017bc0:	f04f 34ff 	mov.w	r4, #4294967295
 8017bc4:	9105      	str	r1, [sp, #20]
 8017bc6:	9101      	str	r1, [sp, #4]
 8017bc8:	9403      	str	r4, [sp, #12]
 8017bca:	4608      	mov	r0, r1
 8017bcc:	f108 0801 	add.w	r8, r8, #1
 8017bd0:	f1a3 0220 	sub.w	r2, r3, #32
 8017bd4:	2a58      	cmp	r2, #88	; 0x58
 8017bd6:	f200 829a 	bhi.w	801810e <_svfiprintf_r+0x5de>
 8017bda:	e8df f012 	tbh	[pc, r2, lsl #1]
 8017bde:	0102      	.short	0x0102
 8017be0:	02980298 	.word	0x02980298
 8017be4:	029800ce 	.word	0x029800ce
 8017be8:	02980298 	.word	0x02980298
 8017bec:	02980298 	.word	0x02980298
 8017bf0:	00590298 	.word	0x00590298
 8017bf4:	029800d5 	.word	0x029800d5
 8017bf8:	02390064 	.word	0x02390064
 8017bfc:	022c0298 	.word	0x022c0298
 8017c00:	021e021e 	.word	0x021e021e
 8017c04:	021e021e 	.word	0x021e021e
 8017c08:	021e021e 	.word	0x021e021e
 8017c0c:	021e021e 	.word	0x021e021e
 8017c10:	0298021e 	.word	0x0298021e
 8017c14:	02980298 	.word	0x02980298
 8017c18:	02980298 	.word	0x02980298
 8017c1c:	02980298 	.word	0x02980298
 8017c20:	02980298 	.word	0x02980298
 8017c24:	02000298 	.word	0x02000298
 8017c28:	02980298 	.word	0x02980298
 8017c2c:	02980298 	.word	0x02980298
 8017c30:	02980298 	.word	0x02980298
 8017c34:	02980298 	.word	0x02980298
 8017c38:	02980298 	.word	0x02980298
 8017c3c:	02980276 	.word	0x02980276
 8017c40:	02980298 	.word	0x02980298
 8017c44:	02980298 	.word	0x02980298
 8017c48:	02980256 	.word	0x02980256
 8017c4c:	01710298 	.word	0x01710298
 8017c50:	02980298 	.word	0x02980298
 8017c54:	02980298 	.word	0x02980298
 8017c58:	02980298 	.word	0x02980298
 8017c5c:	02980298 	.word	0x02980298
 8017c60:	02980298 	.word	0x02980298
 8017c64:	01b30109 	.word	0x01b30109
 8017c68:	02980298 	.word	0x02980298
 8017c6c:	01aa0298 	.word	0x01aa0298
 8017c70:	029801b3 	.word	0x029801b3
 8017c74:	019f0298 	.word	0x019f0298
 8017c78:	018c0298 	.word	0x018c0298
 8017c7c:	00b800a6 	.word	0x00b800a6
 8017c80:	029801f7 	.word	0x029801f7
 8017c84:	029801d1 	.word	0x029801d1
 8017c88:	0298006b 	.word	0x0298006b
 8017c8c:	00d90298 	.word	0x00d90298
 8017c90:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8017c94:	f8dc 0000 	ldr.w	r0, [ip]
 8017c98:	2800      	cmp	r0, #0
 8017c9a:	f10c 0304 	add.w	r3, ip, #4
 8017c9e:	f280 841a 	bge.w	80184d6 <_svfiprintf_r+0x9a6>
 8017ca2:	4240      	negs	r0, r0
 8017ca4:	9309      	str	r3, [sp, #36]	; 0x24
 8017ca6:	9c01      	ldr	r4, [sp, #4]
 8017ca8:	f044 0404 	orr.w	r4, r4, #4
 8017cac:	9401      	str	r4, [sp, #4]
 8017cae:	f898 3000 	ldrb.w	r3, [r8]
 8017cb2:	e78b      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017cb4:	9c01      	ldr	r4, [sp, #4]
 8017cb6:	9005      	str	r0, [sp, #20]
 8017cb8:	06a0      	lsls	r0, r4, #26
 8017cba:	f140 81f1 	bpl.w	80180a0 <_svfiprintf_r+0x570>
 8017cbe:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8017cc0:	1deb      	adds	r3, r5, #7
 8017cc2:	f023 0307 	bic.w	r3, r3, #7
 8017cc6:	f103 0c08 	add.w	ip, r3, #8
 8017cca:	e9d3 4500 	ldrd	r4, r5, [r3]
 8017cce:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8017cd2:	2301      	movs	r3, #1
 8017cd4:	f04f 0100 	mov.w	r1, #0
 8017cd8:	9a03      	ldr	r2, [sp, #12]
 8017cda:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017cde:	2000      	movs	r0, #0
 8017ce0:	9206      	str	r2, [sp, #24]
 8017ce2:	9007      	str	r0, [sp, #28]
 8017ce4:	9903      	ldr	r1, [sp, #12]
 8017ce6:	2900      	cmp	r1, #0
 8017ce8:	db05      	blt.n	8017cf6 <_svfiprintf_r+0x1c6>
 8017cea:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017cee:	f02c 0c80 	bic.w	ip, ip, #128	; 0x80
 8017cf2:	f8cd c004 	str.w	ip, [sp, #4]
 8017cf6:	ea54 0005 	orrs.w	r0, r4, r5
 8017cfa:	f040 82d5 	bne.w	80182a8 <_svfiprintf_r+0x778>
 8017cfe:	9903      	ldr	r1, [sp, #12]
 8017d00:	2900      	cmp	r1, #0
 8017d02:	f040 82d1 	bne.w	80182a8 <_svfiprintf_r+0x778>
 8017d06:	b91b      	cbnz	r3, 8017d10 <_svfiprintf_r+0x1e0>
 8017d08:	9c01      	ldr	r4, [sp, #4]
 8017d0a:	07e2      	lsls	r2, r4, #31
 8017d0c:	f100 830e 	bmi.w	801832c <_svfiprintf_r+0x7fc>
 8017d10:	46b9      	mov	r9, r7
 8017d12:	9c03      	ldr	r4, [sp, #12]
 8017d14:	9d06      	ldr	r5, [sp, #24]
 8017d16:	42a5      	cmp	r5, r4
 8017d18:	bfb8      	it	lt
 8017d1a:	4625      	movlt	r5, r4
 8017d1c:	9c07      	ldr	r4, [sp, #28]
 8017d1e:	9504      	str	r5, [sp, #16]
 8017d20:	2c00      	cmp	r4, #0
 8017d22:	d07b      	beq.n	8017e1c <_svfiprintf_r+0x2ec>
 8017d24:	3501      	adds	r5, #1
 8017d26:	9504      	str	r5, [sp, #16]
 8017d28:	e078      	b.n	8017e1c <_svfiprintf_r+0x2ec>
 8017d2a:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017d2e:	9005      	str	r0, [sp, #20]
 8017d30:	f01c 0320 	ands.w	r3, ip, #32
 8017d34:	f000 81d4 	beq.w	80180e0 <_svfiprintf_r+0x5b0>
 8017d38:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8017d3a:	1de3      	adds	r3, r4, #7
 8017d3c:	f023 0307 	bic.w	r3, r3, #7
 8017d40:	f103 0508 	add.w	r5, r3, #8
 8017d44:	9509      	str	r5, [sp, #36]	; 0x24
 8017d46:	e9d3 4500 	ldrd	r4, r5, [r3]
 8017d4a:	2300      	movs	r3, #0
 8017d4c:	e7c2      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 8017d4e:	9a09      	ldr	r2, [sp, #36]	; 0x24
 8017d50:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017d54:	9005      	str	r0, [sp, #20]
 8017d56:	2330      	movs	r3, #48	; 0x30
 8017d58:	1d15      	adds	r5, r2, #4
 8017d5a:	f88d 3048 	strb.w	r3, [sp, #72]	; 0x48
 8017d5e:	f04c 0c02 	orr.w	ip, ip, #2
 8017d62:	2378      	movs	r3, #120	; 0x78
 8017d64:	48b7      	ldr	r0, [pc, #732]	; (8018044 <_svfiprintf_r+0x514>)
 8017d66:	9509      	str	r5, [sp, #36]	; 0x24
 8017d68:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
 8017d6c:	6814      	ldr	r4, [r2, #0]
 8017d6e:	f8cd c004 	str.w	ip, [sp, #4]
 8017d72:	2500      	movs	r5, #0
 8017d74:	900b      	str	r0, [sp, #44]	; 0x2c
 8017d76:	2302      	movs	r3, #2
 8017d78:	e7ac      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 8017d7a:	9d01      	ldr	r5, [sp, #4]
 8017d7c:	f045 0501 	orr.w	r5, r5, #1
 8017d80:	9501      	str	r5, [sp, #4]
 8017d82:	f898 3000 	ldrb.w	r3, [r8]
 8017d86:	e721      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017d88:	f898 3000 	ldrb.w	r3, [r8]
 8017d8c:	212b      	movs	r1, #43	; 0x2b
 8017d8e:	e71d      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017d90:	9d01      	ldr	r5, [sp, #4]
 8017d92:	4cac      	ldr	r4, [pc, #688]	; (8018044 <_svfiprintf_r+0x514>)
 8017d94:	9005      	str	r0, [sp, #20]
 8017d96:	06aa      	lsls	r2, r5, #26
 8017d98:	940b      	str	r4, [sp, #44]	; 0x2c
 8017d9a:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017d9e:	f140 8098 	bpl.w	8017ed2 <_svfiprintf_r+0x3a2>
 8017da2:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8017da6:	f10c 0207 	add.w	r2, ip, #7
 8017daa:	f022 0207 	bic.w	r2, r2, #7
 8017dae:	f102 0408 	add.w	r4, r2, #8
 8017db2:	9409      	str	r4, [sp, #36]	; 0x24
 8017db4:	e9d2 4500 	ldrd	r4, r5, [r2]
 8017db8:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017dbc:	f01c 0f01 	tst.w	ip, #1
 8017dc0:	f000 81ba 	beq.w	8018138 <_svfiprintf_r+0x608>
 8017dc4:	ea54 0005 	orrs.w	r0, r4, r5
 8017dc8:	f000 81b6 	beq.w	8018138 <_svfiprintf_r+0x608>
 8017dcc:	2230      	movs	r2, #48	; 0x30
 8017dce:	f04c 0c02 	orr.w	ip, ip, #2
 8017dd2:	f88d 3049 	strb.w	r3, [sp, #73]	; 0x49
 8017dd6:	f8cd c004 	str.w	ip, [sp, #4]
 8017dda:	f88d 2048 	strb.w	r2, [sp, #72]	; 0x48
 8017dde:	2302      	movs	r3, #2
 8017de0:	e778      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 8017de2:	f898 3000 	ldrb.w	r3, [r8]
 8017de6:	2900      	cmp	r1, #0
 8017de8:	f47f aef0 	bne.w	8017bcc <_svfiprintf_r+0x9c>
 8017dec:	2120      	movs	r1, #32
 8017dee:	e6ed      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017df0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8017df2:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8017df6:	681b      	ldr	r3, [r3, #0]
 8017df8:	9005      	str	r0, [sp, #20]
 8017dfa:	2401      	movs	r4, #1
 8017dfc:	f04f 0500 	mov.w	r5, #0
 8017e00:	f10c 0c04 	add.w	ip, ip, #4
 8017e04:	9404      	str	r4, [sp, #16]
 8017e06:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
 8017e0a:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 8017e0e:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8017e12:	9406      	str	r4, [sp, #24]
 8017e14:	f10d 0958 	add.w	r9, sp, #88	; 0x58
 8017e18:	2400      	movs	r4, #0
 8017e1a:	9403      	str	r4, [sp, #12]
 8017e1c:	9d01      	ldr	r5, [sp, #4]
 8017e1e:	f015 0502 	ands.w	r5, r5, #2
 8017e22:	9507      	str	r5, [sp, #28]
 8017e24:	d005      	beq.n	8017e32 <_svfiprintf_r+0x302>
 8017e26:	f8dd c010 	ldr.w	ip, [sp, #16]
 8017e2a:	f10c 0c02 	add.w	ip, ip, #2
 8017e2e:	f8cd c010 	str.w	ip, [sp, #16]
 8017e32:	9b01      	ldr	r3, [sp, #4]
 8017e34:	f013 0384 	ands.w	r3, r3, #132	; 0x84
 8017e38:	930a      	str	r3, [sp, #40]	; 0x28
 8017e3a:	f040 817f 	bne.w	801813c <_svfiprintf_r+0x60c>
 8017e3e:	9d05      	ldr	r5, [sp, #20]
 8017e40:	f8dd c010 	ldr.w	ip, [sp, #16]
 8017e44:	ebcc 0405 	rsb	r4, ip, r5
 8017e48:	2c00      	cmp	r4, #0
 8017e4a:	f340 8177 	ble.w	801813c <_svfiprintf_r+0x60c>
 8017e4e:	2c10      	cmp	r4, #16
 8017e50:	9915      	ldr	r1, [sp, #84]	; 0x54
 8017e52:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8017e54:	f8df b1f4 	ldr.w	fp, [pc, #500]	; 801804c <_svfiprintf_r+0x51c>
 8017e58:	dd26      	ble.n	8017ea8 <_svfiprintf_r+0x378>
 8017e5a:	465b      	mov	r3, fp
 8017e5c:	2510      	movs	r5, #16
 8017e5e:	46a3      	mov	fp, r4
 8017e60:	461c      	mov	r4, r3
 8017e62:	e006      	b.n	8017e72 <_svfiprintf_r+0x342>
 8017e64:	f1ab 0b10 	sub.w	fp, fp, #16
 8017e68:	f1bb 0f10 	cmp.w	fp, #16
 8017e6c:	f106 0608 	add.w	r6, r6, #8
 8017e70:	dd17      	ble.n	8017ea2 <_svfiprintf_r+0x372>
 8017e72:	3201      	adds	r2, #1
 8017e74:	3110      	adds	r1, #16
 8017e76:	2a07      	cmp	r2, #7
 8017e78:	9115      	str	r1, [sp, #84]	; 0x54
 8017e7a:	9214      	str	r2, [sp, #80]	; 0x50
 8017e7c:	e886 0030 	stmia.w	r6, {r4, r5}
 8017e80:	ddf0      	ble.n	8017e64 <_svfiprintf_r+0x334>
 8017e82:	9802      	ldr	r0, [sp, #8]
 8017e84:	4651      	mov	r1, sl
 8017e86:	aa13      	add	r2, sp, #76	; 0x4c
 8017e88:	f7ff fdd2 	bl	8017a30 <__ssprint_r>
 8017e8c:	2800      	cmp	r0, #0
 8017e8e:	f040 825d 	bne.w	801834c <_svfiprintf_r+0x81c>
 8017e92:	f1ab 0b10 	sub.w	fp, fp, #16
 8017e96:	f1bb 0f10 	cmp.w	fp, #16
 8017e9a:	9915      	ldr	r1, [sp, #84]	; 0x54
 8017e9c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8017e9e:	463e      	mov	r6, r7
 8017ea0:	dce7      	bgt.n	8017e72 <_svfiprintf_r+0x342>
 8017ea2:	4623      	mov	r3, r4
 8017ea4:	465c      	mov	r4, fp
 8017ea6:	469b      	mov	fp, r3
 8017ea8:	3201      	adds	r2, #1
 8017eaa:	4421      	add	r1, r4
 8017eac:	2a07      	cmp	r2, #7
 8017eae:	9115      	str	r1, [sp, #84]	; 0x54
 8017eb0:	9214      	str	r2, [sp, #80]	; 0x50
 8017eb2:	f8c6 b000 	str.w	fp, [r6]
 8017eb6:	6074      	str	r4, [r6, #4]
 8017eb8:	f300 82ee 	bgt.w	8018498 <_svfiprintf_r+0x968>
 8017ebc:	3608      	adds	r6, #8
 8017ebe:	e13f      	b.n	8018140 <_svfiprintf_r+0x610>
 8017ec0:	9d01      	ldr	r5, [sp, #4]
 8017ec2:	4c61      	ldr	r4, [pc, #388]	; (8018048 <_svfiprintf_r+0x518>)
 8017ec4:	9005      	str	r0, [sp, #20]
 8017ec6:	06aa      	lsls	r2, r5, #26
 8017ec8:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017ecc:	940b      	str	r4, [sp, #44]	; 0x2c
 8017ece:	f53f af68 	bmi.w	8017da2 <_svfiprintf_r+0x272>
 8017ed2:	9d01      	ldr	r5, [sp, #4]
 8017ed4:	06ed      	lsls	r5, r5, #27
 8017ed6:	f100 8330 	bmi.w	801853a <_svfiprintf_r+0xa0a>
 8017eda:	9c01      	ldr	r4, [sp, #4]
 8017edc:	0664      	lsls	r4, r4, #25
 8017ede:	f140 8358 	bpl.w	8018592 <_svfiprintf_r+0xa62>
 8017ee2:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8017ee6:	f8bc 4000 	ldrh.w	r4, [ip]
 8017eea:	f10c 0c04 	add.w	ip, ip, #4
 8017eee:	2500      	movs	r5, #0
 8017ef0:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8017ef4:	e760      	b.n	8017db8 <_svfiprintf_r+0x288>
 8017ef6:	9c01      	ldr	r4, [sp, #4]
 8017ef8:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017efc:	06a4      	lsls	r4, r4, #26
 8017efe:	f100 8326 	bmi.w	801854e <_svfiprintf_r+0xa1e>
 8017f02:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017f06:	f01c 0f10 	tst.w	ip, #16
 8017f0a:	f000 8348 	beq.w	801859e <_svfiprintf_r+0xa6e>
 8017f0e:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8017f10:	9d08      	ldr	r5, [sp, #32]
 8017f12:	6823      	ldr	r3, [r4, #0]
 8017f14:	3404      	adds	r4, #4
 8017f16:	9409      	str	r4, [sp, #36]	; 0x24
 8017f18:	601d      	str	r5, [r3, #0]
 8017f1a:	e620      	b.n	8017b5e <_svfiprintf_r+0x2e>
 8017f1c:	f898 3000 	ldrb.w	r3, [r8]
 8017f20:	2b6c      	cmp	r3, #108	; 0x6c
 8017f22:	4642      	mov	r2, r8
 8017f24:	f000 8320 	beq.w	8018568 <_svfiprintf_r+0xa38>
 8017f28:	9d01      	ldr	r5, [sp, #4]
 8017f2a:	f045 0510 	orr.w	r5, r5, #16
 8017f2e:	9501      	str	r5, [sp, #4]
 8017f30:	e64c      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017f32:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017f36:	f04c 0c40 	orr.w	ip, ip, #64	; 0x40
 8017f3a:	f8cd c004 	str.w	ip, [sp, #4]
 8017f3e:	f898 3000 	ldrb.w	r3, [r8]
 8017f42:	e643      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017f44:	9d01      	ldr	r5, [sp, #4]
 8017f46:	9005      	str	r0, [sp, #20]
 8017f48:	06aa      	lsls	r2, r5, #26
 8017f4a:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017f4e:	d550      	bpl.n	8017ff2 <_svfiprintf_r+0x4c2>
 8017f50:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8017f54:	f10c 0107 	add.w	r1, ip, #7
 8017f58:	f021 0107 	bic.w	r1, r1, #7
 8017f5c:	e9d1 2300 	ldrd	r2, r3, [r1]
 8017f60:	3108      	adds	r1, #8
 8017f62:	9109      	str	r1, [sp, #36]	; 0x24
 8017f64:	4614      	mov	r4, r2
 8017f66:	461d      	mov	r5, r3
 8017f68:	2a00      	cmp	r2, #0
 8017f6a:	f173 0000 	sbcs.w	r0, r3, #0
 8017f6e:	f2c0 82d6 	blt.w	801851e <_svfiprintf_r+0x9ee>
 8017f72:	f89d 1047 	ldrb.w	r1, [sp, #71]	; 0x47
 8017f76:	9a03      	ldr	r2, [sp, #12]
 8017f78:	9107      	str	r1, [sp, #28]
 8017f7a:	9206      	str	r2, [sp, #24]
 8017f7c:	2301      	movs	r3, #1
 8017f7e:	e6b1      	b.n	8017ce4 <_svfiprintf_r+0x1b4>
 8017f80:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8017f82:	9005      	str	r0, [sp, #20]
 8017f84:	f8d4 9000 	ldr.w	r9, [r4]
 8017f88:	f04f 0500 	mov.w	r5, #0
 8017f8c:	f88d 5047 	strb.w	r5, [sp, #71]	; 0x47
 8017f90:	3404      	adds	r4, #4
 8017f92:	9d03      	ldr	r5, [sp, #12]
 8017f94:	f1b9 0f00 	cmp.w	r9, #0
 8017f98:	f000 8319 	beq.w	80185ce <_svfiprintf_r+0xa9e>
 8017f9c:	2d00      	cmp	r5, #0
 8017f9e:	4648      	mov	r0, r9
 8017fa0:	f2c0 830a 	blt.w	80185b8 <_svfiprintf_r+0xa88>
 8017fa4:	2100      	movs	r1, #0
 8017fa6:	462a      	mov	r2, r5
 8017fa8:	f000 ff22 	bl	8018df0 <memchr>
 8017fac:	2800      	cmp	r0, #0
 8017fae:	f000 8334 	beq.w	801861a <_svfiprintf_r+0xaea>
 8017fb2:	ebc9 0000 	rsb	r0, r9, r0
 8017fb6:	42a8      	cmp	r0, r5
 8017fb8:	bfb8      	it	lt
 8017fba:	4605      	movlt	r5, r0
 8017fbc:	9506      	str	r5, [sp, #24]
 8017fbe:	9409      	str	r4, [sp, #36]	; 0x24
 8017fc0:	2500      	movs	r5, #0
 8017fc2:	f89d 4047 	ldrb.w	r4, [sp, #71]	; 0x47
 8017fc6:	9407      	str	r4, [sp, #28]
 8017fc8:	9503      	str	r5, [sp, #12]
 8017fca:	e6a2      	b.n	8017d12 <_svfiprintf_r+0x1e2>
 8017fcc:	f8dd c004 	ldr.w	ip, [sp, #4]
 8017fd0:	f04c 0c20 	orr.w	ip, ip, #32
 8017fd4:	f8cd c004 	str.w	ip, [sp, #4]
 8017fd8:	f898 3000 	ldrb.w	r3, [r8]
 8017fdc:	e5f6      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8017fde:	9c01      	ldr	r4, [sp, #4]
 8017fe0:	9005      	str	r0, [sp, #20]
 8017fe2:	f044 0410 	orr.w	r4, r4, #16
 8017fe6:	9401      	str	r4, [sp, #4]
 8017fe8:	9d01      	ldr	r5, [sp, #4]
 8017fea:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8017fee:	06aa      	lsls	r2, r5, #26
 8017ff0:	d4ae      	bmi.n	8017f50 <_svfiprintf_r+0x420>
 8017ff2:	9c01      	ldr	r4, [sp, #4]
 8017ff4:	06e3      	lsls	r3, r4, #27
 8017ff6:	f100 8282 	bmi.w	80184fe <_svfiprintf_r+0x9ce>
 8017ffa:	9c01      	ldr	r4, [sp, #4]
 8017ffc:	0665      	lsls	r5, r4, #25
 8017ffe:	f140 827e 	bpl.w	80184fe <_svfiprintf_r+0x9ce>
 8018002:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8018006:	f9bc 4000 	ldrsh.w	r4, [ip]
 801800a:	f10c 0c04 	add.w	ip, ip, #4
 801800e:	17e5      	asrs	r5, r4, #31
 8018010:	4622      	mov	r2, r4
 8018012:	462b      	mov	r3, r5
 8018014:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8018018:	e7a6      	b.n	8017f68 <_svfiprintf_r+0x438>
 801801a:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801801e:	2000      	movs	r0, #0
 8018020:	f818 3b01 	ldrb.w	r3, [r8], #1
 8018024:	eb00 0080 	add.w	r0, r0, r0, lsl #2
 8018028:	eb02 0040 	add.w	r0, r2, r0, lsl #1
 801802c:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8018030:	2a09      	cmp	r2, #9
 8018032:	d9f5      	bls.n	8018020 <_svfiprintf_r+0x4f0>
 8018034:	e5cc      	b.n	8017bd0 <_svfiprintf_r+0xa0>
 8018036:	9d01      	ldr	r5, [sp, #4]
 8018038:	f045 0580 	orr.w	r5, r5, #128	; 0x80
 801803c:	9501      	str	r5, [sp, #4]
 801803e:	f898 3000 	ldrb.w	r3, [r8]
 8018042:	e5c3      	b.n	8017bcc <_svfiprintf_r+0x9c>
 8018044:	0801a894 	.word	0x0801a894
 8018048:	0801a880 	.word	0x0801a880
 801804c:	0801a8b0 	.word	0x0801a8b0
 8018050:	f898 3000 	ldrb.w	r3, [r8]
 8018054:	2b2a      	cmp	r3, #42	; 0x2a
 8018056:	f108 0501 	add.w	r5, r8, #1
 801805a:	f000 82ec 	beq.w	8018636 <_svfiprintf_r+0xb06>
 801805e:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8018062:	2a09      	cmp	r2, #9
 8018064:	bf98      	it	ls
 8018066:	2400      	movls	r4, #0
 8018068:	f200 82e0 	bhi.w	801862c <_svfiprintf_r+0xafc>
 801806c:	f815 3b01 	ldrb.w	r3, [r5], #1
 8018070:	eb04 0484 	add.w	r4, r4, r4, lsl #2
 8018074:	eb02 0444 	add.w	r4, r2, r4, lsl #1
 8018078:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 801807c:	2a09      	cmp	r2, #9
 801807e:	d9f5      	bls.n	801806c <_svfiprintf_r+0x53c>
 8018080:	ea44 74e4 	orr.w	r4, r4, r4, asr #31
 8018084:	9403      	str	r4, [sp, #12]
 8018086:	46a8      	mov	r8, r5
 8018088:	e5a2      	b.n	8017bd0 <_svfiprintf_r+0xa0>
 801808a:	f8dd c004 	ldr.w	ip, [sp, #4]
 801808e:	9005      	str	r0, [sp, #20]
 8018090:	f04c 0c10 	orr.w	ip, ip, #16
 8018094:	f8cd c004 	str.w	ip, [sp, #4]
 8018098:	9c01      	ldr	r4, [sp, #4]
 801809a:	06a0      	lsls	r0, r4, #26
 801809c:	f53f ae0f 	bmi.w	8017cbe <_svfiprintf_r+0x18e>
 80180a0:	9c01      	ldr	r4, [sp, #4]
 80180a2:	06e1      	lsls	r1, r4, #27
 80180a4:	f100 8223 	bmi.w	80184ee <_svfiprintf_r+0x9be>
 80180a8:	f8dd c004 	ldr.w	ip, [sp, #4]
 80180ac:	f01c 0f40 	tst.w	ip, #64	; 0x40
 80180b0:	f000 821d 	beq.w	80184ee <_svfiprintf_r+0x9be>
 80180b4:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 80180b8:	f8bc 4000 	ldrh.w	r4, [ip]
 80180bc:	f10c 0c04 	add.w	ip, ip, #4
 80180c0:	2500      	movs	r5, #0
 80180c2:	2301      	movs	r3, #1
 80180c4:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 80180c8:	e604      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 80180ca:	9d01      	ldr	r5, [sp, #4]
 80180cc:	9005      	str	r0, [sp, #20]
 80180ce:	f045 0510 	orr.w	r5, r5, #16
 80180d2:	9501      	str	r5, [sp, #4]
 80180d4:	f8dd c004 	ldr.w	ip, [sp, #4]
 80180d8:	f01c 0320 	ands.w	r3, ip, #32
 80180dc:	f47f ae2c 	bne.w	8017d38 <_svfiprintf_r+0x208>
 80180e0:	f8dd c004 	ldr.w	ip, [sp, #4]
 80180e4:	f01c 0210 	ands.w	r2, ip, #16
 80180e8:	f040 81fa 	bne.w	80184e0 <_svfiprintf_r+0x9b0>
 80180ec:	f8dd c004 	ldr.w	ip, [sp, #4]
 80180f0:	f01c 0340 	ands.w	r3, ip, #64	; 0x40
 80180f4:	f000 81f4 	beq.w	80184e0 <_svfiprintf_r+0x9b0>
 80180f8:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 80180fc:	f8bc 4000 	ldrh.w	r4, [ip]
 8018100:	f10c 0c04 	add.w	ip, ip, #4
 8018104:	4613      	mov	r3, r2
 8018106:	2500      	movs	r5, #0
 8018108:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801810c:	e5e2      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 801810e:	9005      	str	r0, [sp, #20]
 8018110:	f88d 1047 	strb.w	r1, [sp, #71]	; 0x47
 8018114:	2b00      	cmp	r3, #0
 8018116:	f000 8112 	beq.w	801833e <_svfiprintf_r+0x80e>
 801811a:	f04f 0c01 	mov.w	ip, #1
 801811e:	f04f 0000 	mov.w	r0, #0
 8018122:	f8cd c010 	str.w	ip, [sp, #16]
 8018126:	f88d 3058 	strb.w	r3, [sp, #88]	; 0x58
 801812a:	f88d 0047 	strb.w	r0, [sp, #71]	; 0x47
 801812e:	f8cd c018 	str.w	ip, [sp, #24]
 8018132:	f10d 0958 	add.w	r9, sp, #88	; 0x58
 8018136:	e66f      	b.n	8017e18 <_svfiprintf_r+0x2e8>
 8018138:	2302      	movs	r3, #2
 801813a:	e5cb      	b.n	8017cd4 <_svfiprintf_r+0x1a4>
 801813c:	9915      	ldr	r1, [sp, #84]	; 0x54
 801813e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018140:	f89d 3047 	ldrb.w	r3, [sp, #71]	; 0x47
 8018144:	b163      	cbz	r3, 8018160 <_svfiprintf_r+0x630>
 8018146:	3201      	adds	r2, #1
 8018148:	3101      	adds	r1, #1
 801814a:	f10d 0047 	add.w	r0, sp, #71	; 0x47
 801814e:	2301      	movs	r3, #1
 8018150:	2a07      	cmp	r2, #7
 8018152:	9115      	str	r1, [sp, #84]	; 0x54
 8018154:	9214      	str	r2, [sp, #80]	; 0x50
 8018156:	e886 0009 	stmia.w	r6, {r0, r3}
 801815a:	f300 8185 	bgt.w	8018468 <_svfiprintf_r+0x938>
 801815e:	3608      	adds	r6, #8
 8018160:	9b07      	ldr	r3, [sp, #28]
 8018162:	b15b      	cbz	r3, 801817c <_svfiprintf_r+0x64c>
 8018164:	3201      	adds	r2, #1
 8018166:	3102      	adds	r1, #2
 8018168:	a812      	add	r0, sp, #72	; 0x48
 801816a:	2302      	movs	r3, #2
 801816c:	2a07      	cmp	r2, #7
 801816e:	9115      	str	r1, [sp, #84]	; 0x54
 8018170:	9214      	str	r2, [sp, #80]	; 0x50
 8018172:	e886 0009 	stmia.w	r6, {r0, r3}
 8018176:	f300 8183 	bgt.w	8018480 <_svfiprintf_r+0x950>
 801817a:	3608      	adds	r6, #8
 801817c:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 801817e:	2c80      	cmp	r4, #128	; 0x80
 8018180:	f000 80ef 	beq.w	8018362 <_svfiprintf_r+0x832>
 8018184:	9d03      	ldr	r5, [sp, #12]
 8018186:	9b06      	ldr	r3, [sp, #24]
 8018188:	1aec      	subs	r4, r5, r3
 801818a:	2c00      	cmp	r4, #0
 801818c:	dd30      	ble.n	80181f0 <_svfiprintf_r+0x6c0>
 801818e:	2c10      	cmp	r4, #16
 8018190:	4da4      	ldr	r5, [pc, #656]	; (8018424 <_svfiprintf_r+0x8f4>)
 8018192:	dd23      	ble.n	80181dc <_svfiprintf_r+0x6ac>
 8018194:	462b      	mov	r3, r5
 8018196:	f04f 0b10 	mov.w	fp, #16
 801819a:	4625      	mov	r5, r4
 801819c:	461c      	mov	r4, r3
 801819e:	e004      	b.n	80181aa <_svfiprintf_r+0x67a>
 80181a0:	3d10      	subs	r5, #16
 80181a2:	2d10      	cmp	r5, #16
 80181a4:	f106 0608 	add.w	r6, r6, #8
 80181a8:	dd15      	ble.n	80181d6 <_svfiprintf_r+0x6a6>
 80181aa:	3201      	adds	r2, #1
 80181ac:	3110      	adds	r1, #16
 80181ae:	2a07      	cmp	r2, #7
 80181b0:	9115      	str	r1, [sp, #84]	; 0x54
 80181b2:	9214      	str	r2, [sp, #80]	; 0x50
 80181b4:	e886 0810 	stmia.w	r6, {r4, fp}
 80181b8:	ddf2      	ble.n	80181a0 <_svfiprintf_r+0x670>
 80181ba:	9802      	ldr	r0, [sp, #8]
 80181bc:	4651      	mov	r1, sl
 80181be:	aa13      	add	r2, sp, #76	; 0x4c
 80181c0:	f7ff fc36 	bl	8017a30 <__ssprint_r>
 80181c4:	2800      	cmp	r0, #0
 80181c6:	f040 80c1 	bne.w	801834c <_svfiprintf_r+0x81c>
 80181ca:	3d10      	subs	r5, #16
 80181cc:	2d10      	cmp	r5, #16
 80181ce:	9915      	ldr	r1, [sp, #84]	; 0x54
 80181d0:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80181d2:	463e      	mov	r6, r7
 80181d4:	dce9      	bgt.n	80181aa <_svfiprintf_r+0x67a>
 80181d6:	4623      	mov	r3, r4
 80181d8:	462c      	mov	r4, r5
 80181da:	461d      	mov	r5, r3
 80181dc:	3201      	adds	r2, #1
 80181de:	4421      	add	r1, r4
 80181e0:	2a07      	cmp	r2, #7
 80181e2:	9115      	str	r1, [sp, #84]	; 0x54
 80181e4:	9214      	str	r2, [sp, #80]	; 0x50
 80181e6:	6035      	str	r5, [r6, #0]
 80181e8:	6074      	str	r4, [r6, #4]
 80181ea:	f300 8110 	bgt.w	801840e <_svfiprintf_r+0x8de>
 80181ee:	3608      	adds	r6, #8
 80181f0:	9c06      	ldr	r4, [sp, #24]
 80181f2:	f8c6 9000 	str.w	r9, [r6]
 80181f6:	3201      	adds	r2, #1
 80181f8:	4421      	add	r1, r4
 80181fa:	2a07      	cmp	r2, #7
 80181fc:	9115      	str	r1, [sp, #84]	; 0x54
 80181fe:	9214      	str	r2, [sp, #80]	; 0x50
 8018200:	6074      	str	r4, [r6, #4]
 8018202:	f300 80e7 	bgt.w	80183d4 <_svfiprintf_r+0x8a4>
 8018206:	3608      	adds	r6, #8
 8018208:	9d01      	ldr	r5, [sp, #4]
 801820a:	076b      	lsls	r3, r5, #29
 801820c:	d536      	bpl.n	801827c <_svfiprintf_r+0x74c>
 801820e:	9d05      	ldr	r5, [sp, #20]
 8018210:	f8dd c010 	ldr.w	ip, [sp, #16]
 8018214:	ebcc 0405 	rsb	r4, ip, r5
 8018218:	2c00      	cmp	r4, #0
 801821a:	dd2f      	ble.n	801827c <_svfiprintf_r+0x74c>
 801821c:	2c10      	cmp	r4, #16
 801821e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018220:	f8df b204 	ldr.w	fp, [pc, #516]	; 8018428 <_svfiprintf_r+0x8f8>
 8018224:	dd20      	ble.n	8018268 <_svfiprintf_r+0x738>
 8018226:	2510      	movs	r5, #16
 8018228:	460b      	mov	r3, r1
 801822a:	f8dd 9008 	ldr.w	r9, [sp, #8]
 801822e:	e004      	b.n	801823a <_svfiprintf_r+0x70a>
 8018230:	3c10      	subs	r4, #16
 8018232:	2c10      	cmp	r4, #16
 8018234:	f106 0608 	add.w	r6, r6, #8
 8018238:	dd15      	ble.n	8018266 <_svfiprintf_r+0x736>
 801823a:	3201      	adds	r2, #1
 801823c:	3310      	adds	r3, #16
 801823e:	2a07      	cmp	r2, #7
 8018240:	9315      	str	r3, [sp, #84]	; 0x54
 8018242:	9214      	str	r2, [sp, #80]	; 0x50
 8018244:	f8c6 b000 	str.w	fp, [r6]
 8018248:	6075      	str	r5, [r6, #4]
 801824a:	ddf1      	ble.n	8018230 <_svfiprintf_r+0x700>
 801824c:	4648      	mov	r0, r9
 801824e:	4651      	mov	r1, sl
 8018250:	aa13      	add	r2, sp, #76	; 0x4c
 8018252:	f7ff fbed 	bl	8017a30 <__ssprint_r>
 8018256:	2800      	cmp	r0, #0
 8018258:	d178      	bne.n	801834c <_svfiprintf_r+0x81c>
 801825a:	3c10      	subs	r4, #16
 801825c:	2c10      	cmp	r4, #16
 801825e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018260:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018262:	463e      	mov	r6, r7
 8018264:	dce9      	bgt.n	801823a <_svfiprintf_r+0x70a>
 8018266:	4619      	mov	r1, r3
 8018268:	3201      	adds	r2, #1
 801826a:	4421      	add	r1, r4
 801826c:	2a07      	cmp	r2, #7
 801826e:	9115      	str	r1, [sp, #84]	; 0x54
 8018270:	9214      	str	r2, [sp, #80]	; 0x50
 8018272:	f8c6 b000 	str.w	fp, [r6]
 8018276:	6074      	str	r4, [r6, #4]
 8018278:	f300 8123 	bgt.w	80184c2 <_svfiprintf_r+0x992>
 801827c:	9c08      	ldr	r4, [sp, #32]
 801827e:	f8dd c010 	ldr.w	ip, [sp, #16]
 8018282:	9d05      	ldr	r5, [sp, #20]
 8018284:	45ac      	cmp	ip, r5
 8018286:	bfac      	ite	ge
 8018288:	4464      	addge	r4, ip
 801828a:	1964      	addlt	r4, r4, r5
 801828c:	9408      	str	r4, [sp, #32]
 801828e:	2900      	cmp	r1, #0
 8018290:	f040 80aa 	bne.w	80183e8 <_svfiprintf_r+0x8b8>
 8018294:	f898 3000 	ldrb.w	r3, [r8]
 8018298:	2000      	movs	r0, #0
 801829a:	9014      	str	r0, [sp, #80]	; 0x50
 801829c:	463e      	mov	r6, r7
 801829e:	2b00      	cmp	r3, #0
 80182a0:	f47f ac62 	bne.w	8017b68 <_svfiprintf_r+0x38>
 80182a4:	4644      	mov	r4, r8
 80182a6:	e47f      	b.n	8017ba8 <_svfiprintf_r+0x78>
 80182a8:	2b01      	cmp	r3, #1
 80182aa:	f000 80bf 	beq.w	801842c <_svfiprintf_r+0x8fc>
 80182ae:	2b02      	cmp	r3, #2
 80182b0:	f10d 037f 	add.w	r3, sp, #127	; 0x7f
 80182b4:	d11a      	bne.n	80182ec <_svfiprintf_r+0x7bc>
 80182b6:	f8dd c02c 	ldr.w	ip, [sp, #44]	; 0x2c
 80182ba:	4619      	mov	r1, r3
 80182bc:	f004 000f 	and.w	r0, r4, #15
 80182c0:	0922      	lsrs	r2, r4, #4
 80182c2:	ea42 7205 	orr.w	r2, r2, r5, lsl #28
 80182c6:	4689      	mov	r9, r1
 80182c8:	092b      	lsrs	r3, r5, #4
 80182ca:	f81c 1000 	ldrb.w	r1, [ip, r0]
 80182ce:	f889 1000 	strb.w	r1, [r9]
 80182d2:	ea52 0003 	orrs.w	r0, r2, r3
 80182d6:	4614      	mov	r4, r2
 80182d8:	461d      	mov	r5, r3
 80182da:	f109 31ff 	add.w	r1, r9, #4294967295
 80182de:	d1ed      	bne.n	80182bc <_svfiprintf_r+0x78c>
 80182e0:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
 80182e4:	ebc9 0307 	rsb	r3, r9, r7
 80182e8:	9306      	str	r3, [sp, #24]
 80182ea:	e512      	b.n	8017d12 <_svfiprintf_r+0x1e2>
 80182ec:	08e0      	lsrs	r0, r4, #3
 80182ee:	ea40 7045 	orr.w	r0, r0, r5, lsl #29
 80182f2:	f004 0207 	and.w	r2, r4, #7
 80182f6:	08e9      	lsrs	r1, r5, #3
 80182f8:	3230      	adds	r2, #48	; 0x30
 80182fa:	ea50 0c01 	orrs.w	ip, r0, r1
 80182fe:	4699      	mov	r9, r3
 8018300:	701a      	strb	r2, [r3, #0]
 8018302:	4604      	mov	r4, r0
 8018304:	460d      	mov	r5, r1
 8018306:	f103 33ff 	add.w	r3, r3, #4294967295
 801830a:	d1ef      	bne.n	80182ec <_svfiprintf_r+0x7bc>
 801830c:	9c01      	ldr	r4, [sp, #4]
 801830e:	e9cd 010c 	strd	r0, r1, [sp, #48]	; 0x30
 8018312:	07e0      	lsls	r0, r4, #31
 8018314:	4649      	mov	r1, r9
 8018316:	d50e      	bpl.n	8018336 <_svfiprintf_r+0x806>
 8018318:	2a30      	cmp	r2, #48	; 0x30
 801831a:	d0e3      	beq.n	80182e4 <_svfiprintf_r+0x7b4>
 801831c:	4699      	mov	r9, r3
 801831e:	ebc9 0407 	rsb	r4, r9, r7
 8018322:	2330      	movs	r3, #48	; 0x30
 8018324:	9406      	str	r4, [sp, #24]
 8018326:	f801 3c01 	strb.w	r3, [r1, #-1]
 801832a:	e4f2      	b.n	8017d12 <_svfiprintf_r+0x1e2>
 801832c:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
 8018330:	2330      	movs	r3, #48	; 0x30
 8018332:	f809 3d41 	strb.w	r3, [r9, #-65]!
 8018336:	ebc9 0507 	rsb	r5, r9, r7
 801833a:	9506      	str	r5, [sp, #24]
 801833c:	e4e9      	b.n	8017d12 <_svfiprintf_r+0x1e2>
 801833e:	9b15      	ldr	r3, [sp, #84]	; 0x54
 8018340:	b123      	cbz	r3, 801834c <_svfiprintf_r+0x81c>
 8018342:	9802      	ldr	r0, [sp, #8]
 8018344:	4651      	mov	r1, sl
 8018346:	aa13      	add	r2, sp, #76	; 0x4c
 8018348:	f7ff fb72 	bl	8017a30 <__ssprint_r>
 801834c:	f8ba 300c 	ldrh.w	r3, [sl, #12]
 8018350:	9808      	ldr	r0, [sp, #32]
 8018352:	f013 0f40 	tst.w	r3, #64	; 0x40
 8018356:	bf18      	it	ne
 8018358:	f04f 30ff 	movne.w	r0, #4294967295
 801835c:	b031      	add	sp, #196	; 0xc4
 801835e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018362:	9d05      	ldr	r5, [sp, #20]
 8018364:	f8dd c010 	ldr.w	ip, [sp, #16]
 8018368:	ebcc 0405 	rsb	r4, ip, r5
 801836c:	2c00      	cmp	r4, #0
 801836e:	f77f af09 	ble.w	8018184 <_svfiprintf_r+0x654>
 8018372:	2c10      	cmp	r4, #16
 8018374:	4d2b      	ldr	r5, [pc, #172]	; (8018424 <_svfiprintf_r+0x8f4>)
 8018376:	dd22      	ble.n	80183be <_svfiprintf_r+0x88e>
 8018378:	462b      	mov	r3, r5
 801837a:	f04f 0b10 	mov.w	fp, #16
 801837e:	4625      	mov	r5, r4
 8018380:	461c      	mov	r4, r3
 8018382:	e004      	b.n	801838e <_svfiprintf_r+0x85e>
 8018384:	3d10      	subs	r5, #16
 8018386:	2d10      	cmp	r5, #16
 8018388:	f106 0608 	add.w	r6, r6, #8
 801838c:	dd14      	ble.n	80183b8 <_svfiprintf_r+0x888>
 801838e:	3201      	adds	r2, #1
 8018390:	3110      	adds	r1, #16
 8018392:	2a07      	cmp	r2, #7
 8018394:	9115      	str	r1, [sp, #84]	; 0x54
 8018396:	9214      	str	r2, [sp, #80]	; 0x50
 8018398:	e886 0810 	stmia.w	r6, {r4, fp}
 801839c:	ddf2      	ble.n	8018384 <_svfiprintf_r+0x854>
 801839e:	9802      	ldr	r0, [sp, #8]
 80183a0:	4651      	mov	r1, sl
 80183a2:	aa13      	add	r2, sp, #76	; 0x4c
 80183a4:	f7ff fb44 	bl	8017a30 <__ssprint_r>
 80183a8:	2800      	cmp	r0, #0
 80183aa:	d1cf      	bne.n	801834c <_svfiprintf_r+0x81c>
 80183ac:	3d10      	subs	r5, #16
 80183ae:	2d10      	cmp	r5, #16
 80183b0:	9915      	ldr	r1, [sp, #84]	; 0x54
 80183b2:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80183b4:	463e      	mov	r6, r7
 80183b6:	dcea      	bgt.n	801838e <_svfiprintf_r+0x85e>
 80183b8:	4623      	mov	r3, r4
 80183ba:	462c      	mov	r4, r5
 80183bc:	461d      	mov	r5, r3
 80183be:	3201      	adds	r2, #1
 80183c0:	4421      	add	r1, r4
 80183c2:	2a07      	cmp	r2, #7
 80183c4:	9115      	str	r1, [sp, #84]	; 0x54
 80183c6:	9214      	str	r2, [sp, #80]	; 0x50
 80183c8:	6035      	str	r5, [r6, #0]
 80183ca:	6074      	str	r4, [r6, #4]
 80183cc:	f300 80d5 	bgt.w	801857a <_svfiprintf_r+0xa4a>
 80183d0:	3608      	adds	r6, #8
 80183d2:	e6d7      	b.n	8018184 <_svfiprintf_r+0x654>
 80183d4:	9802      	ldr	r0, [sp, #8]
 80183d6:	4651      	mov	r1, sl
 80183d8:	aa13      	add	r2, sp, #76	; 0x4c
 80183da:	f7ff fb29 	bl	8017a30 <__ssprint_r>
 80183de:	2800      	cmp	r0, #0
 80183e0:	d1b4      	bne.n	801834c <_svfiprintf_r+0x81c>
 80183e2:	9915      	ldr	r1, [sp, #84]	; 0x54
 80183e4:	463e      	mov	r6, r7
 80183e6:	e70f      	b.n	8018208 <_svfiprintf_r+0x6d8>
 80183e8:	9802      	ldr	r0, [sp, #8]
 80183ea:	4651      	mov	r1, sl
 80183ec:	aa13      	add	r2, sp, #76	; 0x4c
 80183ee:	f7ff fb1f 	bl	8017a30 <__ssprint_r>
 80183f2:	2800      	cmp	r0, #0
 80183f4:	f43f af4e 	beq.w	8018294 <_svfiprintf_r+0x764>
 80183f8:	e7a8      	b.n	801834c <_svfiprintf_r+0x81c>
 80183fa:	9802      	ldr	r0, [sp, #8]
 80183fc:	4651      	mov	r1, sl
 80183fe:	aa13      	add	r2, sp, #76	; 0x4c
 8018400:	f7ff fb16 	bl	8017a30 <__ssprint_r>
 8018404:	2800      	cmp	r0, #0
 8018406:	d1a1      	bne.n	801834c <_svfiprintf_r+0x81c>
 8018408:	463e      	mov	r6, r7
 801840a:	f7ff bbca 	b.w	8017ba2 <_svfiprintf_r+0x72>
 801840e:	9802      	ldr	r0, [sp, #8]
 8018410:	4651      	mov	r1, sl
 8018412:	aa13      	add	r2, sp, #76	; 0x4c
 8018414:	f7ff fb0c 	bl	8017a30 <__ssprint_r>
 8018418:	2800      	cmp	r0, #0
 801841a:	d197      	bne.n	801834c <_svfiprintf_r+0x81c>
 801841c:	9915      	ldr	r1, [sp, #84]	; 0x54
 801841e:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018420:	463e      	mov	r6, r7
 8018422:	e6e5      	b.n	80181f0 <_svfiprintf_r+0x6c0>
 8018424:	0801a870 	.word	0x0801a870
 8018428:	0801a8b0 	.word	0x0801a8b0
 801842c:	2d00      	cmp	r5, #0
 801842e:	bf08      	it	eq
 8018430:	2c0a      	cmpeq	r4, #10
 8018432:	d33d      	bcc.n	80184b0 <_svfiprintf_r+0x980>
 8018434:	f10d 0b7f 	add.w	fp, sp, #127	; 0x7f
 8018438:	4620      	mov	r0, r4
 801843a:	4629      	mov	r1, r5
 801843c:	220a      	movs	r2, #10
 801843e:	2300      	movs	r3, #0
 8018440:	f7fe fc36 	bl	8016cb0 <__aeabi_uldivmod>
 8018444:	3230      	adds	r2, #48	; 0x30
 8018446:	f88b 2000 	strb.w	r2, [fp]
 801844a:	4620      	mov	r0, r4
 801844c:	4629      	mov	r1, r5
 801844e:	220a      	movs	r2, #10
 8018450:	2300      	movs	r3, #0
 8018452:	f7fe fc2d 	bl	8016cb0 <__aeabi_uldivmod>
 8018456:	4604      	mov	r4, r0
 8018458:	460d      	mov	r5, r1
 801845a:	ea54 0c05 	orrs.w	ip, r4, r5
 801845e:	46d9      	mov	r9, fp
 8018460:	f10b 3bff 	add.w	fp, fp, #4294967295
 8018464:	d1e8      	bne.n	8018438 <_svfiprintf_r+0x908>
 8018466:	e73d      	b.n	80182e4 <_svfiprintf_r+0x7b4>
 8018468:	9802      	ldr	r0, [sp, #8]
 801846a:	4651      	mov	r1, sl
 801846c:	aa13      	add	r2, sp, #76	; 0x4c
 801846e:	f7ff fadf 	bl	8017a30 <__ssprint_r>
 8018472:	2800      	cmp	r0, #0
 8018474:	f47f af6a 	bne.w	801834c <_svfiprintf_r+0x81c>
 8018478:	9915      	ldr	r1, [sp, #84]	; 0x54
 801847a:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801847c:	463e      	mov	r6, r7
 801847e:	e66f      	b.n	8018160 <_svfiprintf_r+0x630>
 8018480:	9802      	ldr	r0, [sp, #8]
 8018482:	4651      	mov	r1, sl
 8018484:	aa13      	add	r2, sp, #76	; 0x4c
 8018486:	f7ff fad3 	bl	8017a30 <__ssprint_r>
 801848a:	2800      	cmp	r0, #0
 801848c:	f47f af5e 	bne.w	801834c <_svfiprintf_r+0x81c>
 8018490:	9915      	ldr	r1, [sp, #84]	; 0x54
 8018492:	9a14      	ldr	r2, [sp, #80]	; 0x50
 8018494:	463e      	mov	r6, r7
 8018496:	e671      	b.n	801817c <_svfiprintf_r+0x64c>
 8018498:	9802      	ldr	r0, [sp, #8]
 801849a:	4651      	mov	r1, sl
 801849c:	aa13      	add	r2, sp, #76	; 0x4c
 801849e:	f7ff fac7 	bl	8017a30 <__ssprint_r>
 80184a2:	2800      	cmp	r0, #0
 80184a4:	f47f af52 	bne.w	801834c <_svfiprintf_r+0x81c>
 80184a8:	9915      	ldr	r1, [sp, #84]	; 0x54
 80184aa:	9a14      	ldr	r2, [sp, #80]	; 0x50
 80184ac:	463e      	mov	r6, r7
 80184ae:	e647      	b.n	8018140 <_svfiprintf_r+0x610>
 80184b0:	f10d 09c0 	add.w	r9, sp, #192	; 0xc0
 80184b4:	3430      	adds	r4, #48	; 0x30
 80184b6:	f809 4d41 	strb.w	r4, [r9, #-65]!
 80184ba:	ebc9 0507 	rsb	r5, r9, r7
 80184be:	9506      	str	r5, [sp, #24]
 80184c0:	e427      	b.n	8017d12 <_svfiprintf_r+0x1e2>
 80184c2:	9802      	ldr	r0, [sp, #8]
 80184c4:	4651      	mov	r1, sl
 80184c6:	aa13      	add	r2, sp, #76	; 0x4c
 80184c8:	f7ff fab2 	bl	8017a30 <__ssprint_r>
 80184cc:	2800      	cmp	r0, #0
 80184ce:	f47f af3d 	bne.w	801834c <_svfiprintf_r+0x81c>
 80184d2:	9915      	ldr	r1, [sp, #84]	; 0x54
 80184d4:	e6d2      	b.n	801827c <_svfiprintf_r+0x74c>
 80184d6:	9309      	str	r3, [sp, #36]	; 0x24
 80184d8:	f898 3000 	ldrb.w	r3, [r8]
 80184dc:	f7ff bb76 	b.w	8017bcc <_svfiprintf_r+0x9c>
 80184e0:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80184e2:	682c      	ldr	r4, [r5, #0]
 80184e4:	3504      	adds	r5, #4
 80184e6:	9509      	str	r5, [sp, #36]	; 0x24
 80184e8:	2500      	movs	r5, #0
 80184ea:	f7ff bbf3 	b.w	8017cd4 <_svfiprintf_r+0x1a4>
 80184ee:	9d09      	ldr	r5, [sp, #36]	; 0x24
 80184f0:	682c      	ldr	r4, [r5, #0]
 80184f2:	3504      	adds	r5, #4
 80184f4:	9509      	str	r5, [sp, #36]	; 0x24
 80184f6:	2301      	movs	r3, #1
 80184f8:	2500      	movs	r5, #0
 80184fa:	f7ff bbeb 	b.w	8017cd4 <_svfiprintf_r+0x1a4>
 80184fe:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8018500:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8018504:	682c      	ldr	r4, [r5, #0]
 8018506:	17e5      	asrs	r5, r4, #31
 8018508:	4622      	mov	r2, r4
 801850a:	462b      	mov	r3, r5
 801850c:	f10c 0c04 	add.w	ip, ip, #4
 8018510:	2a00      	cmp	r2, #0
 8018512:	f173 0000 	sbcs.w	r0, r3, #0
 8018516:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801851a:	f6bf ad2a 	bge.w	8017f72 <_svfiprintf_r+0x442>
 801851e:	f04f 0b2d 	mov.w	fp, #45	; 0x2d
 8018522:	9b03      	ldr	r3, [sp, #12]
 8018524:	9306      	str	r3, [sp, #24]
 8018526:	4264      	negs	r4, r4
 8018528:	eb65 0545 	sbc.w	r5, r5, r5, lsl #1
 801852c:	f88d b047 	strb.w	fp, [sp, #71]	; 0x47
 8018530:	f8cd b01c 	str.w	fp, [sp, #28]
 8018534:	2301      	movs	r3, #1
 8018536:	f7ff bbd5 	b.w	8017ce4 <_svfiprintf_r+0x1b4>
 801853a:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801853e:	f8dc 4000 	ldr.w	r4, [ip]
 8018542:	f10c 0c04 	add.w	ip, ip, #4
 8018546:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 801854a:	2500      	movs	r5, #0
 801854c:	e434      	b.n	8017db8 <_svfiprintf_r+0x288>
 801854e:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8018550:	9c08      	ldr	r4, [sp, #32]
 8018552:	6829      	ldr	r1, [r5, #0]
 8018554:	17e5      	asrs	r5, r4, #31
 8018556:	462b      	mov	r3, r5
 8018558:	9d09      	ldr	r5, [sp, #36]	; 0x24
 801855a:	4622      	mov	r2, r4
 801855c:	3504      	adds	r5, #4
 801855e:	9509      	str	r5, [sp, #36]	; 0x24
 8018560:	e9c1 2300 	strd	r2, r3, [r1]
 8018564:	f7ff bafb 	b.w	8017b5e <_svfiprintf_r+0x2e>
 8018568:	9c01      	ldr	r4, [sp, #4]
 801856a:	7853      	ldrb	r3, [r2, #1]
 801856c:	f044 0420 	orr.w	r4, r4, #32
 8018570:	f108 0801 	add.w	r8, r8, #1
 8018574:	9401      	str	r4, [sp, #4]
 8018576:	f7ff bb29 	b.w	8017bcc <_svfiprintf_r+0x9c>
 801857a:	9802      	ldr	r0, [sp, #8]
 801857c:	4651      	mov	r1, sl
 801857e:	aa13      	add	r2, sp, #76	; 0x4c
 8018580:	f7ff fa56 	bl	8017a30 <__ssprint_r>
 8018584:	2800      	cmp	r0, #0
 8018586:	f47f aee1 	bne.w	801834c <_svfiprintf_r+0x81c>
 801858a:	9915      	ldr	r1, [sp, #84]	; 0x54
 801858c:	9a14      	ldr	r2, [sp, #80]	; 0x50
 801858e:	463e      	mov	r6, r7
 8018590:	e5f8      	b.n	8018184 <_svfiprintf_r+0x654>
 8018592:	9d09      	ldr	r5, [sp, #36]	; 0x24
 8018594:	682c      	ldr	r4, [r5, #0]
 8018596:	3504      	adds	r5, #4
 8018598:	9509      	str	r5, [sp, #36]	; 0x24
 801859a:	2500      	movs	r5, #0
 801859c:	e40c      	b.n	8017db8 <_svfiprintf_r+0x288>
 801859e:	f8dd c004 	ldr.w	ip, [sp, #4]
 80185a2:	f01c 0f40 	tst.w	ip, #64	; 0x40
 80185a6:	d02c      	beq.n	8018602 <_svfiprintf_r+0xad2>
 80185a8:	9c09      	ldr	r4, [sp, #36]	; 0x24
 80185aa:	9d08      	ldr	r5, [sp, #32]
 80185ac:	6823      	ldr	r3, [r4, #0]
 80185ae:	3404      	adds	r4, #4
 80185b0:	9409      	str	r4, [sp, #36]	; 0x24
 80185b2:	801d      	strh	r5, [r3, #0]
 80185b4:	f7ff bad3 	b.w	8017b5e <_svfiprintf_r+0x2e>
 80185b8:	9409      	str	r4, [sp, #36]	; 0x24
 80185ba:	f000 feb9 	bl	8019330 <strlen>
 80185be:	2500      	movs	r5, #0
 80185c0:	f89d 4047 	ldrb.w	r4, [sp, #71]	; 0x47
 80185c4:	9006      	str	r0, [sp, #24]
 80185c6:	9407      	str	r4, [sp, #28]
 80185c8:	9503      	str	r5, [sp, #12]
 80185ca:	f7ff bba2 	b.w	8017d12 <_svfiprintf_r+0x1e2>
 80185ce:	2d06      	cmp	r5, #6
 80185d0:	bf28      	it	cs
 80185d2:	2506      	movcs	r5, #6
 80185d4:	ea25 7ce5 	bic.w	ip, r5, r5, asr #31
 80185d8:	9506      	str	r5, [sp, #24]
 80185da:	9409      	str	r4, [sp, #36]	; 0x24
 80185dc:	f8cd c010 	str.w	ip, [sp, #16]
 80185e0:	f8df 9084 	ldr.w	r9, [pc, #132]	; 8018668 <_svfiprintf_r+0xb38>
 80185e4:	e418      	b.n	8017e18 <_svfiprintf_r+0x2e8>
 80185e6:	2140      	movs	r1, #64	; 0x40
 80185e8:	f000 f962 	bl	80188b0 <_malloc_r>
 80185ec:	f8ca 0000 	str.w	r0, [sl]
 80185f0:	f8ca 0010 	str.w	r0, [sl, #16]
 80185f4:	2800      	cmp	r0, #0
 80185f6:	d031      	beq.n	801865c <_svfiprintf_r+0xb2c>
 80185f8:	2340      	movs	r3, #64	; 0x40
 80185fa:	f8ca 3014 	str.w	r3, [sl, #20]
 80185fe:	f7ff baa6 	b.w	8017b4e <_svfiprintf_r+0x1e>
 8018602:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 8018606:	9c08      	ldr	r4, [sp, #32]
 8018608:	f8dc 3000 	ldr.w	r3, [ip]
 801860c:	f10c 0c04 	add.w	ip, ip, #4
 8018610:	f8cd c024 	str.w	ip, [sp, #36]	; 0x24
 8018614:	601c      	str	r4, [r3, #0]
 8018616:	f7ff baa2 	b.w	8017b5e <_svfiprintf_r+0x2e>
 801861a:	f89d 5047 	ldrb.w	r5, [sp, #71]	; 0x47
 801861e:	9507      	str	r5, [sp, #28]
 8018620:	9d03      	ldr	r5, [sp, #12]
 8018622:	9506      	str	r5, [sp, #24]
 8018624:	9409      	str	r4, [sp, #36]	; 0x24
 8018626:	9003      	str	r0, [sp, #12]
 8018628:	f7ff bb73 	b.w	8017d12 <_svfiprintf_r+0x1e2>
 801862c:	46a8      	mov	r8, r5
 801862e:	2500      	movs	r5, #0
 8018630:	9503      	str	r5, [sp, #12]
 8018632:	f7ff bacd 	b.w	8017bd0 <_svfiprintf_r+0xa0>
 8018636:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8018638:	f8dd c024 	ldr.w	ip, [sp, #36]	; 0x24
 801863c:	6824      	ldr	r4, [r4, #0]
 801863e:	f898 3001 	ldrb.w	r3, [r8, #1]
 8018642:	9403      	str	r4, [sp, #12]
 8018644:	f10c 0204 	add.w	r2, ip, #4
 8018648:	2c00      	cmp	r4, #0
 801864a:	9209      	str	r2, [sp, #36]	; 0x24
 801864c:	46a8      	mov	r8, r5
 801864e:	f6bf aabd 	bge.w	8017bcc <_svfiprintf_r+0x9c>
 8018652:	f04f 34ff 	mov.w	r4, #4294967295
 8018656:	9403      	str	r4, [sp, #12]
 8018658:	f7ff bab8 	b.w	8017bcc <_svfiprintf_r+0x9c>
 801865c:	9c02      	ldr	r4, [sp, #8]
 801865e:	230c      	movs	r3, #12
 8018660:	6023      	str	r3, [r4, #0]
 8018662:	f04f 30ff 	mov.w	r0, #4294967295
 8018666:	e679      	b.n	801835c <_svfiprintf_r+0x82c>
 8018668:	0801a8a8 	.word	0x0801a8a8
 801866c:	00000000 	.word	0x00000000

08018670 <_malloc_trim_r>:
 8018670:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8018672:	4d23      	ldr	r5, [pc, #140]	; (8018700 <_malloc_trim_r+0x90>)
 8018674:	460f      	mov	r7, r1
 8018676:	4604      	mov	r4, r0
 8018678:	f000 fc62 	bl	8018f40 <__malloc_lock>
 801867c:	68ab      	ldr	r3, [r5, #8]
 801867e:	685e      	ldr	r6, [r3, #4]
 8018680:	f026 0603 	bic.w	r6, r6, #3
 8018684:	1bf1      	subs	r1, r6, r7
 8018686:	f601 71ef 	addw	r1, r1, #4079	; 0xfef
 801868a:	f421 617f 	bic.w	r1, r1, #4080	; 0xff0
 801868e:	f021 010f 	bic.w	r1, r1, #15
 8018692:	f5a1 5780 	sub.w	r7, r1, #4096	; 0x1000
 8018696:	f5b7 5f80 	cmp.w	r7, #4096	; 0x1000
 801869a:	db07      	blt.n	80186ac <_malloc_trim_r+0x3c>
 801869c:	4620      	mov	r0, r4
 801869e:	2100      	movs	r1, #0
 80186a0:	f7f9 fb26 	bl	8011cf0 <_sbrk_r>
 80186a4:	68ab      	ldr	r3, [r5, #8]
 80186a6:	4433      	add	r3, r6
 80186a8:	4298      	cmp	r0, r3
 80186aa:	d004      	beq.n	80186b6 <_malloc_trim_r+0x46>
 80186ac:	4620      	mov	r0, r4
 80186ae:	f000 fc4f 	bl	8018f50 <__malloc_unlock>
 80186b2:	2000      	movs	r0, #0
 80186b4:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80186b6:	4620      	mov	r0, r4
 80186b8:	4279      	negs	r1, r7
 80186ba:	f7f9 fb19 	bl	8011cf0 <_sbrk_r>
 80186be:	3001      	adds	r0, #1
 80186c0:	d00d      	beq.n	80186de <_malloc_trim_r+0x6e>
 80186c2:	4b10      	ldr	r3, [pc, #64]	; (8018704 <_malloc_trim_r+0x94>)
 80186c4:	68aa      	ldr	r2, [r5, #8]
 80186c6:	6819      	ldr	r1, [r3, #0]
 80186c8:	1bf6      	subs	r6, r6, r7
 80186ca:	f046 0601 	orr.w	r6, r6, #1
 80186ce:	4620      	mov	r0, r4
 80186d0:	1bc9      	subs	r1, r1, r7
 80186d2:	6056      	str	r6, [r2, #4]
 80186d4:	6019      	str	r1, [r3, #0]
 80186d6:	f000 fc3b 	bl	8018f50 <__malloc_unlock>
 80186da:	2001      	movs	r0, #1
 80186dc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80186de:	4620      	mov	r0, r4
 80186e0:	2100      	movs	r1, #0
 80186e2:	f7f9 fb05 	bl	8011cf0 <_sbrk_r>
 80186e6:	68ab      	ldr	r3, [r5, #8]
 80186e8:	1ac2      	subs	r2, r0, r3
 80186ea:	2a0f      	cmp	r2, #15
 80186ec:	ddde      	ble.n	80186ac <_malloc_trim_r+0x3c>
 80186ee:	4d06      	ldr	r5, [pc, #24]	; (8018708 <_malloc_trim_r+0x98>)
 80186f0:	4904      	ldr	r1, [pc, #16]	; (8018704 <_malloc_trim_r+0x94>)
 80186f2:	682d      	ldr	r5, [r5, #0]
 80186f4:	f042 0201 	orr.w	r2, r2, #1
 80186f8:	1b40      	subs	r0, r0, r5
 80186fa:	605a      	str	r2, [r3, #4]
 80186fc:	6008      	str	r0, [r1, #0]
 80186fe:	e7d5      	b.n	80186ac <_malloc_trim_r+0x3c>
 8018700:	20000d74 	.word	0x20000d74
 8018704:	20001b9c 	.word	0x20001b9c
 8018708:	20001180 	.word	0x20001180
 801870c:	00000000 	.word	0x00000000

08018710 <_free_r>:
 8018710:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8018714:	460d      	mov	r5, r1
 8018716:	4606      	mov	r6, r0
 8018718:	2900      	cmp	r1, #0
 801871a:	d055      	beq.n	80187c8 <_free_r+0xb8>
 801871c:	f000 fc10 	bl	8018f40 <__malloc_lock>
 8018720:	f855 1c04 	ldr.w	r1, [r5, #-4]
 8018724:	f8df c174 	ldr.w	ip, [pc, #372]	; 801889c <_free_r+0x18c>
 8018728:	f021 0301 	bic.w	r3, r1, #1
 801872c:	f1a5 0408 	sub.w	r4, r5, #8
 8018730:	18e2      	adds	r2, r4, r3
 8018732:	f8dc 0008 	ldr.w	r0, [ip, #8]
 8018736:	6857      	ldr	r7, [r2, #4]
 8018738:	4290      	cmp	r0, r2
 801873a:	f027 0703 	bic.w	r7, r7, #3
 801873e:	d069      	beq.n	8018814 <_free_r+0x104>
 8018740:	f011 0101 	ands.w	r1, r1, #1
 8018744:	6057      	str	r7, [r2, #4]
 8018746:	d032      	beq.n	80187ae <_free_r+0x9e>
 8018748:	2100      	movs	r1, #0
 801874a:	19d0      	adds	r0, r2, r7
 801874c:	6840      	ldr	r0, [r0, #4]
 801874e:	07c0      	lsls	r0, r0, #31
 8018750:	d406      	bmi.n	8018760 <_free_r+0x50>
 8018752:	443b      	add	r3, r7
 8018754:	6890      	ldr	r0, [r2, #8]
 8018756:	2900      	cmp	r1, #0
 8018758:	d04e      	beq.n	80187f8 <_free_r+0xe8>
 801875a:	68d2      	ldr	r2, [r2, #12]
 801875c:	60c2      	str	r2, [r0, #12]
 801875e:	6090      	str	r0, [r2, #8]
 8018760:	f043 0201 	orr.w	r2, r3, #1
 8018764:	6062      	str	r2, [r4, #4]
 8018766:	50e3      	str	r3, [r4, r3]
 8018768:	b9e1      	cbnz	r1, 80187a4 <_free_r+0x94>
 801876a:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 801876e:	d32d      	bcc.n	80187cc <_free_r+0xbc>
 8018770:	0a5a      	lsrs	r2, r3, #9
 8018772:	2a04      	cmp	r2, #4
 8018774:	d86a      	bhi.n	801884c <_free_r+0x13c>
 8018776:	0998      	lsrs	r0, r3, #6
 8018778:	3038      	adds	r0, #56	; 0x38
 801877a:	0041      	lsls	r1, r0, #1
 801877c:	eb0c 0c81 	add.w	ip, ip, r1, lsl #2
 8018780:	4946      	ldr	r1, [pc, #280]	; (801889c <_free_r+0x18c>)
 8018782:	f8dc 2008 	ldr.w	r2, [ip, #8]
 8018786:	4562      	cmp	r2, ip
 8018788:	d066      	beq.n	8018858 <_free_r+0x148>
 801878a:	6851      	ldr	r1, [r2, #4]
 801878c:	f021 0103 	bic.w	r1, r1, #3
 8018790:	428b      	cmp	r3, r1
 8018792:	d202      	bcs.n	801879a <_free_r+0x8a>
 8018794:	6892      	ldr	r2, [r2, #8]
 8018796:	4594      	cmp	ip, r2
 8018798:	d1f7      	bne.n	801878a <_free_r+0x7a>
 801879a:	68d3      	ldr	r3, [r2, #12]
 801879c:	60e3      	str	r3, [r4, #12]
 801879e:	60a2      	str	r2, [r4, #8]
 80187a0:	609c      	str	r4, [r3, #8]
 80187a2:	60d4      	str	r4, [r2, #12]
 80187a4:	4630      	mov	r0, r6
 80187a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80187aa:	f000 bbd1 	b.w	8018f50 <__malloc_unlock>
 80187ae:	f855 5c08 	ldr.w	r5, [r5, #-8]
 80187b2:	1b64      	subs	r4, r4, r5
 80187b4:	f10c 0808 	add.w	r8, ip, #8
 80187b8:	68a0      	ldr	r0, [r4, #8]
 80187ba:	4540      	cmp	r0, r8
 80187bc:	442b      	add	r3, r5
 80187be:	d043      	beq.n	8018848 <_free_r+0x138>
 80187c0:	68e5      	ldr	r5, [r4, #12]
 80187c2:	60c5      	str	r5, [r0, #12]
 80187c4:	60a8      	str	r0, [r5, #8]
 80187c6:	e7c0      	b.n	801874a <_free_r+0x3a>
 80187c8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80187cc:	08db      	lsrs	r3, r3, #3
 80187ce:	eb0c 02c3 	add.w	r2, ip, r3, lsl #3
 80187d2:	2501      	movs	r5, #1
 80187d4:	f8dc 0004 	ldr.w	r0, [ip, #4]
 80187d8:	6891      	ldr	r1, [r2, #8]
 80187da:	60a1      	str	r1, [r4, #8]
 80187dc:	109b      	asrs	r3, r3, #2
 80187de:	fa05 f303 	lsl.w	r3, r5, r3
 80187e2:	4318      	orrs	r0, r3
 80187e4:	60e2      	str	r2, [r4, #12]
 80187e6:	f8cc 0004 	str.w	r0, [ip, #4]
 80187ea:	6094      	str	r4, [r2, #8]
 80187ec:	4630      	mov	r0, r6
 80187ee:	60cc      	str	r4, [r1, #12]
 80187f0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80187f4:	f000 bbac 	b.w	8018f50 <__malloc_unlock>
 80187f8:	4d29      	ldr	r5, [pc, #164]	; (80188a0 <_free_r+0x190>)
 80187fa:	42a8      	cmp	r0, r5
 80187fc:	d1ad      	bne.n	801875a <_free_r+0x4a>
 80187fe:	f043 0201 	orr.w	r2, r3, #1
 8018802:	f8cc 4014 	str.w	r4, [ip, #20]
 8018806:	f8cc 4010 	str.w	r4, [ip, #16]
 801880a:	60e0      	str	r0, [r4, #12]
 801880c:	60a0      	str	r0, [r4, #8]
 801880e:	6062      	str	r2, [r4, #4]
 8018810:	50e3      	str	r3, [r4, r3]
 8018812:	e7c7      	b.n	80187a4 <_free_r+0x94>
 8018814:	441f      	add	r7, r3
 8018816:	07cb      	lsls	r3, r1, #31
 8018818:	d407      	bmi.n	801882a <_free_r+0x11a>
 801881a:	f855 3c08 	ldr.w	r3, [r5, #-8]
 801881e:	1ae4      	subs	r4, r4, r3
 8018820:	441f      	add	r7, r3
 8018822:	68a2      	ldr	r2, [r4, #8]
 8018824:	68e3      	ldr	r3, [r4, #12]
 8018826:	60d3      	str	r3, [r2, #12]
 8018828:	609a      	str	r2, [r3, #8]
 801882a:	4b1e      	ldr	r3, [pc, #120]	; (80188a4 <_free_r+0x194>)
 801882c:	681b      	ldr	r3, [r3, #0]
 801882e:	f047 0201 	orr.w	r2, r7, #1
 8018832:	429f      	cmp	r7, r3
 8018834:	6062      	str	r2, [r4, #4]
 8018836:	f8cc 4008 	str.w	r4, [ip, #8]
 801883a:	d3b3      	bcc.n	80187a4 <_free_r+0x94>
 801883c:	4b1a      	ldr	r3, [pc, #104]	; (80188a8 <_free_r+0x198>)
 801883e:	4630      	mov	r0, r6
 8018840:	6819      	ldr	r1, [r3, #0]
 8018842:	f7ff ff15 	bl	8018670 <_malloc_trim_r>
 8018846:	e7ad      	b.n	80187a4 <_free_r+0x94>
 8018848:	2101      	movs	r1, #1
 801884a:	e77e      	b.n	801874a <_free_r+0x3a>
 801884c:	2a14      	cmp	r2, #20
 801884e:	d80c      	bhi.n	801886a <_free_r+0x15a>
 8018850:	f102 005b 	add.w	r0, r2, #91	; 0x5b
 8018854:	0041      	lsls	r1, r0, #1
 8018856:	e791      	b.n	801877c <_free_r+0x6c>
 8018858:	684b      	ldr	r3, [r1, #4]
 801885a:	1080      	asrs	r0, r0, #2
 801885c:	2501      	movs	r5, #1
 801885e:	fa05 f000 	lsl.w	r0, r5, r0
 8018862:	4303      	orrs	r3, r0
 8018864:	604b      	str	r3, [r1, #4]
 8018866:	4613      	mov	r3, r2
 8018868:	e798      	b.n	801879c <_free_r+0x8c>
 801886a:	2a54      	cmp	r2, #84	; 0x54
 801886c:	d803      	bhi.n	8018876 <_free_r+0x166>
 801886e:	0b18      	lsrs	r0, r3, #12
 8018870:	306e      	adds	r0, #110	; 0x6e
 8018872:	0041      	lsls	r1, r0, #1
 8018874:	e782      	b.n	801877c <_free_r+0x6c>
 8018876:	f5b2 7faa 	cmp.w	r2, #340	; 0x154
 801887a:	d803      	bhi.n	8018884 <_free_r+0x174>
 801887c:	0bd8      	lsrs	r0, r3, #15
 801887e:	3077      	adds	r0, #119	; 0x77
 8018880:	0041      	lsls	r1, r0, #1
 8018882:	e77b      	b.n	801877c <_free_r+0x6c>
 8018884:	f240 5154 	movw	r1, #1364	; 0x554
 8018888:	428a      	cmp	r2, r1
 801888a:	d803      	bhi.n	8018894 <_free_r+0x184>
 801888c:	0c98      	lsrs	r0, r3, #18
 801888e:	307c      	adds	r0, #124	; 0x7c
 8018890:	0041      	lsls	r1, r0, #1
 8018892:	e773      	b.n	801877c <_free_r+0x6c>
 8018894:	21fc      	movs	r1, #252	; 0xfc
 8018896:	207e      	movs	r0, #126	; 0x7e
 8018898:	e770      	b.n	801877c <_free_r+0x6c>
 801889a:	bf00      	nop
 801889c:	20000d74 	.word	0x20000d74
 80188a0:	20000d7c 	.word	0x20000d7c
 80188a4:	2000117c 	.word	0x2000117c
 80188a8:	20001b98 	.word	0x20001b98
 80188ac:	00000000 	.word	0x00000000

080188b0 <_malloc_r>:
 80188b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80188b4:	f101 050b 	add.w	r5, r1, #11
 80188b8:	2d16      	cmp	r5, #22
 80188ba:	b083      	sub	sp, #12
 80188bc:	4606      	mov	r6, r0
 80188be:	d927      	bls.n	8018910 <_malloc_r+0x60>
 80188c0:	f035 0507 	bics.w	r5, r5, #7
 80188c4:	d427      	bmi.n	8018916 <_malloc_r+0x66>
 80188c6:	42a9      	cmp	r1, r5
 80188c8:	d825      	bhi.n	8018916 <_malloc_r+0x66>
 80188ca:	4630      	mov	r0, r6
 80188cc:	f000 fb38 	bl	8018f40 <__malloc_lock>
 80188d0:	f5b5 7ffc 	cmp.w	r5, #504	; 0x1f8
 80188d4:	d226      	bcs.n	8018924 <_malloc_r+0x74>
 80188d6:	4fc1      	ldr	r7, [pc, #772]	; (8018bdc <_malloc_r+0x32c>)
 80188d8:	ea4f 0cd5 	mov.w	ip, r5, lsr #3
 80188dc:	eb07 03cc 	add.w	r3, r7, ip, lsl #3
 80188e0:	68dc      	ldr	r4, [r3, #12]
 80188e2:	429c      	cmp	r4, r3
 80188e4:	f000 81d2 	beq.w	8018c8c <_malloc_r+0x3dc>
 80188e8:	6863      	ldr	r3, [r4, #4]
 80188ea:	68e2      	ldr	r2, [r4, #12]
 80188ec:	68a1      	ldr	r1, [r4, #8]
 80188ee:	f023 0303 	bic.w	r3, r3, #3
 80188f2:	4423      	add	r3, r4
 80188f4:	4630      	mov	r0, r6
 80188f6:	685d      	ldr	r5, [r3, #4]
 80188f8:	60ca      	str	r2, [r1, #12]
 80188fa:	f045 0501 	orr.w	r5, r5, #1
 80188fe:	6091      	str	r1, [r2, #8]
 8018900:	605d      	str	r5, [r3, #4]
 8018902:	f000 fb25 	bl	8018f50 <__malloc_unlock>
 8018906:	3408      	adds	r4, #8
 8018908:	4620      	mov	r0, r4
 801890a:	b003      	add	sp, #12
 801890c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018910:	2510      	movs	r5, #16
 8018912:	42a9      	cmp	r1, r5
 8018914:	d9d9      	bls.n	80188ca <_malloc_r+0x1a>
 8018916:	2400      	movs	r4, #0
 8018918:	230c      	movs	r3, #12
 801891a:	4620      	mov	r0, r4
 801891c:	6033      	str	r3, [r6, #0]
 801891e:	b003      	add	sp, #12
 8018920:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018924:	ea5f 2c55 	movs.w	ip, r5, lsr #9
 8018928:	f000 808a 	beq.w	8018a40 <_malloc_r+0x190>
 801892c:	f1bc 0f04 	cmp.w	ip, #4
 8018930:	f200 8160 	bhi.w	8018bf4 <_malloc_r+0x344>
 8018934:	ea4f 1c95 	mov.w	ip, r5, lsr #6
 8018938:	f10c 0c38 	add.w	ip, ip, #56	; 0x38
 801893c:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018940:	4fa6      	ldr	r7, [pc, #664]	; (8018bdc <_malloc_r+0x32c>)
 8018942:	eb07 0181 	add.w	r1, r7, r1, lsl #2
 8018946:	68cc      	ldr	r4, [r1, #12]
 8018948:	42a1      	cmp	r1, r4
 801894a:	d105      	bne.n	8018958 <_malloc_r+0xa8>
 801894c:	e00c      	b.n	8018968 <_malloc_r+0xb8>
 801894e:	2b00      	cmp	r3, #0
 8018950:	da7a      	bge.n	8018a48 <_malloc_r+0x198>
 8018952:	68e4      	ldr	r4, [r4, #12]
 8018954:	42a1      	cmp	r1, r4
 8018956:	d007      	beq.n	8018968 <_malloc_r+0xb8>
 8018958:	6862      	ldr	r2, [r4, #4]
 801895a:	f022 0203 	bic.w	r2, r2, #3
 801895e:	1b53      	subs	r3, r2, r5
 8018960:	2b0f      	cmp	r3, #15
 8018962:	ddf4      	ble.n	801894e <_malloc_r+0x9e>
 8018964:	f10c 3cff 	add.w	ip, ip, #4294967295
 8018968:	f10c 0c01 	add.w	ip, ip, #1
 801896c:	4b9b      	ldr	r3, [pc, #620]	; (8018bdc <_malloc_r+0x32c>)
 801896e:	693c      	ldr	r4, [r7, #16]
 8018970:	f103 0e08 	add.w	lr, r3, #8
 8018974:	4574      	cmp	r4, lr
 8018976:	f000 817e 	beq.w	8018c76 <_malloc_r+0x3c6>
 801897a:	6861      	ldr	r1, [r4, #4]
 801897c:	f021 0103 	bic.w	r1, r1, #3
 8018980:	1b4a      	subs	r2, r1, r5
 8018982:	2a0f      	cmp	r2, #15
 8018984:	f300 8164 	bgt.w	8018c50 <_malloc_r+0x3a0>
 8018988:	2a00      	cmp	r2, #0
 801898a:	f8c3 e014 	str.w	lr, [r3, #20]
 801898e:	f8c3 e010 	str.w	lr, [r3, #16]
 8018992:	da6a      	bge.n	8018a6a <_malloc_r+0x1ba>
 8018994:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8018998:	f080 813a 	bcs.w	8018c10 <_malloc_r+0x360>
 801899c:	08c9      	lsrs	r1, r1, #3
 801899e:	eb03 00c1 	add.w	r0, r3, r1, lsl #3
 80189a2:	ea4f 08a1 	mov.w	r8, r1, asr #2
 80189a6:	685a      	ldr	r2, [r3, #4]
 80189a8:	6881      	ldr	r1, [r0, #8]
 80189aa:	60a1      	str	r1, [r4, #8]
 80189ac:	f04f 0901 	mov.w	r9, #1
 80189b0:	fa09 f808 	lsl.w	r8, r9, r8
 80189b4:	ea48 0202 	orr.w	r2, r8, r2
 80189b8:	60e0      	str	r0, [r4, #12]
 80189ba:	605a      	str	r2, [r3, #4]
 80189bc:	6084      	str	r4, [r0, #8]
 80189be:	60cc      	str	r4, [r1, #12]
 80189c0:	ea4f 03ac 	mov.w	r3, ip, asr #2
 80189c4:	2001      	movs	r0, #1
 80189c6:	4098      	lsls	r0, r3
 80189c8:	4290      	cmp	r0, r2
 80189ca:	d85b      	bhi.n	8018a84 <_malloc_r+0x1d4>
 80189cc:	4202      	tst	r2, r0
 80189ce:	d106      	bne.n	80189de <_malloc_r+0x12e>
 80189d0:	f02c 0c03 	bic.w	ip, ip, #3
 80189d4:	0040      	lsls	r0, r0, #1
 80189d6:	4202      	tst	r2, r0
 80189d8:	f10c 0c04 	add.w	ip, ip, #4
 80189dc:	d0fa      	beq.n	80189d4 <_malloc_r+0x124>
 80189de:	eb07 08cc 	add.w	r8, r7, ip, lsl #3
 80189e2:	4644      	mov	r4, r8
 80189e4:	46e1      	mov	r9, ip
 80189e6:	68e3      	ldr	r3, [r4, #12]
 80189e8:	429c      	cmp	r4, r3
 80189ea:	d107      	bne.n	80189fc <_malloc_r+0x14c>
 80189ec:	e145      	b.n	8018c7a <_malloc_r+0x3ca>
 80189ee:	2a00      	cmp	r2, #0
 80189f0:	f280 8156 	bge.w	8018ca0 <_malloc_r+0x3f0>
 80189f4:	68db      	ldr	r3, [r3, #12]
 80189f6:	429c      	cmp	r4, r3
 80189f8:	f000 813f 	beq.w	8018c7a <_malloc_r+0x3ca>
 80189fc:	6859      	ldr	r1, [r3, #4]
 80189fe:	f021 0103 	bic.w	r1, r1, #3
 8018a02:	1b4a      	subs	r2, r1, r5
 8018a04:	2a0f      	cmp	r2, #15
 8018a06:	ddf2      	ble.n	80189ee <_malloc_r+0x13e>
 8018a08:	461c      	mov	r4, r3
 8018a0a:	f8d3 c00c 	ldr.w	ip, [r3, #12]
 8018a0e:	f854 8f08 	ldr.w	r8, [r4, #8]!
 8018a12:	1959      	adds	r1, r3, r5
 8018a14:	f045 0901 	orr.w	r9, r5, #1
 8018a18:	f042 0501 	orr.w	r5, r2, #1
 8018a1c:	f8c3 9004 	str.w	r9, [r3, #4]
 8018a20:	4630      	mov	r0, r6
 8018a22:	f8c8 c00c 	str.w	ip, [r8, #12]
 8018a26:	f8cc 8008 	str.w	r8, [ip, #8]
 8018a2a:	6179      	str	r1, [r7, #20]
 8018a2c:	6139      	str	r1, [r7, #16]
 8018a2e:	f8c1 e00c 	str.w	lr, [r1, #12]
 8018a32:	f8c1 e008 	str.w	lr, [r1, #8]
 8018a36:	604d      	str	r5, [r1, #4]
 8018a38:	508a      	str	r2, [r1, r2]
 8018a3a:	f000 fa89 	bl	8018f50 <__malloc_unlock>
 8018a3e:	e763      	b.n	8018908 <_malloc_r+0x58>
 8018a40:	217e      	movs	r1, #126	; 0x7e
 8018a42:	f04f 0c3f 	mov.w	ip, #63	; 0x3f
 8018a46:	e77b      	b.n	8018940 <_malloc_r+0x90>
 8018a48:	4422      	add	r2, r4
 8018a4a:	68e3      	ldr	r3, [r4, #12]
 8018a4c:	6850      	ldr	r0, [r2, #4]
 8018a4e:	68a1      	ldr	r1, [r4, #8]
 8018a50:	f040 0501 	orr.w	r5, r0, #1
 8018a54:	60cb      	str	r3, [r1, #12]
 8018a56:	4630      	mov	r0, r6
 8018a58:	6099      	str	r1, [r3, #8]
 8018a5a:	6055      	str	r5, [r2, #4]
 8018a5c:	f000 fa78 	bl	8018f50 <__malloc_unlock>
 8018a60:	3408      	adds	r4, #8
 8018a62:	4620      	mov	r0, r4
 8018a64:	b003      	add	sp, #12
 8018a66:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018a6a:	4421      	add	r1, r4
 8018a6c:	4630      	mov	r0, r6
 8018a6e:	684b      	ldr	r3, [r1, #4]
 8018a70:	f043 0301 	orr.w	r3, r3, #1
 8018a74:	604b      	str	r3, [r1, #4]
 8018a76:	f000 fa6b 	bl	8018f50 <__malloc_unlock>
 8018a7a:	3408      	adds	r4, #8
 8018a7c:	4620      	mov	r0, r4
 8018a7e:	b003      	add	sp, #12
 8018a80:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018a84:	68bc      	ldr	r4, [r7, #8]
 8018a86:	6863      	ldr	r3, [r4, #4]
 8018a88:	f023 0903 	bic.w	r9, r3, #3
 8018a8c:	45a9      	cmp	r9, r5
 8018a8e:	d304      	bcc.n	8018a9a <_malloc_r+0x1ea>
 8018a90:	ebc5 0309 	rsb	r3, r5, r9
 8018a94:	2b0f      	cmp	r3, #15
 8018a96:	f300 8091 	bgt.w	8018bbc <_malloc_r+0x30c>
 8018a9a:	4b51      	ldr	r3, [pc, #324]	; (8018be0 <_malloc_r+0x330>)
 8018a9c:	4a51      	ldr	r2, [pc, #324]	; (8018be4 <_malloc_r+0x334>)
 8018a9e:	6819      	ldr	r1, [r3, #0]
 8018aa0:	6813      	ldr	r3, [r2, #0]
 8018aa2:	3301      	adds	r3, #1
 8018aa4:	eb05 0a01 	add.w	sl, r5, r1
 8018aa8:	eb04 0b09 	add.w	fp, r4, r9
 8018aac:	f000 8161 	beq.w	8018d72 <_malloc_r+0x4c2>
 8018ab0:	f50a 5a80 	add.w	sl, sl, #4096	; 0x1000
 8018ab4:	f10a 0a0f 	add.w	sl, sl, #15
 8018ab8:	f42a 6a7f 	bic.w	sl, sl, #4080	; 0xff0
 8018abc:	f02a 0a0f 	bic.w	sl, sl, #15
 8018ac0:	4630      	mov	r0, r6
 8018ac2:	4651      	mov	r1, sl
 8018ac4:	9201      	str	r2, [sp, #4]
 8018ac6:	f7f9 f913 	bl	8011cf0 <_sbrk_r>
 8018aca:	f1b0 3fff 	cmp.w	r0, #4294967295
 8018ace:	4680      	mov	r8, r0
 8018ad0:	9a01      	ldr	r2, [sp, #4]
 8018ad2:	f000 8100 	beq.w	8018cd6 <_malloc_r+0x426>
 8018ad6:	4583      	cmp	fp, r0
 8018ad8:	f200 80fa 	bhi.w	8018cd0 <_malloc_r+0x420>
 8018adc:	f8df c110 	ldr.w	ip, [pc, #272]	; 8018bf0 <_malloc_r+0x340>
 8018ae0:	f8dc 3000 	ldr.w	r3, [ip]
 8018ae4:	45c3      	cmp	fp, r8
 8018ae6:	4453      	add	r3, sl
 8018ae8:	f8cc 3000 	str.w	r3, [ip]
 8018aec:	f000 814a 	beq.w	8018d84 <_malloc_r+0x4d4>
 8018af0:	6812      	ldr	r2, [r2, #0]
 8018af2:	493c      	ldr	r1, [pc, #240]	; (8018be4 <_malloc_r+0x334>)
 8018af4:	3201      	adds	r2, #1
 8018af6:	bf1b      	ittet	ne
 8018af8:	ebcb 0b08 	rsbne	fp, fp, r8
 8018afc:	445b      	addne	r3, fp
 8018afe:	f8c1 8000 	streq.w	r8, [r1]
 8018b02:	f8cc 3000 	strne.w	r3, [ip]
 8018b06:	f018 0307 	ands.w	r3, r8, #7
 8018b0a:	f000 8113 	beq.w	8018d34 <_malloc_r+0x484>
 8018b0e:	f1c3 0208 	rsb	r2, r3, #8
 8018b12:	f5c3 5380 	rsb	r3, r3, #4096	; 0x1000
 8018b16:	4490      	add	r8, r2
 8018b18:	3308      	adds	r3, #8
 8018b1a:	44c2      	add	sl, r8
 8018b1c:	f3ca 0a0b 	ubfx	sl, sl, #0, #12
 8018b20:	ebca 0a03 	rsb	sl, sl, r3
 8018b24:	4651      	mov	r1, sl
 8018b26:	4630      	mov	r0, r6
 8018b28:	f8cd c004 	str.w	ip, [sp, #4]
 8018b2c:	f7f9 f8e0 	bl	8011cf0 <_sbrk_r>
 8018b30:	1c43      	adds	r3, r0, #1
 8018b32:	f8dd c004 	ldr.w	ip, [sp, #4]
 8018b36:	f000 8135 	beq.w	8018da4 <_malloc_r+0x4f4>
 8018b3a:	ebc8 0200 	rsb	r2, r8, r0
 8018b3e:	4452      	add	r2, sl
 8018b40:	f042 0201 	orr.w	r2, r2, #1
 8018b44:	f8dc 3000 	ldr.w	r3, [ip]
 8018b48:	f8c7 8008 	str.w	r8, [r7, #8]
 8018b4c:	4453      	add	r3, sl
 8018b4e:	42bc      	cmp	r4, r7
 8018b50:	f8c8 2004 	str.w	r2, [r8, #4]
 8018b54:	f8cc 3000 	str.w	r3, [ip]
 8018b58:	f8df a094 	ldr.w	sl, [pc, #148]	; 8018bf0 <_malloc_r+0x340>
 8018b5c:	d015      	beq.n	8018b8a <_malloc_r+0x2da>
 8018b5e:	f1b9 0f0f 	cmp.w	r9, #15
 8018b62:	f240 80ea 	bls.w	8018d3a <_malloc_r+0x48a>
 8018b66:	6861      	ldr	r1, [r4, #4]
 8018b68:	f1a9 020c 	sub.w	r2, r9, #12
 8018b6c:	f022 0207 	bic.w	r2, r2, #7
 8018b70:	f001 0e01 	and.w	lr, r1, #1
 8018b74:	18a1      	adds	r1, r4, r2
 8018b76:	2005      	movs	r0, #5
 8018b78:	ea42 0e0e 	orr.w	lr, r2, lr
 8018b7c:	2a0f      	cmp	r2, #15
 8018b7e:	f8c4 e004 	str.w	lr, [r4, #4]
 8018b82:	6048      	str	r0, [r1, #4]
 8018b84:	6088      	str	r0, [r1, #8]
 8018b86:	f200 8111 	bhi.w	8018dac <_malloc_r+0x4fc>
 8018b8a:	4a17      	ldr	r2, [pc, #92]	; (8018be8 <_malloc_r+0x338>)
 8018b8c:	68bc      	ldr	r4, [r7, #8]
 8018b8e:	6811      	ldr	r1, [r2, #0]
 8018b90:	428b      	cmp	r3, r1
 8018b92:	bf88      	it	hi
 8018b94:	6013      	strhi	r3, [r2, #0]
 8018b96:	4a15      	ldr	r2, [pc, #84]	; (8018bec <_malloc_r+0x33c>)
 8018b98:	6811      	ldr	r1, [r2, #0]
 8018b9a:	428b      	cmp	r3, r1
 8018b9c:	bf88      	it	hi
 8018b9e:	6013      	strhi	r3, [r2, #0]
 8018ba0:	6862      	ldr	r2, [r4, #4]
 8018ba2:	f022 0203 	bic.w	r2, r2, #3
 8018ba6:	4295      	cmp	r5, r2
 8018ba8:	ebc5 0302 	rsb	r3, r5, r2
 8018bac:	d801      	bhi.n	8018bb2 <_malloc_r+0x302>
 8018bae:	2b0f      	cmp	r3, #15
 8018bb0:	dc04      	bgt.n	8018bbc <_malloc_r+0x30c>
 8018bb2:	4630      	mov	r0, r6
 8018bb4:	f000 f9cc 	bl	8018f50 <__malloc_unlock>
 8018bb8:	2400      	movs	r4, #0
 8018bba:	e6a5      	b.n	8018908 <_malloc_r+0x58>
 8018bbc:	1962      	adds	r2, r4, r5
 8018bbe:	f043 0301 	orr.w	r3, r3, #1
 8018bc2:	f045 0501 	orr.w	r5, r5, #1
 8018bc6:	6065      	str	r5, [r4, #4]
 8018bc8:	4630      	mov	r0, r6
 8018bca:	60ba      	str	r2, [r7, #8]
 8018bcc:	6053      	str	r3, [r2, #4]
 8018bce:	f000 f9bf 	bl	8018f50 <__malloc_unlock>
 8018bd2:	3408      	adds	r4, #8
 8018bd4:	4620      	mov	r0, r4
 8018bd6:	b003      	add	sp, #12
 8018bd8:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8018bdc:	20000d74 	.word	0x20000d74
 8018be0:	20001b98 	.word	0x20001b98
 8018be4:	20001180 	.word	0x20001180
 8018be8:	20001b94 	.word	0x20001b94
 8018bec:	20001b90 	.word	0x20001b90
 8018bf0:	20001b9c 	.word	0x20001b9c
 8018bf4:	f1bc 0f14 	cmp.w	ip, #20
 8018bf8:	d961      	bls.n	8018cbe <_malloc_r+0x40e>
 8018bfa:	f1bc 0f54 	cmp.w	ip, #84	; 0x54
 8018bfe:	f200 808f 	bhi.w	8018d20 <_malloc_r+0x470>
 8018c02:	ea4f 3c15 	mov.w	ip, r5, lsr #12
 8018c06:	f10c 0c6e 	add.w	ip, ip, #110	; 0x6e
 8018c0a:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018c0e:	e697      	b.n	8018940 <_malloc_r+0x90>
 8018c10:	0a4b      	lsrs	r3, r1, #9
 8018c12:	2b04      	cmp	r3, #4
 8018c14:	d958      	bls.n	8018cc8 <_malloc_r+0x418>
 8018c16:	2b14      	cmp	r3, #20
 8018c18:	f200 80ae 	bhi.w	8018d78 <_malloc_r+0x4c8>
 8018c1c:	f103 025b 	add.w	r2, r3, #91	; 0x5b
 8018c20:	0050      	lsls	r0, r2, #1
 8018c22:	eb07 0080 	add.w	r0, r7, r0, lsl #2
 8018c26:	f8df 81bc 	ldr.w	r8, [pc, #444]	; 8018de4 <_malloc_r+0x534>
 8018c2a:	6883      	ldr	r3, [r0, #8]
 8018c2c:	4283      	cmp	r3, r0
 8018c2e:	f000 808a 	beq.w	8018d46 <_malloc_r+0x496>
 8018c32:	685a      	ldr	r2, [r3, #4]
 8018c34:	f022 0203 	bic.w	r2, r2, #3
 8018c38:	4291      	cmp	r1, r2
 8018c3a:	d202      	bcs.n	8018c42 <_malloc_r+0x392>
 8018c3c:	689b      	ldr	r3, [r3, #8]
 8018c3e:	4298      	cmp	r0, r3
 8018c40:	d1f7      	bne.n	8018c32 <_malloc_r+0x382>
 8018c42:	68d9      	ldr	r1, [r3, #12]
 8018c44:	687a      	ldr	r2, [r7, #4]
 8018c46:	60e1      	str	r1, [r4, #12]
 8018c48:	60a3      	str	r3, [r4, #8]
 8018c4a:	608c      	str	r4, [r1, #8]
 8018c4c:	60dc      	str	r4, [r3, #12]
 8018c4e:	e6b7      	b.n	80189c0 <_malloc_r+0x110>
 8018c50:	1961      	adds	r1, r4, r5
 8018c52:	f042 0701 	orr.w	r7, r2, #1
 8018c56:	f045 0501 	orr.w	r5, r5, #1
 8018c5a:	6065      	str	r5, [r4, #4]
 8018c5c:	4630      	mov	r0, r6
 8018c5e:	6159      	str	r1, [r3, #20]
 8018c60:	6119      	str	r1, [r3, #16]
 8018c62:	f8c1 e00c 	str.w	lr, [r1, #12]
 8018c66:	f8c1 e008 	str.w	lr, [r1, #8]
 8018c6a:	604f      	str	r7, [r1, #4]
 8018c6c:	508a      	str	r2, [r1, r2]
 8018c6e:	3408      	adds	r4, #8
 8018c70:	f000 f96e 	bl	8018f50 <__malloc_unlock>
 8018c74:	e648      	b.n	8018908 <_malloc_r+0x58>
 8018c76:	685a      	ldr	r2, [r3, #4]
 8018c78:	e6a2      	b.n	80189c0 <_malloc_r+0x110>
 8018c7a:	f109 0901 	add.w	r9, r9, #1
 8018c7e:	f019 0f03 	tst.w	r9, #3
 8018c82:	f104 0408 	add.w	r4, r4, #8
 8018c86:	f47f aeae 	bne.w	80189e6 <_malloc_r+0x136>
 8018c8a:	e02d      	b.n	8018ce8 <_malloc_r+0x438>
 8018c8c:	f104 0308 	add.w	r3, r4, #8
 8018c90:	6964      	ldr	r4, [r4, #20]
 8018c92:	42a3      	cmp	r3, r4
 8018c94:	bf08      	it	eq
 8018c96:	f10c 0c02 	addeq.w	ip, ip, #2
 8018c9a:	f43f ae67 	beq.w	801896c <_malloc_r+0xbc>
 8018c9e:	e623      	b.n	80188e8 <_malloc_r+0x38>
 8018ca0:	4419      	add	r1, r3
 8018ca2:	461c      	mov	r4, r3
 8018ca4:	6848      	ldr	r0, [r1, #4]
 8018ca6:	68db      	ldr	r3, [r3, #12]
 8018ca8:	f854 2f08 	ldr.w	r2, [r4, #8]!
 8018cac:	f040 0501 	orr.w	r5, r0, #1
 8018cb0:	604d      	str	r5, [r1, #4]
 8018cb2:	4630      	mov	r0, r6
 8018cb4:	60d3      	str	r3, [r2, #12]
 8018cb6:	609a      	str	r2, [r3, #8]
 8018cb8:	f000 f94a 	bl	8018f50 <__malloc_unlock>
 8018cbc:	e624      	b.n	8018908 <_malloc_r+0x58>
 8018cbe:	f10c 0c5b 	add.w	ip, ip, #91	; 0x5b
 8018cc2:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018cc6:	e63b      	b.n	8018940 <_malloc_r+0x90>
 8018cc8:	098a      	lsrs	r2, r1, #6
 8018cca:	3238      	adds	r2, #56	; 0x38
 8018ccc:	0050      	lsls	r0, r2, #1
 8018cce:	e7a8      	b.n	8018c22 <_malloc_r+0x372>
 8018cd0:	42bc      	cmp	r4, r7
 8018cd2:	f43f af03 	beq.w	8018adc <_malloc_r+0x22c>
 8018cd6:	68bc      	ldr	r4, [r7, #8]
 8018cd8:	6862      	ldr	r2, [r4, #4]
 8018cda:	f022 0203 	bic.w	r2, r2, #3
 8018cde:	e762      	b.n	8018ba6 <_malloc_r+0x2f6>
 8018ce0:	f8d8 8000 	ldr.w	r8, [r8]
 8018ce4:	4598      	cmp	r8, r3
 8018ce6:	d17b      	bne.n	8018de0 <_malloc_r+0x530>
 8018ce8:	f01c 0f03 	tst.w	ip, #3
 8018cec:	f1a8 0308 	sub.w	r3, r8, #8
 8018cf0:	f10c 3cff 	add.w	ip, ip, #4294967295
 8018cf4:	d1f4      	bne.n	8018ce0 <_malloc_r+0x430>
 8018cf6:	687b      	ldr	r3, [r7, #4]
 8018cf8:	ea23 0300 	bic.w	r3, r3, r0
 8018cfc:	607b      	str	r3, [r7, #4]
 8018cfe:	0040      	lsls	r0, r0, #1
 8018d00:	4298      	cmp	r0, r3
 8018d02:	f63f aebf 	bhi.w	8018a84 <_malloc_r+0x1d4>
 8018d06:	2800      	cmp	r0, #0
 8018d08:	f43f aebc 	beq.w	8018a84 <_malloc_r+0x1d4>
 8018d0c:	4203      	tst	r3, r0
 8018d0e:	46cc      	mov	ip, r9
 8018d10:	f47f ae65 	bne.w	80189de <_malloc_r+0x12e>
 8018d14:	0040      	lsls	r0, r0, #1
 8018d16:	4203      	tst	r3, r0
 8018d18:	f10c 0c04 	add.w	ip, ip, #4
 8018d1c:	d0fa      	beq.n	8018d14 <_malloc_r+0x464>
 8018d1e:	e65e      	b.n	80189de <_malloc_r+0x12e>
 8018d20:	f5bc 7faa 	cmp.w	ip, #340	; 0x154
 8018d24:	d81a      	bhi.n	8018d5c <_malloc_r+0x4ac>
 8018d26:	ea4f 3cd5 	mov.w	ip, r5, lsr #15
 8018d2a:	f10c 0c77 	add.w	ip, ip, #119	; 0x77
 8018d2e:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018d32:	e605      	b.n	8018940 <_malloc_r+0x90>
 8018d34:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8018d38:	e6ef      	b.n	8018b1a <_malloc_r+0x26a>
 8018d3a:	2301      	movs	r3, #1
 8018d3c:	f8c8 3004 	str.w	r3, [r8, #4]
 8018d40:	4644      	mov	r4, r8
 8018d42:	2200      	movs	r2, #0
 8018d44:	e72f      	b.n	8018ba6 <_malloc_r+0x2f6>
 8018d46:	1091      	asrs	r1, r2, #2
 8018d48:	2001      	movs	r0, #1
 8018d4a:	f8d8 2004 	ldr.w	r2, [r8, #4]
 8018d4e:	fa00 f101 	lsl.w	r1, r0, r1
 8018d52:	430a      	orrs	r2, r1
 8018d54:	f8c8 2004 	str.w	r2, [r8, #4]
 8018d58:	4619      	mov	r1, r3
 8018d5a:	e774      	b.n	8018c46 <_malloc_r+0x396>
 8018d5c:	f240 5354 	movw	r3, #1364	; 0x554
 8018d60:	459c      	cmp	ip, r3
 8018d62:	d81b      	bhi.n	8018d9c <_malloc_r+0x4ec>
 8018d64:	ea4f 4c95 	mov.w	ip, r5, lsr #18
 8018d68:	f10c 0c7c 	add.w	ip, ip, #124	; 0x7c
 8018d6c:	ea4f 014c 	mov.w	r1, ip, lsl #1
 8018d70:	e5e6      	b.n	8018940 <_malloc_r+0x90>
 8018d72:	f10a 0a10 	add.w	sl, sl, #16
 8018d76:	e6a3      	b.n	8018ac0 <_malloc_r+0x210>
 8018d78:	2b54      	cmp	r3, #84	; 0x54
 8018d7a:	d81f      	bhi.n	8018dbc <_malloc_r+0x50c>
 8018d7c:	0b0a      	lsrs	r2, r1, #12
 8018d7e:	326e      	adds	r2, #110	; 0x6e
 8018d80:	0050      	lsls	r0, r2, #1
 8018d82:	e74e      	b.n	8018c22 <_malloc_r+0x372>
 8018d84:	f3cb 010b 	ubfx	r1, fp, #0, #12
 8018d88:	2900      	cmp	r1, #0
 8018d8a:	f47f aeb1 	bne.w	8018af0 <_malloc_r+0x240>
 8018d8e:	eb0a 0109 	add.w	r1, sl, r9
 8018d92:	68ba      	ldr	r2, [r7, #8]
 8018d94:	f041 0101 	orr.w	r1, r1, #1
 8018d98:	6051      	str	r1, [r2, #4]
 8018d9a:	e6f6      	b.n	8018b8a <_malloc_r+0x2da>
 8018d9c:	21fc      	movs	r1, #252	; 0xfc
 8018d9e:	f04f 0c7e 	mov.w	ip, #126	; 0x7e
 8018da2:	e5cd      	b.n	8018940 <_malloc_r+0x90>
 8018da4:	2201      	movs	r2, #1
 8018da6:	f04f 0a00 	mov.w	sl, #0
 8018daa:	e6cb      	b.n	8018b44 <_malloc_r+0x294>
 8018dac:	f104 0108 	add.w	r1, r4, #8
 8018db0:	4630      	mov	r0, r6
 8018db2:	f7ff fcad 	bl	8018710 <_free_r>
 8018db6:	f8da 3000 	ldr.w	r3, [sl]
 8018dba:	e6e6      	b.n	8018b8a <_malloc_r+0x2da>
 8018dbc:	f5b3 7faa 	cmp.w	r3, #340	; 0x154
 8018dc0:	d803      	bhi.n	8018dca <_malloc_r+0x51a>
 8018dc2:	0bca      	lsrs	r2, r1, #15
 8018dc4:	3277      	adds	r2, #119	; 0x77
 8018dc6:	0050      	lsls	r0, r2, #1
 8018dc8:	e72b      	b.n	8018c22 <_malloc_r+0x372>
 8018dca:	f240 5254 	movw	r2, #1364	; 0x554
 8018dce:	4293      	cmp	r3, r2
 8018dd0:	d803      	bhi.n	8018dda <_malloc_r+0x52a>
 8018dd2:	0c8a      	lsrs	r2, r1, #18
 8018dd4:	327c      	adds	r2, #124	; 0x7c
 8018dd6:	0050      	lsls	r0, r2, #1
 8018dd8:	e723      	b.n	8018c22 <_malloc_r+0x372>
 8018dda:	20fc      	movs	r0, #252	; 0xfc
 8018ddc:	227e      	movs	r2, #126	; 0x7e
 8018dde:	e720      	b.n	8018c22 <_malloc_r+0x372>
 8018de0:	687b      	ldr	r3, [r7, #4]
 8018de2:	e78c      	b.n	8018cfe <_malloc_r+0x44e>
 8018de4:	20000d74 	.word	0x20000d74
	...

08018df0 <memchr>:
 8018df0:	0783      	lsls	r3, r0, #30
 8018df2:	b470      	push	{r4, r5, r6}
 8018df4:	b2c9      	uxtb	r1, r1
 8018df6:	d03f      	beq.n	8018e78 <memchr+0x88>
 8018df8:	1e54      	subs	r4, r2, #1
 8018dfa:	b32a      	cbz	r2, 8018e48 <memchr+0x58>
 8018dfc:	7803      	ldrb	r3, [r0, #0]
 8018dfe:	428b      	cmp	r3, r1
 8018e00:	d023      	beq.n	8018e4a <memchr+0x5a>
 8018e02:	1c43      	adds	r3, r0, #1
 8018e04:	e004      	b.n	8018e10 <memchr+0x20>
 8018e06:	b1fc      	cbz	r4, 8018e48 <memchr+0x58>
 8018e08:	7804      	ldrb	r4, [r0, #0]
 8018e0a:	428c      	cmp	r4, r1
 8018e0c:	d01d      	beq.n	8018e4a <memchr+0x5a>
 8018e0e:	4614      	mov	r4, r2
 8018e10:	f013 0f03 	tst.w	r3, #3
 8018e14:	4618      	mov	r0, r3
 8018e16:	f104 32ff 	add.w	r2, r4, #4294967295
 8018e1a:	f103 0301 	add.w	r3, r3, #1
 8018e1e:	d1f2      	bne.n	8018e06 <memchr+0x16>
 8018e20:	2c03      	cmp	r4, #3
 8018e22:	d814      	bhi.n	8018e4e <memchr+0x5e>
 8018e24:	1e65      	subs	r5, r4, #1
 8018e26:	b34c      	cbz	r4, 8018e7c <memchr+0x8c>
 8018e28:	7803      	ldrb	r3, [r0, #0]
 8018e2a:	428b      	cmp	r3, r1
 8018e2c:	d00d      	beq.n	8018e4a <memchr+0x5a>
 8018e2e:	1c42      	adds	r2, r0, #1
 8018e30:	2300      	movs	r3, #0
 8018e32:	e002      	b.n	8018e3a <memchr+0x4a>
 8018e34:	7804      	ldrb	r4, [r0, #0]
 8018e36:	428c      	cmp	r4, r1
 8018e38:	d007      	beq.n	8018e4a <memchr+0x5a>
 8018e3a:	42ab      	cmp	r3, r5
 8018e3c:	4610      	mov	r0, r2
 8018e3e:	f103 0301 	add.w	r3, r3, #1
 8018e42:	f102 0201 	add.w	r2, r2, #1
 8018e46:	d1f5      	bne.n	8018e34 <memchr+0x44>
 8018e48:	2000      	movs	r0, #0
 8018e4a:	bc70      	pop	{r4, r5, r6}
 8018e4c:	4770      	bx	lr
 8018e4e:	ea41 2601 	orr.w	r6, r1, r1, lsl #8
 8018e52:	4603      	mov	r3, r0
 8018e54:	ea46 4606 	orr.w	r6, r6, r6, lsl #16
 8018e58:	4618      	mov	r0, r3
 8018e5a:	3304      	adds	r3, #4
 8018e5c:	6802      	ldr	r2, [r0, #0]
 8018e5e:	4072      	eors	r2, r6
 8018e60:	f1a2 3501 	sub.w	r5, r2, #16843009	; 0x1010101
 8018e64:	ea25 0202 	bic.w	r2, r5, r2
 8018e68:	f012 3f80 	tst.w	r2, #2155905152	; 0x80808080
 8018e6c:	d1da      	bne.n	8018e24 <memchr+0x34>
 8018e6e:	3c04      	subs	r4, #4
 8018e70:	2c03      	cmp	r4, #3
 8018e72:	4618      	mov	r0, r3
 8018e74:	d8f0      	bhi.n	8018e58 <memchr+0x68>
 8018e76:	e7d5      	b.n	8018e24 <memchr+0x34>
 8018e78:	4614      	mov	r4, r2
 8018e7a:	e7d1      	b.n	8018e20 <memchr+0x30>
 8018e7c:	4620      	mov	r0, r4
 8018e7e:	e7e4      	b.n	8018e4a <memchr+0x5a>

08018e80 <memmove>:
 8018e80:	4288      	cmp	r0, r1
 8018e82:	b4f0      	push	{r4, r5, r6, r7}
 8018e84:	d910      	bls.n	8018ea8 <memmove+0x28>
 8018e86:	188c      	adds	r4, r1, r2
 8018e88:	42a0      	cmp	r0, r4
 8018e8a:	d20d      	bcs.n	8018ea8 <memmove+0x28>
 8018e8c:	1885      	adds	r5, r0, r2
 8018e8e:	1e53      	subs	r3, r2, #1
 8018e90:	b142      	cbz	r2, 8018ea4 <memmove+0x24>
 8018e92:	4621      	mov	r1, r4
 8018e94:	462a      	mov	r2, r5
 8018e96:	f811 4d01 	ldrb.w	r4, [r1, #-1]!
 8018e9a:	f802 4d01 	strb.w	r4, [r2, #-1]!
 8018e9e:	3b01      	subs	r3, #1
 8018ea0:	1c5c      	adds	r4, r3, #1
 8018ea2:	d1f8      	bne.n	8018e96 <memmove+0x16>
 8018ea4:	bcf0      	pop	{r4, r5, r6, r7}
 8018ea6:	4770      	bx	lr
 8018ea8:	2a0f      	cmp	r2, #15
 8018eaa:	d93f      	bls.n	8018f2c <memmove+0xac>
 8018eac:	ea40 0301 	orr.w	r3, r0, r1
 8018eb0:	079b      	lsls	r3, r3, #30
 8018eb2:	d13f      	bne.n	8018f34 <memmove+0xb4>
 8018eb4:	f1a2 0710 	sub.w	r7, r2, #16
 8018eb8:	093f      	lsrs	r7, r7, #4
 8018eba:	eb00 1607 	add.w	r6, r0, r7, lsl #4
 8018ebe:	3610      	adds	r6, #16
 8018ec0:	460c      	mov	r4, r1
 8018ec2:	4603      	mov	r3, r0
 8018ec4:	6825      	ldr	r5, [r4, #0]
 8018ec6:	601d      	str	r5, [r3, #0]
 8018ec8:	6865      	ldr	r5, [r4, #4]
 8018eca:	605d      	str	r5, [r3, #4]
 8018ecc:	68a5      	ldr	r5, [r4, #8]
 8018ece:	609d      	str	r5, [r3, #8]
 8018ed0:	68e5      	ldr	r5, [r4, #12]
 8018ed2:	60dd      	str	r5, [r3, #12]
 8018ed4:	3310      	adds	r3, #16
 8018ed6:	42b3      	cmp	r3, r6
 8018ed8:	f104 0410 	add.w	r4, r4, #16
 8018edc:	d1f2      	bne.n	8018ec4 <memmove+0x44>
 8018ede:	1c7b      	adds	r3, r7, #1
 8018ee0:	f002 0c0f 	and.w	ip, r2, #15
 8018ee4:	011b      	lsls	r3, r3, #4
 8018ee6:	f1bc 0f03 	cmp.w	ip, #3
 8018eea:	4419      	add	r1, r3
 8018eec:	4403      	add	r3, r0
 8018eee:	d923      	bls.n	8018f38 <memmove+0xb8>
 8018ef0:	460e      	mov	r6, r1
 8018ef2:	461d      	mov	r5, r3
 8018ef4:	4664      	mov	r4, ip
 8018ef6:	3c04      	subs	r4, #4
 8018ef8:	f856 7b04 	ldr.w	r7, [r6], #4
 8018efc:	f845 7b04 	str.w	r7, [r5], #4
 8018f00:	2c03      	cmp	r4, #3
 8018f02:	d8f8      	bhi.n	8018ef6 <memmove+0x76>
 8018f04:	f1ac 0404 	sub.w	r4, ip, #4
 8018f08:	f024 0403 	bic.w	r4, r4, #3
 8018f0c:	3404      	adds	r4, #4
 8018f0e:	f002 0203 	and.w	r2, r2, #3
 8018f12:	4423      	add	r3, r4
 8018f14:	4421      	add	r1, r4
 8018f16:	2a00      	cmp	r2, #0
 8018f18:	d0c4      	beq.n	8018ea4 <memmove+0x24>
 8018f1a:	441a      	add	r2, r3
 8018f1c:	f811 4b01 	ldrb.w	r4, [r1], #1
 8018f20:	f803 4b01 	strb.w	r4, [r3], #1
 8018f24:	4293      	cmp	r3, r2
 8018f26:	d1f9      	bne.n	8018f1c <memmove+0x9c>
 8018f28:	bcf0      	pop	{r4, r5, r6, r7}
 8018f2a:	4770      	bx	lr
 8018f2c:	4603      	mov	r3, r0
 8018f2e:	2a00      	cmp	r2, #0
 8018f30:	d1f3      	bne.n	8018f1a <memmove+0x9a>
 8018f32:	e7b7      	b.n	8018ea4 <memmove+0x24>
 8018f34:	4603      	mov	r3, r0
 8018f36:	e7f0      	b.n	8018f1a <memmove+0x9a>
 8018f38:	4662      	mov	r2, ip
 8018f3a:	2a00      	cmp	r2, #0
 8018f3c:	d1ed      	bne.n	8018f1a <memmove+0x9a>
 8018f3e:	e7b1      	b.n	8018ea4 <memmove+0x24>

08018f40 <__malloc_lock>:
 8018f40:	4770      	bx	lr
 8018f42:	bf00      	nop
	...

08018f50 <__malloc_unlock>:
 8018f50:	4770      	bx	lr
 8018f52:	bf00      	nop
	...

08018f60 <_realloc_r>:
 8018f60:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8018f64:	460c      	mov	r4, r1
 8018f66:	b083      	sub	sp, #12
 8018f68:	4690      	mov	r8, r2
 8018f6a:	4681      	mov	r9, r0
 8018f6c:	2900      	cmp	r1, #0
 8018f6e:	f000 80e2 	beq.w	8019136 <_realloc_r+0x1d6>
 8018f72:	f7ff ffe5 	bl	8018f40 <__malloc_lock>
 8018f76:	f108 060b 	add.w	r6, r8, #11
 8018f7a:	f854 3c04 	ldr.w	r3, [r4, #-4]
 8018f7e:	2e16      	cmp	r6, #22
 8018f80:	f023 0503 	bic.w	r5, r3, #3
 8018f84:	f1a4 0708 	sub.w	r7, r4, #8
 8018f88:	d84b      	bhi.n	8019022 <_realloc_r+0xc2>
 8018f8a:	2110      	movs	r1, #16
 8018f8c:	460e      	mov	r6, r1
 8018f8e:	45b0      	cmp	r8, r6
 8018f90:	d84c      	bhi.n	801902c <_realloc_r+0xcc>
 8018f92:	428d      	cmp	r5, r1
 8018f94:	da78      	bge.n	8019088 <_realloc_r+0x128>
 8018f96:	f8df b390 	ldr.w	fp, [pc, #912]	; 8019328 <_realloc_r+0x3c8>
 8018f9a:	f8db e008 	ldr.w	lr, [fp, #8]
 8018f9e:	1978      	adds	r0, r7, r5
 8018fa0:	4586      	cmp	lr, r0
 8018fa2:	f000 80ce 	beq.w	8019142 <_realloc_r+0x1e2>
 8018fa6:	6842      	ldr	r2, [r0, #4]
 8018fa8:	f022 0c01 	bic.w	ip, r2, #1
 8018fac:	4484      	add	ip, r0
 8018fae:	f8dc c004 	ldr.w	ip, [ip, #4]
 8018fb2:	f01c 0f01 	tst.w	ip, #1
 8018fb6:	d07a      	beq.n	80190ae <_realloc_r+0x14e>
 8018fb8:	2200      	movs	r2, #0
 8018fba:	4610      	mov	r0, r2
 8018fbc:	07db      	lsls	r3, r3, #31
 8018fbe:	f100 8092 	bmi.w	80190e6 <_realloc_r+0x186>
 8018fc2:	f854 3c08 	ldr.w	r3, [r4, #-8]
 8018fc6:	ebc3 0a07 	rsb	sl, r3, r7
 8018fca:	f8da 3004 	ldr.w	r3, [sl, #4]
 8018fce:	f023 0303 	bic.w	r3, r3, #3
 8018fd2:	442b      	add	r3, r5
 8018fd4:	b388      	cbz	r0, 801903a <_realloc_r+0xda>
 8018fd6:	4570      	cmp	r0, lr
 8018fd8:	f000 80ed 	beq.w	80191b6 <_realloc_r+0x256>
 8018fdc:	eb02 0e03 	add.w	lr, r2, r3
 8018fe0:	458e      	cmp	lr, r1
 8018fe2:	db2a      	blt.n	801903a <_realloc_r+0xda>
 8018fe4:	68c3      	ldr	r3, [r0, #12]
 8018fe6:	6882      	ldr	r2, [r0, #8]
 8018fe8:	4657      	mov	r7, sl
 8018fea:	60d3      	str	r3, [r2, #12]
 8018fec:	609a      	str	r2, [r3, #8]
 8018fee:	f857 1f08 	ldr.w	r1, [r7, #8]!
 8018ff2:	f8da 300c 	ldr.w	r3, [sl, #12]
 8018ff6:	60cb      	str	r3, [r1, #12]
 8018ff8:	1f2a      	subs	r2, r5, #4
 8018ffa:	2a24      	cmp	r2, #36	; 0x24
 8018ffc:	6099      	str	r1, [r3, #8]
 8018ffe:	f200 8126 	bhi.w	801924e <_realloc_r+0x2ee>
 8019002:	2a13      	cmp	r2, #19
 8019004:	f240 80b3 	bls.w	801916e <_realloc_r+0x20e>
 8019008:	6823      	ldr	r3, [r4, #0]
 801900a:	f8ca 3008 	str.w	r3, [sl, #8]
 801900e:	6863      	ldr	r3, [r4, #4]
 8019010:	f8ca 300c 	str.w	r3, [sl, #12]
 8019014:	2a1b      	cmp	r2, #27
 8019016:	f200 8130 	bhi.w	801927a <_realloc_r+0x31a>
 801901a:	3408      	adds	r4, #8
 801901c:	f10a 0310 	add.w	r3, sl, #16
 8019020:	e0a6      	b.n	8019170 <_realloc_r+0x210>
 8019022:	f026 0607 	bic.w	r6, r6, #7
 8019026:	2e00      	cmp	r6, #0
 8019028:	4631      	mov	r1, r6
 801902a:	dab0      	bge.n	8018f8e <_realloc_r+0x2e>
 801902c:	230c      	movs	r3, #12
 801902e:	2000      	movs	r0, #0
 8019030:	f8c9 3000 	str.w	r3, [r9]
 8019034:	b003      	add	sp, #12
 8019036:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 801903a:	428b      	cmp	r3, r1
 801903c:	db53      	blt.n	80190e6 <_realloc_r+0x186>
 801903e:	4657      	mov	r7, sl
 8019040:	f8da 100c 	ldr.w	r1, [sl, #12]
 8019044:	f857 0f08 	ldr.w	r0, [r7, #8]!
 8019048:	1f2a      	subs	r2, r5, #4
 801904a:	2a24      	cmp	r2, #36	; 0x24
 801904c:	60c1      	str	r1, [r0, #12]
 801904e:	6088      	str	r0, [r1, #8]
 8019050:	f200 8109 	bhi.w	8019266 <_realloc_r+0x306>
 8019054:	2a13      	cmp	r2, #19
 8019056:	f240 8104 	bls.w	8019262 <_realloc_r+0x302>
 801905a:	6821      	ldr	r1, [r4, #0]
 801905c:	f8ca 1008 	str.w	r1, [sl, #8]
 8019060:	6861      	ldr	r1, [r4, #4]
 8019062:	f8ca 100c 	str.w	r1, [sl, #12]
 8019066:	2a1b      	cmp	r2, #27
 8019068:	f200 811c 	bhi.w	80192a4 <_realloc_r+0x344>
 801906c:	3408      	adds	r4, #8
 801906e:	f10a 0210 	add.w	r2, sl, #16
 8019072:	6821      	ldr	r1, [r4, #0]
 8019074:	6011      	str	r1, [r2, #0]
 8019076:	6861      	ldr	r1, [r4, #4]
 8019078:	6051      	str	r1, [r2, #4]
 801907a:	68a1      	ldr	r1, [r4, #8]
 801907c:	6091      	str	r1, [r2, #8]
 801907e:	461d      	mov	r5, r3
 8019080:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019084:	463c      	mov	r4, r7
 8019086:	4657      	mov	r7, sl
 8019088:	1baa      	subs	r2, r5, r6
 801908a:	2a0f      	cmp	r2, #15
 801908c:	f003 0301 	and.w	r3, r3, #1
 8019090:	d819      	bhi.n	80190c6 <_realloc_r+0x166>
 8019092:	432b      	orrs	r3, r5
 8019094:	443d      	add	r5, r7
 8019096:	607b      	str	r3, [r7, #4]
 8019098:	686b      	ldr	r3, [r5, #4]
 801909a:	f043 0301 	orr.w	r3, r3, #1
 801909e:	606b      	str	r3, [r5, #4]
 80190a0:	4648      	mov	r0, r9
 80190a2:	f7ff ff55 	bl	8018f50 <__malloc_unlock>
 80190a6:	4620      	mov	r0, r4
 80190a8:	b003      	add	sp, #12
 80190aa:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80190ae:	f022 0203 	bic.w	r2, r2, #3
 80190b2:	eb02 0c05 	add.w	ip, r2, r5
 80190b6:	458c      	cmp	ip, r1
 80190b8:	db80      	blt.n	8018fbc <_realloc_r+0x5c>
 80190ba:	68c2      	ldr	r2, [r0, #12]
 80190bc:	6881      	ldr	r1, [r0, #8]
 80190be:	4665      	mov	r5, ip
 80190c0:	60ca      	str	r2, [r1, #12]
 80190c2:	6091      	str	r1, [r2, #8]
 80190c4:	e7e0      	b.n	8019088 <_realloc_r+0x128>
 80190c6:	19b9      	adds	r1, r7, r6
 80190c8:	f042 0001 	orr.w	r0, r2, #1
 80190cc:	431e      	orrs	r6, r3
 80190ce:	440a      	add	r2, r1
 80190d0:	607e      	str	r6, [r7, #4]
 80190d2:	6048      	str	r0, [r1, #4]
 80190d4:	6853      	ldr	r3, [r2, #4]
 80190d6:	f043 0301 	orr.w	r3, r3, #1
 80190da:	3108      	adds	r1, #8
 80190dc:	6053      	str	r3, [r2, #4]
 80190de:	4648      	mov	r0, r9
 80190e0:	f7ff fb16 	bl	8018710 <_free_r>
 80190e4:	e7dc      	b.n	80190a0 <_realloc_r+0x140>
 80190e6:	4641      	mov	r1, r8
 80190e8:	4648      	mov	r0, r9
 80190ea:	f7ff fbe1 	bl	80188b0 <_malloc_r>
 80190ee:	4680      	mov	r8, r0
 80190f0:	b1d0      	cbz	r0, 8019128 <_realloc_r+0x1c8>
 80190f2:	f854 3c04 	ldr.w	r3, [r4, #-4]
 80190f6:	f023 0201 	bic.w	r2, r3, #1
 80190fa:	443a      	add	r2, r7
 80190fc:	f1a0 0108 	sub.w	r1, r0, #8
 8019100:	4291      	cmp	r1, r2
 8019102:	f000 809e 	beq.w	8019242 <_realloc_r+0x2e2>
 8019106:	1f2a      	subs	r2, r5, #4
 8019108:	2a24      	cmp	r2, #36	; 0x24
 801910a:	d850      	bhi.n	80191ae <_realloc_r+0x24e>
 801910c:	2a13      	cmp	r2, #19
 801910e:	d823      	bhi.n	8019158 <_realloc_r+0x1f8>
 8019110:	4603      	mov	r3, r0
 8019112:	4622      	mov	r2, r4
 8019114:	6811      	ldr	r1, [r2, #0]
 8019116:	6019      	str	r1, [r3, #0]
 8019118:	6851      	ldr	r1, [r2, #4]
 801911a:	6059      	str	r1, [r3, #4]
 801911c:	6892      	ldr	r2, [r2, #8]
 801911e:	609a      	str	r2, [r3, #8]
 8019120:	4621      	mov	r1, r4
 8019122:	4648      	mov	r0, r9
 8019124:	f7ff faf4 	bl	8018710 <_free_r>
 8019128:	4648      	mov	r0, r9
 801912a:	f7ff ff11 	bl	8018f50 <__malloc_unlock>
 801912e:	4640      	mov	r0, r8
 8019130:	b003      	add	sp, #12
 8019132:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8019136:	4611      	mov	r1, r2
 8019138:	b003      	add	sp, #12
 801913a:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 801913e:	f7ff bbb7 	b.w	80188b0 <_malloc_r>
 8019142:	f8de 2004 	ldr.w	r2, [lr, #4]
 8019146:	f022 0203 	bic.w	r2, r2, #3
 801914a:	1950      	adds	r0, r2, r5
 801914c:	f106 0c10 	add.w	ip, r6, #16
 8019150:	4560      	cmp	r0, ip
 8019152:	da19      	bge.n	8019188 <_realloc_r+0x228>
 8019154:	4670      	mov	r0, lr
 8019156:	e731      	b.n	8018fbc <_realloc_r+0x5c>
 8019158:	6823      	ldr	r3, [r4, #0]
 801915a:	6003      	str	r3, [r0, #0]
 801915c:	6863      	ldr	r3, [r4, #4]
 801915e:	6043      	str	r3, [r0, #4]
 8019160:	2a1b      	cmp	r2, #27
 8019162:	d863      	bhi.n	801922c <_realloc_r+0x2cc>
 8019164:	f100 0308 	add.w	r3, r0, #8
 8019168:	f104 0208 	add.w	r2, r4, #8
 801916c:	e7d2      	b.n	8019114 <_realloc_r+0x1b4>
 801916e:	463b      	mov	r3, r7
 8019170:	6822      	ldr	r2, [r4, #0]
 8019172:	601a      	str	r2, [r3, #0]
 8019174:	6862      	ldr	r2, [r4, #4]
 8019176:	605a      	str	r2, [r3, #4]
 8019178:	68a2      	ldr	r2, [r4, #8]
 801917a:	609a      	str	r2, [r3, #8]
 801917c:	463c      	mov	r4, r7
 801917e:	4675      	mov	r5, lr
 8019180:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019184:	4657      	mov	r7, sl
 8019186:	e77f      	b.n	8019088 <_realloc_r+0x128>
 8019188:	4437      	add	r7, r6
 801918a:	1b83      	subs	r3, r0, r6
 801918c:	f043 0301 	orr.w	r3, r3, #1
 8019190:	f8cb 7008 	str.w	r7, [fp, #8]
 8019194:	607b      	str	r3, [r7, #4]
 8019196:	f854 3c04 	ldr.w	r3, [r4, #-4]
 801919a:	f003 0301 	and.w	r3, r3, #1
 801919e:	431e      	orrs	r6, r3
 80191a0:	4648      	mov	r0, r9
 80191a2:	f844 6c04 	str.w	r6, [r4, #-4]
 80191a6:	f7ff fed3 	bl	8018f50 <__malloc_unlock>
 80191aa:	4620      	mov	r0, r4
 80191ac:	e77c      	b.n	80190a8 <_realloc_r+0x148>
 80191ae:	4621      	mov	r1, r4
 80191b0:	f7ff fe66 	bl	8018e80 <memmove>
 80191b4:	e7b4      	b.n	8019120 <_realloc_r+0x1c0>
 80191b6:	eb02 0c03 	add.w	ip, r2, r3
 80191ba:	f106 0210 	add.w	r2, r6, #16
 80191be:	4594      	cmp	ip, r2
 80191c0:	f6ff af3b 	blt.w	801903a <_realloc_r+0xda>
 80191c4:	4657      	mov	r7, sl
 80191c6:	f8da 300c 	ldr.w	r3, [sl, #12]
 80191ca:	f857 1f08 	ldr.w	r1, [r7, #8]!
 80191ce:	1f2a      	subs	r2, r5, #4
 80191d0:	2a24      	cmp	r2, #36	; 0x24
 80191d2:	60cb      	str	r3, [r1, #12]
 80191d4:	6099      	str	r1, [r3, #8]
 80191d6:	f200 8087 	bhi.w	80192e8 <_realloc_r+0x388>
 80191da:	2a13      	cmp	r2, #19
 80191dc:	d978      	bls.n	80192d0 <_realloc_r+0x370>
 80191de:	6823      	ldr	r3, [r4, #0]
 80191e0:	f8ca 3008 	str.w	r3, [sl, #8]
 80191e4:	6863      	ldr	r3, [r4, #4]
 80191e6:	f8ca 300c 	str.w	r3, [sl, #12]
 80191ea:	2a1b      	cmp	r2, #27
 80191ec:	f200 8085 	bhi.w	80192fa <_realloc_r+0x39a>
 80191f0:	3408      	adds	r4, #8
 80191f2:	f10a 0310 	add.w	r3, sl, #16
 80191f6:	6822      	ldr	r2, [r4, #0]
 80191f8:	601a      	str	r2, [r3, #0]
 80191fa:	6862      	ldr	r2, [r4, #4]
 80191fc:	605a      	str	r2, [r3, #4]
 80191fe:	68a2      	ldr	r2, [r4, #8]
 8019200:	609a      	str	r2, [r3, #8]
 8019202:	eb0a 0306 	add.w	r3, sl, r6
 8019206:	ebc6 020c 	rsb	r2, r6, ip
 801920a:	f042 0201 	orr.w	r2, r2, #1
 801920e:	f8cb 3008 	str.w	r3, [fp, #8]
 8019212:	605a      	str	r2, [r3, #4]
 8019214:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019218:	f003 0301 	and.w	r3, r3, #1
 801921c:	431e      	orrs	r6, r3
 801921e:	4648      	mov	r0, r9
 8019220:	f8ca 6004 	str.w	r6, [sl, #4]
 8019224:	f7ff fe94 	bl	8018f50 <__malloc_unlock>
 8019228:	4638      	mov	r0, r7
 801922a:	e73d      	b.n	80190a8 <_realloc_r+0x148>
 801922c:	68a3      	ldr	r3, [r4, #8]
 801922e:	6083      	str	r3, [r0, #8]
 8019230:	68e3      	ldr	r3, [r4, #12]
 8019232:	60c3      	str	r3, [r0, #12]
 8019234:	2a24      	cmp	r2, #36	; 0x24
 8019236:	d02c      	beq.n	8019292 <_realloc_r+0x332>
 8019238:	f100 0310 	add.w	r3, r0, #16
 801923c:	f104 0210 	add.w	r2, r4, #16
 8019240:	e768      	b.n	8019114 <_realloc_r+0x1b4>
 8019242:	f850 2c04 	ldr.w	r2, [r0, #-4]
 8019246:	f022 0203 	bic.w	r2, r2, #3
 801924a:	4415      	add	r5, r2
 801924c:	e71c      	b.n	8019088 <_realloc_r+0x128>
 801924e:	4621      	mov	r1, r4
 8019250:	4638      	mov	r0, r7
 8019252:	4675      	mov	r5, lr
 8019254:	463c      	mov	r4, r7
 8019256:	f7ff fe13 	bl	8018e80 <memmove>
 801925a:	4657      	mov	r7, sl
 801925c:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019260:	e712      	b.n	8019088 <_realloc_r+0x128>
 8019262:	463a      	mov	r2, r7
 8019264:	e705      	b.n	8019072 <_realloc_r+0x112>
 8019266:	4621      	mov	r1, r4
 8019268:	4638      	mov	r0, r7
 801926a:	461d      	mov	r5, r3
 801926c:	463c      	mov	r4, r7
 801926e:	f7ff fe07 	bl	8018e80 <memmove>
 8019272:	4657      	mov	r7, sl
 8019274:	f8da 3004 	ldr.w	r3, [sl, #4]
 8019278:	e706      	b.n	8019088 <_realloc_r+0x128>
 801927a:	68a3      	ldr	r3, [r4, #8]
 801927c:	f8ca 3010 	str.w	r3, [sl, #16]
 8019280:	68e3      	ldr	r3, [r4, #12]
 8019282:	f8ca 3014 	str.w	r3, [sl, #20]
 8019286:	2a24      	cmp	r2, #36	; 0x24
 8019288:	d018      	beq.n	80192bc <_realloc_r+0x35c>
 801928a:	3410      	adds	r4, #16
 801928c:	f10a 0318 	add.w	r3, sl, #24
 8019290:	e76e      	b.n	8019170 <_realloc_r+0x210>
 8019292:	6923      	ldr	r3, [r4, #16]
 8019294:	6103      	str	r3, [r0, #16]
 8019296:	6963      	ldr	r3, [r4, #20]
 8019298:	6143      	str	r3, [r0, #20]
 801929a:	f104 0218 	add.w	r2, r4, #24
 801929e:	f100 0318 	add.w	r3, r0, #24
 80192a2:	e737      	b.n	8019114 <_realloc_r+0x1b4>
 80192a4:	68a1      	ldr	r1, [r4, #8]
 80192a6:	f8ca 1010 	str.w	r1, [sl, #16]
 80192aa:	68e1      	ldr	r1, [r4, #12]
 80192ac:	f8ca 1014 	str.w	r1, [sl, #20]
 80192b0:	2a24      	cmp	r2, #36	; 0x24
 80192b2:	d00f      	beq.n	80192d4 <_realloc_r+0x374>
 80192b4:	3410      	adds	r4, #16
 80192b6:	f10a 0218 	add.w	r2, sl, #24
 80192ba:	e6da      	b.n	8019072 <_realloc_r+0x112>
 80192bc:	6923      	ldr	r3, [r4, #16]
 80192be:	f8ca 3018 	str.w	r3, [sl, #24]
 80192c2:	6963      	ldr	r3, [r4, #20]
 80192c4:	f8ca 301c 	str.w	r3, [sl, #28]
 80192c8:	3418      	adds	r4, #24
 80192ca:	f10a 0320 	add.w	r3, sl, #32
 80192ce:	e74f      	b.n	8019170 <_realloc_r+0x210>
 80192d0:	463b      	mov	r3, r7
 80192d2:	e790      	b.n	80191f6 <_realloc_r+0x296>
 80192d4:	6922      	ldr	r2, [r4, #16]
 80192d6:	f8ca 2018 	str.w	r2, [sl, #24]
 80192da:	6962      	ldr	r2, [r4, #20]
 80192dc:	f8ca 201c 	str.w	r2, [sl, #28]
 80192e0:	3418      	adds	r4, #24
 80192e2:	f10a 0220 	add.w	r2, sl, #32
 80192e6:	e6c4      	b.n	8019072 <_realloc_r+0x112>
 80192e8:	4621      	mov	r1, r4
 80192ea:	4638      	mov	r0, r7
 80192ec:	f8cd c004 	str.w	ip, [sp, #4]
 80192f0:	f7ff fdc6 	bl	8018e80 <memmove>
 80192f4:	f8dd c004 	ldr.w	ip, [sp, #4]
 80192f8:	e783      	b.n	8019202 <_realloc_r+0x2a2>
 80192fa:	68a3      	ldr	r3, [r4, #8]
 80192fc:	f8ca 3010 	str.w	r3, [sl, #16]
 8019300:	68e3      	ldr	r3, [r4, #12]
 8019302:	f8ca 3014 	str.w	r3, [sl, #20]
 8019306:	2a24      	cmp	r2, #36	; 0x24
 8019308:	d003      	beq.n	8019312 <_realloc_r+0x3b2>
 801930a:	3410      	adds	r4, #16
 801930c:	f10a 0318 	add.w	r3, sl, #24
 8019310:	e771      	b.n	80191f6 <_realloc_r+0x296>
 8019312:	6923      	ldr	r3, [r4, #16]
 8019314:	f8ca 3018 	str.w	r3, [sl, #24]
 8019318:	6963      	ldr	r3, [r4, #20]
 801931a:	f8ca 301c 	str.w	r3, [sl, #28]
 801931e:	3418      	adds	r4, #24
 8019320:	f10a 0320 	add.w	r3, sl, #32
 8019324:	e767      	b.n	80191f6 <_realloc_r+0x296>
 8019326:	bf00      	nop
 8019328:	20000d74 	.word	0x20000d74
 801932c:	00000000 	.word	0x00000000

08019330 <strlen>:
 8019330:	f020 0103 	bic.w	r1, r0, #3
 8019334:	f010 0003 	ands.w	r0, r0, #3
 8019338:	f1c0 0000 	rsb	r0, r0, #0
 801933c:	f851 3b04 	ldr.w	r3, [r1], #4
 8019340:	f100 0c04 	add.w	ip, r0, #4
 8019344:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8019348:	f06f 0200 	mvn.w	r2, #0
 801934c:	bf1c      	itt	ne
 801934e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8019352:	4313      	orrne	r3, r2
 8019354:	f04f 0c01 	mov.w	ip, #1
 8019358:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 801935c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8019360:	eba3 020c 	sub.w	r2, r3, ip
 8019364:	ea22 0203 	bic.w	r2, r2, r3
 8019368:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 801936c:	bf04      	itt	eq
 801936e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8019372:	3004      	addeq	r0, #4
 8019374:	d0f4      	beq.n	8019360 <strlen+0x30>
 8019376:	f013 0fff 	tst.w	r3, #255	; 0xff
 801937a:	bf1f      	itttt	ne
 801937c:	3001      	addne	r0, #1
 801937e:	f413 4f7f 	tstne.w	r3, #65280	; 0xff00
 8019382:	3001      	addne	r0, #1
 8019384:	f413 0f7f 	tstne.w	r3, #16711680	; 0xff0000
 8019388:	bf18      	it	ne
 801938a:	3001      	addne	r0, #1
 801938c:	4770      	bx	lr
 801938e:	bf00      	nop

08019390 <ram_areas>:
 8019390:	b264 0801 55bc 2000 55bc 2000 55bc 2000     d....U. .U. .U. 
 80193a0:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 80193b0:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 80193c0:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 80193d0:	b264 0801 0000 1000 0000 1000 0000 1000     d...............
 80193e0:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 80193f0:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 8019400:	b264 0801 0000 0000 0000 0000 0000 0000     d...............
 8019410:	6469 656c 0000 0000 0000 0000 0000 0000     idle............

08019420 <ch_debug>:
 8019420:	616d 6e69 1600 1845 0404 0844 100c 1814     main..E...D.....
 8019430:	1c00 1e1d 001f 0000 0000 0000 0000 0000     ................

08019440 <month_len>:
 8019440:	1e1f 1e1f 1e1f 1f1f 1f1e 1f1e 0000 0000     ................

08019450 <sdc_vmt>:
 8019450:	bb01 0800 bb11 0800 5b01 0800 5cc1 0800     .........[...\..
 8019460:	5d21 0800 5d81 0800 5e11 0800 5e51 0800     !]...]...^..Q^..

08019470 <vmt>:
 8019470:	6041 0800 6071 0800 60a1 0800 60d1 0800     A`..q`...`...`..
 8019480:	60f1 0800 6121 0800 6141 0800 6171 0800     .`..!a..Aa..qa..

08019490 <zero_status>:
 8019490:	0000 0000                                   ....

08019494 <active_status>:
 8019494:	0000 0000                                   ....

08019498 <halted_status>:
 8019498:	0001 0000 0000 0000                         ........

080194a0 <_stm32_dma_streams>:
 80194a0:	0000 4002 0008 4002 0001 0000 00a8 4002     ...@...@.......@
 80194b0:	0000 000b 0000 4002 001c 4002 0002 0000     .......@...@....
 80194c0:	00a8 4002 0104 000c 0000 4002 0030 4002     ...@.......@0..@
 80194d0:	0004 0000 00a8 4002 0208 000d 0000 4002     .......@.......@
 80194e0:	0044 4002 0008 0000 00a8 4002 030c 000e     D..@.......@....
 80194f0:	0000 4002 0058 4002 0010 0000 00a8 4002     ...@X..@.......@
 8019500:	0410 000f 0000 4002 006c 4002 0020 0000     .......@l..@ ...
 8019510:	00a8 4002 0514 0010 0000 4002 0080 4002     ...@.......@...@
 8019520:	0040 0000 00a8 4002 0618 0011 0400 4002     @......@.......@
 8019530:	0408 4002 0080 0000 04a8 4002 0700 0038     ...@.......@..8.
 8019540:	0400 4002 041c 4002 0100 0000 04a8 4002     ...@...@.......@
 8019550:	0804 0039 0400 4002 0430 4002 0200 0000     ..9....@0..@....
 8019560:	04a8 4002 0908 003a 0400 4002 0444 4002     ...@..:....@D..@
 8019570:	0400 0000 04a8 4002 0a0c 003b 0400 4002     .......@..;....@
 8019580:	0458 4002 0800 0000 04a8 4002 0b10 003c     X..@.......@..<.
 8019590:	0400 4002 046c 4002 1000 0000 04a8 4002     ...@l..@.......@
 80195a0:	0c14 0044 0400 4002 0480 4002 2000 0000     ..D....@...@. ..
 80195b0:	04a8 4002 0d18 0045 0000 0000 0000 0000     ...@..E.........

080195c0 <ep0config>:
 80195c0:	0000 0000 7011 0800 7171 0800 7271 0800     .....p..qq..qr..
 80195d0:	0040 0040 11b4 2000 11b4 2000 0001 0000     @.@.... ... ....
 80195e0:	11c4 2000                                   ... 

080195e4 <fsparams>:
 80195e4:	0080 0000 0140 0000 0003 0000 7375 5f62     ....@.......usb_
 80195f4:	6c6c 5f64 7570 706d 0000 0000               lld_pump....

08019600 <sdc_default_cfg>:
 8019600:	0000 0000 0001 0000 0000 0000 0000 0000     ................

08019610 <dummytx>:
 8019610:	ffff 0000 4d44 2041 6166 6c69 7275 0065     ....DMA failure.

08019620 <default_config>:
 8019620:	9600 0000 0000 0000 4000 0000 0000 0000     .........@......

08019630 <pal_default_config>:
 8019630:	ab73 ebff 0000 0000 fcc0 c3f0 0008 2800     s..............(
 8019640:	ffff 0000 0000 5550 00b0 0000 0000 0000     ......PU........
 8019650:	0000 0000 afd4 b9fc 0000 0000 3c3f cf0f     ............?<..
 8019660:	0002 000a ffff 0000 0000 0600 0000 505b     ..............[P
	...
 8019678:	f1ec 0eff 0000 0000 cf3c 0fc3 0822 0000     ........<..."...
 8019688:	fdff 0000 0600 0000 0000 0008 0000 0000     ................
 8019698:	0000 0000 ffef ffff 0000 0000 ffff ffff     ................
 80196a8:	0000 0000 fffe 0000 0800 0000 0000 0000     ................
	...
 80196c0:	ffff ffff 0000 0000 ffff ffff 0009 5550     ..............PU
 80196d0:	feff 0000 0d00 6ddd aa60 aaaa 0000 0000     .......m`.......
 80196e0:	0000 0000 ffff ffff 0000 0000 ffff ffff     ................
 80196f0:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...
 8019708:	ffff fdff 0000 0000 0000 0000 0000 0000     ................
 8019718:	ffff 0000 0000 0000 0000 0000 0000 0000     ................
 8019728:	0000 0000 fffd ffff 0000 0000 0003 0000     ................
 8019738:	0000 0000 ffff 0000 0000 0000 0000 0000     ................
	...

08019750 <wa>:
 8019750:	2070 2000 21b8 2000 2300 2000 2448 2000     p . .!. .#. H$. 
 8019760:	2590 2000 0a0d 0000 0000 0000 2a2a 202a     .%. ........*** 
 8019770:	6843 6269 4f69 2f53 5452 7420 7365 2074     ChibiOS/RT test 
 8019780:	7573 7469 0065 0000 2a2a 002a 2a2a 202a     suite...***.*** 
 8019790:	654b 6e72 6c65 203a 2020 2020 2020 0000     Kernel:       ..
 80197a0:	2e33 2e31 0035 0000 2a2a 202a 6f43 706d     3.1.5...*** Comp
 80197b0:	6c69 6465 203a 2020 2020 0000 7041 2072     iled:     ..Apr 
 80197c0:	3431 3220 3130 2037 202d 3231 353a 3a34     14 2017 - 12:54:
 80197d0:	3632 0000 2a2a 202a 6f43 706d 6c69 7265     26..*** Compiler
 80197e0:	203a 2020 2020 0000 4347 2043 2e34 2e38     :     ..GCC 4.8.
 80197f0:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 8019800:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 8019810:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 8019820:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 8019830:	2a2a 202a 7241 6863 7469 6365 7574 6572     *** Architecture
 8019840:	203a 0000 5241 764d 4537 4d2d 0000 0000     : ..ARMv7E-M....
 8019850:	2a2a 202a 6f43 6572 5620 7261 6169 746e     *** Core Variant
 8019860:	203a 0000 6f43 7472 7865 4d2d 0034 0000     : ..Cortex-M4...
 8019870:	2a2a 202a 6f50 7472 4920 666e 3a6f 2020     *** Port Info:  
 8019880:	2020 0000 6441 6176 636e 6465 6b20 7265       ..Advanced ker
 8019890:	656e 206c 6f6d 6564 0000 0000 2a2a 202a     nel mode....*** 
 80198a0:	6c50 7461 6f66 6d72 203a 2020 2020 0000     Platform:     ..
 80198b0:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 80198c0:	6f4c 2077 6f50 6577 0072 0000 2a2a 202a     Low Power...*** 
 80198d0:	6554 7473 4220 616f 6472 203a 2020 0000     Test Board:   ..
 80198e0:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 80198f0:	2d2d 202d 6554 7473 4320 7361 2065 0000     --- Test Case ..
 8019900:	002e 0000 2820 0000 0029 0000 2d2d 202d     .... (..)...--- 
 8019910:	6552 7573 746c 203a 4146 4c49 5255 2045     Result: FAILURE 
 8019920:	2328 0000 5b20 0000 295d 0000 2d2d 202d     (#.. [..])..--- 
 8019930:	6552 7573 746c 203a 5553 4343 5345 0053     Result: SUCCESS.
 8019940:	6946 616e 206c 6572 7573 746c 203a 0000     Final result: ..
 8019950:	4146 4c49 5255 0045 5553 4343 5345 0053     FAILURE.SUCCESS.
 8019960:	0045 0000 0044 0000 0043 0000 0042 0000     E...D...C...B...
 8019970:	0041 0000 4241 4443 0045 0000 6854 6572     A...ABCDE...Thre
 8019980:	6461 2c73 6520 716e 6575 6975 676e 7420     ads, enqueuing t
 8019990:	7365 2074 3123 0000                         est #1..

08019998 <testthd1>:
 8019998:	997c 0801 0000 0000 0000 0000 c3a1 0800     |...............
 80199a8:	6854 6572 6461 2c73 6520 716e 6575 6975     Threads, enqueui
 80199b8:	676e 7420 7365 2074 3223 0000               ng test #2..

080199c4 <testthd2>:
 80199c4:	99a8 0801 0000 0000 0000 0000 c4a1 0800     ................
 80199d4:	6854 6572 6461 2c73 7020 6972 726f 7469     Threads, priorit
 80199e4:	2079 6863 6e61 6567 0000 0000               y change....

080199f0 <testthd3>:
 80199f0:	99d4 0801 0000 0000 0000 0000 c5b1 0800     ................
 8019a00:	6854 6572 6461 2c73 6420 6c65 7961 0073     Threads, delays.

08019a10 <testthd4>:
 8019a10:	9a00 0801 0000 0000 0000 0000 c7a1 0800     ................

08019a20 <patternthd>:
 8019a20:	9998 0801 99c4 0801 99f0 0801 9a10 0801     ................
	...
 8019a40:	0041 0000 0042 0000 0043 0000 0044 0000     A...B...C...D...
 8019a50:	0045 0000 4241 4443 0045 0000 6553 616d     E...ABCDE...Sema
 8019a60:	6870 726f 7365 202c 6e65 7571 7565 6e69     phores, enqueuin
 8019a70:	0067 0000                                   g...

08019a74 <testsem1>:
 8019a74:	9a5c 0801 c9f1 0800 0000 0000 ca21 0800     \...........!...
 8019a84:	6553 616d 6870 726f 7365 202c 6974 656d     Semaphores, time
 8019a94:	756f 0074                                   out.

08019a98 <testsem2>:
 8019a98:	9a84 0801 cba1 0800 0000 0000 cbe1 0800     ................
 8019aa8:	6553 616d 6870 726f 7365 202c 7461 6d6f     Semaphores, atom
 8019ab8:	6369 7320 6769 616e 2d6c 6177 7469 0000     ic signal-wait..

08019ac8 <testsem3>:
 8019ac8:	9aa8 0801 cda1 0800 0000 0000 cdd1 0800     ................
 8019ad8:	6942 616e 7972 5320 6d65 7061 6f68 6572     Binary Semaphore
 8019ae8:	2c73 6620 6e75 7463 6f69 616e 696c 7974     s, functionality
 8019af8:	0000 0000                                   ....

08019afc <testsem4>:
 8019afc:	9ad8 0801 0000 0000 0000 0000 ceb1 0800     ................

08019b0c <patternsem>:
 8019b0c:	9a74 0801 9a98 0801 9ac8 0801 9afc 0801     t...............
 8019b1c:	0000 0000 0045 0000 0044 0000 0043 0000     ....E...D...C...
 8019b2c:	0042 0000 0041 0000 4241 4443 0045 0000     B...A...ABCDE...
 8019b3c:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 8019b4c:	2079 6e65 7571 7565 6e69 2067 6574 7473     y enqueuing test
 8019b5c:	0000 0000                                   ....

08019b60 <testmtx1>:
 8019b60:	9b3c 0801 d0d1 0800 0000 0000 d111 0800     <...............
 8019b70:	754d 6574 6578 2c73 7020 6972 726f 7469     Mutexes, priorit
 8019b80:	2079 6572 7574 6e72 0000 0000               y return....

08019b8c <testmtx4>:
 8019b8c:	9b70 0801 d231 0800 0000 0000 d2b1 0800     p...1...........
 8019b9c:	754d 6574 6578 2c73 7320 6174 7574 0073     Mutexes, status.

08019bac <testmtx5>:
 8019bac:	9b9c 0801 d5b1 0800 0000 0000 d5c1 0800     ................
 8019bbc:	6f43 646e 6156 2c72 7320 6769 616e 206c     CondVar, signal 
 8019bcc:	6574 7473 0000 0000                         test....

08019bd4 <testmtx6>:
 8019bd4:	9bbc 0801 d6d1 0800 0000 0000 d721 0800     ............!...
 8019be4:	6f43 646e 6156 2c72 6220 6f72 6461 6163     CondVar, broadca
 8019bf4:	7473 7420 7365 0074                         st test.

08019bfc <testmtx7>:
 8019bfc:	9be4 0801 d841 0800 0000 0000 d861 0800     ....A.......a...
 8019c0c:	4241 0043 6f43 646e 6156 2c72 6220 6f6f     ABC.CondVar, boo
 8019c1c:	7473 7420 7365 0074                         st test.

08019c24 <testmtx8>:
 8019c24:	9c10 0801 d961 0800 0000 0000 da11 0800     ....a...........

08019c34 <patternmtx>:
 8019c34:	9b60 0801 9b8c 0801 9bac 0801 9bd4 0801     `...............
 8019c44:	9bfc 0801 9c24 0801 0000 0000 4241 0043     ....$.......ABC.
 8019c54:	654d 7373 6761 7365 202c 6f6c 706f 0000     Messages, loop..

08019c64 <testmsg1>:
 8019c64:	9c54 0801 0000 0000 0000 0000 db31 0800     T...........1...

08019c74 <patternmsg>:
 8019c74:	9c64 0801 0000 0000 0000 0000 4241 4443     d...........ABCD
 8019c84:	0045 0000 614d 6c69 6f62 6578 2c73 7120     E...Mailboxes, q
 8019c94:	6575 6975 676e 6120 646e 7420 6d69 6f65     ueuing and timeo
 8019ca4:	7475 0073                                   uts.

08019ca8 <testmbox1>:
 8019ca8:	9c88 0801 dc71 0800 0000 0000 dc91 0800     ....q...........

08019cb8 <patternmbox>:
 8019cb8:	9ca8 0801 0000 0000                         ........

08019cc0 <evhndl>:
 8019cc0:	e5c1 0800 e5e1 0800 e601 0800 4241 0043     ............ABC.
 8019cd0:	7645 6e65 7374 202c 6572 6967 7473 6172     Events, registra
 8019ce0:	6974 6e6f 6120 646e 6420 7369 6170 6374     tion and dispatc
 8019cf0:	0068 0000                                   h...

08019cf4 <testevt1>:
 8019cf4:	9cd0 0801 e5b1 0800 0000 0000 e621 0800     ............!...
 8019d04:	0041 0000 7645 6e65 7374 202c 6177 7469     A...Events, wait
 8019d14:	6120 646e 6220 6f72 6461 6163 7473 0000      and broadcast..

08019d24 <testevt2>:
 8019d24:	9d08 0801 e6e1 0800 0000 0000 e741 0800     ............A...
 8019d34:	7645 6e65 7374 202c 6974 656d 756f 7374     Events, timeouts
 8019d44:	0000 0000                                   ....

08019d48 <testevt3>:
 8019d48:	9d34 0801 eaa1 0800 0000 0000 eab1 0800     4...............

08019d58 <patternevt>:
 8019d58:	9cf4 0801 9d24 0801 9d48 0801 0000 0000     ....$...H.......
	...
 8019d70:	6548 7061 202c 6c61 6f6c 6163 6974 6e6f     Heap, allocation
 8019d80:	6120 646e 6620 6172 6d67 6e65 6174 6974      and fragmentati
 8019d90:	6e6f 7420 7365 0074                         on test.

08019d98 <testheap1>:
 8019d98:	9d70 0801 ebb1 0800 0000 0000 ebd1 0800     p...............

08019da8 <patternheap>:
 8019da8:	9d98 0801 0000 0000 654d 6f6d 7972 5020     ........Memory P
 8019db8:	6f6f 736c 202c 7571 7565 2f65 6564 7571     ools, queue/dequ
 8019dc8:	7565 0065                                   eue.

08019dcc <testpools1>:
 8019dcc:	9db0 0801 eec1 0800 0000 0000 eee1 0800     ................

08019ddc <patternpools>:
 8019ddc:	9dcc 0801 0000 0000 0000 0000 0000 0000     ................
 8019dec:	0000 0000 0041 0000 0042 0000 0043 0000     ....A...B...C...
 8019dfc:	4241 0000 7944 616e 696d 2063 5041 7349     AB..Dynamic APIs
 8019e0c:	202c 6874 6572 6461 2073 7263 6165 6974     , threads creati
 8019e1c:	6e6f 6620 6f72 206d 6568 7061 0000 0000     on from heap....

08019e2c <testdyn1>:
 8019e2c:	9e00 0801 f041 0800 0000 0000 f061 0800     ....A.......a...
 8019e3c:	0044 0000 0045 0000 4241 4443 0000 0000     D...E...ABCD....
 8019e4c:	7944 616e 696d 2063 5041 7349 202c 6874     Dynamic APIs, th
 8019e5c:	6572 6461 2073 7263 6165 6974 6e6f 6620     reads creation f
 8019e6c:	6f72 206d 656d 6f6d 7972 7020 6f6f 006c     rom memory pool.

08019e7c <testdyn2>:
 8019e7c:	9e4c 0801 f1b1 0800 0000 0000 f1d1 0800     L...............
 8019e8c:	7944 616e 696d 2063 5041 7349 202c 6572     Dynamic APIs, re
 8019e9c:	6967 7473 7972 6120 646e 7220 6665 7265     gistry and refer
 8019eac:	6e65 6563 0073 0000                         ences...

08019eb4 <testdyn3>:
 8019eb4:	9e8c 0801 f3a1 0800 0000 0000 f3c1 0800     ................

08019ec4 <patterndyn>:
 8019ec4:	9e2c 0801 9e7c 0801 9eb4 0801 0000 0000     ,...|...........
	...
 8019ee0:	4241 4443 0000 0000 7551 7565 7365 202c     ABCD....Queues, 
 8019ef0:	6e69 7570 2074 7571 7565 7365 0000 0000     input queues....

08019f00 <testqueues1>:
 8019f00:	9ee8 0801 f701 0800 0000 0000 f751 0800     ............Q...
 8019f10:	7551 7565 7365 202c 756f 7074 7475 7120     Queues, output q
 8019f20:	6575 6575 0073 0000                         ueues...

08019f28 <testqueues2>:
 8019f28:	9f10 0801 fa61 0800 0000 0000 fab1 0800     ....a...........

08019f38 <patternqueues>:
 8019f38:	9f00 0801 9f28 0801 0000 0000 0000 0000     ....(...........
	...
 8019f50:	7953 7473 6d65 202c 7263 7469 6369 6c61     System, critical
 8019f60:	7a20 6e6f 7365 0000                          zones..

08019f68 <testsys1>:
 8019f68:	9f50 0801 0000 0000 0000 0000 fff1 0800     P...............
 8019f78:	7953 7473 6d65 202c 6e69 6574 7272 7075     System, interrup
 8019f88:	7374 6820 6e61 6c64 6e69 0067               ts handling.

08019f94 <testsys2>:
 8019f94:	9f78 0801 0000 0000 0000 0000 0081 0801     x...............
 8019fa4:	7953 7473 6d65 202c 6e69 6574 7267 7469     System, integrit
 8019fb4:	0079 0000                                   y...

08019fb8 <testsys3>:
 8019fb8:	9fa4 0801 0000 0000 0000 0000 00a1 0801     ................

08019fc8 <patternsys>:
 8019fc8:	9f68 0801 9f94 0801 9fb8 0801 0000 0000     h...............
	...
 8019fe0:	2d2d 202d 6353 726f 2065 203a 0000 0000     --- Score : ....
 8019ff0:	6d20 6773 2f73 2c53 0020 0000 6320 7874      msgs/S, ... ctx
 801a000:	7773 2f63 0053 0000 6542 636e 6d68 7261     swc/S...Benchmar
 801a010:	2c6b 6d20 7365 6173 6567 2073 3123 0000     k, messages #1..

0801a020 <testbmk1>:
 801a020:	a008 0801 0000 0000 0000 0000 0301 0801     ................
 801a030:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 801a040:	6567 2073 3223 0000                         ges #2..

0801a048 <testbmk2>:
 801a048:	a030 0801 0000 0000 0000 0000 0381 0801     0...............
 801a058:	6542 636e 6d68 7261 2c6b 6d20 7365 6173     Benchmark, messa
 801a068:	6567 2073 3323 0000                         ges #3..

0801a070 <testbmk3>:
 801a070:	a058 0801 0000 0000 0000 0000 0401 0801     X...............
 801a080:	6542 636e 6d68 7261 2c6b 6320 6e6f 6574     Benchmark, conte
 801a090:	7478 7320 6977 6374 0068 0000               xt switch...

0801a09c <testbmk4>:
 801a09c:	a080 0801 0000 0000 0000 0000 0541 0801     ............A...
 801a0ac:	7420 7268 6165 7364 532f 0000 6542 636e      threads/S..Benc
 801a0bc:	6d68 7261 2c6b 7420 7268 6165 7364 202c     hmark, threads, 
 801a0cc:	7566 6c6c 6320 6379 656c 0000               full cycle..

0801a0d8 <testbmk5>:
 801a0d8:	a0b8 0801 0000 0000 0000 0000 0611 0801     ................
 801a0e8:	6542 636e 6d68 7261 2c6b 7420 7268 6165     Benchmark, threa
 801a0f8:	7364 202c 7263 6165 6574 6f20 6c6e 0079     ds, create only.

0801a108 <testbmk6>:
 801a108:	a0e8 0801 0000 0000 0000 0000 0691 0801     ................
 801a118:	7220 7365 6863 6465 6c75 7365 532f 202c      reschedules/S, 
 801a128:	0000 0000 6542 636e 6d68 7261 2c6b 6d20     ....Benchmark, m
 801a138:	7361 2073 6572 6373 6568 7564 656c 202c     ass reschedule, 
 801a148:	2035 6874 6572 6461 0073 0000               5 threads...

0801a154 <testbmk7>:
 801a154:	a12c 0801 0741 0801 0000 0000 0751 0801     ,...A.......Q...
 801a164:	6542 636e 6d68 7261 2c6b 7220 756f 646e     Benchmark, round
 801a174:	7220 626f 6e69 6320 6e6f 6574 7478 7320      robin context s
 801a184:	6977 6374 6968 676e 0000 0000               witching....

0801a190 <testbmk8>:
 801a190:	a164 0801 0000 0000 0000 0000 08d1 0801     d...............
 801a1a0:	6220 7479 7365 532f 0000 0000 6542 636e      bytes/S....Benc
 801a1b0:	6d68 7261 2c6b 4920 4f2f 5120 6575 6575     hmark, I/O Queue
 801a1c0:	2073 6874 6f72 6775 7068 7475 0000 0000     s throughput....

0801a1d0 <testbmk9>:
 801a1d0:	a1ac 0801 0000 0000 0000 0000 09d1 0801     ................
 801a1e0:	7420 6d69 7265 2f73 0053 0000 6542 636e      timers/S...Benc
 801a1f0:	6d68 7261 2c6b 7620 7269 7574 6c61 7420     hmark, virtual t
 801a200:	6d69 7265 2073 6573 2f74 6572 6573 0074     imers set/reset.

0801a210 <testbmk10>:
 801a210:	a1ec 0801 0000 0000 0000 0000 0a91 0801     ................
 801a220:	7720 6961 2b74 6973 6e67 6c61 532f 0000      wait+signal/S..
 801a230:	6542 636e 6d68 7261 2c6b 7320 6d65 7061     Benchmark, semap
 801a240:	6f68 6572 2073 6177 7469 732f 6769 616e     hores wait/signa
 801a250:	006c 0000                                   l...

0801a254 <testbmk11>:
 801a254:	a230 0801 0b21 0801 0000 0000 0b31 0801     0...!.......1...
 801a264:	6c20 636f 2b6b 6e75 6f6c 6b63 532f 0000      lock+unlock/S..
 801a274:	6542 636e 6d68 7261 2c6b 6d20 7475 7865     Benchmark, mutex
 801a284:	7365 6c20 636f 2f6b 6e75 6f6c 6b63 0000     es lock/unlock..

0801a294 <testbmk12>:
 801a294:	a274 0801 0bc1 0801 0000 0000 0bd1 0801     t...............
 801a2a4:	2d2d 202d 7953 7473 6d65 203a 0000 0000     --- System: ....
 801a2b4:	6220 7479 7365 0000 2d2d 202d 6854 6572      bytes..--- Thre
 801a2c4:	6461 203a 0000 0000 2d2d 202d 6954 656d     ad: ....--- Time
 801a2d4:	2072 203a 0000 0000 2d2d 202d 6553 616d     r : ....--- Sema
 801a2e4:	6870 203a 0000 0000 2d2d 202d 7645 6e65     ph: ....--- Even
 801a2f4:	5374 203a 0000 0000 2d2d 202d 7645 6e65     tS: ....--- Even
 801a304:	4c74 203a 0000 0000 2d2d 202d 754d 6574     tL: ....--- Mute
 801a314:	2078 203a 0000 0000 2d2d 202d 6f43 646e     x : ....--- Cond
 801a324:	2e56 203a 0000 0000 2d2d 202d 7551 7565     V.: ....--- Queu
 801a334:	2065 203a 0000 0000 2d2d 202d 614d 6c69     e : ....--- Mail
 801a344:	2e42 203a 0000 0000 6542 636e 6d68 7261     B.: ....Benchmar
 801a354:	2c6b 5220 4d41 6620 6f6f 7074 6972 746e     k, RAM footprint
 801a364:	0000 0000                                   ....

0801a368 <testbmk13>:
 801a368:	a34c 0801 0000 0000 0000 0000 0c61 0801     L...........a...

0801a378 <patternbmk>:
 801a378:	a020 0801 a048 0801 a070 0801 a09c 0801      ...H...p.......
 801a388:	a0d8 0801 a108 0801 a154 0801 a190 0801     ........T.......
 801a398:	a1d0 0801 a210 0801 a254 0801 a294 0801     ........T.......
 801a3a8:	a368 0801 0000 0000                         h.......

0801a3b0 <vmt>:
 801a3b0:	0f51 0801 0fb1 0801 1011 0801 1061 0801     Q...........a...
 801a3c0:	6e28 6c75 296c 0000 0000 0000 0000 0000     (null)..........
 801a3d0:	7355 6761 3a65 2520 0d73 000a 7325 0020     Usage: %s...%s .
 801a3e0:	6e69 6f66 0000 0000 654b 6e72 6c65 203a     info....Kernel: 
 801a3f0:	2020 2020 2020 7325 0a0d 0000 2e33 2e31           %s....3.1.
 801a400:	0035 0000 6f43 706d 6c69 7265 203a 2020     5...Compiler:   
 801a410:	2020 7325 0a0d 0000 4347 2043 2e34 2e38       %s....GCC 4.8.
 801a420:	2034 3032 3431 3530 3632 2820 6572 656c     4 20140526 (rele
 801a430:	7361 2965 5b20 5241 2f4d 6d65 6562 6464     ase) [ARM/embedd
 801a440:	6465 342d 385f 622d 6172 636e 2068 6572     ed-4_8-branch re
 801a450:	6976 6973 6e6f 3220 3131 3533 5d38 0000     vision 211358]..
 801a460:	7241 6863 7469 6365 7574 6572 203a 7325     Architecture: %s
 801a470:	0a0d 0000 5241 764d 4537 4d2d 0000 0000     ....ARMv7E-M....
 801a480:	6f43 6572 5620 7261 6169 746e 203a 7325     Core Variant: %s
 801a490:	0a0d 0000 6f43 7472 7865 4d2d 0034 0000     ....Cortex-M4...
 801a4a0:	6f50 7472 4920 666e 3a6f 2020 2020 7325     Port Info:    %s
 801a4b0:	0a0d 0000 6441 6176 636e 6465 6b20 7265     ....Advanced ker
 801a4c0:	656e 206c 6f6d 6564 0000 0000 6c50 7461     nel mode....Plat
 801a4d0:	6f66 6d72 203a 2020 2020 7325 0a0d 0000     form:     %s....
 801a4e0:	5453 334d 4c32 7834 2078 6c55 7274 2061     STM32L4xx Ultra 
 801a4f0:	6f4c 2077 6f50 6577 0072 0000 6f42 7261     Low Power...Boar
 801a500:	3a64 2020 2020 2020 2020 7325 0a0d 0000     d:        %s....
 801a510:	5453 5320 6e65 6f73 7472 6c69 2065 0000     ST Sensortile ..
 801a520:	7542 6c69 2064 6974 656d 203a 2020 7325     Build time:   %s
 801a530:	7325 7325 0a0d 0000 7041 2072 3431 3220     %s%s....Apr 14 2
 801a540:	3130 0037 2d20 0020 3231 353a 3a34 3832     017. - .12:54:28
 801a550:	0000 0000 7973 7473 6d69 0065 6c25 0d75     ....systime.%lu.
 801a560:	000a 0000                                   ....

0801a564 <local_commands>:
 801a564:	a3e0 0801 1801 0801 a554 0801 18d1 0801     ........T.......
	...
 801a57c:	6873 6c65 006c 0000 0a0d 6843 6269 4f69     shell.....ChibiO
 801a58c:	2f53 5452 5320 6568 6c6c 0a0d 0000 0000     S/RT Shell......
 801a59c:	6863 203e 0000 0000 0a0d 6f6c 6f67 7475     ch> ......logout
 801a5ac:	0000 0000 0920 0000 6f74 206f 616d 796e     .... ...too many
 801a5bc:	6120 6772 6d75 6e65 7374 0a0d 0000 0000      arguments......
 801a5cc:	7865 7469 0000 0000 6568 706c 0000 0000     exit....help....
 801a5dc:	6f43 6d6d 6e61 7364 203a 6568 706c 6520     Commands: help e
 801a5ec:	6978 2074 0000 0000 0a0d 0000 7325 0000     xit ........%s..
 801a5fc:	3f20 0a0d 0000 0000 445e 0000 0000 0000      ?......^D......
 801a60c:	0000 0000                                   ....

0801a610 <LSM303AGR_ACC_Sensitivity_List>:
 801a610:	03d4 0000 0000 0000 079e 0000 0000 0000     ................
 801a620:	0f3c 0000 0000 0000 2dc8 0000 0000 0000     <........-......
 801a630:	0f3c 0000 0000 0000 1e8c 0000 0000 0000     <...............
 801a640:	3d0e 0000 0000 0000 b734 0000 0000 0000     .=......4.......
 801a650:	3d0e 0000 0000 0000 7a1c 0000 0000 0000     .=.......z......
 801a660:	f438 0000 0000 0000 dcbc 0002 0000 0000     8...............
 801a670:	6c62 6e69 656b 0072 6574 7473 0000 0000     blinker.test....
 801a680:	6341 6563 3a6c 2520 6434 252c 6434 252c     Accel: %4d,%4d,%
 801a690:	6434 0a20 000d 0000 6974 656d 0072 0000     4d .....timer...
 801a6a0:	7473 7065 6f43 6e75 6574 0072 6f43 6e75     stepCounter.Coun
 801a6b0:	3a74 2520 6434 7c20 2520 2073 0d0a 0000     t: %4d | %s ....
 801a6c0:	7325 0d0a 0000 0000 796d 6365 6f68 0000     %s......myecho..
 801a6d0:	6964 7073 616c 5f79 6f63 6e75 0074 0000     display_count...

0801a6e0 <commands>:
 801a6e0:	a6c8 0801 6141 0801 a6d0 0801 6091 0801     ....Aa.......`..
	...

0801a6f8 <shell_cfg1>:
 801a6f8:	1fd8 2000 a6e0 0801 0d0a 7055 6120 646e     ... ......Up and
 801a708:	5220 6e75 696e 676e 0d0a 0000 0000 0000      Running........
	...

0801a720 <_DAYS_BEFORE_MONTH>:
 801a720:	0000 0000 001f 0000 003b 0000 005a 0000     ........;...Z...
 801a730:	0078 0000 0097 0000 00b5 0000 00d4 0000     x...............
 801a740:	00f3 0000 0111 0000 0130 0000 014e 0000     ........0...N...

0801a750 <DAYS_IN_MONTH>:
 801a750:	001f 0000 001c 0000 001f 0000 001e 0000     ................
 801a760:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 801a770:	001e 0000 001f 0000 001e 0000 001f 0000     ................

0801a780 <mon_lengths>:
 801a780:	001f 0000 001c 0000 001f 0000 001e 0000     ................
 801a790:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 801a7a0:	001e 0000 001f 0000 001e 0000 001f 0000     ................
 801a7b0:	001f 0000 001d 0000 001f 0000 001e 0000     ................
 801a7c0:	001f 0000 001e 0000 001f 0000 001f 0000     ................
 801a7d0:	001e 0000 001f 0000 001e 0000 001f 0000     ................

0801a7e0 <year_lengths>:
 801a7e0:	016d 0000 016e 0000 0000 0000 0000 0000     m...n...........
 801a7f0:	4d47 0054 0000 0000 0000 0000 0000 0000     GMT.............

0801a800 <day_name.4587>:
 801a800:	7553 4d6e 6e6f 7554 5765 6465 6854 4675     SunMonTueWedThuF
 801a810:	6972 6153 0074 0000 0000 0000 0000 0000     riSat...........
 801a820:	2e25 7333 2520 332e 2573 6433 2520 322e     %.3s %.3s%3d %.2
 801a830:	3a64 2e25 6432 253a 322e 2064 6425 000a     d:%.2d:%.2d %d..

0801a840 <mon_name.4588>:
 801a840:	614a 466e 6265 614d 4172 7270 614d 4a79     JanFebMarAprMayJ
 801a850:	6e75 754a 416c 6775 6553 4f70 7463 6f4e     unJulAugSepOctNo
 801a860:	4476 6365 0000 0000 0000 0000 0000 0000     vDec............

0801a870 <zeroes.6707>:
 801a870:	3030 3030 3030 3030 3030 3030 3030 3030     0000000000000000
 801a880:	3130 3332 3534 3736 3938 4241 4443 4645     0123456789ABCDEF
 801a890:	0000 0000 3130 3332 3534 3736 3938 6261     ....0123456789ab
 801a8a0:	6463 6665 0000 0000 6e28 6c75 296c 0000     cdef....(null)..

0801a8b0 <blanks.6706>:
 801a8b0:	2020 2020 2020 2020 2020 2020 2020 2020                     
 801a8c0:	0043 0000 0000 0000 0000 0000 0000 0000     C...............

0801a8d0 <_global_impure_ptr>:
 801a8d0:	0948 2000                                   H.. 
