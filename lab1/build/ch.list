
build/ch.elf:     file format elf32-littlearm


Disassembly of section .text:

08000200 <Reset_Handler>:
 8000200:	b672      	cpsid	i
 8000202:	4825      	ldr	r0, [pc, #148]	; (8000298 <endfiniloop+0x4>)
 8000204:	f380 8809 	msr	PSP, r0
 8000208:	4824      	ldr	r0, [pc, #144]	; (800029c <endfiniloop+0x8>)
 800020a:	f64e 5108 	movw	r1, #60680	; 0xed08
 800020e:	f2ce 0100 	movt	r1, #57344	; 0xe000
 8000212:	6008      	str	r0, [r1, #0]
 8000214:	2002      	movs	r0, #2
 8000216:	f380 8814 	msr	CONTROL, r0
 800021a:	f3bf 8f6f 	isb	sy
 800021e:	f005 fc17 	bl	8005a50 <__core_init>
 8000222:	f003 ff45 	bl	80040b0 <__early_init>
 8000226:	481e      	ldr	r0, [pc, #120]	; (80002a0 <endfiniloop+0xc>)
 8000228:	491e      	ldr	r1, [pc, #120]	; (80002a4 <endfiniloop+0x10>)
 800022a:	4a1f      	ldr	r2, [pc, #124]	; (80002a8 <endfiniloop+0x14>)

0800022c <msloop>:
 800022c:	4291      	cmp	r1, r2
 800022e:	bf3c      	itt	cc
 8000230:	f841 0b04 	strcc.w	r0, [r1], #4
 8000234:	e7fa      	bcc.n	800022c <msloop>
 8000236:	491d      	ldr	r1, [pc, #116]	; (80002ac <endfiniloop+0x18>)
 8000238:	4a17      	ldr	r2, [pc, #92]	; (8000298 <endfiniloop+0x4>)

0800023a <psloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <psloop>
 8000244:	491a      	ldr	r1, [pc, #104]	; (80002b0 <endfiniloop+0x1c>)
 8000246:	4a1b      	ldr	r2, [pc, #108]	; (80002b4 <endfiniloop+0x20>)
 8000248:	4b1b      	ldr	r3, [pc, #108]	; (80002b8 <endfiniloop+0x24>)

0800024a <dloop>:
 800024a:	429a      	cmp	r2, r3
 800024c:	bf3e      	ittt	cc
 800024e:	f851 0b04 	ldrcc.w	r0, [r1], #4
 8000252:	f842 0b04 	strcc.w	r0, [r2], #4
 8000256:	e7f8      	bcc.n	800024a <dloop>
 8000258:	2000      	movs	r0, #0
 800025a:	4918      	ldr	r1, [pc, #96]	; (80002bc <endfiniloop+0x28>)
 800025c:	4a18      	ldr	r2, [pc, #96]	; (80002c0 <endfiniloop+0x2c>)

0800025e <bloop>:
 800025e:	4291      	cmp	r1, r2
 8000260:	bf3c      	itt	cc
 8000262:	f841 0b04 	strcc.w	r0, [r1], #4
 8000266:	e7fa      	bcc.n	800025e <bloop>
 8000268:	f005 fbba 	bl	80059e0 <__init_ram_areas>
 800026c:	f005 fbe8 	bl	8005a40 <__late_init>
 8000270:	4c14      	ldr	r4, [pc, #80]	; (80002c4 <endfiniloop+0x30>)
 8000272:	4d15      	ldr	r5, [pc, #84]	; (80002c8 <endfiniloop+0x34>)

08000274 <initloop>:
 8000274:	42ac      	cmp	r4, r5
 8000276:	da03      	bge.n	8000280 <endinitloop>
 8000278:	f854 1b04 	ldr.w	r1, [r4], #4
 800027c:	4788      	blx	r1
 800027e:	e7f9      	b.n	8000274 <initloop>

08000280 <endinitloop>:
 8000280:	f000 fbee 	bl	8000a60 <main>
 8000284:	4c11      	ldr	r4, [pc, #68]	; (80002cc <endfiniloop+0x38>)
 8000286:	4d12      	ldr	r5, [pc, #72]	; (80002d0 <endfiniloop+0x3c>)

08000288 <finiloop>:
 8000288:	42ac      	cmp	r4, r5
 800028a:	da03      	bge.n	8000294 <endfiniloop>
 800028c:	f854 1b04 	ldr.w	r1, [r4], #4
 8000290:	4788      	blx	r1
 8000292:	e7f9      	b.n	8000288 <finiloop>

08000294 <endfiniloop>:
 8000294:	f005 bbcc 	b.w	8005a30 <__default_exit>
 8000298:	20000800 	.word	0x20000800
 800029c:	08000000 	.word	0x08000000
 80002a0:	55555555 	.word	0x55555555
 80002a4:	20000000 	.word	0x20000000
 80002a8:	20000400 	.word	0x20000400
 80002ac:	20000400 	.word	0x20000400
 80002b0:	0800747c 	.word	0x0800747c
 80002b4:	20000800 	.word	0x20000800
 80002b8:	200008b0 	.word	0x200008b0
 80002bc:	200008b0 	.word	0x200008b0
 80002c0:	200014a0 	.word	0x200014a0
 80002c4:	08000200 	.word	0x08000200
 80002c8:	08000200 	.word	0x08000200
 80002cc:	08000200 	.word	0x08000200
 80002d0:	08000200 	.word	0x08000200

080002d4 <_port_switch>:
 80002d4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002d8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002dc:	68c3      	ldr	r3, [r0, #12]
 80002de:	469d      	mov	sp, r3
 80002e0:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002e4 <_port_thread_start>:
 80002e4:	2300      	movs	r3, #0
 80002e6:	f383 8811 	msr	BASEPRI, r3
 80002ea:	4628      	mov	r0, r5
 80002ec:	47a0      	blx	r4
 80002ee:	2000      	movs	r0, #0
 80002f0:	f005 f9de 	bl	80056b0 <chThdExit>

080002f4 <_port_switch_from_isr>:
 80002f4:	f004 ffa4 	bl	8005240 <chSchDoReschedule>

080002f8 <_port_exit_from_isr>:
 80002f8:	df00      	svc	0
 80002fa:	e7fe      	b.n	80002fa <_port_exit_from_isr+0x2>
 80002fc:	0000      	movs	r0, r0
	...

08000300 <test_012_011_setup>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000300:	4b02      	ldr	r3, [pc, #8]	; (800030c <test_012_011_setup+0xc>)
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 8000302:	2200      	movs	r2, #0
 8000304:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000306:	605b      	str	r3, [r3, #4]
 8000308:	609a      	str	r2, [r3, #8]
 800030a:	4770      	bx	lr
 800030c:	20001354 	.word	0x20001354

08000310 <test_012_010_setup>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000310:	4b02      	ldr	r3, [pc, #8]	; (800031c <test_012_010_setup+0xc>)
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8000312:	2201      	movs	r2, #1
 8000314:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000316:	605b      	str	r3, [r3, #4]
 8000318:	609a      	str	r2, [r3, #8]
 800031a:	4770      	bx	lr
 800031c:	2000099c 	.word	0x2000099c

08000320 <test_012_007_setup>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000320:	4b02      	ldr	r3, [pc, #8]	; (800032c <test_012_007_setup+0xc>)
 8000322:	2200      	movs	r2, #0
 8000324:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8000326:	605b      	str	r3, [r3, #4]
 8000328:	609a      	str	r2, [r3, #8]
 800032a:	4770      	bx	lr
 800032c:	2000099c 	.word	0x2000099c

08000330 <Thread1>:

/*
 * Blinker thread #1.
 */
THD_WORKING_AREA(waThread1, 128);
THD_FUNCTION(Thread1, arg) {
 8000330:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.current->name = name;
 8000332:	4b13      	ldr	r3, [pc, #76]	; (8000380 <Thread1+0x50>)
 8000334:	4a13      	ldr	r2, [pc, #76]	; (8000384 <Thread1+0x54>)
 8000336:	699b      	ldr	r3, [r3, #24]

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    palToggleLine(LINE_LED3_RED);
 8000338:	4c13      	ldr	r4, [pc, #76]	; (8000388 <Thread1+0x58>)
 800033a:	619a      	str	r2, [r3, #24]
 800033c:	6963      	ldr	r3, [r4, #20]
 800033e:	f483 7300 	eor.w	r3, r3, #512	; 0x200
 8000342:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 8000344:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000348:	f005 fab2 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED7_GREEN);
 800034c:	6963      	ldr	r3, [r4, #20]
 800034e:	f483 6300 	eor.w	r3, r3, #2048	; 0x800
 8000352:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 8000354:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000358:	f005 faaa 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED10_RED);
 800035c:	6963      	ldr	r3, [r4, #20]
 800035e:	f483 5300 	eor.w	r3, r3, #8192	; 0x2000
 8000362:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 8000364:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000368:	f005 faa2 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED6_GREEN);
 800036c:	6963      	ldr	r3, [r4, #20]
 800036e:	f483 4300 	eor.w	r3, r3, #32768	; 0x8000
 8000372:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 8000374:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 8000378:	f005 fa9a 	bl	80058b0 <chThdSleep>
 800037c:	e7de      	b.n	800033c <Thread1+0xc>
 800037e:	bf00      	nop
 8000380:	200013b0 	.word	0x200013b0
 8000384:	080065bc 	.word	0x080065bc
 8000388:	48001000 	.word	0x48001000
 800038c:	f3af 8000 	nop.w

08000390 <Thread2>:

/*
 * Blinker thread #2.
 */
THD_WORKING_AREA(waThread2, 128);
THD_FUNCTION(Thread2, arg) {
 8000390:	b508      	push	{r3, lr}
 8000392:	4b15      	ldr	r3, [pc, #84]	; (80003e8 <Thread2+0x58>)
 8000394:	4a15      	ldr	r2, [pc, #84]	; (80003ec <Thread2+0x5c>)
 8000396:	699b      	ldr	r3, [r3, #24]
  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    chThdSleepMilliseconds(50);
    palToggleLine(LINE_LED5_ORANGE);
 8000398:	4c15      	ldr	r4, [pc, #84]	; (80003f0 <Thread2+0x60>)
 800039a:	619a      	str	r2, [r3, #24]

  (void)arg;

  chRegSetThreadName("blinker");
  while (true) {
    chThdSleepMilliseconds(50);
 800039c:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80003a0:	f005 fa86 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED5_ORANGE);
 80003a4:	6963      	ldr	r3, [r4, #20]
 80003a6:	f483 6380 	eor.w	r3, r3, #1024	; 0x400
 80003aa:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 80003ac:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80003b0:	f005 fa7e 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED9_BLUE);
 80003b4:	6963      	ldr	r3, [r4, #20]
 80003b6:	f483 5380 	eor.w	r3, r3, #4096	; 0x1000
 80003ba:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 80003bc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80003c0:	f005 fa76 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED8_ORANGE);
 80003c4:	6963      	ldr	r3, [r4, #20]
 80003c6:	f483 4380 	eor.w	r3, r3, #16384	; 0x4000
 80003ca:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(100);
 80003cc:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80003d0:	f005 fa6e 	bl	80058b0 <chThdSleep>
    palToggleLine(LINE_LED4_BLUE);
 80003d4:	6963      	ldr	r3, [r4, #20]
 80003d6:	f483 7380 	eor.w	r3, r3, #256	; 0x100
 80003da:	6163      	str	r3, [r4, #20]
    chThdSleepMilliseconds(50);
 80003dc:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80003e0:	f005 fa66 	bl	80058b0 <chThdSleep>
 80003e4:	e7da      	b.n	800039c <Thread2+0xc>
 80003e6:	bf00      	nop
 80003e8:	200013b0 	.word	0x200013b0
 80003ec:	080065bc 	.word	0x080065bc
 80003f0:	48001000 	.word	0x48001000
 80003f4:	f3af 8000 	nop.w
 80003f8:	f3af 8000 	nop.w
 80003fc:	f3af 8000 	nop.w

08000400 <test_012_012_execute>:
 * - [12.12.8] The size of an event listener is printed.
 * - [12.12.9] The size of a mailbox is printed.
 * .
 */

static void test_012_012_execute(void) {
 8000400:	b570      	push	{r4, r5, r6, lr}

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8000402:	4d33      	ldr	r5, [pc, #204]	; (80004d0 <test_012_012_execute+0xd0>)
  {
    test_print("--- System: ");
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
 8000404:	4c33      	ldr	r4, [pc, #204]	; (80004d4 <test_012_012_execute+0xd4>)
static void test_012_012_execute(void) {

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
  {
    test_print("--- System: ");
 8000406:	4834      	ldr	r0, [pc, #208]	; (80004d8 <test_012_012_execute+0xd8>)
 */

static void test_012_012_execute(void) {

  /* [12.12.1] The size of the system area is printed.*/
  test_set_step(1);
 8000408:	2301      	movs	r3, #1
 800040a:	602b      	str	r3, [r5, #0]
  {
    test_print("--- System: ");
 800040c:	f003 fcf0 	bl	8003df0 <test_print>
    test_printn(sizeof(ch_system_t));
 8000410:	2078      	movs	r0, #120	; 0x78
 8000412:	f003 fcfd 	bl	8003e10 <test_printn>
    test_println(" bytes");
 8000416:	4620      	mov	r0, r4
 8000418:	f003 fcca 	bl	8003db0 <test_println>
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 800041c:	2302      	movs	r3, #2
  {
    test_print("--- Thread: ");
 800041e:	482f      	ldr	r0, [pc, #188]	; (80004dc <test_012_012_execute+0xdc>)
    test_printn(sizeof(ch_system_t));
    test_println(" bytes");
  }

  /* [12.12.2] The size of a thread structure is printed.*/
  test_set_step(2);
 8000420:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Thread: ");
 8000422:	f003 fce5 	bl	8003df0 <test_print>
    test_printn(sizeof(thread_t));
 8000426:	2044      	movs	r0, #68	; 0x44
 8000428:	f003 fcf2 	bl	8003e10 <test_printn>
    test_println(" bytes");
 800042c:	4620      	mov	r0, r4
 800042e:	f003 fcbf 	bl	8003db0 <test_println>
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8000432:	2303      	movs	r3, #3
  {
    test_print("--- Timer : ");
 8000434:	482a      	ldr	r0, [pc, #168]	; (80004e0 <test_012_012_execute+0xe0>)
    test_printn(sizeof(thread_t));
    test_println(" bytes");
  }

  /* [12.12.3] The size of a virtual timer structure is printed.*/
  test_set_step(3);
 8000436:	602b      	str	r3, [r5, #0]
  {
    test_print("--- Timer : ");
 8000438:	f003 fcda 	bl	8003df0 <test_print>
    test_printn(sizeof(virtual_timer_t));
 800043c:	2014      	movs	r0, #20
 800043e:	f003 fce7 	bl	8003e10 <test_printn>
    test_println(" bytes");
 8000442:	4620      	mov	r0, r4
 8000444:	f003 fcb4 	bl	8003db0 <test_println>
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 8000448:	2604      	movs	r6, #4
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800044a:	4826      	ldr	r0, [pc, #152]	; (80004e4 <test_012_012_execute+0xe4>)
    test_printn(sizeof(virtual_timer_t));
    test_println(" bytes");
  }

  /* [12.12.4] The size of a semaphore structure is printed.*/
  test_set_step(4);
 800044c:	602e      	str	r6, [r5, #0]
  {
#if CH_CFG_USE_SEMAPHORES || defined(__DOXYGEN__)
    test_print("--- Semaph: ");
 800044e:	f003 fccf 	bl	8003df0 <test_print>
    test_printn(sizeof(semaphore_t));
 8000452:	200c      	movs	r0, #12
 8000454:	f003 fcdc 	bl	8003e10 <test_printn>
    test_println(" bytes");
 8000458:	4620      	mov	r0, r4
 800045a:	f003 fca9 	bl	8003db0 <test_println>
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 800045e:	2305      	movs	r3, #5
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8000460:	4821      	ldr	r0, [pc, #132]	; (80004e8 <test_012_012_execute+0xe8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.5] The size of a mutex is printed.*/
  test_set_step(5);
 8000462:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
    test_print("--- Mutex : ");
 8000464:	f003 fcc4 	bl	8003df0 <test_print>
    test_printn(sizeof(mutex_t));
 8000468:	2010      	movs	r0, #16
 800046a:	f003 fcd1 	bl	8003e10 <test_printn>
    test_println(" bytes");
 800046e:	4620      	mov	r0, r4
 8000470:	f003 fc9e 	bl	8003db0 <test_println>
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8000474:	2306      	movs	r3, #6
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 8000476:	481d      	ldr	r0, [pc, #116]	; (80004ec <test_012_012_execute+0xec>)
    test_println(" bytes");
#endif
  }

  /* [12.12.6] The size of a condition variable is printed.*/
  test_set_step(6);
 8000478:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
    test_print("--- CondV.: ");
 800047a:	f003 fcb9 	bl	8003df0 <test_print>
    test_printn(sizeof(condition_variable_t));
 800047e:	2008      	movs	r0, #8
 8000480:	f003 fcc6 	bl	8003e10 <test_printn>
    test_println(" bytes");
 8000484:	4620      	mov	r0, r4
 8000486:	f003 fc93 	bl	8003db0 <test_println>
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800048a:	2307      	movs	r3, #7
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 800048c:	4818      	ldr	r0, [pc, #96]	; (80004f0 <test_012_012_execute+0xf0>)
    test_println(" bytes");
#endif
  }

  /* [12.12.7] The size of an event source is printed.*/
  test_set_step(7);
 800048e:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventS: ");
 8000490:	f003 fcae 	bl	8003df0 <test_print>
    test_printn(sizeof(event_source_t));
 8000494:	4630      	mov	r0, r6
 8000496:	f003 fcbb 	bl	8003e10 <test_printn>
    test_println(" bytes");
 800049a:	4620      	mov	r0, r4
 800049c:	f003 fc88 	bl	8003db0 <test_println>
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 80004a0:	2308      	movs	r3, #8
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 80004a2:	4814      	ldr	r0, [pc, #80]	; (80004f4 <test_012_012_execute+0xf4>)
    test_println(" bytes");
#endif
  }

  /* [12.12.8] The size of an event listener is printed.*/
  test_set_step(8);
 80004a4:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_EVENTS || defined(__DOXYGEN__)
    test_print("--- EventL: ");
 80004a6:	f003 fca3 	bl	8003df0 <test_print>
    test_printn(sizeof(event_listener_t));
 80004aa:	2014      	movs	r0, #20
 80004ac:	f003 fcb0 	bl	8003e10 <test_printn>
    test_println(" bytes");
 80004b0:	4620      	mov	r0, r4
 80004b2:	f003 fc7d 	bl	8003db0 <test_println>
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 80004b6:	2309      	movs	r3, #9
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 80004b8:	480f      	ldr	r0, [pc, #60]	; (80004f8 <test_012_012_execute+0xf8>)
    test_println(" bytes");
#endif
  }

  /* [12.12.9] The size of a mailbox is printed.*/
  test_set_step(9);
 80004ba:	602b      	str	r3, [r5, #0]
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
 80004bc:	f003 fc98 	bl	8003df0 <test_print>
    test_printn(sizeof(mailbox_t));
 80004c0:	2028      	movs	r0, #40	; 0x28
 80004c2:	f003 fca5 	bl	8003e10 <test_printn>
    test_println(" bytes");
 80004c6:	4620      	mov	r0, r4
#endif
  }
}
 80004c8:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_set_step(9);
  {
#if CH_CFG_USE_MAILBOXES || defined(__DOXYGEN__)
    test_print("--- MailB.: ");
    test_printn(sizeof(mailbox_t));
    test_println(" bytes");
 80004cc:	f003 bc70 	b.w	8003db0 <test_println>
 80004d0:	2000133c 	.word	0x2000133c
 80004d4:	080065d4 	.word	0x080065d4
 80004d8:	080065c4 	.word	0x080065c4
 80004dc:	080065dc 	.word	0x080065dc
 80004e0:	080065ec 	.word	0x080065ec
 80004e4:	080065fc 	.word	0x080065fc
 80004e8:	0800660c 	.word	0x0800660c
 80004ec:	0800661c 	.word	0x0800661c
 80004f0:	0800662c 	.word	0x0800662c
 80004f4:	0800663c 	.word	0x0800663c
 80004f8:	0800664c 	.word	0x0800664c
 80004fc:	f3af 8000 	nop.w

08000500 <test_012_011_execute>:

static void test_012_011_setup(void) {
  chMtxObjectInit(&mtx1);
}

static void test_012_011_execute(void) {
 8000500:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;

  /* [12.11.1] A mutex is locked and unlocked. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8000504:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8000584 <test_012_011_execute+0x84>
 8000508:	2301      	movs	r3, #1
 800050a:	f8c8 3000 	str.w	r3, [r8]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800050e:	f003 fbef 	bl	8003cf0 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 8000512:	2400      	movs	r4, #0
    start = test_wait_tick();
 8000514:	4607      	mov	r7, r0
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8000516:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
      chMtxUnlock(&mtx1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800051a:	f242 750f 	movw	r5, #9999	; 0x270f

    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chMtxLock(&mtx1);
 800051e:	4816      	ldr	r0, [pc, #88]	; (8000578 <test_012_011_execute+0x78>)
 8000520:	f005 f87e 	bl	8005620 <chMtxLock>
      chMtxUnlock(&mtx1);
 8000524:	4814      	ldr	r0, [pc, #80]	; (8000578 <test_012_011_execute+0x78>)
 8000526:	f004 ffdb 	bl	80054e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 800052a:	4813      	ldr	r0, [pc, #76]	; (8000578 <test_012_011_execute+0x78>)
 800052c:	f005 f878 	bl	8005620 <chMtxLock>
      chMtxUnlock(&mtx1);
 8000530:	4811      	ldr	r0, [pc, #68]	; (8000578 <test_012_011_execute+0x78>)
 8000532:	f004 ffd5 	bl	80054e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8000536:	4810      	ldr	r0, [pc, #64]	; (8000578 <test_012_011_execute+0x78>)
 8000538:	f005 f872 	bl	8005620 <chMtxLock>
      chMtxUnlock(&mtx1);
 800053c:	480e      	ldr	r0, [pc, #56]	; (8000578 <test_012_011_execute+0x78>)
 800053e:	f004 ffcf 	bl	80054e0 <chMtxUnlock>
      chMtxLock(&mtx1);
 8000542:	480d      	ldr	r0, [pc, #52]	; (8000578 <test_012_011_execute+0x78>)
 8000544:	f005 f86c 	bl	8005620 <chMtxLock>
      chMtxUnlock(&mtx1);
 8000548:	480b      	ldr	r0, [pc, #44]	; (8000578 <test_012_011_execute+0x78>)
 800054a:	f004 ffc9 	bl	80054e0 <chMtxUnlock>
 800054e:	6a73      	ldr	r3, [r6, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8000550:	1bdb      	subs	r3, r3, r7
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000552:	42ab      	cmp	r3, r5
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      chMtxLock(&mtx1);
      chMtxUnlock(&mtx1);
      n++;
 8000554:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000558:	d9e1      	bls.n	800051e <test_012_011_execute+0x1e>
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 800055a:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 800055c:	4807      	ldr	r0, [pc, #28]	; (800057c <test_012_011_execute+0x7c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.11.2] The score is printed.*/
  test_set_step(2);
 800055e:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 8000562:	f003 fc45 	bl	8003df0 <test_print>
    test_printn(n * 4);
 8000566:	00a0      	lsls	r0, r4, #2
 8000568:	f003 fc52 	bl	8003e10 <test_printn>
    test_println(" lock+unlock/S");
 800056c:	4804      	ldr	r0, [pc, #16]	; (8000580 <test_012_011_execute+0x80>)
  }
}
 800056e:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [12.11.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" lock+unlock/S");
 8000572:	f003 bc1d 	b.w	8003db0 <test_println>
 8000576:	bf00      	nop
 8000578:	20001354 	.word	0x20001354
 800057c:	0800665c 	.word	0x0800665c
 8000580:	0800666c 	.word	0x0800666c
 8000584:	2000133c 	.word	0x2000133c
 8000588:	f3af 8000 	nop.w
 800058c:	f3af 8000 	nop.w

08000590 <test_012_010_execute>:

static void test_012_010_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_012_010_execute(void) {
 8000590:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint32_t n;

  /* [12.10.1] A semaphore is teken and released. The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 8000594:	f8df 807c 	ldr.w	r8, [pc, #124]	; 8000614 <test_012_010_execute+0x84>
 8000598:	2301      	movs	r3, #1
 800059a:	f8c8 3000 	str.w	r3, [r8]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 800059e:	f003 fba7 	bl	8003cf0 <test_wait_tick>
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 80005a2:	2400      	movs	r4, #0
    start = test_wait_tick();
 80005a4:	4607      	mov	r7, r0
 80005a6:	f04f 4680 	mov.w	r6, #1073741824	; 0x40000000
      chSemSignal(&sem1);
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80005aa:	f242 750f 	movw	r5, #9999	; 0x270f

    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemWait(&sem1);
 80005ae:	4816      	ldr	r0, [pc, #88]	; (8000608 <test_012_010_execute+0x78>)
 80005b0:	f004 ff0e 	bl	80053d0 <chSemWait>
      chSemSignal(&sem1);
 80005b4:	4814      	ldr	r0, [pc, #80]	; (8000608 <test_012_010_execute+0x78>)
 80005b6:	f004 fed3 	bl	8005360 <chSemSignal>
      chSemWait(&sem1);
 80005ba:	4813      	ldr	r0, [pc, #76]	; (8000608 <test_012_010_execute+0x78>)
 80005bc:	f004 ff08 	bl	80053d0 <chSemWait>
      chSemSignal(&sem1);
 80005c0:	4811      	ldr	r0, [pc, #68]	; (8000608 <test_012_010_execute+0x78>)
 80005c2:	f004 fecd 	bl	8005360 <chSemSignal>
      chSemWait(&sem1);
 80005c6:	4810      	ldr	r0, [pc, #64]	; (8000608 <test_012_010_execute+0x78>)
 80005c8:	f004 ff02 	bl	80053d0 <chSemWait>
      chSemSignal(&sem1);
 80005cc:	480e      	ldr	r0, [pc, #56]	; (8000608 <test_012_010_execute+0x78>)
 80005ce:	f004 fec7 	bl	8005360 <chSemSignal>
      chSemWait(&sem1);
 80005d2:	480d      	ldr	r0, [pc, #52]	; (8000608 <test_012_010_execute+0x78>)
 80005d4:	f004 fefc 	bl	80053d0 <chSemWait>
      chSemSignal(&sem1);
 80005d8:	480b      	ldr	r0, [pc, #44]	; (8000608 <test_012_010_execute+0x78>)
 80005da:	f004 fec1 	bl	8005360 <chSemSignal>
 80005de:	6a73      	ldr	r3, [r6, #36]	; 0x24
 80005e0:	1bdb      	subs	r3, r3, r7
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80005e2:	42ab      	cmp	r3, r5
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      chSemWait(&sem1);
      chSemSignal(&sem1);
      n++;
 80005e4:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80005e8:	d9e1      	bls.n	80005ae <test_012_010_execute+0x1e>
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 80005ea:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80005ec:	4807      	ldr	r0, [pc, #28]	; (800060c <test_012_010_execute+0x7c>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.10.2] The score is printed.*/
  test_set_step(2);
 80005ee:	f8c8 3000 	str.w	r3, [r8]
  {
    test_print("--- Score : ");
 80005f2:	f003 fbfd 	bl	8003df0 <test_print>
    test_printn(n * 4);
 80005f6:	00a0      	lsls	r0, r4, #2
 80005f8:	f003 fc0a 	bl	8003e10 <test_printn>
    test_println(" wait+signal/S");
 80005fc:	4804      	ldr	r0, [pc, #16]	; (8000610 <test_012_010_execute+0x80>)
  }
}
 80005fe:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [12.10.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 4);
    test_println(" wait+signal/S");
 8000602:	f003 bbd5 	b.w	8003db0 <test_println>
 8000606:	bf00      	nop
 8000608:	2000099c 	.word	0x2000099c
 800060c:	0800665c 	.word	0x0800665c
 8000610:	0800667c 	.word	0x0800667c
 8000614:	2000133c 	.word	0x2000133c
 8000618:	f3af 8000 	nop.w
 800061c:	f3af 8000 	nop.w

08000620 <test_012_009_execute>:
 *   one-second time window.
 * - [12.9.2] The score is printed.
 * .
 */

static void test_012_009_execute(void) {
 8000620:	b570      	push	{r4, r5, r6, lr}
  uint32_t n;

  /* [12.9.1] Two timers are set then reset without waiting for their
     counter to elapse. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8000622:	4e1b      	ldr	r6, [pc, #108]	; (8000690 <test_012_009_execute+0x70>)
 8000624:	2301      	movs	r3, #1
 8000626:	6033      	str	r3, [r6, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 8000628:	f003 fb62 	bl	8003cf0 <test_wait_tick>
     one-second time window.*/
  test_set_step(1);
  {
    systime_t start, end;

    n = 0;
 800062c:	2400      	movs	r4, #0
    start = test_wait_tick();
 800062e:	4605      	mov	r5, r0
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000630:	2320      	movs	r3, #32
 8000632:	f383 8811 	msr	BASEPRI, r3
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chVTDoSetI(&vt1, 1, tmo, NULL);
 8000636:	4817      	ldr	r0, [pc, #92]	; (8000694 <test_012_009_execute+0x74>)
 8000638:	4a17      	ldr	r2, [pc, #92]	; (8000698 <test_012_009_execute+0x78>)
 800063a:	2101      	movs	r1, #1
 800063c:	2300      	movs	r3, #0
 800063e:	f005 f897 	bl	8005770 <chVTDoSetI>
      chVTDoSetI(&vt2, 10000, tmo, NULL);
 8000642:	4a15      	ldr	r2, [pc, #84]	; (8000698 <test_012_009_execute+0x78>)
 8000644:	4815      	ldr	r0, [pc, #84]	; (800069c <test_012_009_execute+0x7c>)
 8000646:	f242 7110 	movw	r1, #10000	; 0x2710
 800064a:	2300      	movs	r3, #0
 800064c:	f005 f890 	bl	8005770 <chVTDoSetI>
      chVTDoResetI(&vt1);
 8000650:	4810      	ldr	r0, [pc, #64]	; (8000694 <test_012_009_execute+0x74>)
 8000652:	f005 f855 	bl	8005700 <chVTDoResetI>
      chVTDoResetI(&vt2);
 8000656:	4811      	ldr	r0, [pc, #68]	; (800069c <test_012_009_execute+0x7c>)
 8000658:	f005 f852 	bl	8005700 <chVTDoResetI>
 800065c:	2300      	movs	r3, #0
 800065e:	f383 8811 	msr	BASEPRI, r3
 8000662:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      chSysUnlock();
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000666:	f242 720f 	movw	r2, #9999	; 0x270f
 800066a:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800066c:	1b5b      	subs	r3, r3, r5
 800066e:	4293      	cmp	r3, r2
      chVTDoSetI(&vt1, 1, tmo, NULL);
      chVTDoSetI(&vt2, 10000, tmo, NULL);
      chVTDoResetI(&vt1);
      chVTDoResetI(&vt2);
      chSysUnlock();
      n++;
 8000670:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000674:	d9dc      	bls.n	8000630 <test_012_009_execute+0x10>
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 8000676:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8000678:	4809      	ldr	r0, [pc, #36]	; (80006a0 <test_012_009_execute+0x80>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.9.2] The score is printed.*/
  test_set_step(2);
 800067a:	6033      	str	r3, [r6, #0]
  {
    test_print("--- Score : ");
 800067c:	f003 fbb8 	bl	8003df0 <test_print>
    test_printn(n * 2);
 8000680:	0060      	lsls	r0, r4, #1
 8000682:	f003 fbc5 	bl	8003e10 <test_printn>
    test_println(" timers/S");
 8000686:	4807      	ldr	r0, [pc, #28]	; (80006a4 <test_012_009_execute+0x84>)
  }
}
 8000688:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  /* [12.9.2] The score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" timers/S");
 800068c:	f003 bb90 	b.w	8003db0 <test_println>
 8000690:	2000133c 	.word	0x2000133c
 8000694:	20000c38 	.word	0x20000c38
 8000698:	08004351 	.word	0x08004351
 800069c:	20001368 	.word	0x20001368
 80006a0:	0800665c 	.word	0x0800665c
 80006a4:	0800668c 	.word	0x0800668c
 80006a8:	f3af 8000 	nop.w
 80006ac:	f3af 8000 	nop.w

080006b0 <test_012_004_execute>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80006b0:	4b2e      	ldr	r3, [pc, #184]	; (800076c <test_012_004_execute+0xbc>)
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80006b2:	4a2f      	ldr	r2, [pc, #188]	; (8000770 <test_012_004_execute+0xc0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80006b4:	699b      	ldr	r3, [r3, #24]
 80006b6:	482f      	ldr	r0, [pc, #188]	; (8000774 <test_012_004_execute+0xc4>)
 80006b8:	6899      	ldr	r1, [r3, #8]
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 80006ba:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80006be:	f8df b0c4 	ldr.w	fp, [pc, #196]	; 8000784 <test_012_004_execute+0xd4>
 * - [12.4.3] Stopping the target thread.
 * - [12.4.4] Score is printed.
 * .
 */

static void test_012_004_execute(void) {
 80006c2:	b083      	sub	sp, #12
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80006c4:	3101      	adds	r1, #1
static void test_012_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80006c6:	2401      	movs	r4, #1
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80006c8:	2300      	movs	r3, #0
static void test_012_004_execute(void) {
  thread_t *tp;
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
 80006ca:	f8cb 4000 	str.w	r4, [fp]
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80006ce:	f005 f9cf 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80006d2:	4a29      	ldr	r2, [pc, #164]	; (8000778 <test_012_004_execute+0xc8>)
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 80006d4:	2302      	movs	r3, #2
  uint32_t n;

  /* [12.4.1] Starting the target thread at an higher priority level.*/
  test_set_step(1);
  {
    tp = threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1,
 80006d6:	4604      	mov	r4, r0
 80006d8:	6010      	str	r0, [r2, #0]
                                        bmk_thread4, NULL);
  }

  /* [12.4.2] Waking up the thread as fast as possible in a one second
     time window.*/
  test_set_step(2);
 80006da:	f8cb 3000 	str.w	r3, [fp]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80006de:	f003 fb07 	bl	8003cf0 <test_wait_tick>
     time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80006e2:	2500      	movs	r5, #0
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 80006e4:	46aa      	mov	sl, r5
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80006e6:	4681      	mov	r9, r0
 80006e8:	f04f 0820 	mov.w	r8, #32
 80006ec:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 80006f0:	2620      	movs	r6, #32
 80006f2:	f388 8811 	msr	BASEPRI, r8
    end = start + MS2ST(1000);
    do {
      chSysLock();
      chSchWakeupS(tp, MSG_OK);
 80006f6:	2100      	movs	r1, #0
 80006f8:	4620      	mov	r0, r4
 80006fa:	f004 fe01 	bl	8005300 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 80006fe:	4620      	mov	r0, r4
 8000700:	2100      	movs	r1, #0
 8000702:	f004 fdfd 	bl	8005300 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 8000706:	4620      	mov	r0, r4
 8000708:	2100      	movs	r1, #0
 800070a:	f004 fdf9 	bl	8005300 <chSchWakeupS>
      chSchWakeupS(tp, MSG_OK);
 800070e:	4620      	mov	r0, r4
 8000710:	2100      	movs	r1, #0
 8000712:	f004 fdf5 	bl	8005300 <chSchWakeupS>
 8000716:	2200      	movs	r2, #0
 8000718:	f38a 8811 	msr	BASEPRI, sl
 800071c:	6a7b      	ldr	r3, [r7, #36]	; 0x24
      chSysUnlock();
      n += 4;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800071e:	f242 710f 	movw	r1, #9999	; 0x270f
 8000722:	ebc9 0303 	rsb	r3, r9, r3
 8000726:	428b      	cmp	r3, r1
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSchWakeupS(tp, MSG_OK);
      chSysUnlock();
      n += 4;
 8000728:	f105 0504 	add.w	r5, r5, #4
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800072c:	d9e0      	bls.n	80006f0 <test_012_004_execute+0x40>
  }

  /* [12.4.3] Stopping the target thread.*/
  test_set_step(3);
 800072e:	2303      	movs	r3, #3
 8000730:	9201      	str	r2, [sp, #4]
 8000732:	f8cb 3000 	str.w	r3, [fp]
 8000736:	f386 8811 	msr	BASEPRI, r6
  {
    chSysLock();
    chSchWakeupS(tp, MSG_TIMEOUT);
 800073a:	f04f 31ff 	mov.w	r1, #4294967295
 800073e:	4620      	mov	r0, r4
 8000740:	f004 fdde 	bl	8005300 <chSchWakeupS>
 8000744:	9a01      	ldr	r2, [sp, #4]
 8000746:	f382 8811 	msr	BASEPRI, r2
    chSysUnlock();
    test_wait_threads();
 800074a:	f003 fae1 	bl	8003d10 <test_wait_threads>
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 800074e:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8000750:	480a      	ldr	r0, [pc, #40]	; (800077c <test_012_004_execute+0xcc>)
    chSysUnlock();
    test_wait_threads();
  }

  /* [12.4.4] Score is printed.*/
  test_set_step(4);
 8000752:	f8cb 3000 	str.w	r3, [fp]
  {
    test_print("--- Score : ");
 8000756:	f003 fb4b 	bl	8003df0 <test_print>
    test_printn(n * 2);
 800075a:	0068      	lsls	r0, r5, #1
 800075c:	f003 fb58 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 8000760:	4807      	ldr	r0, [pc, #28]	; (8000780 <test_012_004_execute+0xd0>)
  }
}
 8000762:	b003      	add	sp, #12
 8000764:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  /* [12.4.4] Score is printed.*/
  test_set_step(4);
  {
    test_print("--- Score : ");
    test_printn(n * 2);
    test_println(" ctxswc/S");
 8000768:	f003 bb22 	b.w	8003db0 <test_println>
 800076c:	200013b0 	.word	0x200013b0
 8000770:	08004481 	.word	0x08004481
 8000774:	20000c50 	.word	0x20000c50
 8000778:	20001340 	.word	0x20001340
 800077c:	0800665c 	.word	0x0800665c
 8000780:	08006698 	.word	0x08006698
 8000784:	2000133c 	.word	0x2000133c
 8000788:	f3af 8000 	nop.w
 800078c:	f3af 8000 	nop.w

08000790 <test_012_008_execute>:
 * - [12.8.2] Waiting one second then terminating the 5 threads.
 * - [12.8.3] The score is printed.
 * .
 */

static void test_012_008_execute(void) {
 8000790:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 8000794:	b083      	sub	sp, #12
  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
  {
    n = 0;
 8000796:	ac02      	add	r4, sp, #8
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000798:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 800086c <test_012_008_execute+0xdc>
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 800079c:	f8df 90d0 	ldr.w	r9, [pc, #208]	; 8000870 <test_012_008_execute+0xe0>
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80007a0:	4f2d      	ldr	r7, [pc, #180]	; (8000858 <test_012_008_execute+0xc8>)
 80007a2:	4e2e      	ldr	r6, [pc, #184]	; (800085c <test_012_008_execute+0xcc>)
 80007a4:	4d2e      	ldr	r5, [pc, #184]	; (8000860 <test_012_008_execute+0xd0>)
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 80007a6:	2201      	movs	r2, #1
  {
    n = 0;
 80007a8:	2300      	movs	r3, #0
 80007aa:	f844 3d04 	str.w	r3, [r4, #-4]!
  uint32_t n;

  /* [12.8.1] The five threads are created at lower priority. The
     threds have equal priority and start calling @p chThdYield()
     continuously.*/
  test_set_step(1);
 80007ae:	f8c9 2000 	str.w	r2, [r9]
  {
    n = 0;
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80007b2:	f003 fa9d 	bl	8003cf0 <test_wait_tick>
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80007b6:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80007ba:	6899      	ldr	r1, [r3, #8]
 80007bc:	4632      	mov	r2, r6
 80007be:	4623      	mov	r3, r4
 80007c0:	3901      	subs	r1, #1
 80007c2:	4638      	mov	r0, r7
 80007c4:	f005 f954 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80007c8:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80007cc:	6028      	str	r0, [r5, #0]

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80007ce:	6899      	ldr	r1, [r3, #8]
 80007d0:	4632      	mov	r2, r6
 80007d2:	4623      	mov	r3, r4
 80007d4:	3901      	subs	r1, #1
 80007d6:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 80007da:	f005 f949 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80007de:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80007e2:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80007e4:	6899      	ldr	r1, [r3, #8]
 80007e6:	4632      	mov	r2, r6
 80007e8:	4623      	mov	r3, r4
 80007ea:	3901      	subs	r1, #1
 80007ec:	f507 7024 	add.w	r0, r7, #656	; 0x290
 80007f0:	f005 f93e 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80007f4:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80007f8:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 80007fa:	6899      	ldr	r1, [r3, #8]
 80007fc:	4632      	mov	r2, r6
 80007fe:	4623      	mov	r3, r4
 8000800:	3901      	subs	r1, #1
 8000802:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 8000806:	f005 f933 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800080a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800080e:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8000810:	6899      	ldr	r1, [r3, #8]
 8000812:	4632      	mov	r2, r6
 8000814:	3901      	subs	r1, #1
 8000816:	4623      	mov	r3, r4
 8000818:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 800081c:	f005 f928 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8000820:	2302      	movs	r3, #2
    test_wait_tick();threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);

    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
 8000822:	6128      	str	r0, [r5, #16]
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
  {
    chThdSleepSeconds(1);
 8000824:	f242 7010 	movw	r0, #10000	; 0x2710
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, bmk_thread8, (void *)&n);
  }

  /* [12.8.2] Waiting one second then terminating the 5 threads.*/
  test_set_step(2);
 8000828:	f8c9 3000 	str.w	r3, [r9]
  {
    chThdSleepSeconds(1);
 800082c:	f005 f840 	bl	80058b0 <chThdSleep>
    test_terminate_threads();
 8000830:	f003 fa86 	bl	8003d40 <test_terminate_threads>
    test_wait_threads();
 8000834:	f003 fa6c 	bl	8003d10 <test_wait_threads>
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 8000838:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800083a:	480a      	ldr	r0, [pc, #40]	; (8000864 <test_012_008_execute+0xd4>)
    test_terminate_threads();
    test_wait_threads();
  }

  /* [12.8.3] The score is printed.*/
  test_set_step(3);
 800083c:	f8c9 3000 	str.w	r3, [r9]
  {
    test_print("--- Score : ");
 8000840:	f003 fad6 	bl	8003df0 <test_print>
    test_printn(n);
 8000844:	9801      	ldr	r0, [sp, #4]
 8000846:	f003 fae3 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 800084a:	4807      	ldr	r0, [pc, #28]	; (8000868 <test_012_008_execute+0xd8>)
 800084c:	f003 fab0 	bl	8003db0 <test_println>
  }
}
 8000850:	b003      	add	sp, #12
 8000852:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000856:	bf00      	nop
 8000858:	20000c50 	.word	0x20000c50
 800085c:	08004421 	.word	0x08004421
 8000860:	20001340 	.word	0x20001340
 8000864:	0800665c 	.word	0x0800665c
 8000868:	08006698 	.word	0x08006698
 800086c:	200013b0 	.word	0x200013b0
 8000870:	2000133c 	.word	0x2000133c
 8000874:	f3af 8000 	nop.w
 8000878:	f3af 8000 	nop.w
 800087c:	f3af 8000 	nop.w

08000880 <test_012_007_execute>:

static void test_012_007_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_012_007_execute(void) {
 8000880:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000882:	4d32      	ldr	r5, [pc, #200]	; (800094c <test_012_007_execute+0xcc>)
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8000884:	4f32      	ldr	r7, [pc, #200]	; (8000950 <test_012_007_execute+0xd0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8000886:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8000888:	4a32      	ldr	r2, [pc, #200]	; (8000954 <test_012_007_execute+0xd4>)
 800088a:	6899      	ldr	r1, [r3, #8]
 800088c:	4832      	ldr	r0, [pc, #200]	; (8000958 <test_012_007_execute+0xd8>)
 800088e:	4c33      	ldr	r4, [pc, #204]	; (800095c <test_012_007_execute+0xdc>)
static void test_012_007_execute(void) {
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8000890:	2601      	movs	r6, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8000892:	3105      	adds	r1, #5
 8000894:	2300      	movs	r3, #0
static void test_012_007_execute(void) {
  uint32_t n;

  /* [12.7.1] Five threads are created at higher priority that
     immediately enqueue on a semaphore.*/
  test_set_step(1);
 8000896:	603e      	str	r6, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
 8000898:	f005 f8ea 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800089c:	69ab      	ldr	r3, [r5, #24]
 800089e:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
 80008a0:	6899      	ldr	r1, [r3, #8]
 80008a2:	4a2c      	ldr	r2, [pc, #176]	; (8000954 <test_012_007_execute+0xd4>)
 80008a4:	482e      	ldr	r0, [pc, #184]	; (8000960 <test_012_007_execute+0xe0>)
 80008a6:	3104      	adds	r1, #4
 80008a8:	2300      	movs	r3, #0
 80008aa:	f005 f8e1 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80008ae:	69ab      	ldr	r3, [r5, #24]
 80008b0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
 80008b2:	6899      	ldr	r1, [r3, #8]
 80008b4:	4a27      	ldr	r2, [pc, #156]	; (8000954 <test_012_007_execute+0xd4>)
 80008b6:	482b      	ldr	r0, [pc, #172]	; (8000964 <test_012_007_execute+0xe4>)
 80008b8:	3103      	adds	r1, #3
 80008ba:	2300      	movs	r3, #0
 80008bc:	f005 f8d8 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80008c0:	69ab      	ldr	r3, [r5, #24]
 80008c2:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
 80008c4:	6899      	ldr	r1, [r3, #8]
 80008c6:	4a23      	ldr	r2, [pc, #140]	; (8000954 <test_012_007_execute+0xd4>)
 80008c8:	4827      	ldr	r0, [pc, #156]	; (8000968 <test_012_007_execute+0xe8>)
 80008ca:	3102      	adds	r1, #2
 80008cc:	2300      	movs	r3, #0
 80008ce:	f005 f8cf 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80008d2:	69ab      	ldr	r3, [r5, #24]
 80008d4:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80008d6:	6899      	ldr	r1, [r3, #8]
 80008d8:	4a1e      	ldr	r2, [pc, #120]	; (8000954 <test_012_007_execute+0xd4>)
 80008da:	4824      	ldr	r0, [pc, #144]	; (800096c <test_012_007_execute+0xec>)
 80008dc:	4431      	add	r1, r6
 80008de:	2300      	movs	r3, #0
 80008e0:	f005 f8c6 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 80008e4:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, bmk_thread7, NULL);
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+4, bmk_thread7, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, bmk_thread7, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+2, bmk_thread7, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+1, bmk_thread7, NULL);
 80008e6:	6120      	str	r0, [r4, #16]
  }

  /* [12.7.2] The semaphore is reset waking up the five threads. The
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
 80008e8:	603b      	str	r3, [r7, #0]
  {
    systime_t start, end;

    n = 0;
    start = test_wait_tick();
 80008ea:	f003 fa01 	bl	8003cf0 <test_wait_tick>
     operation is repeated continuously in a one-second time window.*/
  test_set_step(2);
  {
    systime_t start, end;

    n = 0;
 80008ee:	2400      	movs	r4, #0
    start = test_wait_tick();
 80008f0:	4606      	mov	r6, r0
 80008f2:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
 80008f6:	481e      	ldr	r0, [pc, #120]	; (8000970 <test_012_007_execute+0xf0>)
 80008f8:	2100      	movs	r1, #0
 80008fa:	f004 fec9 	bl	8005690 <chSemReset>
 80008fe:	6a6b      	ldr	r3, [r5, #36]	; 0x24
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000900:	f242 720f 	movw	r2, #9999	; 0x270f
 8000904:	1b9b      	subs	r3, r3, r6
 8000906:	4293      	cmp	r3, r2
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chSemReset(&sem1, 0);
      n++;
 8000908:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 800090c:	d9f3      	bls.n	80008f6 <test_012_007_execute+0x76>
  }

  /* [12.7.3] The five threads are terminated.*/
  test_set_step(3);
 800090e:	2303      	movs	r3, #3
 8000910:	603b      	str	r3, [r7, #0]
  {
    test_terminate_threads();
 8000912:	f003 fa15 	bl	8003d40 <test_terminate_threads>
    chSemReset(&sem1, 0);
 8000916:	2100      	movs	r1, #0
 8000918:	4815      	ldr	r0, [pc, #84]	; (8000970 <test_012_007_execute+0xf0>)
 800091a:	f004 feb9 	bl	8005690 <chSemReset>
    test_wait_threads();
 800091e:	f003 f9f7 	bl	8003d10 <test_wait_threads>
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8000922:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8000924:	4813      	ldr	r0, [pc, #76]	; (8000974 <test_012_007_execute+0xf4>)
    chSemReset(&sem1, 0);
    test_wait_threads();
  }

  /* [12.7.4] The score is printed.*/
  test_set_step(4);
 8000926:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8000928:	f003 fa62 	bl	8003df0 <test_print>
    test_printn(n);
 800092c:	4620      	mov	r0, r4
 800092e:	f003 fa6f 	bl	8003e10 <test_printn>
    test_print(" reschedules/S, ");
 8000932:	4811      	ldr	r0, [pc, #68]	; (8000978 <test_012_007_execute+0xf8>)
 8000934:	f003 fa5c 	bl	8003df0 <test_print>
    test_printn(n * 6);
 8000938:	eb04 0044 	add.w	r0, r4, r4, lsl #1
 800093c:	0040      	lsls	r0, r0, #1
 800093e:	f003 fa67 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 8000942:	480e      	ldr	r0, [pc, #56]	; (800097c <test_012_007_execute+0xfc>)
  }
}
 8000944:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" reschedules/S, ");
    test_printn(n * 6);
    test_println(" ctxswc/S");
 8000948:	f003 ba32 	b.w	8003db0 <test_println>
 800094c:	200013b0 	.word	0x200013b0
 8000950:	2000133c 	.word	0x2000133c
 8000954:	08004451 	.word	0x08004451
 8000958:	20000c50 	.word	0x20000c50
 800095c:	20001340 	.word	0x20001340
 8000960:	20000d98 	.word	0x20000d98
 8000964:	20000ee0 	.word	0x20000ee0
 8000968:	20001028 	.word	0x20001028
 800096c:	20001170 	.word	0x20001170
 8000970:	2000099c 	.word	0x2000099c
 8000974:	0800665c 	.word	0x0800665c
 8000978:	080066a4 	.word	0x080066a4
 800097c:	08006698 	.word	0x08006698

08000980 <test_012_006_execute>:
 *   one-second time window.
 * - [12.6.2] Score is printed.
 * .
 */

static void test_012_006_execute(void) {
 8000980:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8000982:	4b15      	ldr	r3, [pc, #84]	; (80009d8 <test_012_006_execute+0x58>)
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 8000984:	4f15      	ldr	r7, [pc, #84]	; (80009dc <test_012_006_execute+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8000986:	699b      	ldr	r3, [r3, #24]
 * .
 */

static void test_012_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 8000988:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800098a:	2301      	movs	r3, #1
 * .
 */

static void test_012_006_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() + 1;
 800098c:	441d      	add	r5, r3
  systime_t start, end;

  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
 800098e:	603b      	str	r3, [r7, #0]
  {
    n = 0;
    start = test_wait_tick();
 8000990:	f003 f9ae 	bl	8003cf0 <test_wait_tick>
  /* [12.6.1] A thread is created at an higher priority level and let
     terminate immediately. The operation is repeated continuously in a
     one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 8000994:	2400      	movs	r4, #0
    start = test_wait_tick();
 8000996:	4606      	mov	r6, r0
    end = start + MS2ST(1000);
    do {
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8000998:	4a11      	ldr	r2, [pc, #68]	; (80009e0 <test_012_006_execute+0x60>)
 800099a:	4812      	ldr	r0, [pc, #72]	; (80009e4 <test_012_006_execute+0x64>)
 800099c:	2300      	movs	r3, #0
 800099e:	4629      	mov	r1, r5
 80009a0:	f005 f866 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80009a4:	f004 fbcc 	bl	8005140 <chThdRelease>
 80009a8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
#endif
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80009ac:	f242 720f 	movw	r2, #9999	; 0x270f
 80009b0:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80009b2:	1b9b      	subs	r3, r3, r6
 80009b4:	4293      	cmp	r3, r2
#if CH_CFG_USE_REGISTRY
      chThdRelease(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
#else
      chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL);
#endif
      n++;
 80009b6:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 80009ba:	d9ed      	bls.n	8000998 <test_012_006_execute+0x18>
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 80009bc:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 80009be:	480a      	ldr	r0, [pc, #40]	; (80009e8 <test_012_006_execute+0x68>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.6.2] Score is printed.*/
  test_set_step(2);
 80009c0:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 80009c2:	f003 fa15 	bl	8003df0 <test_print>
    test_printn(n);
 80009c6:	4620      	mov	r0, r4
 80009c8:	f003 fa22 	bl	8003e10 <test_printn>
    test_println(" threads/S");
 80009cc:	4807      	ldr	r0, [pc, #28]	; (80009ec <test_012_006_execute+0x6c>)
  }
}
 80009ce:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [12.6.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 80009d2:	f003 b9ed 	b.w	8003db0 <test_println>
 80009d6:	bf00      	nop
 80009d8:	200013b0 	.word	0x200013b0
 80009dc:	2000133c 	.word	0x2000133c
 80009e0:	08004f71 	.word	0x08004f71
 80009e4:	20000c50 	.word	0x20000c50
 80009e8:	0800665c 	.word	0x0800665c
 80009ec:	080066b8 	.word	0x080066b8

080009f0 <test_012_005_execute>:
 *   repeated continuously in a one-second time window.
 * - [12.5.2] Score is printed.
 * .
 */

static void test_012_005_execute(void) {
 80009f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80009f2:	4b15      	ldr	r3, [pc, #84]	; (8000a48 <test_012_005_execute+0x58>)
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80009f4:	4f15      	ldr	r7, [pc, #84]	; (8000a4c <test_012_005_execute+0x5c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80009f6:	699b      	ldr	r3, [r3, #24]
 * .
 */

static void test_012_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 80009f8:	689d      	ldr	r5, [r3, #8]
  systime_t start, end;

  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
 80009fa:	2301      	movs	r3, #1
 80009fc:	603b      	str	r3, [r7, #0]
  {
    n = 0;
    start = test_wait_tick();
 80009fe:	f003 f977 	bl	8003cf0 <test_wait_tick>
 * .
 */

static void test_012_005_execute(void) {
  uint32_t n;
  tprio_t prio = chThdGetPriorityX() - 1;
 8000a02:	3d01      	subs	r5, #1
  /* [12.5.1] A thread is created at a lower priority level and its
     termination detected using @p chThdWait(). The operation is
     repeated continuously in a one-second time window.*/
  test_set_step(1);
  {
    n = 0;
 8000a04:	2400      	movs	r4, #0
    start = test_wait_tick();
 8000a06:	4606      	mov	r6, r0
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
 8000a08:	4a11      	ldr	r2, [pc, #68]	; (8000a50 <test_012_005_execute+0x60>)
 8000a0a:	4812      	ldr	r0, [pc, #72]	; (8000a54 <test_012_005_execute+0x64>)
 8000a0c:	2300      	movs	r3, #0
 8000a0e:	4629      	mov	r1, r5
 8000a10:	f005 f82e 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8000a14:	f004 fd04 	bl	8005420 <chThdWait>
 8000a18:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
      n++;
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000a1c:	f242 720f 	movw	r2, #9999	; 0x270f
 8000a20:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8000a22:	1b9b      	subs	r3, r3, r6
 8000a24:	4293      	cmp	r3, r2
    n = 0;
    start = test_wait_tick();
    end = start + MS2ST(1000);
    do {
      chThdWait(chThdCreateStatic(wa[0], WA_SIZE, prio, bmk_thread3, NULL));
      n++;
 8000a26:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
 8000a2a:	d9ed      	bls.n	8000a08 <test_012_005_execute+0x18>
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 8000a2c:	2302      	movs	r3, #2
  {
    test_print("--- Score : ");
 8000a2e:	480a      	ldr	r0, [pc, #40]	; (8000a58 <test_012_005_execute+0x68>)
#endif
    } while (chVTIsSystemTimeWithinX(start, end));
  }

  /* [12.5.2] Score is printed.*/
  test_set_step(2);
 8000a30:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8000a32:	f003 f9dd 	bl	8003df0 <test_print>
    test_printn(n);
 8000a36:	4620      	mov	r0, r4
 8000a38:	f003 f9ea 	bl	8003e10 <test_printn>
    test_println(" threads/S");
 8000a3c:	4807      	ldr	r0, [pc, #28]	; (8000a5c <test_012_005_execute+0x6c>)
  }
}
 8000a3e:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [12.5.2] Score is printed.*/
  test_set_step(2);
  {
    test_print("--- Score : ");
    test_printn(n);
    test_println(" threads/S");
 8000a42:	f003 b9b5 	b.w	8003db0 <test_println>
 8000a46:	bf00      	nop
 8000a48:	200013b0 	.word	0x200013b0
 8000a4c:	2000133c 	.word	0x2000133c
 8000a50:	08004f71 	.word	0x08004f71
 8000a54:	20000c50 	.word	0x20000c50
 8000a58:	0800665c 	.word	0x0800665c
 8000a5c:	080066b8 	.word	0x080066b8

08000a60 <main>:
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000a60:	4bb9      	ldr	r3, [pc, #740]	; (8000d48 <main+0x2e8>)
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000a62:	48ba      	ldr	r0, [pc, #744]	; (8000d4c <main+0x2ec>)
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 8000a64:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8000a66:	f04f 31ff 	mov.w	r1, #4294967295
 8000a6a:	2200      	movs	r2, #0
}

/*
 * Application entry point.
 */
int main(void) {
 8000a6c:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 8000a70:	6299      	str	r1, [r3, #40]	; 0x28
 8000a72:	629a      	str	r2, [r3, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8000a74:	691c      	ldr	r4, [r3, #16]
 8000a76:	6119      	str	r1, [r3, #16]
 8000a78:	611a      	str	r2, [r3, #16]
  rccResetAPB2(0xFFFFFFFF);
 8000a7a:	68dc      	ldr	r4, [r3, #12]
 8000a7c:	60d9      	str	r1, [r3, #12]
 8000a7e:	60da      	str	r2, [r3, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8000a80:	69d9      	ldr	r1, [r3, #28]
 8000a82:	f041 5180 	orr.w	r1, r1, #268435456	; 0x10000000
 8000a86:	61d9      	str	r1, [r3, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8000a88:	6801      	ldr	r1, [r0, #0]
 8000a8a:	f441 7180 	orr.w	r1, r1, #256	; 0x100
 8000a8e:	6001      	str	r1, [r0, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8000a90:	6a19      	ldr	r1, [r3, #32]
 8000a92:	f401 7140 	and.w	r1, r1, #768	; 0x300
 8000a96:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8000a9a:	b089      	sub	sp, #36	; 0x24
 8000a9c:	d003      	beq.n	8000aa6 <main+0x46>
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 8000a9e:	f44f 3180 	mov.w	r1, #65536	; 0x10000
 8000aa2:	6219      	str	r1, [r3, #32]
    RCC->BDCR = 0;
 8000aa4:	621a      	str	r2, [r3, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8000aa6:	4ba8      	ldr	r3, [pc, #672]	; (8000d48 <main+0x2e8>)
 8000aa8:	6a1a      	ldr	r2, [r3, #32]
 8000aaa:	0412      	lsls	r2, r2, #16
 8000aac:	d407      	bmi.n	8000abe <main+0x5e>
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 8000aae:	6a1a      	ldr	r2, [r3, #32]
 8000ab0:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8000ab4:	621a      	str	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8000ab6:	6a1a      	ldr	r2, [r3, #32]
 8000ab8:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8000abc:	621a      	str	r2, [r3, #32]
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000abe:	4da2      	ldr	r5, [pc, #648]	; (8000d48 <main+0x2e8>)

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8000ac0:	4fa3      	ldr	r7, [pc, #652]	; (8000d50 <main+0x2f0>)
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 8000ac2:	69ac      	ldr	r4, [r5, #24]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000ac4:	f8df a2e4 	ldr.w	sl, [pc, #740]	; 8000dac <main+0x34c>
  gpiop->PUPDR   = config->pupdr;
 8000ac8:	f8df e2e4 	ldr.w	lr, [pc, #740]	; 8000db0 <main+0x350>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000acc:	f8df 82e4 	ldr.w	r8, [pc, #740]	; 8000db4 <main+0x354>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ad0:	4ea0      	ldr	r6, [pc, #640]	; (8000d54 <main+0x2f4>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000ad2:	f8df 92e4 	ldr.w	r9, [pc, #740]	; 8000db8 <main+0x358>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ad6:	48a0      	ldr	r0, [pc, #640]	; (8000d58 <main+0x2f8>)
 8000ad8:	49a0      	ldr	r1, [pc, #640]	; (8000d5c <main+0x2fc>)
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000ada:	f8df b2e0 	ldr.w	fp, [pc, #736]	; 8000dbc <main+0x35c>
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000ade:	4aa0      	ldr	r2, [pc, #640]	; (8000d60 <main+0x300>)
 8000ae0:	4ba0      	ldr	r3, [pc, #640]	; (8000d64 <main+0x304>)
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
}
#else
void sdObjectInit(SerialDriver *sdp) {

  sdp->vmt = &vmt;
 8000ae2:	f8df c28c 	ldr.w	ip, [pc, #652]	; 8000d70 <main+0x310>
 8000ae6:	f044 0401 	orr.w	r4, r4, #1
 8000aea:	61ac      	str	r4, [r5, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8000aec:	683c      	ldr	r4, [r7, #0]
 8000aee:	f044 0420 	orr.w	r4, r4, #32
 8000af2:	603c      	str	r4, [r7, #0]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000af4:	696c      	ldr	r4, [r5, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000af6:	f04f 4790 	mov.w	r7, #1207959552	; 0x48000000
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 8000afa:	f444 04fc 	orr.w	r4, r4, #8257536	; 0x7e0000
 8000afe:	616c      	str	r4, [r5, #20]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b00:	2400      	movs	r4, #0
 8000b02:	607c      	str	r4, [r7, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b04:	f8c7 a008 	str.w	sl, [r7, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b08:	f8c7 e00c 	str.w	lr, [r7, #12]
  gpiop->ODR     = config->odr;
 8000b0c:	f64f 7eff 	movw	lr, #65535	; 0xffff
 8000b10:	f8c7 e014 	str.w	lr, [r7, #20]
  gpiop->AFRL    = config->afrl;
 8000b14:	f8c7 8020 	str.w	r8, [r7, #32]
  gpiop->AFRH    = config->afrh;
 8000b18:	f44f 286e 	mov.w	r8, #974848	; 0xee000
 8000b1c:	f8c7 8024 	str.w	r8, [r7, #36]	; 0x24

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000b20:	f04f 4a88 	mov.w	sl, #1140850688	; 0x44000000
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000b24:	f8c7 9000 	str.w	r9, [r7]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b28:	f04f 08c0 	mov.w	r8, #192	; 0xc0
  gpiop->OSPEEDR = config->ospeedr;
 8000b2c:	f24f 07c0 	movw	r7, #61632	; 0xf0c0
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b30:	f8c6 8004 	str.w	r8, [r6, #4]
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000b34:	f24a 0980 	movw	r9, #41088	; 0xa080
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000b38:	60b7      	str	r7, [r6, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b3a:	f8c6 b00c 	str.w	fp, [r6, #12]
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
 8000b3e:	f04f 4770 	mov.w	r7, #4026531840	; 0xf0000000
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000b42:	f8c6 e014 	str.w	lr, [r6, #20]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b46:	f04f 3b55 	mov.w	fp, #1431655765	; 0x55555555
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000b4a:	f8c6 a020 	str.w	sl, [r6, #32]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b4e:	f8df a270 	ldr.w	sl, [pc, #624]	; 8000dc0 <main+0x360>
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
 8000b52:	6274      	str	r4, [r6, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b54:	f8c6 9000 	str.w	r9, [r6]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b58:	6044      	str	r4, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b5a:	f8df 9268 	ldr.w	r9, [pc, #616]	; 8000dc4 <main+0x364>
 8000b5e:	6087      	str	r7, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
 8000b60:	26ff      	movs	r6, #255	; 0xff

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b62:	f8c0 a00c 	str.w	sl, [r0, #12]
 8000b66:	4f80      	ldr	r7, [pc, #512]	; (8000d68 <main+0x308>)
  gpiop->ODR     = config->odr;
 8000b68:	f8c0 e014 	str.w	lr, [r0, #20]
  gpiop->AFRL    = config->afrl;
  gpiop->AFRH    = config->afrh;
  gpiop->MODER   = config->moder;
 8000b6c:	f8df a258 	ldr.w	sl, [pc, #600]	; 8000dc8 <main+0x368>

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
  gpiop->ODR     = config->odr;
  gpiop->AFRL    = config->afrl;
 8000b70:	6204      	str	r4, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8000b72:	6244      	str	r4, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b74:	6004      	str	r4, [r0, #0]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b76:	604c      	str	r4, [r1, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b78:	200f      	movs	r0, #15
 8000b7a:	608c      	str	r4, [r1, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b7c:	f8c1 b00c 	str.w	fp, [r1, #12]
  gpiop->ODR     = config->odr;
 8000b80:	f8c1 e014 	str.w	lr, [r1, #20]
  gpiop->AFRL    = config->afrl;
 8000b84:	620c      	str	r4, [r1, #32]
  gpiop->AFRH    = config->afrh;
 8000b86:	624c      	str	r4, [r1, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b88:	600c      	str	r4, [r1, #0]

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
  gpiop->OSPEEDR = config->ospeedr;
  gpiop->PUPDR   = config->pupdr;
 8000b8a:	4978      	ldr	r1, [pc, #480]	; (8000d6c <main+0x30c>)
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b8c:	6054      	str	r4, [r2, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000b8e:	f8c2 9008 	str.w	r9, [r2, #8]
  gpiop->PUPDR   = config->pupdr;
 8000b92:	60d7      	str	r7, [r2, #12]
  gpiop->ODR     = config->odr;
 8000b94:	6156      	str	r6, [r2, #20]
  gpiop->AFRL    = config->afrl;
 8000b96:	6214      	str	r4, [r2, #32]
  gpiop->AFRH    = config->afrh;
 8000b98:	6254      	str	r4, [r2, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000b9a:	f8c2 a000 	str.w	sl, [r2]
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8000b9e:	605c      	str	r4, [r3, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8000ba0:	6098      	str	r0, [r3, #8]
  gpiop->PUPDR   = config->pupdr;
 8000ba2:	60d9      	str	r1, [r3, #12]
  gpiop->ODR     = config->odr;
 8000ba4:	f8c3 e014 	str.w	lr, [r3, #20]
  gpiop->AFRL    = config->afrl;
 8000ba8:	621c      	str	r4, [r3, #32]
  gpiop->AFRH    = config->afrh;
 8000baa:	625c      	str	r4, [r3, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8000bac:	601c      	str	r4, [r3, #0]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bae:	4b70      	ldr	r3, [pc, #448]	; (8000d70 <main+0x310>)
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000bb0:	f8df 9218 	ldr.w	r9, [pc, #536]	; 8000dcc <main+0x36c>
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8000bb4:	4f6f      	ldr	r7, [pc, #444]	; (8000d74 <main+0x314>)
 8000bb6:	4e70      	ldr	r6, [pc, #448]	; (8000d78 <main+0x318>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000bb8:	4a70      	ldr	r2, [pc, #448]	; (8000d7c <main+0x31c>)
 8000bba:	f84c 6b04 	str.w	r6, [ip], #4
 8000bbe:	f103 010c 	add.w	r1, r3, #12
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000bc2:	f1a1 000c 	sub.w	r0, r1, #12
 8000bc6:	3330      	adds	r3, #48	; 0x30
 8000bc8:	9301      	str	r3, [sp, #4]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8000bca:	4603      	mov	r3, r0
  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 8000bcc:	f109 0610 	add.w	r6, r9, #16
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 8000bd0:	f04f 0a01 	mov.w	sl, #1
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000bd4:	f04f 0b10 	mov.w	fp, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8000bd8:	f107 0e10 	add.w	lr, r7, #16
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
 8000bdc:	608c      	str	r4, [r1, #8]
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 8000bde:	6284      	str	r4, [r0, #40]	; 0x28
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {

  osalThreadQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
 8000be0:	f8c0 9018 	str.w	r9, [r0, #24]
  iqp->q_rdptr   = bp;
 8000be4:	f8c0 9024 	str.w	r9, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
 8000be8:	f8c0 9020 	str.w	r9, [r0, #32]
  iqp->q_top     = bp + size;
 8000bec:	61de      	str	r6, [r3, #28]
 8000bee:	60d9      	str	r1, [r3, #12]
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000bf0:	2620      	movs	r6, #32
  tqp->prev = (thread_t *)tqp;
 8000bf2:	6119      	str	r1, [r3, #16]
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8000bf4:	62c0      	str	r0, [r0, #44]	; 0x2c
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000bf6:	9901      	ldr	r1, [sp, #4]
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000bf8:	4861      	ldr	r0, [pc, #388]	; (8000d80 <main+0x320>)
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8000bfa:	63df      	str	r7, [r3, #60]	; 0x3c
  oqp->q_rdptr   = bp;
 8000bfc:	649f      	str	r7, [r3, #72]	; 0x48
  oqp->q_wrptr   = bp;
 8000bfe:	645f      	str	r7, [r3, #68]	; 0x44
  oqp->q_top     = bp + size;
 8000c00:	f8c3 e040 	str.w	lr, [r3, #64]	; 0x40
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->next = (event_listener_t *)esp;
 8000c04:	f8c3 c004 	str.w	ip, [r3, #4]
 8000c08:	f883 a008 	strb.w	sl, [r3, #8]
 8000c0c:	6319      	str	r1, [r3, #48]	; 0x30
  tqp->prev = (thread_t *)tqp;
 8000c0e:	6359      	str	r1, [r3, #52]	; 0x34
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {

  osalThreadQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8000c10:	f8c3 b038 	str.w	fp, [r3, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
  oqp->q_notify  = onfy;
 8000c14:	64d8      	str	r0, [r3, #76]	; 0x4c

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000c16:	f882 8325 	strb.w	r8, [r2, #805]	; 0x325
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000c1a:	f8c2 6184 	str.w	r6, [r2, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000c1e:	6056      	str	r6, [r2, #4]

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000c20:	69eb      	ldr	r3, [r5, #28]
  oqp->q_link    = link;
 8000c22:	4853      	ldr	r0, [pc, #332]	; (8000d70 <main+0x310>)

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000c24:	f8df c1a8 	ldr.w	ip, [pc, #424]	; 8000dd0 <main+0x370>
 8000c28:	6500      	str	r0, [r0, #80]	; 0x50

#if OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING
  /* Free running counter mode.*/

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();
 8000c2a:	ea43 030a 	orr.w	r3, r3, sl
 8000c2e:	61eb      	str	r3, [r5, #28]
 8000c30:	4601      	mov	r1, r0

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000c32:	f8dc 0008 	ldr.w	r0, [ip, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000c36:	4f53      	ldr	r7, [pc, #332]	; (8000d84 <main+0x324>)

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1);
  iqObjectInit(&SD1.iqueue, sd_in_buf1, sizeof sd_in_buf1, NULL, &SD1);
  oqObjectInit(&SD1.oqueue, sd_out_buf1, sizeof sd_out_buf1, notify1, &SD1);
  SD1.usart = USART1;
 8000c38:	f8df e198 	ldr.w	lr, [pc, #408]	; 8000dd4 <main+0x374>
 8000c3c:	f8c1 e054 	str.w	lr, [r1, #84]	; 0x54

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000c40:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000c44:	ea40 000a 	orr.w	r0, r0, sl
  SD1.clock = STM32_USART1CLK;
 8000c48:	f8df 818c 	ldr.w	r8, [pc, #396]	; 8000dd8 <main+0x378>
 8000c4c:	f8c1 8058 	str.w	r8, [r1, #88]	; 0x58

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000c50:	f641 4e1f 	movw	lr, #7199	; 0x1c1f

  /* Enabling timer clock.*/
  ST_ENABLE_CLOCK();

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();
 8000c54:	f8cc 0008 	str.w	r0, [ip, #8]

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000c58:	f04f 31ff 	mov.w	r1, #4294967295

  /* Enabling the stop mode during debug for this timer.*/
  ST_ENABLE_STOP();

  /* Initializing the counter in free running mode.*/
  STM32_ST_TIM->PSC    = (ST_CLOCK_SRC / OSAL_ST_FREQUENCY) - 1;
 8000c5c:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000c60:	f04f 5c80 	mov.w	ip, #268435456	; 0x10000000
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000c64:	f107 0e1c 	add.w	lr, r7, #28

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000c68:	f04f 0880 	mov.w	r8, #128	; 0x80
  STM32_ST_TIM->ARR    = ST_ARR_INIT;
 8000c6c:	62d9      	str	r1, [r3, #44]	; 0x2c
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000c6e:	a802      	add	r0, sp, #8
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
  ch.vtlist.delta = (systime_t)-1;
 8000c70:	6279      	str	r1, [r7, #36]	; 0x24
  STM32_ST_TIM->CCMR1  = 0;
 8000c72:	619c      	str	r4, [r3, #24]
  tqp->prev = (thread_t *)tqp;
 8000c74:	607f      	str	r7, [r7, #4]
  STM32_ST_TIM->CCR[0] = 0;
 8000c76:	635c      	str	r4, [r3, #52]	; 0x34
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.queue);
  ch.rlist.prio = NOPRIO;
 8000c78:	60bc      	str	r4, [r7, #8]
  STM32_ST_TIM->DIER   = 0;
 8000c7a:	60dc      	str	r4, [r3, #12]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.newer = (thread_t *)&ch.rlist;
 8000c7c:	613f      	str	r7, [r7, #16]
  STM32_ST_TIM->CR2    = 0;
 8000c7e:	605c      	str	r4, [r3, #4]
  ch.rlist.older = (thread_t *)&ch.rlist;
 8000c80:	617f      	str	r7, [r7, #20]
  STM32_ST_TIM->EGR    = TIM_EGR_UG;
 8000c82:	f8c3 a014 	str.w	sl, [r3, #20]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.systime = (systime_t)0;
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  ch.vtlist.lasttime = (systime_t)0;
 8000c86:	62bc      	str	r4, [r7, #40]	; 0x28
  STM32_ST_TIM->CR1    = TIM_CR1_CEN;
 8000c88:	f8c3 a000 	str.w	sl, [r3]
 8000c8c:	f882 831c 	strb.w	r8, [r2, #796]	; 0x31c

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000c90:	2300      	movs	r3, #0
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8000c92:	677c      	str	r4, [r7, #116]	; 0x74
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000c94:	f8c2 c180 	str.w	ip, [r2, #384]	; 0x180
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.next = (virtual_timer_t *)&ch.vtlist;
 8000c98:	f8c7 e01c 	str.w	lr, [r7, #28]
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8000c9c:	f8c2 c000 	str.w	ip, [r2]

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000ca0:	2200      	movs	r2, #0
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8000ca2:	9102      	str	r1, [sp, #8]
  tmp->worst      = (rtcnt_t)0;
 8000ca4:	9403      	str	r4, [sp, #12]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000ca6:	603f      	str	r7, [r7, #0]
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8000ca8:	e9cd 2306 	strd	r2, r3, [sp, #24]
  ch.vtlist.prev = (virtual_timer_t *)&ch.vtlist;
 8000cac:	f8c7 e020 	str.w	lr, [r7, #32]
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
 8000cb0:	9404      	str	r4, [sp, #16]
  tmp->n          = (ucnt_t)0;
 8000cb2:	9405      	str	r4, [sp, #20]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8000cb4:	f004 fed4 	bl	8005a60 <chTMStartMeasurementX.constprop.70>
  chTMStopMeasurementX(&tm);
 8000cb8:	a802      	add	r0, sp, #8
 8000cba:	f004 f9e9 	bl	8005090 <chTMStopMeasurementX>
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
 8000cbe:	4b32      	ldr	r3, [pc, #200]	; (8000d88 <main+0x328>)
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = __heap_base__;
 8000cc0:	4a32      	ldr	r2, [pc, #200]	; (8000d8c <main+0x32c>)
 8000cc2:	4833      	ldr	r0, [pc, #204]	; (8000d90 <main+0x330>)
 8000cc4:	6018      	str	r0, [r3, #0]
 8000cc6:	4833      	ldr	r0, [pc, #204]	; (8000d94 <main+0x334>)
 8000cc8:	6010      	str	r0, [r2, #0]
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8000cca:	4a33      	ldr	r2, [pc, #204]	; (8000d98 <main+0x338>)
  endmem  = __heap_end__;
 8000ccc:	4933      	ldr	r1, [pc, #204]	; (8000d9c <main+0x33c>)
 8000cce:	f8d2 c00c 	ldr.w	ip, [r2, #12]
 8000cd2:	4833      	ldr	r0, [pc, #204]	; (8000da0 <main+0x340>)
 8000cd4:	6008      	str	r0, [r1, #0]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
  reg_value  =  (reg_value                                   |
 8000cd6:	4933      	ldr	r1, [pc, #204]	; (8000da4 <main+0x344>)
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000cd8:	f8d7 e014 	ldr.w	lr, [r7, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8000cdc:	f8c7 8038 	str.w	r8, [r7, #56]	; 0x38
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 8000ce0:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 8000ce4:	ea0c 0000 	and.w	r0, ip, r0
  reg_value  =  (reg_value                                   |
 8000ce8:	4301      	orrs	r1, r0
  ch.tm.offset = tm.last;
 8000cea:	9804      	ldr	r0, [sp, #16]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8000cec:	f8c7 806c 	str.w	r8, [r7, #108]	; 0x6c
 8000cf0:	6778      	str	r0, [r7, #116]	; 0x74
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000cf2:	f107 0c30 	add.w	ip, r7, #48	; 0x30
 8000cf6:	eb03 080b 	add.w	r8, r3, fp

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000cfa:	482b      	ldr	r0, [pc, #172]	; (8000da8 <main+0x348>)
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000cfc:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 8000ddc <main+0x37c>
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8000d00:	f887 4051 	strb.w	r4, [r7, #81]	; 0x51
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8000d04:	667c      	str	r4, [r7, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8000d06:	f887 a052 	strb.w	sl, [r7, #82]	; 0x52
 8000d0a:	619c      	str	r4, [r3, #24]
  tp->name      = name;
  REG_INSERT(tp);
 8000d0c:	f8c7 e044 	str.w	lr, [r7, #68]	; 0x44
 8000d10:	f8c3 8010 	str.w	r8, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8000d14:	f8c3 8014 	str.w	r8, [r3, #20]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8000d18:	66bc      	str	r4, [r7, #104]	; 0x68
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8000d1a:	643f      	str	r7, [r7, #64]	; 0x40
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8000d1c:	f8c7 9048 	str.w	r9, [r7, #72]	; 0x48
  REG_INSERT(tp);
 8000d20:	f8ce c010 	str.w	ip, [lr, #16]
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8U)                      );              /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 8000d24:	60d1      	str	r1, [r2, #12]
 8000d26:	68c1      	ldr	r1, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000d28:	f8df e0b4 	ldr.w	lr, [pc, #180]	; 8000de0 <main+0x380>
  H_NEXT(&default_heap.header) = NULL;
 8000d2c:	609c      	str	r4, [r3, #8]

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable, note, the M7 requires DWT unlocking.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 8000d2e:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8000d32:	60c1      	str	r1, [r0, #12]
#if CORTEX_MODEL == 7
  DWT->LAR = 0xC5ACCE55U;
#endif
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 8000d34:	f8de 1000 	ldr.w	r1, [lr]
  H_PAGES(&default_heap.header) = 0;
 8000d38:	60dc      	str	r4, [r3, #12]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000d3a:	f107 0058 	add.w	r0, r7, #88	; 0x58
 8000d3e:	ea41 030a 	orr.w	r3, r1, sl
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000d42:	f107 015c 	add.w	r1, r7, #92	; 0x5c
 8000d46:	e04d      	b.n	8000de4 <main+0x384>
 8000d48:	40021000 	.word	0x40021000
 8000d4c:	40007000 	.word	0x40007000
 8000d50:	40010000 	.word	0x40010000
 8000d54:	48000400 	.word	0x48000400
 8000d58:	48000800 	.word	0x48000800
 8000d5c:	48000c00 	.word	0x48000c00
 8000d60:	48001000 	.word	0x48001000
 8000d64:	48001400 	.word	0x48001400
 8000d68:	01155515 	.word	0x01155515
 8000d6c:	55555550 	.word	0x55555550
 8000d70:	200012dc 	.word	0x200012dc
 8000d74:	200012cc 	.word	0x200012cc
 8000d78:	08006264 	.word	0x08006264
 8000d7c:	e000e100 	.word	0xe000e100
 8000d80:	08003711 	.word	0x08003711
 8000d84:	200013b0 	.word	0x200013b0
 8000d88:	20001480 	.word	0x20001480
 8000d8c:	20000998 	.word	0x20000998
 8000d90:	08003841 	.word	0x08003841
 8000d94:	200014a0 	.word	0x200014a0
 8000d98:	e000ed00 	.word	0xe000ed00
 8000d9c:	200012b8 	.word	0x200012b8
 8000da0:	2000a000 	.word	0x2000a000
 8000da4:	05fa0300 	.word	0x05fa0300
 8000da8:	e000edf0 	.word	0xe000edf0
 8000dac:	3cc0fc00 	.word	0x3cc0fc00
 8000db0:	64151154 	.word	0x64151154
 8000db4:	55500000 	.word	0x55500000
 8000db8:	2a80a800 	.word	0x2a80a800
 8000dbc:	55550515 	.word	0x55550515
 8000dc0:	05555555 	.word	0x05555555
 8000dc4:	ffff00c0 	.word	0xffff00c0
 8000dc8:	55550040 	.word	0x55550040
 8000dcc:	200012bc 	.word	0x200012bc
 8000dd0:	e0042000 	.word	0xe0042000
 8000dd4:	40013800 	.word	0x40013800
 8000dd8:	02255100 	.word	0x02255100
 8000ddc:	0800643c 	.word	0x0800643c
 8000de0:	e0001000 	.word	0xe0001000
 8000de4:	f8c7 c014 	str.w	ip, [r7, #20]
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
#if CH_CFG_USE_REGISTRY == TRUE
  currp = _thread_init(&ch.mainthread, (const char *)&ch_debug, NORMALPRIO);
 8000de8:	f8c7 c018 	str.w	ip, [r7, #24]
       symbol must be provided externally.*/
    extern stkalign_t __main_thread_stack_base__;
    currp->wabase = &__main_thread_stack_base__;
  }
#elif CH_CFG_USE_DYNAMIC == TRUE
  currp->wabase = NULL;
 8000dec:	64fc      	str	r4, [r7, #76]	; 0x4c
#endif

  /* Setting up the caller as current thread.*/
  currp->state = CH_STATE_CURRENT;
 8000dee:	f887 a050 	strb.w	sl, [r7, #80]	; 0x50
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8000df2:	65b8      	str	r0, [r7, #88]	; 0x58
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8000df4:	65f9      	str	r1, [r7, #92]	; 0x5c
  tqp->prev = (thread_t *)tqp;
 8000df6:	6639      	str	r1, [r7, #96]	; 0x60
 8000df8:	f8ce 3000 	str.w	r3, [lr]
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) < 0)
  {
    SCB->SHP[(((uint32_t)(int32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8000dfc:	f882 b01f 	strb.w	fp, [r2, #31]
 8000e00:	f882 6022 	strb.w	r6, [r2, #34]	; 0x22
 8000e04:	f384 8811 	msr	BASEPRI, r4
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8000e08:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000e0a:	f386 8811 	msr	BASEPRI, r6
                  (uint8_t *)tdp->wend,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(tdp);
 8000e0e:	48a6      	ldr	r0, [pc, #664]	; (80010a8 <main+0x648>)
 8000e10:	f004 f9ce 	bl	80051b0 <chThdCreateSuspendedI>
  chSchWakeupS(tp, MSG_OK);
 8000e14:	4621      	mov	r1, r4
 8000e16:	f004 fa73 	bl	8005300 <chSchWakeupS>
 8000e1a:	f384 8811 	msr	BASEPRI, r4
 8000e1e:	f386 8811 	msr	BASEPRI, r6
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;

  if (sdp->state == SD_STOP) {
 8000e22:	4ba2      	ldr	r3, [pc, #648]	; (80010ac <main+0x64c>)
 8000e24:	7a1b      	ldrb	r3, [r3, #8]
 8000e26:	4553      	cmp	r3, sl
 8000e28:	d103      	bne.n	8000e32 <main+0x3d2>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
      rccEnableUSART1(FALSE);
 8000e2a:	69ab      	ldr	r3, [r5, #24]
 8000e2c:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8000e30:	61ab      	str	r3, [r5, #24]
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000e32:	4b9e      	ldr	r3, [pc, #632]	; (80010ac <main+0x64c>)
 8000e34:	499e      	ldr	r1, [pc, #632]	; (80010b0 <main+0x650>)
 8000e36:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000e38:	6d5b      	ldr	r3, [r3, #84]	; 0x54
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000e3a:	fba1 1202 	umull	r1, r2, r1, r2
 8000e3e:	0b12      	lsrs	r2, r2, #12
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000e40:	f04f 31ff 	mov.w	r1, #4294967295
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000e44:	2740      	movs	r7, #64	; 0x40
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000e46:	2601      	movs	r6, #1
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000e48:	f240 142d 	movw	r4, #301	; 0x12d
  {
      u->BRR = (uint32_t)( ( (uint64_t)sdp->clock * 256 ) / config->speed);
  }
  else
#endif
  u->BRR = (uint32_t)(sdp->clock / config->speed);
 8000e4c:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 8000e4e:	605f      	str	r7, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000e50:	609e      	str	r6, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000e52:	601c      	str	r4, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFFU;
 8000e54:	6219      	str	r1, [r3, #32]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8000e56:	4b95      	ldr	r3, [pc, #596]	; (80010ac <main+0x64c>)
 8000e58:	2002      	movs	r0, #2
 8000e5a:	2500      	movs	r5, #0
 8000e5c:	7218      	strb	r0, [r3, #8]
    default:
      sdp->rxmask = 0xFF;
    }
  }
  else {
    sdp->rxmask = 0xFF;
 8000e5e:	f883 105c 	strb.w	r1, [r3, #92]	; 0x5c
 8000e62:	f385 8811 	msr	BASEPRI, r5
  /*
   * Activates the serial driver 1 using the driver default configuration.
   * PA9(TX) and PA10(RX) are routed to USART1.
   */
  sdStart(&SD1, NULL);
  palSetPadMode(GPIOA, 9, PAL_MODE_ALTERNATE(7));
 8000e66:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000e6a:	f005 f8e9 	bl	8006040 <_pal_lld_setgroupmode.constprop.5>
  palSetPadMode(GPIOA, 10, PAL_MODE_ALTERNATE(7));
 8000e6e:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000e72:	f005 f8e5 	bl	8006040 <_pal_lld_setgroupmode.constprop.5>
 8000e76:	4c8f      	ldr	r4, [pc, #572]	; (80010b4 <main+0x654>)

  /*
   * Creates the example threads.
   */
  chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO+1, Thread1, NULL);
 8000e78:	4a8f      	ldr	r2, [pc, #572]	; (80010b8 <main+0x658>)
 8000e7a:	4890      	ldr	r0, [pc, #576]	; (80010bc <main+0x65c>)
 8000e7c:	4e90      	ldr	r6, [pc, #576]	; (80010c0 <main+0x660>)
 8000e7e:	f8df a2a8 	ldr.w	sl, [pc, #680]	; 8001128 <main+0x6c8>
 8000e82:	462b      	mov	r3, r5
 8000e84:	2181      	movs	r1, #129	; 0x81
 8000e86:	f004 fdf3 	bl	8005a70 <chThdCreateStatic.constprop.69>
  chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO+1, Thread2, NULL);
 8000e8a:	462b      	mov	r3, r5
 8000e8c:	488d      	ldr	r0, [pc, #564]	; (80010c4 <main+0x664>)
 8000e8e:	4a8e      	ldr	r2, [pc, #568]	; (80010c8 <main+0x668>)
 8000e90:	2181      	movs	r1, #129	; 0x81
 8000e92:	f004 fded 	bl	8005a70 <chThdCreateStatic.constprop.69>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000e96:	46a3      	mov	fp, r4
 8000e98:	e003      	b.n	8000ea2 <main+0x442>
   * pressed the test procedure is launched.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
      test_execute((BaseSequentialStream *)&SD1);
    chThdSleepMilliseconds(500);
 8000e9a:	f241 3088 	movw	r0, #5000	; 0x1388
 8000e9e:	f004 fd07 	bl	80058b0 <chThdSleep>
   * Normal main() thread activity, in this demo it does nothing except
   * sleeping in a loop and check the button state, when the button is
   * pressed the test procedure is launched.
   */
  while (true) {
    if (palReadPad(GPIOA, GPIOA_BUTTON))
 8000ea2:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
 8000ea6:	691b      	ldr	r3, [r3, #16]
 8000ea8:	07db      	lsls	r3, r3, #31
 8000eaa:	d5f6      	bpl.n	8000e9a <main+0x43a>
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 8000eac:	4b7f      	ldr	r3, [pc, #508]	; (80010ac <main+0x64c>)
  test_println("");
 8000eae:	4887      	ldr	r0, [pc, #540]	; (80010cc <main+0x66c>)
 * @api
 */
msg_t test_execute(BaseSequentialStream *stream) {
  int i, j;

  test_chp = stream;
 8000eb0:	6023      	str	r3, [r4, #0]
  test_println("");
 8000eb2:	f002 ff7d 	bl	8003db0 <test_println>
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 8000eb6:	4886      	ldr	r0, [pc, #536]	; (80010d0 <main+0x670>)
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8000eb8:	4d86      	ldr	r5, [pc, #536]	; (80010d4 <main+0x674>)
  int i, j;

  test_chp = stream;
  test_println("");
#if defined(TEST_SUITE_NAME)
  test_println("*** " TEST_SUITE_NAME);
 8000eba:	f002 ff79 	bl	8003db0 <test_println>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
 8000ebe:	4886      	ldr	r0, [pc, #536]	; (80010d8 <main+0x678>)
 8000ec0:	f002 ff76 	bl	8003db0 <test_println>
 8000ec4:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000ec6:	6820      	ldr	r0, [r4, #0]
 8000ec8:	6803      	ldr	r3, [r0, #0]
 8000eca:	689b      	ldr	r3, [r3, #8]
 8000ecc:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000ece:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000ed2:	2900      	cmp	r1, #0
 8000ed4:	d1f7      	bne.n	8000ec6 <main+0x466>
#else
  test_println("*** ChibiOS test suite");
#endif
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
 8000ed6:	4881      	ldr	r0, [pc, #516]	; (80010dc <main+0x67c>)
 8000ed8:	4d81      	ldr	r5, [pc, #516]	; (80010e0 <main+0x680>)
 8000eda:	f002 ff69 	bl	8003db0 <test_println>
 8000ede:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000ee0:	6820      	ldr	r0, [r4, #0]
 8000ee2:	6803      	ldr	r3, [r0, #0]
 8000ee4:	689b      	ldr	r3, [r3, #8]
 8000ee6:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000ee8:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000eec:	2900      	cmp	r1, #0
 8000eee:	d1f7      	bne.n	8000ee0 <main+0x480>
  test_println("***");
  test_print("*** Compiled:     ");
  test_println(__DATE__ " - " __TIME__);
#if defined(PLATFORM_NAME)
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
 8000ef0:	487c      	ldr	r0, [pc, #496]	; (80010e4 <main+0x684>)
 8000ef2:	4d7d      	ldr	r5, [pc, #500]	; (80010e8 <main+0x688>)
 8000ef4:	f002 ff5c 	bl	8003db0 <test_println>
 8000ef8:	212a      	movs	r1, #42	; 0x2a
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000efa:	6820      	ldr	r0, [r4, #0]
 8000efc:	6803      	ldr	r3, [r0, #0]
 8000efe:	689b      	ldr	r3, [r3, #8]
 8000f00:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000f02:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000f06:	2900      	cmp	r1, #0
 8000f08:	d1f7      	bne.n	8000efa <main+0x49a>
  test_print("*** Platform:     ");
  test_println(PLATFORM_NAME);
#endif
#if defined(BOARD_NAME)
  test_print("*** Test Board:   ");
  test_println(BOARD_NAME);
 8000f0a:	4878      	ldr	r0, [pc, #480]	; (80010ec <main+0x68c>)
 8000f0c:	9101      	str	r1, [sp, #4]
 8000f0e:	f002 ff4f 	bl	8003db0 <test_println>
#endif
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");
 8000f12:	486e      	ldr	r0, [pc, #440]	; (80010cc <main+0x66c>)
 8000f14:	f002 ff4c 	bl	8003db0 <test_println>

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8000f18:	4b75      	ldr	r3, [pc, #468]	; (80010f0 <main+0x690>)
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
 8000f1a:	4a76      	ldr	r2, [pc, #472]	; (80010f4 <main+0x694>)
  i = 0;
  while (test_suite[i]) {
 8000f1c:	681b      	ldr	r3, [r3, #0]
#if defined(TEST_REPORT_HOOK_HEADER)
  TEST_REPORT_HOOK_HEADER
#endif
  test_println("");

  test_global_fail = false;
 8000f1e:	9901      	ldr	r1, [sp, #4]
 8000f20:	7011      	strb	r1, [r2, #0]
  i = 0;
  while (test_suite[i]) {
 8000f22:	2b00      	cmp	r3, #0
 8000f24:	f000 80a9 	beq.w	800107a <main+0x61a>
 8000f28:	f8df 81c4 	ldr.w	r8, [pc, #452]	; 80010f0 <main+0x690>
 8000f2c:	9a01      	ldr	r2, [sp, #4]
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8000f2e:	2700      	movs	r7, #0
 8000f30:	3201      	adds	r2, #1

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8000f32:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 8000f36:	9201      	str	r2, [sp, #4]
 8000f38:	ea4f 0987 	mov.w	r9, r7, lsl #2
 8000f3c:	2b00      	cmp	r3, #0
 8000f3e:	f000 8097 	beq.w	8001070 <main+0x610>
      print_line();
 8000f42:	4d6d      	ldr	r5, [pc, #436]	; (80010f8 <main+0x698>)
 8000f44:	f003 f89c 	bl	8004080 <print_line.lto_priv.168>
 8000f48:	212d      	movs	r1, #45	; 0x2d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000f4a:	6820      	ldr	r0, [r4, #0]
 8000f4c:	6803      	ldr	r3, [r0, #0]
 8000f4e:	689b      	ldr	r3, [r3, #8]
 8000f50:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000f52:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000f56:	2900      	cmp	r1, #0
 8000f58:	d1f7      	bne.n	8000f4a <main+0x4ea>
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8000f5a:	9801      	ldr	r0, [sp, #4]
      test_print(".");
      test_printn(j + 1);
 8000f5c:	4d67      	ldr	r5, [pc, #412]	; (80010fc <main+0x69c>)
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
 8000f5e:	f002 ff57 	bl	8003e10 <test_printn>
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000f62:	f8db 0000 	ldr.w	r0, [fp]
 8000f66:	6803      	ldr	r3, [r0, #0]
 8000f68:	212e      	movs	r1, #46	; 0x2e
 8000f6a:	689b      	ldr	r3, [r3, #8]
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8000f6c:	3701      	adds	r7, #1
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000f6e:	4798      	blx	r3
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8000f70:	4638      	mov	r0, r7
 8000f72:	f002 ff4d 	bl	8003e10 <test_printn>
 8000f76:	2120      	movs	r1, #32
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000f78:	6820      	ldr	r0, [r4, #0]
 8000f7a:	6803      	ldr	r3, [r0, #0]
 8000f7c:	689b      	ldr	r3, [r3, #8]
 8000f7e:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000f80:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000f84:	2900      	cmp	r1, #0
 8000f86:	d1f7      	bne.n	8000f78 <main+0x518>
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
 8000f88:	f8d8 3000 	ldr.w	r3, [r8]
 8000f8c:	f853 3009 	ldr.w	r3, [r3, r9]
 8000f90:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000f92:	7829      	ldrb	r1, [r5, #0]
 8000f94:	b139      	cbz	r1, 8000fa6 <main+0x546>
    streamPut(test_chp, *msgp++);
 8000f96:	6820      	ldr	r0, [r4, #0]
 8000f98:	6803      	ldr	r3, [r0, #0]
 8000f9a:	689b      	ldr	r3, [r3, #8]
 8000f9c:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000f9e:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000fa2:	2900      	cmp	r1, #0
 8000fa4:	d1f7      	bne.n	8000f96 <main+0x536>
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
      test_print(" (");
      test_print(test_suite[i][j]->name);
      test_println(")");
 8000fa6:	4856      	ldr	r0, [pc, #344]	; (8001100 <main+0x6a0>)
 8000fa8:	f002 ff02 	bl	8003db0 <test_println>
 *
 * @api
 */
static inline void osalThreadSleep(systime_t time) {

  chThdSleep(time);
 8000fac:	f44f 60fa 	mov.w	r0, #2000	; 0x7d0
 8000fb0:	f004 fc7e 	bl	80058b0 <chThdSleep>
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
 8000fb4:	f8d8 3000 	ldr.w	r3, [r8]
 8000fb8:	f853 5009 	ldr.w	r5, [r3, r9]
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8000fbc:	4b51      	ldr	r3, [pc, #324]	; (8001104 <main+0x6a4>)
 8000fbe:	6033      	str	r3, [r6, #0]

  /* Initialization */
  clear_tokens();
  test_local_fail = false;

  if (tcp->setup != NULL)
 8000fc0:	686b      	ldr	r3, [r5, #4]

static void execute_test(const testcase_t *tcp) {

  /* Initialization */
  clear_tokens();
  test_local_fail = false;
 8000fc2:	2200      	movs	r2, #0
 8000fc4:	f88a 2000 	strb.w	r2, [sl]

  if (tcp->setup != NULL)
 8000fc8:	b103      	cbz	r3, 8000fcc <main+0x56c>
    tcp->setup();
 8000fca:	4798      	blx	r3
  tcp->execute();
 8000fcc:	68eb      	ldr	r3, [r5, #12]
 8000fce:	4798      	blx	r3
  if (tcp->teardown != NULL)
 8000fd0:	68ab      	ldr	r3, [r5, #8]
 8000fd2:	b103      	cbz	r3, 8000fd6 <main+0x576>
    tcp->teardown();
 8000fd4:	4798      	blx	r3
      test_println(")");
#if TEST_DELAY_BETWEEN_TESTS > 0
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
 8000fd6:	f89a 3000 	ldrb.w	r3, [sl]
 8000fda:	2b00      	cmp	r3, #0
 8000fdc:	f000 80a6 	beq.w	800112c <main+0x6cc>
    while (test_suite[i][j]) {
      print_line();
      test_print("--- Test Case ");
      test_printn(i + 1);
      test_print(".");
      test_printn(j + 1);
 8000fe0:	4d49      	ldr	r5, [pc, #292]	; (8001108 <main+0x6a8>)
 8000fe2:	212d      	movs	r1, #45	; 0x2d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8000fe4:	6820      	ldr	r0, [r4, #0]
 8000fe6:	6803      	ldr	r3, [r0, #0]
 8000fe8:	689b      	ldr	r3, [r3, #8]
 8000fea:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8000fec:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8000ff0:	2900      	cmp	r1, #0
 8000ff2:	d1f7      	bne.n	8000fe4 <main+0x584>
      osalThreadSleepMilliseconds(TEST_DELAY_BETWEEN_TESTS);
#endif
      execute_test(test_suite[i][j]);
      if (test_local_fail) {
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
 8000ff4:	4b45      	ldr	r3, [pc, #276]	; (800110c <main+0x6ac>)
 8000ff6:	4d46      	ldr	r5, [pc, #280]	; (8001110 <main+0x6b0>)
 8000ff8:	6818      	ldr	r0, [r3, #0]
 8000ffa:	f002 ff09 	bl	8003e10 <test_printn>
 8000ffe:	2120      	movs	r1, #32
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8001000:	6820      	ldr	r0, [r4, #0]
 8001002:	6803      	ldr	r3, [r0, #0]
 8001004:	689b      	ldr	r3, [r3, #8]
 8001006:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001008:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800100c:	2900      	cmp	r1, #0
 800100e:	d1f7      	bne.n	8001000 <main+0x5a0>
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8001010:	6833      	ldr	r3, [r6, #0]
 8001012:	4a3c      	ldr	r2, [pc, #240]	; (8001104 <main+0x6a4>)
 8001014:	4293      	cmp	r3, r2
 8001016:	d909      	bls.n	800102c <main+0x5cc>
 8001018:	4d3a      	ldr	r5, [pc, #232]	; (8001104 <main+0x6a4>)
    streamPut(test_chp, *cp++);
 800101a:	6820      	ldr	r0, [r4, #0]
 800101c:	f815 1b01 	ldrb.w	r1, [r5], #1
 8001020:	6803      	ldr	r3, [r0, #0]
 8001022:	689b      	ldr	r3, [r3, #8]
 8001024:	4798      	blx	r3
}

static void print_tokens(void) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp)
 8001026:	6833      	ldr	r3, [r6, #0]
 8001028:	429d      	cmp	r5, r3
 800102a:	d3f6      	bcc.n	800101a <main+0x5ba>
 800102c:	4d39      	ldr	r5, [pc, #228]	; (8001114 <main+0x6b4>)
 800102e:	215d      	movs	r1, #93	; 0x5d
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8001030:	6820      	ldr	r0, [r4, #0]
 8001032:	6803      	ldr	r3, [r0, #0]
 8001034:	689b      	ldr	r3, [r3, #8]
 8001036:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001038:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 800103c:	2900      	cmp	r1, #0
 800103e:	d1f7      	bne.n	8001030 <main+0x5d0>
        test_print("--- Result: FAILURE (#");
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
 8001040:	4b35      	ldr	r3, [pc, #212]	; (8001118 <main+0x6b8>)
 8001042:	681d      	ldr	r5, [r3, #0]
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001044:	7829      	ldrb	r1, [r5, #0]
 8001046:	b139      	cbz	r1, 8001058 <main+0x5f8>
    streamPut(test_chp, *msgp++);
 8001048:	6820      	ldr	r0, [r4, #0]
 800104a:	6803      	ldr	r3, [r0, #0]
 800104c:	689b      	ldr	r3, [r3, #8]
 800104e:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001050:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8001054:	2900      	cmp	r1, #0
 8001056:	d1f7      	bne.n	8001048 <main+0x5e8>
        test_printn(test_step);
        test_print(" [");
        print_tokens();
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
 8001058:	4830      	ldr	r0, [pc, #192]	; (800111c <main+0x6bc>)
 800105a:	f002 fea9 	bl	8003db0 <test_println>
 800105e:	f8d8 3000 	ldr.w	r3, [r8]

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
    j = 0;
    while (test_suite[i][j]) {
 8001062:	f853 3027 	ldr.w	r3, [r3, r7, lsl #2]
 8001066:	ea4f 0987 	mov.w	r9, r7, lsl #2
 800106a:	2b00      	cmp	r3, #0
 800106c:	f47f af69 	bne.w	8000f42 <main+0x4e2>
#endif
  test_println("");

  test_global_fail = false;
  i = 0;
  while (test_suite[i]) {
 8001070:	f858 3f04 	ldr.w	r3, [r8, #4]!
 8001074:	2b00      	cmp	r3, #0
 8001076:	f47f af59 	bne.w	8000f2c <main+0x4cc>
        test_println("--- Result: SUCCESS");
      j++;
    }
    i++;
  }
  print_line();
 800107a:	f003 f801 	bl	8004080 <print_line.lto_priv.168>
  test_println("");
 800107e:	4d28      	ldr	r5, [pc, #160]	; (8001120 <main+0x6c0>)
 8001080:	4812      	ldr	r0, [pc, #72]	; (80010cc <main+0x66c>)
 8001082:	f002 fe95 	bl	8003db0 <test_println>
 8001086:	2146      	movs	r1, #70	; 0x46
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
    streamPut(test_chp, *msgp++);
 8001088:	6820      	ldr	r0, [r4, #0]
 800108a:	6803      	ldr	r3, [r0, #0]
 800108c:	689b      	ldr	r3, [r3, #8]
 800108e:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8001090:	f815 1f01 	ldrb.w	r1, [r5, #1]!
 8001094:	2900      	cmp	r1, #0
 8001096:	d1f7      	bne.n	8001088 <main+0x628>
    i++;
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
 8001098:	4b16      	ldr	r3, [pc, #88]	; (80010f4 <main+0x694>)
 800109a:	781b      	ldrb	r3, [r3, #0]
 800109c:	2b00      	cmp	r3, #0
 800109e:	d149      	bne.n	8001134 <main+0x6d4>
    test_println("FAILURE");
  else
    test_println("SUCCESS");
 80010a0:	4820      	ldr	r0, [pc, #128]	; (8001124 <main+0x6c4>)
 80010a2:	f002 fe85 	bl	8003db0 <test_println>
 80010a6:	e6f8      	b.n	8000e9a <main+0x43a>
 80010a8:	0800621c 	.word	0x0800621c
 80010ac:	200012dc 	.word	0x200012dc
 80010b0:	1b4e81b5 	.word	0x1b4e81b5
 80010b4:	20000c4c 	.word	0x20000c4c
 80010b8:	08000331 	.word	0x08000331
 80010bc:	200009a8 	.word	0x200009a8
 80010c0:	20001364 	.word	0x20001364
 80010c4:	20000af0 	.word	0x20000af0
 80010c8:	08000391 	.word	0x08000391
 80010cc:	080066b4 	.word	0x080066b4
 80010d0:	08006744 	.word	0x08006744
 80010d4:	080066c4 	.word	0x080066c4
 80010d8:	08006760 	.word	0x08006760
 80010dc:	080067b0 	.word	0x080067b0
 80010e0:	080066d8 	.word	0x080066d8
 80010e4:	080067c8 	.word	0x080067c8
 80010e8:	080066ec 	.word	0x080066ec
 80010ec:	08006764 	.word	0x08006764
 80010f0:	20000800 	.word	0x20000800
 80010f4:	2000146c 	.word	0x2000146c
 80010f8:	08006700 	.word	0x08006700
 80010fc:	08006710 	.word	0x08006710
 8001100:	0800678c 	.word	0x0800678c
 8001104:	200008b0 	.word	0x200008b0
 8001108:	08006714 	.word	0x08006714
 800110c:	2000133c 	.word	0x2000133c
 8001110:	0800672c 	.word	0x0800672c
 8001114:	08006730 	.word	0x08006730
 8001118:	20001428 	.word	0x20001428
 800111c:	08006790 	.word	0x08006790
 8001120:	08006734 	.word	0x08006734
 8001124:	080067a0 	.word	0x080067a0
 8001128:	2000146d 	.word	0x2000146d
        test_print("] \"");
        test_print(test_failure_message);
        test_println("\")");
      }
      else
        test_println("--- Result: SUCCESS");
 800112c:	4803      	ldr	r0, [pc, #12]	; (800113c <main+0x6dc>)
 800112e:	f002 fe3f 	bl	8003db0 <test_println>
 8001132:	e794      	b.n	800105e <main+0x5fe>
  }
  print_line();
  test_println("");
  test_print("Final result: ");
  if (test_global_fail)
    test_println("FAILURE");
 8001134:	4802      	ldr	r0, [pc, #8]	; (8001140 <main+0x6e0>)
 8001136:	f002 fe3b 	bl	8003db0 <test_println>
 800113a:	e6ae      	b.n	8000e9a <main+0x43a>
 800113c:	08006794 	.word	0x08006794
 8001140:	080067a8 	.word	0x080067a8
 8001144:	f3af 8000 	nop.w
 8001148:	f3af 8000 	nop.w
 800114c:	f3af 8000 	nop.w

08001150 <test_004_005_setup.lto_priv.111>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001150:	4b02      	ldr	r3, [pc, #8]	; (800115c <test_004_005_setup.lto_priv.111+0xc>)
 8001152:	2200      	movs	r2, #0
 8001154:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001156:	605b      	str	r3, [r3, #4]
 8001158:	609a      	str	r2, [r3, #8]
 800115a:	4770      	bx	lr
 800115c:	20001460 	.word	0x20001460

08001160 <test_004_004_setup.lto_priv.109>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001160:	4b02      	ldr	r3, [pc, #8]	; (800116c <test_004_004_setup.lto_priv.109+0xc>)
 8001162:	2200      	movs	r2, #0
 8001164:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001166:	605b      	str	r3, [r3, #4]
 8001168:	609a      	str	r2, [r3, #8]
 800116a:	4770      	bx	lr
 800116c:	20001460 	.word	0x20001460

08001170 <test_004_003_setup.lto_priv.107>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001170:	4b02      	ldr	r3, [pc, #8]	; (800117c <test_004_003_setup.lto_priv.107+0xc>)
 8001172:	2200      	movs	r2, #0
 8001174:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001176:	605b      	str	r3, [r3, #4]
 8001178:	609a      	str	r2, [r3, #8]
 800117a:	4770      	bx	lr
 800117c:	20001460 	.word	0x20001460

08001180 <test_004_002_setup.lto_priv.105>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001180:	4b02      	ldr	r3, [pc, #8]	; (800118c <test_004_002_setup.lto_priv.105+0xc>)
 8001182:	2200      	movs	r2, #0
 8001184:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001186:	605b      	str	r3, [r3, #4]
 8001188:	609a      	str	r2, [r3, #8]
 800118a:	4770      	bx	lr
 800118c:	20001460 	.word	0x20001460

08001190 <test_004_001_setup.lto_priv.102>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001190:	4b02      	ldr	r3, [pc, #8]	; (800119c <test_004_001_setup.lto_priv.102+0xc>)
 8001192:	2201      	movs	r2, #1
 8001194:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8001196:	605b      	str	r3, [r3, #4]
 8001198:	609a      	str	r2, [r3, #8]
 800119a:	4770      	bx	lr
 800119c:	20001460 	.word	0x20001460

080011a0 <test_003_001_setup.lto_priv.100>:
 *   the state of the reference are tested.
 * .
 */

static void test_003_001_setup(void) {
  tr1 = NULL;
 80011a0:	4b01      	ldr	r3, [pc, #4]	; (80011a8 <test_003_001_setup.lto_priv.100+0x8>)
 80011a2:	2200      	movs	r2, #0
 80011a4:	601a      	str	r2, [r3, #0]
 80011a6:	4770      	bx	lr
 80011a8:	2000137c 	.word	0x2000137c
 80011ac:	f3af 8000 	nop.w

080011b0 <test_001_004_execute.lto_priv.95>:

static void test_001_004_execute(void) {

  /* [1.4.1] A System Tick Counter increment is expected, the test
     simply hangs if it does not happen.*/
  test_set_step(1);
 80011b0:	4b04      	ldr	r3, [pc, #16]	; (80011c4 <test_001_004_execute.lto_priv.95+0x14>)
 80011b2:	2101      	movs	r1, #1
 80011b4:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 80011b8:	6019      	str	r1, [r3, #0]
 80011ba:	6a51      	ldr	r1, [r2, #36]	; 0x24
 80011bc:	6a53      	ldr	r3, [r2, #36]	; 0x24
  {
    systime_t time = chVTGetSystemTimeX();
    while (time == chVTGetSystemTimeX()) {
 80011be:	428b      	cmp	r3, r1
 80011c0:	d0fc      	beq.n	80011bc <test_001_004_execute.lto_priv.95+0xc>
#if defined(SIMULATOR)
      _sim_check_for_interrupts();
#endif
    }
  }
}
 80011c2:	4770      	bx	lr
 80011c4:	2000133c 	.word	0x2000133c
 80011c8:	f3af 8000 	nop.w
 80011cc:	f3af 8000 	nop.w

080011d0 <test_001_003_execute.lto_priv.94>:

static void test_001_003_execute(void) {

  /* [1.3.1] Testing chSysSuspend(), chSysDisable() and
     chSysEnable().*/
  test_set_step(1);
 80011d0:	4b07      	ldr	r3, [pc, #28]	; (80011f0 <test_001_003_execute.lto_priv.94+0x20>)
 80011d2:	2201      	movs	r2, #1
 80011d4:	601a      	str	r2, [r3, #0]
 80011d6:	2320      	movs	r3, #32
 80011d8:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011dc:	b662      	cpsie	i
  \details Disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i" : : : "memory");
 80011de:	b672      	cpsid	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80011e0:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011e4:	b662      	cpsie	i
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80011e6:	2300      	movs	r3, #0
 80011e8:	f383 8811 	msr	BASEPRI, r3
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 80011ec:	b662      	cpsie	i
 80011ee:	4770      	bx	lr
 80011f0:	2000133c 	.word	0x2000133c
 80011f4:	f3af 8000 	nop.w
 80011f8:	f3af 8000 	nop.w
 80011fc:	f3af 8000 	nop.w

08001200 <test_004_001_teardown.lto_priv.103>:
static void test_004_001_setup(void) {
  chSemObjectInit(&sem1, 1);
}

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
 8001200:	4801      	ldr	r0, [pc, #4]	; (8001208 <test_004_001_teardown.lto_priv.103+0x8>)
 8001202:	2100      	movs	r1, #0
 8001204:	f004 ba44 	b.w	8005690 <chSemReset>
 8001208:	20001460 	.word	0x20001460
 800120c:	f3af 8000 	nop.w

08001210 <test_004_006_execute.lto_priv.115>:

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8001210:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 8001214:	4f60      	ldr	r7, [pc, #384]	; (8001398 <test_004_006_execute.lto_priv.115+0x188>)

static void test_004_006_teardown(void) {
  test_wait_threads();
}

static void test_004_006_execute(void) {
 8001216:	b084      	sub	sp, #16
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001218:	ac01      	add	r4, sp, #4
  binary_semaphore_t bsem;
  msg_t msg;

  /* [4.6.1] Creating a binary semaphore in "taken" state, the state is
     checked.*/
  test_set_step(1);
 800121a:	2301      	movs	r3, #1
 800121c:	2600      	movs	r6, #0
 800121e:	603b      	str	r3, [r7, #0]
 8001220:	9401      	str	r4, [sp, #4]
  tqp->prev = (thread_t *)tqp;
 8001222:	9402      	str	r4, [sp, #8]
 8001224:	9603      	str	r6, [sp, #12]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8001226:	f04f 0820 	mov.w	r8, #32
 800122a:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 800122e:	9803      	ldr	r0, [sp, #12]
  {
    chBSemObjectInit(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8001230:	495a      	ldr	r1, [pc, #360]	; (800139c <test_004_006_execute.lto_priv.115+0x18c>)
 8001232:	42b0      	cmp	r0, r6
 8001234:	bfcc      	ite	gt
 8001236:	2000      	movgt	r0, #0
 8001238:	2001      	movle	r0, #1
 800123a:	f002 fe41 	bl	8003ec0 <_test_assert>
 800123e:	4605      	mov	r5, r0
 8001240:	b120      	cbz	r0, 800124c <test_004_006_execute.lto_priv.115+0x3c>
 8001242:	f386 8811 	msr	BASEPRI, r6
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 8001246:	b004      	add	sp, #16
 8001248:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800124c:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.2] Resetting the binary semaphore in "taken" state, the state
     must not change.*/
  test_set_step(2);
 8001250:	2302      	movs	r3, #2
 *
 * @api
 */
static inline void chBSemReset(binary_semaphore_t *bsp, bool taken) {

  chSemReset(&bsp->sem, taken ? (cnt_t)0 : (cnt_t)1);
 8001252:	4620      	mov	r0, r4
 8001254:	4629      	mov	r1, r5
 8001256:	603b      	str	r3, [r7, #0]
 8001258:	f004 fa1a 	bl	8005690 <chSemReset>
 800125c:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 8001260:	9803      	ldr	r0, [sp, #12]
  {
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 8001262:	494e      	ldr	r1, [pc, #312]	; (800139c <test_004_006_execute.lto_priv.115+0x18c>)
 8001264:	2800      	cmp	r0, #0
 8001266:	bfcc      	ite	gt
 8001268:	2000      	movgt	r0, #0
 800126a:	2001      	movle	r0, #1
 800126c:	f002 fe28 	bl	8003ec0 <_test_assert>
 8001270:	4606      	mov	r6, r0
 8001272:	b120      	cbz	r0, 800127e <test_004_006_execute.lto_priv.115+0x6e>
 8001274:	f385 8811 	msr	BASEPRI, r5
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
  }
}
 8001278:	b004      	add	sp, #16
 800127a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 800127e:	f380 8811 	msr	BASEPRI, r0
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001282:	4b47      	ldr	r3, [pc, #284]	; (80013a0 <test_004_006_execute.lto_priv.115+0x190>)
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8001284:	4a47      	ldr	r2, [pc, #284]	; (80013a4 <test_004_006_execute.lto_priv.115+0x194>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001286:	699b      	ldr	r3, [r3, #24]
 8001288:	4847      	ldr	r0, [pc, #284]	; (80013a8 <test_004_006_execute.lto_priv.115+0x198>)
 800128a:	6899      	ldr	r1, [r3, #8]
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 800128c:	2503      	movs	r5, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800128e:	3901      	subs	r1, #1
 8001290:	4623      	mov	r3, r4
    chBSemReset(&bsem, true);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
 8001292:	603d      	str	r5, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 8001294:	f004 fbec 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001298:	4a44      	ldr	r2, [pc, #272]	; (80013ac <test_004_006_execute.lto_priv.115+0x19c>)
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [4.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 800129a:	2304      	movs	r3, #4
  }

  /* [4.6.3] Starting a signaler thread at a lower priority.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE,
 800129c:	6010      	str	r0, [r2, #0]
 *
 * @api
 */
static inline msg_t chBSemWait(binary_semaphore_t *bsp) {

  return chSemWait(&bsp->sem);
 800129e:	4620      	mov	r0, r4
                                   chThdGetPriorityX()-1, thread4, &bsem);
  }

  /* [4.6.4] Waiting for the binary semaphore to be signaled, the
     semaphore is expected to be taken.*/
  test_set_step(4);
 80012a0:	603b      	str	r3, [r7, #0]
 80012a2:	f004 f895 	bl	80053d0 <chSemWait>
 80012a6:	4605      	mov	r5, r0
 80012a8:	f388 8811 	msr	BASEPRI, r8
 */
static inline bool chBSemGetStateI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  return (bsp->sem.cnt > (cnt_t)0) ? false : true;
 80012ac:	9803      	ldr	r0, [sp, #12]
  {
    msg = chBSemWait(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == true, "not taken");
 80012ae:	493b      	ldr	r1, [pc, #236]	; (800139c <test_004_006_execute.lto_priv.115+0x18c>)
 80012b0:	2800      	cmp	r0, #0
 80012b2:	bfcc      	ite	gt
 80012b4:	2000      	movgt	r0, #0
 80012b6:	2001      	movle	r0, #1
 80012b8:	f002 fe02 	bl	8003ec0 <_test_assert>
 80012bc:	2800      	cmp	r0, #0
 80012be:	d1c0      	bne.n	8001242 <test_004_006_execute.lto_priv.115+0x32>
 80012c0:	f380 8811 	msr	BASEPRI, r0
    test_assert(msg == MSG_OK, "unexpected message");
 80012c4:	fab5 f085 	clz	r0, r5
 80012c8:	4939      	ldr	r1, [pc, #228]	; (80013b0 <test_004_006_execute.lto_priv.115+0x1a0>)
 80012ca:	0940      	lsrs	r0, r0, #5
 80012cc:	f002 fdf8 	bl	8003ec0 <_test_assert>
 80012d0:	2800      	cmp	r0, #0
 80012d2:	d1b8      	bne.n	8001246 <test_004_006_execute.lto_priv.115+0x36>
  }

  /* [4.6.5] Signaling the binary semaphore, checking the binary
     semaphore state to be "not taken" and the underlying counter
     semaphore counter to be one.*/
  test_set_step(5);
 80012d4:	2305      	movs	r3, #5
 80012d6:	603b      	str	r3, [r7, #0]
 80012d8:	f388 8811 	msr	BASEPRI, r8
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80012dc:	9b03      	ldr	r3, [sp, #12]
 80012de:	2b00      	cmp	r3, #0
 80012e0:	dd23      	ble.n	800132a <test_004_006_execute.lto_priv.115+0x11a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80012e2:	f003 ffcd 	bl	8005280 <chSchRescheduleS>
 80012e6:	2500      	movs	r5, #0
 80012e8:	f385 8811 	msr	BASEPRI, r5
 80012ec:	2620      	movs	r6, #32
 80012ee:	f386 8811 	msr	BASEPRI, r6
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) ==false, "still taken");
 80012f2:	9803      	ldr	r0, [sp, #12]
 80012f4:	492f      	ldr	r1, [pc, #188]	; (80013b4 <test_004_006_execute.lto_priv.115+0x1a4>)
 80012f6:	42a8      	cmp	r0, r5
 80012f8:	bfd4      	ite	le
 80012fa:	2000      	movle	r0, #0
 80012fc:	2001      	movgt	r0, #1
 80012fe:	f002 fddf 	bl	8003ec0 <_test_assert>
 8001302:	4680      	mov	r8, r0
 8001304:	2800      	cmp	r0, #0
 8001306:	d1b5      	bne.n	8001274 <test_004_006_execute.lto_priv.115+0x64>
 8001308:	f380 8811 	msr	BASEPRI, r0
 800130c:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8001310:	9803      	ldr	r0, [sp, #12]
 8001312:	4929      	ldr	r1, [pc, #164]	; (80013b8 <test_004_006_execute.lto_priv.115+0x1a8>)
 8001314:	f1a0 0001 	sub.w	r0, r0, #1
 8001318:	fab0 f080 	clz	r0, r0
 800131c:	0940      	lsrs	r0, r0, #5
 800131e:	f002 fdcf 	bl	8003ec0 <_test_assert>
 8001322:	b130      	cbz	r0, 8001332 <test_004_006_execute.lto_priv.115+0x122>
 8001324:	f388 8811 	msr	BASEPRI, r8
 8001328:	e78d      	b.n	8001246 <test_004_006_execute.lto_priv.115+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 800132a:	4620      	mov	r0, r4
 800132c:	f004 f988 	bl	8005640 <chSemSignalI>
 8001330:	e7d7      	b.n	80012e2 <test_004_006_execute.lto_priv.115+0xd2>
 8001332:	f380 8811 	msr	BASEPRI, r0
  }

  /* [4.6.6] Signaling the binary semaphore again, the internal state
     must not change from "not taken".*/
  test_set_step(6);
 8001336:	2306      	movs	r3, #6
 8001338:	603b      	str	r3, [r7, #0]
 800133a:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 800133e:	9b03      	ldr	r3, [sp, #12]
 8001340:	2b00      	cmp	r3, #0
 8001342:	dd22      	ble.n	800138a <test_004_006_execute.lto_priv.115+0x17a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 8001344:	f003 ff9c 	bl	8005280 <chSchRescheduleS>
 8001348:	2600      	movs	r6, #0
 800134a:	f386 8811 	msr	BASEPRI, r6
 800134e:	2520      	movs	r5, #32
 8001350:	f385 8811 	msr	BASEPRI, r5
  {
    chBSemSignal(&bsem);
    test_assert_lock(chBSemGetStateI(&bsem) == false, "taken");
 8001354:	9803      	ldr	r0, [sp, #12]
 8001356:	4919      	ldr	r1, [pc, #100]	; (80013bc <test_004_006_execute.lto_priv.115+0x1ac>)
 8001358:	42b0      	cmp	r0, r6
 800135a:	bfd4      	ite	le
 800135c:	2000      	movle	r0, #0
 800135e:	2001      	movgt	r0, #1
 8001360:	f002 fdae 	bl	8003ec0 <_test_assert>
 8001364:	4604      	mov	r4, r0
 8001366:	2800      	cmp	r0, #0
 8001368:	f47f af6b 	bne.w	8001242 <test_004_006_execute.lto_priv.115+0x32>
 800136c:	f380 8811 	msr	BASEPRI, r0
 8001370:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&bsem.sem) == 1, "unexpected counter");
 8001374:	9803      	ldr	r0, [sp, #12]
 8001376:	4910      	ldr	r1, [pc, #64]	; (80013b8 <test_004_006_execute.lto_priv.115+0x1a8>)
 8001378:	1e43      	subs	r3, r0, #1
 800137a:	4258      	negs	r0, r3
 800137c:	4158      	adcs	r0, r3
 800137e:	f002 fd9f 	bl	8003ec0 <_test_assert>
 8001382:	b130      	cbz	r0, 8001392 <test_004_006_execute.lto_priv.115+0x182>
 8001384:	f384 8811 	msr	BASEPRI, r4
 8001388:	e75d      	b.n	8001246 <test_004_006_execute.lto_priv.115+0x36>
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 800138a:	4620      	mov	r0, r4
 800138c:	f004 f958 	bl	8005640 <chSemSignalI>
 8001390:	e7d8      	b.n	8001344 <test_004_006_execute.lto_priv.115+0x134>
 8001392:	f380 8811 	msr	BASEPRI, r0
 8001396:	e756      	b.n	8001246 <test_004_006_execute.lto_priv.115+0x36>
 8001398:	2000133c 	.word	0x2000133c
 800139c:	08006ea8 	.word	0x08006ea8
 80013a0:	200013b0 	.word	0x200013b0
 80013a4:	080013c1 	.word	0x080013c1
 80013a8:	20000c50 	.word	0x20000c50
 80013ac:	20001340 	.word	0x20001340
 80013b0:	08006eb4 	.word	0x08006eb4
 80013b4:	08006ec8 	.word	0x08006ec8
 80013b8:	08006ed4 	.word	0x08006ed4
 80013bc:	08006eac 	.word	0x08006eac

080013c0 <thread4>:
  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
}

static THD_FUNCTION(thread4, p) {
 80013c0:	b508      	push	{r3, lr}
 80013c2:	2220      	movs	r2, #32
 80013c4:	f382 8811 	msr	BASEPRI, r2
 */
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
 80013c8:	6883      	ldr	r3, [r0, #8]
 80013ca:	2b00      	cmp	r3, #0
 80013cc:	dd05      	ble.n	80013da <thread4+0x1a>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80013ce:	f003 ff57 	bl	8005280 <chSchRescheduleS>
 80013d2:	2300      	movs	r3, #0
 80013d4:	f383 8811 	msr	BASEPRI, r3
 80013d8:	bd08      	pop	{r3, pc}
static inline void chBSemSignalI(binary_semaphore_t *bsp) {

  chDbgCheckClassI();

  if (bsp->sem.cnt < (cnt_t)1) {
    chSemSignalI(&bsp->sem);
 80013da:	f004 f931 	bl	8005640 <chSemSignalI>
 */
static inline void chBSemSignal(binary_semaphore_t *bsp) {

  chSysLock();
  chBSemSignalI(bsp);
  chSchRescheduleS();
 80013de:	f003 ff4f 	bl	8005280 <chSchRescheduleS>
 80013e2:	2300      	movs	r3, #0
 80013e4:	f383 8811 	msr	BASEPRI, r3
 80013e8:	bd08      	pop	{r3, pc}
 80013ea:	bf00      	nop
 80013ec:	f3af 8000 	nop.w

080013f0 <test_004_006_teardown.lto_priv.114>:
 *   must not change from "not taken".
 * .
 */

static void test_004_006_teardown(void) {
  test_wait_threads();
 80013f0:	f002 bc8e 	b.w	8003d10 <test_wait_threads>
 80013f4:	f3af 8000 	nop.w
 80013f8:	f3af 8000 	nop.w
 80013fc:	f3af 8000 	nop.w

08001400 <test_004_005_teardown.lto_priv.112>:
static void test_004_005_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_005_teardown(void) {
  test_wait_threads();
 8001400:	f002 bc86 	b.w	8003d10 <test_wait_threads>
 8001404:	f3af 8000 	nop.w
 8001408:	f3af 8000 	nop.w
 800140c:	f3af 8000 	nop.w

08001410 <test_004_005_execute.lto_priv.113>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001410:	4b1e      	ldr	r3, [pc, #120]	; (800148c <test_004_005_execute.lto_priv.113+0x7c>)

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001412:	4a1f      	ldr	r2, [pc, #124]	; (8001490 <test_004_005_execute.lto_priv.113+0x80>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001414:	699b      	ldr	r3, [r3, #24]
 8001416:	481f      	ldr	r0, [pc, #124]	; (8001494 <test_004_005_execute.lto_priv.113+0x84>)
 8001418:	6899      	ldr	r1, [r3, #8]

static void test_004_005_teardown(void) {
  test_wait_threads();
}

static void test_004_005_execute(void) {
 800141a:	b570      	push	{r4, r5, r6, lr}

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 800141c:	4d1e      	ldr	r5, [pc, #120]	; (8001498 <test_004_005_execute.lto_priv.113+0x88>)
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 800141e:	4c1f      	ldr	r4, [pc, #124]	; (800149c <test_004_005_execute.lto_priv.113+0x8c>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001420:	3101      	adds	r1, #1
 8001422:	2300      	movs	r3, #0

static void test_004_005_execute(void) {

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
 8001424:	2601      	movs	r6, #1
 8001426:	602e      	str	r6, [r5, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001428:	f004 fb22 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800142c:	4a1c      	ldr	r2, [pc, #112]	; (80014a0 <test_004_005_execute.lto_priv.113+0x90>)
  }

  /* [4.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 800142e:	2302      	movs	r3, #2

  /* [4.5.1] An higher priority thread is created that performs
     non-atomical wait and signal operations on a semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread3, 0);
 8001430:	6010      	str	r0, [r2, #0]
  }

  /* [4.5.2] The function chSemSignalWait() is invoked by specifying
     the same semaphore for the wait and signal phases. The counter
     value must be one on exit.*/
  test_set_step(2);
 8001432:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8001434:	f004 fb6c 	bl	8005b10 <chSemSignalWait.constprop.63>
 8001438:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 800143a:	491a      	ldr	r1, [pc, #104]	; (80014a4 <test_004_005_execute.lto_priv.113+0x94>)
 800143c:	1b00      	subs	r0, r0, r4
 800143e:	fab0 f080 	clz	r0, r0
 8001442:	0940      	lsrs	r0, r0, #5
 8001444:	f002 fd3c 	bl	8003ec0 <_test_assert>
 8001448:	b100      	cbz	r0, 800144c <test_004_005_execute.lto_priv.113+0x3c>
 800144a:	bd70      	pop	{r4, r5, r6, pc}
    test_assert(sem1.cnt == 0, "counter not zero");
 800144c:	68a0      	ldr	r0, [r4, #8]
 800144e:	4916      	ldr	r1, [pc, #88]	; (80014a8 <test_004_005_execute.lto_priv.113+0x98>)
 8001450:	fab0 f080 	clz	r0, r0
 8001454:	0940      	lsrs	r0, r0, #5
 8001456:	f002 fd33 	bl	8003ec0 <_test_assert>
 800145a:	2800      	cmp	r0, #0
 800145c:	d1f5      	bne.n	800144a <test_004_005_execute.lto_priv.113+0x3a>
  }

  /* [4.5.3] The function chSemSignalWait() is invoked again by
     specifying the same semaphore for the wait and signal phases. The
     counter value must be one on exit.*/
  test_set_step(3);
 800145e:	2303      	movs	r3, #3
 8001460:	602b      	str	r3, [r5, #0]
  {
    chSemSignalWait(&sem1, &sem1);
 8001462:	f004 fb55 	bl	8005b10 <chSemSignalWait.constprop.63>
 8001466:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001468:	490e      	ldr	r1, [pc, #56]	; (80014a4 <test_004_005_execute.lto_priv.113+0x94>)
 800146a:	1b00      	subs	r0, r0, r4
 800146c:	fab0 f080 	clz	r0, r0
 8001470:	0940      	lsrs	r0, r0, #5
 8001472:	f002 fd25 	bl	8003ec0 <_test_assert>
 8001476:	2800      	cmp	r0, #0
 8001478:	d1e7      	bne.n	800144a <test_004_005_execute.lto_priv.113+0x3a>
    test_assert(sem1.cnt == 0, "counter not zero");
 800147a:	68a0      	ldr	r0, [r4, #8]
 800147c:	490a      	ldr	r1, [pc, #40]	; (80014a8 <test_004_005_execute.lto_priv.113+0x98>)
 800147e:	fab0 f080 	clz	r0, r0
  }
}
 8001482:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     counter value must be one on exit.*/
  test_set_step(3);
  {
    chSemSignalWait(&sem1, &sem1);
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
 8001486:	0940      	lsrs	r0, r0, #5
 8001488:	f002 bd1a 	b.w	8003ec0 <_test_assert>
 800148c:	200013b0 	.word	0x200013b0
 8001490:	080014b1 	.word	0x080014b1
 8001494:	20000c50 	.word	0x20000c50
 8001498:	2000133c 	.word	0x2000133c
 800149c:	20001460 	.word	0x20001460
 80014a0:	20001340 	.word	0x20001340
 80014a4:	08006ee8 	.word	0x08006ee8
 80014a8:	08006ef8 	.word	0x08006ef8
 80014ac:	f3af 8000 	nop.w

080014b0 <thread3>:
  chSemSignalI(&sem1); /* For coverage reasons */
  chSchRescheduleS();
  chSysUnlock();
}

static THD_FUNCTION(thread3, p) {
 80014b0:	b510      	push	{r4, lr}

  (void)p;
  chSemWait(&sem1);
 80014b2:	4c04      	ldr	r4, [pc, #16]	; (80014c4 <thread3+0x14>)
 80014b4:	4620      	mov	r0, r4
 80014b6:	f003 ff8b 	bl	80053d0 <chSemWait>
  chSemSignal(&sem1);
 80014ba:	4620      	mov	r0, r4
}
 80014bc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

static THD_FUNCTION(thread3, p) {

  (void)p;
  chSemWait(&sem1);
  chSemSignal(&sem1);
 80014c0:	f003 bf4e 	b.w	8005360 <chSemSignal>
 80014c4:	20001460 	.word	0x20001460
 80014c8:	f3af 8000 	nop.w
 80014cc:	f3af 8000 	nop.w

080014d0 <test_004_001_execute.lto_priv.104>:

static void test_004_001_teardown(void) {
  chSemReset(&sem1, 0);
}

static void test_004_001_execute(void) {
 80014d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
     counter and the returned message are tested.*/
  test_set_step(1);
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80014d4:	4c2b      	ldr	r4, [pc, #172]	; (8001584 <test_004_001_execute.lto_priv.104+0xb4>)

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 80014d6:	4e2c      	ldr	r6, [pc, #176]	; (8001588 <test_004_001_execute.lto_priv.104+0xb8>)
 80014d8:	2301      	movs	r3, #1
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80014da:	4620      	mov	r0, r4

static void test_004_001_execute(void) {

  /* [4.1.1] The function chSemWait() is invoked, after return the
     counter and the returned message are tested.*/
  test_set_step(1);
 80014dc:	6033      	str	r3, [r6, #0]
  {
    msg_t msg;

    msg = chSemWait(&sem1);
 80014de:	f003 ff77 	bl	80053d0 <chSemWait>
 80014e2:	2520      	movs	r5, #32
 80014e4:	4607      	mov	r7, r0
 80014e6:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 0, "wrong counter value");
 80014ea:	4928      	ldr	r1, [pc, #160]	; (800158c <test_004_001_execute.lto_priv.104+0xbc>)
 80014ec:	68a0      	ldr	r0, [r4, #8]
 80014ee:	fab0 f080 	clz	r0, r0
 80014f2:	0940      	lsrs	r0, r0, #5
 80014f4:	f002 fce4 	bl	8003ec0 <_test_assert>
 80014f8:	b120      	cbz	r0, 8001504 <test_004_001_execute.lto_priv.104+0x34>
 80014fa:	2300      	movs	r3, #0
 80014fc:	f383 8811 	msr	BASEPRI, r3
 8001500:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001504:	f380 8811 	msr	BASEPRI, r0
    test_assert(MSG_OK == msg, "wrong returned message");
 8001508:	4921      	ldr	r1, [pc, #132]	; (8001590 <test_004_001_execute.lto_priv.104+0xc0>)
 800150a:	fab7 f087 	clz	r0, r7
 800150e:	0940      	lsrs	r0, r0, #5
 8001510:	f002 fcd6 	bl	8003ec0 <_test_assert>
 8001514:	4607      	mov	r7, r0
 8001516:	b108      	cbz	r0, 800151c <test_004_001_execute.lto_priv.104+0x4c>
 8001518:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 800151c:	f04f 0902 	mov.w	r9, #2
  {
    chSemSignal(&sem1);
 8001520:	4620      	mov	r0, r4
    test_assert(MSG_OK == msg, "wrong returned message");
  }

  /* [4.1.2] The function chSemSignal() is invoked, after return the
     counter is tested.*/
  test_set_step(2);
 8001522:	f8c6 9000 	str.w	r9, [r6]
  {
    chSemSignal(&sem1);
 8001526:	f003 ff1b 	bl	8005360 <chSemSignal>
 800152a:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
 800152e:	68a0      	ldr	r0, [r4, #8]
 8001530:	4916      	ldr	r1, [pc, #88]	; (800158c <test_004_001_execute.lto_priv.104+0xbc>)
 8001532:	f1a0 0001 	sub.w	r0, r0, #1
 8001536:	fab0 f080 	clz	r0, r0
 800153a:	0940      	lsrs	r0, r0, #5
 800153c:	f002 fcc0 	bl	8003ec0 <_test_assert>
 8001540:	4680      	mov	r8, r0
 8001542:	b118      	cbz	r0, 800154c <test_004_001_execute.lto_priv.104+0x7c>
 8001544:	f387 8811 	msr	BASEPRI, r7
 8001548:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 800154c:	f380 8811 	msr	BASEPRI, r0
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8001550:	2303      	movs	r3, #3
  {
    chSemReset(&sem1, 2);
 8001552:	4649      	mov	r1, r9
 8001554:	4620      	mov	r0, r4
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "wrong counter value");
  }

  /* [4.1.3] The function chSemReset() is invoked, after return the
     counter is tested.*/
  test_set_step(3);
 8001556:	6033      	str	r3, [r6, #0]
  {
    chSemReset(&sem1, 2);
 8001558:	f004 f89a 	bl	8005690 <chSemReset>
 800155c:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(chSemGetCounterI(&sem1) == 2, "wrong counter value");
 8001560:	68a0      	ldr	r0, [r4, #8]
 8001562:	490a      	ldr	r1, [pc, #40]	; (800158c <test_004_001_execute.lto_priv.104+0xbc>)
 8001564:	f1a0 0002 	sub.w	r0, r0, #2
 8001568:	fab0 f080 	clz	r0, r0
 800156c:	0940      	lsrs	r0, r0, #5
 800156e:	f002 fca7 	bl	8003ec0 <_test_assert>
 8001572:	b910      	cbnz	r0, 800157a <test_004_001_execute.lto_priv.104+0xaa>
 8001574:	f380 8811 	msr	BASEPRI, r0
 8001578:	e7ce      	b.n	8001518 <test_004_001_execute.lto_priv.104+0x48>
 800157a:	f388 8811 	msr	BASEPRI, r8
 800157e:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8001582:	bf00      	nop
 8001584:	20001460 	.word	0x20001460
 8001588:	2000133c 	.word	0x2000133c
 800158c:	08006f0c 	.word	0x08006f0c
 8001590:	08006f20 	.word	0x08006f20
 8001594:	f3af 8000 	nop.w
 8001598:	f3af 8000 	nop.w
 800159c:	f3af 8000 	nop.w

080015a0 <thread1.lto_priv.186>:

#include "ch.h"

static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {
 80015a0:	b510      	push	{r4, lr}
 80015a2:	4604      	mov	r4, r0

  chSemWait(&sem1);
 80015a4:	4803      	ldr	r0, [pc, #12]	; (80015b4 <thread1.lto_priv.186+0x14>)
 80015a6:	f003 ff13 	bl	80053d0 <chSemWait>
  test_emit_token(*(char *)p);
 80015aa:	7820      	ldrb	r0, [r4, #0]
}
 80015ac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static semaphore_t sem1;

static THD_FUNCTION(thread1, p) {

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
 80015b0:	f002 bbe6 	b.w	8003d80 <test_emit_token>
 80015b4:	20001460 	.word	0x20001460
 80015b8:	f3af 8000 	nop.w
 80015bc:	f3af 8000 	nop.w

080015c0 <thread>:
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(thread, p) {

  test_emit_token(*(char *)p);
 80015c0:	7800      	ldrb	r0, [r0, #0]
 80015c2:	f002 bbdd 	b.w	8003d80 <test_emit_token>
 80015c6:	bf00      	nop
 80015c8:	f3af 8000 	nop.w
 80015cc:	f3af 8000 	nop.w

080015d0 <test_004_002_execute.lto_priv.106>:

static void test_004_002_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_002_execute(void) {
 80015d0:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80015d4:	f8df 80e0 	ldr.w	r8, [pc, #224]	; 80016b8 <test_004_002_execute.lto_priv.106+0xe8>
  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80015d8:	4f2c      	ldr	r7, [pc, #176]	; (800168c <test_004_002_execute.lto_priv.106+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80015da:	f8d8 3018 	ldr.w	r3, [r8, #24]
 80015de:	4e2c      	ldr	r6, [pc, #176]	; (8001690 <test_004_002_execute.lto_priv.106+0xc0>)
 80015e0:	6899      	ldr	r1, [r3, #8]
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80015e2:	f8df 90d8 	ldr.w	r9, [pc, #216]	; 80016bc <test_004_002_execute.lto_priv.106+0xec>
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80015e6:	4b2b      	ldr	r3, [pc, #172]	; (8001694 <test_004_002_execute.lto_priv.106+0xc4>)
 80015e8:	4d2b      	ldr	r5, [pc, #172]	; (8001698 <test_004_002_execute.lto_priv.106+0xc8>)

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 80015ea:	4c2c      	ldr	r4, [pc, #176]	; (800169c <test_004_002_execute.lto_priv.106+0xcc>)
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80015ec:	f04f 0e01 	mov.w	lr, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80015f0:	4632      	mov	r2, r6
 80015f2:	3105      	adds	r1, #5
 80015f4:	4638      	mov	r0, r7
static void test_004_002_execute(void) {

  /* [4.2.1] Five threads are created with mixed priority levels (not
     increasing nor decreasing). Threads enqueue on a semaphore
     initialized to zero.*/
  test_set_step(1);
 80015f6:	f8c9 e000 	str.w	lr, [r9]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
 80015fa:	f004 fa39 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80015fe:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8001602:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
 8001604:	6899      	ldr	r1, [r3, #8]
 8001606:	4b26      	ldr	r3, [pc, #152]	; (80016a0 <test_004_002_execute.lto_priv.106+0xd0>)
 8001608:	4632      	mov	r2, r6
 800160a:	3101      	adds	r1, #1
 800160c:	f507 70a4 	add.w	r0, r7, #328	; 0x148
 8001610:	f004 fa2e 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001614:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8001618:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
 800161a:	6899      	ldr	r1, [r3, #8]
 800161c:	4b21      	ldr	r3, [pc, #132]	; (80016a4 <test_004_002_execute.lto_priv.106+0xd4>)
 800161e:	4632      	mov	r2, r6
 8001620:	3103      	adds	r1, #3
 8001622:	f507 7024 	add.w	r0, r7, #656	; 0x290
 8001626:	f004 fa23 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800162a:	f8d8 3018 	ldr.w	r3, [r8, #24]
 800162e:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
 8001630:	6899      	ldr	r1, [r3, #8]
 8001632:	4b1d      	ldr	r3, [pc, #116]	; (80016a8 <test_004_002_execute.lto_priv.106+0xd8>)
 8001634:	4632      	mov	r2, r6
 8001636:	3104      	adds	r1, #4
 8001638:	f507 7076 	add.w	r0, r7, #984	; 0x3d8
 800163c:	f004 fa18 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001640:	f8d8 3018 	ldr.w	r3, [r8, #24]
 8001644:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001646:	6899      	ldr	r1, [r3, #8]
 8001648:	4b18      	ldr	r3, [pc, #96]	; (80016ac <test_004_002_execute.lto_priv.106+0xdc>)
 800164a:	3102      	adds	r1, #2
 800164c:	4632      	mov	r2, r6
 800164e:	f507 60a4 	add.w	r0, r7, #1312	; 0x520
 8001652:	f004 fa0d 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 8001656:	2302      	movs	r3, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+5, thread1, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()+1, thread1, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()+4, thread1, "D");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
 8001658:	6128      	str	r0, [r5, #16]

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
  {
    chSemSignal(&sem1);
 800165a:	4620      	mov	r0, r4
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()+2, thread1, "E");
  }

  /* [4.2.2] The semaphore is signaled 5 times. The thread activation
     sequence is tested.*/
  test_set_step(2);
 800165c:	f8c9 3000 	str.w	r3, [r9]
  {
    chSemSignal(&sem1);
 8001660:	f003 fe7e 	bl	8005360 <chSemSignal>
    chSemSignal(&sem1);
 8001664:	4620      	mov	r0, r4
 8001666:	f003 fe7b 	bl	8005360 <chSemSignal>
    chSemSignal(&sem1);
 800166a:	4620      	mov	r0, r4
 800166c:	f003 fe78 	bl	8005360 <chSemSignal>
    chSemSignal(&sem1);
 8001670:	4620      	mov	r0, r4
 8001672:	f003 fe75 	bl	8005360 <chSemSignal>
    chSemSignal(&sem1);
 8001676:	4620      	mov	r0, r4
 8001678:	f003 fe72 	bl	8005360 <chSemSignal>
    test_wait_threads();
 800167c:	f002 fb48 	bl	8003d10 <test_wait_threads>
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 8001680:	480b      	ldr	r0, [pc, #44]	; (80016b0 <test_004_002_execute.lto_priv.106+0xe0>)
 8001682:	490c      	ldr	r1, [pc, #48]	; (80016b4 <test_004_002_execute.lto_priv.106+0xe4>)
#endif
  }
}
 8001684:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    chSemSignal(&sem1);
    test_wait_threads();
#if CH_CFG_USE_SEMAPHORES_PRIORITY
    test_assert_sequence("ADCEB", "invalid sequence");
#else
    test_assert_sequence("ABCDE", "invalid sequence");
 8001688:	f002 bbf2 	b.w	8003e70 <_test_assert_sequence>
 800168c:	20000c50 	.word	0x20000c50
 8001690:	080015a1 	.word	0x080015a1
 8001694:	08006f38 	.word	0x08006f38
 8001698:	20001340 	.word	0x20001340
 800169c:	20001460 	.word	0x20001460
 80016a0:	08006f3c 	.word	0x08006f3c
 80016a4:	08006f40 	.word	0x08006f40
 80016a8:	08006f44 	.word	0x08006f44
 80016ac:	08006f4c 	.word	0x08006f4c
 80016b0:	08006f48 	.word	0x08006f48
 80016b4:	08006f50 	.word	0x08006f50
 80016b8:	200013b0 	.word	0x200013b0
 80016bc:	2000133c 	.word	0x2000133c

080016c0 <test_002_002_execute.lto_priv.97>:
 * - [2.2.3] Creating 5 threads with pseudo-random priority, execution
 *   sequence is tested.
 * .
 */

static void test_002_002_execute(void) {
 80016c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80016c2:	4d54      	ldr	r5, [pc, #336]	; (8001814 <test_002_002_execute.lto_priv.97+0x154>)

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80016c4:	4e54      	ldr	r6, [pc, #336]	; (8001818 <test_002_002_execute.lto_priv.97+0x158>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80016c6:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80016c8:	4a54      	ldr	r2, [pc, #336]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80016ca:	6899      	ldr	r1, [r3, #8]
 80016cc:	4854      	ldr	r0, [pc, #336]	; (8001820 <test_002_002_execute.lto_priv.97+0x160>)
 80016ce:	4b55      	ldr	r3, [pc, #340]	; (8001824 <test_002_002_execute.lto_priv.97+0x164>)
 80016d0:	4c55      	ldr	r4, [pc, #340]	; (8001828 <test_002_002_execute.lto_priv.97+0x168>)
 80016d2:	3905      	subs	r1, #5

static void test_002_002_execute(void) {

  /* [2.2.1] Creating 5 threads with increasing priority, execution
     sequence is tested.*/
  test_set_step(1);
 80016d4:	2701      	movs	r7, #1
 80016d6:	6037      	str	r7, [r6, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80016d8:	f004 f9ca 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80016dc:	69ab      	ldr	r3, [r5, #24]
 80016de:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80016e0:	6899      	ldr	r1, [r3, #8]
 80016e2:	4a4e      	ldr	r2, [pc, #312]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80016e4:	4b51      	ldr	r3, [pc, #324]	; (800182c <test_002_002_execute.lto_priv.97+0x16c>)
 80016e6:	4852      	ldr	r0, [pc, #328]	; (8001830 <test_002_002_execute.lto_priv.97+0x170>)
 80016e8:	3904      	subs	r1, #4
 80016ea:	f004 f9c1 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80016ee:	69ab      	ldr	r3, [r5, #24]
 80016f0:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80016f2:	6899      	ldr	r1, [r3, #8]
 80016f4:	4a49      	ldr	r2, [pc, #292]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80016f6:	4b4f      	ldr	r3, [pc, #316]	; (8001834 <test_002_002_execute.lto_priv.97+0x174>)
 80016f8:	484f      	ldr	r0, [pc, #316]	; (8001838 <test_002_002_execute.lto_priv.97+0x178>)
 80016fa:	3903      	subs	r1, #3
 80016fc:	f004 f9b8 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001700:	69ab      	ldr	r3, [r5, #24]
 8001702:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 8001704:	6899      	ldr	r1, [r3, #8]
 8001706:	4a45      	ldr	r2, [pc, #276]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 8001708:	4b4c      	ldr	r3, [pc, #304]	; (800183c <test_002_002_execute.lto_priv.97+0x17c>)
 800170a:	484d      	ldr	r0, [pc, #308]	; (8001840 <test_002_002_execute.lto_priv.97+0x180>)
 800170c:	3902      	subs	r1, #2
 800170e:	f004 f9af 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001712:	69ab      	ldr	r3, [r5, #24]
 8001714:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001716:	6899      	ldr	r1, [r3, #8]
 8001718:	4a40      	ldr	r2, [pc, #256]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 800171a:	4b4a      	ldr	r3, [pc, #296]	; (8001844 <test_002_002_execute.lto_priv.97+0x184>)
 800171c:	484a      	ldr	r0, [pc, #296]	; (8001848 <test_002_002_execute.lto_priv.97+0x188>)
 800171e:	3901      	subs	r1, #1
 8001720:	f004 f9a6 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001724:	6120      	str	r0, [r4, #16]
    test_wait_threads();
 8001726:	f002 faf3 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 800172a:	4848      	ldr	r0, [pc, #288]	; (800184c <test_002_002_execute.lto_priv.97+0x18c>)
 800172c:	4948      	ldr	r1, [pc, #288]	; (8001850 <test_002_002_execute.lto_priv.97+0x190>)
 800172e:	f002 fb9f 	bl	8003e70 <_test_assert_sequence>
 8001732:	b100      	cbz	r0, 8001736 <test_002_002_execute.lto_priv.97+0x76>
 8001734:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8001736:	69ab      	ldr	r3, [r5, #24]

  /* [2.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001738:	4a38      	ldr	r2, [pc, #224]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 800173a:	6899      	ldr	r1, [r3, #8]
 800173c:	4842      	ldr	r0, [pc, #264]	; (8001848 <test_002_002_execute.lto_priv.97+0x188>)
 800173e:	4b41      	ldr	r3, [pc, #260]	; (8001844 <test_002_002_execute.lto_priv.97+0x184>)
 8001740:	3901      	subs	r1, #1
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [2.2.2] Creating 5 threads with decreasing priority, execution
     sequence is tested.*/
  test_set_step(2);
 8001742:	2702      	movs	r7, #2
 8001744:	6037      	str	r7, [r6, #0]
  {
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 8001746:	f004 f993 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800174a:	69ab      	ldr	r3, [r5, #24]
 800174c:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 800174e:	6899      	ldr	r1, [r3, #8]
 8001750:	4a32      	ldr	r2, [pc, #200]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 8001752:	4b3a      	ldr	r3, [pc, #232]	; (800183c <test_002_002_execute.lto_priv.97+0x17c>)
 8001754:	483a      	ldr	r0, [pc, #232]	; (8001840 <test_002_002_execute.lto_priv.97+0x180>)
 8001756:	3902      	subs	r1, #2
 8001758:	f004 f98a 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800175c:	69ab      	ldr	r3, [r5, #24]
 800175e:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 8001760:	6899      	ldr	r1, [r3, #8]
 8001762:	4a2e      	ldr	r2, [pc, #184]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 8001764:	4b33      	ldr	r3, [pc, #204]	; (8001834 <test_002_002_execute.lto_priv.97+0x174>)
 8001766:	4834      	ldr	r0, [pc, #208]	; (8001838 <test_002_002_execute.lto_priv.97+0x178>)
 8001768:	3903      	subs	r1, #3
 800176a:	f004 f981 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800176e:	69ab      	ldr	r3, [r5, #24]
 8001770:	60a0      	str	r0, [r4, #8]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 8001772:	6899      	ldr	r1, [r3, #8]
 8001774:	4a29      	ldr	r2, [pc, #164]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 8001776:	4b2d      	ldr	r3, [pc, #180]	; (800182c <test_002_002_execute.lto_priv.97+0x16c>)
 8001778:	482d      	ldr	r0, [pc, #180]	; (8001830 <test_002_002_execute.lto_priv.97+0x170>)
 800177a:	3904      	subs	r1, #4
 800177c:	f004 f978 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001780:	69ab      	ldr	r3, [r5, #24]
 8001782:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 8001784:	6899      	ldr	r1, [r3, #8]
 8001786:	4a25      	ldr	r2, [pc, #148]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 8001788:	4b26      	ldr	r3, [pc, #152]	; (8001824 <test_002_002_execute.lto_priv.97+0x164>)
 800178a:	4825      	ldr	r0, [pc, #148]	; (8001820 <test_002_002_execute.lto_priv.97+0x160>)
 800178c:	3905      	subs	r1, #5
 800178e:	f004 f96f 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001792:	6020      	str	r0, [r4, #0]
    test_wait_threads();
 8001794:	f002 fabc 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001798:	482c      	ldr	r0, [pc, #176]	; (800184c <test_002_002_execute.lto_priv.97+0x18c>)
 800179a:	492d      	ldr	r1, [pc, #180]	; (8001850 <test_002_002_execute.lto_priv.97+0x190>)
 800179c:	f002 fb68 	bl	8003e70 <_test_assert_sequence>
 80017a0:	2800      	cmp	r0, #0
 80017a2:	d1c7      	bne.n	8001734 <test_002_002_execute.lto_priv.97+0x74>
 80017a4:	69ab      	ldr	r3, [r5, #24]

  /* [2.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80017a6:	4a1d      	ldr	r2, [pc, #116]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80017a8:	6899      	ldr	r1, [r3, #8]
 80017aa:	4821      	ldr	r0, [pc, #132]	; (8001830 <test_002_002_execute.lto_priv.97+0x170>)
 80017ac:	4b1f      	ldr	r3, [pc, #124]	; (800182c <test_002_002_execute.lto_priv.97+0x16c>)
 80017ae:	3904      	subs	r1, #4
    test_assert_sequence("ABCDE", "invalid sequence");
  }

  /* [2.2.3] Creating 5 threads with pseudo-random priority, execution
     sequence is tested.*/
  test_set_step(3);
 80017b0:	2703      	movs	r7, #3
 80017b2:	6037      	str	r7, [r6, #0]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-4, thread, "D");
 80017b4:	f004 f95c 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80017b8:	69ab      	ldr	r3, [r5, #24]
 80017ba:	6060      	str	r0, [r4, #4]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
 80017bc:	6899      	ldr	r1, [r3, #8]
 80017be:	4a17      	ldr	r2, [pc, #92]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80017c0:	4b18      	ldr	r3, [pc, #96]	; (8001824 <test_002_002_execute.lto_priv.97+0x164>)
 80017c2:	4817      	ldr	r0, [pc, #92]	; (8001820 <test_002_002_execute.lto_priv.97+0x160>)
 80017c4:	3905      	subs	r1, #5
 80017c6:	f004 f953 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80017ca:	69ab      	ldr	r3, [r5, #24]
 80017cc:	6020      	str	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
 80017ce:	6899      	ldr	r1, [r3, #8]
 80017d0:	4a12      	ldr	r2, [pc, #72]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80017d2:	4b1c      	ldr	r3, [pc, #112]	; (8001844 <test_002_002_execute.lto_priv.97+0x184>)
 80017d4:	481c      	ldr	r0, [pc, #112]	; (8001848 <test_002_002_execute.lto_priv.97+0x188>)
 80017d6:	3901      	subs	r1, #1
 80017d8:	f004 f94a 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80017dc:	69ab      	ldr	r3, [r5, #24]
 80017de:	6120      	str	r0, [r4, #16]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
 80017e0:	6899      	ldr	r1, [r3, #8]
 80017e2:	4a0e      	ldr	r2, [pc, #56]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80017e4:	4b15      	ldr	r3, [pc, #84]	; (800183c <test_002_002_execute.lto_priv.97+0x17c>)
 80017e6:	4816      	ldr	r0, [pc, #88]	; (8001840 <test_002_002_execute.lto_priv.97+0x180>)
 80017e8:	3902      	subs	r1, #2
 80017ea:	f004 f941 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80017ee:	69ab      	ldr	r3, [r5, #24]
 80017f0:	60e0      	str	r0, [r4, #12]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
 80017f2:	6899      	ldr	r1, [r3, #8]
 80017f4:	4a09      	ldr	r2, [pc, #36]	; (800181c <test_002_002_execute.lto_priv.97+0x15c>)
 80017f6:	4b0f      	ldr	r3, [pc, #60]	; (8001834 <test_002_002_execute.lto_priv.97+0x174>)
 80017f8:	480f      	ldr	r0, [pc, #60]	; (8001838 <test_002_002_execute.lto_priv.97+0x178>)
 80017fa:	3903      	subs	r1, #3
 80017fc:	f004 f938 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001800:	60a0      	str	r0, [r4, #8]
    test_wait_threads();
 8001802:	f002 fa85 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8001806:	4811      	ldr	r0, [pc, #68]	; (800184c <test_002_002_execute.lto_priv.97+0x18c>)
 8001808:	4911      	ldr	r1, [pc, #68]	; (8001850 <test_002_002_execute.lto_priv.97+0x190>)
  }
}
 800180a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-5, thread, "E");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-1, thread, "A");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-2, thread, "B");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, thread, "C");
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 800180e:	f002 bb2f 	b.w	8003e70 <_test_assert_sequence>
 8001812:	bf00      	nop
 8001814:	200013b0 	.word	0x200013b0
 8001818:	2000133c 	.word	0x2000133c
 800181c:	080015c1 	.word	0x080015c1
 8001820:	20000c50 	.word	0x20000c50
 8001824:	08006f4c 	.word	0x08006f4c
 8001828:	20001340 	.word	0x20001340
 800182c:	08006f44 	.word	0x08006f44
 8001830:	20000d98 	.word	0x20000d98
 8001834:	08006f40 	.word	0x08006f40
 8001838:	20000ee0 	.word	0x20000ee0
 800183c:	08006f3c 	.word	0x08006f3c
 8001840:	20001028 	.word	0x20001028
 8001844:	08006f38 	.word	0x08006f38
 8001848:	20001170 	.word	0x20001170
 800184c:	08006f48 	.word	0x08006f48
 8001850:	08006f50 	.word	0x08006f50
 8001854:	f3af 8000 	nop.w
 8001858:	f3af 8000 	nop.w
 800185c:	f3af 8000 	nop.w

08001860 <test_004_004_execute.lto_priv.110>:

static void test_004_004_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_004_execute(void) {
 8001860:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001862:	4b23      	ldr	r3, [pc, #140]	; (80018f0 <test_004_004_execute.lto_priv.110+0x90>)

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8001864:	4c23      	ldr	r4, [pc, #140]	; (80018f4 <test_004_004_execute.lto_priv.110+0x94>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001866:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8001868:	4a23      	ldr	r2, [pc, #140]	; (80018f8 <test_004_004_execute.lto_priv.110+0x98>)
 800186a:	6899      	ldr	r1, [r3, #8]
 800186c:	4823      	ldr	r0, [pc, #140]	; (80018fc <test_004_004_execute.lto_priv.110+0x9c>)
 800186e:	4b24      	ldr	r3, [pc, #144]	; (8001900 <test_004_004_execute.lto_priv.110+0xa0>)
 8001870:	3101      	adds	r1, #1
}

static void test_004_004_execute(void) {

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
 8001872:	2501      	movs	r5, #1
 8001874:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 8001876:	f004 f8fb 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800187a:	4b22      	ldr	r3, [pc, #136]	; (8001904 <test_004_004_execute.lto_priv.110+0xa4>)
  }

  /* [4.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 800187c:	2502      	movs	r5, #2
static void test_004_004_execute(void) {

  /* [4.4.1] A thread is created, it goes to wait on the semaphore.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, thread1, "A");
 800187e:	6018      	str	r0, [r3, #0]
  }

  /* [4.4.2] The semaphore counter is increased by two, it is then
     tested to be one, the thread must have completed.*/
  test_set_step(2);
 8001880:	6025      	str	r5, [r4, #0]
 8001882:	2320      	movs	r3, #32
 8001884:	f383 8811 	msr	BASEPRI, r3
 8001888:	4c1f      	ldr	r4, [pc, #124]	; (8001908 <test_004_004_execute.lto_priv.110+0xa8>)
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 800188a:	2700      	movs	r7, #0
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
    if (++sp->cnt <= (cnt_t)0) {
 800188c:	4626      	mov	r6, r4
 800188e:	e002      	b.n	8001896 <test_004_004_execute.lto_priv.110+0x36>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 8001890:	2d01      	cmp	r5, #1
 8001892:	d00e      	beq.n	80018b2 <test_004_004_execute.lto_priv.110+0x52>
 8001894:	2501      	movs	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
 8001896:	68a3      	ldr	r3, [r4, #8]
 8001898:	3301      	adds	r3, #1
 800189a:	2b00      	cmp	r3, #0
 800189c:	60a3      	str	r3, [r4, #8]
 800189e:	dcf7      	bgt.n	8001890 <test_004_004_execute.lto_priv.110+0x30>
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80018a0:	6830      	ldr	r0, [r6, #0]

  tqp->next             = tp->queue.next;
 80018a2:	6803      	ldr	r3, [r0, #0]
 80018a4:	6033      	str	r3, [r6, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 80018a6:	605e      	str	r6, [r3, #4]
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 80018a8:	f003 fdda 	bl	8005460 <chSchReadyI>
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80018ac:	2d01      	cmp	r5, #1
    if (++sp->cnt <= (cnt_t)0) {
      chSchReadyI(queue_fifo_remove(&sp->queue))->u.rdymsg = MSG_OK;
 80018ae:	6247      	str	r7, [r0, #36]	; 0x24
  chDbgCheck((sp != NULL) && (n > (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  while (n > (cnt_t)0) {
 80018b0:	d1f0      	bne.n	8001894 <test_004_004_execute.lto_priv.110+0x34>
  {
    chSysLock();
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
 80018b2:	f003 fce5 	bl	8005280 <chSchRescheduleS>
 80018b6:	2500      	movs	r5, #0
 80018b8:	f385 8811 	msr	BASEPRI, r5
    chSysUnlock();
    test_wait_threads();
 80018bc:	f002 fa28 	bl	8003d10 <test_wait_threads>
 80018c0:	2320      	movs	r3, #32
 80018c2:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
 80018c6:	68a0      	ldr	r0, [r4, #8]
 80018c8:	4910      	ldr	r1, [pc, #64]	; (800190c <test_004_004_execute.lto_priv.110+0xac>)
 80018ca:	f1a0 0001 	sub.w	r0, r0, #1
 80018ce:	fab0 f080 	clz	r0, r0
 80018d2:	0940      	lsrs	r0, r0, #5
 80018d4:	f002 faf4 	bl	8003ec0 <_test_assert>
 80018d8:	b110      	cbz	r0, 80018e0 <test_004_004_execute.lto_priv.110+0x80>
 80018da:	f385 8811 	msr	BASEPRI, r5
 80018de:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80018e0:	f380 8811 	msr	BASEPRI, r0
    test_assert_sequence("A", "invalid sequence");
 80018e4:	4806      	ldr	r0, [pc, #24]	; (8001900 <test_004_004_execute.lto_priv.110+0xa0>)
 80018e6:	490a      	ldr	r1, [pc, #40]	; (8001910 <test_004_004_execute.lto_priv.110+0xb0>)
  }
}
 80018e8:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    chSemAddCounterI(&sem1, 2);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_lock(chSemGetCounterI(&sem1) == 1, "invalid counter");
    test_assert_sequence("A", "invalid sequence");
 80018ec:	f002 bac0 	b.w	8003e70 <_test_assert_sequence>
 80018f0:	200013b0 	.word	0x200013b0
 80018f4:	2000133c 	.word	0x2000133c
 80018f8:	080015a1 	.word	0x080015a1
 80018fc:	20000c50 	.word	0x20000c50
 8001900:	08006f38 	.word	0x08006f38
 8001904:	20001340 	.word	0x20001340
 8001908:	20001460 	.word	0x20001460
 800190c:	08006f64 	.word	0x08006f64
 8001910:	08006f50 	.word	0x08006f50
 8001914:	f3af 8000 	nop.w
 8001918:	f3af 8000 	nop.w
 800191c:	f3af 8000 	nop.w

08001920 <thread1.lto_priv.185>:
 * Shared code.
 ****************************************************************************/

static thread_reference_t tr1;

static THD_FUNCTION(thread1, p) {
 8001920:	b510      	push	{r4, lr}
 8001922:	2320      	movs	r3, #32
 8001924:	4604      	mov	r4, r0
 8001926:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 800192a:	4b09      	ldr	r3, [pc, #36]	; (8001950 <thread1.lto_priv.185+0x30>)
 800192c:	6818      	ldr	r0, [r3, #0]
 800192e:	b120      	cbz	r0, 800193a <thread1.lto_priv.185+0x1a>
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001930:	2200      	movs	r2, #0
    tp->u.rdymsg = msg;
 8001932:	6242      	str	r2, [r0, #36]	; 0x24
  if (*trp != NULL) {
    thread_t *tp = *trp;

    chDbgAssert(tp->state == CH_STATE_SUSPENDED, "not CH_STATE_SUSPENDED");

    *trp = NULL;
 8001934:	601a      	str	r2, [r3, #0]
    tp->u.rdymsg = msg;
    (void) chSchReadyI(tp);
 8001936:	f003 fd93 	bl	8005460 <chSchReadyI>

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
 800193a:	f003 fca1 	bl	8005280 <chSchRescheduleS>
 800193e:	2300      	movs	r3, #0
 8001940:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();
  test_emit_token(*(char *)p);
 8001944:	7820      	ldrb	r0, [r4, #0]
}
 8001946:	e8bd 4010 	ldmia.w	sp!, {r4, lr}

  chSysLock();
  chThdResumeI(&tr1, MSG_OK);
  chSchRescheduleS();
  chSysUnlock();
  test_emit_token(*(char *)p);
 800194a:	f002 ba19 	b.w	8003d80 <test_emit_token>
 800194e:	bf00      	nop
 8001950:	2000137c 	.word	0x2000137c
 8001954:	f3af 8000 	nop.w
 8001958:	f3af 8000 	nop.w
 800195c:	f3af 8000 	nop.w

08001960 <thread2>:

  chSemWait(&sem1);
  test_emit_token(*(char *)p);
}

static THD_FUNCTION(thread2, p) {
 8001960:	b508      	push	{r3, lr}

  (void)p;
  chThdSleepMilliseconds(50);
 8001962:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8001966:	f003 ffa3 	bl	80058b0 <chThdSleep>
 800196a:	2320      	movs	r3, #32
 800196c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chSemSignalI(&sem1); /* For coverage reasons */
 8001970:	4804      	ldr	r0, [pc, #16]	; (8001984 <thread2+0x24>)
 8001972:	f003 fe65 	bl	8005640 <chSemSignalI>
  chSchRescheduleS();
 8001976:	f003 fc83 	bl	8005280 <chSchRescheduleS>
 800197a:	2300      	movs	r3, #0
 800197c:	f383 8811 	msr	BASEPRI, r3
 8001980:	bd08      	pop	{r3, pc}
 8001982:	bf00      	nop
 8001984:	20001460 	.word	0x20001460
 8001988:	f3af 8000 	nop.w
 800198c:	f3af 8000 	nop.w

08001990 <test_002_001_execute.lto_priv.96>:
 * - [2.1.5] Function chThdSleepUntil() is tested with a timeline of
 *   "now" + 100 ticks.
 * .
 */

static void test_002_001_execute(void) {
 8001990:	b570      	push	{r4, r5, r6, lr}
  systime_t time;

  /* [2.1.1] The current system time is read then a sleep is performed
     for 100 system ticks and on exit the system time is verified
     again.*/
  test_set_step(1);
 8001992:	4e2b      	ldr	r6, [pc, #172]	; (8001a40 <test_002_001_execute.lto_priv.96+0xb0>)
 8001994:	2301      	movs	r3, #1
 8001996:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 800199a:	6033      	str	r3, [r6, #0]
 800199c:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleep(100);
 800199e:	2064      	movs	r0, #100	; 0x64
 80019a0:	f003 ff86 	bl	80058b0 <chThdSleep>
    test_assert_time_window(time + 100,
 80019a4:	f104 0064 	add.w	r0, r4, #100	; 0x64
 80019a8:	f104 0167 	add.w	r1, r4, #103	; 0x67
 80019ac:	f004 fba8 	bl	8006100 <_test_assert_time_window.constprop.2>
 80019b0:	b100      	cbz	r0, 80019b4 <test_002_001_execute.lto_priv.96+0x24>
 80019b2:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [2.1.2] The current system time is read then a sleep is performed
     for 100000 microseconds and on exit the system time is verified
     again.*/
  test_set_step(2);
 80019b4:	2302      	movs	r3, #2
 80019b6:	6033      	str	r3, [r6, #0]
 80019b8:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMicroseconds(100000);
 80019ba:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80019be:	f003 ff77 	bl	80058b0 <chThdSleep>
    test_assert_time_window(time + US2ST(100000),
 80019c2:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 80019c6:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 80019ca:	f004 fb99 	bl	8006100 <_test_assert_time_window.constprop.2>
 80019ce:	2800      	cmp	r0, #0
 80019d0:	d1ef      	bne.n	80019b2 <test_002_001_execute.lto_priv.96+0x22>
  }

  /* [2.1.3] The current system time is read then a sleep is performed
     for 100 milliseconds and on exit the system time is verified
     again.*/
  test_set_step(3);
 80019d2:	2303      	movs	r3, #3
 80019d4:	6033      	str	r3, [r6, #0]
 80019d6:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepMilliseconds(100);
 80019d8:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
 80019dc:	f003 ff68 	bl	80058b0 <chThdSleep>
    test_assert_time_window(time + MS2ST(100),
 80019e0:	f504 707a 	add.w	r0, r4, #1000	; 0x3e8
 80019e4:	f204 31eb 	addw	r1, r4, #1003	; 0x3eb
 80019e8:	f004 fb8a 	bl	8006100 <_test_assert_time_window.constprop.2>
 80019ec:	2800      	cmp	r0, #0
 80019ee:	d1e0      	bne.n	80019b2 <test_002_001_execute.lto_priv.96+0x22>
                            "out of time window");
  }

  /* [2.1.4] The current system time is read then a sleep is performed
     for 1 second and on exit the system time is verified again.*/
  test_set_step(4);
 80019f0:	2304      	movs	r3, #4
 80019f2:	6033      	str	r3, [r6, #0]
 80019f4:	6a6c      	ldr	r4, [r5, #36]	; 0x24
  {
    time = chVTGetSystemTimeX();
    chThdSleepSeconds(1);
 80019f6:	f242 7010 	movw	r0, #10000	; 0x2710
 80019fa:	f003 ff59 	bl	80058b0 <chThdSleep>
    test_assert_time_window(time + S2ST(1),
 80019fe:	f504 501c 	add.w	r0, r4, #9984	; 0x2700
 8001a02:	4601      	mov	r1, r0
 8001a04:	3113      	adds	r1, #19
 8001a06:	3010      	adds	r0, #16
 8001a08:	f004 fb7a 	bl	8006100 <_test_assert_time_window.constprop.2>
 8001a0c:	2800      	cmp	r0, #0
 8001a0e:	d1d0      	bne.n	80019b2 <test_002_001_execute.lto_priv.96+0x22>
                            "out of time window");
  }

  /* [2.1.5] Function chThdSleepUntil() is tested with a timeline of
     "now" + 100 ticks.*/
  test_set_step(5);
 8001a10:	2305      	movs	r3, #5
 8001a12:	6033      	str	r3, [r6, #0]
 8001a14:	6a6e      	ldr	r6, [r5, #36]	; 0x24
 8001a16:	2320      	movs	r3, #32
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
 8001a18:	f106 0464 	add.w	r4, r6, #100	; 0x64
 8001a1c:	f383 8811 	msr	BASEPRI, r3
 8001a20:	6a69      	ldr	r1, [r5, #36]	; 0x24
 */
void chThdSleepUntil(systime_t time) {

  chSysLock();
  time -= chVTGetSystemTimeX();
  if (time > (systime_t)0) {
 8001a22:	1a61      	subs	r1, r4, r1
 8001a24:	d002      	beq.n	8001a2c <test_002_001_execute.lto_priv.96+0x9c>
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8001a26:	2008      	movs	r0, #8
 8001a28:	f003 fee2 	bl	80057f0 <chSchGoSleepTimeoutS>
 8001a2c:	2300      	movs	r3, #0
 8001a2e:	f383 8811 	msr	BASEPRI, r3
    test_assert_time_window(time + 100,
 8001a32:	4620      	mov	r0, r4
 8001a34:	f106 0167 	add.w	r1, r6, #103	; 0x67
                            time + 100 + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
  }
}
 8001a38:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
     "now" + 100 ticks.*/
  test_set_step(5);
  {
    time = chVTGetSystemTimeX();
    chThdSleepUntil(time + 100);
    test_assert_time_window(time + 100,
 8001a3c:	f004 bb60 	b.w	8006100 <_test_assert_time_window.constprop.2>
 8001a40:	2000133c 	.word	0x2000133c
 8001a44:	f3af 8000 	nop.w
 8001a48:	f3af 8000 	nop.w
 8001a4c:	f3af 8000 	nop.w

08001a50 <test_004_003_execute.lto_priv.108>:

static void test_004_003_setup(void) {
  chSemObjectInit(&sem1, 0);
}

static void test_004_003_execute(void) {
 8001a50:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  systime_t target_time;
  msg_t msg;

  /* [4.3.1] Testing special case TIME_IMMEDIATE.*/
  test_set_step(1);
 8001a52:	4d53      	ldr	r5, [pc, #332]	; (8001ba0 <test_004_003_execute.lto_priv.108+0x150>)
 8001a54:	2301      	movs	r3, #1
 8001a56:	602b      	str	r3, [r5, #0]
 8001a58:	2620      	movs	r6, #32
 8001a5a:	f386 8811 	msr	BASEPRI, r6
 */
msg_t chSemWaitTimeout(semaphore_t *sp, systime_t time) {
  msg_t msg;

  chSysLock();
  msg = chSemWaitTimeoutS(sp, time);
 8001a5e:	4c51      	ldr	r4, [pc, #324]	; (8001ba4 <test_004_003_execute.lto_priv.108+0x154>)
 8001a60:	2100      	movs	r1, #0
 8001a62:	4620      	mov	r0, r4
 8001a64:	f003 feec 	bl	8005840 <chSemWaitTimeoutS>
 8001a68:	2300      	movs	r3, #0
 8001a6a:	f383 8811 	msr	BASEPRI, r3
  {
    msg = chSemWaitTimeout(&sem1, TIME_IMMEDIATE);
    test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8001a6e:	494e      	ldr	r1, [pc, #312]	; (8001ba8 <test_004_003_execute.lto_priv.108+0x158>)
 8001a70:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8001a74:	fab0 f080 	clz	r0, r0
 8001a78:	0940      	lsrs	r0, r0, #5
 8001a7a:	f002 fa21 	bl	8003ec0 <_test_assert>
 8001a7e:	b100      	cbz	r0, 8001a82 <test_004_003_execute.lto_priv.108+0x32>
 8001a80:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8001a82:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001a84:	4949      	ldr	r1, [pc, #292]	; (8001bac <test_004_003_execute.lto_priv.108+0x15c>)
 8001a86:	1b00      	subs	r0, r0, r4
 8001a88:	fab0 f080 	clz	r0, r0
 8001a8c:	0940      	lsrs	r0, r0, #5
 8001a8e:	f002 fa17 	bl	8003ec0 <_test_assert>
 8001a92:	2800      	cmp	r0, #0
 8001a94:	d1f4      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 8001a96:	68a0      	ldr	r0, [r4, #8]
 8001a98:	4945      	ldr	r1, [pc, #276]	; (8001bb0 <test_004_003_execute.lto_priv.108+0x160>)
 8001a9a:	fab0 f080 	clz	r0, r0
 8001a9e:	0940      	lsrs	r0, r0, #5
 8001aa0:	f002 fa0e 	bl	8003ec0 <_test_assert>
 8001aa4:	4607      	mov	r7, r0
 8001aa6:	2800      	cmp	r0, #0
 8001aa8:	d1ea      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001aaa:	4b42      	ldr	r3, [pc, #264]	; (8001bb4 <test_004_003_execute.lto_priv.108+0x164>)
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001aac:	4a42      	ldr	r2, [pc, #264]	; (8001bb8 <test_004_003_execute.lto_priv.108+0x168>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001aae:	699b      	ldr	r3, [r3, #24]
 8001ab0:	4842      	ldr	r0, [pc, #264]	; (8001bbc <test_004_003_execute.lto_priv.108+0x16c>)
 8001ab2:	6899      	ldr	r1, [r3, #8]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8001ab4:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001ab8:	463b      	mov	r3, r7
 8001aba:	3901      	subs	r1, #1
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
    test_assert(sem1.cnt == 0, "counter not zero");
  }

  /* [4.3.2] Testing non-timeout condition.*/
  test_set_step(2);
 8001abc:	f8c5 e000 	str.w	lr, [r5]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8001ac0:	f003 ffd6 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001ac4:	4b3e      	ldr	r3, [pc, #248]	; (8001bc0 <test_004_003_execute.lto_priv.108+0x170>)
 8001ac6:	6018      	str	r0, [r3, #0]
 8001ac8:	f386 8811 	msr	BASEPRI, r6
 8001acc:	f241 3188 	movw	r1, #5000	; 0x1388
 8001ad0:	4620      	mov	r0, r4
 8001ad2:	f003 feb5 	bl	8005840 <chSemWaitTimeoutS>
 8001ad6:	4606      	mov	r6, r0
 8001ad8:	f387 8811 	msr	BASEPRI, r7
                                   thread2, 0);
    msg = chSemWaitTimeout(&sem1, MS2ST(500));
    test_wait_threads();
 8001adc:	f002 f918 	bl	8003d10 <test_wait_threads>
    test_assert(msg == MSG_OK, "wrong wake-up message");
 8001ae0:	fab6 f086 	clz	r0, r6
 8001ae4:	4930      	ldr	r1, [pc, #192]	; (8001ba8 <test_004_003_execute.lto_priv.108+0x158>)
 8001ae6:	0940      	lsrs	r0, r0, #5
 8001ae8:	f002 f9ea 	bl	8003ec0 <_test_assert>
 8001aec:	2800      	cmp	r0, #0
 8001aee:	d1c7      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
 8001af0:	6820      	ldr	r0, [r4, #0]
    test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001af2:	492e      	ldr	r1, [pc, #184]	; (8001bac <test_004_003_execute.lto_priv.108+0x15c>)
 8001af4:	1b00      	subs	r0, r0, r4
 8001af6:	fab0 f080 	clz	r0, r0
 8001afa:	0940      	lsrs	r0, r0, #5
 8001afc:	f002 f9e0 	bl	8003ec0 <_test_assert>
 8001b00:	2800      	cmp	r0, #0
 8001b02:	d1bd      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
    test_assert(sem1.cnt == 0, "counter not zero");
 8001b04:	68a0      	ldr	r0, [r4, #8]
 8001b06:	492a      	ldr	r1, [pc, #168]	; (8001bb0 <test_004_003_execute.lto_priv.108+0x160>)
 8001b08:	fab0 f080 	clz	r0, r0
 8001b0c:	0940      	lsrs	r0, r0, #5
 8001b0e:	f002 f9d7 	bl	8003ec0 <_test_assert>
 8001b12:	2800      	cmp	r0, #0
 8001b14:	d1b4      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
  }

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
 8001b16:	2303      	movs	r3, #3
 8001b18:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
 8001b1a:	f002 f8e9 	bl	8003cf0 <test_wait_tick>
 8001b1e:	2541      	movs	r5, #65	; 0x41
 8001b20:	4606      	mov	r6, r0
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
 8001b22:	4628      	mov	r0, r5
 8001b24:	f002 f92c 	bl	8003d80 <test_emit_token>
 8001b28:	2320      	movs	r3, #32
 8001b2a:	f383 8811 	msr	BASEPRI, r3
 8001b2e:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 8001b32:	481c      	ldr	r0, [pc, #112]	; (8001ba4 <test_004_003_execute.lto_priv.108+0x154>)
 8001b34:	f003 fe84 	bl	8005840 <chSemWaitTimeoutS>
 8001b38:	2300      	movs	r3, #0
 8001b3a:	f383 8811 	msr	BASEPRI, r3
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8001b3e:	491a      	ldr	r1, [pc, #104]	; (8001ba8 <test_004_003_execute.lto_priv.108+0x158>)
 8001b40:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8001b44:	fab0 f080 	clz	r0, r0
 8001b48:	0940      	lsrs	r0, r0, #5
 8001b4a:	f002 f9b9 	bl	8003ec0 <_test_assert>
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001b4e:	4917      	ldr	r1, [pc, #92]	; (8001bac <test_004_003_execute.lto_priv.108+0x15c>)
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
 8001b50:	2800      	cmp	r0, #0
 8001b52:	d195      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
 8001b54:	6820      	ldr	r0, [r4, #0]
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001b56:	1b00      	subs	r0, r0, r4
 8001b58:	fab0 f080 	clz	r0, r0
 8001b5c:	0940      	lsrs	r0, r0, #5
 8001b5e:	f002 f9af 	bl	8003ec0 <_test_assert>
      test_assert(sem1.cnt == 0, "counter not zero");
 8001b62:	4913      	ldr	r1, [pc, #76]	; (8001bb0 <test_004_003_execute.lto_priv.108+0x160>)
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
      test_emit_token('A' + i);
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
 8001b64:	2800      	cmp	r0, #0
 8001b66:	d18b      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>
      test_assert(sem1.cnt == 0, "counter not zero");
 8001b68:	68a0      	ldr	r0, [r4, #8]
 8001b6a:	fab0 f080 	clz	r0, r0
 8001b6e:	0940      	lsrs	r0, r0, #5
 8001b70:	f002 f9a6 	bl	8003ec0 <_test_assert>
 8001b74:	3501      	adds	r5, #1
 8001b76:	b2ed      	uxtb	r5, r5
 8001b78:	2800      	cmp	r0, #0
 8001b7a:	d181      	bne.n	8001a80 <test_004_003_execute.lto_priv.108+0x30>

  /* [4.3.3] Testing timeout condition.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(5 * 50);
    for (i = 0; i < 5; i++) {
 8001b7c:	2d46      	cmp	r5, #70	; 0x46
 8001b7e:	d1d0      	bne.n	8001b22 <test_004_003_execute.lto_priv.108+0xd2>
      msg = chSemWaitTimeout(&sem1, MS2ST(50));
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
 8001b80:	4810      	ldr	r0, [pc, #64]	; (8001bc4 <test_004_003_execute.lto_priv.108+0x174>)
 8001b82:	4911      	ldr	r1, [pc, #68]	; (8001bc8 <test_004_003_execute.lto_priv.108+0x178>)
 8001b84:	f002 f974 	bl	8003e70 <_test_assert_sequence>
 8001b88:	2800      	cmp	r0, #0
 8001b8a:	f47f af79 	bne.w	8001a80 <test_004_003_execute.lto_priv.108+0x30>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001b8e:	f606 10c4 	addw	r0, r6, #2500	; 0x9c4
 8001b92:	f606 11d8 	addw	r1, r6, #2520	; 0x9d8
                            "out of time window");
  }
}
 8001b96:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      test_assert(msg == MSG_TIMEOUT, "wrong wake-up message");
      test_assert(queue_isempty(&sem1.queue), "queue not empty");
      test_assert(sem1.cnt == 0, "counter not zero");
    }
    test_assert_sequence("ABCDE", "invalid sequence");
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8001b9a:	f004 bab1 	b.w	8006100 <_test_assert_time_window.constprop.2>
 8001b9e:	bf00      	nop
 8001ba0:	2000133c 	.word	0x2000133c
 8001ba4:	20001460 	.word	0x20001460
 8001ba8:	08006f74 	.word	0x08006f74
 8001bac:	08006ee8 	.word	0x08006ee8
 8001bb0:	08006ef8 	.word	0x08006ef8
 8001bb4:	200013b0 	.word	0x200013b0
 8001bb8:	08001961 	.word	0x08001961
 8001bbc:	20000c50 	.word	0x20000c50
 8001bc0:	20001340 	.word	0x20001340
 8001bc4:	08006f48 	.word	0x08006f48
 8001bc8:	08006f50 	.word	0x08006f50
 8001bcc:	f3af 8000 	nop.w

08001bd0 <test_003_001_execute.lto_priv.101>:

static void test_003_001_setup(void) {
  tr1 = NULL;
}

static void test_003_001_execute(void) {
 8001bd0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001bd4:	4d30      	ldr	r5, [pc, #192]	; (8001c98 <test_003_001_execute.lto_priv.101+0xc8>)
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8001bd6:	4f31      	ldr	r7, [pc, #196]	; (8001c9c <test_003_001_execute.lto_priv.101+0xcc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001bd8:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8001bda:	4a31      	ldr	r2, [pc, #196]	; (8001ca0 <test_003_001_execute.lto_priv.101+0xd0>)
 8001bdc:	6899      	ldr	r1, [r3, #8]
 8001bde:	4831      	ldr	r0, [pc, #196]	; (8001ca4 <test_003_001_execute.lto_priv.101+0xd4>)
 8001be0:	4b31      	ldr	r3, [pc, #196]	; (8001ca8 <test_003_001_execute.lto_priv.101+0xd8>)
 8001be2:	3901      	subs	r1, #1
  msg_t msg;

  /* [3.1.1] The function chThdSuspendTimeoutS() is invoked, the thread
     is remotely resumed with message @p MSG_OK. On return the message
     and the state of the reference are tested.*/
  test_set_step(1);
 8001be4:	2401      	movs	r4, #1
 8001be6:	603c      	str	r4, [r7, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, thread1, "A");
 8001be8:	f003 ff42 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8001bec:	4b2f      	ldr	r3, [pc, #188]	; (8001cac <test_003_001_execute.lto_priv.101+0xdc>)
 8001bee:	2620      	movs	r6, #32
 8001bf0:	6018      	str	r0, [r3, #0]
 8001bf2:	f386 8811 	msr	BASEPRI, r6
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001bf6:	69ab      	ldr	r3, [r5, #24]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001bf8:	4c2d      	ldr	r4, [pc, #180]	; (8001cb0 <test_003_001_execute.lto_priv.101+0xe0>)
  tp->u.wttrp = trp;
 8001bfa:	625c      	str	r4, [r3, #36]	; 0x24
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8001bfc:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001bfe:	6023      	str	r3, [r4, #0]
 8001c00:	f003 fbce 	bl	80053a0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8001c04:	69aa      	ldr	r2, [r5, #24]
 8001c06:	2300      	movs	r3, #0
 8001c08:	f8d2 8024 	ldr.w	r8, [r2, #36]	; 0x24
 8001c0c:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg = chThdSuspendTimeoutS(&tr1, TIME_INFINITE);
    chSysUnlock();
    test_assert(NULL == tr1, "not NULL");
 8001c10:	4928      	ldr	r1, [pc, #160]	; (8001cb4 <test_003_001_execute.lto_priv.101+0xe4>)
 8001c12:	6820      	ldr	r0, [r4, #0]
 8001c14:	fab0 f080 	clz	r0, r0
 8001c18:	0940      	lsrs	r0, r0, #5
 8001c1a:	f002 f951 	bl	8003ec0 <_test_assert>
 8001c1e:	b108      	cbz	r0, 8001c24 <test_003_001_execute.lto_priv.101+0x54>
 8001c20:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(MSG_OK == msg,"wrong returned message");
 8001c24:	fab8 f088 	clz	r0, r8
 8001c28:	4923      	ldr	r1, [pc, #140]	; (8001cb8 <test_003_001_execute.lto_priv.101+0xe8>)
 8001c2a:	0940      	lsrs	r0, r0, #5
 8001c2c:	f002 f948 	bl	8003ec0 <_test_assert>
 8001c30:	4680      	mov	r8, r0
 8001c32:	2800      	cmp	r0, #0
 8001c34:	d1f4      	bne.n	8001c20 <test_003_001_execute.lto_priv.101+0x50>
    test_wait_threads();
 8001c36:	f002 f86b 	bl	8003d10 <test_wait_threads>
  }

  /* [3.1.2] The function chThdSuspendTimeoutS() is invoked, the thread
     is not resumed so a timeout must occur. On return the message and
     the state of the reference are tested.*/
  test_set_step(2);
 8001c3a:	2302      	movs	r3, #2
 8001c3c:	603b      	str	r3, [r7, #0]
 8001c3e:	f386 8811 	msr	BASEPRI, r6
 8001c42:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8001c46:	69ab      	ldr	r3, [r5, #24]
 8001c48:	6a55      	ldr	r5, [r2, #36]	; 0x24
  tp->u.wttrp = trp;
 8001c4a:	625c      	str	r4, [r3, #36]	; 0x24

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001c4c:	f242 7110 	movw	r1, #10000	; 0x2710
 8001c50:	2003      	movs	r0, #3

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8001c52:	6023      	str	r3, [r4, #0]
  tp->u.wttrp = trp;

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 8001c54:	f003 fdcc 	bl	80057f0 <chSchGoSleepTimeoutS>
 8001c58:	4606      	mov	r6, r0
 8001c5a:	f388 8811 	msr	BASEPRI, r8
  {
    chSysLock();
    time = chVTGetSystemTimeX();
    msg = chThdSuspendTimeoutS(&tr1, MS2ST(1000));
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
 8001c5e:	f505 501c 	add.w	r0, r5, #9984	; 0x2700
 8001c62:	4601      	mov	r1, r0
 8001c64:	3113      	adds	r1, #19
 8001c66:	3010      	adds	r0, #16
 8001c68:	f004 fa4a 	bl	8006100 <_test_assert_time_window.constprop.2>
 8001c6c:	2800      	cmp	r0, #0
 8001c6e:	d1d7      	bne.n	8001c20 <test_003_001_execute.lto_priv.101+0x50>
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
 8001c70:	6820      	ldr	r0, [r4, #0]
 8001c72:	4910      	ldr	r1, [pc, #64]	; (8001cb4 <test_003_001_execute.lto_priv.101+0xe4>)
 8001c74:	fab0 f080 	clz	r0, r0
 8001c78:	0940      	lsrs	r0, r0, #5
 8001c7a:	f002 f921 	bl	8003ec0 <_test_assert>
 8001c7e:	2800      	cmp	r0, #0
 8001c80:	d1ce      	bne.n	8001c20 <test_003_001_execute.lto_priv.101+0x50>
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8001c82:	f1a6 30ff 	sub.w	r0, r6, #4294967295
 8001c86:	490c      	ldr	r1, [pc, #48]	; (8001cb8 <test_003_001_execute.lto_priv.101+0xe8>)
 8001c88:	fab0 f080 	clz	r0, r0
  }
}
 8001c8c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chSysUnlock();
    test_assert_time_window(time + MS2ST(1000),
                            time + MS2ST(1000) + CH_CFG_ST_TIMEDELTA + 1,
                            "out of time window");
    test_assert(NULL == tr1, "not NULL");
    test_assert(MSG_TIMEOUT == msg, "wrong returned message");
 8001c90:	0940      	lsrs	r0, r0, #5
 8001c92:	f002 b915 	b.w	8003ec0 <_test_assert>
 8001c96:	bf00      	nop
 8001c98:	200013b0 	.word	0x200013b0
 8001c9c:	2000133c 	.word	0x2000133c
 8001ca0:	08001921 	.word	0x08001921
 8001ca4:	20000c50 	.word	0x20000c50
 8001ca8:	08006f38 	.word	0x08006f38
 8001cac:	20001340 	.word	0x20001340
 8001cb0:	2000137c 	.word	0x2000137c
 8001cb4:	08006f8c 	.word	0x08006f8c
 8001cb8:	08006f20 	.word	0x08006f20
 8001cbc:	f3af 8000 	nop.w

08001cc0 <test_002_004_execute.lto_priv.99>:
 * - [2.4.3] Raising thread priority above the boosted level.
 * - [2.4.4] Restoring original conditions.
 * .
 */

static void test_002_004_execute(void) {
 8001cc0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001cc4:	4d2f      	ldr	r5, [pc, #188]	; (8001d84 <test_002_004_execute.lto_priv.99+0xc4>)
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001cc6:	f8df 80d0 	ldr.w	r8, [pc, #208]	; 8001d98 <test_002_004_execute.lto_priv.99+0xd8>
 8001cca:	69ab      	ldr	r3, [r5, #24]
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001ccc:	689c      	ldr	r4, [r3, #8]

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8001cce:	1ca6      	adds	r6, r4, #2

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8001cd0:	1c67      	adds	r7, r4, #1

  /* [2.4.1] Simulating a priority boost situation (prio > realprio).*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    chThdGetSelfX()->prio += 2;
 8001cd2:	609e      	str	r6, [r3, #8]

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(prio + 1);
 8001cd4:	4638      	mov	r0, r7
    test_assert(chThdGetPriorityX() == prio + 2, "unexpected priority level");
  }

  /* [2.4.2] Raising thread priority above original priority but below
     the boosted level.*/
  test_set_step(2);
 8001cd6:	2302      	movs	r3, #2
 8001cd8:	f8c8 3000 	str.w	r3, [r8]
  {
    p1 = chThdSetPriority(prio + 1);
 8001cdc:	f003 faf8 	bl	80052d0 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8001ce0:	4929      	ldr	r1, [pc, #164]	; (8001d88 <test_002_004_execute.lto_priv.99+0xc8>)
 8001ce2:	1b00      	subs	r0, r0, r4
 8001ce4:	fab0 f080 	clz	r0, r0
 8001ce8:	0940      	lsrs	r0, r0, #5
 8001cea:	f002 f8e9 	bl	8003ec0 <_test_assert>
 8001cee:	b108      	cbz	r0, 8001cf4 <test_002_004_execute.lto_priv.99+0x34>
 8001cf0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
 8001cf4:	69ab      	ldr	r3, [r5, #24]
 8001cf6:	4925      	ldr	r1, [pc, #148]	; (8001d8c <test_002_004_execute.lto_priv.99+0xcc>)
 8001cf8:	6898      	ldr	r0, [r3, #8]
 8001cfa:	1a30      	subs	r0, r6, r0
 8001cfc:	fab0 f080 	clz	r0, r0
 8001d00:	0940      	lsrs	r0, r0, #5
 8001d02:	f002 f8dd 	bl	8003ec0 <_test_assert>
 8001d06:	2800      	cmp	r0, #0
 8001d08:	d1f2      	bne.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
 8001d0a:	69ab      	ldr	r3, [r5, #24]
 8001d0c:	4920      	ldr	r1, [pc, #128]	; (8001d90 <test_002_004_execute.lto_priv.99+0xd0>)
 8001d0e:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001d10:	1a38      	subs	r0, r7, r0
 8001d12:	fab0 f080 	clz	r0, r0
 8001d16:	0940      	lsrs	r0, r0, #5
 8001d18:	f002 f8d2 	bl	8003ec0 <_test_assert>
 8001d1c:	2800      	cmp	r0, #0
 8001d1e:	d1e7      	bne.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
  {
    p1 = chThdSetPriority(prio + 3);
 8001d20:	1ce6      	adds	r6, r4, #3
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8001d22:	2303      	movs	r3, #3
  {
    p1 = chThdSetPriority(prio + 3);
 8001d24:	4630      	mov	r0, r6
    test_assert(chThdGetSelfX()->prio == prio + 2, "unexpected priority level");
    test_assert(chThdGetSelfX()->realprio == prio + 1, "unexpected returned real priority level");
  }

  /* [2.4.3] Raising thread priority above the boosted level.*/
  test_set_step(3);
 8001d26:	f8c8 3000 	str.w	r3, [r8]
  {
    p1 = chThdSetPriority(prio + 3);
 8001d2a:	f003 fad1 	bl	80052d0 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001d2e:	4916      	ldr	r1, [pc, #88]	; (8001d88 <test_002_004_execute.lto_priv.99+0xc8>)
 8001d30:	1a38      	subs	r0, r7, r0
 8001d32:	fab0 f080 	clz	r0, r0
 8001d36:	0940      	lsrs	r0, r0, #5
 8001d38:	f002 f8c2 	bl	8003ec0 <_test_assert>
 8001d3c:	2800      	cmp	r0, #0
 8001d3e:	d1d7      	bne.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
    test_assert(chThdGetSelfX()->prio == prio + 3, "unexpected priority level");
 8001d40:	69ab      	ldr	r3, [r5, #24]
 8001d42:	4912      	ldr	r1, [pc, #72]	; (8001d8c <test_002_004_execute.lto_priv.99+0xcc>)
 8001d44:	6898      	ldr	r0, [r3, #8]
 8001d46:	1a30      	subs	r0, r6, r0
 8001d48:	fab0 f080 	clz	r0, r0
 8001d4c:	0940      	lsrs	r0, r0, #5
 8001d4e:	f002 f8b7 	bl	8003ec0 <_test_assert>
 8001d52:	2800      	cmp	r0, #0
 8001d54:	d1cc      	bne.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
    test_assert(chThdGetSelfX()->realprio == prio + 3, "unexpected real priority level");
 8001d56:	69ab      	ldr	r3, [r5, #24]
 8001d58:	490e      	ldr	r1, [pc, #56]	; (8001d94 <test_002_004_execute.lto_priv.99+0xd4>)
 8001d5a:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 8001d5c:	1a30      	subs	r0, r6, r0
 8001d5e:	fab0 f080 	clz	r0, r0
 8001d62:	0940      	lsrs	r0, r0, #5
 8001d64:	f002 f8ac 	bl	8003ec0 <_test_assert>
 8001d68:	2800      	cmp	r0, #0
 8001d6a:	d1c1      	bne.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
  }

  /* [2.4.4] Restoring original conditions.*/
  test_set_step(4);
 8001d6c:	2304      	movs	r3, #4
 8001d6e:	f8c8 3000 	str.w	r3, [r8]
 8001d72:	2320      	movs	r3, #32
 8001d74:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8001d78:	69ab      	ldr	r3, [r5, #24]
  {
    chSysLock();
    chThdGetSelfX()->prio = prio;
 8001d7a:	609c      	str	r4, [r3, #8]
    chThdGetSelfX()->realprio = prio;
 8001d7c:	63dc      	str	r4, [r3, #60]	; 0x3c
 8001d7e:	f380 8811 	msr	BASEPRI, r0
 8001d82:	e7b5      	b.n	8001cf0 <test_002_004_execute.lto_priv.99+0x30>
 8001d84:	200013b0 	.word	0x200013b0
 8001d88:	08006f98 	.word	0x08006f98
 8001d8c:	08006fbc 	.word	0x08006fbc
 8001d90:	08006fd8 	.word	0x08006fd8
 8001d94:	08007000 	.word	0x08007000
 8001d98:	2000133c 	.word	0x2000133c
 8001d9c:	f3af 8000 	nop.w

08001da0 <test_002_003_execute.lto_priv.98>:
 * - [2.3.2] Thread priority is returned to the previous value then a
 *   check is performed.
 * .
 */

static void test_002_003_execute(void) {
 8001da0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001da4:	4e1c      	ldr	r6, [pc, #112]	; (8001e18 <test_002_003_execute.lto_priv.98+0x78>)
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001da6:	4f1d      	ldr	r7, [pc, #116]	; (8001e1c <test_002_003_execute.lto_priv.98+0x7c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8001da8:	69b3      	ldr	r3, [r6, #24]
 8001daa:	689c      	ldr	r4, [r3, #8]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8001dac:	1c65      	adds	r5, r4, #1
static void test_002_003_execute(void) {
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001dae:	2301      	movs	r3, #1
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8001db0:	4628      	mov	r0, r5
static void test_002_003_execute(void) {
  tprio_t prio, p1;

  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
 8001db2:	603b      	str	r3, [r7, #0]
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8001db4:	f003 fa8c 	bl	80052d0 <chThdSetPriority>
    test_assert(p1 == prio, "unexpected returned priority level");
 8001db8:	4919      	ldr	r1, [pc, #100]	; (8001e20 <test_002_003_execute.lto_priv.98+0x80>)
  /* [2.3.1] Thread priority is increased by one then a check is
     performed.*/
  test_set_step(1);
  {
    prio = chThdGetPriorityX();
    p1 = chThdSetPriority(prio + 1);
 8001dba:	4680      	mov	r8, r0
    test_assert(p1 == prio, "unexpected returned priority level");
 8001dbc:	1b00      	subs	r0, r0, r4
 8001dbe:	fab0 f080 	clz	r0, r0
 8001dc2:	0940      	lsrs	r0, r0, #5
 8001dc4:	f002 f87c 	bl	8003ec0 <_test_assert>
 8001dc8:	b108      	cbz	r0, 8001dce <test_002_003_execute.lto_priv.98+0x2e>
 8001dca:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8001dce:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
 8001dd0:	4914      	ldr	r1, [pc, #80]	; (8001e24 <test_002_003_execute.lto_priv.98+0x84>)
 8001dd2:	6898      	ldr	r0, [r3, #8]
 8001dd4:	1a28      	subs	r0, r5, r0
 8001dd6:	fab0 f080 	clz	r0, r0
 8001dda:	0940      	lsrs	r0, r0, #5
 8001ddc:	f002 f870 	bl	8003ec0 <_test_assert>
 8001de0:	2800      	cmp	r0, #0
 8001de2:	d1f2      	bne.n	8001dca <test_002_003_execute.lto_priv.98+0x2a>
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8001de4:	2302      	movs	r3, #2
  {
    p1 = chThdSetPriority(p1);
 8001de6:	4640      	mov	r0, r8
    test_assert(chThdGetPriorityX() == prio + 1, "unexpected priority level");
  }

  /* [2.3.2] Thread priority is returned to the previous value then a
     check is performed.*/
  test_set_step(2);
 8001de8:	603b      	str	r3, [r7, #0]
  {
    p1 = chThdSetPriority(p1);
 8001dea:	f003 fa71 	bl	80052d0 <chThdSetPriority>
    test_assert(p1 == prio + 1, "unexpected returned priority level");
 8001dee:	490c      	ldr	r1, [pc, #48]	; (8001e20 <test_002_003_execute.lto_priv.98+0x80>)
 8001df0:	1a28      	subs	r0, r5, r0
 8001df2:	fab0 f080 	clz	r0, r0
 8001df6:	0940      	lsrs	r0, r0, #5
 8001df8:	f002 f862 	bl	8003ec0 <_test_assert>
 8001dfc:	2800      	cmp	r0, #0
 8001dfe:	d1e4      	bne.n	8001dca <test_002_003_execute.lto_priv.98+0x2a>
 8001e00:	69b3      	ldr	r3, [r6, #24]
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8001e02:	4908      	ldr	r1, [pc, #32]	; (8001e24 <test_002_003_execute.lto_priv.98+0x84>)
 8001e04:	6898      	ldr	r0, [r3, #8]
 8001e06:	1a20      	subs	r0, r4, r0
  }
}
 8001e08:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
     check is performed.*/
  test_set_step(2);
  {
    p1 = chThdSetPriority(p1);
    test_assert(p1 == prio + 1, "unexpected returned priority level");
    test_assert(chThdGetPriorityX() == prio, "unexpected priority level");
 8001e0c:	fab0 f080 	clz	r0, r0
 8001e10:	0940      	lsrs	r0, r0, #5
 8001e12:	f002 b855 	b.w	8003ec0 <_test_assert>
 8001e16:	bf00      	nop
 8001e18:	200013b0 	.word	0x200013b0
 8001e1c:	2000133c 	.word	0x2000133c
 8001e20:	08006f98 	.word	0x08006f98
 8001e24:	08006fbc 	.word	0x08006fbc
 8001e28:	f3af 8000 	nop.w
 8001e2c:	f3af 8000 	nop.w

08001e30 <test_009_001_setup.lto_priv.152>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8001e30:	4b03      	ldr	r3, [pc, #12]	; (8001e40 <test_009_001_setup.lto_priv.152+0x10>)
 8001e32:	2200      	movs	r2, #0
  mp->object_size = size;
 8001e34:	2104      	movs	r1, #4
 8001e36:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8001e38:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 8001e3a:	609a      	str	r2, [r3, #8]
 8001e3c:	4770      	bx	lr
 8001e3e:	bf00      	nop
 8001e40:	2000084c 	.word	0x2000084c
 8001e44:	f3af 8000 	nop.w
 8001e48:	f3af 8000 	nop.w
 8001e4c:	f3af 8000 	nop.w

08001e50 <null_provider.lto_priv.174>:

  (void)size;
  (void)align;

  return NULL;
}
 8001e50:	2000      	movs	r0, #0
 8001e52:	4770      	bx	lr
 8001e54:	f3af 8000 	nop.w
 8001e58:	f3af 8000 	nop.w
 8001e5c:	f3af 8000 	nop.w

08001e60 <test_008_003_setup.lto_priv.149>:
 * - [8.3.3] Resetting the mailbox.
 * - [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.
 * .
 */

static void test_008_003_setup(void) {
 8001e60:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8001e62:	4b0b      	ldr	r3, [pc, #44]	; (8001e90 <test_008_003_setup.lto_priv.149+0x30>)
 8001e64:	4a0b      	ldr	r2, [pc, #44]	; (8001e94 <test_008_003_setup.lto_priv.149+0x34>)
 8001e66:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8001e68:	f102 0610 	add.w	r6, r2, #16
void chSemObjectInit(semaphore_t *sp, cnt_t n) {

  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));

  queue_init(&sp->queue);
  sp->cnt = n;
 8001e6c:	2504      	movs	r5, #4
 8001e6e:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e70:	f103 001c 	add.w	r0, r3, #28
 8001e74:	f103 0110 	add.w	r1, r3, #16
 8001e78:	605e      	str	r6, [r3, #4]
 8001e7a:	625d      	str	r5, [r3, #36]	; 0x24
 8001e7c:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 8001e7e:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8001e80:	609a      	str	r2, [r3, #8]
 8001e82:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8001e84:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001e86:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001e88:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8001e8a:	bc70      	pop	{r4, r5, r6}
 8001e8c:	4770      	bx	lr
 8001e8e:	bf00      	nop
 8001e90:	20000860 	.word	0x20000860
 8001e94:	20001450 	.word	0x20001450
 8001e98:	f3af 8000 	nop.w
 8001e9c:	f3af 8000 	nop.w

08001ea0 <test_008_002_setup.lto_priv.146>:
 * - [8.2.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_008_002_setup(void) {
 8001ea0:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8001ea2:	4b0b      	ldr	r3, [pc, #44]	; (8001ed0 <test_008_002_setup.lto_priv.146+0x30>)
 8001ea4:	4a0b      	ldr	r2, [pc, #44]	; (8001ed4 <test_008_002_setup.lto_priv.146+0x34>)
 8001ea6:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8001ea8:	f102 0610 	add.w	r6, r2, #16
 8001eac:	2504      	movs	r5, #4
 8001eae:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001eb0:	f103 001c 	add.w	r0, r3, #28
 8001eb4:	f103 0110 	add.w	r1, r3, #16
 8001eb8:	605e      	str	r6, [r3, #4]
 8001eba:	625d      	str	r5, [r3, #36]	; 0x24
 8001ebc:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 8001ebe:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8001ec0:	609a      	str	r2, [r3, #8]
 8001ec2:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8001ec4:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ec6:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001ec8:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8001eca:	bc70      	pop	{r4, r5, r6}
 8001ecc:	4770      	bx	lr
 8001ece:	bf00      	nop
 8001ed0:	20000860 	.word	0x20000860
 8001ed4:	20001450 	.word	0x20001450
 8001ed8:	f3af 8000 	nop.w
 8001edc:	f3af 8000 	nop.w

08001ee0 <test_008_001_setup.lto_priv.143>:
 * - [8.1.7] Testing final conditions. Data pointers must be aligned to
 *   buffer start, semaphore counters are checked.
 * .
 */

static void test_008_001_setup(void) {
 8001ee0:	b470      	push	{r4, r5, r6}
 */
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
 8001ee2:	4b0b      	ldr	r3, [pc, #44]	; (8001f10 <test_008_001_setup.lto_priv.143+0x30>)
 8001ee4:	4a0b      	ldr	r2, [pc, #44]	; (8001f14 <test_008_001_setup.lto_priv.143+0x34>)
 8001ee6:	601a      	str	r2, [r3, #0]
  mbp->rdptr = buf;
  mbp->wrptr = buf;
  mbp->top = &buf[n];
 8001ee8:	f102 0610 	add.w	r6, r2, #16
 8001eec:	2504      	movs	r5, #4
 8001eee:	2400      	movs	r4, #0
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001ef0:	f103 001c 	add.w	r0, r3, #28
 8001ef4:	f103 0110 	add.w	r1, r3, #16
 8001ef8:	605e      	str	r6, [r3, #4]
 8001efa:	625d      	str	r5, [r3, #36]	; 0x24
 8001efc:	619c      	str	r4, [r3, #24]
void chMBObjectInit(mailbox_t *mbp, msg_t *buf, cnt_t n) {

  chDbgCheck((mbp != NULL) && (buf != NULL) && (n > (cnt_t)0));

  mbp->buffer = buf;
  mbp->rdptr = buf;
 8001efe:	60da      	str	r2, [r3, #12]
  mbp->wrptr = buf;
 8001f00:	609a      	str	r2, [r3, #8]
 8001f02:	61d8      	str	r0, [r3, #28]
  tqp->prev = (thread_t *)tqp;
 8001f04:	6218      	str	r0, [r3, #32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8001f06:	6119      	str	r1, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8001f08:	6159      	str	r1, [r3, #20]
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}
 8001f0a:	bc70      	pop	{r4, r5, r6}
 8001f0c:	4770      	bx	lr
 8001f0e:	bf00      	nop
 8001f10:	20000860 	.word	0x20000860
 8001f14:	20001450 	.word	0x20001450
 8001f18:	f3af 8000 	nop.w
 8001f1c:	f3af 8000 	nop.w

08001f20 <test_008_003_teardown.lto_priv.150>:
static void test_008_003_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
 8001f20:	f003 bfde 	b.w	8005ee0 <chMBReset.constprop.29>
 8001f24:	f3af 8000 	nop.w
 8001f28:	f3af 8000 	nop.w
 8001f2c:	f3af 8000 	nop.w

08001f30 <test_008_002_teardown.lto_priv.147>:
static void test_008_002_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
 8001f30:	f003 bfd6 	b.w	8005ee0 <chMBReset.constprop.29>
 8001f34:	f3af 8000 	nop.w
 8001f38:	f3af 8000 	nop.w
 8001f3c:	f3af 8000 	nop.w

08001f40 <test_008_001_teardown.lto_priv.144>:
static void test_008_001_setup(void) {
  chMBObjectInit(&mb1, mb_buffer, MB_SIZE);
}

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
 8001f40:	f003 bfce 	b.w	8005ee0 <chMBReset.constprop.29>
 8001f44:	f3af 8000 	nop.w
 8001f48:	f3af 8000 	nop.w
 8001f4c:	f3af 8000 	nop.w

08001f50 <test_008_003_execute.lto_priv.151>:

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_003_execute(void) {
 8001f50:	b5f0      	push	{r4, r5, r6, r7, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 8001f52:	4d58      	ldr	r5, [pc, #352]	; (80020b4 <test_008_003_execute.lto_priv.151+0x164>)
 8001f54:	2301      	movs	r3, #1

static void test_008_003_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_003_execute(void) {
 8001f56:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
 8001f58:	602b      	str	r3, [r5, #0]
 8001f5a:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8001f5c:	4620      	mov	r0, r4
 8001f5e:	f04f 31ff 	mov.w	r1, #4294967295
 8001f62:	f003 ffcd 	bl	8005f00 <chMBPost.constprop.28>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8001f66:	4954      	ldr	r1, [pc, #336]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8001f68:	fab0 f080 	clz	r0, r0
 8001f6c:	0940      	lsrs	r0, r0, #5
 8001f6e:	f001 ffa7 	bl	8003ec0 <_test_assert>
 8001f72:	3401      	adds	r4, #1
 8001f74:	b988      	cbnz	r0, 8001f9a <test_008_003_execute.lto_priv.151+0x4a>
  unsigned i;

  /* [8.3.1] Filling the mailbox.*/
  test_set_step(1);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8001f76:	2c46      	cmp	r4, #70	; 0x46
 8001f78:	d1f0      	bne.n	8001f5c <test_008_003_execute.lto_priv.151+0xc>
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8001f7a:	2302      	movs	r3, #2
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8001f7c:	2101      	movs	r1, #1
 8001f7e:	2058      	movs	r0, #88	; 0x58
    }
  }

  /* [8.3.2] Testing chMBPost(), chMBPostI(), chMBPostAhead() and
     chMBPostAheadI() timeout.*/
  test_set_step(2);
 8001f80:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBPost(&mb1, 'X', 1);
 8001f82:	f003 ffbd 	bl	8005f00 <chMBPost.constprop.28>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8001f86:	494c      	ldr	r1, [pc, #304]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8001f88:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8001f8c:	fab0 f080 	clz	r0, r0
 8001f90:	0940      	lsrs	r0, r0, #5
 8001f92:	f001 ff95 	bl	8003ec0 <_test_assert>
 8001f96:	4604      	mov	r4, r0
 8001f98:	b108      	cbz	r0, 8001f9e <test_008_003_execute.lto_priv.151+0x4e>
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
  }
}
 8001f9a:	b003      	add	sp, #12
 8001f9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001f9e:	2320      	movs	r3, #32
 8001fa0:	f383 8811 	msr	BASEPRI, r3
 8001fa4:	4e45      	ldr	r6, [pc, #276]	; (80020bc <test_008_003_execute.lto_priv.151+0x16c>)
 8001fa6:	6a73      	ldr	r3, [r6, #36]	; 0x24
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8001fa8:	2b00      	cmp	r3, #0
 8001faa:	dd7c      	ble.n	80020a6 <test_008_003_execute.lto_priv.151+0x156>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001fac:	68b1      	ldr	r1, [r6, #8]
  if (mbp->wrptr >= mbp->top) {
 8001fae:	6870      	ldr	r0, [r6, #4]
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001fb0:	1d0a      	adds	r2, r1, #4
 */
static inline void chSemFastWaitI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt--;
 8001fb2:	3b01      	subs	r3, #1
  if (mbp->wrptr >= mbp->top) {
 8001fb4:	4282      	cmp	r2, r0
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001fb6:	f04f 0758 	mov.w	r7, #88	; 0x58
 8001fba:	6273      	str	r3, [r6, #36]	; 0x24
 8001fbc:	60b2      	str	r2, [r6, #8]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 8001fbe:	bf28      	it	cs
 8001fc0:	6833      	ldrcs	r3, [r6, #0]
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8001fc2:	600f      	str	r7, [r1, #0]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
  }
  chSemSignalI(&mbp->fullsem);
 8001fc4:	483e      	ldr	r0, [pc, #248]	; (80020c0 <test_008_003_execute.lto_priv.151+0x170>)
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 8001fc6:	bf28      	it	cs
 8001fc8:	60b3      	strcs	r3, [r6, #8]
  }
  chSemSignalI(&mbp->fullsem);
 8001fca:	f003 fb39 	bl	8005640 <chSemSignalI>
 8001fce:	2300      	movs	r3, #0
 8001fd0:	f383 8811 	msr	BASEPRI, r3
    msg1 = chMBPost(&mb1, 'X', 1);
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
    chSysLock();
    msg1 = chMBPostI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8001fd4:	4938      	ldr	r1, [pc, #224]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8001fd6:	4620      	mov	r0, r4
 8001fd8:	f001 ff72 	bl	8003ec0 <_test_assert>
 8001fdc:	2800      	cmp	r0, #0
 8001fde:	d1dc      	bne.n	8001f9a <test_008_003_execute.lto_priv.151+0x4a>
    msg1 = chMBPostAhead(&mb1, 'X', 1);
 8001fe0:	2101      	movs	r1, #1
 8001fe2:	2058      	movs	r0, #88	; 0x58
 8001fe4:	f003 ffb4 	bl	8005f50 <chMBPostAhead.constprop.26>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8001fe8:	4933      	ldr	r1, [pc, #204]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8001fea:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 8001fee:	fab0 f080 	clz	r0, r0
 8001ff2:	0940      	lsrs	r0, r0, #5
 8001ff4:	f001 ff64 	bl	8003ec0 <_test_assert>
 8001ff8:	4604      	mov	r4, r0
 8001ffa:	2800      	cmp	r0, #0
 8001ffc:	d1cd      	bne.n	8001f9a <test_008_003_execute.lto_priv.151+0x4a>
 8001ffe:	2320      	movs	r3, #32
 8002000:	f383 8811 	msr	BASEPRI, r3
 8002004:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8002006:	4a2d      	ldr	r2, [pc, #180]	; (80020bc <test_008_003_execute.lto_priv.151+0x16c>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002008:	2900      	cmp	r1, #0
 800200a:	dd4e      	ble.n	80020aa <test_008_003_execute.lto_priv.151+0x15a>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 800200c:	68d3      	ldr	r3, [r2, #12]
 800200e:	6810      	ldr	r0, [r2, #0]
 8002010:	3b04      	subs	r3, #4
 8002012:	3901      	subs	r1, #1
 8002014:	4283      	cmp	r3, r0
 8002016:	6251      	str	r1, [r2, #36]	; 0x24
 8002018:	60d3      	str	r3, [r2, #12]
 800201a:	d202      	bcs.n	8002022 <test_008_003_execute.lto_priv.151+0xd2>
    mbp->rdptr = mbp->top - 1;
 800201c:	6853      	ldr	r3, [r2, #4]
 800201e:	3b04      	subs	r3, #4
 8002020:	60d3      	str	r3, [r2, #12]
  }
  *mbp->rdptr = msg;
 8002022:	2258      	movs	r2, #88	; 0x58
 8002024:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 8002026:	4826      	ldr	r0, [pc, #152]	; (80020c0 <test_008_003_execute.lto_priv.151+0x170>)
 8002028:	f003 fb0a 	bl	8005640 <chSemSignalI>
 800202c:	2300      	movs	r3, #0
 800202e:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'X');
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8002032:	4921      	ldr	r1, [pc, #132]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8002034:	4620      	mov	r0, r4
 8002036:	f001 ff43 	bl	8003ec0 <_test_assert>
 800203a:	2800      	cmp	r0, #0
 800203c:	d1ad      	bne.n	8001f9a <test_008_003_execute.lto_priv.151+0x4a>
  }

  /* [8.3.3] Resetting the mailbox.*/
  test_set_step(3);
 800203e:	2303      	movs	r3, #3
 8002040:	602b      	str	r3, [r5, #0]
  {
    chMBReset(&mb1);
 8002042:	f003 ff4d 	bl	8005ee0 <chMBReset.constprop.29>
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 8002046:	2304      	movs	r3, #4
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8002048:	eb0d 0003 	add.w	r0, sp, r3
 800204c:	2101      	movs	r1, #1
  {
    chMBReset(&mb1);
  }

  /* [8.3.4] Testing chMBFetch() and chMBFetchI() timeout.*/
  test_set_step(4);
 800204e:	602b      	str	r3, [r5, #0]
  {
    msg1 = chMBFetch(&mb1, &msg2, 1);
 8002050:	f003 ffa6 	bl	8005fa0 <chMBFetch.constprop.24>
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 8002054:	4918      	ldr	r1, [pc, #96]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 8002056:	f1a0 30ff 	sub.w	r0, r0, #4294967295
 800205a:	fab0 f080 	clz	r0, r0
 800205e:	0940      	lsrs	r0, r0, #5
 8002060:	f001 ff2e 	bl	8003ec0 <_test_assert>
 8002064:	4604      	mov	r4, r0
 8002066:	2800      	cmp	r0, #0
 8002068:	d197      	bne.n	8001f9a <test_008_003_execute.lto_priv.151+0x4a>
 800206a:	2320      	movs	r3, #32
 800206c:	f383 8811 	msr	BASEPRI, r3
 8002070:	69b2      	ldr	r2, [r6, #24]
 8002072:	4b12      	ldr	r3, [pc, #72]	; (80020bc <test_008_003_execute.lto_priv.151+0x16c>)
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8002074:	2a00      	cmp	r2, #0
 8002076:	dd1a      	ble.n	80020ae <test_008_003_execute.lto_priv.151+0x15e>
 8002078:	1e51      	subs	r1, r2, #1
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 800207a:	68da      	ldr	r2, [r3, #12]
 800207c:	6199      	str	r1, [r3, #24]
  if (mbp->rdptr >= mbp->top) {
 800207e:	6859      	ldr	r1, [r3, #4]

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002080:	6810      	ldr	r0, [r2, #0]
 8002082:	9001      	str	r0, [sp, #4]
 8002084:	3204      	adds	r2, #4
  if (mbp->rdptr >= mbp->top) {
 8002086:	428a      	cmp	r2, r1

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002088:	60da      	str	r2, [r3, #12]
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
  }
  chSemSignalI(&mbp->emptysem);
 800208a:	480e      	ldr	r0, [pc, #56]	; (80020c4 <test_008_003_execute.lto_priv.151+0x174>)
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
 800208c:	bf24      	itt	cs
 800208e:	681a      	ldrcs	r2, [r3, #0]
 8002090:	60da      	strcs	r2, [r3, #12]
  }
  chSemSignalI(&mbp->emptysem);
 8002092:	f003 fad5 	bl	8005640 <chSemSignalI>
 8002096:	2300      	movs	r3, #0
 8002098:	f383 8811 	msr	BASEPRI, r3
    chSysLock();
    msg1 = chMBFetchI(&mb1, &msg2);
    chSysUnlock();
    test_assert(msg1 == MSG_TIMEOUT, "wrong wake-up message");
 800209c:	4906      	ldr	r1, [pc, #24]	; (80020b8 <test_008_003_execute.lto_priv.151+0x168>)
 800209e:	4620      	mov	r0, r4
 80020a0:	f001 ff0e 	bl	8003ec0 <_test_assert>
 80020a4:	e779      	b.n	8001f9a <test_008_003_execute.lto_priv.151+0x4a>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 80020a6:	2401      	movs	r4, #1
 80020a8:	e791      	b.n	8001fce <test_008_003_execute.lto_priv.151+0x7e>
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 80020aa:	2401      	movs	r4, #1
 80020ac:	e7be      	b.n	800202c <test_008_003_execute.lto_priv.151+0xdc>
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 80020ae:	2401      	movs	r4, #1
 80020b0:	e7f1      	b.n	8002096 <test_008_003_execute.lto_priv.151+0x146>
 80020b2:	bf00      	nop
 80020b4:	2000133c 	.word	0x2000133c
 80020b8:	08006f74 	.word	0x08006f74
 80020bc:	20000860 	.word	0x20000860
 80020c0:	20000870 	.word	0x20000870
 80020c4:	2000087c 	.word	0x2000087c
 80020c8:	f3af 8000 	nop.w
 80020cc:	f3af 8000 	nop.w

080020d0 <test_008_001_execute.lto_priv.145>:

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 80020d0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80020d4:	4f99      	ldr	r7, [pc, #612]	; (800233c <test_008_001_execute.lto_priv.145+0x26c>)
 80020d6:	2301      	movs	r3, #1

static void test_008_001_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_001_execute(void) {
 80020d8:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.1.1] Testing the mailbox size.*/
  test_set_step(1);
 80020da:	603b      	str	r3, [r7, #0]
 80020dc:	2620      	movs	r6, #32
 80020de:	f386 8811 	msr	BASEPRI, r6
 80020e2:	4d97      	ldr	r5, [pc, #604]	; (8002340 <test_008_001_execute.lto_priv.145+0x270>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 80020e4:	4997      	ldr	r1, [pc, #604]	; (8002344 <test_008_001_execute.lto_priv.145+0x274>)
 80020e6:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80020e8:	f1a0 0004 	sub.w	r0, r0, #4
 80020ec:	fab0 f080 	clz	r0, r0
 80020f0:	0940      	lsrs	r0, r0, #5
 80020f2:	f001 fee5 	bl	8003ec0 <_test_assert>
 80020f6:	4604      	mov	r4, r0
 80020f8:	b128      	cbz	r0, 8002106 <test_008_001_execute.lto_priv.145+0x36>
 80020fa:	2300      	movs	r3, #0
 80020fc:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 8002100:	b003      	add	sp, #12
 8002102:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002106:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.1.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 800210a:	2302      	movs	r3, #2
 800210c:	603b      	str	r3, [r7, #0]
  {
    chMBReset(&mb1);
 800210e:	f003 fee7 	bl	8005ee0 <chMBReset.constprop.29>
 8002112:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 8002116:	6a68      	ldr	r0, [r5, #36]	; 0x24
 8002118:	498b      	ldr	r1, [pc, #556]	; (8002348 <test_008_001_execute.lto_priv.145+0x278>)
 800211a:	f1a0 0004 	sub.w	r0, r0, #4
 800211e:	fab0 f080 	clz	r0, r0
 8002122:	0940      	lsrs	r0, r0, #5
 8002124:	f001 fecc 	bl	8003ec0 <_test_assert>
 8002128:	4680      	mov	r8, r0
 800212a:	b120      	cbz	r0, 8002136 <test_008_001_execute.lto_priv.145+0x66>
 800212c:	f384 8811 	msr	BASEPRI, r4
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 8002130:	b003      	add	sp, #12
 8002132:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8002136:	f380 8811 	msr	BASEPRI, r0
 800213a:	f386 8811 	msr	BASEPRI, r6
     expected.*/
  test_set_step(2);
  {
    chMBReset(&mb1);
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800213e:	4983      	ldr	r1, [pc, #524]	; (800234c <test_008_001_execute.lto_priv.145+0x27c>)
 8002140:	69a8      	ldr	r0, [r5, #24]
 8002142:	fab0 f080 	clz	r0, r0
 8002146:	0940      	lsrs	r0, r0, #5
 8002148:	f001 feba 	bl	8003ec0 <_test_assert>
 800214c:	4604      	mov	r4, r0
 800214e:	b110      	cbz	r0, 8002156 <test_008_001_execute.lto_priv.145+0x86>
 8002150:	f388 8811 	msr	BASEPRI, r8
 8002154:	e7d4      	b.n	8002100 <test_008_001_execute.lto_priv.145+0x30>
 8002156:	f380 8811 	msr	BASEPRI, r0
 800215a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 800215e:	6828      	ldr	r0, [r5, #0]
 8002160:	68ab      	ldr	r3, [r5, #8]
 8002162:	497b      	ldr	r1, [pc, #492]	; (8002350 <test_008_001_execute.lto_priv.145+0x280>)
 8002164:	1ac0      	subs	r0, r0, r3
 8002166:	fab0 f080 	clz	r0, r0
 800216a:	0940      	lsrs	r0, r0, #5
 800216c:	f001 fea8 	bl	8003ec0 <_test_assert>
 8002170:	4680      	mov	r8, r0
 8002172:	2800      	cmp	r0, #0
 8002174:	d1da      	bne.n	800212c <test_008_001_execute.lto_priv.145+0x5c>
 8002176:	f380 8811 	msr	BASEPRI, r0
 800217a:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 800217e:	6828      	ldr	r0, [r5, #0]
 8002180:	68eb      	ldr	r3, [r5, #12]
 8002182:	4974      	ldr	r1, [pc, #464]	; (8002354 <test_008_001_execute.lto_priv.145+0x284>)
 8002184:	1ac0      	subs	r0, r0, r3
 8002186:	fab0 f080 	clz	r0, r0
 800218a:	0940      	lsrs	r0, r0, #5
 800218c:	f001 fe98 	bl	8003ec0 <_test_assert>
 8002190:	2800      	cmp	r0, #0
 8002192:	d1dd      	bne.n	8002150 <test_008_001_execute.lto_priv.145+0x80>
 8002194:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
 8002198:	2303      	movs	r3, #3
 800219a:	603b      	str	r3, [r7, #0]
 800219c:	2442      	movs	r4, #66	; 0x42
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800219e:	4620      	mov	r0, r4
 80021a0:	f04f 31ff 	mov.w	r1, #4294967295
 80021a4:	f003 feac 	bl	8005f00 <chMBPost.constprop.28>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80021a8:	496b      	ldr	r1, [pc, #428]	; (8002358 <test_008_001_execute.lto_priv.145+0x288>)
 80021aa:	fab0 f080 	clz	r0, r0
 80021ae:	0940      	lsrs	r0, r0, #5
 80021b0:	f001 fe86 	bl	8003ec0 <_test_assert>
 80021b4:	3401      	adds	r4, #1
 80021b6:	2800      	cmp	r0, #0
 80021b8:	d1a2      	bne.n	8002100 <test_008_001_execute.lto_priv.145+0x30>

  /* [8.1.3] Filling the mailbox using chMBPost() and chMBPostAhead()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 80021ba:	2c45      	cmp	r4, #69	; 0x45
 80021bc:	d1ef      	bne.n	800219e <test_008_001_execute.lto_priv.145+0xce>
      msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    msg1 = chMBPostAhead(&mb1, 'A', TIME_INFINITE);
 80021be:	f04f 31ff 	mov.w	r1, #4294967295
 80021c2:	2041      	movs	r0, #65	; 0x41
 80021c4:	f003 fec4 	bl	8005f50 <chMBPostAhead.constprop.26>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80021c8:	4963      	ldr	r1, [pc, #396]	; (8002358 <test_008_001_execute.lto_priv.145+0x288>)
 80021ca:	fab0 f080 	clz	r0, r0
 80021ce:	0940      	lsrs	r0, r0, #5
 80021d0:	f001 fe76 	bl	8003ec0 <_test_assert>
 80021d4:	4606      	mov	r6, r0
 80021d6:	2800      	cmp	r0, #0
 80021d8:	d192      	bne.n	8002100 <test_008_001_execute.lto_priv.145+0x30>
  }

  /* [8.1.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 80021da:	2404      	movs	r4, #4
 80021dc:	603c      	str	r4, [r7, #0]
 80021de:	f8df 915c 	ldr.w	r9, [pc, #348]	; 800233c <test_008_001_execute.lto_priv.145+0x26c>
 80021e2:	f04f 0a20 	mov.w	sl, #32
 80021e6:	f38a 8811 	msr	BASEPRI, sl
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80021ea:	495c      	ldr	r1, [pc, #368]	; (800235c <test_008_001_execute.lto_priv.145+0x28c>)
 80021ec:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80021ee:	fab0 f080 	clz	r0, r0
 80021f2:	0940      	lsrs	r0, r0, #5
 80021f4:	f001 fe64 	bl	8003ec0 <_test_assert>
 80021f8:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8002340 <test_008_001_execute.lto_priv.145+0x270>
 80021fc:	4683      	mov	fp, r0
 80021fe:	b110      	cbz	r0, 8002206 <test_008_001_execute.lto_priv.145+0x136>
 8002200:	f386 8811 	msr	BASEPRI, r6
 8002204:	e77c      	b.n	8002100 <test_008_001_execute.lto_priv.145+0x30>
 8002206:	f380 8811 	msr	BASEPRI, r0
 800220a:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 800220e:	f8d8 0018 	ldr.w	r0, [r8, #24]
 8002212:	4953      	ldr	r1, [pc, #332]	; (8002360 <test_008_001_execute.lto_priv.145+0x290>)
 8002214:	f1a0 0c04 	sub.w	ip, r0, #4
 8002218:	f1dc 0000 	rsbs	r0, ip, #0
 800221c:	eb40 000c 	adc.w	r0, r0, ip
 8002220:	f001 fe4e 	bl	8003ec0 <_test_assert>
 8002224:	4606      	mov	r6, r0
 8002226:	b110      	cbz	r0, 800222e <test_008_001_execute.lto_priv.145+0x15e>
 8002228:	f38b 8811 	msr	BASEPRI, fp
 800222c:	e768      	b.n	8002100 <test_008_001_execute.lto_priv.145+0x30>
 800222e:	f380 8811 	msr	BASEPRI, r0
 8002232:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8002236:	f8d8 000c 	ldr.w	r0, [r8, #12]
 800223a:	f8d8 3008 	ldr.w	r3, [r8, #8]
 800223e:	4949      	ldr	r1, [pc, #292]	; (8002364 <test_008_001_execute.lto_priv.145+0x294>)
 8002240:	ebc3 0e00 	rsb	lr, r3, r0
 8002244:	f1de 0000 	rsbs	r0, lr, #0
 8002248:	eb40 000e 	adc.w	r0, r0, lr
 800224c:	f001 fe38 	bl	8003ec0 <_test_assert>
 8002250:	2800      	cmp	r0, #0
 8002252:	d1d5      	bne.n	8002200 <test_008_001_execute.lto_priv.145+0x130>
 8002254:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
 8002258:	2305      	movs	r3, #5
 800225a:	f8c9 3000 	str.w	r3, [r9]
  {
    for (i = 0; i < MB_SIZE; i++) {
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 800225e:	f04f 31ff 	mov.w	r1, #4294967295
 8002262:	a801      	add	r0, sp, #4
 8002264:	f003 fe9c 	bl	8005fa0 <chMBFetch.constprop.24>
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002268:	493b      	ldr	r1, [pc, #236]	; (8002358 <test_008_001_execute.lto_priv.145+0x288>)
 800226a:	fab0 f080 	clz	r0, r0
 800226e:	0940      	lsrs	r0, r0, #5
 8002270:	f001 fe26 	bl	8003ec0 <_test_assert>
 8002274:	2800      	cmp	r0, #0
 8002276:	f47f af43 	bne.w	8002100 <test_008_001_execute.lto_priv.145+0x30>
      test_emit_token(msg2);
 800227a:	f89d 0004 	ldrb.w	r0, [sp, #4]
 800227e:	f001 fd7f 	bl	8003d80 <test_emit_token>

  /* [8.1.5] Emptying the mailbox using chMBFetch(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8002282:	3c01      	subs	r4, #1
 8002284:	d1eb      	bne.n	800225e <test_008_001_execute.lto_priv.145+0x18e>
      msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 8002286:	4838      	ldr	r0, [pc, #224]	; (8002368 <test_008_001_execute.lto_priv.145+0x298>)
 8002288:	4938      	ldr	r1, [pc, #224]	; (800236c <test_008_001_execute.lto_priv.145+0x29c>)
 800228a:	f001 fdf1 	bl	8003e70 <_test_assert_sequence>
 800228e:	2800      	cmp	r0, #0
 8002290:	f47f af36 	bne.w	8002100 <test_008_001_execute.lto_priv.145+0x30>
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 8002294:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 8002296:	f04f 31ff 	mov.w	r1, #4294967295
 800229a:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 800229c:	603b      	str	r3, [r7, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 800229e:	f003 fe2f 	bl	8005f00 <chMBPost.constprop.28>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80022a2:	492d      	ldr	r1, [pc, #180]	; (8002358 <test_008_001_execute.lto_priv.145+0x288>)
 80022a4:	fab0 f080 	clz	r0, r0
 80022a8:	0940      	lsrs	r0, r0, #5
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.1.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80022aa:	4e24      	ldr	r6, [pc, #144]	; (800233c <test_008_001_execute.lto_priv.145+0x26c>)
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80022ac:	f001 fe08 	bl	8003ec0 <_test_assert>
 80022b0:	2800      	cmp	r0, #0
 80022b2:	f47f af25 	bne.w	8002100 <test_008_001_execute.lto_priv.145+0x30>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80022b6:	f04f 31ff 	mov.w	r1, #4294967295
 80022ba:	a801      	add	r0, sp, #4
 80022bc:	f003 fe70 	bl	8005fa0 <chMBFetch.constprop.24>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80022c0:	4925      	ldr	r1, [pc, #148]	; (8002358 <test_008_001_execute.lto_priv.145+0x288>)
 80022c2:	fab0 f080 	clz	r0, r0
 80022c6:	0940      	lsrs	r0, r0, #5
 80022c8:	f001 fdfa 	bl	8003ec0 <_test_assert>
 80022cc:	2800      	cmp	r0, #0
 80022ce:	f47f af17 	bne.w	8002100 <test_008_001_execute.lto_priv.145+0x30>
  }

  /* [8.1.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 80022d2:	2307      	movs	r3, #7
 80022d4:	6033      	str	r3, [r6, #0]
 80022d6:	2620      	movs	r6, #32
 80022d8:	f386 8811 	msr	BASEPRI, r6
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80022dc:	6a68      	ldr	r0, [r5, #36]	; 0x24
 80022de:	491a      	ldr	r1, [pc, #104]	; (8002348 <test_008_001_execute.lto_priv.145+0x278>)
 80022e0:	4d17      	ldr	r5, [pc, #92]	; (8002340 <test_008_001_execute.lto_priv.145+0x270>)
 80022e2:	1f07      	subs	r7, r0, #4
 80022e4:	4278      	negs	r0, r7
 80022e6:	4178      	adcs	r0, r7
 80022e8:	f001 fdea 	bl	8003ec0 <_test_assert>
 80022ec:	2800      	cmp	r0, #0
 80022ee:	f47f af1d 	bne.w	800212c <test_008_001_execute.lto_priv.145+0x5c>
 80022f2:	f384 8811 	msr	BASEPRI, r4
 80022f6:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80022fa:	4914      	ldr	r1, [pc, #80]	; (800234c <test_008_001_execute.lto_priv.145+0x27c>)
 80022fc:	69a8      	ldr	r0, [r5, #24]
 80022fe:	fab0 f080 	clz	r0, r0
 8002302:	0940      	lsrs	r0, r0, #5
 8002304:	f001 fddc 	bl	8003ec0 <_test_assert>
 8002308:	2800      	cmp	r0, #0
 800230a:	f47f af0f 	bne.w	800212c <test_008_001_execute.lto_priv.145+0x5c>
 800230e:	f384 8811 	msr	BASEPRI, r4
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002312:	6828      	ldr	r0, [r5, #0]
 8002314:	68ab      	ldr	r3, [r5, #8]
 8002316:	490e      	ldr	r1, [pc, #56]	; (8002350 <test_008_001_execute.lto_priv.145+0x280>)
 8002318:	1ac2      	subs	r2, r0, r3
 800231a:	4250      	negs	r0, r2
 800231c:	4150      	adcs	r0, r2
 800231e:	f001 fdcf 	bl	8003ec0 <_test_assert>
 8002322:	2800      	cmp	r0, #0
 8002324:	f47f aeec 	bne.w	8002100 <test_008_001_execute.lto_priv.145+0x30>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002328:	6828      	ldr	r0, [r5, #0]
 800232a:	68eb      	ldr	r3, [r5, #12]
 800232c:	4909      	ldr	r1, [pc, #36]	; (8002354 <test_008_001_execute.lto_priv.145+0x284>)
 800232e:	1ac3      	subs	r3, r0, r3
 8002330:	4258      	negs	r0, r3
 8002332:	4158      	adcs	r0, r3
 8002334:	f001 fdc4 	bl	8003ec0 <_test_assert>
 8002338:	e6e2      	b.n	8002100 <test_008_001_execute.lto_priv.145+0x30>
 800233a:	bf00      	nop
 800233c:	2000133c 	.word	0x2000133c
 8002340:	20000860 	.word	0x20000860
 8002344:	08007020 	.word	0x08007020
 8002348:	0800702c 	.word	0x0800702c
 800234c:	08007038 	.word	0x08007038
 8002350:	08007044 	.word	0x08007044
 8002354:	08007068 	.word	0x08007068
 8002358:	08006f74 	.word	0x08006f74
 800235c:	0800708c 	.word	0x0800708c
 8002360:	08007098 	.word	0x08007098
 8002364:	080070a4 	.word	0x080070a4
 8002368:	080070bc 	.word	0x080070bc
 800236c:	080070c4 	.word	0x080070c4

08002370 <test_008_002_execute.lto_priv.148>:

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8002370:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 8002374:	4fb8      	ldr	r7, [pc, #736]	; (8002658 <test_008_002_execute.lto_priv.148+0x2e8>)
 8002376:	2301      	movs	r3, #1

static void test_008_002_teardown(void) {
  chMBReset(&mb1);
}

static void test_008_002_execute(void) {
 8002378:	b083      	sub	sp, #12
  msg_t msg1, msg2;
  unsigned i;

  /* [8.2.1] Testing the mailbox size.*/
  test_set_step(1);
 800237a:	603b      	str	r3, [r7, #0]
 800237c:	2520      	movs	r5, #32
 800237e:	f385 8811 	msr	BASEPRI, r5
 8002382:	4eb6      	ldr	r6, [pc, #728]	; (800265c <test_008_002_execute.lto_priv.148+0x2ec>)
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
 8002384:	49b6      	ldr	r1, [pc, #728]	; (8002660 <test_008_002_execute.lto_priv.148+0x2f0>)
 8002386:	6a70      	ldr	r0, [r6, #36]	; 0x24
 8002388:	f1a0 0004 	sub.w	r0, r0, #4
 800238c:	fab0 f080 	clz	r0, r0
 8002390:	0940      	lsrs	r0, r0, #5
 8002392:	f001 fd95 	bl	8003ec0 <_test_assert>
 8002396:	4604      	mov	r4, r0
 8002398:	b128      	cbz	r0, 80023a6 <test_008_002_execute.lto_priv.148+0x36>
 800239a:	2300      	movs	r3, #0
 800239c:	f383 8811 	msr	BASEPRI, r3
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80023a0:	b003      	add	sp, #12
 80023a2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80023a6:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "wrong size");
  }

  /* [8.2.2] Resetting the mailbox, conditions are checked, no errors
     expected.*/
  test_set_step(2);
 80023aa:	2302      	movs	r3, #2
 80023ac:	603b      	str	r3, [r7, #0]
 80023ae:	f385 8811 	msr	BASEPRI, r5
  {
    chSysLock();
    chMBResetI(&mb1);
 80023b2:	f003 fd7d 	bl	8005eb0 <chMBResetI.constprop.30>
 80023b6:	f384 8811 	msr	BASEPRI, r4
 80023ba:	f385 8811 	msr	BASEPRI, r5
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80023be:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80023c0:	49a8      	ldr	r1, [pc, #672]	; (8002664 <test_008_002_execute.lto_priv.148+0x2f4>)
 80023c2:	f1a0 0004 	sub.w	r0, r0, #4
 80023c6:	fab0 f080 	clz	r0, r0
 80023ca:	0940      	lsrs	r0, r0, #5
 80023cc:	f001 fd78 	bl	8003ec0 <_test_assert>
 80023d0:	4680      	mov	r8, r0
 80023d2:	b120      	cbz	r0, 80023de <test_008_002_execute.lto_priv.148+0x6e>
 80023d4:	f384 8811 	msr	BASEPRI, r4
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
  }
}
 80023d8:	b003      	add	sp, #12
 80023da:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80023de:	f380 8811 	msr	BASEPRI, r0
 80023e2:	f385 8811 	msr	BASEPRI, r5
  {
    chSysLock();
    chMBResetI(&mb1);
    chSysUnlock();
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 80023e6:	49a0      	ldr	r1, [pc, #640]	; (8002668 <test_008_002_execute.lto_priv.148+0x2f8>)
 80023e8:	69b0      	ldr	r0, [r6, #24]
 80023ea:	fab0 f080 	clz	r0, r0
 80023ee:	0940      	lsrs	r0, r0, #5
 80023f0:	f001 fd66 	bl	8003ec0 <_test_assert>
 80023f4:	4604      	mov	r4, r0
 80023f6:	b110      	cbz	r0, 80023fe <test_008_002_execute.lto_priv.148+0x8e>
 80023f8:	f388 8811 	msr	BASEPRI, r8
 80023fc:	e7d0      	b.n	80023a0 <test_008_002_execute.lto_priv.148+0x30>
 80023fe:	f380 8811 	msr	BASEPRI, r0
 8002402:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002406:	6830      	ldr	r0, [r6, #0]
 8002408:	68b3      	ldr	r3, [r6, #8]
 800240a:	4998      	ldr	r1, [pc, #608]	; (800266c <test_008_002_execute.lto_priv.148+0x2fc>)
 800240c:	1ac0      	subs	r0, r0, r3
 800240e:	fab0 f080 	clz	r0, r0
 8002412:	0940      	lsrs	r0, r0, #5
 8002414:	f001 fd54 	bl	8003ec0 <_test_assert>
 8002418:	4680      	mov	r8, r0
 800241a:	2800      	cmp	r0, #0
 800241c:	d1da      	bne.n	80023d4 <test_008_002_execute.lto_priv.148+0x64>
 800241e:	f380 8811 	msr	BASEPRI, r0
 8002422:	f385 8811 	msr	BASEPRI, r5
    test_assert_lock(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002426:	6830      	ldr	r0, [r6, #0]
 8002428:	68f3      	ldr	r3, [r6, #12]
 800242a:	4991      	ldr	r1, [pc, #580]	; (8002670 <test_008_002_execute.lto_priv.148+0x300>)
 800242c:	1ac0      	subs	r0, r0, r3
 800242e:	fab0 f080 	clz	r0, r0
 8002432:	0940      	lsrs	r0, r0, #5
 8002434:	f001 fd44 	bl	8003ec0 <_test_assert>
 8002438:	2800      	cmp	r0, #0
 800243a:	d1dd      	bne.n	80023f8 <test_008_002_execute.lto_priv.148+0x88>
 800243c:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
 8002440:	2303      	movs	r3, #3
 8002442:	603b      	str	r3, [r7, #0]
 8002444:	4634      	mov	r4, r6
 8002446:	2542      	movs	r5, #66	; 0x42
 8002448:	2320      	movs	r3, #32
 800244a:	f383 8811 	msr	BASEPRI, r3
 800244e:	6a73      	ldr	r3, [r6, #36]	; 0x24
  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
  }
  chSemSignalI(&mbp->fullsem);
 8002450:	4888      	ldr	r0, [pc, #544]	; (8002674 <test_008_002_execute.lto_priv.148+0x304>)
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002452:	2b00      	cmp	r3, #0
 8002454:	f103 3eff 	add.w	lr, r3, #4294967295
 8002458:	dd60      	ble.n	800251c <test_008_002_execute.lto_priv.148+0x1ac>
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 800245a:	68a2      	ldr	r2, [r4, #8]
  if (mbp->wrptr >= mbp->top) {
 800245c:	6861      	ldr	r1, [r4, #4]
 800245e:	f8c4 e024 	str.w	lr, [r4, #36]	; 0x24
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8002462:	1d13      	adds	r3, r2, #4
  if (mbp->wrptr >= mbp->top) {
 8002464:	428b      	cmp	r3, r1
  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }

  chSemFastWaitI(&mbp->emptysem);
  *mbp->wrptr++ = msg;
 8002466:	60a3      	str	r3, [r4, #8]
 8002468:	6015      	str	r5, [r2, #0]
  if (mbp->wrptr >= mbp->top) {
     mbp->wrptr = mbp->buffer;
 800246a:	bf24      	itt	cs
 800246c:	6823      	ldrcs	r3, [r4, #0]
 800246e:	60a3      	strcs	r3, [r4, #8]
  }
  chSemSignalI(&mbp->fullsem);
 8002470:	f003 f8e6 	bl	8005640 <chSemSignalI>
 8002474:	2001      	movs	r0, #1
 8002476:	2300      	movs	r3, #0
 8002478:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
      chSysLock();
      msg1 = chMBPostI(&mb1, 'B' + i);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 800247c:	497e      	ldr	r1, [pc, #504]	; (8002678 <test_008_002_execute.lto_priv.148+0x308>)
 800247e:	f001 fd1f 	bl	8003ec0 <_test_assert>
 8002482:	3501      	adds	r5, #1
 8002484:	2800      	cmp	r0, #0
 8002486:	d18b      	bne.n	80023a0 <test_008_002_execute.lto_priv.148+0x30>

  /* [8.2.3] Filling the mailbox using chMBPostI() and chMBPostAheadI()
     once, no errors expected.*/
  test_set_step(3);
  {
    for (i = 0; i < MB_SIZE - 1; i++) {
 8002488:	2d45      	cmp	r5, #69	; 0x45
 800248a:	d1dd      	bne.n	8002448 <test_008_002_execute.lto_priv.148+0xd8>
 800248c:	2320      	movs	r3, #32
 800248e:	f383 8811 	msr	BASEPRI, r3
 8002492:	6a71      	ldr	r1, [r6, #36]	; 0x24
 8002494:	4a71      	ldr	r2, [pc, #452]	; (800265c <test_008_002_execute.lto_priv.148+0x2ec>)
msg_t chMBPostAheadI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 8002496:	2900      	cmp	r1, #0
 8002498:	dd10      	ble.n	80024bc <test_008_002_execute.lto_priv.148+0x14c>
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
 800249a:	68d3      	ldr	r3, [r2, #12]
 800249c:	6810      	ldr	r0, [r2, #0]
 800249e:	3b04      	subs	r3, #4
 80024a0:	3901      	subs	r1, #1
 80024a2:	4283      	cmp	r3, r0
 80024a4:	6251      	str	r1, [r2, #36]	; 0x24
 80024a6:	60d3      	str	r3, [r2, #12]
 80024a8:	d202      	bcs.n	80024b0 <test_008_002_execute.lto_priv.148+0x140>
    mbp->rdptr = mbp->top - 1;
 80024aa:	6853      	ldr	r3, [r2, #4]
 80024ac:	3b04      	subs	r3, #4
 80024ae:	60d3      	str	r3, [r2, #12]
  }
  *mbp->rdptr = msg;
 80024b0:	2241      	movs	r2, #65	; 0x41
  chSemSignalI(&mbp->fullsem);
 80024b2:	4870      	ldr	r0, [pc, #448]	; (8002674 <test_008_002_execute.lto_priv.148+0x304>)
  }
  chSemFastWaitI(&mbp->emptysem);
  if (--mbp->rdptr < mbp->buffer) {
    mbp->rdptr = mbp->top - 1;
  }
  *mbp->rdptr = msg;
 80024b4:	601a      	str	r2, [r3, #0]
  chSemSignalI(&mbp->fullsem);
 80024b6:	f003 f8c3 	bl	8005640 <chSemSignalI>
 80024ba:	2001      	movs	r0, #1
 80024bc:	2300      	movs	r3, #0
 80024be:	f383 8811 	msr	BASEPRI, r3
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
    }
    chSysLock();
    msg1 = chMBPostAheadI(&mb1, 'A');
    chSysUnlock();
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80024c2:	496d      	ldr	r1, [pc, #436]	; (8002678 <test_008_002_execute.lto_priv.148+0x308>)
 80024c4:	f001 fcfc 	bl	8003ec0 <_test_assert>
 80024c8:	4680      	mov	r8, r0
 80024ca:	2800      	cmp	r0, #0
 80024cc:	f47f af68 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
  }

  /* [8.2.4] Testing intermediate conditions. Data pointers must be
     aligned, semaphore counters are checked.*/
  test_set_step(4);
 80024d0:	2504      	movs	r5, #4
 80024d2:	603d      	str	r5, [r7, #0]
 80024d4:	f8df 9180 	ldr.w	r9, [pc, #384]	; 8002658 <test_008_002_execute.lto_priv.148+0x2e8>
 80024d8:	f04f 0a20 	mov.w	sl, #32
 80024dc:	f38a 8811 	msr	BASEPRI, sl
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == 0, "still empty");
 80024e0:	4966      	ldr	r1, [pc, #408]	; (800267c <test_008_002_execute.lto_priv.148+0x30c>)
 80024e2:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80024e4:	fab0 f080 	clz	r0, r0
 80024e8:	0940      	lsrs	r0, r0, #5
 80024ea:	f001 fce9 	bl	8003ec0 <_test_assert>
 80024ee:	4c5b      	ldr	r4, [pc, #364]	; (800265c <test_008_002_execute.lto_priv.148+0x2ec>)
 80024f0:	4683      	mov	fp, r0
 80024f2:	2800      	cmp	r0, #0
 80024f4:	d180      	bne.n	80023f8 <test_008_002_execute.lto_priv.148+0x88>
 80024f6:	f380 8811 	msr	BASEPRI, r0
 80024fa:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(chMBGetUsedCountI(&mb1) == MB_SIZE, "not full");
 80024fe:	69a0      	ldr	r0, [r4, #24]
 8002500:	495f      	ldr	r1, [pc, #380]	; (8002680 <test_008_002_execute.lto_priv.148+0x310>)
 8002502:	f1a0 0c04 	sub.w	ip, r0, #4
 8002506:	f1dc 0000 	rsbs	r0, ip, #0
 800250a:	eb40 000c 	adc.w	r0, r0, ip
 800250e:	f001 fcd7 	bl	8003ec0 <_test_assert>
 8002512:	4680      	mov	r8, r0
 8002514:	b120      	cbz	r0, 8002520 <test_008_002_execute.lto_priv.148+0x1b0>
 8002516:	f38b 8811 	msr	BASEPRI, fp
 800251a:	e741      	b.n	80023a0 <test_008_002_execute.lto_priv.148+0x30>
msg_t chMBPostI(mailbox_t *mbp, msg_t msg) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  if (chSemGetCounterI(&mbp->emptysem) <= (cnt_t)0) {
 800251c:	2000      	movs	r0, #0
 800251e:	e7aa      	b.n	8002476 <test_008_002_execute.lto_priv.148+0x106>
 8002520:	f380 8811 	msr	BASEPRI, r0
 8002524:	f38a 8811 	msr	BASEPRI, sl
    test_assert_lock(mb1.rdptr == mb1.wrptr, "pointers not aligned");
 8002528:	68e0      	ldr	r0, [r4, #12]
 800252a:	68a3      	ldr	r3, [r4, #8]
 800252c:	4955      	ldr	r1, [pc, #340]	; (8002684 <test_008_002_execute.lto_priv.148+0x314>)
 800252e:	ebc3 0e00 	rsb	lr, r3, r0
 8002532:	f1de 0000 	rsbs	r0, lr, #0
 8002536:	eb40 000e 	adc.w	r0, r0, lr
 800253a:	f001 fcc1 	bl	8003ec0 <_test_assert>
 800253e:	2800      	cmp	r0, #0
 8002540:	f47f af5a 	bne.w	80023f8 <test_008_002_execute.lto_priv.148+0x88>
 8002544:	f380 8811 	msr	BASEPRI, r0
  }

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
 8002548:	2305      	movs	r3, #5
 800254a:	f8c9 3000 	str.w	r3, [r9]
 800254e:	e01d      	b.n	800258c <test_008_002_execute.lto_priv.148+0x21c>

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002550:	68e3      	ldr	r3, [r4, #12]
 8002552:	61a2      	str	r2, [r4, #24]
  if (mbp->rdptr >= mbp->top) {
 8002554:	6862      	ldr	r2, [r4, #4]

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 8002556:	6819      	ldr	r1, [r3, #0]
 8002558:	9101      	str	r1, [sp, #4]
 800255a:	3304      	adds	r3, #4
  if (mbp->rdptr >= mbp->top) {
 800255c:	4293      	cmp	r3, r2

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
    return MSG_TIMEOUT;
  }
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
 800255e:	60e3      	str	r3, [r4, #12]
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
 8002560:	bf24      	itt	cs
 8002562:	6823      	ldrcs	r3, [r4, #0]
 8002564:	60e3      	strcs	r3, [r4, #12]
  }
  chSemSignalI(&mbp->emptysem);
 8002566:	f003 f86b 	bl	8005640 <chSemSignalI>

  return MSG_OK;
 800256a:	2000      	movs	r0, #0
 800256c:	2300      	movs	r3, #0
 800256e:	f383 8811 	msr	BASEPRI, r3
  {
    for (i = 0; i < MB_SIZE; i++) {
      chSysLock();
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
 8002572:	4941      	ldr	r1, [pc, #260]	; (8002678 <test_008_002_execute.lto_priv.148+0x308>)
 8002574:	3001      	adds	r0, #1
 8002576:	f001 fca3 	bl	8003ec0 <_test_assert>
 800257a:	2800      	cmp	r0, #0
 800257c:	f47f af10 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
      test_emit_token(msg2);
 8002580:	f89d 0004 	ldrb.w	r0, [sp, #4]
 8002584:	f001 fbfc 	bl	8003d80 <test_emit_token>

  /* [8.2.5] Emptying the mailbox using chMBFetchI(), no errors
     expected.*/
  test_set_step(5);
  {
    for (i = 0; i < MB_SIZE; i++) {
 8002588:	3d01      	subs	r5, #1
 800258a:	d00b      	beq.n	80025a4 <test_008_002_execute.lto_priv.148+0x234>
 800258c:	2320      	movs	r3, #32
 800258e:	f383 8811 	msr	BASEPRI, r3
 8002592:	69b3      	ldr	r3, [r6, #24]
  chSemFastWaitI(&mbp->fullsem);
  *msgp = *mbp->rdptr++;
  if (mbp->rdptr >= mbp->top) {
    mbp->rdptr = mbp->buffer;
  }
  chSemSignalI(&mbp->emptysem);
 8002594:	483c      	ldr	r0, [pc, #240]	; (8002688 <test_008_002_execute.lto_priv.148+0x318>)
msg_t chMBFetchI(mailbox_t *mbp, msg_t *msgp) {

  chDbgCheckClassI();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  if (chSemGetCounterI(&mbp->fullsem) <= (cnt_t)0) {
 8002596:	2b00      	cmp	r3, #0
 8002598:	f103 32ff 	add.w	r2, r3, #4294967295
 800259c:	dcd8      	bgt.n	8002550 <test_008_002_execute.lto_priv.148+0x1e0>
    return MSG_TIMEOUT;
 800259e:	f04f 30ff 	mov.w	r0, #4294967295
 80025a2:	e7e3      	b.n	800256c <test_008_002_execute.lto_priv.148+0x1fc>
      msg1 = chMBFetchI(&mb1, &msg2);
      chSysUnlock();
      test_assert(msg1 == MSG_OK, "wrong wake-up message");
      test_emit_token(msg2);
    }
    test_assert_sequence("ABCD", "wrong get sequence");
 80025a4:	4839      	ldr	r0, [pc, #228]	; (800268c <test_008_002_execute.lto_priv.148+0x31c>)
 80025a6:	493a      	ldr	r1, [pc, #232]	; (8002690 <test_008_002_execute.lto_priv.148+0x320>)
 80025a8:	f001 fc62 	bl	8003e70 <_test_assert_sequence>
 80025ac:	2800      	cmp	r0, #0
 80025ae:	f47f aef7 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80025b2:	2306      	movs	r3, #6
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80025b4:	f04f 31ff 	mov.w	r1, #4294967295
 80025b8:	2046      	movs	r0, #70	; 0x46
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80025ba:	603b      	str	r3, [r7, #0]
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
 80025bc:	f003 fca0 	bl	8005f00 <chMBPost.constprop.28>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80025c0:	492d      	ldr	r1, [pc, #180]	; (8002678 <test_008_002_execute.lto_priv.148+0x308>)
 80025c2:	fab0 f080 	clz	r0, r0
 80025c6:	0940      	lsrs	r0, r0, #5
    test_assert_sequence("ABCD", "wrong get sequence");
  }

  /* [8.2.6] Posting and then fetching one more message, no errors
     expected.*/
  test_set_step(6);
 80025c8:	4c23      	ldr	r4, [pc, #140]	; (8002658 <test_008_002_execute.lto_priv.148+0x2e8>)
  {
    msg1 = chMBPost(&mb1, 'B' + i, TIME_INFINITE);
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80025ca:	f001 fc79 	bl	8003ec0 <_test_assert>
 80025ce:	2800      	cmp	r0, #0
 80025d0:	f47f aee6 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
    msg1 = chMBFetch(&mb1, &msg2, TIME_INFINITE);
 80025d4:	f04f 31ff 	mov.w	r1, #4294967295
 80025d8:	a801      	add	r0, sp, #4
 80025da:	f003 fce1 	bl	8005fa0 <chMBFetch.constprop.24>
    test_assert(msg1 == MSG_OK, "wrong wake-up message");
 80025de:	4926      	ldr	r1, [pc, #152]	; (8002678 <test_008_002_execute.lto_priv.148+0x308>)
 80025e0:	fab0 f080 	clz	r0, r0
 80025e4:	0940      	lsrs	r0, r0, #5
 80025e6:	f001 fc6b 	bl	8003ec0 <_test_assert>
 80025ea:	2800      	cmp	r0, #0
 80025ec:	f47f aed8 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
  }

  /* [8.2.7] Testing final conditions. Data pointers must be aligned to
     buffer start, semaphore counters are checked.*/
  test_set_step(7);
 80025f0:	2307      	movs	r3, #7
 80025f2:	6023      	str	r3, [r4, #0]
 80025f4:	2720      	movs	r7, #32
 80025f6:	f387 8811 	msr	BASEPRI, r7
  {
    test_assert_lock(chMBGetFreeCountI(&mb1) == MB_SIZE, "not empty");
 80025fa:	6a70      	ldr	r0, [r6, #36]	; 0x24
 80025fc:	4919      	ldr	r1, [pc, #100]	; (8002664 <test_008_002_execute.lto_priv.148+0x2f4>)
 80025fe:	4c17      	ldr	r4, [pc, #92]	; (800265c <test_008_002_execute.lto_priv.148+0x2ec>)
 8002600:	1f06      	subs	r6, r0, #4
 8002602:	4270      	negs	r0, r6
 8002604:	4170      	adcs	r0, r6
 8002606:	f001 fc5b 	bl	8003ec0 <_test_assert>
 800260a:	b110      	cbz	r0, 8002612 <test_008_002_execute.lto_priv.148+0x2a2>
 800260c:	f385 8811 	msr	BASEPRI, r5
 8002610:	e6c6      	b.n	80023a0 <test_008_002_execute.lto_priv.148+0x30>
 8002612:	f385 8811 	msr	BASEPRI, r5
 8002616:	f387 8811 	msr	BASEPRI, r7
    test_assert_lock(chMBGetUsedCountI(&mb1) == 0, "still full");
 800261a:	4913      	ldr	r1, [pc, #76]	; (8002668 <test_008_002_execute.lto_priv.148+0x2f8>)
 800261c:	69a0      	ldr	r0, [r4, #24]
 800261e:	fab0 f080 	clz	r0, r0
 8002622:	0940      	lsrs	r0, r0, #5
 8002624:	f001 fc4c 	bl	8003ec0 <_test_assert>
 8002628:	2800      	cmp	r0, #0
 800262a:	d1ef      	bne.n	800260c <test_008_002_execute.lto_priv.148+0x29c>
 800262c:	f385 8811 	msr	BASEPRI, r5
    test_assert(mb1.buffer == mb1.wrptr, "write pointer not aligned to base");
 8002630:	6820      	ldr	r0, [r4, #0]
 8002632:	68a3      	ldr	r3, [r4, #8]
 8002634:	490d      	ldr	r1, [pc, #52]	; (800266c <test_008_002_execute.lto_priv.148+0x2fc>)
 8002636:	1ac2      	subs	r2, r0, r3
 8002638:	4250      	negs	r0, r2
 800263a:	4150      	adcs	r0, r2
 800263c:	f001 fc40 	bl	8003ec0 <_test_assert>
 8002640:	2800      	cmp	r0, #0
 8002642:	f47f aead 	bne.w	80023a0 <test_008_002_execute.lto_priv.148+0x30>
    test_assert(mb1.buffer == mb1.rdptr, "read pointer not aligned to base");
 8002646:	6820      	ldr	r0, [r4, #0]
 8002648:	68e3      	ldr	r3, [r4, #12]
 800264a:	4909      	ldr	r1, [pc, #36]	; (8002670 <test_008_002_execute.lto_priv.148+0x300>)
 800264c:	1ac3      	subs	r3, r0, r3
 800264e:	4258      	negs	r0, r3
 8002650:	4158      	adcs	r0, r3
 8002652:	f001 fc35 	bl	8003ec0 <_test_assert>
 8002656:	e6a3      	b.n	80023a0 <test_008_002_execute.lto_priv.148+0x30>
 8002658:	2000133c 	.word	0x2000133c
 800265c:	20000860 	.word	0x20000860
 8002660:	08007020 	.word	0x08007020
 8002664:	0800702c 	.word	0x0800702c
 8002668:	08007038 	.word	0x08007038
 800266c:	08007044 	.word	0x08007044
 8002670:	08007068 	.word	0x08007068
 8002674:	20000870 	.word	0x20000870
 8002678:	08006f74 	.word	0x08006f74
 800267c:	0800708c 	.word	0x0800708c
 8002680:	08007098 	.word	0x08007098
 8002684:	080070a4 	.word	0x080070a4
 8002688:	2000087c 	.word	0x2000087c
 800268c:	080070bc 	.word	0x080070bc
 8002690:	080070c4 	.word	0x080070c4
 8002694:	f3af 8000 	nop.w
 8002698:	f3af 8000 	nop.w
 800269c:	f3af 8000 	nop.w

080026a0 <test_007_007_setup.lto_priv.141>:
 *   has been emptied.
 * - [7.7.4] Unregistering from the Event Sources.
 * .
 */

static void test_007_007_setup(void) {
 80026a0:	b508      	push	{r3, lr}
  chEvtGetAndClearEvents(ALL_EVENTS);
 80026a2:	f003 fabd 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
 80026a6:	4a02      	ldr	r2, [pc, #8]	; (80026b0 <test_007_007_setup.lto_priv.141+0x10>)
 80026a8:	4b02      	ldr	r3, [pc, #8]	; (80026b4 <test_007_007_setup.lto_priv.141+0x14>)
 80026aa:	6012      	str	r2, [r2, #0]
 80026ac:	601b      	str	r3, [r3, #0]
 80026ae:	bd08      	pop	{r3, pc}
 80026b0:	20000834 	.word	0x20000834
 80026b4:	20000838 	.word	0x20000838
 80026b8:	f3af 8000 	nop.w
 80026bc:	f3af 8000 	nop.w

080026c0 <test_007_006_setup.lto_priv.139>:
 *   timeout condition is tested.
 * .
 */

static void test_007_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 80026c0:	f003 baae 	b.w	8005c20 <chEvtGetAndClearEvents.constprop.50>
 80026c4:	f3af 8000 	nop.w
 80026c8:	f3af 8000 	nop.w
 80026cc:	f3af 8000 	nop.w

080026d0 <test_007_005_setup.lto_priv.137>:
 *   has been emptied.
 * .
 */

static void test_007_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 80026d0:	f003 baa6 	b.w	8005c20 <chEvtGetAndClearEvents.constprop.50>
 80026d4:	f3af 8000 	nop.w
 80026d8:	f3af 8000 	nop.w
 80026dc:	f3af 8000 	nop.w

080026e0 <test_007_007_execute.lto_priv.142>:
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 80026e0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80026e4:	4d3c      	ldr	r5, [pc, #240]	; (80027d8 <test_007_007_execute.lto_priv.142+0xf8>)
 80026e6:	2301      	movs	r3, #1
  chEvtGetAndClearEvents(ALL_EVENTS);
  chEvtObjectInit(&es1);
  chEvtObjectInit(&es2);
}

static void test_007_007_execute(void) {
 80026e8:	b08b      	sub	sp, #44	; 0x2c
  event_listener_t el1, el2;
  systime_t target_time;

  /* [7.7.1] Registering on two event sources associating them with
     flags 1 and 4.*/
  test_set_step(1);
 80026ea:	602b      	str	r3, [r5, #0]
 80026ec:	2220      	movs	r2, #32
 80026ee:	f382 8811 	msr	BASEPRI, r2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80026f2:	f8df 8104 	ldr.w	r8, [pc, #260]	; 80027f8 <test_007_007_execute.lto_priv.142+0x118>
  esp->next     = elp;
  elp->listener = currp;
 80026f6:	4f39      	ldr	r7, [pc, #228]	; (80027dc <test_007_007_execute.lto_priv.142+0xfc>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 80026f8:	f8d8 0000 	ldr.w	r0, [r8]
  esp->next     = elp;
  elp->listener = currp;
 80026fc:	69b9      	ldr	r1, [r7, #24]
  elp->events   = events;
 80026fe:	9302      	str	r3, [sp, #8]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002700:	ae0a      	add	r6, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002702:	2300      	movs	r3, #0
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002704:	f846 0d28 	str.w	r0, [r6, #-40]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002708:	f04f 30ff 	mov.w	r0, #4294967295
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 800270c:	9101      	str	r1, [sp, #4]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 800270e:	f8c8 6000 	str.w	r6, [r8]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002712:	9303      	str	r3, [sp, #12]
  elp->wflags   = wflags;
 8002714:	9004      	str	r0, [sp, #16]
 8002716:	f383 8811 	msr	BASEPRI, r3
 800271a:	f382 8811 	msr	BASEPRI, r2
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800271e:	f8df 90dc 	ldr.w	r9, [pc, #220]	; 80027fc <test_007_007_execute.lto_priv.142+0x11c>
  esp->next     = elp;
  elp->listener = currp;
 8002722:	69ba      	ldr	r2, [r7, #24]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002724:	f8d9 1000 	ldr.w	r1, [r9]
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002728:	9308      	str	r3, [sp, #32]
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 800272a:	ac0a      	add	r4, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 800272c:	f04f 0a04 	mov.w	sl, #4
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002730:	f844 1d14 	str.w	r1, [r4, #-20]!
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
  elp->wflags   = wflags;
 8002734:	9009      	str	r0, [sp, #36]	; 0x24
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8002736:	9206      	str	r2, [sp, #24]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8002738:	f8c9 4000 	str.w	r4, [r9]
  elp->listener = currp;
  elp->events   = events;
 800273c:	f8cd a01c 	str.w	sl, [sp, #28]
 8002740:	f383 8811 	msr	BASEPRI, r3
  }

  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
 8002744:	2302      	movs	r3, #2
 8002746:	602b      	str	r3, [r5, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002748:	f001 fad2 	bl	8003cf0 <test_wait_tick>
 800274c:	69bb      	ldr	r3, [r7, #24]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 800274e:	4a24      	ldr	r2, [pc, #144]	; (80027e0 <test_007_007_execute.lto_priv.142+0x100>)
 8002750:	6899      	ldr	r1, [r3, #8]
 8002752:	4b24      	ldr	r3, [pc, #144]	; (80027e4 <test_007_007_execute.lto_priv.142+0x104>)
  /* [7.7.2] Getting current time and starting a broadcaster thread,
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002754:	4683      	mov	fp, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002756:	3901      	subs	r1, #1
 8002758:	4823      	ldr	r0, [pc, #140]	; (80027e8 <test_007_007_execute.lto_priv.142+0x108>)
 800275a:	f003 f989 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800275e:	4a23      	ldr	r2, [pc, #140]	; (80027ec <test_007_007_execute.lto_priv.142+0x10c>)
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8002760:	2303      	movs	r3, #3
     the thread broadcast the first Event Source immediately and the
     other after 50mS.*/
  test_set_step(2);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002762:	6010      	str	r0, [r2, #0]
  }

  /* [7.7.3] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(3);
 8002764:	602b      	str	r3, [r5, #0]
  {
    m = chEvtWaitAll(5);
 8002766:	f003 faa3 	bl	8005cb0 <chEvtWaitAll.constprop.44>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 800276a:	f50b 70fa 	add.w	r0, fp, #500	; 0x1f4
 800276e:	f50b 7102 	add.w	r1, fp, #520	; 0x208
 8002772:	f003 fcc5 	bl	8006100 <_test_assert_time_window.constprop.2>
 8002776:	b110      	cbz	r0, 800277e <test_007_007_execute.lto_priv.142+0x9e>
    chEvtUnregister(&es1, &el1);
    chEvtUnregister(&es2, &el2);
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
  }
}
 8002778:	b00b      	add	sp, #44	; 0x2c
 800277a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
  test_set_step(3);
  {
    m = chEvtWaitAll(5);
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800277e:	f003 fa4f 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002782:	491b      	ldr	r1, [pc, #108]	; (80027f0 <test_007_007_execute.lto_priv.142+0x110>)
 8002784:	fab0 f080 	clz	r0, r0
 8002788:	0940      	lsrs	r0, r0, #5
 800278a:	f001 fb99 	bl	8003ec0 <_test_assert>
 800278e:	2800      	cmp	r0, #0
 8002790:	d1f2      	bne.n	8002778 <test_007_007_execute.lto_priv.142+0x98>
    test_wait_threads();
 8002792:	f001 fabd 	bl	8003d10 <test_wait_threads>
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el1);
 8002796:	4631      	mov	r1, r6
 8002798:	4640      	mov	r0, r8
    test_assert(m == 0, "stuck event");
    test_wait_threads();
  }

  /* [7.7.4] Unregistering from the Event Sources.*/
  test_set_step(4);
 800279a:	f8c5 a000 	str.w	sl, [r5]
  {
    chEvtUnregister(&es1, &el1);
 800279e:	f002 fc5f 	bl	8005060 <chEvtUnregister>
    chEvtUnregister(&es2, &el2);
 80027a2:	4648      	mov	r0, r9
 80027a4:	4621      	mov	r1, r4
 80027a6:	f002 fc5b 	bl	8005060 <chEvtUnregister>
    test_assert(!chEvtIsListeningI(&es1), "stuck listener");
 80027aa:	f8d8 0000 	ldr.w	r0, [r8]
 80027ae:	4911      	ldr	r1, [pc, #68]	; (80027f4 <test_007_007_execute.lto_priv.142+0x114>)
 80027b0:	ebc8 0000 	rsb	r0, r8, r0
 80027b4:	fab0 f080 	clz	r0, r0
 80027b8:	0940      	lsrs	r0, r0, #5
 80027ba:	f001 fb81 	bl	8003ec0 <_test_assert>
 80027be:	2800      	cmp	r0, #0
 80027c0:	d1da      	bne.n	8002778 <test_007_007_execute.lto_priv.142+0x98>
    test_assert(!chEvtIsListeningI(&es2), "stuck listener");
 80027c2:	f8d9 0000 	ldr.w	r0, [r9]
 80027c6:	490b      	ldr	r1, [pc, #44]	; (80027f4 <test_007_007_execute.lto_priv.142+0x114>)
 80027c8:	ebc9 0000 	rsb	r0, r9, r0
 80027cc:	fab0 f080 	clz	r0, r0
 80027d0:	0940      	lsrs	r0, r0, #5
 80027d2:	f001 fb75 	bl	8003ec0 <_test_assert>
 80027d6:	e7cf      	b.n	8002778 <test_007_007_execute.lto_priv.142+0x98>
 80027d8:	2000133c 	.word	0x2000133c
 80027dc:	200013b0 	.word	0x200013b0
 80027e0:	08002e51 	.word	0x08002e51
 80027e4:	08006f38 	.word	0x08006f38
 80027e8:	20000c50 	.word	0x20000c50
 80027ec:	20001340 	.word	0x20001340
 80027f0:	080070d8 	.word	0x080070d8
 80027f4:	080070e4 	.word	0x080070e4
 80027f8:	20000834 	.word	0x20000834
 80027fc:	20000838 	.word	0x20000838

08002800 <test_007_006_execute.lto_priv.140>:

static void test_007_006_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_006_execute(void) {
 8002800:	b570      	push	{r4, r5, r6, lr}
  eventmask_t m;

  /* [7.6.1] The functions are invoked first with TIME_IMMEDIATE
     timeout, the timeout condition is tested.*/
  test_set_step(1);
 8002802:	4d57      	ldr	r5, [pc, #348]	; (8002960 <test_007_006_execute.lto_priv.140+0x160>)
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002804:	4c57      	ldr	r4, [pc, #348]	; (8002964 <test_007_006_execute.lto_priv.140+0x164>)
 8002806:	2001      	movs	r0, #1
 8002808:	6028      	str	r0, [r5, #0]
 800280a:	69a2      	ldr	r2, [r4, #24]
 800280c:	2320      	movs	r3, #32
 800280e:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8002812:	6b53      	ldr	r3, [r2, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8002814:	b933      	cbnz	r3, 8002824 <test_007_006_execute.lto_priv.140+0x24>
 8002816:	f383 8811 	msr	BASEPRI, r3
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 800281a:	4953      	ldr	r1, [pc, #332]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 800281c:	f001 fb50 	bl	8003ec0 <_test_assert>
 8002820:	b180      	cbz	r0, 8002844 <test_007_006_execute.lto_priv.140+0x44>
 8002822:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  m ^= m & (m - (eventmask_t)1);
 8002824:	4258      	negs	r0, r3
 8002826:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8002828:	ea23 0300 	bic.w	r3, r3, r0
 800282c:	6353      	str	r3, [r2, #52]	; 0x34
 800282e:	2300      	movs	r3, #0
 8002830:	f383 8811 	msr	BASEPRI, r3
 8002834:	494c      	ldr	r1, [pc, #304]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 8002836:	fab0 f080 	clz	r0, r0
 800283a:	0940      	lsrs	r0, r0, #5
 800283c:	f001 fb40 	bl	8003ec0 <_test_assert>
 8002840:	2800      	cmp	r0, #0
 8002842:	d1ee      	bne.n	8002822 <test_007_006_execute.lto_priv.140+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002844:	69a3      	ldr	r3, [r4, #24]
 8002846:	2220      	movs	r2, #32
 8002848:	f382 8811 	msr	BASEPRI, r2
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
 800284c:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800284e:	2a00      	cmp	r2, #0
 8002850:	d072      	beq.n	8002938 <test_007_006_execute.lto_priv.140+0x138>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
  }
  ctp->epending &= ~m;
 8002852:	6358      	str	r0, [r3, #52]	; 0x34
 8002854:	f380 8811 	msr	BASEPRI, r0
    m = chEvtWaitAnyTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002858:	4943      	ldr	r1, [pc, #268]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 800285a:	f001 fb31 	bl	8003ec0 <_test_assert>
 800285e:	2800      	cmp	r0, #0
 8002860:	d1df      	bne.n	8002822 <test_007_006_execute.lto_priv.140+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002862:	69a3      	ldr	r3, [r4, #24]
 8002864:	2220      	movs	r2, #32
 8002866:	f382 8811 	msr	BASEPRI, r2

  chSysLock();
  if ((ctp->epending & events) != events) {
 800286a:	6b5a      	ldr	r2, [r3, #52]	; 0x34
 800286c:	3201      	adds	r2, #1
 800286e:	d067      	beq.n	8002940 <test_007_006_execute.lto_priv.140+0x140>
 8002870:	f380 8811 	msr	BASEPRI, r0
 8002874:	2001      	movs	r0, #1
    m = chEvtWaitAllTimeout(ALL_EVENTS, TIME_IMMEDIATE);
    test_assert(m == 0, "spurious event");
 8002876:	493c      	ldr	r1, [pc, #240]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 8002878:	f001 fb22 	bl	8003ec0 <_test_assert>
 800287c:	2800      	cmp	r0, #0
 800287e:	d1d0      	bne.n	8002822 <test_007_006_execute.lto_priv.140+0x22>
  }

  /* [7.6.2] The functions are invoked first with a 50mS timeout, the
     timeout condition is tested.*/
  test_set_step(2);
 8002880:	2302      	movs	r3, #2
 8002882:	602b      	str	r3, [r5, #0]
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitOneTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002884:	69a6      	ldr	r6, [r4, #24]
 8002886:	2320      	movs	r3, #32
 8002888:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 800288c:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 800288e:	b955      	cbnz	r5, 80028a6 <test_007_006_execute.lto_priv.140+0xa6>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002890:	f04f 33ff 	mov.w	r3, #4294967295
 8002894:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 8002896:	200a      	movs	r0, #10
 8002898:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800289c:	f002 ffa8 	bl	80057f0 <chSchGoSleepTimeoutS>
 80028a0:	2800      	cmp	r0, #0
 80028a2:	db51      	blt.n	8002948 <test_007_006_execute.lto_priv.140+0x148>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 80028a4:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 80028a6:	4268      	negs	r0, r5
 80028a8:	4028      	ands	r0, r5
  ctp->epending &= ~m;
 80028aa:	ea25 0500 	bic.w	r5, r5, r0
 80028ae:	6375      	str	r5, [r6, #52]	; 0x34
 80028b0:	2300      	movs	r3, #0
 80028b2:	f383 8811 	msr	BASEPRI, r3
 80028b6:	fab0 f080 	clz	r0, r0
 80028ba:	0940      	lsrs	r0, r0, #5
  {
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80028bc:	492a      	ldr	r1, [pc, #168]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 80028be:	f001 faff 	bl	8003ec0 <_test_assert>
 80028c2:	2800      	cmp	r0, #0
 80028c4:	d1ad      	bne.n	8002822 <test_007_006_execute.lto_priv.140+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAnyTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 80028c6:	69a6      	ldr	r6, [r4, #24]
 80028c8:	2320      	movs	r3, #32
 80028ca:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 80028ce:	6b75      	ldr	r5, [r6, #52]	; 0x34
  if (m == (eventmask_t)0) {
 80028d0:	b955      	cbnz	r5, 80028e8 <test_007_006_execute.lto_priv.140+0xe8>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 80028d2:	f04f 33ff 	mov.w	r3, #4294967295
 80028d6:	6273      	str	r3, [r6, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTOREVT, time) < MSG_OK) {
 80028d8:	200a      	movs	r0, #10
 80028da:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80028de:	f002 ff87 	bl	80057f0 <chSchGoSleepTimeoutS>
 80028e2:	2800      	cmp	r0, #0
 80028e4:	db34      	blt.n	8002950 <test_007_006_execute.lto_priv.140+0x150>
      chSysUnlock();
      return (eventmask_t)0;
    }
    m = ctp->epending & events;
 80028e6:	6b75      	ldr	r5, [r6, #52]	; 0x34
  }
  ctp->epending &= ~m;
 80028e8:	2300      	movs	r3, #0
 80028ea:	6373      	str	r3, [r6, #52]	; 0x34
 80028ec:	f383 8811 	msr	BASEPRI, r3
 80028f0:	fab5 f085 	clz	r0, r5
 80028f4:	0940      	lsrs	r0, r0, #5
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 80028f6:	491c      	ldr	r1, [pc, #112]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
 80028f8:	f001 fae2 	bl	8003ec0 <_test_assert>
 80028fc:	4605      	mov	r5, r0
 80028fe:	2800      	cmp	r0, #0
 8002900:	d18f      	bne.n	8002822 <test_007_006_execute.lto_priv.140+0x22>
 * @retval 0            if the operation has timed out.
 *
 * @api
 */
eventmask_t chEvtWaitAllTimeout(eventmask_t events, systime_t time) {
  thread_t *ctp = currp;
 8002902:	69a4      	ldr	r4, [r4, #24]
 8002904:	2320      	movs	r3, #32
 8002906:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 800290a:	6b63      	ldr	r3, [r4, #52]	; 0x34
 800290c:	3301      	adds	r3, #1
 800290e:	d009      	beq.n	8002924 <test_007_006_execute.lto_priv.140+0x124>
    if (TIME_IMMEDIATE == time) {
      chSysUnlock();
      return (eventmask_t)0;
    }
    ctp->u.ewmask = events;
 8002910:	f04f 33ff 	mov.w	r3, #4294967295
 8002914:	6263      	str	r3, [r4, #36]	; 0x24
    if (chSchGoSleepTimeoutS(CH_STATE_WTANDEVT, time) < MSG_OK) {
 8002916:	200b      	movs	r0, #11
 8002918:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 800291c:	f002 ff68 	bl	80057f0 <chSchGoSleepTimeoutS>
 8002920:	2800      	cmp	r0, #0
 8002922:	db19      	blt.n	8002958 <test_007_006_execute.lto_priv.140+0x158>
      chSysUnlock();
      return (eventmask_t)0;
    }
  }
  ctp->epending &= ~events;
 8002924:	2300      	movs	r3, #0
 8002926:	6363      	str	r3, [r4, #52]	; 0x34
 8002928:	f383 8811 	msr	BASEPRI, r3
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 800292c:	4628      	mov	r0, r5
 800292e:	490e      	ldr	r1, [pc, #56]	; (8002968 <test_007_006_execute.lto_priv.140+0x168>)
  }
}
 8002930:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    m = chEvtWaitOneTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAnyTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
    m = chEvtWaitAllTimeout(ALL_EVENTS, MS2ST(50));
    test_assert(m == 0, "spurious event");
 8002934:	f001 bac4 	b.w	8003ec0 <_test_assert>
 8002938:	f380 8811 	msr	BASEPRI, r0
 800293c:	2001      	movs	r0, #1
 800293e:	e78b      	b.n	8002858 <test_007_006_execute.lto_priv.140+0x58>
 8002940:	6358      	str	r0, [r3, #52]	; 0x34
 8002942:	f380 8811 	msr	BASEPRI, r0
 8002946:	e796      	b.n	8002876 <test_007_006_execute.lto_priv.140+0x76>
 8002948:	f385 8811 	msr	BASEPRI, r5
 800294c:	2001      	movs	r0, #1
 800294e:	e7b5      	b.n	80028bc <test_007_006_execute.lto_priv.140+0xbc>
 8002950:	f385 8811 	msr	BASEPRI, r5
 8002954:	2001      	movs	r0, #1
 8002956:	e7ce      	b.n	80028f6 <test_007_006_execute.lto_priv.140+0xf6>
 8002958:	f385 8811 	msr	BASEPRI, r5
 800295c:	2501      	movs	r5, #1
 800295e:	e7e5      	b.n	800292c <test_007_006_execute.lto_priv.140+0x12c>
 8002960:	2000133c 	.word	0x2000133c
 8002964:	200013b0 	.word	0x200013b0
 8002968:	080070f4 	.word	0x080070f4
 800296c:	f3af 8000 	nop.w

08002970 <test_007_005_execute.lto_priv.138>:

static void test_007_005_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_005_execute(void) {
 8002970:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002972:	4c2b      	ldr	r4, [pc, #172]	; (8002a20 <test_007_005_execute.lto_priv.138+0xb0>)
 8002974:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8002976:	2005      	movs	r0, #5
static void test_007_005_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.5.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002978:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 800297a:	f002 fb61 	bl	8005040 <chEvtAddEvents>
  }

  /* [7.5.2] Calling chEvtWaitAll() one time, the two flags must be
     returned.*/
  test_set_step(2);
 800297e:	2302      	movs	r3, #2
 8002980:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAll(5);
 8002982:	f003 f995 	bl	8005cb0 <chEvtWaitAll.constprop.44>
    test_assert(m == 5, "unexpected pending bit");
 8002986:	4927      	ldr	r1, [pc, #156]	; (8002a24 <test_007_005_execute.lto_priv.138+0xb4>)
 8002988:	f1a0 0005 	sub.w	r0, r0, #5
 800298c:	fab0 f080 	clz	r0, r0
 8002990:	0940      	lsrs	r0, r0, #5
 8002992:	f001 fa95 	bl	8003ec0 <_test_assert>
 8002996:	b100      	cbz	r0, 800299a <test_007_005_execute.lto_priv.138+0x2a>
 8002998:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 800299a:	f003 f941 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 800299e:	4922      	ldr	r1, [pc, #136]	; (8002a28 <test_007_005_execute.lto_priv.138+0xb8>)
 80029a0:	fab0 f080 	clz	r0, r0
 80029a4:	0940      	lsrs	r0, r0, #5
 80029a6:	f001 fa8b 	bl	8003ec0 <_test_assert>
 80029aa:	2800      	cmp	r0, #0
 80029ac:	d1f4      	bne.n	8002998 <test_007_005_execute.lto_priv.138+0x28>
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 80029ae:	2303      	movs	r3, #3
  {
    chEvtAddEvents(4);
 80029b0:	2004      	movs	r0, #4
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
  }

  /* [7.5.3] Setting one event flag.*/
  test_set_step(3);
 80029b2:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(4);
 80029b4:	f002 fb44 	bl	8005040 <chEvtAddEvents>
  }

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
 80029b8:	2304      	movs	r3, #4
 80029ba:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 80029bc:	f001 f998 	bl	8003cf0 <test_wait_tick>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80029c0:	4b1a      	ldr	r3, [pc, #104]	; (8002a2c <test_007_005_execute.lto_priv.138+0xbc>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80029c2:	4a1b      	ldr	r2, [pc, #108]	; (8002a30 <test_007_005_execute.lto_priv.138+0xc0>)
 80029c4:	699b      	ldr	r3, [r3, #24]
 80029c6:	6899      	ldr	r1, [r3, #8]

  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
 80029c8:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80029ca:	3901      	subs	r1, #1
 80029cc:	4819      	ldr	r0, [pc, #100]	; (8002a34 <test_007_005_execute.lto_priv.138+0xc4>)
 80029ce:	f003 f84f 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80029d2:	4a19      	ldr	r2, [pc, #100]	; (8002a38 <test_007_005_execute.lto_priv.138+0xc8>)
  }

  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
 80029d4:	2305      	movs	r3, #5
 80029d6:	6023      	str	r3, [r4, #0]
  /* [7.5.4] Getting current time and starting a signaler thread, the
     thread will set another event flag after 50mS.*/
  test_set_step(4);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 80029d8:	6010      	str	r0, [r2, #0]
  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 80029da:	f003 f969 	bl	8005cb0 <chEvtWaitAll.constprop.44>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80029de:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.5.5] Calling chEvtWaitAll() then verifying that both event
     flags have been received after 50mS and that the event flags mask
     has been emptied.*/
  test_set_step(5);
  {
    m = chEvtWaitAll(5);
 80029e2:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 80029e4:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 80029e8:	f003 fb8a 	bl	8006100 <_test_assert_time_window.constprop.2>
 80029ec:	2800      	cmp	r0, #0
 80029ee:	d1d3      	bne.n	8002998 <test_007_005_execute.lto_priv.138+0x28>
                            "out of time window");
    test_assert(m == 5, "event flags error");
 80029f0:	f1a4 0005 	sub.w	r0, r4, #5
 80029f4:	4911      	ldr	r1, [pc, #68]	; (8002a3c <test_007_005_execute.lto_priv.138+0xcc>)
 80029f6:	fab0 f080 	clz	r0, r0
 80029fa:	0940      	lsrs	r0, r0, #5
 80029fc:	f001 fa60 	bl	8003ec0 <_test_assert>
 8002a00:	2800      	cmp	r0, #0
 8002a02:	d1c9      	bne.n	8002998 <test_007_005_execute.lto_priv.138+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002a04:	f003 f90c 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002a08:	4907      	ldr	r1, [pc, #28]	; (8002a28 <test_007_005_execute.lto_priv.138+0xb8>)
 8002a0a:	fab0 f080 	clz	r0, r0
 8002a0e:	0940      	lsrs	r0, r0, #5
 8002a10:	f001 fa56 	bl	8003ec0 <_test_assert>
 8002a14:	2800      	cmp	r0, #0
 8002a16:	d1bf      	bne.n	8002998 <test_007_005_execute.lto_priv.138+0x28>
    test_wait_threads();
  }
}
 8002a18:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 5, "event flags error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8002a1c:	f001 b978 	b.w	8003d10 <test_wait_threads>
 8002a20:	2000133c 	.word	0x2000133c
 8002a24:	08007104 	.word	0x08007104
 8002a28:	080070d8 	.word	0x080070d8
 8002a2c:	200013b0 	.word	0x200013b0
 8002a30:	08002e91 	.word	0x08002e91
 8002a34:	20000c50 	.word	0x20000c50
 8002a38:	20001340 	.word	0x20001340
 8002a3c:	0800711c 	.word	0x0800711c

08002a40 <test_005_009_setup.lto_priv.127>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002a40:	4a06      	ldr	r2, [pc, #24]	; (8002a5c <test_005_009_setup.lto_priv.127+0x1c>)
 8002a42:	4b07      	ldr	r3, [pc, #28]	; (8002a60 <test_005_009_setup.lto_priv.127+0x20>)
 8002a44:	4907      	ldr	r1, [pc, #28]	; (8002a64 <test_005_009_setup.lto_priv.127+0x24>)
 8002a46:	6012      	str	r2, [r2, #0]
 8002a48:	2000      	movs	r0, #0
 8002a4a:	6009      	str	r1, [r1, #0]
  tqp->prev = (thread_t *)tqp;
 8002a4c:	6049      	str	r1, [r1, #4]
 8002a4e:	6052      	str	r2, [r2, #4]
 8002a50:	6090      	str	r0, [r2, #8]
 8002a52:	6098      	str	r0, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002a54:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002a56:	605b      	str	r3, [r3, #4]
 8002a58:	4770      	bx	lr
 8002a5a:	bf00      	nop
 8002a5c:	200008a0 	.word	0x200008a0
 8002a60:	2000083c 	.word	0x2000083c
 8002a64:	20000858 	.word	0x20000858
 8002a68:	f3af 8000 	nop.w
 8002a6c:	f3af 8000 	nop.w

08002a70 <test_005_008_setup.lto_priv.125>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002a70:	4b04      	ldr	r3, [pc, #16]	; (8002a84 <test_005_008_setup.lto_priv.125+0x14>)
 8002a72:	4a05      	ldr	r2, [pc, #20]	; (8002a88 <test_005_008_setup.lto_priv.125+0x18>)
 8002a74:	601b      	str	r3, [r3, #0]
 8002a76:	2100      	movs	r1, #0
 8002a78:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8002a7a:	6052      	str	r2, [r2, #4]
 8002a7c:	605b      	str	r3, [r3, #4]
 8002a7e:	6099      	str	r1, [r3, #8]
 8002a80:	4770      	bx	lr
 8002a82:	bf00      	nop
 8002a84:	200008a0 	.word	0x200008a0
 8002a88:	20000858 	.word	0x20000858
 8002a8c:	f3af 8000 	nop.w

08002a90 <test_005_007_setup.lto_priv.123>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002a90:	4b04      	ldr	r3, [pc, #16]	; (8002aa4 <test_005_007_setup.lto_priv.123+0x14>)
 8002a92:	4a05      	ldr	r2, [pc, #20]	; (8002aa8 <test_005_007_setup.lto_priv.123+0x18>)
 8002a94:	601b      	str	r3, [r3, #0]
 8002a96:	2100      	movs	r1, #0
 8002a98:	6012      	str	r2, [r2, #0]
  tqp->prev = (thread_t *)tqp;
 8002a9a:	6052      	str	r2, [r2, #4]
 8002a9c:	605b      	str	r3, [r3, #4]
 8002a9e:	6099      	str	r1, [r3, #8]
 8002aa0:	4770      	bx	lr
 8002aa2:	bf00      	nop
 8002aa4:	200008a0 	.word	0x200008a0
 8002aa8:	20000858 	.word	0x20000858
 8002aac:	f3af 8000 	nop.w

08002ab0 <test_005_005_setup.lto_priv.121>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ab0:	4b02      	ldr	r3, [pc, #8]	; (8002abc <test_005_005_setup.lto_priv.121+0xc>)
 8002ab2:	2200      	movs	r2, #0
 8002ab4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ab6:	605b      	str	r3, [r3, #4]
 8002ab8:	609a      	str	r2, [r3, #8]
 8002aba:	4770      	bx	lr
 8002abc:	200008a0 	.word	0x200008a0

08002ac0 <test_005_004_setup.lto_priv.118>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ac0:	4a04      	ldr	r2, [pc, #16]	; (8002ad4 <test_005_004_setup.lto_priv.118+0x14>)
 8002ac2:	4b05      	ldr	r3, [pc, #20]	; (8002ad8 <test_005_004_setup.lto_priv.118+0x18>)
 8002ac4:	6012      	str	r2, [r2, #0]
 8002ac6:	2100      	movs	r1, #0
  tqp->prev = (thread_t *)tqp;
 8002ac8:	6052      	str	r2, [r2, #4]
 8002aca:	6091      	str	r1, [r2, #8]
 8002acc:	6099      	str	r1, [r3, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ace:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ad0:	605b      	str	r3, [r3, #4]
 8002ad2:	4770      	bx	lr
 8002ad4:	200008a0 	.word	0x200008a0
 8002ad8:	2000083c 	.word	0x2000083c
 8002adc:	f3af 8000 	nop.w

08002ae0 <test_005_001_setup.lto_priv.116>:
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8002ae0:	4b02      	ldr	r3, [pc, #8]	; (8002aec <test_005_001_setup.lto_priv.116+0xc>)
 8002ae2:	2200      	movs	r2, #0
 8002ae4:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8002ae6:	605b      	str	r3, [r3, #4]
 8002ae8:	609a      	str	r2, [r3, #8]
 8002aea:	4770      	bx	lr
 8002aec:	200008a0 	.word	0x200008a0

08002af0 <test_007_004_setup.lto_priv.135>:
 *   emptied.
 * .
 */

static void test_007_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002af0:	f003 b896 	b.w	8005c20 <chEvtGetAndClearEvents.constprop.50>
 8002af4:	f3af 8000 	nop.w
 8002af8:	f3af 8000 	nop.w
 8002afc:	f3af 8000 	nop.w

08002b00 <test_007_003_setup.lto_priv.133>:
 *   emptied.
 * .
 */

static void test_007_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002b00:	f003 b88e 	b.w	8005c20 <chEvtGetAndClearEvents.constprop.50>
 8002b04:	f3af 8000 	nop.w
 8002b08:	f3af 8000 	nop.w
 8002b0c:	f3af 8000 	nop.w

08002b10 <test_007_002_setup.lto_priv.131>:
 *   invoked, the sequence of handlers calls is tested.
 * .
 */

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
 8002b10:	f003 b886 	b.w	8005c20 <chEvtGetAndClearEvents.constprop.50>
 8002b14:	f3af 8000 	nop.w
 8002b18:	f3af 8000 	nop.w
 8002b1c:	f3af 8000 	nop.w

08002b20 <test_007_004_execute.lto_priv.136>:

static void test_007_004_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_004_execute(void) {
 8002b20:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002b22:	4c29      	ldr	r4, [pc, #164]	; (8002bc8 <test_007_004_execute.lto_priv.136+0xa8>)
 8002b24:	2301      	movs	r3, #1
  {
    chEvtAddEvents(5);
 8002b26:	2005      	movs	r0, #5
static void test_007_004_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.4.1] Setting two, non contiguous, event flags.*/
  test_set_step(1);
 8002b28:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(5);
 8002b2a:	f002 fa89 	bl	8005040 <chEvtAddEvents>
  }

  /* [7.4.2] Calling chEvtWaitAny() one time, the two flags must be
     returned.*/
  test_set_step(2);
 8002b2e:	2302      	movs	r3, #2
 8002b30:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8002b32:	f003 f8a5 	bl	8005c80 <chEvtWaitAny.constprop.45>
    test_assert(m == 5, "unexpected pending bit");
 8002b36:	4925      	ldr	r1, [pc, #148]	; (8002bcc <test_007_004_execute.lto_priv.136+0xac>)
 8002b38:	f1a0 0005 	sub.w	r0, r0, #5
 8002b3c:	fab0 f080 	clz	r0, r0
 8002b40:	0940      	lsrs	r0, r0, #5
 8002b42:	f001 f9bd 	bl	8003ec0 <_test_assert>
 8002b46:	b100      	cbz	r0, 8002b4a <test_007_004_execute.lto_priv.136+0x2a>
 8002b48:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002b4a:	f003 f869 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002b4e:	4920      	ldr	r1, [pc, #128]	; (8002bd0 <test_007_004_execute.lto_priv.136+0xb0>)
 8002b50:	fab0 f080 	clz	r0, r0
 8002b54:	0940      	lsrs	r0, r0, #5
 8002b56:	f001 f9b3 	bl	8003ec0 <_test_assert>
 8002b5a:	2800      	cmp	r0, #0
 8002b5c:	d1f4      	bne.n	8002b48 <test_007_004_execute.lto_priv.136+0x28>
  }

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8002b5e:	2303      	movs	r3, #3
 8002b60:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002b62:	f001 f8c5 	bl	8003cf0 <test_wait_tick>
 8002b66:	4b1b      	ldr	r3, [pc, #108]	; (8002bd4 <test_007_004_execute.lto_priv.136+0xb4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002b68:	4a1b      	ldr	r2, [pc, #108]	; (8002bd8 <test_007_004_execute.lto_priv.136+0xb8>)
 8002b6a:	699b      	ldr	r3, [r3, #24]
 8002b6c:	6899      	ldr	r1, [r3, #8]

  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002b6e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002b70:	3901      	subs	r1, #1
 8002b72:	481a      	ldr	r0, [pc, #104]	; (8002bdc <test_007_004_execute.lto_priv.136+0xbc>)
 8002b74:	f002 ff7c 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8002b78:	4a19      	ldr	r2, [pc, #100]	; (8002be0 <test_007_004_execute.lto_priv.136+0xc0>)
  }

  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8002b7a:	2304      	movs	r3, #4
 8002b7c:	6023      	str	r3, [r4, #0]
  /* [7.4.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002b7e:	6010      	str	r0, [r2, #0]
  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8002b80:	f003 f87e 	bl	8005c80 <chEvtWaitAny.constprop.45>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8002b84:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.4.4] Calling chEvtWaitAny() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitAny(ALL_EVENTS);
 8002b88:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8002b8a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8002b8e:	f003 fab7 	bl	8006100 <_test_assert_time_window.constprop.2>
 8002b92:	2800      	cmp	r0, #0
 8002b94:	d1d8      	bne.n	8002b48 <test_007_004_execute.lto_priv.136+0x28>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8002b96:	f1a4 0001 	sub.w	r0, r4, #1
 8002b9a:	4912      	ldr	r1, [pc, #72]	; (8002be4 <test_007_004_execute.lto_priv.136+0xc4>)
 8002b9c:	fab0 f080 	clz	r0, r0
 8002ba0:	0940      	lsrs	r0, r0, #5
 8002ba2:	f001 f98d 	bl	8003ec0 <_test_assert>
 8002ba6:	2800      	cmp	r0, #0
 8002ba8:	d1ce      	bne.n	8002b48 <test_007_004_execute.lto_priv.136+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002baa:	f003 f839 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002bae:	4908      	ldr	r1, [pc, #32]	; (8002bd0 <test_007_004_execute.lto_priv.136+0xb0>)
 8002bb0:	fab0 f080 	clz	r0, r0
 8002bb4:	0940      	lsrs	r0, r0, #5
 8002bb6:	f001 f983 	bl	8003ec0 <_test_assert>
 8002bba:	2800      	cmp	r0, #0
 8002bbc:	d1c4      	bne.n	8002b48 <test_007_004_execute.lto_priv.136+0x28>
    test_wait_threads();
  }
}
 8002bbe:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8002bc2:	f001 b8a5 	b.w	8003d10 <test_wait_threads>
 8002bc6:	bf00      	nop
 8002bc8:	2000133c 	.word	0x2000133c
 8002bcc:	08007104 	.word	0x08007104
 8002bd0:	080070d8 	.word	0x080070d8
 8002bd4:	200013b0 	.word	0x200013b0
 8002bd8:	08002e91 	.word	0x08002e91
 8002bdc:	20000c50 	.word	0x20000c50
 8002be0:	20001340 	.word	0x20001340
 8002be4:	08007130 	.word	0x08007130
 8002be8:	f3af 8000 	nop.w
 8002bec:	f3af 8000 	nop.w

08002bf0 <test_005_004_teardown.lto_priv.119>:
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_004_teardown(void) {
  test_wait_threads();
 8002bf0:	f001 b88e 	b.w	8003d10 <test_wait_threads>
 8002bf4:	f3af 8000 	nop.w
 8002bf8:	f3af 8000 	nop.w
 8002bfc:	f3af 8000 	nop.w

08002c00 <test_007_003_execute.lto_priv.134>:

static void test_007_003_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_003_execute(void) {
 8002c00:	b538      	push	{r3, r4, r5, lr}
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8002c02:	4c35      	ldr	r4, [pc, #212]	; (8002cd8 <test_007_003_execute.lto_priv.134+0xd8>)
 8002c04:	2301      	movs	r3, #1
  {
    chEvtAddEvents(7);
 8002c06:	2007      	movs	r0, #7
static void test_007_003_execute(void) {
  eventmask_t m;
  systime_t target_time;

  /* [7.3.1] Setting three event flags.*/
  test_set_step(1);
 8002c08:	6023      	str	r3, [r4, #0]
  {
    chEvtAddEvents(7);
 8002c0a:	f002 fa19 	bl	8005040 <chEvtAddEvents>
  }

  /* [7.3.2] Calling chEvtWaitOne() three times, each time a single
     flag must be returned in order of priority.*/
  test_set_step(2);
 8002c0e:	2302      	movs	r3, #2
 8002c10:	6023      	str	r3, [r4, #0]
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8002c12:	f003 f815 	bl	8005c40 <chEvtWaitOne.constprop.46>
    test_assert(m == 1, "single event error");
 8002c16:	4931      	ldr	r1, [pc, #196]	; (8002cdc <test_007_003_execute.lto_priv.134+0xdc>)
 8002c18:	f1a0 0001 	sub.w	r0, r0, #1
 8002c1c:	fab0 f080 	clz	r0, r0
 8002c20:	0940      	lsrs	r0, r0, #5
 8002c22:	f001 f94d 	bl	8003ec0 <_test_assert>
 8002c26:	b100      	cbz	r0, 8002c2a <test_007_003_execute.lto_priv.134+0x2a>
 8002c28:	bd38      	pop	{r3, r4, r5, pc}
    m = chEvtWaitOne(ALL_EVENTS);
 8002c2a:	f003 f809 	bl	8005c40 <chEvtWaitOne.constprop.46>
    test_assert(m == 2, "single event error");
 8002c2e:	492b      	ldr	r1, [pc, #172]	; (8002cdc <test_007_003_execute.lto_priv.134+0xdc>)
 8002c30:	f1a0 0002 	sub.w	r0, r0, #2
 8002c34:	fab0 f080 	clz	r0, r0
 8002c38:	0940      	lsrs	r0, r0, #5
 8002c3a:	f001 f941 	bl	8003ec0 <_test_assert>
 8002c3e:	2800      	cmp	r0, #0
 8002c40:	d1f2      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
    m = chEvtWaitOne(ALL_EVENTS);
 8002c42:	f002 fffd 	bl	8005c40 <chEvtWaitOne.constprop.46>
    test_assert(m == 4, "single event error");
 8002c46:	4925      	ldr	r1, [pc, #148]	; (8002cdc <test_007_003_execute.lto_priv.134+0xdc>)
 8002c48:	f1a0 0004 	sub.w	r0, r0, #4
 8002c4c:	fab0 f080 	clz	r0, r0
 8002c50:	0940      	lsrs	r0, r0, #5
 8002c52:	f001 f935 	bl	8003ec0 <_test_assert>
 8002c56:	2800      	cmp	r0, #0
 8002c58:	d1e6      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002c5a:	f002 ffe1 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002c5e:	4920      	ldr	r1, [pc, #128]	; (8002ce0 <test_007_003_execute.lto_priv.134+0xe0>)
 8002c60:	fab0 f080 	clz	r0, r0
 8002c64:	0940      	lsrs	r0, r0, #5
 8002c66:	f001 f92b 	bl	8003ec0 <_test_assert>
 8002c6a:	2800      	cmp	r0, #0
 8002c6c:	d1dc      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
  }

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
 8002c6e:	2303      	movs	r3, #3
 8002c70:	6023      	str	r3, [r4, #0]
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002c72:	f001 f83d 	bl	8003cf0 <test_wait_tick>
 8002c76:	4b1b      	ldr	r3, [pc, #108]	; (8002ce4 <test_007_003_execute.lto_priv.134+0xe4>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002c78:	4a1b      	ldr	r2, [pc, #108]	; (8002ce8 <test_007_003_execute.lto_priv.134+0xe8>)
 8002c7a:	699b      	ldr	r3, [r3, #24]
 8002c7c:	6899      	ldr	r1, [r3, #8]

  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
 8002c7e:	4605      	mov	r5, r0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002c80:	3901      	subs	r1, #1
 8002c82:	481a      	ldr	r0, [pc, #104]	; (8002cec <test_007_003_execute.lto_priv.134+0xec>)
 8002c84:	f002 fef4 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8002c88:	4a19      	ldr	r2, [pc, #100]	; (8002cf0 <test_007_003_execute.lto_priv.134+0xf0>)
  }

  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
 8002c8a:	2304      	movs	r3, #4
 8002c8c:	6023      	str	r3, [r4, #0]
  /* [7.3.3] Getting current time and starting a signaler thread, the
     thread will set an event flag after 50mS.*/
  test_set_step(3);
  {
    target_time = test_wait_tick() + MS2ST(50);
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() - 1,
 8002c8e:	6010      	str	r0, [r2, #0]
  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8002c90:	f002 ffd6 	bl	8005c40 <chEvtWaitOne.constprop.46>
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8002c94:	f505 7102 	add.w	r1, r5, #520	; 0x208
  /* [7.3.4] Calling chEvtWaitOne() then verifying that the event has
     been received after 50mS and that the event flags mask has been
     emptied.*/
  test_set_step(4);
  {
    m = chEvtWaitOne(ALL_EVENTS);
 8002c98:	4604      	mov	r4, r0
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
 8002c9a:	f505 70fa 	add.w	r0, r5, #500	; 0x1f4
 8002c9e:	f003 fa2f 	bl	8006100 <_test_assert_time_window.constprop.2>
 8002ca2:	2800      	cmp	r0, #0
 8002ca4:	d1c0      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
                            "out of time window");
    test_assert(m == 1, "event flag error");
 8002ca6:	f1a4 0001 	sub.w	r0, r4, #1
 8002caa:	4912      	ldr	r1, [pc, #72]	; (8002cf4 <test_007_003_execute.lto_priv.134+0xf4>)
 8002cac:	fab0 f080 	clz	r0, r0
 8002cb0:	0940      	lsrs	r0, r0, #5
 8002cb2:	f001 f905 	bl	8003ec0 <_test_assert>
 8002cb6:	2800      	cmp	r0, #0
 8002cb8:	d1b6      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
    m = chEvtGetAndClearEvents(ALL_EVENTS);
 8002cba:	f002 ffb1 	bl	8005c20 <chEvtGetAndClearEvents.constprop.50>
    test_assert(m == 0, "stuck event");
 8002cbe:	4908      	ldr	r1, [pc, #32]	; (8002ce0 <test_007_003_execute.lto_priv.134+0xe0>)
 8002cc0:	fab0 f080 	clz	r0, r0
 8002cc4:	0940      	lsrs	r0, r0, #5
 8002cc6:	f001 f8fb 	bl	8003ec0 <_test_assert>
 8002cca:	2800      	cmp	r0, #0
 8002ccc:	d1ac      	bne.n	8002c28 <test_007_003_execute.lto_priv.134+0x28>
    test_wait_threads();
  }
}
 8002cce:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    test_assert_time_window(target_time, target_time + ALLOWED_DELAY,
                            "out of time window");
    test_assert(m == 1, "event flag error");
    m = chEvtGetAndClearEvents(ALL_EVENTS);
    test_assert(m == 0, "stuck event");
    test_wait_threads();
 8002cd2:	f001 b81d 	b.w	8003d10 <test_wait_threads>
 8002cd6:	bf00      	nop
 8002cd8:	2000133c 	.word	0x2000133c
 8002cdc:	08007144 	.word	0x08007144
 8002ce0:	080070d8 	.word	0x080070d8
 8002ce4:	200013b0 	.word	0x200013b0
 8002ce8:	08002e91 	.word	0x08002e91
 8002cec:	20000c50 	.word	0x20000c50
 8002cf0:	20001340 	.word	0x20001340
 8002cf4:	08007130 	.word	0x08007130
 8002cf8:	f3af 8000 	nop.w
 8002cfc:	f3af 8000 	nop.w

08002d00 <test_007_002_execute.lto_priv.132>:

static void test_007_002_setup(void) {
  chEvtGetAndClearEvents(ALL_EVENTS);
}

static void test_007_002_execute(void) {
 8002d00:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
 8002d02:	4b0f      	ldr	r3, [pc, #60]	; (8002d40 <test_007_002_execute.lto_priv.132+0x40>)
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8002d04:	4f0f      	ldr	r7, [pc, #60]	; (8002d44 <test_007_002_execute.lto_priv.132+0x44>)
 8002d06:	2601      	movs	r6, #1
 8002d08:	601e      	str	r6, [r3, #0]
void chEvtDispatch(const evhandler_t *handlers, eventmask_t events) {
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
 8002d0a:	2400      	movs	r4, #0
 8002d0c:	2507      	movs	r5, #7
 8002d0e:	e001      	b.n	8002d14 <test_007_002_execute.lto_priv.132+0x14>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
    }
    eid++;
 8002d10:	3401      	adds	r4, #1
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002d12:	b175      	cbz	r5, 8002d32 <test_007_002_execute.lto_priv.132+0x32>
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
 8002d14:	fa25 f304 	lsr.w	r3, r5, r4
 8002d18:	07db      	lsls	r3, r3, #31
 8002d1a:	d5f9      	bpl.n	8002d10 <test_007_002_execute.lto_priv.132+0x10>
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002d1c:	fa06 f304 	lsl.w	r3, r6, r4
      handlers[eid](eid);
 8002d20:	f857 2024 	ldr.w	r2, [r7, r4, lsl #2]
 8002d24:	4620      	mov	r0, r4

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
 8002d26:	ea25 0503 	bic.w	r5, r5, r3
      handlers[eid](eid);
    }
    eid++;
 8002d2a:	3401      	adds	r4, #1
  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
    if ((events & EVENT_MASK(eid)) != (eventmask_t)0) {
      chDbgAssert(handlers[eid] != NULL, "null handler");
      events &= ~EVENT_MASK(eid);
      handlers[eid](eid);
 8002d2c:	4790      	blx	r2
  eventid_t eid;

  chDbgCheck(handlers != NULL);

  eid = (eventid_t)0;
  while (events != (eventmask_t)0) {
 8002d2e:	2d00      	cmp	r5, #0
 8002d30:	d1f0      	bne.n	8002d14 <test_007_002_execute.lto_priv.132+0x14>
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8002d32:	4805      	ldr	r0, [pc, #20]	; (8002d48 <test_007_002_execute.lto_priv.132+0x48>)
 8002d34:	4905      	ldr	r1, [pc, #20]	; (8002d4c <test_007_002_execute.lto_priv.132+0x4c>)
  }
}
 8002d36:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [7.2.1] Three evenf flag bits are raised then chEvtDispatch() is
     invoked, the sequence of handlers calls is tested.*/
  test_set_step(1);
  {
    chEvtDispatch(evhndl, 7);
    test_assert_sequence("ABC", "invalid sequence");
 8002d3a:	f001 b899 	b.w	8003e70 <_test_assert_sequence>
 8002d3e:	bf00      	nop
 8002d40:	2000133c 	.word	0x2000133c
 8002d44:	080071a8 	.word	0x080071a8
 8002d48:	08007158 	.word	0x08007158
 8002d4c:	08006f50 	.word	0x08006f50

08002d50 <test_007_001_execute.lto_priv.130>:
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 8002d50:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8002d54:	4c36      	ldr	r4, [pc, #216]	; (8002e30 <test_007_001_execute.lto_priv.130+0xe0>)
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8002d56:	f8df 90e8 	ldr.w	r9, [pc, #232]	; 8002e40 <test_007_001_execute.lto_priv.130+0xf0>
 8002d5a:	6024      	str	r4, [r4, #0]
 8002d5c:	2102      	movs	r1, #2
 * - [7.1.4] An Event Listener is unregistered, the Event Source must
 *   not have listeners.
 * .
 */

static void test_007_001_execute(void) {
 8002d5e:	b08a      	sub	sp, #40	; 0x28
    chEvtObjectInit(&es1);
  }

  /* [7.1.2] Two Event Listeners are registered on the Event Source,
     the Event Source is tested to have listeners.*/
  test_set_step(2);
 8002d60:	f8c9 1000 	str.w	r1, [r9]
 8002d64:	2620      	movs	r6, #32
 8002d66:	f386 8811 	msr	BASEPRI, r6
  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
 8002d6a:	4832      	ldr	r0, [pc, #200]	; (8002e34 <test_007_001_execute.lto_priv.130+0xe4>)
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002d6c:	6823      	ldr	r3, [r4, #0]
 8002d6e:	af0a      	add	r7, sp, #40	; 0x28
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8002d70:	2201      	movs	r2, #1
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002d72:	f847 3d28 	str.w	r3, [r7, #-40]!
  esp->next     = elp;
  elp->listener = currp;
 8002d76:	6983      	ldr	r3, [r0, #24]
 8002d78:	9301      	str	r3, [sp, #4]
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002d7a:	2500      	movs	r5, #0
  elp->wflags   = wflags;
 8002d7c:	f04f 33ff 	mov.w	r3, #4294967295

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
  elp->listener = currp;
  elp->events   = events;
 8002d80:	9202      	str	r2, [sp, #8]

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8002d82:	6027      	str	r7, [r4, #0]
  elp->listener = currp;
  elp->events   = events;
  elp->flags    = (eventflags_t)0;
 8002d84:	9503      	str	r5, [sp, #12]
  elp->wflags   = wflags;
 8002d86:	9304      	str	r3, [sp, #16]
 8002d88:	f385 8811 	msr	BASEPRI, r5
 8002d8c:	f386 8811 	msr	BASEPRI, r6
                                eventflags_t wflags) {

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
 8002d90:	f10d 0828 	add.w	r8, sp, #40	; 0x28
 8002d94:	6822      	ldr	r2, [r4, #0]
 8002d96:	f848 2d14 	str.w	r2, [r8, #-20]!
  esp->next     = elp;
  elp->listener = currp;
 8002d9a:	6982      	ldr	r2, [r0, #24]
 8002d9c:	9206      	str	r2, [sp, #24]
  elp->events   = events;
 8002d9e:	9107      	str	r1, [sp, #28]
  elp->flags    = (eventflags_t)0;
 8002da0:	9508      	str	r5, [sp, #32]
  elp->wflags   = wflags;
 8002da2:	9309      	str	r3, [sp, #36]	; 0x24

  chDbgCheck((esp != NULL) && (elp != NULL));

  chSysLock();
  elp->next     = esp->next;
  esp->next     = elp;
 8002da4:	f8c4 8000 	str.w	r8, [r4]
 8002da8:	f385 8811 	msr	BASEPRI, r5
 8002dac:	f386 8811 	msr	BASEPRI, r6
 *
 * @iclass
 */
static inline bool chEvtIsListeningI(event_source_t *esp) {

  return (bool)(esp != (event_source_t *)esp->next);
 8002db0:	6820      	ldr	r0, [r4, #0]
  {
    chEvtRegisterMask(&es1, &el1, 1);
    chEvtRegisterMask(&es1, &el2, 2);
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8002db2:	4921      	ldr	r1, [pc, #132]	; (8002e38 <test_007_001_execute.lto_priv.130+0xe8>)
 8002db4:	1b00      	subs	r0, r0, r4
 8002db6:	bf18      	it	ne
 8002db8:	2001      	movne	r0, #1
 8002dba:	f001 f881 	bl	8003ec0 <_test_assert>
 8002dbe:	4682      	mov	sl, r0
 8002dc0:	b120      	cbz	r0, 8002dcc <test_007_001_execute.lto_priv.130+0x7c>
 8002dc2:	f385 8811 	msr	BASEPRI, r5
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 8002dc6:	b00a      	add	sp, #40	; 0x28
 8002dc8:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002dcc:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8002dd0:	2303      	movs	r3, #3
  {
    chEvtUnregister(&es1, &el1);
 8002dd2:	4639      	mov	r1, r7
 8002dd4:	4620      	mov	r0, r4
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.3] An Event Listener is unregistered, the Event Source must
     still have listeners.*/
  test_set_step(3);
 8002dd6:	f8c9 3000 	str.w	r3, [r9]
  {
    chEvtUnregister(&es1, &el1);
 8002dda:	f002 f941 	bl	8005060 <chEvtUnregister>
 8002dde:	f386 8811 	msr	BASEPRI, r6
 8002de2:	6820      	ldr	r0, [r4, #0]
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
 8002de4:	4914      	ldr	r1, [pc, #80]	; (8002e38 <test_007_001_execute.lto_priv.130+0xe8>)
 8002de6:	1b00      	subs	r0, r0, r4
 8002de8:	bf18      	it	ne
 8002dea:	2001      	movne	r0, #1
 8002dec:	f001 f868 	bl	8003ec0 <_test_assert>
 8002df0:	4605      	mov	r5, r0
 8002df2:	b120      	cbz	r0, 8002dfe <test_007_001_execute.lto_priv.130+0xae>
 8002df4:	f38a 8811 	msr	BASEPRI, sl
  test_set_step(4);
  {
    chEvtUnregister(&es1, &el2);
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
  }
}
 8002df8:	b00a      	add	sp, #40	; 0x28
 8002dfa:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8002dfe:	f380 8811 	msr	BASEPRI, r0
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8002e02:	2304      	movs	r3, #4
  {
    chEvtUnregister(&es1, &el2);
 8002e04:	4641      	mov	r1, r8
 8002e06:	4620      	mov	r0, r4
    test_assert_lock(chEvtIsListeningI(&es1), "no listener");
  }

  /* [7.1.4] An Event Listener is unregistered, the Event Source must
     not have listeners.*/
  test_set_step(4);
 8002e08:	f8c9 3000 	str.w	r3, [r9]
  {
    chEvtUnregister(&es1, &el2);
 8002e0c:	f002 f928 	bl	8005060 <chEvtUnregister>
 8002e10:	f386 8811 	msr	BASEPRI, r6
    test_assert_lock(!chEvtIsListeningI(&es1), "stuck listener");
 8002e14:	6820      	ldr	r0, [r4, #0]
 8002e16:	4909      	ldr	r1, [pc, #36]	; (8002e3c <test_007_001_execute.lto_priv.130+0xec>)
 8002e18:	1b00      	subs	r0, r0, r4
 8002e1a:	fab0 f080 	clz	r0, r0
 8002e1e:	0940      	lsrs	r0, r0, #5
 8002e20:	f001 f84e 	bl	8003ec0 <_test_assert>
 8002e24:	2800      	cmp	r0, #0
 8002e26:	d1cc      	bne.n	8002dc2 <test_007_001_execute.lto_priv.130+0x72>
 8002e28:	f380 8811 	msr	BASEPRI, r0
 8002e2c:	e7cb      	b.n	8002dc6 <test_007_001_execute.lto_priv.130+0x76>
 8002e2e:	bf00      	nop
 8002e30:	20000834 	.word	0x20000834
 8002e34:	200013b0 	.word	0x200013b0
 8002e38:	0800715c 	.word	0x0800715c
 8002e3c:	080070e4 	.word	0x080070e4
 8002e40:	2000133c 	.word	0x2000133c
 8002e44:	f3af 8000 	nop.w
 8002e48:	f3af 8000 	nop.w
 8002e4c:	f3af 8000 	nop.w

08002e50 <evt_thread7.lto_priv.177>:

  chThdSleepMilliseconds(50);
  chEvtSignal((thread_t *)p, 1);
}

static THD_FUNCTION(evt_thread7, p) {
 8002e50:	b538      	push	{r3, r4, r5, lr}
 8002e52:	2520      	movs	r5, #32
 8002e54:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8002e58:	480b      	ldr	r0, [pc, #44]	; (8002e88 <evt_thread7.lto_priv.177+0x38>)
 8002e5a:	2100      	movs	r1, #0
 8002e5c:	f002 f8d8 	bl	8005010 <chEvtBroadcastFlagsI>
 8002e60:	2400      	movs	r4, #0
  chSchRescheduleS();
 8002e62:	f002 fa0d 	bl	8005280 <chSchRescheduleS>
 8002e66:	f384 8811 	msr	BASEPRI, r4

  (void)p;
  chEvtBroadcast(&es1);
  chThdSleepMilliseconds(50);
 8002e6a:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002e6e:	f002 fd1f 	bl	80058b0 <chThdSleep>
 8002e72:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chEvtBroadcastFlags(event_source_t *esp, eventflags_t flags) {

  chSysLock();
  chEvtBroadcastFlagsI(esp, flags);
 8002e76:	4805      	ldr	r0, [pc, #20]	; (8002e8c <evt_thread7.lto_priv.177+0x3c>)
 8002e78:	4621      	mov	r1, r4
 8002e7a:	f002 f8c9 	bl	8005010 <chEvtBroadcastFlagsI>
  chSchRescheduleS();
 8002e7e:	f002 f9ff 	bl	8005280 <chSchRescheduleS>
 8002e82:	f384 8811 	msr	BASEPRI, r4
 8002e86:	bd38      	pop	{r3, r4, r5, pc}
 8002e88:	20000834 	.word	0x20000834
 8002e8c:	20000838 	.word	0x20000838

08002e90 <evt_thread3.lto_priv.178>:
static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
static ROMCONST evhandler_t evhndl[] = {h1, h2, h3};

static THD_FUNCTION(evt_thread3, p) {
 8002e90:	b510      	push	{r4, lr}
 8002e92:	4604      	mov	r4, r0

  chThdSleepMilliseconds(50);
 8002e94:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 8002e98:	f002 fd0a 	bl	80058b0 <chThdSleep>
 8002e9c:	2320      	movs	r3, #32
 8002e9e:	f383 8811 	msr	BASEPRI, r3
void chEvtSignal(thread_t *tp, eventmask_t events) {

  chDbgCheck(tp != NULL);

  chSysLock();
  chEvtSignalI(tp, events);
 8002ea2:	2101      	movs	r1, #1
 8002ea4:	4620      	mov	r0, r4
 8002ea6:	f001 fa3b 	bl	8004320 <chEvtSignalI>
  chSchRescheduleS();
 8002eaa:	f002 f9e9 	bl	8005280 <chSchRescheduleS>
 8002eae:	2300      	movs	r3, #0
 8002eb0:	f383 8811 	msr	BASEPRI, r3
 8002eb4:	bd10      	pop	{r4, pc}
 8002eb6:	bf00      	nop
 8002eb8:	f3af 8000 	nop.w
 8002ebc:	f3af 8000 	nop.w

08002ec0 <h3>:
static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
static void h3(eventid_t id) {(void)id;test_emit_token('C');}
 8002ec0:	2043      	movs	r0, #67	; 0x43
 8002ec2:	f000 bf5d 	b.w	8003d80 <test_emit_token>
 8002ec6:	bf00      	nop
 8002ec8:	f3af 8000 	nop.w
 8002ecc:	f3af 8000 	nop.w

08002ed0 <h2>:

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
static void h2(eventid_t id) {(void)id;test_emit_token('B');}
 8002ed0:	2042      	movs	r0, #66	; 0x42
 8002ed2:	f000 bf55 	b.w	8003d80 <test_emit_token>
 8002ed6:	bf00      	nop
 8002ed8:	f3af 8000 	nop.w
 8002edc:	f3af 8000 	nop.w

08002ee0 <h1>:
 ****************************************************************************/

static EVENTSOURCE_DECL(es1);
static EVENTSOURCE_DECL(es2);

static void h1(eventid_t id) {(void)id;test_emit_token('A');}
 8002ee0:	2041      	movs	r0, #65	; 0x41
 8002ee2:	f000 bf4d 	b.w	8003d80 <test_emit_token>
 8002ee6:	bf00      	nop
 8002ee8:	f3af 8000 	nop.w
 8002eec:	f3af 8000 	nop.w

08002ef0 <msg_thread1>:

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8002ef0:	b510      	push	{r4, lr}

  chMsgSend(p, 'A');
 8002ef2:	2141      	movs	r1, #65	; 0x41

/****************************************************************************
 * Shared code.
 ****************************************************************************/

static THD_FUNCTION(msg_thread1, p) {
 8002ef4:	4604      	mov	r4, r0

  chMsgSend(p, 'A');
 8002ef6:	f001 f9f3 	bl	80042e0 <chMsgSend>
  chMsgSend(p, 'B');
 8002efa:	4620      	mov	r0, r4
 8002efc:	2142      	movs	r1, #66	; 0x42
 8002efe:	f001 f9ef 	bl	80042e0 <chMsgSend>
  chMsgSend(p, 'C');
 8002f02:	4620      	mov	r0, r4
 8002f04:	2143      	movs	r1, #67	; 0x43
 8002f06:	f001 f9eb 	bl	80042e0 <chMsgSend>
  chMsgSend(p, 'D');
 8002f0a:	4620      	mov	r0, r4
 8002f0c:	2144      	movs	r1, #68	; 0x44
}
 8002f0e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(msg_thread1, p) {

  chMsgSend(p, 'A');
  chMsgSend(p, 'B');
  chMsgSend(p, 'C');
  chMsgSend(p, 'D');
 8002f12:	f001 b9e5 	b.w	80042e0 <chMsgSend>
 8002f16:	bf00      	nop
 8002f18:	f3af 8000 	nop.w
 8002f1c:	f3af 8000 	nop.w

08002f20 <test_006_001_execute.lto_priv.129>:
 * - [6.1.1] Starting the messenger thread.
 * - [6.1.2] Waiting for four messages then testing the receive order.
 * .
 */

static void test_006_001_execute(void) {
 8002f20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f22:	4b14      	ldr	r3, [pc, #80]	; (8002f74 <test_006_001_execute.lto_priv.129+0x54>)
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8002f24:	4c14      	ldr	r4, [pc, #80]	; (8002f78 <test_006_001_execute.lto_priv.129+0x58>)
 8002f26:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8002f28:	4a14      	ldr	r2, [pc, #80]	; (8002f7c <test_006_001_execute.lto_priv.129+0x5c>)
 8002f2a:	6899      	ldr	r1, [r3, #8]
 8002f2c:	4814      	ldr	r0, [pc, #80]	; (8002f80 <test_006_001_execute.lto_priv.129+0x60>)
 8002f2e:	3101      	adds	r1, #1
static void test_006_001_execute(void) {
  thread_t *tp;
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
 8002f30:	2501      	movs	r5, #1
 8002f32:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8002f34:	f002 fd9c 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8002f38:	4a12      	ldr	r2, [pc, #72]	; (8002f84 <test_006_001_execute.lto_priv.129+0x64>)
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8002f3a:	2302      	movs	r3, #2
 8002f3c:	6023      	str	r3, [r4, #0]
  msg_t msg;

  /* [6.1.1] Starting the messenger thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX() + 1,
 8002f3e:	6010      	str	r0, [r2, #0]
                                   msg_thread1, chThdGetSelfX());
  }

  /* [6.1.2] Waiting for four messages then testing the receive
     order.*/
  test_set_step(2);
 8002f40:	2404      	movs	r4, #4
 8002f42:	2720      	movs	r7, #32
 8002f44:	2600      	movs	r6, #0
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
      tp = chMsgWait();
 8002f46:	f001 f9ab 	bl	80042a0 <chMsgWait>
 8002f4a:	6a45      	ldr	r5, [r0, #36]	; 0x24
 8002f4c:	f387 8811 	msr	BASEPRI, r7
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 8002f50:	4629      	mov	r1, r5
 8002f52:	f002 f9d5 	bl	8005300 <chSchWakeupS>
 8002f56:	f386 8811 	msr	BASEPRI, r6
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
 8002f5a:	b2e8      	uxtb	r0, r5
 8002f5c:	f000 ff10 	bl	8003d80 <test_emit_token>
     order.*/
  test_set_step(2);
  {
    unsigned i;

    for (i = 0; i < 4; i++) {
 8002f60:	3c01      	subs	r4, #1
 8002f62:	d1f0      	bne.n	8002f46 <test_006_001_execute.lto_priv.129+0x26>
      tp = chMsgWait();
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
 8002f64:	f000 fed4 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 8002f68:	4807      	ldr	r0, [pc, #28]	; (8002f88 <test_006_001_execute.lto_priv.129+0x68>)
 8002f6a:	4908      	ldr	r1, [pc, #32]	; (8002f8c <test_006_001_execute.lto_priv.129+0x6c>)
  }
}
 8002f6c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
      msg = chMsgGet(tp);
      chMsgRelease(tp, msg);
      test_emit_token(msg);
    }
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 8002f70:	f000 bf7e 	b.w	8003e70 <_test_assert_sequence>
 8002f74:	200013b0 	.word	0x200013b0
 8002f78:	2000133c 	.word	0x2000133c
 8002f7c:	08002ef1 	.word	0x08002ef1
 8002f80:	20000c50 	.word	0x20000c50
 8002f84:	20001340 	.word	0x20001340
 8002f88:	080070bc 	.word	0x080070bc
 8002f8c:	08006f50 	.word	0x08006f50

08002f90 <test_005_009_execute.lto_priv.128>:
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
  chMtxObjectInit(&m2);
}

static void test_005_009_execute(void) {
 8002f90:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8002f92:	4b1c      	ldr	r3, [pc, #112]	; (8003004 <test_005_009_execute.lto_priv.128+0x74>)

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8002f94:	4e1c      	ldr	r6, [pc, #112]	; (8003008 <test_005_009_execute.lto_priv.128+0x78>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8002f96:	699b      	ldr	r3, [r3, #24]
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8002f98:	4c1c      	ldr	r4, [pc, #112]	; (800300c <test_005_009_execute.lto_priv.128+0x7c>)
 8002f9a:	689f      	ldr	r7, [r3, #8]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8002f9c:	4a1c      	ldr	r2, [pc, #112]	; (8003010 <test_005_009_execute.lto_priv.128+0x80>)
 8002f9e:	4b1d      	ldr	r3, [pc, #116]	; (8003014 <test_005_009_execute.lto_priv.128+0x84>)
 8002fa0:	4d1d      	ldr	r5, [pc, #116]	; (8003018 <test_005_009_execute.lto_priv.128+0x88>)
 8002fa2:	1c79      	adds	r1, r7, #1
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8002fa4:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8002fa8:	4630      	mov	r0, r6
    prio = chThdGetPriorityX();
  }

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
 8002faa:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8002fae:	f002 fd5f 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8002fb2:	f04f 0e03 	mov.w	lr, #3

  /* [5.9.2] Thread A is created at priority P(+1), it locks M2, locks
     M1 and goes to wait on C1.*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
 8002fb6:	6028      	str	r0, [r5, #0]

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8002fb8:	1cb9      	adds	r1, r7, #2
 8002fba:	f506 70a4 	add.w	r0, r6, #328	; 0x148
 8002fbe:	4a17      	ldr	r2, [pc, #92]	; (800301c <test_005_009_execute.lto_priv.128+0x8c>)
 8002fc0:	4b17      	ldr	r3, [pc, #92]	; (8003020 <test_005_009_execute.lto_priv.128+0x90>)
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread8, "A");
  }

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
 8002fc2:	f8c4 e000 	str.w	lr, [r4]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8002fc6:	f002 fd53 	bl	8005a70 <chThdCreateStatic.constprop.69>

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8002fca:	1cf9      	adds	r1, r7, #3
 8002fcc:	4a15      	ldr	r2, [pc, #84]	; (8003024 <test_005_009_execute.lto_priv.128+0x94>)

  /* [5.9.3] Thread C is created at priority P(+2), it enqueues on M1
     and boosts TA priority at P(+2).*/
  test_set_step(3);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
 8002fce:	6068      	str	r0, [r5, #4]
  }

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8002fd0:	2704      	movs	r7, #4
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8002fd2:	f506 7024 	add.w	r0, r6, #656	; 0x290
 8002fd6:	4b14      	ldr	r3, [pc, #80]	; (8003028 <test_005_009_execute.lto_priv.128+0x98>)
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "C");
  }

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
 8002fd8:	6027      	str	r7, [r4, #0]
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8002fda:	f002 fd49 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8002fde:	2305      	movs	r3, #5

  /* [5.9.4] Thread B is created at priority P(+3), it enqueues on M2
     and boosts TA priority at P(+3).*/
  test_set_step(4);
  {
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread9, "B");
 8002fe0:	60a8      	str	r0, [r5, #8]
  }

  /* [5.9.5] Signaling C1: TA wakes up, unlocks M1 and priority goes to
     P(+2). TB locks M1, unlocks M1 and completes. TA unlocks M2 and
     priority goes to P(+1). TC waits on C1. TA completes.*/
  test_set_step(5);
 8002fe2:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8002fe4:	f002 fdec 	bl	8005bc0 <chCondSignal.constprop.59>
  }

  /* [5.9.6] Signaling C1: TC wakes up, unlocks M1 and completes.*/
  test_set_step(6);
 8002fe8:	2306      	movs	r3, #6
 8002fea:	6023      	str	r3, [r4, #0]
  {
    chCondSignal(&c1);
 8002fec:	f002 fde8 	bl	8005bc0 <chCondSignal.constprop.59>
  }

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
 8002ff0:	2307      	movs	r3, #7
 8002ff2:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8002ff4:	f000 fe8c 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABC", "invalid sequence");
 8002ff8:	480c      	ldr	r0, [pc, #48]	; (800302c <test_005_009_execute.lto_priv.128+0x9c>)
 8002ffa:	490d      	ldr	r1, [pc, #52]	; (8003030 <test_005_009_execute.lto_priv.128+0xa0>)
  }
}
 8002ffc:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}

  /* [5.9.7] Checking the order of operations.*/
  test_set_step(7);
  {
    test_wait_threads();
    test_assert_sequence("ABC", "invalid sequence");
 8003000:	f000 bf36 	b.w	8003e70 <_test_assert_sequence>
 8003004:	200013b0 	.word	0x200013b0
 8003008:	20000c50 	.word	0x20000c50
 800300c:	2000133c 	.word	0x2000133c
 8003010:	08003611 	.word	0x08003611
 8003014:	08006f38 	.word	0x08006f38
 8003018:	20001340 	.word	0x20001340
 800301c:	080036a1 	.word	0x080036a1
 8003020:	08006f40 	.word	0x08006f40
 8003024:	08003041 	.word	0x08003041
 8003028:	08006f3c 	.word	0x08006f3c
 800302c:	08007158 	.word	0x08007158
 8003030:	08006f50 	.word	0x08006f50
 8003034:	f3af 8000 	nop.w
 8003038:	f3af 8000 	nop.w
 800303c:	f3af 8000 	nop.w

08003040 <thread9>:
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8003040:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m2);
 8003042:	4c06      	ldr	r4, [pc, #24]	; (800305c <thread9+0x1c>)
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
}

static THD_FUNCTION(thread9, p) {
 8003044:	4605      	mov	r5, r0

  chMtxLock(&m2);
 8003046:	4620      	mov	r0, r4
 8003048:	f002 faea 	bl	8005620 <chMtxLock>
  test_emit_token(*(char *)p);
 800304c:	7828      	ldrb	r0, [r5, #0]
 800304e:	f000 fe97 	bl	8003d80 <test_emit_token>
  chMtxUnlock(&m2);
 8003052:	4620      	mov	r0, r4
}
 8003054:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread9, p) {

  chMtxLock(&m2);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m2);
 8003058:	f002 ba42 	b.w	80054e0 <chMtxUnlock>
 800305c:	2000083c 	.word	0x2000083c

08003060 <test_005_004_execute.lto_priv.120>:

static void test_005_004_teardown(void) {
  test_wait_threads();
}

static void test_005_004_execute(void) {
 8003060:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003064:	4d40      	ldr	r5, [pc, #256]	; (8003168 <test_005_004_execute.lto_priv.120+0x108>)
    pa = p + 1;
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8003066:	4e41      	ldr	r6, [pc, #260]	; (800316c <test_005_004_execute.lto_priv.120+0x10c>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003068:	69ab      	ldr	r3, [r5, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800306a:	4a41      	ldr	r2, [pc, #260]	; (8003170 <test_005_004_execute.lto_priv.120+0x110>)
 800306c:	689c      	ldr	r4, [r3, #8]
 800306e:	4841      	ldr	r0, [pc, #260]	; (8003174 <test_005_004_execute.lto_priv.120+0x114>)
 8003070:	4b41      	ldr	r3, [pc, #260]	; (8003178 <test_005_004_execute.lto_priv.120+0x118>)
 8003072:	4f42      	ldr	r7, [pc, #264]	; (800317c <test_005_004_execute.lto_priv.120+0x11c>)
  /* [5.4.1] Getting current thread priority P(0) and assigning to the
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
 8003074:	f104 0801 	add.w	r8, r4, #1
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 8003078:	f04f 0e02 	mov.w	lr, #2
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800307c:	4641      	mov	r1, r8
    pa = p + 1;
    pb = p + 2;
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
 800307e:	f8c6 e000 	str.w	lr, [r6]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 8003082:	f002 fcf5 	bl	8005a70 <chThdCreateStatic.constprop.69>
     threads A and B priorities +1 and +2.*/
  test_set_step(1);
  {
    p = chThdGetPriorityX();
    pa = p + 1;
    pb = p + 2;
 8003086:	f104 0902 	add.w	r9, r4, #2

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800308a:	4649      	mov	r1, r9
  }

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
 800308c:	6038      	str	r0, [r7, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800308e:	4a3c      	ldr	r2, [pc, #240]	; (8003180 <test_005_004_execute.lto_priv.120+0x120>)
 8003090:	4b3c      	ldr	r3, [pc, #240]	; (8003184 <test_005_004_execute.lto_priv.120+0x124>)
 8003092:	483d      	ldr	r0, [pc, #244]	; (8003188 <test_005_004_execute.lto_priv.120+0x128>)
 8003094:	f002 fcec 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 8003098:	2303      	movs	r3, #3

  /* [5.4.2] Spawning threads A and B at priorities P(A) and P(B).*/
  test_set_step(2);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, pa, thread4A, "A");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, pb, thread4B, "B");
 800309a:	6078      	str	r0, [r7, #4]
  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
  {
    chMtxLock(&m1);
 800309c:	483b      	ldr	r0, [pc, #236]	; (800318c <test_005_004_execute.lto_priv.120+0x12c>)
  }

  /* [5.4.3] Locking the mutex M1 before thread A has a chance to lock
     it. The priority must not change because A has not yet reached
     chMtxLock(M1). the mutex is not locked.*/
  test_set_step(3);
 800309e:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 80030a0:	f002 fabe 	bl	8005620 <chMtxLock>
 80030a4:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 80030a6:	493a      	ldr	r1, [pc, #232]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 80030a8:	6898      	ldr	r0, [r3, #8]
 80030aa:	1a20      	subs	r0, r4, r0
 80030ac:	fab0 f080 	clz	r0, r0
 80030b0:	0940      	lsrs	r0, r0, #5
 80030b2:	f000 ff05 	bl	8003ec0 <_test_assert>
 80030b6:	b108      	cbz	r0, 80030bc <test_005_004_execute.lto_priv.120+0x5c>
 80030b8:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80030bc:	2304      	movs	r3, #4
  {
    chThdSleepMilliseconds(100);
 80030be:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  }

  /* [5.4.4] Waiting 100mS, this makes thread A reach chMtxLock(M1) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread A.*/
  test_set_step(4);
 80030c2:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 80030c4:	f002 fbf4 	bl	80058b0 <chThdSleep>
 80030c8:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80030ca:	4931      	ldr	r1, [pc, #196]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 80030cc:	6898      	ldr	r0, [r3, #8]
 80030ce:	ebc0 0008 	rsb	r0, r0, r8
 80030d2:	fab0 f080 	clz	r0, r0
 80030d6:	0940      	lsrs	r0, r0, #5
 80030d8:	f000 fef2 	bl	8003ec0 <_test_assert>
 80030dc:	2800      	cmp	r0, #0
 80030de:	d1eb      	bne.n	80030b8 <test_005_004_execute.lto_priv.120+0x58>
  }

  /* [5.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 80030e0:	2305      	movs	r3, #5
  {
    chMtxLock(&m2);
 80030e2:	482c      	ldr	r0, [pc, #176]	; (8003194 <test_005_004_execute.lto_priv.120+0x134>)
  }

  /* [5.4.5] Locking the mutex M2 before thread B has a chance to lock
     it. The priority must not change because B has not yet reached
     chMtxLock(M2). the mutex is not locked.*/
  test_set_step(5);
 80030e4:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m2);
 80030e6:	f002 fa9b 	bl	8005620 <chMtxLock>
 80030ea:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 80030ec:	4928      	ldr	r1, [pc, #160]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 80030ee:	6898      	ldr	r0, [r3, #8]
 80030f0:	ebc0 0008 	rsb	r0, r0, r8
 80030f4:	fab0 f080 	clz	r0, r0
 80030f8:	0940      	lsrs	r0, r0, #5
 80030fa:	f000 fee1 	bl	8003ec0 <_test_assert>
 80030fe:	2800      	cmp	r0, #0
 8003100:	d1da      	bne.n	80030b8 <test_005_004_execute.lto_priv.120+0x58>
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8003102:	2306      	movs	r3, #6
  {
    chThdSleepMilliseconds(100);
 8003104:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
  }

  /* [5.4.6] Waiting 100mS, this makes thread B reach chMtxLock(M2) and
     get the mutex. This must boost the priority of the current thread
     at the same level of thread B.*/
  test_set_step(6);
 8003108:	6033      	str	r3, [r6, #0]
  {
    chThdSleepMilliseconds(100);
 800310a:	f002 fbd1 	bl	80058b0 <chThdSleep>
 800310e:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
 8003110:	491f      	ldr	r1, [pc, #124]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 8003112:	6898      	ldr	r0, [r3, #8]
 8003114:	ebc0 0009 	rsb	r0, r0, r9
 8003118:	fab0 f080 	clz	r0, r0
 800311c:	0940      	lsrs	r0, r0, #5
 800311e:	f000 fecf 	bl	8003ec0 <_test_assert>
 8003122:	2800      	cmp	r0, #0
 8003124:	d1c8      	bne.n	80030b8 <test_005_004_execute.lto_priv.120+0x58>
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 8003126:	2307      	movs	r3, #7
  {
    chMtxUnlock(&m2);
 8003128:	481a      	ldr	r0, [pc, #104]	; (8003194 <test_005_004_execute.lto_priv.120+0x134>)
    chThdSleepMilliseconds(100);
    test_assert(chThdGetPriorityX() == pb, "wrong priority level");
  }

  /* [5.4.7] Unlocking M2, the priority should fall back to P(A).*/
  test_set_step(7);
 800312a:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m2);
 800312c:	f002 f9d8 	bl	80054e0 <chMtxUnlock>
 8003130:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
 8003132:	4917      	ldr	r1, [pc, #92]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 8003134:	6898      	ldr	r0, [r3, #8]
 8003136:	ebc0 0008 	rsb	r0, r0, r8
 800313a:	fab0 f080 	clz	r0, r0
 800313e:	0940      	lsrs	r0, r0, #5
 8003140:	f000 febe 	bl	8003ec0 <_test_assert>
 8003144:	2800      	cmp	r0, #0
 8003146:	d1b7      	bne.n	80030b8 <test_005_004_execute.lto_priv.120+0x58>
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 8003148:	2308      	movs	r3, #8
  {
    chMtxUnlock(&m1);
 800314a:	4810      	ldr	r0, [pc, #64]	; (800318c <test_005_004_execute.lto_priv.120+0x12c>)
    chMtxUnlock(&m2);
    test_assert(chThdGetPriorityX() == pa, "wrong priority level");
  }

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
 800314c:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 800314e:	f002 f9c7 	bl	80054e0 <chMtxUnlock>
 8003152:	69ab      	ldr	r3, [r5, #24]
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 8003154:	490e      	ldr	r1, [pc, #56]	; (8003190 <test_005_004_execute.lto_priv.120+0x130>)
 8003156:	6898      	ldr	r0, [r3, #8]
 8003158:	1a20      	subs	r0, r4, r0
  }
}
 800315a:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}

  /* [5.4.8] Unlocking M1, the priority should fall back to P(0).*/
  test_set_step(8);
  {
    chMtxUnlock(&m1);
    test_assert(chThdGetPriorityX() == p, "wrong priority level");
 800315e:	fab0 f080 	clz	r0, r0
 8003162:	0940      	lsrs	r0, r0, #5
 8003164:	f000 beac 	b.w	8003ec0 <_test_assert>
 8003168:	200013b0 	.word	0x200013b0
 800316c:	2000133c 	.word	0x2000133c
 8003170:	080031a1 	.word	0x080031a1
 8003174:	20000c50 	.word	0x20000c50
 8003178:	08006f38 	.word	0x08006f38
 800317c:	20001340 	.word	0x20001340
 8003180:	080035e1 	.word	0x080035e1
 8003184:	08006f3c 	.word	0x08006f3c
 8003188:	20000d98 	.word	0x20000d98
 800318c:	200008a0 	.word	0x200008a0
 8003190:	08007168 	.word	0x08007168
 8003194:	2000083c 	.word	0x2000083c
 8003198:	f3af 8000 	nop.w
 800319c:	f3af 8000 	nop.w

080031a0 <thread4A>:
  chMtxUnlock(&m2);
  test_emit_token('A');
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {
 80031a0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
 80031a2:	4c06      	ldr	r4, [pc, #24]	; (80031bc <thread4A+0x1c>)
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
 80031a4:	f44f 70fa 	mov.w	r0, #500	; 0x1f4
 80031a8:	f002 fb82 	bl	80058b0 <chThdSleep>
  chMtxLock(&m1);
 80031ac:	4620      	mov	r0, r4
 80031ae:	f002 fa37 	bl	8005620 <chMtxLock>
  chMtxUnlock(&m1);
 80031b2:	4620      	mov	r0, r4
}
 80031b4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
static THD_FUNCTION(thread4A, p) {

  (void)p;
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
 80031b8:	f002 b992 	b.w	80054e0 <chMtxUnlock>
 80031bc:	200008a0 	.word	0x200008a0

080031c0 <test_005_001_execute.lto_priv.117>:

static void test_005_001_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_001_execute(void) {
 80031c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80031c2:	4f24      	ldr	r7, [pc, #144]	; (8003254 <test_005_001_execute.lto_priv.117+0x94>)
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80031c4:	4e24      	ldr	r6, [pc, #144]	; (8003258 <test_005_001_execute.lto_priv.117+0x98>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80031c6:	69bb      	ldr	r3, [r7, #24]
  {
    chMtxLock(&m1);
 80031c8:	4824      	ldr	r0, [pc, #144]	; (800325c <test_005_001_execute.lto_priv.117+0x9c>)
 80031ca:	689c      	ldr	r4, [r3, #8]
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80031cc:	4d24      	ldr	r5, [pc, #144]	; (8003260 <test_005_001_execute.lto_priv.117+0xa0>)
  {
    prio = chThdGetPriorityX();
  }

  /* [5.1.2] Locking the mutex.*/
  test_set_step(2);
 80031ce:	2302      	movs	r3, #2
 80031d0:	6033      	str	r3, [r6, #0]
  {
    chMtxLock(&m1);
 80031d2:	f002 fa25 	bl	8005620 <chMtxLock>
  }

  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80031d6:	f04f 0e03 	mov.w	lr, #3
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80031da:	1c61      	adds	r1, r4, #1
 80031dc:	4a21      	ldr	r2, [pc, #132]	; (8003264 <test_005_001_execute.lto_priv.117+0xa4>)
 80031de:	4b22      	ldr	r3, [pc, #136]	; (8003268 <test_005_001_execute.lto_priv.117+0xa8>)
 80031e0:	4822      	ldr	r0, [pc, #136]	; (800326c <test_005_001_execute.lto_priv.117+0xac>)
  }

  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
 80031e2:	f8c6 e000 	str.w	lr, [r6]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80031e6:	f002 fc43 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80031ea:	1ca1      	adds	r1, r4, #2
  /* [5.1.3] Five threads are created that try to lock and unlock the
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
 80031ec:	6028      	str	r0, [r5, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80031ee:	4a1d      	ldr	r2, [pc, #116]	; (8003264 <test_005_001_execute.lto_priv.117+0xa4>)
 80031f0:	4b1f      	ldr	r3, [pc, #124]	; (8003270 <test_005_001_execute.lto_priv.117+0xb0>)
 80031f2:	4820      	ldr	r0, [pc, #128]	; (8003274 <test_005_001_execute.lto_priv.117+0xb4>)
 80031f4:	f002 fc3c 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80031f8:	1ce1      	adds	r1, r4, #3
     mutex then terminate. The threads are created in ascending
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
 80031fa:	6068      	str	r0, [r5, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 80031fc:	4a19      	ldr	r2, [pc, #100]	; (8003264 <test_005_001_execute.lto_priv.117+0xa4>)
 80031fe:	4b1e      	ldr	r3, [pc, #120]	; (8003278 <test_005_001_execute.lto_priv.117+0xb8>)
 8003200:	481e      	ldr	r0, [pc, #120]	; (800327c <test_005_001_execute.lto_priv.117+0xbc>)
 8003202:	f002 fc35 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8003206:	1d21      	adds	r1, r4, #4
     priority order.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
 8003208:	60a8      	str	r0, [r5, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 800320a:	4a16      	ldr	r2, [pc, #88]	; (8003264 <test_005_001_execute.lto_priv.117+0xa4>)
 800320c:	4b1c      	ldr	r3, [pc, #112]	; (8003280 <test_005_001_execute.lto_priv.117+0xc0>)
 800320e:	481d      	ldr	r0, [pc, #116]	; (8003284 <test_005_001_execute.lto_priv.117+0xc4>)
 8003210:	f002 fc2e 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8003214:	1d61      	adds	r1, r4, #5
 8003216:	4a13      	ldr	r2, [pc, #76]	; (8003264 <test_005_001_execute.lto_priv.117+0xa4>)
  test_set_step(3);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
 8003218:	60e8      	str	r0, [r5, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 800321a:	4b1b      	ldr	r3, [pc, #108]	; (8003288 <test_005_001_execute.lto_priv.117+0xc8>)
 800321c:	481b      	ldr	r0, [pc, #108]	; (800328c <test_005_001_execute.lto_priv.117+0xcc>)
 800321e:	f002 fc27 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8003222:	2304      	movs	r3, #4
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread1, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread1, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread1, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread1, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
 8003224:	6128      	str	r0, [r5, #16]

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 8003226:	480d      	ldr	r0, [pc, #52]	; (800325c <test_005_001_execute.lto_priv.117+0x9c>)
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread1, "A");
  }

  /* [5.1.4] Unlocking the mutex, the threads will wakeup in priority
     order because the mutext queue is an ordered one.*/
  test_set_step(4);
 8003228:	6033      	str	r3, [r6, #0]
  {
    chMtxUnlock(&m1);
 800322a:	f002 f959 	bl	80054e0 <chMtxUnlock>
    test_wait_threads();
 800322e:	f000 fd6f 	bl	8003d10 <test_wait_threads>
 8003232:	69bb      	ldr	r3, [r7, #24]
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
 8003234:	4916      	ldr	r1, [pc, #88]	; (8003290 <test_005_001_execute.lto_priv.117+0xd0>)
 8003236:	6898      	ldr	r0, [r3, #8]
 8003238:	1a20      	subs	r0, r4, r0
 800323a:	fab0 f080 	clz	r0, r0
 800323e:	0940      	lsrs	r0, r0, #5
 8003240:	f000 fe3e 	bl	8003ec0 <_test_assert>
 8003244:	b100      	cbz	r0, 8003248 <test_005_001_execute.lto_priv.117+0x88>
 8003246:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    test_assert_sequence("ABCDE", "invalid sequence");
 8003248:	4812      	ldr	r0, [pc, #72]	; (8003294 <test_005_001_execute.lto_priv.117+0xd4>)
 800324a:	4913      	ldr	r1, [pc, #76]	; (8003298 <test_005_001_execute.lto_priv.117+0xd8>)
  }
}
 800324c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  test_set_step(4);
  {
    chMtxUnlock(&m1);
    test_wait_threads();
    test_assert(prio == chThdGetPriorityX(), "wrong priority level");
    test_assert_sequence("ABCDE", "invalid sequence");
 8003250:	f000 be0e 	b.w	8003e70 <_test_assert_sequence>
 8003254:	200013b0 	.word	0x200013b0
 8003258:	2000133c 	.word	0x2000133c
 800325c:	200008a0 	.word	0x200008a0
 8003260:	20001340 	.word	0x20001340
 8003264:	080032a1 	.word	0x080032a1
 8003268:	08006f4c 	.word	0x08006f4c
 800326c:	20000c50 	.word	0x20000c50
 8003270:	08006f44 	.word	0x08006f44
 8003274:	20000d98 	.word	0x20000d98
 8003278:	08006f40 	.word	0x08006f40
 800327c:	20000ee0 	.word	0x20000ee0
 8003280:	08006f3c 	.word	0x08006f3c
 8003284:	20001028 	.word	0x20001028
 8003288:	08006f38 	.word	0x08006f38
 800328c:	20001170 	.word	0x20001170
 8003290:	08007168 	.word	0x08007168
 8003294:	08006f48 	.word	0x08006f48
 8003298:	08006f50 	.word	0x08006f50
 800329c:	f3af 8000 	nop.w

080032a0 <thread1>:
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 80032a0:	b538      	push	{r3, r4, r5, lr}

  chMtxLock(&m1);
 80032a2:	4c06      	ldr	r4, [pc, #24]	; (80032bc <thread1+0x1c>)
  }
  while (chVTIsTimeWithinX(now, start, end));
}
#endif /* CH_DBG_THREADS_PROFILING */

static THD_FUNCTION(thread1, p) {
 80032a4:	4605      	mov	r5, r0

  chMtxLock(&m1);
 80032a6:	4620      	mov	r0, r4
 80032a8:	f002 f9ba 	bl	8005620 <chMtxLock>
  test_emit_token(*(char *)p);
 80032ac:	7828      	ldrb	r0, [r5, #0]
 80032ae:	f000 fd67 	bl	8003d80 <test_emit_token>
  chMtxUnlock(&m1);
 80032b2:	4620      	mov	r0, r4
}
 80032b4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

static THD_FUNCTION(thread1, p) {

  chMtxLock(&m1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80032b8:	f002 b912 	b.w	80054e0 <chMtxUnlock>
 80032bc:	200008a0 	.word	0x200008a0

080032c0 <test_005_008_execute.lto_priv.126>:
static void test_005_008_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_008_execute(void) {
 80032c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80032c2:	4b26      	ldr	r3, [pc, #152]	; (800335c <test_005_008_execute.lto_priv.126+0x9c>)

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80032c4:	4e26      	ldr	r6, [pc, #152]	; (8003360 <test_005_008_execute.lto_priv.126+0xa0>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80032c6:	699b      	ldr	r3, [r3, #24]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80032c8:	4a26      	ldr	r2, [pc, #152]	; (8003364 <test_005_008_execute.lto_priv.126+0xa4>)
 80032ca:	689d      	ldr	r5, [r3, #8]
 80032cc:	4826      	ldr	r0, [pc, #152]	; (8003368 <test_005_008_execute.lto_priv.126+0xa8>)
 80032ce:	4b27      	ldr	r3, [pc, #156]	; (800336c <test_005_008_execute.lto_priv.126+0xac>)
 80032d0:	4c27      	ldr	r4, [pc, #156]	; (8003370 <test_005_008_execute.lto_priv.126+0xb0>)
 80032d2:	1c69      	adds	r1, r5, #1

static void test_005_008_execute(void) {

  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80032d4:	2701      	movs	r7, #1
 80032d6:	6037      	str	r7, [r6, #0]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80032d8:	f002 fbca 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80032dc:	1ca9      	adds	r1, r5, #2
  /* [5.8.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80032de:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80032e0:	4a20      	ldr	r2, [pc, #128]	; (8003364 <test_005_008_execute.lto_priv.126+0xa4>)
 80032e2:	4b24      	ldr	r3, [pc, #144]	; (8003374 <test_005_008_execute.lto_priv.126+0xb4>)
 80032e4:	4824      	ldr	r0, [pc, #144]	; (8003378 <test_005_008_execute.lto_priv.126+0xb8>)
 80032e6:	f002 fbc3 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80032ea:	1ce9      	adds	r1, r5, #3
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80032ec:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80032ee:	4a1d      	ldr	r2, [pc, #116]	; (8003364 <test_005_008_execute.lto_priv.126+0xa4>)
 80032f0:	4b22      	ldr	r3, [pc, #136]	; (800337c <test_005_008_execute.lto_priv.126+0xbc>)
 80032f2:	4823      	ldr	r0, [pc, #140]	; (8003380 <test_005_008_execute.lto_priv.126+0xc0>)
 80032f4:	f002 fbbc 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80032f8:	1d29      	adds	r1, r5, #4
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80032fa:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80032fc:	4a19      	ldr	r2, [pc, #100]	; (8003364 <test_005_008_execute.lto_priv.126+0xa4>)
 80032fe:	4b21      	ldr	r3, [pc, #132]	; (8003384 <test_005_008_execute.lto_priv.126+0xc4>)
 8003300:	4821      	ldr	r0, [pc, #132]	; (8003388 <test_005_008_execute.lto_priv.126+0xc8>)
 8003302:	f002 fbb5 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8003306:	1d69      	adds	r1, r5, #5
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 8003308:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800330a:	4a16      	ldr	r2, [pc, #88]	; (8003364 <test_005_008_execute.lto_priv.126+0xa4>)
 800330c:	4b1f      	ldr	r3, [pc, #124]	; (800338c <test_005_008_execute.lto_priv.126+0xcc>)
 800330e:	4820      	ldr	r0, [pc, #128]	; (8003390 <test_005_008_execute.lto_priv.126+0xd0>)
 8003310:	f002 fbae 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
 8003314:	2302      	movs	r3, #2
 8003316:	6033      	str	r3, [r6, #0]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 8003318:	6120      	str	r0, [r4, #16]
 800331a:	2320      	movs	r3, #32
 800331c:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003320:	4c1c      	ldr	r4, [pc, #112]	; (8003394 <test_005_008_execute.lto_priv.126+0xd4>)
 8003322:	6823      	ldr	r3, [r4, #0]
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 8003324:	42a3      	cmp	r3, r4
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8003326:	bf18      	it	ne
 8003328:	f06f 0501 	mvnne.w	r5, #1
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 800332c:	d009      	beq.n	8003342 <test_005_008_execute.lto_priv.126+0x82>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800332e:	681a      	ldr	r2, [r3, #0]
 8003330:	6022      	str	r2, [r4, #0]
    chSchReadyI(queue_fifo_remove(&cp->queue))->u.rdymsg = MSG_RESET;
 8003332:	4618      	mov	r0, r3
  tqp->next->queue.prev = (thread_t *)tqp;
 8003334:	6054      	str	r4, [r2, #4]
 8003336:	f002 f893 	bl	8005460 <chSchReadyI>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800333a:	6823      	ldr	r3, [r4, #0]
 800333c:	6245      	str	r5, [r0, #36]	; 0x24
  chDbgCheck(cp != NULL);

  /* Empties the condition variable queue and inserts all the threads into the
     ready list in FIFO order. The wakeup message is set to @p MSG_RESET in
     order to make a chCondBroadcast() detectable from a chCondSignal().*/
  while (queue_notempty(&cp->queue)) {
 800333e:	42a3      	cmp	r3, r4
 8003340:	d1f5      	bne.n	800332e <test_005_008_execute.lto_priv.126+0x6e>
 */
void chCondBroadcast(condition_variable_t *cp) {

  chSysLock();
  chCondBroadcastI(cp);
  chSchRescheduleS();
 8003342:	f001 ff9d 	bl	8005280 <chSchRescheduleS>
 8003346:	2300      	movs	r3, #0
 8003348:	f383 8811 	msr	BASEPRI, r3
  /* [5.8.2] Broarcasting on the condition variable then waiting for
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
 800334c:	f000 fce0 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8003350:	4811      	ldr	r0, [pc, #68]	; (8003398 <test_005_008_execute.lto_priv.126+0xd8>)
 8003352:	4912      	ldr	r1, [pc, #72]	; (800339c <test_005_008_execute.lto_priv.126+0xdc>)
  }
}
 8003354:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
     the threads to terminate in priority order, the order is tested.*/
  test_set_step(2);
  {
    chCondBroadcast(&c1);
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 8003358:	f000 bd8a 	b.w	8003e70 <_test_assert_sequence>
 800335c:	200013b0 	.word	0x200013b0
 8003360:	2000133c 	.word	0x2000133c
 8003364:	080036a1 	.word	0x080036a1
 8003368:	20000c50 	.word	0x20000c50
 800336c:	08006f4c 	.word	0x08006f4c
 8003370:	20001340 	.word	0x20001340
 8003374:	08006f44 	.word	0x08006f44
 8003378:	20000d98 	.word	0x20000d98
 800337c:	08006f40 	.word	0x08006f40
 8003380:	20000ee0 	.word	0x20000ee0
 8003384:	08006f3c 	.word	0x08006f3c
 8003388:	20001028 	.word	0x20001028
 800338c:	08006f38 	.word	0x08006f38
 8003390:	20001170 	.word	0x20001170
 8003394:	20000858 	.word	0x20000858
 8003398:	08006f48 	.word	0x08006f48
 800339c:	08006f50 	.word	0x08006f50

080033a0 <test_005_007_execute.lto_priv.124>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80033a0:	4b28      	ldr	r3, [pc, #160]	; (8003444 <test_005_007_execute.lto_priv.124+0xa4>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80033a2:	699b      	ldr	r3, [r3, #24]
static void test_005_007_setup(void) {
  chCondObjectInit(&c1);
  chMtxObjectInit(&m1);
}

static void test_005_007_execute(void) {
 80033a4:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80033a8:	689f      	ldr	r7, [r3, #8]
  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033aa:	4d27      	ldr	r5, [pc, #156]	; (8003448 <test_005_007_execute.lto_priv.124+0xa8>)
 80033ac:	4e27      	ldr	r6, [pc, #156]	; (800344c <test_005_007_execute.lto_priv.124+0xac>)

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80033ae:	f8df 80c0 	ldr.w	r8, [pc, #192]	; 8003470 <test_005_007_execute.lto_priv.124+0xd0>
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033b2:	4b27      	ldr	r3, [pc, #156]	; (8003450 <test_005_007_execute.lto_priv.124+0xb0>)
 80033b4:	4c27      	ldr	r4, [pc, #156]	; (8003454 <test_005_007_execute.lto_priv.124+0xb4>)

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80033b6:	f04f 0e01 	mov.w	lr, #1
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033ba:	1c79      	adds	r1, r7, #1
 80033bc:	4632      	mov	r2, r6
 80033be:	4628      	mov	r0, r5

static void test_005_007_execute(void) {

  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
 80033c0:	f8c8 e000 	str.w	lr, [r8]
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033c4:	f002 fb54 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80033c8:	1cb9      	adds	r1, r7, #2
  /* [5.7.1] Starting the five threads with increasing priority, the
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
 80033ca:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80033cc:	4632      	mov	r2, r6
 80033ce:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 80033d2:	4b21      	ldr	r3, [pc, #132]	; (8003458 <test_005_007_execute.lto_priv.124+0xb8>)
 80033d4:	f002 fb4c 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80033d8:	1cf9      	adds	r1, r7, #3
     threads will queue on the condition variable.*/
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
 80033da:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80033dc:	4632      	mov	r2, r6
 80033de:	f505 7024 	add.w	r0, r5, #656	; 0x290
 80033e2:	4b1e      	ldr	r3, [pc, #120]	; (800345c <test_005_007_execute.lto_priv.124+0xbc>)
 80033e4:	f002 fb44 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80033e8:	1d39      	adds	r1, r7, #4
  test_set_step(1);
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
 80033ea:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80033ec:	4632      	mov	r2, r6
 80033ee:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 80033f2:	4b1b      	ldr	r3, [pc, #108]	; (8003460 <test_005_007_execute.lto_priv.124+0xc0>)
 80033f4:	f002 fb3c 	bl	8005a70 <chThdCreateStatic.constprop.69>
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80033f8:	1d79      	adds	r1, r7, #5
  {
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
 80033fa:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 80033fc:	4632      	mov	r2, r6
 80033fe:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 8003402:	4b18      	ldr	r3, [pc, #96]	; (8003464 <test_005_007_execute.lto_priv.124+0xc4>)
 8003404:	f002 fb34 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [5.7.2] Atomically signaling the condition variable five times
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
 8003408:	2302      	movs	r3, #2
 800340a:	f8c8 3000 	str.w	r3, [r8]
    tprio_t prio = chThdGetPriorityX();
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, prio+1, thread6, "E");
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, prio+2, thread6, "D");
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, prio+3, thread6, "C");
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, prio+4, thread6, "B");
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, prio+5, thread6, "A");
 800340e:	6120      	str	r0, [r4, #16]
 8003410:	2320      	movs	r3, #32
 8003412:	f383 8811 	msr	BASEPRI, r3
     then waiting for the threads to terminate in priority order, the
     order is tested.*/
  test_set_step(2);
  {
    chSysLock();
    chCondSignalI(&c1);
 8003416:	f002 fbeb 	bl	8005bf0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 800341a:	f002 fbe9 	bl	8005bf0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 800341e:	f002 fbe7 	bl	8005bf0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8003422:	f002 fbe5 	bl	8005bf0 <chCondSignalI.constprop.58>
    chCondSignalI(&c1);
 8003426:	f002 fbe3 	bl	8005bf0 <chCondSignalI.constprop.58>
    chSchRescheduleS();
 800342a:	f001 ff29 	bl	8005280 <chSchRescheduleS>
 800342e:	2300      	movs	r3, #0
 8003430:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_wait_threads();
 8003434:	f000 fc6c 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCDE", "invalid sequence");
 8003438:	480b      	ldr	r0, [pc, #44]	; (8003468 <test_005_007_execute.lto_priv.124+0xc8>)
 800343a:	490c      	ldr	r1, [pc, #48]	; (800346c <test_005_007_execute.lto_priv.124+0xcc>)
  }
}
 800343c:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
    chCondSignalI(&c1);
    chCondSignalI(&c1);
    chSchRescheduleS();
    chSysUnlock();
    test_wait_threads();
    test_assert_sequence("ABCDE", "invalid sequence");
 8003440:	f000 bd16 	b.w	8003e70 <_test_assert_sequence>
 8003444:	200013b0 	.word	0x200013b0
 8003448:	20000c50 	.word	0x20000c50
 800344c:	080036a1 	.word	0x080036a1
 8003450:	08006f4c 	.word	0x08006f4c
 8003454:	20001340 	.word	0x20001340
 8003458:	08006f44 	.word	0x08006f44
 800345c:	08006f40 	.word	0x08006f40
 8003460:	08006f3c 	.word	0x08006f3c
 8003464:	08006f38 	.word	0x08006f38
 8003468:	08006f48 	.word	0x08006f48
 800346c:	08006f50 	.word	0x08006f50
 8003470:	2000133c 	.word	0x2000133c
 8003474:	f3af 8000 	nop.w
 8003478:	f3af 8000 	nop.w
 800347c:	f3af 8000 	nop.w

08003480 <test_005_005_execute.lto_priv.122>:

static void test_005_005_setup(void) {
  chMtxObjectInit(&m1);
}

static void test_005_005_execute(void) {
 8003480:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003484:	4d4e      	ldr	r5, [pc, #312]	; (80035c0 <test_005_005_execute.lto_priv.122+0x140>)
    prio = chThdGetPriorityX();
  }

  /* [5.5.2] Locking the mutex first time, it must be possible because
     it is not owned.*/
  test_set_step(2);
 8003486:	4c4f      	ldr	r4, [pc, #316]	; (80035c4 <test_005_005_execute.lto_priv.122+0x144>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8003488:	69aa      	ldr	r2, [r5, #24]
 800348a:	2302      	movs	r3, #2
 800348c:	6896      	ldr	r6, [r2, #8]
 800348e:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8003490:	f002 fb76 	bl	8005b80 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 8003494:	494c      	ldr	r1, [pc, #304]	; (80035c8 <test_005_005_execute.lto_priv.122+0x148>)
 8003496:	f000 fd13 	bl	8003ec0 <_test_assert>
 800349a:	b108      	cbz	r0, 80034a0 <test_005_005_execute.lto_priv.122+0x20>
 800349c:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  }

  /* [5.5.3] Locking the mutex second time, it must fail because it is
     already owned.*/
  test_set_step(3);
 80034a0:	2303      	movs	r3, #3
 80034a2:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 80034a4:	f002 fb6c 	bl	8005b80 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 80034a8:	f080 0001 	eor.w	r0, r0, #1
 80034ac:	b2c0      	uxtb	r0, r0
 80034ae:	4947      	ldr	r1, [pc, #284]	; (80035cc <test_005_005_execute.lto_priv.122+0x14c>)
 80034b0:	f000 fd06 	bl	8003ec0 <_test_assert>
 80034b4:	2800      	cmp	r0, #0
 80034b6:	d1f1      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
  {
    chMtxUnlock(&m1);
 80034b8:	4f45      	ldr	r7, [pc, #276]	; (80035d0 <test_005_005_execute.lto_priv.122+0x150>)
    test_assert(!b, "not locked");
  }

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 80034ba:	2304      	movs	r3, #4
  {
    chMtxUnlock(&m1);
 80034bc:	4638      	mov	r0, r7
    test_assert(!b, "not locked");
  }

  /* [5.5.4] Unlocking the mutex then it must not be owned anymore and
     the queue must be empty.*/
  test_set_step(4);
 80034be:	6023      	str	r3, [r4, #0]
  {
    chMtxUnlock(&m1);
 80034c0:	f002 f80e 	bl	80054e0 <chMtxUnlock>
    test_assert(m1.owner == NULL, "still owned");
 80034c4:	68b8      	ldr	r0, [r7, #8]
 80034c6:	4943      	ldr	r1, [pc, #268]	; (80035d4 <test_005_005_execute.lto_priv.122+0x154>)
 80034c8:	fab0 f080 	clz	r0, r0
 80034cc:	0940      	lsrs	r0, r0, #5
 80034ce:	f000 fcf7 	bl	8003ec0 <_test_assert>
 80034d2:	2800      	cmp	r0, #0
 80034d4:	d1e2      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 80034d6:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 80034d8:	493f      	ldr	r1, [pc, #252]	; (80035d8 <test_005_005_execute.lto_priv.122+0x158>)
 80034da:	1bc0      	subs	r0, r0, r7
 80034dc:	fab0 f080 	clz	r0, r0
 80034e0:	0940      	lsrs	r0, r0, #5
 80034e2:	f000 fced 	bl	8003ec0 <_test_assert>
 80034e6:	2800      	cmp	r0, #0
 80034e8:	d1d8      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
 80034ea:	69ab      	ldr	r3, [r5, #24]
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80034ec:	493b      	ldr	r1, [pc, #236]	; (80035dc <test_005_005_execute.lto_priv.122+0x15c>)
 80034ee:	6898      	ldr	r0, [r3, #8]
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 80034f0:	2305      	movs	r3, #5
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80034f2:	1a30      	subs	r0, r6, r0
 80034f4:	fab0 f080 	clz	r0, r0
 80034f8:	0940      	lsrs	r0, r0, #5
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.5] Testing that priority has not changed after operations.*/
  test_set_step(5);
 80034fa:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80034fc:	f000 fce0 	bl	8003ec0 <_test_assert>
 8003500:	2800      	cmp	r0, #0
 8003502:	d1cb      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
  }

  /* [5.5.6] Testing chMtxUnlockAll() behavior.*/
  test_set_step(6);
 8003504:	2306      	movs	r3, #6
 8003506:	6023      	str	r3, [r4, #0]
  {
    b = chMtxTryLock(&m1);
 8003508:	f002 fb3a 	bl	8005b80 <chMtxTryLock.constprop.61>
    test_assert(b, "already locked");
 800350c:	492e      	ldr	r1, [pc, #184]	; (80035c8 <test_005_005_execute.lto_priv.122+0x148>)
 800350e:	f000 fcd7 	bl	8003ec0 <_test_assert>
 8003512:	2800      	cmp	r0, #0
 8003514:	d1c2      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
    b = chMtxTryLock(&m1);
 8003516:	f002 fb33 	bl	8005b80 <chMtxTryLock.constprop.61>
    test_assert(!b, "not locked");
 800351a:	f080 0001 	eor.w	r0, r0, #1
 800351e:	b2c0      	uxtb	r0, r0
 8003520:	492a      	ldr	r1, [pc, #168]	; (80035cc <test_005_005_execute.lto_priv.122+0x14c>)
 8003522:	f000 fccd 	bl	8003ec0 <_test_assert>
 8003526:	2800      	cmp	r0, #0
 8003528:	d1b8      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
 *          inheritance mechanism.
 *
 * @api
 */
void chMtxUnlockAll(void) {
  thread_t *ctp = currp;
 800352a:	f8d5 8018 	ldr.w	r8, [r5, #24]
 800352e:	2320      	movs	r3, #32
 8003530:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if (ctp->mtxlist != NULL) {
 8003534:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8003538:	b1fb      	cbz	r3, 800357a <test_005_005_execute.lto_priv.122+0xfa>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 800353a:	4681      	mov	r9, r0
 800353c:	e00d      	b.n	800355a <test_005_005_execute.lto_priv.122+0xda>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 800353e:	6811      	ldr	r1, [r2, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
 8003540:	f8d2 e038 	ldr.w	lr, [r2, #56]	; 0x38
 8003544:	6019      	str	r1, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8003546:	604b      	str	r3, [r1, #4]
      if (chMtxQueueNotEmptyS(mp)) {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)1;
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
 8003548:	609a      	str	r2, [r3, #8]
        mp->next = tp->mtxlist;
 800354a:	f8c3 e00c 	str.w	lr, [r3, #12]
        tp->mtxlist = mp;
 800354e:	6393      	str	r3, [r2, #56]	; 0x38
        (void) chSchReadyI(tp);
 8003550:	f001 ff86 	bl	8005460 <chSchReadyI>
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
      }
    } while (ctp->mtxlist != NULL);
 8003554:	f8d8 3038 	ldr.w	r3, [r8, #56]	; 0x38
 8003558:	b14b      	cbz	r3, 800356e <test_005_005_execute.lto_priv.122+0xee>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 800355a:	681a      	ldr	r2, [r3, #0]

  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
 800355c:	68d9      	ldr	r1, [r3, #12]
 800355e:	f8c8 1038 	str.w	r1, [r8, #56]	; 0x38
      if (chMtxQueueNotEmptyS(mp)) {
 8003562:	4293      	cmp	r3, r2
#endif
        thread_t *tp = queue_fifo_remove(&mp->queue);
        mp->owner = tp;
        mp->next = tp->mtxlist;
        tp->mtxlist = mp;
        (void) chSchReadyI(tp);
 8003564:	4610      	mov	r0, r2
  chSysLock();
  if (ctp->mtxlist != NULL) {
    do {
      mutex_t *mp = ctp->mtxlist;
      ctp->mtxlist = mp->next;
      if (chMtxQueueNotEmptyS(mp)) {
 8003566:	d1ea      	bne.n	800353e <test_005_005_execute.lto_priv.122+0xbe>
      }
      else {
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
        mp->cnt = (cnt_t)0;
#endif
        mp->owner = NULL;
 8003568:	f8c3 9008 	str.w	r9, [r3, #8]
 800356c:	e7f2      	b.n	8003554 <test_005_005_execute.lto_priv.122+0xd4>
      }
    } while (ctp->mtxlist != NULL);
    ctp->prio = ctp->realprio;
 800356e:	f8d8 303c 	ldr.w	r3, [r8, #60]	; 0x3c
 8003572:	f8c8 3008 	str.w	r3, [r8, #8]
    chSchRescheduleS();
 8003576:	f001 fe83 	bl	8005280 <chSchRescheduleS>
 800357a:	2300      	movs	r3, #0
 800357c:	f383 8811 	msr	BASEPRI, r3

    chMtxUnlockAll();
    test_assert(m1.owner == NULL, "still owned");
 8003580:	4914      	ldr	r1, [pc, #80]	; (80035d4 <test_005_005_execute.lto_priv.122+0x154>)
 8003582:	68b8      	ldr	r0, [r7, #8]
 8003584:	fab0 f080 	clz	r0, r0
 8003588:	0940      	lsrs	r0, r0, #5
 800358a:	4f11      	ldr	r7, [pc, #68]	; (80035d0 <test_005_005_execute.lto_priv.122+0x150>)
 800358c:	f000 fc98 	bl	8003ec0 <_test_assert>
 8003590:	2800      	cmp	r0, #0
 8003592:	d183      	bne.n	800349c <test_005_005_execute.lto_priv.122+0x1c>
 *
 * @notapi
 */
static inline bool queue_isempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next == (const thread_t *)tqp);
 8003594:	6838      	ldr	r0, [r7, #0]
    test_assert(queue_isempty(&m1.queue), "queue not empty");
 8003596:	4910      	ldr	r1, [pc, #64]	; (80035d8 <test_005_005_execute.lto_priv.122+0x158>)
 8003598:	1bc7      	subs	r7, r0, r7
 800359a:	4278      	negs	r0, r7
 800359c:	4178      	adcs	r0, r7
 800359e:	f000 fc8f 	bl	8003ec0 <_test_assert>
 80035a2:	2800      	cmp	r0, #0
 80035a4:	f47f af7a 	bne.w	800349c <test_005_005_execute.lto_priv.122+0x1c>
 80035a8:	69ab      	ldr	r3, [r5, #24]
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80035aa:	490c      	ldr	r1, [pc, #48]	; (80035dc <test_005_005_execute.lto_priv.122+0x15c>)
 80035ac:	6898      	ldr	r0, [r3, #8]
 80035ae:	1a32      	subs	r2, r6, r0
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 80035b0:	2307      	movs	r3, #7
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80035b2:	4250      	negs	r0, r2
    test_assert(m1.owner == NULL, "still owned");
    test_assert(queue_isempty(&m1.queue), "queue not empty");
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
 80035b4:	6023      	str	r3, [r4, #0]
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80035b6:	4150      	adcs	r0, r2
  }
}
 80035b8:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  }

  /* [5.5.7] Testing that priority has not changed after operations.*/
  test_set_step(7);
  {
    test_assert(chThdGetPriorityX() == prio, "wrong priority level");
 80035bc:	f000 bc80 	b.w	8003ec0 <_test_assert>
 80035c0:	200013b0 	.word	0x200013b0
 80035c4:	2000133c 	.word	0x2000133c
 80035c8:	08007180 	.word	0x08007180
 80035cc:	08007190 	.word	0x08007190
 80035d0:	200008a0 	.word	0x200008a0
 80035d4:	0800719c 	.word	0x0800719c
 80035d8:	08006ee8 	.word	0x08006ee8
 80035dc:	08007168 	.word	0x08007168

080035e0 <thread4B>:
  chThdSleepMilliseconds(50);
  chMtxLock(&m1);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread4B, p) {
 80035e0:	b510      	push	{r4, lr}

  (void)p;
  chThdSleepMilliseconds(150);
 80035e2:	f240 50dc 	movw	r0, #1500	; 0x5dc
 80035e6:	f002 f963 	bl	80058b0 <chThdSleep>
 80035ea:	2320      	movs	r3, #32
 80035ec:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  chMtxLockS(&m2);   /* For coverage of the chMtxLockS() function variant.*/
 80035f0:	4c06      	ldr	r4, [pc, #24]	; (800360c <thread4B+0x2c>)
 80035f2:	4620      	mov	r0, r4
 80035f4:	f001 ffac 	bl	8005550 <chMtxLockS>
  chMtxUnlockS(&m2); /* For coverage of the chMtxUnlockS() function variant.*/
 80035f8:	4620      	mov	r0, r4
 80035fa:	f001 ff49 	bl	8005490 <chMtxUnlockS>
  chSchRescheduleS();
 80035fe:	f001 fe3f 	bl	8005280 <chSchRescheduleS>
 8003602:	2300      	movs	r3, #0
 8003604:	f383 8811 	msr	BASEPRI, r3
 8003608:	bd10      	pop	{r4, pc}
 800360a:	bf00      	nop
 800360c:	2000083c 	.word	0x2000083c

08003610 <thread8>:
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
}

static THD_FUNCTION(thread8, p) {
 8003610:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003612:	4607      	mov	r7, r0

  chMtxLock(&m2);
 8003614:	481b      	ldr	r0, [pc, #108]	; (8003684 <thread8+0x74>)
 8003616:	f002 f803 	bl	8005620 <chMtxLock>
  chMtxLock(&m1);
 800361a:	481b      	ldr	r0, [pc, #108]	; (8003688 <thread8+0x78>)
 800361c:	f002 f800 	bl	8005620 <chMtxLock>
 8003620:	2320      	movs	r3, #32
 8003622:	f383 8811 	msr	BASEPRI, r3
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8003626:	4d19      	ldr	r5, [pc, #100]	; (800368c <thread8+0x7c>)
 *
 * @sclass
 */
static inline mutex_t *chMtxGetNextMutexS(void) {

  return chThdGetSelfX()->mtxlist;
 8003628:	69ab      	ldr	r3, [r5, #24]
 800362a:	6b9e      	ldr	r6, [r3, #56]	; 0x38
  chDbgCheck((cp != NULL) && (time != TIME_IMMEDIATE));
  chDbgAssert(currp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 800362c:	4630      	mov	r0, r6
 800362e:	f001 ff2f 	bl	8005490 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  currp->u.wtobjp = cp;
 8003632:	4b17      	ldr	r3, [pc, #92]	; (8003690 <thread8+0x80>)
 8003634:	69ac      	ldr	r4, [r5, #24]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8003636:	4618      	mov	r0, r3
 8003638:	6263      	str	r3, [r4, #36]	; 0x24
 800363a:	e003      	b.n	8003644 <thread8+0x34>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800363c:	6899      	ldr	r1, [r3, #8]
 800363e:	68a2      	ldr	r2, [r4, #8]
 8003640:	4291      	cmp	r1, r2
 8003642:	d302      	bcc.n	800364a <thread8+0x3a>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8003644:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8003646:	4283      	cmp	r3, r0
 8003648:	d1f8      	bne.n	800363c <thread8+0x2c>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800364a:	685a      	ldr	r2, [r3, #4]
 800364c:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800364e:	6023      	str	r3, [r4, #0]
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8003650:	2007      	movs	r0, #7
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8003652:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8003654:	605c      	str	r4, [r3, #4]
 8003656:	f001 fea3 	bl	80053a0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 800365a:	69ab      	ldr	r3, [r5, #24]
  queue_prio_insert(currp, &cp->queue);
  msg = chSchGoSleepTimeoutS(CH_STATE_WTCOND, time);
  if (msg != MSG_TIMEOUT) {
 800365c:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 800365e:	3301      	adds	r3, #1
 8003660:	d002      	beq.n	8003668 <thread8+0x58>
    chMtxLockS(mp);
 8003662:	4630      	mov	r0, r6
 8003664:	f001 ff74 	bl	8005550 <chMtxLockS>
 8003668:	2300      	movs	r3, #0
 800366a:	f383 8811 	msr	BASEPRI, r3
#if CH_CFG_USE_CONDVARS_TIMEOUT || defined(__DOXYGEN__)
  chCondWaitTimeout(&c1, TIME_INFINITE);
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
 800366e:	7838      	ldrb	r0, [r7, #0]
 8003670:	f000 fb86 	bl	8003d80 <test_emit_token>
  chMtxUnlock(&m1);
 8003674:	4804      	ldr	r0, [pc, #16]	; (8003688 <thread8+0x78>)
 8003676:	f001 ff33 	bl	80054e0 <chMtxUnlock>
  chMtxUnlock(&m2);
 800367a:	4802      	ldr	r0, [pc, #8]	; (8003684 <thread8+0x74>)
}
 800367c:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
#else
  chCondWait(&c1);
#endif
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
  chMtxUnlock(&m2);
 8003680:	f001 bf2e 	b.w	80054e0 <chMtxUnlock>
 8003684:	2000083c 	.word	0x2000083c
 8003688:	200008a0 	.word	0x200008a0
 800368c:	200013b0 	.word	0x200013b0
 8003690:	20000858 	.word	0x20000858
 8003694:	f3af 8000 	nop.w
 8003698:	f3af 8000 	nop.w
 800369c:	f3af 8000 	nop.w

080036a0 <thread6>:
  chSchRescheduleS();
  chSysUnlock();
}

#if CH_CFG_USE_CONDVARS || defined(__DOXYGEN__)
static THD_FUNCTION(thread6, p) {
 80036a0:	b570      	push	{r4, r5, r6, lr}
 80036a2:	4606      	mov	r6, r0

  chMtxLock(&m1);
 80036a4:	4816      	ldr	r0, [pc, #88]	; (8003700 <thread6+0x60>)
 80036a6:	f001 ffbb 	bl	8005620 <chMtxLock>
 80036aa:	2320      	movs	r3, #32
 80036ac:	f383 8811 	msr	BASEPRI, r3
 *                      @p chCondBroadcast().
 *
 * @sclass
 */
msg_t chCondWaitS(condition_variable_t *cp) {
  thread_t *ctp = currp;
 80036b0:	4b14      	ldr	r3, [pc, #80]	; (8003704 <thread6+0x64>)
 80036b2:	699c      	ldr	r4, [r3, #24]
 80036b4:	6ba5      	ldr	r5, [r4, #56]	; 0x38
  chDbgCheck(cp != NULL);
  chDbgAssert(ctp->mtxlist != NULL, "not owning a mutex");

  /* Getting "current" mutex and releasing it.*/
  mp = chMtxGetNextMutexS();
  chMtxUnlockS(mp);
 80036b6:	4628      	mov	r0, r5
 80036b8:	f001 feea 	bl	8005490 <chMtxUnlockS>

  /* Start waiting on the condition variable, on exit the mutex is taken
     again.*/
  ctp->u.wtobjp = cp;
 80036bc:	4812      	ldr	r0, [pc, #72]	; (8003708 <thread6+0x68>)
 80036be:	6260      	str	r0, [r4, #36]	; 0x24
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80036c0:	4603      	mov	r3, r0
 80036c2:	e003      	b.n	80036cc <thread6+0x2c>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80036c4:	6899      	ldr	r1, [r3, #8]
 80036c6:	68a2      	ldr	r2, [r4, #8]
 80036c8:	4291      	cmp	r1, r2
 80036ca:	d302      	bcc.n	80036d2 <thread6+0x32>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80036cc:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80036ce:	4283      	cmp	r3, r0
 80036d0:	d1f8      	bne.n	80036c4 <thread6+0x24>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80036d2:	685a      	ldr	r2, [r3, #4]
 80036d4:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80036d6:	6023      	str	r3, [r4, #0]
  queue_prio_insert(ctp, &cp->queue);
  chSchGoSleepS(CH_STATE_WTCOND);
 80036d8:	2007      	movs	r0, #7
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80036da:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80036dc:	605c      	str	r4, [r3, #4]
 80036de:	f001 fe5f 	bl	80053a0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
  chMtxLockS(mp);
 80036e2:	4628      	mov	r0, r5
 80036e4:	f001 ff34 	bl	8005550 <chMtxLockS>
 80036e8:	2300      	movs	r3, #0
 80036ea:	f383 8811 	msr	BASEPRI, r3
  chCondWait(&c1);
  test_emit_token(*(char *)p);
 80036ee:	7830      	ldrb	r0, [r6, #0]
 80036f0:	f000 fb46 	bl	8003d80 <test_emit_token>
  chMtxUnlock(&m1);
 80036f4:	4802      	ldr	r0, [pc, #8]	; (8003700 <thread6+0x60>)
}
 80036f6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static THD_FUNCTION(thread6, p) {

  chMtxLock(&m1);
  chCondWait(&c1);
  test_emit_token(*(char *)p);
  chMtxUnlock(&m1);
 80036fa:	f001 bef1 	b.w	80054e0 <chMtxUnlock>
 80036fe:	bf00      	nop
 8003700:	200008a0 	.word	0x200008a0
 8003704:	200013b0 	.word	0x200013b0
 8003708:	20000858 	.word	0x20000858
 800370c:	f3af 8000 	nop.w

08003710 <notify1.lto_priv.77>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8003710:	4a02      	ldr	r2, [pc, #8]	; (800371c <notify1.lto_priv.77+0xc>)
 8003712:	6813      	ldr	r3, [r2, #0]
 8003714:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8003718:	6013      	str	r3, [r2, #0]
 800371a:	4770      	bx	lr
 800371c:	40013800 	.word	0x40013800

08003720 <_port_irq_epilogue>:
 8003720:	2320      	movs	r3, #32
 8003722:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8003726:	4b0f      	ldr	r3, [pc, #60]	; (8003764 <_port_irq_epilogue+0x44>)
 8003728:	685b      	ldr	r3, [r3, #4]
 800372a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800372e:	d102      	bne.n	8003736 <_port_irq_epilogue+0x16>
 8003730:	f383 8811 	msr	BASEPRI, r3
 8003734:	4770      	bx	lr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003736:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 800373a:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800373e:	f843 2c04 	str.w	r2, [r3, #-4]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8003742:	f1a3 0220 	sub.w	r2, r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003746:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.queue);
 800374a:	4a07      	ldr	r2, [pc, #28]	; (8003768 <_port_irq_epilogue+0x48>)
 800374c:	6811      	ldr	r1, [r2, #0]
  tprio_t p2 = currp->prio;
 800374e:	6992      	ldr	r2, [r2, #24]
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 8003750:	6889      	ldr	r1, [r1, #8]
 8003752:	6892      	ldr	r2, [r2, #8]
 8003754:	4291      	cmp	r1, r2
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 8003756:	bf8c      	ite	hi
 8003758:	4a04      	ldrhi	r2, [pc, #16]	; (800376c <_port_irq_epilogue+0x4c>)
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 800375a:	4a05      	ldrls	r2, [pc, #20]	; (8003770 <_port_irq_epilogue+0x50>)
 800375c:	f843 2c08 	str.w	r2, [r3, #-8]
 8003760:	4770      	bx	lr
 8003762:	bf00      	nop
 8003764:	e000ed00 	.word	0xe000ed00
 8003768:	200013b0 	.word	0x200013b0
 800376c:	080002f5 	.word	0x080002f5
 8003770:	080002f8 	.word	0x080002f8
 8003774:	f3af 8000 	nop.w
 8003778:	f3af 8000 	nop.w
 800377c:	f3af 8000 	nop.w

08003780 <VectorB0>:
 * @brief   TIM2 interrupt handler.
 * @details This interrupt is used for system tick in free running mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(ST_HANDLER) {
 8003780:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  OSAL_IRQ_PROLOGUE();

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
 8003784:	f04f 4580 	mov.w	r5, #1073741824	; 0x40000000
 8003788:	692b      	ldr	r3, [r5, #16]
 800378a:	079b      	lsls	r3, r3, #30
 800378c:	d403      	bmi.n	8003796 <VectorB0+0x16>
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 800378e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003792:	f7ff bfc5 	b.w	8003720 <_port_irq_epilogue>

  /* Note, under rare circumstances an interrupt can remain latched even if
     the timer SR register has been cleared, in those cases the interrupt
     is simply ignored.*/
  if ((STM32_ST_TIM->SR & TIM_SR_CC1IF) != 0U) {
    STM32_ST_TIM->SR = 0U;
 8003796:	2700      	movs	r7, #0
 8003798:	612f      	str	r7, [r5, #16]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800379a:	2620      	movs	r6, #32
 800379c:	f386 8811 	msr	BASEPRI, r6
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  virtual_timer_t *vtp;
  systime_t now, delta;

  /* First timer to be processed.*/
  vtp = ch.vtlist.next;
 80037a0:	f8df 9078 	ldr.w	r9, [pc, #120]	; 800381c <VectorB0+0x9c>
 80037a4:	6a69      	ldr	r1, [r5, #36]	; 0x24
 80037a6:	f8d9 301c 	ldr.w	r3, [r9, #28]

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80037aa:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 80037ae:	689a      	ldr	r2, [r3, #8]
 80037b0:	ebce 0001 	rsb	r0, lr, r1
 80037b4:	4290      	cmp	r0, r2
 80037b6:	f109 081c 	add.w	r8, r9, #28
 80037ba:	d31c      	bcc.n	80037f6 <VectorB0+0x76>
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80037bc:	6819      	ldr	r1, [r3, #0]
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
 80037be:	68dc      	ldr	r4, [r3, #12]
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 80037c0:	4472      	add	r2, lr
    ch.vtlist.next = vtp->next;
    fn = vtp->func;
    vtp->func = NULL;

    /* if the list becomes empty then the timer is stopped.*/
    if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80037c2:	4541      	cmp	r1, r8
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
    vtfunc_t fn;

    /* The "last time" becomes this timer's expiration time.*/
    ch.vtlist.lasttime += vtp->delta;
 80037c4:	f8c9 2028 	str.w	r2, [r9, #40]	; 0x28

    vtp->next->prev = (virtual_timer_t *)&ch.vtlist;
 80037c8:	f8c1 8004 	str.w	r8, [r1, #4]
    ch.vtlist.next = vtp->next;
 80037cc:	f8c9 101c 	str.w	r1, [r9, #28]
    fn = vtp->func;
    vtp->func = NULL;
 80037d0:	60df      	str	r7, [r3, #12]
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 80037d2:	bf08      	it	eq
 80037d4:	60ef      	streq	r7, [r5, #12]
 80037d6:	f387 8811 	msr	BASEPRI, r7
       and in order to give a preemption chance to higher priority
       interrupts.*/
    chSysUnlockFromISR();

    /* The callback is invoked outside the kernel critical zone.*/
    fn(vtp->par);
 80037da:	6918      	ldr	r0, [r3, #16]
 80037dc:	47a0      	blx	r4
 80037de:	f386 8811 	msr	BASEPRI, r6
       of the list.*/
    chSysLockFromISR();

    /* Next element in the list, the current time could have advanced so
       recalculating the time window.*/
    vtp = ch.vtlist.next;
 80037e2:	f8d9 301c 	ldr.w	r3, [r9, #28]
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 80037e6:	6a69      	ldr	r1, [r5, #36]	; 0x24

  /* All timers within the time window are triggered and removed,
     note that the loop is stopped by the timers header having
     "ch.vtlist.vt_delta == (systime_t)-1" which is greater than
     all deltas.*/
  while (vtp->delta <= (systime_t)(now - ch.vtlist.lasttime)) {
 80037e8:	f8d9 e028 	ldr.w	lr, [r9, #40]	; 0x28
 80037ec:	689a      	ldr	r2, [r3, #8]
 80037ee:	ebce 0001 	rsb	r0, lr, r1
 80037f2:	4282      	cmp	r2, r0
 80037f4:	d9e2      	bls.n	80037bc <VectorB0+0x3c>
    vtp = ch.vtlist.next;
    now = chVTGetSystemTimeX();
  }

  /* if the list is empty, nothing else to do.*/
  if (ch.vtlist.next == (virtual_timer_t *)&ch.vtlist) {
 80037f6:	4543      	cmp	r3, r8
 80037f8:	d008      	beq.n	800380c <VectorB0+0x8c>
    return;
  }

  /* Recalculating the next alarm time.*/
  delta = ch.vtlist.lasttime + vtp->delta - now;
 80037fa:	4472      	add	r2, lr
 80037fc:	1a52      	subs	r2, r2, r1
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 80037fe:	2a01      	cmp	r2, #1
 8003800:	bf98      	it	ls
 8003802:	2202      	movls	r2, #2
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 8003804:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  }
  port_timer_set_alarm(now + delta);
 8003808:	440a      	add	r2, r1
 800380a:	635a      	str	r2, [r3, #52]	; 0x34
 800380c:	2300      	movs	r3, #0
 800380e:	f383 8811 	msr	BASEPRI, r3
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
}
 8003812:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    osalSysLockFromISR();
    osalOsTimerHandlerI();
    osalSysUnlockFromISR();
  }

  OSAL_IRQ_EPILOGUE();
 8003816:	f7ff bf83 	b.w	8003720 <_port_irq_epilogue>
 800381a:	bf00      	nop
 800381c:	200013b0 	.word	0x200013b0

08003820 <SVC_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8003820:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 8003824:	3320      	adds	r3, #32
  \details Assigns the given value to the Process Stack Pointer (PSP).
  \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8003826:	f383 8809 	msr	PSP, r3
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800382a:	2300      	movs	r3, #0
 800382c:	f383 8811 	msr	BASEPRI, r3
 8003830:	4770      	bx	lr
 8003832:	bf00      	nop
 8003834:	f3af 8000 	nop.w
 8003838:	f3af 8000 	nop.w
 800383c:	f3af 8000 	nop.w

08003840 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
 8003840:	b430      	push	{r4, r5}
 8003842:	2320      	movs	r3, #32
 8003844:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8003848:	4d0b      	ldr	r5, [pc, #44]	; (8003878 <chCoreAllocAligned+0x38>)

  if (((size_t)endmem - (size_t)p) < size) {
 800384a:	4a0c      	ldr	r2, [pc, #48]	; (800387c <chCoreAllocAligned+0x3c>)
 800384c:	682b      	ldr	r3, [r5, #0]
 800384e:	6812      	ldr	r2, [r2, #0]
 8003850:	3b01      	subs	r3, #1

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 8003852:	440b      	add	r3, r1
 8003854:	1e4c      	subs	r4, r1, #1
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003856:	4249      	negs	r1, r1
 8003858:	4404      	add	r4, r0
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
 800385a:	ea03 0001 	and.w	r0, r3, r1

  if (((size_t)endmem - (size_t)p) < size) {
 800385e:	1a13      	subs	r3, r2, r0
  uint8_t *p;

  chDbgCheckClassI();
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
 8003860:	4021      	ands	r1, r4
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
 8003862:	4299      	cmp	r1, r3
    return NULL;
  }
  nextmem = p + size;
 8003864:	bf9a      	itte	ls
 8003866:	1809      	addls	r1, r1, r0
 8003868:	6029      	strls	r1, [r5, #0]

  size = MEM_ALIGN_NEXT(size, align);
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);

  if (((size_t)endmem - (size_t)p) < size) {
    return NULL;
 800386a:	2000      	movhi	r0, #0
 800386c:	2300      	movs	r3, #0
 800386e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chCoreAllocAlignedI(size, align);
  chSysUnlock();

  return p;
}
 8003872:	bc30      	pop	{r4, r5}
 8003874:	4770      	bx	lr
 8003876:	bf00      	nop
 8003878:	20000998 	.word	0x20000998
 800387c:	200012b8 	.word	0x200012b8

08003880 <vtcb>:
/****************************************************************************
 * Shared code.
 ****************************************************************************/

/* Timer callback for testing system functions in ISR context.*/
static void vtcb(void *p) {
 8003880:	b508      	push	{r3, lr}
 8003882:	2320      	movs	r3, #32
 8003884:	f383 8811 	msr	BASEPRI, r3
 8003888:	2200      	movs	r2, #0
 800388a:	f382 8811 	msr	BASEPRI, r2
 800388e:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003892:	f3ef 8311 	mrs	r3, BASEPRI
 * @xclass
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
 8003896:	b91b      	cbnz	r3, 80038a0 <vtcb+0x20>
 8003898:	f002 f82a 	bl	80058f0 <chSysGetStatusAndLockX.part.1.lto_priv.193>
 800389c:	f002 f818 	bl	80058d0 <chSysRestoreStatusX.part.2.lto_priv.192>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80038a0:	2300      	movs	r3, #0
 80038a2:	f383 8811 	msr	BASEPRI, r3
 80038a6:	bd08      	pop	{r3, pc}
 80038a8:	f3af 8000 	nop.w
 80038ac:	f3af 8000 	nop.w

080038b0 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 80038b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
  USART_TypeDef *u = sdp->usart;
 80038b4:	4d64      	ldr	r5, [pc, #400]	; (8003a48 <VectorD4+0x198>)
 80038b6:	6d6e      	ldr	r6, [r5, #84]	; 0x54
  uint32_t cr1 = u->CR1;
 80038b8:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80038ba:	69f4      	ldr	r4, [r6, #28]
  u->ICR = isr;
 80038bc:	6234      	str	r4, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80038be:	0722      	lsls	r2, r4, #28
 80038c0:	d156      	bne.n	8003970 <VectorD4+0xc0>
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80038c2:	05e3      	lsls	r3, r4, #23
 80038c4:	d448      	bmi.n	8003958 <VectorD4+0xa8>
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 80038c6:	06a0      	lsls	r0, r4, #26
 80038c8:	d418      	bmi.n	80038fc <VectorD4+0x4c>
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 80038ca:	0639      	lsls	r1, r7, #24
 80038cc:	d501      	bpl.n	80038d2 <VectorD4+0x22>
 80038ce:	0622      	lsls	r2, r4, #24
 80038d0:	d469      	bmi.n	80039a6 <VectorD4+0xf6>
      u->TDR = b;
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 80038d2:	0663      	lsls	r3, r4, #25
 80038d4:	d50e      	bpl.n	80038f4 <VectorD4+0x44>
 80038d6:	2320      	movs	r3, #32
 80038d8:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 80038dc:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80038de:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80038e0:	4859      	ldr	r0, [pc, #356]	; (8003a48 <VectorD4+0x198>)
 80038e2:	429a      	cmp	r2, r3
 80038e4:	f000 808c 	beq.w	8003a00 <VectorD4+0x150>
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80038e8:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 80038ec:	6037      	str	r7, [r6, #0]
 80038ee:	2300      	movs	r3, #0
 80038f0:	f383 8811 	msr	BASEPRI, r3
  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
}
 80038f4:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 80038f8:	f7ff bf12 	b.w	8003720 <_port_irq_epilogue>
 80038fc:	2320      	movs	r3, #32
 80038fe:	f383 8811 	msr	BASEPRI, r3
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR & sdp->rxmask);
 8003902:	8cb2      	ldrh	r2, [r6, #36]	; 0x24
 8003904:	f895 805c 	ldrb.w	r8, [r5, #92]	; 0x5c
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8003908:	696b      	ldr	r3, [r5, #20]
 800390a:	ea08 0802 	and.w	r8, r8, r2
 800390e:	2b00      	cmp	r3, #0
 8003910:	d07f      	beq.n	8003a12 <VectorD4+0x162>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8003912:	6a2b      	ldr	r3, [r5, #32]
 8003914:	6a6a      	ldr	r2, [r5, #36]	; 0x24
 8003916:	484c      	ldr	r0, [pc, #304]	; (8003a48 <VectorD4+0x198>)
 8003918:	4293      	cmp	r3, r2
 800391a:	d07f      	beq.n	8003a1c <VectorD4+0x16c>
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 800391c:	696a      	ldr	r2, [r5, #20]
 800391e:	494a      	ldr	r1, [pc, #296]	; (8003a48 <VectorD4+0x198>)
 8003920:	3201      	adds	r2, #1
  *iqp->q_wrptr++ = b;
 8003922:	1c58      	adds	r0, r3, #1

  if (iqIsFullI(iqp)) {
    return MSG_TIMEOUT;
  }

  iqp->q_counter++;
 8003924:	616a      	str	r2, [r5, #20]
  *iqp->q_wrptr++ = b;
 8003926:	6228      	str	r0, [r5, #32]
 8003928:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 800392c:	6a2a      	ldr	r2, [r5, #32]
 800392e:	69eb      	ldr	r3, [r5, #28]
 8003930:	429a      	cmp	r2, r3
 8003932:	d262      	bcs.n	80039fa <VectorD4+0x14a>
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8003934:	4944      	ldr	r1, [pc, #272]	; (8003a48 <VectorD4+0x198>)
 8003936:	68eb      	ldr	r3, [r5, #12]
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 8003938:	f101 020c 	add.w	r2, r1, #12
 800393c:	4293      	cmp	r3, r2
 800393e:	d007      	beq.n	8003950 <VectorD4+0xa0>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8003940:	6818      	ldr	r0, [r3, #0]
 8003942:	60c8      	str	r0, [r1, #12]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 8003944:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8003946:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 8003948:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 800394a:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 800394c:	f001 fd88 	bl	8005460 <chSchReadyI>
 8003950:	2300      	movs	r3, #0
 8003952:	f383 8811 	msr	BASEPRI, r3
 8003956:	e7b8      	b.n	80038ca <VectorD4+0x1a>
 8003958:	2320      	movs	r3, #32
 800395a:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 800395e:	483b      	ldr	r0, [pc, #236]	; (8003a4c <VectorD4+0x19c>)
 8003960:	f44f 7100 	mov.w	r1, #512	; 0x200
 8003964:	f001 fb54 	bl	8005010 <chEvtBroadcastFlagsI>
 8003968:	2300      	movs	r3, #0
 800396a:	f383 8811 	msr	BASEPRI, r3
 800396e:	e7aa      	b.n	80038c6 <VectorD4+0x16>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 8003970:	f014 0f08 	tst.w	r4, #8
 8003974:	bf0c      	ite	eq
 8003976:	2100      	moveq	r1, #0
 8003978:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
 800397a:	07e3      	lsls	r3, r4, #31
    sts |= SD_PARITY_ERROR;
 800397c:	bf48      	it	mi
 800397e:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 8003982:	07a0      	lsls	r0, r4, #30
    sts |= SD_FRAMING_ERROR;
 8003984:	bf48      	it	mi
 8003986:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 800398a:	0762      	lsls	r2, r4, #29
    sts |= SD_NOISE_ERROR;
 800398c:	bf48      	it	mi
 800398e:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 8003992:	2320      	movs	r3, #32
 8003994:	f383 8811 	msr	BASEPRI, r3
 8003998:	482c      	ldr	r0, [pc, #176]	; (8003a4c <VectorD4+0x19c>)
 800399a:	f001 fb39 	bl	8005010 <chEvtBroadcastFlagsI>
 800399e:	2300      	movs	r3, #0
 80039a0:	f383 8811 	msr	BASEPRI, r3
 80039a4:	e78d      	b.n	80038c2 <VectorD4+0x12>
 80039a6:	2320      	movs	r3, #32
 80039a8:	f383 8811 	msr	BASEPRI, r3
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 80039ac:	6cab      	ldr	r3, [r5, #72]	; 0x48
 80039ae:	6c6a      	ldr	r2, [r5, #68]	; 0x44
 80039b0:	4825      	ldr	r0, [pc, #148]	; (8003a48 <VectorD4+0x198>)
 80039b2:	429a      	cmp	r2, r3
 80039b4:	d03b      	beq.n	8003a2e <VectorD4+0x17e>
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 80039b6:	6baa      	ldr	r2, [r5, #56]	; 0x38
 80039b8:	4923      	ldr	r1, [pc, #140]	; (8003a48 <VectorD4+0x198>)
  b = *oqp->q_rdptr++;
 80039ba:	1c58      	adds	r0, r3, #1

  if (oqIsEmptyI(oqp)) {
    return MSG_TIMEOUT;
  }

  oqp->q_counter++;
 80039bc:	3201      	adds	r2, #1
 80039be:	63aa      	str	r2, [r5, #56]	; 0x38
  b = *oqp->q_rdptr++;
 80039c0:	64a8      	str	r0, [r5, #72]	; 0x48
 80039c2:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 80039c6:	6c2b      	ldr	r3, [r5, #64]	; 0x40
 80039c8:	4298      	cmp	r0, r3
 80039ca:	d301      	bcc.n	80039d0 <VectorD4+0x120>
    oqp->q_rdptr = oqp->q_buffer;
 80039cc:	6bcb      	ldr	r3, [r1, #60]	; 0x3c
 80039ce:	648b      	str	r3, [r1, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80039d0:	491d      	ldr	r1, [pc, #116]	; (8003a48 <VectorD4+0x198>)
 80039d2:	6b2b      	ldr	r3, [r5, #48]	; 0x30
 80039d4:	f101 0230 	add.w	r2, r1, #48	; 0x30
 80039d8:	4293      	cmp	r3, r2
 80039da:	d007      	beq.n	80039ec <VectorD4+0x13c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80039dc:	6818      	ldr	r0, [r3, #0]
 80039de:	6308      	str	r0, [r1, #48]	; 0x30

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80039e0:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 80039e2:	6042      	str	r2, [r0, #4]
  (void) chSchReadyI(tp);
 80039e4:	4618      	mov	r0, r3

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->state == CH_STATE_QUEUED, "invalid state");

  tp->u.rdymsg = msg;
 80039e6:	6259      	str	r1, [r3, #36]	; 0x24
  (void) chSchReadyI(tp);
 80039e8:	f001 fd3a 	bl	8005460 <chSchReadyI>
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 80039ec:	fa1f f388 	uxth.w	r3, r8
 80039f0:	8533      	strh	r3, [r6, #40]	; 0x28
 80039f2:	2300      	movs	r3, #0
 80039f4:	f383 8811 	msr	BASEPRI, r3
 80039f8:	e76b      	b.n	80038d2 <VectorD4+0x22>
  }

  iqp->q_counter++;
  *iqp->q_wrptr++ = b;
  if (iqp->q_wrptr >= iqp->q_top) {
    iqp->q_wrptr = iqp->q_buffer;
 80039fa:	698b      	ldr	r3, [r1, #24]
 80039fc:	620b      	str	r3, [r1, #32]
 80039fe:	e799      	b.n	8003934 <VectorD4+0x84>
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
 8003a00:	6b83      	ldr	r3, [r0, #56]	; 0x38
 8003a02:	2b00      	cmp	r3, #0
 8003a04:	f43f af70 	beq.w	80038e8 <VectorD4+0x38>
 8003a08:	3004      	adds	r0, #4
 8003a0a:	2110      	movs	r1, #16
 8003a0c:	f001 fb00 	bl	8005010 <chEvtBroadcastFlagsI>
 8003a10:	e76a      	b.n	80038e8 <VectorD4+0x38>
 8003a12:	480e      	ldr	r0, [pc, #56]	; (8003a4c <VectorD4+0x19c>)
 8003a14:	2104      	movs	r1, #4
 8003a16:	f001 fafb 	bl	8005010 <chEvtBroadcastFlagsI>
 8003a1a:	e77a      	b.n	8003912 <VectorD4+0x62>
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {

  osalDbgCheckClassI();

  if (iqIsFullI(iqp)) {
 8003a1c:	6942      	ldr	r2, [r0, #20]
 8003a1e:	2a00      	cmp	r2, #0
 8003a20:	f43f af7c 	beq.w	800391c <VectorD4+0x6c>
 8003a24:	3004      	adds	r0, #4
 8003a26:	2180      	movs	r1, #128	; 0x80
 8003a28:	f001 faf2 	bl	8005010 <chEvtBroadcastFlagsI>
 8003a2c:	e790      	b.n	8003950 <VectorD4+0xa0>
msg_t oqGetI(output_queue_t *oqp) {
  uint8_t b;

  osalDbgCheckClassI();

  if (oqIsEmptyI(oqp)) {
 8003a2e:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8003a30:	2a00      	cmp	r2, #0
 8003a32:	d0c0      	beq.n	80039b6 <VectorD4+0x106>
 8003a34:	3004      	adds	r0, #4
 8003a36:	2108      	movs	r1, #8
 8003a38:	f001 faea 	bl	8005010 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < MSG_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 8003a3c:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 8003a40:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8003a44:	6033      	str	r3, [r6, #0]
 8003a46:	e7d4      	b.n	80039f2 <VectorD4+0x142>
 8003a48:	200012dc 	.word	0x200012dc
 8003a4c:	200012e0 	.word	0x200012e0

08003a50 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
 8003a50:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003a54:	4604      	mov	r4, r0
 8003a56:	b083      	sub	sp, #12
 8003a58:	468a      	mov	sl, r1
 8003a5a:	4615      	mov	r5, r2
 8003a5c:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
 8003a5e:	69c7      	ldr	r7, [r0, #28]
 8003a60:	f04f 0820 	mov.w	r8, #32
 8003a64:	f388 8811 	msr	BASEPRI, r8
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8003a68:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  size_t w = 0;
 8003a6c:	2600      	movs	r6, #0
 8003a6e:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003a70:	444b      	add	r3, r9
 8003a72:	9301      	str	r3, [sp, #4]
    msg_t msg;

    while (oqIsFullI(oqp)) {
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003a74:	f109 3bff 	add.w	fp, r9, #4294967295
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8003a78:	68a3      	ldr	r3, [r4, #8]
 8003a7a:	b1fb      	cbz	r3, 8003abc <oqWriteTimeout+0x6c>
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003a7c:	6962      	ldr	r2, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003a7e:	68a3      	ldr	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003a80:	1c51      	adds	r1, r2, #1
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003a82:	3b01      	subs	r3, #1
    *oqp->q_wrptr++ = *bp++;
 8003a84:	6161      	str	r1, [r4, #20]
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
 8003a86:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8003a88:	f89a 3000 	ldrb.w	r3, [sl]
 8003a8c:	7013      	strb	r3, [r2, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8003a8e:	6923      	ldr	r3, [r4, #16]
 8003a90:	6962      	ldr	r2, [r4, #20]
 8003a92:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8003a94:	bf24      	itt	cs
 8003a96:	68e3      	ldrcs	r3, [r4, #12]
 8003a98:	6163      	strcs	r3, [r4, #20]
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8003a9a:	f10a 0a01 	add.w	sl, sl, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
 8003a9e:	b10f      	cbz	r7, 8003aa4 <oqWriteTimeout+0x54>
      nfy(oqp);
 8003aa0:	4620      	mov	r0, r4
 8003aa2:	47b8      	blx	r7
 8003aa4:	2300      	movs	r3, #0
 8003aa6:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
    if (--n == 0U) {
 8003aaa:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    w++;
 8003aac:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8003ab0:	d016      	beq.n	8003ae0 <oqWriteTimeout+0x90>
 8003ab2:	f388 8811 	msr	BASEPRI, r8
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
 8003ab6:	68a3      	ldr	r3, [r4, #8]
 8003ab8:	2b00      	cmp	r3, #0
 8003aba:	d1df      	bne.n	8003a7c <oqWriteTimeout+0x2c>
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003abc:	f11b 0f03 	cmn.w	fp, #3
 8003ac0:	d812      	bhi.n	8003ae8 <oqWriteTimeout+0x98>
 8003ac2:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003ac6:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003ac8:	9a01      	ldr	r2, [sp, #4]
 8003aca:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003acc:	4589      	cmp	r9, r1
 8003ace:	d305      	bcc.n	8003adc <oqWriteTimeout+0x8c>
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {

  return chThdEnqueueTimeoutS(tqp, time);
 8003ad0:	4620      	mov	r0, r4
 8003ad2:	f001 fed5 	bl	8005880 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003ad6:	2800      	cmp	r0, #0
 8003ad8:	d0ce      	beq.n	8003a78 <oqWriteTimeout+0x28>
 8003ada:	2300      	movs	r3, #0
 8003adc:	f383 8811 	msr	BASEPRI, r3
      return w;
    }

    osalSysLock();
  }
}
 8003ae0:	4630      	mov	r0, r6
 8003ae2:	b003      	add	sp, #12
 8003ae4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003ae8:	4620      	mov	r0, r4
 8003aea:	4649      	mov	r1, r9
 8003aec:	f001 fec8 	bl	8005880 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003af0:	2800      	cmp	r0, #0
 8003af2:	d0c1      	beq.n	8003a78 <oqWriteTimeout+0x28>
 8003af4:	e7f1      	b.n	8003ada <oqWriteTimeout+0x8a>
 8003af6:	bf00      	nop
 8003af8:	f3af 8000 	nop.w
 8003afc:	f3af 8000 	nop.w

08003b00 <writet.lto_priv.90>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8003b00:	3030      	adds	r0, #48	; 0x30
 8003b02:	f7ff bfa5 	b.w	8003a50 <oqWriteTimeout>
 8003b06:	bf00      	nop
 8003b08:	f3af 8000 	nop.w
 8003b0c:	f3af 8000 	nop.w

08003b10 <write.lto_priv.84>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8003b10:	3030      	adds	r0, #48	; 0x30
 8003b12:	f04f 33ff 	mov.w	r3, #4294967295
 8003b16:	f7ff bf9b 	b.w	8003a50 <oqWriteTimeout>
 8003b1a:	bf00      	nop
 8003b1c:	f3af 8000 	nop.w

08003b20 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8003b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003b22:	4604      	mov	r4, r0
 8003b24:	460f      	mov	r7, r1
 8003b26:	4616      	mov	r6, r2
 8003b28:	2320      	movs	r3, #32
 8003b2a:	f383 8811 	msr	BASEPRI, r3
 8003b2e:	e003      	b.n	8003b38 <oqPutTimeout+0x18>
 8003b30:	f001 fea6 	bl	8005880 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8003b34:	2800      	cmp	r0, #0
 8003b36:	db19      	blt.n	8003b6c <oqPutTimeout+0x4c>
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
 8003b38:	68a5      	ldr	r5, [r4, #8]
 8003b3a:	4620      	mov	r0, r4
 8003b3c:	4631      	mov	r1, r6
 8003b3e:	2d00      	cmp	r5, #0
 8003b40:	d0f6      	beq.n	8003b30 <oqPutTimeout+0x10>
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
  *oqp->q_wrptr++ = b;
 8003b42:	6962      	ldr	r2, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003b44:	68a3      	ldr	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003b46:	1c51      	adds	r1, r2, #1
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003b48:	3b01      	subs	r3, #1
  *oqp->q_wrptr++ = b;
 8003b4a:	6161      	str	r1, [r4, #20]
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
 8003b4c:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8003b4e:	7017      	strb	r7, [r2, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8003b50:	6923      	ldr	r3, [r4, #16]
 8003b52:	6962      	ldr	r2, [r4, #20]
 8003b54:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8003b56:	bf24      	itt	cs
 8003b58:	68e3      	ldrcs	r3, [r4, #12]
 8003b5a:	6163      	strcs	r3, [r4, #20]
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
 8003b5c:	69e3      	ldr	r3, [r4, #28]
 8003b5e:	b10b      	cbz	r3, 8003b64 <oqPutTimeout+0x44>
    oqp->q_notify(oqp);
 8003b60:	4620      	mov	r0, r4
 8003b62:	4798      	blx	r3
 8003b64:	2000      	movs	r0, #0
 8003b66:	f380 8811 	msr	BASEPRI, r0
  }

  osalSysUnlock();

  return MSG_OK;
}
 8003b6a:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003b6c:	f385 8811 	msr	BASEPRI, r5
 8003b70:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8003b72:	bf00      	nop
 8003b74:	f3af 8000 	nop.w
 8003b78:	f3af 8000 	nop.w
 8003b7c:	f3af 8000 	nop.w

08003b80 <putt.lto_priv.88>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8003b80:	3030      	adds	r0, #48	; 0x30
 8003b82:	f7ff bfcd 	b.w	8003b20 <oqPutTimeout>
 8003b86:	bf00      	nop
 8003b88:	f3af 8000 	nop.w
 8003b8c:	f3af 8000 	nop.w

08003b90 <put.lto_priv.86>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8003b90:	3030      	adds	r0, #48	; 0x30
 8003b92:	f04f 32ff 	mov.w	r2, #4294967295
 8003b96:	f7ff bfc3 	b.w	8003b20 <oqPutTimeout>
 8003b9a:	bf00      	nop
 8003b9c:	f3af 8000 	nop.w

08003ba0 <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
 8003ba0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ba4:	4604      	mov	r4, r0
 8003ba6:	b083      	sub	sp, #12
 8003ba8:	468a      	mov	sl, r1
 8003baa:	4615      	mov	r5, r2
 8003bac:	4699      	mov	r9, r3
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
 8003bae:	69c7      	ldr	r7, [r0, #28]
 8003bb0:	f04f 0820 	mov.w	r8, #32
 8003bb4:	f388 8811 	msr	BASEPRI, r8
 8003bb8:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
  size_t r = 0;
 8003bbc:	2600      	movs	r6, #0
 8003bbe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
  osalSysLock();

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
 8003bc0:	444b      	add	r3, r9
 8003bc2:	9301      	str	r3, [sp, #4]
    while (iqIsEmptyI(iqp)) {
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003bc4:	f109 3bff 	add.w	fp, r9, #4294967295
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8003bc8:	68a3      	ldr	r3, [r4, #8]
 8003bca:	b1fb      	cbz	r3, 8003c0c <iqReadTimeout+0x6c>
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8003bcc:	69a2      	ldr	r2, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003bce:	68a3      	ldr	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003bd0:	1c51      	adds	r1, r2, #1
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003bd2:	3b01      	subs	r3, #1
    *bp++ = *iqp->q_rdptr++;
 8003bd4:	61a1      	str	r1, [r4, #24]
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
 8003bd6:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8003bd8:	7813      	ldrb	r3, [r2, #0]
 8003bda:	f88a 3000 	strb.w	r3, [sl]
    if (iqp->q_rdptr >= iqp->q_top) {
 8003bde:	6923      	ldr	r3, [r4, #16]
 8003be0:	69a2      	ldr	r2, [r4, #24]
 8003be2:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8003be4:	bf24      	itt	cs
 8003be6:	68e3      	ldrcs	r3, [r4, #12]
 8003be8:	61a3      	strcs	r3, [r4, #24]
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    *bp++ = *iqp->q_rdptr++;
 8003bea:	f10a 0a01 	add.w	sl, sl, #1
    if (iqp->q_rdptr >= iqp->q_top) {
      iqp->q_rdptr = iqp->q_buffer;
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
 8003bee:	b10f      	cbz	r7, 8003bf4 <iqReadTimeout+0x54>
      nfy(iqp);
 8003bf0:	4620      	mov	r0, r4
 8003bf2:	47b8      	blx	r7
 8003bf4:	2300      	movs	r3, #0
 8003bf6:	f383 8811 	msr	BASEPRI, r3

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
    if (--n == 0U) {
 8003bfa:	3d01      	subs	r5, #1
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();

    r++;
 8003bfc:	f106 0601 	add.w	r6, r6, #1
    if (--n == 0U) {
 8003c00:	d016      	beq.n	8003c30 <iqReadTimeout+0x90>
 8003c02:	f388 8811 	msr	BASEPRI, r8
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
 8003c06:	68a3      	ldr	r3, [r4, #8]
 8003c08:	2b00      	cmp	r3, #0
 8003c0a:	d1df      	bne.n	8003bcc <iqReadTimeout+0x2c>
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
 8003c0c:	f11b 0f03 	cmn.w	fp, #3
 8003c10:	d812      	bhi.n	8003c38 <iqReadTimeout+0x98>
 8003c12:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003c16:	6a51      	ldr	r1, [r2, #36]	; 0x24
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
 8003c18:	9a01      	ldr	r2, [sp, #4]
 8003c1a:	1a51      	subs	r1, r2, r1

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
 8003c1c:	4589      	cmp	r9, r1
 8003c1e:	d305      	bcc.n	8003c2c <iqReadTimeout+0x8c>
 8003c20:	4620      	mov	r0, r4
 8003c22:	f001 fe2d 	bl	8005880 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003c26:	2800      	cmp	r0, #0
 8003c28:	d0ce      	beq.n	8003bc8 <iqReadTimeout+0x28>
 8003c2a:	2300      	movs	r3, #0
 8003c2c:	f383 8811 	msr	BASEPRI, r3
      return r;
    }

    osalSysLock();
  }
}
 8003c30:	4630      	mov	r0, r6
 8003c32:	b003      	add	sp, #12
 8003c34:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8003c38:	4620      	mov	r0, r4
 8003c3a:	4649      	mov	r1, r9
 8003c3c:	f001 fe20 	bl	8005880 <chThdEnqueueTimeoutS>

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
 8003c40:	2800      	cmp	r0, #0
 8003c42:	d0c1      	beq.n	8003bc8 <iqReadTimeout+0x28>
 8003c44:	e7f1      	b.n	8003c2a <iqReadTimeout+0x8a>
 8003c46:	bf00      	nop
 8003c48:	f3af 8000 	nop.w
 8003c4c:	f3af 8000 	nop.w

08003c50 <readt.lto_priv.91>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8003c50:	300c      	adds	r0, #12
 8003c52:	f7ff bfa5 	b.w	8003ba0 <iqReadTimeout>
 8003c56:	bf00      	nop
 8003c58:	f3af 8000 	nop.w
 8003c5c:	f3af 8000 	nop.w

08003c60 <read.lto_priv.85>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8003c60:	300c      	adds	r0, #12
 8003c62:	f04f 33ff 	mov.w	r3, #4294967295
 8003c66:	f7ff bf9b 	b.w	8003ba0 <iqReadTimeout>
 8003c6a:	bf00      	nop
 8003c6c:	f3af 8000 	nop.w

08003c70 <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8003c70:	b570      	push	{r4, r5, r6, lr}
 8003c72:	2320      	movs	r3, #32
 8003c74:	4604      	mov	r4, r0
 8003c76:	460e      	mov	r6, r1
 8003c78:	f383 8811 	msr	BASEPRI, r3
 8003c7c:	e003      	b.n	8003c86 <iqGetTimeout+0x16>
 8003c7e:	f001 fdff 	bl	8005880 <chThdEnqueueTimeoutS>
  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    if (msg < MSG_OK) {
 8003c82:	2800      	cmp	r0, #0
 8003c84:	db1a      	blt.n	8003cbc <iqGetTimeout+0x4c>
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
 8003c86:	68a5      	ldr	r5, [r4, #8]
 8003c88:	4620      	mov	r0, r4
 8003c8a:	4631      	mov	r1, r6
 8003c8c:	2d00      	cmp	r5, #0
 8003c8e:	d0f6      	beq.n	8003c7e <iqGetTimeout+0xe>
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003c90:	69a1      	ldr	r1, [r4, #24]
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003c92:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8003c94:	6920      	ldr	r0, [r4, #16]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003c96:	1c4a      	adds	r2, r1, #1
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003c98:	3b01      	subs	r3, #1
  b = *iqp->q_rdptr++;
  if (iqp->q_rdptr >= iqp->q_top) {
 8003c9a:	4282      	cmp	r2, r0
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
 8003c9c:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8003c9e:	61a2      	str	r2, [r4, #24]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003ca0:	bf28      	it	cs
 8003ca2:	68e3      	ldrcs	r3, [r4, #12]
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
  b = *iqp->q_rdptr++;
 8003ca4:	780d      	ldrb	r5, [r1, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
    iqp->q_rdptr = iqp->q_buffer;
 8003ca6:	bf28      	it	cs
 8003ca8:	61a3      	strcs	r3, [r4, #24]
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
 8003caa:	69e3      	ldr	r3, [r4, #28]
 8003cac:	b10b      	cbz	r3, 8003cb2 <iqGetTimeout+0x42>
    iqp->q_notify(iqp);
 8003cae:	4620      	mov	r0, r4
 8003cb0:	4798      	blx	r3
 8003cb2:	2300      	movs	r3, #0
 8003cb4:	f383 8811 	msr	BASEPRI, r3
  }

  osalSysUnlock();

  return (msg_t)b;
 8003cb8:	4628      	mov	r0, r5
}
 8003cba:	bd70      	pop	{r4, r5, r6, pc}
 8003cbc:	f385 8811 	msr	BASEPRI, r5
 8003cc0:	bd70      	pop	{r4, r5, r6, pc}
 8003cc2:	bf00      	nop
 8003cc4:	f3af 8000 	nop.w
 8003cc8:	f3af 8000 	nop.w
 8003ccc:	f3af 8000 	nop.w

08003cd0 <gett.lto_priv.89>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8003cd0:	300c      	adds	r0, #12
 8003cd2:	f7ff bfcd 	b.w	8003c70 <iqGetTimeout>
 8003cd6:	bf00      	nop
 8003cd8:	f3af 8000 	nop.w
 8003cdc:	f3af 8000 	nop.w

08003ce0 <get.lto_priv.87>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8003ce0:	300c      	adds	r0, #12
 8003ce2:	f04f 31ff 	mov.w	r1, #4294967295
 8003ce6:	f7ff bfc3 	b.w	8003c70 <iqGetTimeout>
 8003cea:	bf00      	nop
 8003cec:	f3af 8000 	nop.w

08003cf0 <test_wait_tick>:
}

/*
 * Delays execution until next system time tick.
 */
systime_t test_wait_tick(void) {
 8003cf0:	b508      	push	{r3, lr}

  chThdSleep(1);
 8003cf2:	2001      	movs	r0, #1
 8003cf4:	f001 fddc 	bl	80058b0 <chThdSleep>
 8003cf8:	2320      	movs	r3, #32
 8003cfa:	f383 8811 	msr	BASEPRI, r3
 8003cfe:	f04f 4280 	mov.w	r2, #1073741824	; 0x40000000
 8003d02:	2300      	movs	r3, #0
 8003d04:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8003d06:	f383 8811 	msr	BASEPRI, r3
  return chVTGetSystemTime();
}
 8003d0a:	bd08      	pop	{r3, pc}
 8003d0c:	f3af 8000 	nop.w

08003d10 <test_wait_threads>:
}

/*
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
 8003d10:	b570      	push	{r4, r5, r6, lr}
 8003d12:	4c07      	ldr	r4, [pc, #28]	; (8003d30 <test_wait_threads+0x20>)
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
 8003d14:	2600      	movs	r6, #0
 8003d16:	f104 0514 	add.w	r5, r4, #20
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i] != NULL) {
 8003d1a:	f854 0b04 	ldr.w	r0, [r4], #4
 8003d1e:	b118      	cbz	r0, 8003d28 <test_wait_threads+0x18>
      chThdWait(threads[i]);
 8003d20:	f001 fb7e 	bl	8005420 <chThdWait>
      threads[i] = NULL;
 8003d24:	f844 6c04 	str.w	r6, [r4, #-4]
 * Waits for the completion of all the test-spawned threads.
 */
void test_wait_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8003d28:	42ac      	cmp	r4, r5
 8003d2a:	d1f6      	bne.n	8003d1a <test_wait_threads+0xa>
    if (threads[i] != NULL) {
      chThdWait(threads[i]);
      threads[i] = NULL;
    }
}
 8003d2c:	bd70      	pop	{r4, r5, r6, pc}
 8003d2e:	bf00      	nop
 8003d30:	20001340 	.word	0x20001340
 8003d34:	f3af 8000 	nop.w
 8003d38:	f3af 8000 	nop.w
 8003d3c:	f3af 8000 	nop.w

08003d40 <test_terminate_threads>:
                         test_buffer + (WA_SIZE * 4)};

/*
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
 8003d40:	4b0b      	ldr	r3, [pc, #44]	; (8003d70 <test_terminate_threads+0x30>)
 8003d42:	b430      	push	{r4, r5}
 8003d44:	f103 0014 	add.w	r0, r3, #20
 8003d48:	2520      	movs	r5, #32
 8003d4a:	2400      	movs	r4, #0
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
    if (threads[i])
 8003d4c:	f853 2b04 	ldr.w	r2, [r3], #4
 8003d50:	b14a      	cbz	r2, 8003d66 <test_terminate_threads+0x26>
 8003d52:	f385 8811 	msr	BASEPRI, r5
 * @api
 */
void chThdTerminate(thread_t *tp) {

  chSysLock();
  tp->flags |= CH_FLAG_TERMINATE;
 8003d56:	f892 1021 	ldrb.w	r1, [r2, #33]	; 0x21
 8003d5a:	f041 0104 	orr.w	r1, r1, #4
 8003d5e:	f882 1021 	strb.w	r1, [r2, #33]	; 0x21
 8003d62:	f384 8811 	msr	BASEPRI, r4
 * Sets a termination request in all the test-spawned threads.
 */
void test_terminate_threads(void) {
  unsigned i;

  for (i = 0; i < MAX_THREADS; i++)
 8003d66:	4283      	cmp	r3, r0
 8003d68:	d1f0      	bne.n	8003d4c <test_terminate_threads+0xc>
    if (threads[i])
      chThdTerminate(threads[i]);
}
 8003d6a:	bc30      	pop	{r4, r5}
 8003d6c:	4770      	bx	lr
 8003d6e:	bf00      	nop
 8003d70:	20001340 	.word	0x20001340
 8003d74:	f3af 8000 	nop.w
 8003d78:	f3af 8000 	nop.w
 8003d7c:	f3af 8000 	nop.w

08003d80 <test_emit_token>:
 8003d80:	2320      	movs	r3, #32
 8003d82:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void test_emit_token(char token) {

  osalSysLock();
  if (test_tokp < &test_tokens_buffer[TEST_MAX_TOKENS])
 8003d86:	4a06      	ldr	r2, [pc, #24]	; (8003da0 <test_emit_token+0x20>)
 8003d88:	4906      	ldr	r1, [pc, #24]	; (8003da4 <test_emit_token+0x24>)
 8003d8a:	6813      	ldr	r3, [r2, #0]
 8003d8c:	428b      	cmp	r3, r1
 8003d8e:	d202      	bcs.n	8003d96 <test_emit_token+0x16>
    *test_tokp++ = token;
 8003d90:	1c59      	adds	r1, r3, #1
 8003d92:	6011      	str	r1, [r2, #0]
 8003d94:	7018      	strb	r0, [r3, #0]
 8003d96:	2300      	movs	r3, #0
 8003d98:	f383 8811 	msr	BASEPRI, r3
 8003d9c:	4770      	bx	lr
 8003d9e:	bf00      	nop
 8003da0:	20001364 	.word	0x20001364
 8003da4:	200008c0 	.word	0x200008c0
 8003da8:	f3af 8000 	nop.w
 8003dac:	f3af 8000 	nop.w

08003db0 <test_println>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003db0:	b570      	push	{r4, r5, r6, lr}
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003db2:	7801      	ldrb	r1, [r0, #0]
 8003db4:	4d09      	ldr	r5, [pc, #36]	; (8003ddc <test_println+0x2c>)
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_println(const char *msgp) {
 8003db6:	4604      	mov	r4, r0
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003db8:	b139      	cbz	r1, 8003dca <test_println+0x1a>
    streamPut(test_chp, *msgp++);
 8003dba:	6828      	ldr	r0, [r5, #0]
 8003dbc:	6803      	ldr	r3, [r0, #0]
 8003dbe:	689b      	ldr	r3, [r3, #8]
 8003dc0:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003dc2:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8003dc6:	2900      	cmp	r1, #0
 8003dc8:	d1f7      	bne.n	8003dba <test_println+0xa>
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003dca:	6828      	ldr	r0, [r5, #0]
 8003dcc:	4904      	ldr	r1, [pc, #16]	; (8003de0 <test_println+0x30>)
 8003dce:	6803      	ldr	r3, [r0, #0]
 8003dd0:	2202      	movs	r2, #2
 8003dd2:	681b      	ldr	r3, [r3, #0]
}
 8003dd4:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 * @api
 */
void test_println(const char *msgp) {

  test_print(msgp);
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8003dd8:	4718      	bx	r3
 8003dda:	bf00      	nop
 8003ddc:	20000c4c 	.word	0x20000c4c
 8003de0:	080071b4 	.word	0x080071b4
 8003de4:	f3af 8000 	nop.w
 8003de8:	f3af 8000 	nop.w
 8003dec:	f3af 8000 	nop.w

08003df0 <test_print>:
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8003df0:	b538      	push	{r3, r4, r5, lr}

  while (*msgp)
 8003df2:	7801      	ldrb	r1, [r0, #0]
 *
 * @param[in] msgp      the message
 *
 * @api
 */
void test_print(const char *msgp) {
 8003df4:	4604      	mov	r4, r0

  while (*msgp)
 8003df6:	b141      	cbz	r1, 8003e0a <test_print+0x1a>
 8003df8:	4d04      	ldr	r5, [pc, #16]	; (8003e0c <test_print+0x1c>)
    streamPut(test_chp, *msgp++);
 8003dfa:	6828      	ldr	r0, [r5, #0]
 8003dfc:	6803      	ldr	r3, [r0, #0]
 8003dfe:	689b      	ldr	r3, [r3, #8]
 8003e00:	4798      	blx	r3
 *
 * @api
 */
void test_print(const char *msgp) {

  while (*msgp)
 8003e02:	f814 1f01 	ldrb.w	r1, [r4, #1]!
 8003e06:	2900      	cmp	r1, #0
 8003e08:	d1f7      	bne.n	8003dfa <test_print+0xa>
 8003e0a:	bd38      	pop	{r3, r4, r5, pc}
 8003e0c:	20000c4c 	.word	0x20000c4c

08003e10 <test_printn>:
 * @api
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
 8003e10:	b310      	cbz	r0, 8003e58 <test_printn+0x48>
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8003e12:	b570      	push	{r4, r5, r6, lr}
  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8003e14:	4a13      	ldr	r2, [pc, #76]	; (8003e64 <test_printn+0x54>)
 *
 * @param[in] n         the number to be printed
 *
 * @api
 */
void test_printn(uint32_t n) {
 8003e16:	b084      	sub	sp, #16
  char buf[16], *p;

  if (!n)
 8003e18:	466d      	mov	r5, sp
 8003e1a:	466c      	mov	r4, sp
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
 8003e1c:	fba2 1300 	umull	r1, r3, r2, r0
 8003e20:	08db      	lsrs	r3, r3, #3
 8003e22:	eb03 0183 	add.w	r1, r3, r3, lsl #2
 8003e26:	eba0 0041 	sub.w	r0, r0, r1, lsl #1
 8003e2a:	f100 0130 	add.w	r1, r0, #48	; 0x30
 8003e2e:	b2c9      	uxtb	r1, r1
 8003e30:	f804 1b01 	strb.w	r1, [r4], #1

  if (!n)
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
 8003e34:	4618      	mov	r0, r3
 8003e36:	2b00      	cmp	r3, #0
 8003e38:	d1f0      	bne.n	8003e1c <test_printn+0xc>
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8003e3a:	42ac      	cmp	r4, r5
 8003e3c:	d90a      	bls.n	8003e54 <test_printn+0x44>
 8003e3e:	4e0a      	ldr	r6, [pc, #40]	; (8003e68 <test_printn+0x58>)
 8003e40:	3c01      	subs	r4, #1
 8003e42:	e001      	b.n	8003e48 <test_printn+0x38>
 8003e44:	f814 1d01 	ldrb.w	r1, [r4, #-1]!
      streamPut(test_chp, *--p);
 8003e48:	6830      	ldr	r0, [r6, #0]
 8003e4a:	6803      	ldr	r3, [r0, #0]
 8003e4c:	689b      	ldr	r3, [r3, #8]
 8003e4e:	4798      	blx	r3
    streamPut(test_chp, '0');
  else {
    p = buf;
    while (n)
      *p++ = (n % 10) + '0', n /= 10;
    while (p > buf)
 8003e50:	42ac      	cmp	r4, r5
 8003e52:	d1f7      	bne.n	8003e44 <test_printn+0x34>
      streamPut(test_chp, *--p);
  }
}
 8003e54:	b004      	add	sp, #16
 8003e56:	bd70      	pop	{r4, r5, r6, pc}
 */
void test_printn(uint32_t n) {
  char buf[16], *p;

  if (!n)
    streamPut(test_chp, '0');
 8003e58:	4b03      	ldr	r3, [pc, #12]	; (8003e68 <test_printn+0x58>)
 8003e5a:	6818      	ldr	r0, [r3, #0]
 8003e5c:	6803      	ldr	r3, [r0, #0]
 8003e5e:	2130      	movs	r1, #48	; 0x30
 8003e60:	689b      	ldr	r3, [r3, #8]
 8003e62:	4718      	bx	r3
 8003e64:	cccccccd 	.word	0xcccccccd
 8003e68:	20000c4c 	.word	0x20000c4c
 8003e6c:	f3af 8000 	nop.w

08003e70 <_test_assert_sequence>:
  if (!condition)
    return _test_fail(msg);
  return false;
}

bool _test_assert_sequence(char *expected, const char *msg) {
 8003e70:	b4f0      	push	{r4, r5, r6, r7}
 8003e72:	4e0d      	ldr	r6, [pc, #52]	; (8003ea8 <_test_assert_sequence+0x38>)
  char *cp = test_tokens_buffer;
 8003e74:	4f0d      	ldr	r7, [pc, #52]	; (8003eac <_test_assert_sequence+0x3c>)
 8003e76:	6835      	ldr	r5, [r6, #0]
 8003e78:	463b      	mov	r3, r7
 8003e7a:	e005      	b.n	8003e88 <_test_assert_sequence+0x18>

  while (cp < test_tokp) {
    if (*cp++ != *expected++)
 8003e7c:	f813 4b01 	ldrb.w	r4, [r3], #1
 8003e80:	f810 2b01 	ldrb.w	r2, [r0], #1
 8003e84:	4294      	cmp	r4, r2
 8003e86:	d106      	bne.n	8003e96 <_test_assert_sequence+0x26>
}

bool _test_assert_sequence(char *expected, const char *msg) {
  char *cp = test_tokens_buffer;

  while (cp < test_tokp) {
 8003e88:	42ab      	cmp	r3, r5
 8003e8a:	d3f7      	bcc.n	8003e7c <_test_assert_sequence+0xc>
    if (*cp++ != *expected++)
     return _test_fail(msg);
  }

  if (*expected)
 8003e8c:	7800      	ldrb	r0, [r0, #0]
 8003e8e:	b910      	cbnz	r0, 8003e96 <_test_assert_sequence+0x26>
/* Module local functions.                                                   */
/*===========================================================================*/

static void clear_tokens(void) {

  test_tokp = test_tokens_buffer;
 8003e90:	6037      	str	r7, [r6, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 8003e92:	bcf0      	pop	{r4, r5, r6, r7}
 8003e94:	4770      	bx	lr
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8003e96:	4c06      	ldr	r4, [pc, #24]	; (8003eb0 <_test_assert_sequence+0x40>)
  test_global_fail     = true;
 8003e98:	4a06      	ldr	r2, [pc, #24]	; (8003eb4 <_test_assert_sequence+0x44>)
  test_failure_message = msg;
 8003e9a:	4b07      	ldr	r3, [pc, #28]	; (8003eb8 <_test_assert_sequence+0x48>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8003e9c:	2001      	movs	r0, #1
 8003e9e:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8003ea0:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8003ea2:	6019      	str	r1, [r3, #0]
    return _test_fail(msg);

  clear_tokens();

  return false;
}
 8003ea4:	bcf0      	pop	{r4, r5, r6, r7}
 8003ea6:	4770      	bx	lr
 8003ea8:	20001364 	.word	0x20001364
 8003eac:	200008b0 	.word	0x200008b0
 8003eb0:	2000146d 	.word	0x2000146d
 8003eb4:	2000146c 	.word	0x2000146c
 8003eb8:	20001428 	.word	0x20001428
 8003ebc:	f3af 8000 	nop.w

08003ec0 <_test_assert>:
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 8003ec0:	b950      	cbnz	r0, 8003ed8 <_test_assert+0x18>
  test_global_fail     = true;
  test_failure_message = msg;
  return true;
}

bool _test_assert(bool condition, const char *msg) {
 8003ec2:	b410      	push	{r4}
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
 8003ec4:	4a05      	ldr	r2, [pc, #20]	; (8003edc <_test_assert+0x1c>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8003ec6:	4c06      	ldr	r4, [pc, #24]	; (8003ee0 <_test_assert+0x20>)
  test_global_fail     = true;
  test_failure_message = msg;
 8003ec8:	4b06      	ldr	r3, [pc, #24]	; (8003ee4 <_test_assert+0x24>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8003eca:	2001      	movs	r0, #1
 8003ecc:	7020      	strb	r0, [r4, #0]
  test_global_fail     = true;
 8003ece:	7010      	strb	r0, [r2, #0]
  test_failure_message = msg;
 8003ed0:	6019      	str	r1, [r3, #0]
bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
}
 8003ed2:	f85d 4b04 	ldr.w	r4, [sp], #4
 8003ed6:	4770      	bx	lr

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 8003ed8:	2000      	movs	r0, #0
 8003eda:	4770      	bx	lr
 8003edc:	2000146c 	.word	0x2000146c
 8003ee0:	2000146d 	.word	0x2000146d
 8003ee4:	20001428 	.word	0x20001428
 8003ee8:	f3af 8000 	nop.w
 8003eec:	f3af 8000 	nop.w

08003ef0 <test_001_002_execute.lto_priv.93>:
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 8003ef0:	b510      	push	{r4, lr}
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8003ef2:	4c31      	ldr	r4, [pc, #196]	; (8003fb8 <test_001_002_execute.lto_priv.93+0xc8>)
 8003ef4:	2301      	movs	r3, #1
 * - [1.2.4] Testing chSysUnconditionalUnlock().
 * - [1.2.5] Testing from ISR context using a virtual timer.
 * .
 */

static void test_001_002_execute(void) {
 8003ef6:	b086      	sub	sp, #24
  syssts_t sts;
  virtual_timer_t vt;

  /* [1.2.1] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), non reentrant case.*/
  test_set_step(1);
 8003ef8:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003efa:	f3ef 8311 	mrs	r3, BASEPRI
 8003efe:	b91b      	cbnz	r3, 8003f08 <test_001_002_execute.lto_priv.93+0x18>
 8003f00:	f001 fcf6 	bl	80058f0 <chSysGetStatusAndLockX.part.1.lto_priv.193>
 8003f04:	f001 fce4 	bl	80058d0 <chSysRestoreStatusX.part.2.lto_priv.192>
    chSysRestoreStatusX(sts);
  }

  /* [1.2.2] Testing chSysGetStatusAndLockX() and
     chSysRestoreStatusX(), reentrant case.*/
  test_set_step(2);
 8003f08:	2302      	movs	r3, #2
 8003f0a:	6023      	str	r3, [r4, #0]
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f0c:	2320      	movs	r3, #32
 8003f0e:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003f12:	f3ef 8311 	mrs	r3, BASEPRI
 8003f16:	b91b      	cbnz	r3, 8003f20 <test_001_002_execute.lto_priv.93+0x30>
 8003f18:	f001 fcea 	bl	80058f0 <chSysGetStatusAndLockX.part.1.lto_priv.193>
 8003f1c:	f001 fcd8 	bl	80058d0 <chSysRestoreStatusX.part.2.lto_priv.192>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f20:	2300      	movs	r3, #0
 8003f22:	f383 8811 	msr	BASEPRI, r3
    chSysRestoreStatusX(sts);
    chSysUnlock();
  }

  /* [1.2.3] Testing chSysUnconditionalLock().*/
  test_set_step(3);
 8003f26:	2303      	movs	r3, #3
 8003f28:	6023      	str	r3, [r4, #0]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003f2a:	f3ef 8311 	mrs	r3, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalLock(void) {

  if (port_irq_enabled(port_get_irq_status())) {
 8003f2e:	b913      	cbnz	r3, 8003f36 <test_001_002_execute.lto_priv.93+0x46>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f30:	2320      	movs	r3, #32
 8003f32:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003f36:	f3ef 8311 	mrs	r3, BASEPRI
 8003f3a:	b913      	cbnz	r3, 8003f42 <test_001_002_execute.lto_priv.93+0x52>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f3c:	2320      	movs	r3, #32
 8003f3e:	f383 8811 	msr	BASEPRI, r3
 8003f42:	2300      	movs	r3, #0
 8003f44:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalLock();
    chSysUnlock();
  }

  /* [1.2.4] Testing chSysUnconditionalUnlock().*/
  test_set_step(4);
 8003f48:	2204      	movs	r2, #4
 8003f4a:	6022      	str	r2, [r4, #0]
 8003f4c:	2220      	movs	r2, #32
 8003f4e:	f382 8811 	msr	BASEPRI, r2
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003f52:	f3ef 8211 	mrs	r2, BASEPRI
 *
 * @special
 */
static inline void chSysUnconditionalUnlock(void) {

  if (!port_irq_enabled(port_get_irq_status())) {
 8003f56:	b10a      	cbz	r2, 8003f5c <test_001_002_execute.lto_priv.93+0x6c>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f58:	f383 8811 	msr	BASEPRI, r3
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_BASEPRI(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, basepri" : "=r" (result) );
 8003f5c:	f3ef 8311 	mrs	r3, BASEPRI
 8003f60:	b113      	cbz	r3, 8003f68 <test_001_002_execute.lto_priv.93+0x78>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8003f62:	2300      	movs	r3, #0
 8003f64:	f383 8811 	msr	BASEPRI, r3
    chSysUnconditionalUnlock();
    chSysUnconditionalUnlock();
  }

  /* [1.2.5] Testing from ISR context using a virtual timer.*/
  test_set_step(5);
 8003f68:	2205      	movs	r2, #5
 *
 * @init
 */
static inline void chVTObjectInit(virtual_timer_t *vtp) {

  vtp->func = NULL;
 8003f6a:	2300      	movs	r3, #0
 8003f6c:	9304      	str	r3, [sp, #16]
 8003f6e:	6022      	str	r2, [r4, #0]
 8003f70:	2320      	movs	r3, #32
 8003f72:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003f76:	9b04      	ldr	r3, [sp, #16]
    chVTDoResetI(vtp);
 8003f78:	ac01      	add	r4, sp, #4
 *
 * @iclass
 */
static inline void chVTResetI(virtual_timer_t *vtp) {

  if (chVTIsArmedI(vtp)) {
 8003f7a:	b113      	cbz	r3, 8003f82 <test_001_002_execute.lto_priv.93+0x92>
    chVTDoResetI(vtp);
 8003f7c:	4620      	mov	r0, r4
 8003f7e:	f001 fbbf 	bl	8005700 <chVTDoResetI>
 */
static inline void chVTSetI(virtual_timer_t *vtp, systime_t delay,
                            vtfunc_t vtfunc, void *par) {

  chVTResetI(vtp);
  chVTDoSetI(vtp, delay, vtfunc, par);
 8003f82:	4620      	mov	r0, r4
 8003f84:	2101      	movs	r1, #1
 8003f86:	4a0d      	ldr	r2, [pc, #52]	; (8003fbc <test_001_002_execute.lto_priv.93+0xcc>)
 8003f88:	2300      	movs	r3, #0
 8003f8a:	f001 fbf1 	bl	8005770 <chVTDoSetI>
 8003f8e:	2400      	movs	r4, #0
 8003f90:	f384 8811 	msr	BASEPRI, r4
  {
    chVTObjectInit(&vt);
    chVTSet(&vt, 1, vtcb, NULL);
    chThdSleep(10);
 8003f94:	200a      	movs	r0, #10
 8003f96:	f001 fc8b 	bl	80058b0 <chThdSleep>
 8003f9a:	2320      	movs	r3, #32
 8003f9c:	f383 8811 	msr	BASEPRI, r3
 8003fa0:	9804      	ldr	r0, [sp, #16]
 8003fa2:	f384 8811 	msr	BASEPRI, r4

    test_assert(chVTIsArmed(&vt) == false, "timer still armed");
 8003fa6:	4906      	ldr	r1, [pc, #24]	; (8003fc0 <test_001_002_execute.lto_priv.93+0xd0>)
 8003fa8:	fab0 f080 	clz	r0, r0
 8003fac:	0940      	lsrs	r0, r0, #5
 8003fae:	f7ff ff87 	bl	8003ec0 <_test_assert>
  }
}
 8003fb2:	b006      	add	sp, #24
 8003fb4:	bd10      	pop	{r4, pc}
 8003fb6:	bf00      	nop
 8003fb8:	2000133c 	.word	0x2000133c
 8003fbc:	08003881 	.word	0x08003881
 8003fc0:	080071b8 	.word	0x080071b8
 8003fc4:	f3af 8000 	nop.w
 8003fc8:	f3af 8000 	nop.w
 8003fcc:	f3af 8000 	nop.w

08003fd0 <test_001_001_execute.lto_priv.92>:
 * - [1.1.3] Testing Registry List integrity.
 * - [1.1.4] Testing Port-defined integrity.
 * .
 */

static void test_001_001_execute(void) {
 8003fd0:	b570      	push	{r4, r5, r6, lr}
  bool result;

  /* [1.1.1] Testing Ready List integrity.*/
  test_set_step(1);
 8003fd2:	4d24      	ldr	r5, [pc, #144]	; (8004064 <test_001_001_execute.lto_priv.92+0x94>)
 8003fd4:	2001      	movs	r0, #1
 8003fd6:	6028      	str	r0, [r5, #0]
 8003fd8:	2420      	movs	r4, #32
 8003fda:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_RLIST);
 8003fde:	f001 fc97 	bl	8005910 <chSysIntegrityCheckI>
 8003fe2:	2300      	movs	r3, #0
 8003fe4:	f383 8811 	msr	BASEPRI, r3
    chSysUnlock();
    test_assert(result == false, "ready list check failed");
 8003fe8:	f080 0001 	eor.w	r0, r0, #1
 8003fec:	b2c0      	uxtb	r0, r0
 8003fee:	491e      	ldr	r1, [pc, #120]	; (8004068 <test_001_001_execute.lto_priv.92+0x98>)
 8003ff0:	f7ff ff66 	bl	8003ec0 <_test_assert>
 8003ff4:	4606      	mov	r6, r0
 8003ff6:	b100      	cbz	r0, 8003ffa <test_001_001_execute.lto_priv.92+0x2a>
 8003ff8:	bd70      	pop	{r4, r5, r6, pc}
  }

  /* [1.1.2] Testing Virtual Timers List integrity.*/
  test_set_step(2);
 8003ffa:	2002      	movs	r0, #2
 8003ffc:	6028      	str	r0, [r5, #0]
 8003ffe:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_VTLIST);
 8004002:	f001 fc85 	bl	8005910 <chSysIntegrityCheckI>
 8004006:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "virtual timers list check failed");
 800400a:	f080 0001 	eor.w	r0, r0, #1
 800400e:	b2c0      	uxtb	r0, r0
 8004010:	4916      	ldr	r1, [pc, #88]	; (800406c <test_001_001_execute.lto_priv.92+0x9c>)
 8004012:	f7ff ff55 	bl	8003ec0 <_test_assert>
 8004016:	4606      	mov	r6, r0
 8004018:	2800      	cmp	r0, #0
 800401a:	d1ed      	bne.n	8003ff8 <test_001_001_execute.lto_priv.92+0x28>
  }

  /* [1.1.3] Testing Registry List integrity.*/
  test_set_step(3);
 800401c:	2303      	movs	r3, #3
 800401e:	602b      	str	r3, [r5, #0]
 8004020:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_REGISTRY);
 8004024:	2004      	movs	r0, #4
 8004026:	f001 fc73 	bl	8005910 <chSysIntegrityCheckI>
 800402a:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "registry list check failed");
 800402e:	f080 0001 	eor.w	r0, r0, #1
 8004032:	b2c0      	uxtb	r0, r0
 8004034:	490e      	ldr	r1, [pc, #56]	; (8004070 <test_001_001_execute.lto_priv.92+0xa0>)
 8004036:	f7ff ff43 	bl	8003ec0 <_test_assert>
 800403a:	4606      	mov	r6, r0
 800403c:	2800      	cmp	r0, #0
 800403e:	d1db      	bne.n	8003ff8 <test_001_001_execute.lto_priv.92+0x28>
  }

  /* [1.1.4] Testing Port-defined integrity.*/
  test_set_step(4);
 8004040:	2304      	movs	r3, #4
 8004042:	602b      	str	r3, [r5, #0]
 8004044:	f384 8811 	msr	BASEPRI, r4
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
 8004048:	2008      	movs	r0, #8
 800404a:	f001 fc61 	bl	8005910 <chSysIntegrityCheckI>
 800404e:	f386 8811 	msr	BASEPRI, r6
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 8004052:	f080 0001 	eor.w	r0, r0, #1
 8004056:	b2c0      	uxtb	r0, r0
 8004058:	4906      	ldr	r1, [pc, #24]	; (8004074 <test_001_001_execute.lto_priv.92+0xa4>)
  }
}
 800405a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
  test_set_step(4);
  {
    chSysLock();
    result = chSysIntegrityCheckI(CH_INTEGRITY_PORT);
    chSysUnlock();
    test_assert(result == false, "port layer check failed");
 800405e:	f7ff bf2f 	b.w	8003ec0 <_test_assert>
 8004062:	bf00      	nop
 8004064:	2000133c 	.word	0x2000133c
 8004068:	080071cc 	.word	0x080071cc
 800406c:	080071e4 	.word	0x080071e4
 8004070:	08007208 	.word	0x08007208
 8004074:	08007224 	.word	0x08007224
 8004078:	f3af 8000 	nop.w
 800407c:	f3af 8000 	nop.w

08004080 <print_line.lto_priv.168>:
  tcp->execute();
  if (tcp->teardown != NULL)
    tcp->teardown();
}

static void print_line(void) {
 8004080:	b570      	push	{r4, r5, r6, lr}
 8004082:	4e09      	ldr	r6, [pc, #36]	; (80040a8 <print_line.lto_priv.168+0x28>)
 8004084:	244c      	movs	r4, #76	; 0x4c
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
 8004086:	6830      	ldr	r0, [r6, #0]
 8004088:	4d07      	ldr	r5, [pc, #28]	; (80040a8 <print_line.lto_priv.168+0x28>)
 800408a:	6803      	ldr	r3, [r0, #0]
 800408c:	212d      	movs	r1, #45	; 0x2d
 800408e:	689b      	ldr	r3, [r3, #8]
 8004090:	4798      	blx	r3
}

static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
 8004092:	3c01      	subs	r4, #1
 8004094:	d1f7      	bne.n	8004086 <print_line.lto_priv.168+0x6>
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 8004096:	6828      	ldr	r0, [r5, #0]
 8004098:	4904      	ldr	r1, [pc, #16]	; (80040ac <print_line.lto_priv.168+0x2c>)
 800409a:	6803      	ldr	r3, [r0, #0]
 800409c:	2202      	movs	r2, #2
 800409e:	681b      	ldr	r3, [r3, #0]
}
 80040a0:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void print_line(void) {
  unsigned i;

  for (i = 0; i < 76; i++)
    streamPut(test_chp, '-');
  streamWrite(test_chp, (const uint8_t *)"\r\n", 2);
 80040a4:	4718      	bx	r3
 80040a6:	bf00      	nop
 80040a8:	20000c4c 	.word	0x20000c4c
 80040ac:	080071b4 	.word	0x080071b4

080040b0 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 80040b0:	4924      	ldr	r1, [pc, #144]	; (8004144 <__early_init+0x94>)
 80040b2:	680b      	ldr	r3, [r1, #0]
 80040b4:	f043 0301 	orr.w	r3, r3, #1
 80040b8:	600b      	str	r3, [r1, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 80040ba:	680a      	ldr	r2, [r1, #0]
 80040bc:	4b21      	ldr	r3, [pc, #132]	; (8004144 <__early_init+0x94>)
 80040be:	0790      	lsls	r0, r2, #30
 80040c0:	d5fb      	bpl.n	80040ba <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 80040c2:	685a      	ldr	r2, [r3, #4]
 80040c4:	f022 0203 	bic.w	r2, r2, #3
 80040c8:	605a      	str	r2, [r3, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 80040ca:	685a      	ldr	r2, [r3, #4]
 80040cc:	605a      	str	r2, [r3, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 80040ce:	4619      	mov	r1, r3
 80040d0:	684b      	ldr	r3, [r1, #4]
 80040d2:	4a1c      	ldr	r2, [pc, #112]	; (8004144 <__early_init+0x94>)
 80040d4:	f013 030c 	ands.w	r3, r3, #12
 80040d8:	d1fa      	bne.n	80040d0 <__early_init+0x20>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 80040da:	6811      	ldr	r1, [r2, #0]
 80040dc:	f001 01f9 	and.w	r1, r1, #249	; 0xf9
 80040e0:	6011      	str	r1, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 80040e2:	6053      	str	r3, [r2, #4]

#if STM32_HSE_ENABLED
  /* HSE activation.*/
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
 80040e4:	6813      	ldr	r3, [r2, #0]
 80040e6:	f443 23a0 	orr.w	r3, r3, #327680	; 0x50000
 80040ea:	6013      	str	r3, [r2, #0]
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 80040ec:	6811      	ldr	r1, [r2, #0]
 80040ee:	4b15      	ldr	r3, [pc, #84]	; (8004144 <__early_init+0x94>)
 80040f0:	0389      	lsls	r1, r1, #14
 80040f2:	d5fb      	bpl.n	80040ec <__early_init+0x3c>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 80040f4:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 80040f6:	f042 0201 	orr.w	r2, r2, #1
 80040fa:	625a      	str	r2, [r3, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 80040fc:	461a      	mov	r2, r3
 80040fe:	6a51      	ldr	r1, [r2, #36]	; 0x24
 8004100:	4b10      	ldr	r3, [pc, #64]	; (8004144 <__early_init+0x94>)
 8004102:	0788      	lsls	r0, r1, #30
 8004104:	d5fb      	bpl.n	80040fe <__early_init+0x4e>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8004106:	4a10      	ldr	r2, [pc, #64]	; (8004148 <__early_init+0x98>)
 8004108:	605a      	str	r2, [r3, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 800410a:	f44f 5104 	mov.w	r1, #8448	; 0x2100
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 800410e:	2230      	movs	r2, #48	; 0x30

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8004110:	62d9      	str	r1, [r3, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8004112:	631a      	str	r2, [r3, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8004114:	681a      	ldr	r2, [r3, #0]
 8004116:	f042 7280 	orr.w	r2, r2, #16777216	; 0x1000000
 800411a:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 800411c:	6819      	ldr	r1, [r3, #0]
 800411e:	4a09      	ldr	r2, [pc, #36]	; (8004144 <__early_init+0x94>)
 8004120:	0189      	lsls	r1, r1, #6
 8004122:	d5fb      	bpl.n	800411c <__early_init+0x6c>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8004124:	4b09      	ldr	r3, [pc, #36]	; (800414c <__early_init+0x9c>)
 8004126:	2112      	movs	r1, #18
 8004128:	6019      	str	r1, [r3, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 800412a:	6853      	ldr	r3, [r2, #4]
 800412c:	f043 0302 	orr.w	r3, r3, #2
 8004130:	6053      	str	r3, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8004132:	6853      	ldr	r3, [r2, #4]
 8004134:	4903      	ldr	r1, [pc, #12]	; (8004144 <__early_init+0x94>)
 8004136:	f003 030c 	and.w	r3, r3, #12
 800413a:	2b08      	cmp	r3, #8
 800413c:	d1f9      	bne.n	8004132 <__early_init+0x82>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 800413e:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8004140:	630b      	str	r3, [r1, #48]	; 0x30
 8004142:	4770      	bx	lr
 8004144:	40021000 	.word	0x40021000
 8004148:	001d2400 	.word	0x001d2400
 800414c:	40022000 	.word	0x40022000

08004150 <chPoolAlloc>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if pool is empty.
 *
 * @api
 */
void *chPoolAlloc(memory_pool_t *mp) {
 8004150:	b508      	push	{r3, lr}
 8004152:	2220      	movs	r2, #32
 8004154:	4603      	mov	r3, r0
 8004156:	f382 8811 	msr	BASEPRI, r2
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 800415a:	6800      	ldr	r0, [r0, #0]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 800415c:	b128      	cbz	r0, 800416a <chPoolAlloc+0x1a>
    mp->next = mp->next->next;
 800415e:	6802      	ldr	r2, [r0, #0]
 8004160:	601a      	str	r2, [r3, #0]
 8004162:	2300      	movs	r3, #0
 8004164:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 8004168:	bd08      	pop	{r3, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 800416a:	689a      	ldr	r2, [r3, #8]
 800416c:	2a00      	cmp	r2, #0
 800416e:	d0f8      	beq.n	8004162 <chPoolAlloc+0x12>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8004170:	6858      	ldr	r0, [r3, #4]
 8004172:	2104      	movs	r1, #4
 8004174:	4790      	blx	r2
 8004176:	2300      	movs	r3, #0
 8004178:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  objp = chPoolAllocI(mp);
  chSysUnlock();

  return objp;
}
 800417c:	bd08      	pop	{r3, pc}
 800417e:	bf00      	nop

08004180 <chHeapStatus>:
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8004180:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  heap_header_t *qp;
  size_t n, tpages, lpages;

  if (heapp == NULL) {
    heapp = &default_heap;
 8004184:	4b16      	ldr	r3, [pc, #88]	; (80041e0 <chHeapStatus+0x60>)
 8004186:	2800      	cmp	r0, #0
 8004188:	bf14      	ite	ne
 800418a:	4604      	movne	r4, r0
 800418c:	461c      	moveq	r4, r3
  }

  H_LOCK(heapp);
 800418e:	f104 0710 	add.w	r7, r4, #16
  tpages = 0U;
  lpages = 0U;
 8004192:	2500      	movs	r5, #0

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 8004194:	4638      	mov	r0, r7
 *                      free free block found space or @ NULL
 * @return              The number of fragments in the heap.
 *
 * @api
 */
size_t chHeapStatus(memory_heap_t *heapp, size_t *totalp, size_t *largestp) {
 8004196:	4689      	mov	r9, r1
 8004198:	4690      	mov	r8, r2
  }

  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
 800419a:	462e      	mov	r6, r5

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 800419c:	f001 fa40 	bl	8005620 <chMtxLock>
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
 80041a0:	f104 0308 	add.w	r3, r4, #8
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  tpages = 0U;
 80041a4:	462c      	mov	r4, r5
 80041a6:	e006      	b.n	80041b6 <chHeapStatus+0x36>
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
    size_t pages = H_PAGES(H_NEXT(qp));
 80041a8:	6858      	ldr	r0, [r3, #4]
 80041aa:	4285      	cmp	r5, r0

    /* Updating counters.*/
    n++;
 80041ac:	f106 0601 	add.w	r6, r6, #1
    tpages += pages;
 80041b0:	4404      	add	r4, r0
 80041b2:	bf38      	it	cc
 80041b4:	4605      	movcc	r5, r0
  H_LOCK(heapp);
  tpages = 0U;
  lpages = 0U;
  n = 0U;
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 80041b6:	681b      	ldr	r3, [r3, #0]
 80041b8:	2b00      	cmp	r3, #0
 80041ba:	d1f5      	bne.n	80041a8 <chHeapStatus+0x28>

    qp = H_NEXT(qp);
  }

  /* Writing out fragmented free memory.*/
  if (totalp != NULL) {
 80041bc:	f1b9 0f00 	cmp.w	r9, #0
 80041c0:	d002      	beq.n	80041c8 <chHeapStatus+0x48>
    *totalp = tpages * CH_HEAP_ALIGNMENT;
 80041c2:	00e4      	lsls	r4, r4, #3
 80041c4:	f8c9 4000 	str.w	r4, [r9]
  }

  /* Writing out unfragmented free memory.*/
  if (largestp != NULL) {
 80041c8:	f1b8 0f00 	cmp.w	r8, #0
 80041cc:	d002      	beq.n	80041d4 <chHeapStatus+0x54>
    *largestp = lpages * CH_HEAP_ALIGNMENT;
 80041ce:	00ed      	lsls	r5, r5, #3
 80041d0:	f8c8 5000 	str.w	r5, [r8]
  }
  H_UNLOCK(heapp);
 80041d4:	4638      	mov	r0, r7
 80041d6:	f001 f983 	bl	80054e0 <chMtxUnlock>

  return n;
}
 80041da:	4630      	mov	r0, r6
 80041dc:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80041e0:	20001480 	.word	0x20001480
 80041e4:	f3af 8000 	nop.w
 80041e8:	f3af 8000 	nop.w
 80041ec:	f3af 8000 	nop.w

080041f0 <chHeapFree>:
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 80041f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80041f2:	f850 3c04 	ldr.w	r3, [r0, #-4]
  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
 80041f6:	f850 5c08 	ldr.w	r5, [r0, #-8]
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 80041fa:	3307      	adds	r3, #7
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 80041fc:	08db      	lsrs	r3, r3, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 80041fe:	f105 0710 	add.w	r7, r5, #16
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;

  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
 8004202:	f840 3c04 	str.w	r3, [r0, #-4]
 *
 * @param[in] p         pointer to the memory block to be freed
 *
 * @api
 */
void chHeapFree(void *p) {
 8004206:	4606      	mov	r6, r0
  memory_heap_t *heapp;

  chDbgCheck((p != NULL) && MEM_IS_ALIGNED(p, CH_HEAP_ALIGNMENT));

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
 8004208:	f1a0 0408 	sub.w	r4, r0, #8
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 800420c:	3508      	adds	r5, #8
  /* Size is converted in number of elementary allocation units.*/
  H_PAGES(hp) = MEM_ALIGN_NEXT(H_SIZE(hp),
                               CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 800420e:	4638      	mov	r0, r7
 8004210:	f001 fa06 	bl	8005620 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (heap_header_t *)p - 1U;
  /*lint -restore*/
  heapp = H_HEAP(hp);
  qp = &heapp->header;
 8004214:	462b      	mov	r3, r5
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8004216:	42ab      	cmp	r3, r5
 8004218:	d004      	beq.n	8004224 <chHeapFree+0x34>
 800421a:	42a3      	cmp	r3, r4
 800421c:	d302      	bcc.n	8004224 <chHeapFree+0x34>
 800421e:	681b      	ldr	r3, [r3, #0]
 8004220:	42ab      	cmp	r3, r5
 8004222:	d1fa      	bne.n	800421a <chHeapFree+0x2a>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004224:	681a      	ldr	r2, [r3, #0]
  H_LOCK(heapp);

  while (true) {
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
 8004226:	b11a      	cbz	r2, 8004230 <chHeapFree+0x40>
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
 8004228:	4294      	cmp	r4, r2
 800422a:	d301      	bcc.n	8004230 <chHeapFree+0x40>
 800422c:	4613      	mov	r3, r2
 800422e:	e7f2      	b.n	8004216 <chHeapFree+0x26>
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 8004230:	f856 1c04 	ldr.w	r1, [r6, #-4]
    chDbgAssert((hp < qp) || (hp >= H_LIMIT(qp)), "within free block");

    if (((qp == &heapp->header) || (hp > qp)) &&
        ((H_NEXT(qp) == NULL) || (hp < H_NEXT(qp)))) {
      /* Insertion after qp.*/
      H_NEXT(hp) = H_NEXT(qp);
 8004234:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(qp) = hp;
 8004238:	601c      	str	r4, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
 800423a:	1c4a      	adds	r2, r1, #1
 800423c:	f856 5c08 	ldr.w	r5, [r6, #-8]
 8004240:	eb04 00c2 	add.w	r0, r4, r2, lsl #3
 8004244:	42a8      	cmp	r0, r5
 8004246:	d00a      	beq.n	800425e <chHeapFree+0x6e>
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8004248:	6859      	ldr	r1, [r3, #4]
 800424a:	1c4a      	adds	r2, r1, #1
 800424c:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004250:	4294      	cmp	r4, r2
 8004252:	d013      	beq.n	800427c <chHeapFree+0x8c>
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8004254:	4638      	mov	r0, r7

  return;
}
 8004256:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800425a:	f001 b941 	b.w	80054e0 <chMtxUnlock>
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 800425e:	6840      	ldr	r0, [r0, #4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
 8004260:	f854 2032 	ldr.w	r2, [r4, r2, lsl #3]
 8004264:	f846 2c08 	str.w	r2, [r6, #-8]
      H_NEXT(hp) = H_NEXT(qp);
      H_NEXT(qp) = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (H_LIMIT(hp) == H_NEXT(hp)) {
        /* Merge with the next block.*/
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
 8004268:	180a      	adds	r2, r1, r0
 800426a:	3201      	adds	r2, #1
 800426c:	f846 2c04 	str.w	r2, [r6, #-4]
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
 8004270:	6859      	ldr	r1, [r3, #4]
 8004272:	1c4a      	adds	r2, r1, #1
 8004274:	eb03 02c2 	add.w	r2, r3, r2, lsl #3
 8004278:	4294      	cmp	r4, r2
 800427a:	d1eb      	bne.n	8004254 <chHeapFree+0x64>
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
        H_NEXT(qp) = H_NEXT(hp);
 800427c:	e916 0005 	ldmdb	r6, {r0, r2}
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004280:	440a      	add	r2, r1
 8004282:	3201      	adds	r2, #1
        H_NEXT(qp) = H_NEXT(hp);
 8004284:	6018      	str	r0, [r3, #0]
        H_PAGES(hp) += H_PAGES(H_NEXT(hp)) + 1U;
        H_NEXT(hp) = H_NEXT(H_NEXT(hp));
      }
      if ((H_LIMIT(qp) == hp)) {
        /* Merge with the previous block.*/
        H_PAGES(qp) += H_PAGES(hp) + 1U;
 8004286:	605a      	str	r2, [r3, #4]
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8004288:	4638      	mov	r0, r7

  return;
}
 800428a:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    }
    qp = H_NEXT(qp);
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 800428e:	f001 b927 	b.w	80054e0 <chMtxUnlock>
 8004292:	bf00      	nop
 8004294:	f3af 8000 	nop.w
 8004298:	f3af 8000 	nop.w
 800429c:	f3af 8000 	nop.w

080042a0 <chMsgWait>:
 *
 * @return              A reference to the thread carrying the message.
 *
 * @api
 */
thread_t *chMsgWait(void) {
 80042a0:	b510      	push	{r4, lr}
 80042a2:	2320      	movs	r3, #32
 80042a4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
 80042a8:	4c0c      	ldr	r4, [pc, #48]	; (80042dc <chMsgWait+0x3c>)
 80042aa:	69a2      	ldr	r2, [r4, #24]
 */
static inline bool chMsgIsPendingI(thread_t *tp) {

  chDbgCheckClassI();

  return (bool)(tp->msgqueue.next != (thread_t *)&tp->msgqueue);
 80042ac:	4613      	mov	r3, r2
 80042ae:	f853 0f2c 	ldr.w	r0, [r3, #44]!
 80042b2:	4298      	cmp	r0, r3
 80042b4:	d009      	beq.n	80042ca <chMsgWait+0x2a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80042b6:	6801      	ldr	r1, [r0, #0]
 80042b8:	62d1      	str	r1, [r2, #44]	; 0x2c
    chSchGoSleepS(CH_STATE_WTMSG);
  }
  tp = queue_fifo_remove(&currp->msgqueue);
  tp->state = CH_STATE_SNDMSG;
 80042ba:	220d      	movs	r2, #13
  tqp->next->queue.prev = (thread_t *)tqp;
 80042bc:	604b      	str	r3, [r1, #4]
 80042be:	2300      	movs	r3, #0
 80042c0:	f880 2020 	strb.w	r2, [r0, #32]
 80042c4:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return tp;
}
 80042c8:	bd10      	pop	{r4, pc}
thread_t *chMsgWait(void) {
  thread_t *tp;

  chSysLock();
  if (!chMsgIsPendingI(currp)) {
    chSchGoSleepS(CH_STATE_WTMSG);
 80042ca:	200e      	movs	r0, #14
 80042cc:	f001 f868 	bl	80053a0 <chSchGoSleepS>
 80042d0:	69a2      	ldr	r2, [r4, #24]
 80042d2:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 80042d4:	f102 032c 	add.w	r3, r2, #44	; 0x2c
 80042d8:	e7ed      	b.n	80042b6 <chMsgWait+0x16>
 80042da:	bf00      	nop
 80042dc:	200013b0 	.word	0x200013b0

080042e0 <chMsgSend>:
 * @param[in] msg       the message
 * @return              The answer message from @p chMsgRelease().
 *
 * @api
 */
msg_t chMsgSend(thread_t *tp, msg_t msg) {
 80042e0:	b538      	push	{r3, r4, r5, lr}
  thread_t *ctp = currp;
 80042e2:	4b0e      	ldr	r3, [pc, #56]	; (800431c <chMsgSend+0x3c>)
 80042e4:	2220      	movs	r2, #32
 80042e6:	699c      	ldr	r4, [r3, #24]
 80042e8:	f382 8811 	msr	BASEPRI, r2

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
 80042ec:	6261      	str	r1, [r4, #36]	; 0x24
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
 80042ee:	f890 1020 	ldrb.w	r1, [r0, #32]
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80042f2:	6b02      	ldr	r2, [r0, #48]	; 0x30
 80042f4:	6062      	str	r2, [r4, #4]

  chDbgCheck(tp != NULL);

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
 80042f6:	f100 052c 	add.w	r5, r0, #44	; 0x2c
  if (tp->state == CH_STATE_WTMSG) {
 80042fa:	290e      	cmp	r1, #14
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 80042fc:	6025      	str	r5, [r4, #0]
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 80042fe:	6014      	str	r4, [r2, #0]
  tqp->prev                  = tp;
 8004300:	6304      	str	r4, [r0, #48]	; 0x30
 8004302:	d007      	beq.n	8004314 <chMsgSend+0x34>
    (void) chSchReadyI(tp);
  }
  chSchGoSleepS(CH_STATE_SNDMSGQ);
 8004304:	200c      	movs	r0, #12
 8004306:	f001 f84b 	bl	80053a0 <chSchGoSleepS>
  msg = ctp->u.rdymsg;
 800430a:	6a60      	ldr	r0, [r4, #36]	; 0x24
 800430c:	2300      	movs	r3, #0
 800430e:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return msg;
}
 8004312:	bd38      	pop	{r3, r4, r5, pc}

  chSysLock();
  ctp->u.sentmsg = msg;
  msg_insert(ctp, &tp->msgqueue);
  if (tp->state == CH_STATE_WTMSG) {
    (void) chSchReadyI(tp);
 8004314:	f001 f8a4 	bl	8005460 <chSchReadyI>
 8004318:	e7f4      	b.n	8004304 <chMsgSend+0x24>
 800431a:	bf00      	nop
 800431c:	200013b0 	.word	0x200013b0

08004320 <chEvtSignalI>:
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004320:	6b43      	ldr	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004322:	f890 2020 	ldrb.w	r2, [r0, #32]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 8004326:	4319      	orrs	r1, r3
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004328:	2a0a      	cmp	r2, #10
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
 800432a:	6341      	str	r1, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 800432c:	d00a      	beq.n	8004344 <chEvtSignalI+0x24>
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 800432e:	2a0b      	cmp	r2, #11
 8004330:	d000      	beq.n	8004334 <chEvtSignalI+0x14>
 8004332:	4770      	bx	lr
      ((tp->state == CH_STATE_WTANDEVT) &&
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
 8004334:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004336:	4019      	ands	r1, r3

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
      ((tp->state == CH_STATE_WTANDEVT) &&
 8004338:	428b      	cmp	r3, r1
 800433a:	d1fa      	bne.n	8004332 <chEvtSignalI+0x12>
       ((tp->epending & tp->u.ewmask) == tp->u.ewmask))) {
    tp->u.rdymsg = MSG_OK;
 800433c:	2300      	movs	r3, #0
 800433e:	6243      	str	r3, [r0, #36]	; 0x24
    (void) chSchReadyI(tp);
 8004340:	f001 b88e 	b.w	8005460 <chSchReadyI>
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
       ((tp->epending & tp->u.ewmask) != (eventmask_t)0)) ||
 8004344:	6a43      	ldr	r3, [r0, #36]	; 0x24
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->state == CH_STATE_WTOREVT) &&
 8004346:	4219      	tst	r1, r3
 8004348:	d1f8      	bne.n	800433c <chEvtSignalI+0x1c>
 800434a:	4770      	bx	lr
 800434c:	f3af 8000 	nop.w

08004350 <tmo.lto_priv.78>:
#endif
#if CH_CFG_USE_MUTEXES || defined(__DOXYGEN__)
static mutex_t mtx1;
#endif

static void tmo(void *param) {(void)param;}
 8004350:	4770      	bx	lr
 8004352:	bf00      	nop
 8004354:	f3af 8000 	nop.w
 8004358:	f3af 8000 	nop.w
 800435c:	f3af 8000 	nop.w

08004360 <test_011_002_setup.lto_priv.163>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004360:	4b03      	ldr	r3, [pc, #12]	; (8004370 <test_011_002_setup.lto_priv.163+0x10>)
 8004362:	2200      	movs	r2, #0
  mp->object_size = size;
 8004364:	f44f 71a4 	mov.w	r1, #328	; 0x148
 8004368:	6059      	str	r1, [r3, #4]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 800436a:	601a      	str	r2, [r3, #0]
  mp->object_size = size;
  mp->provider = provider;
 800436c:	609a      	str	r2, [r3, #8]
 800436e:	4770      	bx	lr
 8004370:	20001470 	.word	0x20001470
 8004374:	f3af 8000 	nop.w
 8004378:	f3af 8000 	nop.w
 800437c:	f3af 8000 	nop.w

08004380 <test_011_001_setup.lto_priv.161>:
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8004380:	4908      	ldr	r1, [pc, #32]	; (80043a4 <test_011_001_setup.lto_priv.161+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 8004382:	4b09      	ldr	r3, [pc, #36]	; (80043a8 <test_011_001_setup.lto_priv.161+0x28>)
 *   freeing memory.
 * - [11.1.7] Getting heap info again for verification.
 * .
 */

static void test_011_001_setup(void) {
 8004384:	b410      	push	{r4}
 8004386:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 8004388:	24cc      	movs	r4, #204	; 0xcc
 800438a:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 800438e:	f103 0010 	add.w	r0, r3, #16
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 8004392:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 8004394:	60da      	str	r2, [r3, #12]
 8004396:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 8004398:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 800439a:	601a      	str	r2, [r3, #0]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->queue);
  mp->owner = NULL;
 800439c:	619a      	str	r2, [r3, #24]
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}
 800439e:	f85d 4b04 	ldr.w	r4, [sp], #4
 80043a2:	4770      	bx	lr
 80043a4:	20000c50 	.word	0x20000c50
 80043a8:	20001430 	.word	0x20001430
 80043ac:	f3af 8000 	nop.w

080043b0 <test_010_001_setup.lto_priv.158>:
  H_NEXT(&heapp->header) = hp;
 80043b0:	4908      	ldr	r1, [pc, #32]	; (80043d4 <test_010_001_setup.lto_priv.158+0x24>)

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80043b2:	4b09      	ldr	r3, [pc, #36]	; (80043d8 <test_010_001_setup.lto_priv.158+0x28>)
 * - [10.1.10] Testing final conditions. The heap geometry must be the
 *   same than the one registered at beginning.
 * .
 */

static void test_010_001_setup(void) {
 80043b4:	b410      	push	{r4}
 80043b6:	2200      	movs	r2, #0
  H_NEXT(&heapp->header) = hp;
  H_PAGES(&heapp->header) = 0;
  H_NEXT(hp) = NULL;
  H_PAGES(hp) = (size - sizeof (heap_header_t)) / CH_HEAP_ALIGNMENT;
 80043b8:	24cc      	movs	r4, #204	; 0xcc
 80043ba:	e881 0014 	stmia.w	r1, {r2, r4}
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80043be:	f103 0010 	add.w	r0, r3, #16
  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
  H_NEXT(&heapp->header) = hp;
 80043c2:	6099      	str	r1, [r3, #8]
  H_PAGES(&heapp->header) = 0;
 80043c4:	60da      	str	r2, [r3, #12]
 80043c6:	6118      	str	r0, [r3, #16]
  tqp->prev = (thread_t *)tqp;
 80043c8:	6158      	str	r0, [r3, #20]

  chDbgCheck((heapp != NULL) && (size > 0U) &&
             MEM_IS_ALIGNED(buf, CH_HEAP_ALIGNMENT) &&
             MEM_IS_ALIGNED(size, CH_HEAP_ALIGNMENT));

  heapp->provider = NULL;
 80043ca:	601a      	str	r2, [r3, #0]
 80043cc:	619a      	str	r2, [r3, #24]
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}
 80043ce:	f85d 4b04 	ldr.w	r4, [sp], #4
 80043d2:	4770      	bx	lr
 80043d4:	20000c50 	.word	0x20000c50
 80043d8:	20001390 	.word	0x20001390
 80043dc:	f3af 8000 	nop.w

080043e0 <test_009_003_setup.lto_priv.156>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80043e0:	4b04      	ldr	r3, [pc, #16]	; (80043f4 <test_009_003_setup.lto_priv.156+0x14>)
 80043e2:	2200      	movs	r2, #0
  mp->object_size = size;
 80043e4:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 80043e6:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 80043e8:	605b      	str	r3, [r3, #4]
 80043ea:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80043ec:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 80043ee:	615a      	str	r2, [r3, #20]
 80043f0:	609a      	str	r2, [r3, #8]
 80043f2:	4770      	bx	lr
 80043f4:	20000888 	.word	0x20000888
 80043f8:	f3af 8000 	nop.w
 80043fc:	f3af 8000 	nop.w

08004400 <test_009_002_setup.lto_priv.154>:
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 8004400:	4b04      	ldr	r3, [pc, #16]	; (8004414 <test_009_002_setup.lto_priv.154+0x14>)
 8004402:	2200      	movs	r2, #0
  mp->object_size = size;
 8004404:	2104      	movs	r1, #4
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8004406:	601b      	str	r3, [r3, #0]
  tqp->prev = (thread_t *)tqp;
 8004408:	605b      	str	r3, [r3, #4]
 800440a:	6119      	str	r1, [r3, #16]
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 800440c:	60da      	str	r2, [r3, #12]
  mp->object_size = size;
  mp->provider = provider;
 800440e:	615a      	str	r2, [r3, #20]
 8004410:	609a      	str	r2, [r3, #8]
 8004412:	4770      	bx	lr
 8004414:	20000888 	.word	0x20000888
 8004418:	f3af 8000 	nop.w
 800441c:	f3af 8000 	nop.w

08004420 <bmk_thread8.lto_priv.79>:
  while (!chThdShouldTerminateX())
    chSemWait(&sem1);
}
#endif

static THD_FUNCTION(bmk_thread8, p) {
 8004420:	b538      	push	{r3, r4, r5, lr}
 8004422:	4d09      	ldr	r5, [pc, #36]	; (8004448 <bmk_thread8.lto_priv.79+0x28>)
 8004424:	4604      	mov	r4, r0

  do {
    chThdYield();
 8004426:	f000 fe5b 	bl	80050e0 <chThdYield>
    chThdYield();
 800442a:	f000 fe59 	bl	80050e0 <chThdYield>
    chThdYield();
 800442e:	f000 fe57 	bl	80050e0 <chThdYield>
    chThdYield();
 8004432:	f000 fe55 	bl	80050e0 <chThdYield>
    (*(uint32_t *)p) += 4;
 8004436:	6823      	ldr	r3, [r4, #0]
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8004438:	69aa      	ldr	r2, [r5, #24]
 800443a:	3304      	adds	r3, #4
 800443c:	6023      	str	r3, [r4, #0]
 800443e:	f892 3021 	ldrb.w	r3, [r2, #33]	; 0x21
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while(!chThdShouldTerminateX());
 8004442:	075b      	lsls	r3, r3, #29
 8004444:	d5ef      	bpl.n	8004426 <bmk_thread8.lto_priv.79+0x6>
}
 8004446:	bd38      	pop	{r3, r4, r5, pc}
 8004448:	200013b0 	.word	0x200013b0
 800444c:	f3af 8000 	nop.w

08004450 <bmk_thread7.lto_priv.80>:
  } while (msg == MSG_OK);
  chSysUnlock();
}

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {
 8004450:	b510      	push	{r4, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004452:	4c07      	ldr	r4, [pc, #28]	; (8004470 <bmk_thread7.lto_priv.80+0x20>)
 *
 * @xclass
 */
static inline bool chThdShouldTerminateX(void) {

  return (bool)((chThdGetSelfX()->flags & CH_FLAG_TERMINATE) != (tmode_t)0);
 8004454:	69a3      	ldr	r3, [r4, #24]
 8004456:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

  (void)p;
  while (!chThdShouldTerminateX())
 800445a:	075a      	lsls	r2, r3, #29
 800445c:	d407      	bmi.n	800446e <bmk_thread7.lto_priv.80+0x1e>
    chSemWait(&sem1);
 800445e:	4805      	ldr	r0, [pc, #20]	; (8004474 <bmk_thread7.lto_priv.80+0x24>)
 8004460:	f000 ffb6 	bl	80053d0 <chSemWait>
 8004464:	69a3      	ldr	r3, [r4, #24]
 8004466:	f893 3021 	ldrb.w	r3, [r3, #33]	; 0x21

#if CH_CFG_USE_SEMAPHORES
static THD_FUNCTION(bmk_thread7, p) {

  (void)p;
  while (!chThdShouldTerminateX())
 800446a:	075b      	lsls	r3, r3, #29
 800446c:	d5f7      	bpl.n	800445e <bmk_thread7.lto_priv.80+0xe>
 800446e:	bd10      	pop	{r4, pc}
 8004470:	200013b0 	.word	0x200013b0
 8004474:	2000099c 	.word	0x2000099c
 8004478:	f3af 8000 	nop.w
 800447c:	f3af 8000 	nop.w

08004480 <bmk_thread4.lto_priv.82>:
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004480:	4a07      	ldr	r2, [pc, #28]	; (80044a0 <bmk_thread4.lto_priv.82+0x20>)
static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
}

static THD_FUNCTION(bmk_thread4, p) {
 8004482:	b510      	push	{r4, lr}
 8004484:	2320      	movs	r3, #32
 8004486:	6994      	ldr	r4, [r2, #24]
 8004488:	f383 8811 	msr	BASEPRI, r3
  thread_t *self = chThdGetSelfX();

  (void)p;
  chSysLock();
  do {
    chSchGoSleepS(CH_STATE_SUSPENDED);
 800448c:	2003      	movs	r0, #3
 800448e:	f000 ff87 	bl	80053a0 <chSchGoSleepS>
    msg = self->u.rdymsg;
  } while (msg == MSG_OK);
 8004492:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8004494:	2b00      	cmp	r3, #0
 8004496:	d0f9      	beq.n	800448c <bmk_thread4.lto_priv.82+0xc>
 8004498:	2300      	movs	r3, #0
 800449a:	f383 8811 	msr	BASEPRI, r3
 800449e:	bd10      	pop	{r4, pc}
 80044a0:	200013b0 	.word	0x200013b0
 80044a4:	f3af 8000 	nop.w
 80044a8:	f3af 8000 	nop.w
 80044ac:	f3af 8000 	nop.w

080044b0 <msg_loop_test>:
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
 80044b0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80044b4:	4605      	mov	r5, r0
  systime_t start, end;

  uint32_t n = 0;
  start = test_wait_tick();
 80044b6:	f7ff fc1b 	bl	8003cf0 <test_wait_tick>
}

NOINLINE static unsigned int msg_loop_test(thread_t *tp) {
  systime_t start, end;

  uint32_t n = 0;
 80044ba:	2400      	movs	r4, #0
  start = test_wait_tick();
 80044bc:	4680      	mov	r8, r0
 80044be:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
    (void)chMsgSend(tp, 1);
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80044c2:	f242 760f 	movw	r6, #9999	; 0x270f

  uint32_t n = 0;
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
 80044c6:	4628      	mov	r0, r5
 80044c8:	2101      	movs	r1, #1
 80044ca:	f7ff ff09 	bl	80042e0 <chMsgSend>
 80044ce:	6a7b      	ldr	r3, [r7, #36]	; 0x24
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 80044d0:	ebc8 0303 	rsb	r3, r8, r3
    n++;
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80044d4:	42b3      	cmp	r3, r6
  uint32_t n = 0;
  start = test_wait_tick();
  end = start + MS2ST(1000);
  do {
    (void)chMsgSend(tp, 1);
    n++;
 80044d6:	f104 0401 	add.w	r4, r4, #1
#if defined(SIMULATOR)
    _sim_check_for_interrupts();
#endif
  } while (chVTIsSystemTimeWithinX(start, end));
 80044da:	d9f4      	bls.n	80044c6 <msg_loop_test+0x16>
  (void)chMsgSend(tp, 0);
 80044dc:	4628      	mov	r0, r5
 80044de:	2100      	movs	r1, #0
 80044e0:	f7ff fefe 	bl	80042e0 <chMsgSend>
  return n;
}
 80044e4:	4620      	mov	r0, r4
 80044e6:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80044ea:	bf00      	nop
 80044ec:	f3af 8000 	nop.w

080044f0 <test_012_003_execute.lto_priv.167>:
 *   second time window.
 * - [12.3.4] Score is printed.
 * .
 */

static void test_012_003_execute(void) {
 80044f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80044f4:	4e2c      	ldr	r6, [pc, #176]	; (80045a8 <test_012_003_execute.lto_priv.167+0xb8>)

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80044f6:	4d2d      	ldr	r5, [pc, #180]	; (80045ac <test_012_003_execute.lto_priv.167+0xbc>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80044f8:	69b3      	ldr	r3, [r6, #24]
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80044fa:	4f2d      	ldr	r7, [pc, #180]	; (80045b0 <test_012_003_execute.lto_priv.167+0xc0>)
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80044fc:	6899      	ldr	r1, [r3, #8]
 80044fe:	4a2d      	ldr	r2, [pc, #180]	; (80045b4 <test_012_003_execute.lto_priv.167+0xc4>)
 8004500:	4c2d      	ldr	r4, [pc, #180]	; (80045b8 <test_012_003_execute.lto_priv.167+0xc8>)

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004502:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 80045c8 <test_012_003_execute.lto_priv.167+0xd8>
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8004506:	f04f 0e01 	mov.w	lr, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 800450a:	3101      	adds	r1, #1
 800450c:	4628      	mov	r0, r5
 800450e:	2300      	movs	r3, #0
static void test_012_003_execute(void) {
  uint32_t n;

  /* [12.3.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 8004510:	f8c7 e000 	str.w	lr, [r7]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 8004514:	f001 faac 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8004518:	69b3      	ldr	r3, [r6, #24]
 800451a:	6020      	str	r0, [r4, #0]

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 800451c:	6899      	ldr	r1, [r3, #8]
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800451e:	f04f 0e02 	mov.w	lr, #2
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004522:	4642      	mov	r2, r8
 8004524:	3902      	subs	r1, #2
 8004526:	f505 70a4 	add.w	r0, r5, #328	; 0x148
 800452a:	2300      	movs	r3, #0
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
  }

  /* [12.3.2] Four threads are started at a lower priority than the
     current thread.*/
  test_set_step(2);
 800452c:	f8c7 e000 	str.w	lr, [r7]
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
 8004530:	f001 fa9e 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8004534:	69b3      	ldr	r3, [r6, #24]
 8004536:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
 8004538:	6899      	ldr	r1, [r3, #8]
 800453a:	4642      	mov	r2, r8
 800453c:	f505 7024 	add.w	r0, r5, #656	; 0x290
 8004540:	3903      	subs	r1, #3
 8004542:	2300      	movs	r3, #0
 8004544:	f001 fa94 	bl	8005a70 <chThdCreateStatic.constprop.69>
 8004548:	69b3      	ldr	r3, [r6, #24]
 800454a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
 800454c:	6899      	ldr	r1, [r3, #8]
 800454e:	4642      	mov	r2, r8
 8004550:	f505 7076 	add.w	r0, r5, #984	; 0x3d8
 8004554:	3904      	subs	r1, #4
 8004556:	2300      	movs	r3, #0
 8004558:	f001 fa8a 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800455c:	69b3      	ldr	r3, [r6, #24]
 800455e:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8004560:	6899      	ldr	r1, [r3, #8]
 8004562:	4642      	mov	r2, r8
 8004564:	3905      	subs	r1, #5
 8004566:	f505 60a4 	add.w	r0, r5, #1312	; 0x520
 800456a:	2300      	movs	r3, #0
 800456c:	f001 fa80 	bl	8005a70 <chThdCreateStatic.constprop.69>
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8004570:	2303      	movs	r3, #3
  test_set_step(2);
  {
    threads[1] = chThdCreateStatic(wa[1], WA_SIZE, chThdGetPriorityX()-2, bmk_thread3, NULL);
    threads[2] = chThdCreateStatic(wa[2], WA_SIZE, chThdGetPriorityX()-3, bmk_thread3, NULL);
    threads[3] = chThdCreateStatic(wa[3], WA_SIZE, chThdGetPriorityX()-4, bmk_thread3, NULL);
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
 8004572:	6120      	str	r0, [r4, #16]

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
  {
    n = msg_loop_test(threads[0]);
 8004574:	6820      	ldr	r0, [r4, #0]
    threads[4] = chThdCreateStatic(wa[4], WA_SIZE, chThdGetPriorityX()-5, bmk_thread3, NULL);
  }

  /* [12.3.3] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(3);
 8004576:	603b      	str	r3, [r7, #0]
  {
    n = msg_loop_test(threads[0]);
 8004578:	f7ff ff9a 	bl	80044b0 <msg_loop_test>
 800457c:	4604      	mov	r4, r0
    test_wait_threads();
 800457e:	f7ff fbc7 	bl	8003d10 <test_wait_threads>
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8004582:	2304      	movs	r3, #4
  {
    test_print("--- Score : ");
 8004584:	480d      	ldr	r0, [pc, #52]	; (80045bc <test_012_003_execute.lto_priv.167+0xcc>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.3.4] Score is printed.*/
  test_set_step(4);
 8004586:	603b      	str	r3, [r7, #0]
  {
    test_print("--- Score : ");
 8004588:	f7ff fc32 	bl	8003df0 <test_print>
    test_printn(n);
 800458c:	4620      	mov	r0, r4
 800458e:	f7ff fc3f 	bl	8003e10 <test_printn>
    test_print(" msgs/S, ");
 8004592:	480b      	ldr	r0, [pc, #44]	; (80045c0 <test_012_003_execute.lto_priv.167+0xd0>)
 8004594:	f7ff fc2c 	bl	8003df0 <test_print>
    test_printn(n << 1);
 8004598:	0060      	lsls	r0, r4, #1
 800459a:	f7ff fc39 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 800459e:	4809      	ldr	r0, [pc, #36]	; (80045c4 <test_012_003_execute.lto_priv.167+0xd4>)
  }
}
 80045a0:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 80045a4:	f7ff bc04 	b.w	8003db0 <test_println>
 80045a8:	200013b0 	.word	0x200013b0
 80045ac:	20000c50 	.word	0x20000c50
 80045b0:	2000133c 	.word	0x2000133c
 80045b4:	080046d1 	.word	0x080046d1
 80045b8:	20001340 	.word	0x20001340
 80045bc:	0800665c 	.word	0x0800665c
 80045c0:	0800723c 	.word	0x0800723c
 80045c4:	08006698 	.word	0x08006698
 80045c8:	08004f71 	.word	0x08004f71
 80045cc:	f3af 8000 	nop.w

080045d0 <test_012_002_execute.lto_priv.166>:
 *   second time window.
 * - [12.2.3] Score is printed.
 * .
 */

static void test_012_002_execute(void) {
 80045d0:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 80045d2:	4b14      	ldr	r3, [pc, #80]	; (8004624 <test_012_002_execute.lto_priv.166+0x54>)
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80045d4:	4c14      	ldr	r4, [pc, #80]	; (8004628 <test_012_002_execute.lto_priv.166+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 80045d6:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80045d8:	4a14      	ldr	r2, [pc, #80]	; (800462c <test_012_002_execute.lto_priv.166+0x5c>)
 80045da:	6899      	ldr	r1, [r3, #8]
 80045dc:	4814      	ldr	r0, [pc, #80]	; (8004630 <test_012_002_execute.lto_priv.166+0x60>)
 80045de:	3101      	adds	r1, #1
static void test_012_002_execute(void) {
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80045e0:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80045e2:	2300      	movs	r3, #0
static void test_012_002_execute(void) {
  uint32_t n;

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
 80045e4:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80045e6:	f001 fa43 	bl	8005a70 <chThdCreateStatic.constprop.69>
 80045ea:	4a12      	ldr	r2, [pc, #72]	; (8004634 <test_012_002_execute.lto_priv.166+0x64>)
  }

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80045ec:	2302      	movs	r3, #2

  /* [12.2.1] The messenger thread is started at an higher priority
     than the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()+1, bmk_thread1, NULL);
 80045ee:	6010      	str	r0, [r2, #0]
  }

  /* [12.2.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 80045f0:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 80045f2:	f7ff ff5d 	bl	80044b0 <msg_loop_test>
 80045f6:	4605      	mov	r5, r0
    test_wait_threads();
 80045f8:	f7ff fb8a 	bl	8003d10 <test_wait_threads>
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 80045fc:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 80045fe:	480e      	ldr	r0, [pc, #56]	; (8004638 <test_012_002_execute.lto_priv.166+0x68>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.2.3] Score is printed.*/
  test_set_step(3);
 8004600:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8004602:	f7ff fbf5 	bl	8003df0 <test_print>
    test_printn(n);
 8004606:	4628      	mov	r0, r5
 8004608:	f7ff fc02 	bl	8003e10 <test_printn>
    test_print(" msgs/S, ");
 800460c:	480b      	ldr	r0, [pc, #44]	; (800463c <test_012_002_execute.lto_priv.166+0x6c>)
 800460e:	f7ff fbef 	bl	8003df0 <test_print>
    test_printn(n << 1);
 8004612:	0068      	lsls	r0, r5, #1
 8004614:	f7ff fbfc 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 8004618:	4809      	ldr	r0, [pc, #36]	; (8004640 <test_012_002_execute.lto_priv.166+0x70>)
  }
}
 800461a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 800461e:	f7ff bbc7 	b.w	8003db0 <test_println>
 8004622:	bf00      	nop
 8004624:	200013b0 	.word	0x200013b0
 8004628:	2000133c 	.word	0x2000133c
 800462c:	080046d1 	.word	0x080046d1
 8004630:	20000c50 	.word	0x20000c50
 8004634:	20001340 	.word	0x20001340
 8004638:	0800665c 	.word	0x0800665c
 800463c:	0800723c 	.word	0x0800723c
 8004640:	08006698 	.word	0x08006698
 8004644:	f3af 8000 	nop.w
 8004648:	f3af 8000 	nop.w
 800464c:	f3af 8000 	nop.w

08004650 <test_012_001_execute.lto_priv.165>:
 *   second time window.
 * - [12.1.3] Score is printed.
 * .
 */

static void test_012_001_execute(void) {
 8004650:	b538      	push	{r3, r4, r5, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004652:	4b14      	ldr	r3, [pc, #80]	; (80046a4 <test_012_001_execute.lto_priv.165+0x54>)
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8004654:	4c14      	ldr	r4, [pc, #80]	; (80046a8 <test_012_001_execute.lto_priv.165+0x58>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004656:	699b      	ldr	r3, [r3, #24]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8004658:	4a14      	ldr	r2, [pc, #80]	; (80046ac <test_012_001_execute.lto_priv.165+0x5c>)
 800465a:	6899      	ldr	r1, [r3, #8]
 800465c:	4814      	ldr	r0, [pc, #80]	; (80046b0 <test_012_001_execute.lto_priv.165+0x60>)
 800465e:	3901      	subs	r1, #1
static void test_012_001_execute(void) {
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8004660:	2501      	movs	r5, #1
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8004662:	2300      	movs	r3, #0
static void test_012_001_execute(void) {
  uint32_t n;

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
 8004664:	6025      	str	r5, [r4, #0]
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 8004666:	f001 fa03 	bl	8005a70 <chThdCreateStatic.constprop.69>
 800466a:	4a12      	ldr	r2, [pc, #72]	; (80046b4 <test_012_001_execute.lto_priv.165+0x64>)
  }

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 800466c:	2302      	movs	r3, #2

  /* [12.1.1] The messenger thread is started at a lower priority than
     the current thread.*/
  test_set_step(1);
  {
    threads[0] = chThdCreateStatic(wa[0], WA_SIZE, chThdGetPriorityX()-1, bmk_thread1, NULL);
 800466e:	6010      	str	r0, [r2, #0]
  }

  /* [12.1.2] The number of messages exchanged is counted in a one
     second time window.*/
  test_set_step(2);
 8004670:	6023      	str	r3, [r4, #0]
  {
    n = msg_loop_test(threads[0]);
 8004672:	f7ff ff1d 	bl	80044b0 <msg_loop_test>
 8004676:	4605      	mov	r5, r0
    test_wait_threads();
 8004678:	f7ff fb4a 	bl	8003d10 <test_wait_threads>
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 800467c:	2303      	movs	r3, #3
  {
    test_print("--- Score : ");
 800467e:	480e      	ldr	r0, [pc, #56]	; (80046b8 <test_012_001_execute.lto_priv.165+0x68>)
    n = msg_loop_test(threads[0]);
    test_wait_threads();
  }

  /* [12.1.3] Score is printed.*/
  test_set_step(3);
 8004680:	6023      	str	r3, [r4, #0]
  {
    test_print("--- Score : ");
 8004682:	f7ff fbb5 	bl	8003df0 <test_print>
    test_printn(n);
 8004686:	4628      	mov	r0, r5
 8004688:	f7ff fbc2 	bl	8003e10 <test_printn>
    test_print(" msgs/S, ");
 800468c:	480b      	ldr	r0, [pc, #44]	; (80046bc <test_012_001_execute.lto_priv.165+0x6c>)
 800468e:	f7ff fbaf 	bl	8003df0 <test_print>
    test_printn(n << 1);
 8004692:	0068      	lsls	r0, r5, #1
 8004694:	f7ff fbbc 	bl	8003e10 <test_printn>
    test_println(" ctxswc/S");
 8004698:	4809      	ldr	r0, [pc, #36]	; (80046c0 <test_012_001_execute.lto_priv.165+0x70>)
  }
}
 800469a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  {
    test_print("--- Score : ");
    test_printn(n);
    test_print(" msgs/S, ");
    test_printn(n << 1);
    test_println(" ctxswc/S");
 800469e:	f7ff bb87 	b.w	8003db0 <test_println>
 80046a2:	bf00      	nop
 80046a4:	200013b0 	.word	0x200013b0
 80046a8:	2000133c 	.word	0x2000133c
 80046ac:	080046d1 	.word	0x080046d1
 80046b0:	20000c50 	.word	0x20000c50
 80046b4:	20001340 	.word	0x20001340
 80046b8:	0800665c 	.word	0x0800665c
 80046bc:	0800723c 	.word	0x0800723c
 80046c0:	08006698 	.word	0x08006698
 80046c4:	f3af 8000 	nop.w
 80046c8:	f3af 8000 	nop.w
 80046cc:	f3af 8000 	nop.w

080046d0 <bmk_thread1>:
#endif

static void tmo(void *param) {(void)param;}

#if CH_CFG_USE_MESSAGES
static THD_FUNCTION(bmk_thread1, p) {
 80046d0:	b570      	push	{r4, r5, r6, lr}
 80046d2:	2620      	movs	r6, #32
 80046d4:	2500      	movs	r5, #0
  thread_t *tp;
  msg_t msg;

  (void)p;
  do {
    tp = chMsgWait();
 80046d6:	f7ff fde3 	bl	80042a0 <chMsgWait>
 80046da:	6a44      	ldr	r4, [r0, #36]	; 0x24
 80046dc:	f386 8811 	msr	BASEPRI, r6
 */
static inline void chMsgReleaseS(thread_t *tp, msg_t msg) {

  chDbgCheckClassS();

  chSchWakeupS(tp, msg);
 80046e0:	4621      	mov	r1, r4
 80046e2:	f000 fe0d 	bl	8005300 <chSchWakeupS>
 80046e6:	f385 8811 	msr	BASEPRI, r5
    msg = chMsgGet(tp);
    chMsgRelease(tp, msg);
  } while (msg);
 80046ea:	2c00      	cmp	r4, #0
 80046ec:	d1f3      	bne.n	80046d6 <bmk_thread1+0x6>
}
 80046ee:	bd70      	pop	{r4, r5, r6, pc}

080046f0 <test_009_001_execute.lto_priv.153>:

static void test_009_001_setup(void) {
  chPoolObjectInit(&mp1, sizeof (uint32_t), NULL);
}

static void test_009_001_execute(void) {
 80046f0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  unsigned i;

  /* [9.1.1] Adding the objects to the pool using chPoolLoadArray().*/
  test_set_step(1);
 80046f4:	4e39      	ldr	r6, [pc, #228]	; (80047dc <test_009_001_execute.lto_priv.153+0xec>)
 80046f6:	4b3a      	ldr	r3, [pc, #232]	; (80047e0 <test_009_001_execute.lto_priv.153+0xf0>)
 80046f8:	4c3a      	ldr	r4, [pc, #232]	; (80047e4 <test_009_001_execute.lto_priv.153+0xf4>)
 80046fa:	2201      	movs	r2, #1
 80046fc:	6032      	str	r2, [r6, #0]
 80046fe:	2520      	movs	r5, #32
 8004700:	2204      	movs	r2, #4
 8004702:	2000      	movs	r0, #0
 8004704:	f385 8811 	msr	BASEPRI, r5
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8004708:	6821      	ldr	r1, [r4, #0]
 800470a:	6019      	str	r1, [r3, #0]
  mp->next = php;
 800470c:	6023      	str	r3, [r4, #0]
 800470e:	f380 8811 	msr	BASEPRI, r0
  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8004712:	6861      	ldr	r1, [r4, #4]
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8004714:	3a01      	subs	r2, #1
    chPoolAdd(mp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + mp->object_size);
 8004716:	440b      	add	r3, r1
 */
void chPoolLoadArray(memory_pool_t *mp, void *p, size_t n) {

  chDbgCheck((mp != NULL) && (n != 0U));

  while (n != 0U) {
 8004718:	d1f4      	bne.n	8004704 <test_009_001_execute.lto_priv.153+0x14>
  {
    chPoolLoadArray(&mp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
 800471a:	2302      	movs	r3, #2
 800471c:	6033      	str	r3, [r6, #0]
 800471e:	2504      	movs	r5, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8004720:	4830      	ldr	r0, [pc, #192]	; (80047e4 <test_009_001_execute.lto_priv.153+0xf4>)
 8004722:	f7ff fd15 	bl	8004150 <chPoolAlloc>
 8004726:	3000      	adds	r0, #0
 8004728:	bf18      	it	ne
 800472a:	2001      	movne	r0, #1
 800472c:	492e      	ldr	r1, [pc, #184]	; (80047e8 <test_009_001_execute.lto_priv.153+0xf8>)
 800472e:	f7ff fbc7 	bl	8003ec0 <_test_assert>
 8004732:	2800      	cmp	r0, #0
 8004734:	d13e      	bne.n	80047b4 <test_009_001_execute.lto_priv.153+0xc4>
  }

  /* [9.1.2] Emptying the pool using chPoolAlloc().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004736:	3d01      	subs	r5, #1
 8004738:	d1f2      	bne.n	8004720 <test_009_001_execute.lto_priv.153+0x30>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 800473a:	2303      	movs	r3, #3
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800473c:	4829      	ldr	r0, [pc, #164]	; (80047e4 <test_009_001_execute.lto_priv.153+0xf4>)
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 800473e:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8004740:	f7ff fd06 	bl	8004150 <chPoolAlloc>
 8004744:	4929      	ldr	r1, [pc, #164]	; (80047ec <test_009_001_execute.lto_priv.153+0xfc>)
 8004746:	fab0 f080 	clz	r0, r0
 800474a:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.3] Now must be empty.*/
  test_set_step(3);
 800474c:	f8df 808c 	ldr.w	r8, [pc, #140]	; 80047dc <test_009_001_execute.lto_priv.153+0xec>
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 8004750:	f7ff fbb6 	bl	8003ec0 <_test_assert>
 8004754:	bb70      	cbnz	r0, 80047b4 <test_009_001_execute.lto_priv.153+0xc4>
 8004756:	4b22      	ldr	r3, [pc, #136]	; (80047e0 <test_009_001_execute.lto_priv.153+0xf0>)
  }

  /* [9.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
 8004758:	2204      	movs	r2, #4
 800475a:	f103 0710 	add.w	r7, r3, #16
 800475e:	f8c8 2000 	str.w	r2, [r8]
 8004762:	2020      	movs	r0, #32
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      chPoolFree(&mp1, &objects[i]);
 8004764:	461a      	mov	r2, r3
 8004766:	f380 8811 	msr	BASEPRI, r0
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800476a:	6821      	ldr	r1, [r4, #0]
 800476c:	f843 1b04 	str.w	r1, [r3], #4
  mp->next = php;
 8004770:	6022      	str	r2, [r4, #0]
 8004772:	f385 8811 	msr	BASEPRI, r5
  }

  /* [9.1.4] Adding the objects to the pool using chPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004776:	42bb      	cmp	r3, r7
 8004778:	d1f4      	bne.n	8004764 <test_009_001_execute.lto_priv.153+0x74>
      chPoolFree(&mp1, &objects[i]);
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
 800477a:	2305      	movs	r3, #5
 800477c:	6033      	str	r3, [r6, #0]
 800477e:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
 8004780:	4d18      	ldr	r5, [pc, #96]	; (80047e4 <test_009_001_execute.lto_priv.153+0xf4>)
 8004782:	4628      	mov	r0, r5
 8004784:	f7ff fce4 	bl	8004150 <chPoolAlloc>
 8004788:	3000      	adds	r0, #0
 800478a:	bf18      	it	ne
 800478c:	2001      	movne	r0, #1
 800478e:	4916      	ldr	r1, [pc, #88]	; (80047e8 <test_009_001_execute.lto_priv.153+0xf8>)
 8004790:	f7ff fb96 	bl	8003ec0 <_test_assert>
 8004794:	b970      	cbnz	r0, 80047b4 <test_009_001_execute.lto_priv.153+0xc4>
  }

  /* [9.1.5] Emptying the pool using chPoolAlloc() again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004796:	3c01      	subs	r4, #1
 8004798:	d1f2      	bne.n	8004780 <test_009_001_execute.lto_priv.153+0x90>
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800479a:	2306      	movs	r3, #6
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 800479c:	4628      	mov	r0, r5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 800479e:	6033      	str	r3, [r6, #0]
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80047a0:	f7ff fcd6 	bl	8004150 <chPoolAlloc>
 80047a4:	4911      	ldr	r1, [pc, #68]	; (80047ec <test_009_001_execute.lto_priv.153+0xfc>)
 80047a6:	fab0 f080 	clz	r0, r0
 80047aa:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "list empty");
  }

  /* [9.1.6] Now must be empty again.*/
  test_set_step(6);
 80047ac:	4e0b      	ldr	r6, [pc, #44]	; (80047dc <test_009_001_execute.lto_priv.153+0xec>)
  {
    test_assert(chPoolAlloc(&mp1) == NULL, "list not empty");
 80047ae:	f7ff fb87 	bl	8003ec0 <_test_assert>
 80047b2:	b108      	cbz	r0, 80047b8 <test_009_001_execute.lto_priv.153+0xc8>
 80047b4:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  }

  /* [9.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
 80047b8:	2107      	movs	r1, #7
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
  mp->object_size = size;
 80047ba:	2204      	movs	r2, #4
  mp->provider = provider;
 80047bc:	4b0c      	ldr	r3, [pc, #48]	; (80047f0 <test_009_001_execute.lto_priv.153+0x100>)
 80047be:	6031      	str	r1, [r6, #0]
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80047c0:	4628      	mov	r0, r5
 */
void chPoolObjectInit(memory_pool_t *mp, size_t size, memgetfunc_t provider) {

  chDbgCheck((mp != NULL) && (size >= sizeof(void *)));

  mp->next = NULL;
 80047c2:	602c      	str	r4, [r5, #0]
  mp->object_size = size;
 80047c4:	606a      	str	r2, [r5, #4]
  mp->provider = provider;
 80047c6:	60ab      	str	r3, [r5, #8]
 80047c8:	f7ff fcc2 	bl	8004150 <chPoolAlloc>
 80047cc:	4909      	ldr	r1, [pc, #36]	; (80047f4 <test_009_001_execute.lto_priv.153+0x104>)
 80047ce:	fab0 f080 	clz	r0, r0
  }
}
 80047d2:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
  /* [9.1.7] Covering the case where a provider is unable to return
     more memory.*/
  test_set_step(7);
  {
    chPoolObjectInit(&mp1, sizeof (uint32_t), null_provider);
    test_assert(chPoolAlloc(&mp1) == NULL, "provider returned memory");
 80047d6:	0940      	lsrs	r0, r0, #5
 80047d8:	f7ff bb72 	b.w	8003ec0 <_test_assert>
 80047dc:	2000133c 	.word	0x2000133c
 80047e0:	20001380 	.word	0x20001380
 80047e4:	2000084c 	.word	0x2000084c
 80047e8:	08007248 	.word	0x08007248
 80047ec:	08007254 	.word	0x08007254
 80047f0:	08001e51 	.word	0x08001e51
 80047f4:	08007264 	.word	0x08007264
 80047f8:	f3af 8000 	nop.w
 80047fc:	f3af 8000 	nop.w

08004800 <test_011_002_execute.lto_priv.164>:

static void test_011_002_setup(void) {
  chPoolObjectInit(&mp1, THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE), NULL);
}

static void test_011_002_execute(void) {
 8004800:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  unsigned i;
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
 8004802:	4d3d      	ldr	r5, [pc, #244]	; (80048f8 <test_011_002_execute.lto_priv.164+0xf8>)
 8004804:	4b3d      	ldr	r3, [pc, #244]	; (80048fc <test_011_002_execute.lto_priv.164+0xfc>)
 8004806:	493e      	ldr	r1, [pc, #248]	; (8004900 <test_011_002_execute.lto_priv.164+0x100>)
 8004808:	2201      	movs	r2, #1
 800480a:	602a      	str	r2, [r5, #0]
 800480c:	f103 0710 	add.w	r7, r3, #16
 8004810:	2620      	movs	r6, #32
 8004812:	2400      	movs	r4, #0
  {
    for (i = 0; i < 4; i++)
      chPoolFree(&mp1, wa[i]);
 8004814:	f853 2b04 	ldr.w	r2, [r3], #4
 8004818:	f386 8811 	msr	BASEPRI, r6
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800481c:	6808      	ldr	r0, [r1, #0]
 800481e:	6010      	str	r0, [r2, #0]
  mp->next = php;
 8004820:	600a      	str	r2, [r1, #0]
 8004822:	f384 8811 	msr	BASEPRI, r4
  tprio_t prio;

  /* [11.2.1] Adding four working areas to the pool.*/
  test_set_step(1);
  {
    for (i = 0; i < 4; i++)
 8004826:	42bb      	cmp	r3, r7
 8004828:	d1f4      	bne.n	8004814 <test_011_002_execute.lto_priv.164+0x14>
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 800482a:	4b36      	ldr	r3, [pc, #216]	; (8004904 <test_011_002_execute.lto_priv.164+0x104>)
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800482c:	4a36      	ldr	r2, [pc, #216]	; (8004908 <test_011_002_execute.lto_priv.164+0x108>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 800482e:	699b      	ldr	r3, [r3, #24]
 8004830:	4836      	ldr	r0, [pc, #216]	; (800490c <test_011_002_execute.lto_priv.164+0x10c>)
 8004832:	689e      	ldr	r6, [r3, #8]
 8004834:	4c36      	ldr	r4, [pc, #216]	; (8004910 <test_011_002_execute.lto_priv.164+0x110>)
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 8004836:	2303      	movs	r3, #3
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8004838:	1e71      	subs	r1, r6, #1
  {
    prio = chThdGetPriorityX();
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
 800483a:	602b      	str	r3, [r5, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 800483c:	f001 fb08 	bl	8005e50 <chThdCreateFromMemoryPool.constprop.38>
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8004840:	1eb1      	subs	r1, r6, #2
  }

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
 8004842:	6020      	str	r0, [r4, #0]
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 8004844:	4a33      	ldr	r2, [pc, #204]	; (8004914 <test_011_002_execute.lto_priv.164+0x114>)
 8004846:	4834      	ldr	r0, [pc, #208]	; (8004918 <test_011_002_execute.lto_priv.164+0x118>)
 8004848:	f001 fb02 	bl	8005e50 <chThdCreateFromMemoryPool.constprop.38>
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800484c:	1ef1      	subs	r1, r6, #3

  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
 800484e:	6060      	str	r0, [r4, #4]
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 8004850:	4a32      	ldr	r2, [pc, #200]	; (800491c <test_011_002_execute.lto_priv.164+0x11c>)
 8004852:	4833      	ldr	r0, [pc, #204]	; (8004920 <test_011_002_execute.lto_priv.164+0x120>)
 8004854:	f001 fafc 	bl	8005e50 <chThdCreateFromMemoryPool.constprop.38>
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004858:	1f31      	subs	r1, r6, #4
  /* [11.2.3] Creating the five threads.*/
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
 800485a:	60a0      	str	r0, [r4, #8]
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 800485c:	4a31      	ldr	r2, [pc, #196]	; (8004924 <test_011_002_execute.lto_priv.164+0x124>)
 800485e:	4832      	ldr	r0, [pc, #200]	; (8004928 <test_011_002_execute.lto_priv.164+0x128>)
 8004860:	f001 faf6 	bl	8005e50 <chThdCreateFromMemoryPool.constprop.38>
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8004864:	4a31      	ldr	r2, [pc, #196]	; (800492c <test_011_002_execute.lto_priv.164+0x12c>)
  test_set_step(3);
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
 8004866:	60e0      	str	r0, [r4, #12]
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8004868:	1f71      	subs	r1, r6, #5
 800486a:	4831      	ldr	r0, [pc, #196]	; (8004930 <test_011_002_execute.lto_priv.164+0x130>)
 800486c:	f001 faf0 	bl	8005e50 <chThdCreateFromMemoryPool.constprop.38>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 8004870:	6823      	ldr	r3, [r4, #0]
  {
    threads[0] = chThdCreateFromMemoryPool(&mp1, "dyn1", prio-1, dyn_thread1, "A");
    threads[1] = chThdCreateFromMemoryPool(&mp1, "dyn2", prio-2, dyn_thread1, "B");
    threads[2] = chThdCreateFromMemoryPool(&mp1, "dyn3", prio-3, dyn_thread1, "C");
    threads[3] = chThdCreateFromMemoryPool(&mp1, "dyn4", prio-4, dyn_thread1, "D");
    threads[4] = chThdCreateFromMemoryPool(&mp1, "dyn5", prio-5, dyn_thread1, "E");
 8004872:	6120      	str	r0, [r4, #16]
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
 8004874:	2204      	movs	r2, #4
 8004876:	602a      	str	r2, [r5, #0]
  {
    test_assert((threads[0] != NULL) &&
 8004878:	2b00      	cmp	r3, #0
 800487a:	d03b      	beq.n	80048f4 <test_011_002_execute.lto_priv.164+0xf4>
 800487c:	6860      	ldr	r0, [r4, #4]
 800487e:	b128      	cbz	r0, 800488c <test_011_002_execute.lto_priv.164+0x8c>
 8004880:	68a0      	ldr	r0, [r4, #8]
 8004882:	b118      	cbz	r0, 800488c <test_011_002_execute.lto_priv.164+0x8c>
 8004884:	68e0      	ldr	r0, [r4, #12]
 8004886:	3000      	adds	r0, #0
 8004888:	bf18      	it	ne
 800488a:	2001      	movne	r0, #1
 800488c:	4929      	ldr	r1, [pc, #164]	; (8004934 <test_011_002_execute.lto_priv.164+0x134>)
 800488e:	f7ff fb17 	bl	8003ec0 <_test_assert>
 8004892:	b100      	cbz	r0, 8004896 <test_011_002_execute.lto_priv.164+0x96>
 8004894:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
                (threads[1] != NULL) &&
                (threads[2] != NULL) &&
                (threads[3] != NULL),
                "thread creation failed");
    test_assert(threads[4] == NULL,
 8004896:	6920      	ldr	r0, [r4, #16]
 8004898:	4927      	ldr	r1, [pc, #156]	; (8004938 <test_011_002_execute.lto_priv.164+0x138>)
 800489a:	fab0 f080 	clz	r0, r0
 800489e:	0940      	lsrs	r0, r0, #5
 80048a0:	f7ff fb0e 	bl	8003ec0 <_test_assert>
 80048a4:	2800      	cmp	r0, #0
 80048a6:	d1f5      	bne.n	8004894 <test_011_002_execute.lto_priv.164+0x94>
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 80048a8:	2305      	movs	r3, #5
 80048aa:	602b      	str	r3, [r5, #0]
  {
    test_wait_threads();
 80048ac:	f7ff fa30 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("ABCD", "invalid sequence");
 80048b0:	4822      	ldr	r0, [pc, #136]	; (800493c <test_011_002_execute.lto_priv.164+0x13c>)
 80048b2:	4923      	ldr	r1, [pc, #140]	; (8004940 <test_011_002_execute.lto_priv.164+0x140>)
                "thread creation not failed");
  }

  /* [11.2.5] Letting them run, free the memory then checking the
     execution sequence.*/
  test_set_step(5);
 80048b4:	4c10      	ldr	r4, [pc, #64]	; (80048f8 <test_011_002_execute.lto_priv.164+0xf8>)
  {
    test_wait_threads();
    test_assert_sequence("ABCD", "invalid sequence");
 80048b6:	f7ff fadb 	bl	8003e70 <_test_assert_sequence>
 80048ba:	2800      	cmp	r0, #0
 80048bc:	d1ea      	bne.n	8004894 <test_011_002_execute.lto_priv.164+0x94>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
 80048be:	2306      	movs	r3, #6
 80048c0:	6023      	str	r3, [r4, #0]
 80048c2:	2404      	movs	r4, #4
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
 80048c4:	480e      	ldr	r0, [pc, #56]	; (8004900 <test_011_002_execute.lto_priv.164+0x100>)
 80048c6:	f7ff fc43 	bl	8004150 <chPoolAlloc>
 80048ca:	3000      	adds	r0, #0
 80048cc:	bf18      	it	ne
 80048ce:	2001      	movne	r0, #1
 80048d0:	491c      	ldr	r1, [pc, #112]	; (8004944 <test_011_002_execute.lto_priv.164+0x144>)
 80048d2:	f7ff faf5 	bl	8003ec0 <_test_assert>
 80048d6:	2800      	cmp	r0, #0
 80048d8:	d1dc      	bne.n	8004894 <test_011_002_execute.lto_priv.164+0x94>
  }

  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
 80048da:	3c01      	subs	r4, #1
 80048dc:	d1f2      	bne.n	80048c4 <test_011_002_execute.lto_priv.164+0xc4>
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80048de:	4808      	ldr	r0, [pc, #32]	; (8004900 <test_011_002_execute.lto_priv.164+0x100>)
 80048e0:	f7ff fc36 	bl	8004150 <chPoolAlloc>
 80048e4:	4918      	ldr	r1, [pc, #96]	; (8004948 <test_011_002_execute.lto_priv.164+0x148>)
 80048e6:	fab0 f080 	clz	r0, r0
  }
}
 80048ea:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
  /* [11.2.6] Testing that the pool contains four elements again.*/
  test_set_step(6);
  {
    for (i = 0; i < 4; i++)
      test_assert(chPoolAlloc(&mp1) != NULL, "pool list empty");
    test_assert(chPoolAlloc(&mp1) == NULL, "pool list not empty");
 80048ee:	0940      	lsrs	r0, r0, #5
 80048f0:	f7ff bae6 	b.w	8003ec0 <_test_assert>
  }

  /* [11.2.4] Testing that only the fifth thread creation failed.*/
  test_set_step(4);
  {
    test_assert((threads[0] != NULL) &&
 80048f4:	4618      	mov	r0, r3
 80048f6:	e7c9      	b.n	800488c <test_011_002_execute.lto_priv.164+0x8c>
 80048f8:	2000133c 	.word	0x2000133c
 80048fc:	08006e94 	.word	0x08006e94
 8004900:	20001470 	.word	0x20001470
 8004904:	200013b0 	.word	0x200013b0
 8004908:	08006f38 	.word	0x08006f38
 800490c:	08007280 	.word	0x08007280
 8004910:	20001340 	.word	0x20001340
 8004914:	08006f3c 	.word	0x08006f3c
 8004918:	08007288 	.word	0x08007288
 800491c:	08006f40 	.word	0x08006f40
 8004920:	08007290 	.word	0x08007290
 8004924:	08006f44 	.word	0x08006f44
 8004928:	08007298 	.word	0x08007298
 800492c:	08006f4c 	.word	0x08006f4c
 8004930:	080072a0 	.word	0x080072a0
 8004934:	080072a8 	.word	0x080072a8
 8004938:	080072c0 	.word	0x080072c0
 800493c:	080070bc 	.word	0x080070bc
 8004940:	08006f50 	.word	0x08006f50
 8004944:	080072dc 	.word	0x080072dc
 8004948:	080072ec 	.word	0x080072ec
 800494c:	f3af 8000 	nop.w

08004950 <dyn_thread1.lto_priv.73>:
static memory_pool_t mp1;
#endif

static THD_FUNCTION(dyn_thread1, p) {

  test_emit_token(*(char *)p);
 8004950:	7800      	ldrb	r0, [r0, #0]
 8004952:	f7ff ba15 	b.w	8003d80 <test_emit_token>
 8004956:	bf00      	nop
 8004958:	f3af 8000 	nop.w
 800495c:	f3af 8000 	nop.w

08004960 <test_011_001_execute.lto_priv.162>:

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 8004960:	b5f0      	push	{r4, r5, r6, r7, lr}
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.current;
 8004962:	4b3e      	ldr	r3, [pc, #248]	; (8004a5c <test_011_001_execute.lto_priv.162+0xfc>)
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8004964:	4c3e      	ldr	r4, [pc, #248]	; (8004a60 <test_011_001_execute.lto_priv.162+0x100>)
 *
 * @xclass
 */
static inline tprio_t chThdGetPriorityX(void) {

  return chThdGetSelfX()->prio;
 8004966:	699b      	ldr	r3, [r3, #24]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004968:	483e      	ldr	r0, [pc, #248]	; (8004a64 <test_011_001_execute.lto_priv.162+0x104>)
 800496a:	689e      	ldr	r6, [r3, #8]

static void test_011_001_setup(void) {
  chHeapObjectInit(&heap1, test_buffer, sizeof test_buffer);
}

static void test_011_001_execute(void) {
 800496c:	b085      	sub	sp, #20
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 800496e:	2302      	movs	r3, #2
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004970:	4669      	mov	r1, sp
 8004972:	aa01      	add	r2, sp, #4
  {
    prio = chThdGetPriorityX();
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
 8004974:	6023      	str	r3, [r4, #0]
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 8004976:	f7ff fc03 	bl	8004180 <chHeapStatus>
    test_assert(n1 == 1, "heap fragmented");
 800497a:	493b      	ldr	r1, [pc, #236]	; (8004a68 <test_011_001_execute.lto_priv.162+0x108>)
  }

  /* [11.1.2] Getting heap info before the test.*/
  test_set_step(2);
  {
    n1 = chHeapStatus(&heap1, &total1, &largest1);
 800497c:	4605      	mov	r5, r0
    test_assert(n1 == 1, "heap fragmented");
 800497e:	f1a0 0001 	sub.w	r0, r0, #1
 8004982:	fab0 f080 	clz	r0, r0
 8004986:	0940      	lsrs	r0, r0, #5
 8004988:	f7ff fa9a 	bl	8003ec0 <_test_assert>
 800498c:	b108      	cbz	r0, 8004992 <test_011_001_execute.lto_priv.162+0x32>
    n2 = chHeapStatus(&heap1, &total2, &largest2);
    test_assert(n1 == n2, "fragmentation changed");
    test_assert(total1 == total2, "total free space changed");
    test_assert(largest1 == largest2, "largest fragment size changed");
  }
}
 800498e:	b005      	add	sp, #20
 8004990:	bdf0      	pop	{r4, r5, r6, r7, pc}
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8004992:	2203      	movs	r2, #3
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8004994:	4935      	ldr	r1, [pc, #212]	; (8004a6c <test_011_001_execute.lto_priv.162+0x10c>)
    n1 = chHeapStatus(&heap1, &total1, &largest1);
    test_assert(n1 == 1, "heap fragmented");
  }

  /* [11.1.3] Creating thread 1, it is expected to succeed.*/
  test_set_step(3);
 8004996:	6022      	str	r2, [r4, #0]
  {
    threads[0] = chThdCreateFromHeap(&heap1,
 8004998:	f44f 70a4 	mov.w	r0, #328	; 0x148
 800499c:	4b34      	ldr	r3, [pc, #208]	; (8004a70 <test_011_001_execute.lto_priv.162+0x110>)
 800499e:	4f35      	ldr	r7, [pc, #212]	; (8004a74 <test_011_001_execute.lto_priv.162+0x114>)
 80049a0:	1e72      	subs	r2, r6, #1
 80049a2:	f001 fa25 	bl	8005df0 <chThdCreateFromHeap.constprop.39>
 80049a6:	6038      	str	r0, [r7, #0]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn1",
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
 80049a8:	3000      	adds	r0, #0
 80049aa:	bf18      	it	ne
 80049ac:	2001      	movne	r0, #1
 80049ae:	4932      	ldr	r1, [pc, #200]	; (8004a78 <test_011_001_execute.lto_priv.162+0x118>)
 80049b0:	f7ff fa86 	bl	8003ec0 <_test_assert>
 80049b4:	2800      	cmp	r0, #0
 80049b6:	d1ea      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 80049b8:	2204      	movs	r2, #4
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80049ba:	4930      	ldr	r1, [pc, #192]	; (8004a7c <test_011_001_execute.lto_priv.162+0x11c>)
 80049bc:	4b30      	ldr	r3, [pc, #192]	; (8004a80 <test_011_001_execute.lto_priv.162+0x120>)
                                     prio-1, dyn_thread1, "A");
    test_assert(threads[0] != NULL, "thread creation failed");
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
 80049be:	6022      	str	r2, [r4, #0]
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80049c0:	f44f 70a4 	mov.w	r0, #328	; 0x148
 80049c4:	1eb2      	subs	r2, r6, #2
 80049c6:	f001 fa13 	bl	8005df0 <chThdCreateFromHeap.constprop.39>
 80049ca:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80049cc:	3000      	adds	r0, #0
 80049ce:	bf18      	it	ne
 80049d0:	2001      	movne	r0, #1
 80049d2:	4929      	ldr	r1, [pc, #164]	; (8004a78 <test_011_001_execute.lto_priv.162+0x118>)
  }

  /* [11.1.4] Creating thread 2, it is expected to succeed.*/
  test_set_step(4);
  {
    threads[1] = chThdCreateFromHeap(&heap1,
 80049d4:	607b      	str	r3, [r7, #4]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE),
                                     "dyn2",
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
 80049d6:	f7ff fa73 	bl	8003ec0 <_test_assert>
 80049da:	2800      	cmp	r0, #0
 80049dc:	d1d7      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80049de:	1ef2      	subs	r2, r6, #3
 80049e0:	4928      	ldr	r1, [pc, #160]	; (8004a84 <test_011_001_execute.lto_priv.162+0x124>)
 80049e2:	4b29      	ldr	r3, [pc, #164]	; (8004a88 <test_011_001_execute.lto_priv.162+0x128>)
 80049e4:	4829      	ldr	r0, [pc, #164]	; (8004a8c <test_011_001_execute.lto_priv.162+0x12c>)
                                     prio-2, dyn_thread1, "B");
    test_assert(threads[1] != NULL, "thread creation failed");
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
 80049e6:	2605      	movs	r6, #5
 80049e8:	6026      	str	r6, [r4, #0]
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80049ea:	f001 fa01 	bl	8005df0 <chThdCreateFromHeap.constprop.39>
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80049ee:	4928      	ldr	r1, [pc, #160]	; (8004a90 <test_011_001_execute.lto_priv.162+0x130>)
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80049f0:	4603      	mov	r3, r0
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80049f2:	fab0 f080 	clz	r0, r0
 80049f6:	40f0      	lsrs	r0, r6
  }

  /* [11.1.5] Creating thread 3, it is expected to fail.*/
  test_set_step(5);
  {
    threads[2] = chThdCreateFromHeap(&heap1,
 80049f8:	60bb      	str	r3, [r7, #8]
                                     THD_WORKING_AREA_SIZE(THREADS_STACK_SIZE * 1024),
                                     "dyn3",
                                     prio-3, dyn_thread1, "C");
    test_assert(threads[2] == NULL, "thread creation not failed");
 80049fa:	f7ff fa61 	bl	8003ec0 <_test_assert>
 80049fe:	2800      	cmp	r0, #0
 8004a00:	d1c5      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
  }

  /* [11.1.6] Letting threads execute then checking the start order and
     freeing memory.*/
  test_set_step(6);
 8004a02:	2306      	movs	r3, #6
 8004a04:	6023      	str	r3, [r4, #0]
  {
    test_wait_threads();
 8004a06:	f7ff f983 	bl	8003d10 <test_wait_threads>
    test_assert_sequence("AB", "invalid sequence");
 8004a0a:	4822      	ldr	r0, [pc, #136]	; (8004a94 <test_011_001_execute.lto_priv.162+0x134>)
 8004a0c:	4922      	ldr	r1, [pc, #136]	; (8004a98 <test_011_001_execute.lto_priv.162+0x138>)
 8004a0e:	f7ff fa2f 	bl	8003e70 <_test_assert_sequence>
 8004a12:	2800      	cmp	r0, #0
 8004a14:	d1bb      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 8004a16:	2307      	movs	r3, #7
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8004a18:	a902      	add	r1, sp, #8
 8004a1a:	4812      	ldr	r0, [pc, #72]	; (8004a64 <test_011_001_execute.lto_priv.162+0x104>)
    test_wait_threads();
    test_assert_sequence("AB", "invalid sequence");
  }

  /* [11.1.7] Getting heap info again for verification.*/
  test_set_step(7);
 8004a1c:	6023      	str	r3, [r4, #0]
  {
    n2 = chHeapStatus(&heap1, &total2, &largest2);
 8004a1e:	aa03      	add	r2, sp, #12
 8004a20:	f7ff fbae 	bl	8004180 <chHeapStatus>
    test_assert(n1 == n2, "fragmentation changed");
 8004a24:	491d      	ldr	r1, [pc, #116]	; (8004a9c <test_011_001_execute.lto_priv.162+0x13c>)
 8004a26:	1a28      	subs	r0, r5, r0
 8004a28:	fab0 f080 	clz	r0, r0
 8004a2c:	0940      	lsrs	r0, r0, #5
 8004a2e:	f7ff fa47 	bl	8003ec0 <_test_assert>
 8004a32:	2800      	cmp	r0, #0
 8004a34:	d1ab      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
    test_assert(total1 == total2, "total free space changed");
 8004a36:	9800      	ldr	r0, [sp, #0]
 8004a38:	9b02      	ldr	r3, [sp, #8]
 8004a3a:	4919      	ldr	r1, [pc, #100]	; (8004aa0 <test_011_001_execute.lto_priv.162+0x140>)
 8004a3c:	1ac2      	subs	r2, r0, r3
 8004a3e:	4250      	negs	r0, r2
 8004a40:	4150      	adcs	r0, r2
 8004a42:	f7ff fa3d 	bl	8003ec0 <_test_assert>
 8004a46:	2800      	cmp	r0, #0
 8004a48:	d1a1      	bne.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
    test_assert(largest1 == largest2, "largest fragment size changed");
 8004a4a:	9801      	ldr	r0, [sp, #4]
 8004a4c:	9b03      	ldr	r3, [sp, #12]
 8004a4e:	4915      	ldr	r1, [pc, #84]	; (8004aa4 <test_011_001_execute.lto_priv.162+0x144>)
 8004a50:	1ac3      	subs	r3, r0, r3
 8004a52:	4258      	negs	r0, r3
 8004a54:	4158      	adcs	r0, r3
 8004a56:	f7ff fa33 	bl	8003ec0 <_test_assert>
 8004a5a:	e798      	b.n	800498e <test_011_001_execute.lto_priv.162+0x2e>
 8004a5c:	200013b0 	.word	0x200013b0
 8004a60:	2000133c 	.word	0x2000133c
 8004a64:	20001430 	.word	0x20001430
 8004a68:	08007300 	.word	0x08007300
 8004a6c:	08007280 	.word	0x08007280
 8004a70:	08006f38 	.word	0x08006f38
 8004a74:	20001340 	.word	0x20001340
 8004a78:	080072a8 	.word	0x080072a8
 8004a7c:	08007288 	.word	0x08007288
 8004a80:	08006f3c 	.word	0x08006f3c
 8004a84:	08007290 	.word	0x08007290
 8004a88:	08006f40 	.word	0x08006f40
 8004a8c:	000200c8 	.word	0x000200c8
 8004a90:	080072c0 	.word	0x080072c0
 8004a94:	08007310 	.word	0x08007310
 8004a98:	08006f50 	.word	0x08006f50
 8004a9c:	08007314 	.word	0x08007314
 8004aa0:	0800732c 	.word	0x0800732c
 8004aa4:	08007348 	.word	0x08007348
 8004aa8:	f3af 8000 	nop.w
 8004aac:	f3af 8000 	nop.w

08004ab0 <test_010_002_execute.lto_priv.160>:
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 8004ab0:	b570      	push	{r4, r5, r6, lr}
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8004ab2:	4c15      	ldr	r4, [pc, #84]	; (8004b08 <test_010_002_execute.lto_priv.160+0x58>)
 *   block is freed using chHeapFree(), must not fail.
 * - [10.2.2] Testing allocation failure.
 * .
 */

static void test_010_002_execute(void) {
 8004ab4:	b082      	sub	sp, #8
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8004ab6:	2301      	movs	r3, #1
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8004ab8:	aa01      	add	r2, sp, #4
 8004aba:	4669      	mov	r1, sp
 8004abc:	2000      	movs	r0, #0
  void *p1;
  size_t total_size, largest_size;

  /* [10.2.1] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(1);
 8004abe:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
 8004ac0:	f7ff fb5e 	bl	8004180 <chHeapStatus>
 *
 * @api
 */
static inline void *chHeapAlloc(memory_heap_t *heapp, size_t size) {

  return chHeapAllocAligned(heapp, size, CH_HEAP_ALIGNMENT);
 8004ac4:	2110      	movs	r1, #16
 8004ac6:	4811      	ldr	r0, [pc, #68]	; (8004b0c <test_010_002_execute.lto_priv.160+0x5c>)
 8004ac8:	f001 f912 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8004acc:	4606      	mov	r6, r0
 8004ace:	3000      	adds	r0, #0
 8004ad0:	490f      	ldr	r1, [pc, #60]	; (8004b10 <test_010_002_execute.lto_priv.160+0x60>)
 8004ad2:	bf18      	it	ne
 8004ad4:	2001      	movne	r0, #1
 8004ad6:	f7ff f9f3 	bl	8003ec0 <_test_assert>
 8004ada:	4605      	mov	r5, r0
 8004adc:	b108      	cbz	r0, 8004ae2 <test_010_002_execute.lto_priv.160+0x32>
  test_set_step(2);
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
  }
}
 8004ade:	b002      	add	sp, #8
 8004ae0:	bd70      	pop	{r4, r5, r6, pc}
  test_set_step(1);
  {
    (void)chHeapStatus(NULL, &total_size, &largest_size);
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
    chHeapFree(p1);
 8004ae2:	4630      	mov	r0, r6
 8004ae4:	f7ff fb84 	bl	80041f0 <chHeapFree>
  }

  /* [10.2.2] Testing allocation failure.*/
  test_set_step(2);
 8004ae8:	2302      	movs	r3, #2
 8004aea:	4628      	mov	r0, r5
 8004aec:	f06f 01ff 	mvn.w	r1, #255	; 0xff
 8004af0:	6023      	str	r3, [r4, #0]
 8004af2:	f001 f8fd 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(NULL, (size_t)-256);
    test_assert(p1 == NULL, "allocation not failed");
 8004af6:	4907      	ldr	r1, [pc, #28]	; (8004b14 <test_010_002_execute.lto_priv.160+0x64>)
 8004af8:	fab0 f080 	clz	r0, r0
 8004afc:	0940      	lsrs	r0, r0, #5
 8004afe:	f7ff f9df 	bl	8003ec0 <_test_assert>
  }
}
 8004b02:	b002      	add	sp, #8
 8004b04:	bd70      	pop	{r4, r5, r6, pc}
 8004b06:	bf00      	nop
 8004b08:	2000133c 	.word	0x2000133c
 8004b0c:	20001390 	.word	0x20001390
 8004b10:	08007368 	.word	0x08007368
 8004b14:	0800737c 	.word	0x0800737c
 8004b18:	f3af 8000 	nop.w
 8004b1c:	f3af 8000 	nop.w

08004b20 <test_010_001_execute.lto_priv.159>:

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_010_001_execute(void) {
 8004b20:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8004b24:	4cbe      	ldr	r4, [pc, #760]	; (8004e20 <test_010_001_execute.lto_priv.159+0x300>)
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8004b26:	48bf      	ldr	r0, [pc, #764]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)

static void test_010_001_setup(void) {
  chHeapObjectInit(&test_heap, test_buffer, sizeof(test_buffer));
}

static void test_010_001_execute(void) {
 8004b28:	b084      	sub	sp, #16
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8004b2a:	2301      	movs	r3, #1
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8004b2c:	a901      	add	r1, sp, #4
 8004b2e:	2200      	movs	r2, #0
  void *p1, *p2, *p3;
  size_t n, sz;

  /* [10.1.1] Testing initial conditions, the heap must not be
     fragmented and one free block present.*/
  test_set_step(1);
 8004b30:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
 8004b32:	f7ff fb25 	bl	8004180 <chHeapStatus>
 8004b36:	49bc      	ldr	r1, [pc, #752]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004b38:	f1a0 0001 	sub.w	r0, r0, #1
 8004b3c:	fab0 f080 	clz	r0, r0
 8004b40:	0940      	lsrs	r0, r0, #5
 8004b42:	f7ff f9bd 	bl	8003ec0 <_test_assert>
 8004b46:	b110      	cbz	r0, 8004b4e <test_010_001_execute.lto_priv.159+0x2e>
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
    test_assert(n == sz, "size changed");
  }
}
 8004b48:	b004      	add	sp, #16
 8004b4a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    test_assert(chHeapStatus(&test_heap, &sz, NULL) == 1, "heap fragmented");
  }

  /* [10.1.2] Trying to allocate an block bigger than available space,
     an error is expected.*/
  test_set_step(2);
 8004b4e:	2302      	movs	r3, #2
 8004b50:	f44f 614d 	mov.w	r1, #3280	; 0xcd0
 8004b54:	48b3      	ldr	r0, [pc, #716]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004b56:	6023      	str	r3, [r4, #0]
 8004b58:	f001 f8ca 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, sizeof test_buffer * 2);
    test_assert(p1 == NULL, "allocation not failed");
 8004b5c:	49b3      	ldr	r1, [pc, #716]	; (8004e2c <test_010_001_execute.lto_priv.159+0x30c>)
 8004b5e:	fab0 f080 	clz	r0, r0
 8004b62:	0940      	lsrs	r0, r0, #5
 8004b64:	f7ff f9ac 	bl	8003ec0 <_test_assert>
 8004b68:	2800      	cmp	r0, #0
 8004b6a:	d1ed      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.3] Single block allocation using chHeapAlloc() then the
     block is freed using chHeapFree(), must not fail.*/
  test_set_step(3);
 8004b6c:	2303      	movs	r3, #3
 8004b6e:	2110      	movs	r1, #16
 8004b70:	48ac      	ldr	r0, [pc, #688]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004b72:	6023      	str	r3, [r4, #0]
 8004b74:	f001 f8bc 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    test_assert(p1 != NULL, "allocation failed");
 8004b78:	4605      	mov	r5, r0
 8004b7a:	3000      	adds	r0, #0
 8004b7c:	bf18      	it	ne
 8004b7e:	2001      	movne	r0, #1
 8004b80:	49ab      	ldr	r1, [pc, #684]	; (8004e30 <test_010_001_execute.lto_priv.159+0x310>)
 8004b82:	f7ff f99d 	bl	8003ec0 <_test_assert>
 8004b86:	2800      	cmp	r0, #0
 8004b88:	d1de      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    chHeapFree(p1);
 8004b8a:	4628      	mov	r0, r5
 8004b8c:	f7ff fb30 	bl	80041f0 <chHeapFree>
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8004b90:	2304      	movs	r3, #4
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8004b92:	a902      	add	r1, sp, #8
 8004b94:	48a3      	ldr	r0, [pc, #652]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
    chHeapFree(p1);
  }

  /* [10.1.4] Using chHeapStatus() to assess the heap state. There must
     be at least one free block of sufficient size.*/
  test_set_step(4);
 8004b96:	6023      	str	r3, [r4, #0]
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8004b98:	aa03      	add	r2, sp, #12
 8004b9a:	f7ff faf1 	bl	8004180 <chHeapStatus>
    test_assert(n == 1, "missing free block");
 8004b9e:	49a5      	ldr	r1, [pc, #660]	; (8004e34 <test_010_001_execute.lto_priv.159+0x314>)
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8004ba0:	4603      	mov	r3, r0
    test_assert(n == 1, "missing free block");
 8004ba2:	f1a0 0001 	sub.w	r0, r0, #1
 8004ba6:	fab0 f080 	clz	r0, r0
 8004baa:	0940      	lsrs	r0, r0, #5
     be at least one free block of sufficient size.*/
  test_set_step(4);
  {
    size_t total_size, largest_size;

    n = chHeapStatus(&test_heap, &total_size, &largest_size);
 8004bac:	9300      	str	r3, [sp, #0]
    test_assert(n == 1, "missing free block");
 8004bae:	f7ff f987 	bl	8003ec0 <_test_assert>
 8004bb2:	2800      	cmp	r0, #0
 8004bb4:	d1c8      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    test_assert(total_size >= ALLOC_SIZE, "unexpected heap state");
 8004bb6:	9802      	ldr	r0, [sp, #8]
 8004bb8:	499f      	ldr	r1, [pc, #636]	; (8004e38 <test_010_001_execute.lto_priv.159+0x318>)
 8004bba:	280f      	cmp	r0, #15
 8004bbc:	bf94      	ite	ls
 8004bbe:	2000      	movls	r0, #0
 8004bc0:	2001      	movhi	r0, #1
 8004bc2:	f7ff f97d 	bl	8003ec0 <_test_assert>
 8004bc6:	2800      	cmp	r0, #0
 8004bc8:	d1be      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    test_assert(total_size == largest_size, "unexpected heap state");
 8004bca:	9802      	ldr	r0, [sp, #8]
 8004bcc:	9b03      	ldr	r3, [sp, #12]
 8004bce:	499a      	ldr	r1, [pc, #616]	; (8004e38 <test_010_001_execute.lto_priv.159+0x318>)
 8004bd0:	1ac0      	subs	r0, r0, r3
 8004bd2:	fab0 f080 	clz	r0, r0
 8004bd6:	0940      	lsrs	r0, r0, #5
 8004bd8:	f7ff f972 	bl	8003ec0 <_test_assert>
 8004bdc:	4605      	mov	r5, r0
 8004bde:	2800      	cmp	r0, #0
 8004be0:	d1b2      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.5] Allocating then freeing in the same order.*/
  test_set_step(5);
 8004be2:	2305      	movs	r3, #5
 8004be4:	2110      	movs	r1, #16
 8004be6:	488f      	ldr	r0, [pc, #572]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004be8:	6023      	str	r3, [r4, #0]
 8004bea:	f001 f881 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004bee:	2110      	movs	r1, #16
 8004bf0:	4680      	mov	r8, r0
 8004bf2:	488c      	ldr	r0, [pc, #560]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004bf4:	f001 f87c 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004bf8:	2110      	movs	r1, #16
 8004bfa:	4607      	mov	r7, r0
 8004bfc:	4889      	ldr	r0, [pc, #548]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004bfe:	f001 f877 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004c02:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);                                 /* Does not merge.*/
 8004c04:	4640      	mov	r0, r8
 8004c06:	f7ff faf3 	bl	80041f0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges backward.*/
 8004c0a:	4638      	mov	r0, r7
 8004c0c:	f7ff faf0 	bl	80041f0 <chHeapFree>
    chHeapFree(p3);                                 /* Merges both sides.*/
 8004c10:	4630      	mov	r0, r6
 8004c12:	f7ff faed 	bl	80041f0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004c16:	462a      	mov	r2, r5
 8004c18:	4669      	mov	r1, sp
 8004c1a:	4882      	ldr	r0, [pc, #520]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c1c:	f7ff fab0 	bl	8004180 <chHeapStatus>
 8004c20:	1e42      	subs	r2, r0, #1
 8004c22:	4250      	negs	r0, r2
 8004c24:	4980      	ldr	r1, [pc, #512]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004c26:	4150      	adcs	r0, r2
 8004c28:	f7ff f94a 	bl	8003ec0 <_test_assert>
 8004c2c:	4605      	mov	r5, r0
 8004c2e:	2800      	cmp	r0, #0
 8004c30:	d18a      	bne.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.6] Allocating then freeing in reverse order.*/
  test_set_step(6);
 8004c32:	2306      	movs	r3, #6
 8004c34:	2110      	movs	r1, #16
 8004c36:	487b      	ldr	r0, [pc, #492]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c38:	6023      	str	r3, [r4, #0]
 8004c3a:	f001 f859 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004c3e:	2110      	movs	r1, #16
 8004c40:	4606      	mov	r6, r0
 8004c42:	4878      	ldr	r0, [pc, #480]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c44:	f001 f854 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004c48:	2110      	movs	r1, #16
 8004c4a:	4607      	mov	r7, r0
 8004c4c:	4875      	ldr	r0, [pc, #468]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c4e:	f001 f84f 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p3 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p3);                                 /* Merges forward.*/
 8004c52:	f7ff facd 	bl	80041f0 <chHeapFree>
    chHeapFree(p2);                                 /* Merges forward.*/
 8004c56:	4638      	mov	r0, r7
 8004c58:	f7ff faca 	bl	80041f0 <chHeapFree>
    chHeapFree(p1);                                 /* Merges forward.*/
 8004c5c:	4630      	mov	r0, r6
 8004c5e:	f7ff fac7 	bl	80041f0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004c62:	462a      	mov	r2, r5
 8004c64:	4669      	mov	r1, sp
 8004c66:	486f      	ldr	r0, [pc, #444]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c68:	f7ff fa8a 	bl	8004180 <chHeapStatus>
 8004c6c:	1e43      	subs	r3, r0, #1
 8004c6e:	4258      	negs	r0, r3
 8004c70:	496d      	ldr	r1, [pc, #436]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004c72:	4158      	adcs	r0, r3
 8004c74:	f7ff f924 	bl	8003ec0 <_test_assert>
 8004c78:	4605      	mov	r5, r0
 8004c7a:	2800      	cmp	r0, #0
 8004c7c:	f47f af64 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.7] Small fragments handling. Checking the behavior when
     allocating blocks with size not multiple of alignment unit.*/
  test_set_step(7);
 8004c80:	2307      	movs	r3, #7
 8004c82:	2111      	movs	r1, #17
 8004c84:	4867      	ldr	r0, [pc, #412]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c86:	6023      	str	r3, [r4, #0]
 8004c88:	f001 f832 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004c8c:	2110      	movs	r1, #16
 8004c8e:	4606      	mov	r6, r0
 8004c90:	4864      	ldr	r0, [pc, #400]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004c92:	f001 f82d 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004c96:	4607      	mov	r7, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE + 1);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 8004c98:	4630      	mov	r0, r6
 8004c9a:	f7ff faa9 	bl	80041f0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8004c9e:	462a      	mov	r2, r5
 8004ca0:	4669      	mov	r1, sp
 8004ca2:	4860      	ldr	r0, [pc, #384]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004ca4:	f7ff fa6c 	bl	8004180 <chHeapStatus>
 8004ca8:	f1a0 0802 	sub.w	r8, r0, #2
 8004cac:	f1d8 0000 	rsbs	r0, r8, #0
 8004cb0:	4962      	ldr	r1, [pc, #392]	; (8004e3c <test_010_001_execute.lto_priv.159+0x31c>)
 8004cb2:	eb40 0008 	adc.w	r0, r0, r8
 8004cb6:	f7ff f903 	bl	8003ec0 <_test_assert>
 8004cba:	4605      	mov	r5, r0
 8004cbc:	2800      	cmp	r0, #0
 8004cbe:	f47f af43 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
 8004cc2:	2110      	movs	r1, #16
 8004cc4:	4857      	ldr	r0, [pc, #348]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004cc6:	f001 f813 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8004cca:	462a      	mov	r2, r5
 8004ccc:	4606      	mov	r6, r0
 8004cce:	4669      	mov	r1, sp
 8004cd0:	4854      	ldr	r0, [pc, #336]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004cd2:	f7ff fa55 	bl	8004180 <chHeapStatus>
 8004cd6:	2801      	cmp	r0, #1
 8004cd8:	f000 80a0 	beq.w	8004e1c <test_010_001_execute.lto_priv.159+0x2fc>
 8004cdc:	4851      	ldr	r0, [pc, #324]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004cde:	4669      	mov	r1, sp
 8004ce0:	2200      	movs	r2, #0
 8004ce2:	f7ff fa4d 	bl	8004180 <chHeapStatus>
 8004ce6:	f1a0 0c02 	sub.w	ip, r0, #2
 8004cea:	f1dc 0000 	rsbs	r0, ip, #0
 8004cee:	eb40 000c 	adc.w	r0, r0, ip
 8004cf2:	494d      	ldr	r1, [pc, #308]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004cf4:	f7ff f8e4 	bl	8003ec0 <_test_assert>
 8004cf8:	4605      	mov	r5, r0
 8004cfa:	2800      	cmp	r0, #0
 8004cfc:	f47f af24 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
                (chHeapStatus(&test_heap, &n, NULL) == 2), "heap fragmented");
    chHeapFree(p2);
 8004d00:	4638      	mov	r0, r7
 8004d02:	f7ff fa75 	bl	80041f0 <chHeapFree>
    chHeapFree(p1);
 8004d06:	4630      	mov	r0, r6
 8004d08:	f7ff fa72 	bl	80041f0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004d0c:	462a      	mov	r2, r5
 8004d0e:	4669      	mov	r1, sp
 8004d10:	4844      	ldr	r0, [pc, #272]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d12:	f7ff fa35 	bl	8004180 <chHeapStatus>
 8004d16:	f100 3eff 	add.w	lr, r0, #4294967295
 8004d1a:	f1de 0000 	rsbs	r0, lr, #0
 8004d1e:	4942      	ldr	r1, [pc, #264]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004d20:	eb40 000e 	adc.w	r0, r0, lr
 8004d24:	f7ff f8cc 	bl	8003ec0 <_test_assert>
 8004d28:	4605      	mov	r5, r0
 8004d2a:	2800      	cmp	r0, #0
 8004d2c:	f47f af0c 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.8] Skipping a fragment, the first fragment in the list is
     too small so the allocator must pick the second one.*/
  test_set_step(8);
 8004d30:	2308      	movs	r3, #8
 8004d32:	2110      	movs	r1, #16
 8004d34:	483b      	ldr	r0, [pc, #236]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d36:	6023      	str	r3, [r4, #0]
 8004d38:	f000 ffda 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004d3c:	2110      	movs	r1, #16
 8004d3e:	4607      	mov	r7, r0
 8004d40:	4838      	ldr	r0, [pc, #224]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d42:	4c37      	ldr	r4, [pc, #220]	; (8004e20 <test_010_001_execute.lto_priv.159+0x300>)
 8004d44:	f000 ffd4 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
 8004d48:	4606      	mov	r6, r0
  {
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    p2 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    chHeapFree(p1);
 8004d4a:	4638      	mov	r0, r7
 8004d4c:	f7ff fa50 	bl	80041f0 <chHeapFree>
    test_assert( chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
 8004d50:	462a      	mov	r2, r5
 8004d52:	4669      	mov	r1, sp
 8004d54:	4833      	ldr	r0, [pc, #204]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d56:	f7ff fa13 	bl	8004180 <chHeapStatus>
 8004d5a:	1e87      	subs	r7, r0, #2
 8004d5c:	4278      	negs	r0, r7
 8004d5e:	4937      	ldr	r1, [pc, #220]	; (8004e3c <test_010_001_execute.lto_priv.159+0x31c>)
 8004d60:	4178      	adcs	r0, r7
 8004d62:	f7ff f8ad 	bl	8003ec0 <_test_assert>
 8004d66:	4605      	mov	r5, r0
 8004d68:	2800      	cmp	r0, #0
 8004d6a:	f47f aeed 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
 8004d6e:	2120      	movs	r1, #32
 8004d70:	482c      	ldr	r0, [pc, #176]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d72:	f000 ffbd 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE * 2); /* Skips first fragment.*/
    chHeapFree(p1);
 8004d76:	f7ff fa3b 	bl	80041f0 <chHeapFree>
    chHeapFree(p2);
 8004d7a:	4630      	mov	r0, r6
 8004d7c:	f7ff fa38 	bl	80041f0 <chHeapFree>
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004d80:	462a      	mov	r2, r5
 8004d82:	4669      	mov	r1, sp
 8004d84:	4827      	ldr	r0, [pc, #156]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004d86:	f7ff f9fb 	bl	8004180 <chHeapStatus>
 8004d8a:	1e45      	subs	r5, r0, #1
 8004d8c:	4268      	negs	r0, r5
 8004d8e:	4926      	ldr	r1, [pc, #152]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004d90:	4168      	adcs	r0, r5
 8004d92:	f7ff f895 	bl	8003ec0 <_test_assert>
 8004d96:	4602      	mov	r2, r0
 8004d98:	2800      	cmp	r0, #0
 8004d9a:	f47f aed5 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 8004d9e:	2309      	movs	r3, #9
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8004da0:	4669      	mov	r1, sp
 8004da2:	4820      	ldr	r0, [pc, #128]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
    chHeapFree(p2);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
  }

  /* [10.1.9] Allocating the whole available space.*/
  test_set_step(9);
 8004da4:	6023      	str	r3, [r4, #0]
  {
    (void)chHeapStatus(&test_heap, &n, NULL);
 8004da6:	f7ff f9eb 	bl	8004180 <chHeapStatus>
 8004daa:	9900      	ldr	r1, [sp, #0]
 8004dac:	481d      	ldr	r0, [pc, #116]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004dae:	f000 ff9f 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
    p1 = chHeapAlloc(&test_heap, n);
    test_assert(p1 != NULL, "allocation failed");
 8004db2:	4606      	mov	r6, r0
 8004db4:	3000      	adds	r0, #0
 8004db6:	491e      	ldr	r1, [pc, #120]	; (8004e30 <test_010_001_execute.lto_priv.159+0x310>)
 8004db8:	bf18      	it	ne
 8004dba:	2001      	movne	r0, #1
 8004dbc:	f7ff f880 	bl	8003ec0 <_test_assert>
 8004dc0:	4601      	mov	r1, r0
 8004dc2:	2800      	cmp	r0, #0
 8004dc4:	f47f aec0 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    test_assert(chHeapStatus(&test_heap, NULL, NULL) == 0, "not empty");
 8004dc8:	460a      	mov	r2, r1
 8004dca:	4816      	ldr	r0, [pc, #88]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
 8004dcc:	f7ff f9d8 	bl	8004180 <chHeapStatus>
 8004dd0:	491b      	ldr	r1, [pc, #108]	; (8004e40 <test_010_001_execute.lto_priv.159+0x320>)
 8004dd2:	fab0 f080 	clz	r0, r0
 8004dd6:	0940      	lsrs	r0, r0, #5
 8004dd8:	f7ff f872 	bl	8003ec0 <_test_assert>
 8004ddc:	4605      	mov	r5, r0
 8004dde:	2800      	cmp	r0, #0
 8004de0:	f47f aeb2 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    chHeapFree(p1);
 8004de4:	4630      	mov	r0, r6
 8004de6:	f7ff fa03 	bl	80041f0 <chHeapFree>

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004dea:	4669      	mov	r1, sp
 8004dec:	462a      	mov	r2, r5
    chHeapFree(p1);
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8004dee:	230a      	movs	r3, #10
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004df0:	480c      	ldr	r0, [pc, #48]	; (8004e24 <test_010_001_execute.lto_priv.159+0x304>)
    chHeapFree(p1);
  }

  /* [10.1.10] Testing final conditions. The heap geometry must be the
     same than the one registered at beginning.*/
  test_set_step(10);
 8004df2:	6023      	str	r3, [r4, #0]
  {
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 1, "heap fragmented");
 8004df4:	f7ff f9c4 	bl	8004180 <chHeapStatus>
 8004df8:	1e42      	subs	r2, r0, #1
 8004dfa:	4250      	negs	r0, r2
 8004dfc:	4150      	adcs	r0, r2
 8004dfe:	490a      	ldr	r1, [pc, #40]	; (8004e28 <test_010_001_execute.lto_priv.159+0x308>)
 8004e00:	f7ff f85e 	bl	8003ec0 <_test_assert>
 8004e04:	2800      	cmp	r0, #0
 8004e06:	f47f ae9f 	bne.w	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    test_assert(n == sz, "size changed");
 8004e0a:	e89d 0009 	ldmia.w	sp, {r0, r3}
 8004e0e:	1ac3      	subs	r3, r0, r3
 8004e10:	4258      	negs	r0, r3
 8004e12:	490c      	ldr	r1, [pc, #48]	; (8004e44 <test_010_001_execute.lto_priv.159+0x324>)
 8004e14:	4158      	adcs	r0, r3
 8004e16:	f7ff f853 	bl	8003ec0 <_test_assert>
 8004e1a:	e695      	b.n	8004b48 <test_010_001_execute.lto_priv.159+0x28>
    chHeapFree(p1);
    test_assert(chHeapStatus(&test_heap, &n, NULL) == 2, "invalid state");
    p1 = chHeapAlloc(&test_heap, ALLOC_SIZE);
    /* Note, the first situation happens when the alignment size is smaller
       than the header size, the second in the other cases.*/
    test_assert((chHeapStatus(&test_heap, &n, NULL) == 1) ||
 8004e1c:	2001      	movs	r0, #1
 8004e1e:	e768      	b.n	8004cf2 <test_010_001_execute.lto_priv.159+0x1d2>
 8004e20:	2000133c 	.word	0x2000133c
 8004e24:	20001390 	.word	0x20001390
 8004e28:	08007300 	.word	0x08007300
 8004e2c:	0800737c 	.word	0x0800737c
 8004e30:	08007368 	.word	0x08007368
 8004e34:	08007394 	.word	0x08007394
 8004e38:	080073a8 	.word	0x080073a8
 8004e3c:	080073c0 	.word	0x080073c0
 8004e40:	0800702c 	.word	0x0800702c
 8004e44:	080073d0 	.word	0x080073d0
 8004e48:	f3af 8000 	nop.w
 8004e4c:	f3af 8000 	nop.w

08004e50 <test_009_003_execute.lto_priv.157>:

static void test_009_003_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_003_execute(void) {
 8004e50:	b508      	push	{r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8004e52:	4b07      	ldr	r3, [pc, #28]	; (8004e70 <test_009_003_execute.lto_priv.157+0x20>)
 8004e54:	2201      	movs	r2, #1
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8004e56:	f44f 707a 	mov.w	r0, #1000	; 0x3e8

static void test_009_003_execute(void) {

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
 8004e5a:	601a      	str	r2, [r3, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8004e5c:	f001 f8c8 	bl	8005ff0 <chGuardedPoolAllocTimeout.constprop.18>
 8004e60:	4904      	ldr	r1, [pc, #16]	; (8004e74 <test_009_003_execute.lto_priv.157+0x24>)
 8004e62:	fab0 f080 	clz	r0, r0
  }
}
 8004e66:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  /* [9.3.1] Trying to allocate with 100mS timeout, must fail because
     the pool is empty.*/
  test_set_step(1);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, MS2ST(100)) == NULL, "list not empty");
 8004e6a:	0940      	lsrs	r0, r0, #5
 8004e6c:	f7ff b828 	b.w	8003ec0 <_test_assert>
 8004e70:	2000133c 	.word	0x2000133c
 8004e74:	08007254 	.word	0x08007254
 8004e78:	f3af 8000 	nop.w
 8004e7c:	f3af 8000 	nop.w

08004e80 <test_009_002_execute.lto_priv.155>:

static void test_009_002_setup(void) {
  chGuardedPoolObjectInit(&gmp1, sizeof (uint32_t));
}

static void test_009_002_execute(void) {
 8004e80:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  unsigned i;

  /* [9.2.1] Adding the objects to the pool using
     chGuardedPoolLoadArray().*/
  test_set_step(1);
 8004e84:	4f35      	ldr	r7, [pc, #212]	; (8004f5c <test_009_002_execute.lto_priv.155+0xdc>)
 8004e86:	4c36      	ldr	r4, [pc, #216]	; (8004f60 <test_009_002_execute.lto_priv.155+0xe0>)
 8004e88:	4d36      	ldr	r5, [pc, #216]	; (8004f64 <test_009_002_execute.lto_priv.155+0xe4>)
 8004e8a:	2301      	movs	r3, #1
 8004e8c:	603b      	str	r3, [r7, #0]
 8004e8e:	2604      	movs	r6, #4
 8004e90:	f04f 0920 	mov.w	r9, #32
 8004e94:	f04f 0800 	mov.w	r8, #0
 8004e98:	f389 8811 	msr	BASEPRI, r9
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8004e9c:	68eb      	ldr	r3, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8004e9e:	4831      	ldr	r0, [pc, #196]	; (8004f64 <test_009_002_execute.lto_priv.155+0xe4>)
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8004ea0:	6023      	str	r3, [r4, #0]
  mp->next = php;
 8004ea2:	60ec      	str	r4, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8004ea4:	f000 fbcc 	bl	8005640 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8004ea8:	f000 f9ea 	bl	8005280 <chSchRescheduleS>
 8004eac:	f388 8811 	msr	BASEPRI, r8
  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8004eb0:	692b      	ldr	r3, [r5, #16]
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8004eb2:	3e01      	subs	r6, #1
    chGuardedPoolAdd(gmp, p);
    /*lint -save -e9087 [11.3] Safe cast.*/
    p = (void *)(((uint8_t *)p) + gmp->pool.object_size);
 8004eb4:	441c      	add	r4, r3
 */
void chGuardedPoolLoadArray(guarded_memory_pool_t *gmp, void *p, size_t n) {

  chDbgCheck((gmp != NULL) && (n != 0U));

  while (n != 0U) {
 8004eb6:	d1ef      	bne.n	8004e98 <test_009_002_execute.lto_priv.155+0x18>
  {
    chGuardedPoolLoadArray(&gmp1, objects, MEMORY_POOL_SIZE);
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
 8004eb8:	2302      	movs	r3, #2
 8004eba:	603b      	str	r3, [r7, #0]
 8004ebc:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8004ebe:	2000      	movs	r0, #0
 8004ec0:	f001 f896 	bl	8005ff0 <chGuardedPoolAllocTimeout.constprop.18>
 8004ec4:	3000      	adds	r0, #0
 8004ec6:	bf18      	it	ne
 8004ec8:	2001      	movne	r0, #1
 8004eca:	4927      	ldr	r1, [pc, #156]	; (8004f68 <test_009_002_execute.lto_priv.155+0xe8>)
 8004ecc:	f7fe fff8 	bl	8003ec0 <_test_assert>
 8004ed0:	2800      	cmp	r0, #0
 8004ed2:	d141      	bne.n	8004f58 <test_009_002_execute.lto_priv.155+0xd8>
  }

  /* [9.2.2] Emptying the pool using chGuardedPoolAllocTimeout().*/
  test_set_step(2);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004ed4:	3c01      	subs	r4, #1
 8004ed6:	d1f2      	bne.n	8004ebe <test_009_002_execute.lto_priv.155+0x3e>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.3] Now must be empty.*/
  test_set_step(3);
 8004ed8:	2303      	movs	r3, #3
 8004eda:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8004edc:	f001 f888 	bl	8005ff0 <chGuardedPoolAllocTimeout.constprop.18>
 8004ee0:	4922      	ldr	r1, [pc, #136]	; (8004f6c <test_009_002_execute.lto_priv.155+0xec>)
 8004ee2:	fab0 f080 	clz	r0, r0
 8004ee6:	0940      	lsrs	r0, r0, #5
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.3] Now must be empty.*/
  test_set_step(3);
 8004ee8:	f8df 8070 	ldr.w	r8, [pc, #112]	; 8004f5c <test_009_002_execute.lto_priv.155+0xdc>
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8004eec:	f7fe ffe8 	bl	8003ec0 <_test_assert>
 8004ef0:	bb90      	cbnz	r0, 8004f58 <test_009_002_execute.lto_priv.155+0xd8>
 8004ef2:	4e1b      	ldr	r6, [pc, #108]	; (8004f60 <test_009_002_execute.lto_priv.155+0xe0>)
  }

  /* [9.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
 8004ef4:	2304      	movs	r3, #4
 8004ef6:	f8c8 3000 	str.w	r3, [r8]
 8004efa:	f106 0910 	add.w	r9, r6, #16
 8004efe:	f04f 0820 	mov.w	r8, #32
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      chGuardedPoolFree(&gmp1, &objects[i]);
 8004f02:	4633      	mov	r3, r6
 8004f04:	f388 8811 	msr	BASEPRI, r8
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8004f08:	68ea      	ldr	r2, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8004f0a:	4816      	ldr	r0, [pc, #88]	; (8004f64 <test_009_002_execute.lto_priv.155+0xe4>)
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 8004f0c:	f846 2b04 	str.w	r2, [r6], #4
  mp->next = php;
 8004f10:	60eb      	str	r3, [r5, #12]
 * @iclass
 */
void chGuardedPoolFreeI(guarded_memory_pool_t *gmp, void *objp) {

  chPoolFreeI(&gmp->pool, objp);
  chSemSignalI(&gmp->sem);
 8004f12:	f000 fb95 	bl	8005640 <chSemSignalI>
 */
void chGuardedPoolFree(guarded_memory_pool_t *gmp, void *objp) {

  chSysLock();
  chGuardedPoolFreeI(gmp, objp);
  chSchRescheduleS();
 8004f16:	f000 f9b3 	bl	8005280 <chSchRescheduleS>
 8004f1a:	f384 8811 	msr	BASEPRI, r4

  /* [9.2.4] Adding the objects to the pool using
     chGuardedPoolFree().*/
  test_set_step(4);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004f1e:	454e      	cmp	r6, r9
 8004f20:	d1ef      	bne.n	8004f02 <test_009_002_execute.lto_priv.155+0x82>
      chGuardedPoolFree(&gmp1, &objects[i]);
  }

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
 8004f22:	2305      	movs	r3, #5
 8004f24:	603b      	str	r3, [r7, #0]
 8004f26:	2404      	movs	r4, #4
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
 8004f28:	2000      	movs	r0, #0
 8004f2a:	f001 f861 	bl	8005ff0 <chGuardedPoolAllocTimeout.constprop.18>
 8004f2e:	3000      	adds	r0, #0
 8004f30:	bf18      	it	ne
 8004f32:	2001      	movne	r0, #1
 8004f34:	490c      	ldr	r1, [pc, #48]	; (8004f68 <test_009_002_execute.lto_priv.155+0xe8>)
 8004f36:	f7fe ffc3 	bl	8003ec0 <_test_assert>
 8004f3a:	b968      	cbnz	r0, 8004f58 <test_009_002_execute.lto_priv.155+0xd8>

  /* [9.2.5] Emptying the pool using chGuardedPoolAllocTimeout()
     again.*/
  test_set_step(5);
  {
    for (i = 0; i < MEMORY_POOL_SIZE; i++)
 8004f3c:	3c01      	subs	r4, #1
 8004f3e:	d1f3      	bne.n	8004f28 <test_009_002_execute.lto_priv.155+0xa8>
      test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) != NULL, "list empty");
  }

  /* [9.2.6] Now must be empty again.*/
  test_set_step(6);
 8004f40:	2306      	movs	r3, #6
 8004f42:	603b      	str	r3, [r7, #0]
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8004f44:	f001 f854 	bl	8005ff0 <chGuardedPoolAllocTimeout.constprop.18>
 8004f48:	4908      	ldr	r1, [pc, #32]	; (8004f6c <test_009_002_execute.lto_priv.155+0xec>)
 8004f4a:	fab0 f080 	clz	r0, r0
  }
}
 8004f4e:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  }

  /* [9.2.6] Now must be empty again.*/
  test_set_step(6);
  {
    test_assert(chGuardedPoolAllocTimeout(&gmp1, TIME_IMMEDIATE) == NULL, "list not empty");
 8004f52:	0940      	lsrs	r0, r0, #5
 8004f54:	f7fe bfb4 	b.w	8003ec0 <_test_assert>
 8004f58:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8004f5c:	2000133c 	.word	0x2000133c
 8004f60:	20001380 	.word	0x20001380
 8004f64:	20000888 	.word	0x20000888
 8004f68:	08007248 	.word	0x08007248
 8004f6c:	08007254 	.word	0x08007254

08004f70 <bmk_thread3.lto_priv.81>:
}
#endif

static THD_FUNCTION(bmk_thread3, p) {

  chThdExit((msg_t)p);
 8004f70:	f000 bb9e 	b.w	80056b0 <chThdExit>
 8004f74:	f3af 8000 	nop.w
 8004f78:	f3af 8000 	nop.w
 8004f7c:	f3af 8000 	nop.w

08004f80 <wakeup.lto_priv.183>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 8004f80:	b410      	push	{r4}
 8004f82:	2320      	movs	r3, #32
 8004f84:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->state) {
 8004f88:	f890 3020 	ldrb.w	r3, [r0, #32]
 8004f8c:	2b07      	cmp	r3, #7
 8004f8e:	d80e      	bhi.n	8004fae <wakeup.lto_priv.183+0x2e>
 8004f90:	e8df f003 	tbb	[pc, r3]
 8004f94:	240d0d28 	.word	0x240d0d28
 8004f98:	080d0408 	.word	0x080d0408
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->u.wtsemp);
 8004f9c:	6a42      	ldr	r2, [r0, #36]	; 0x24
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->cnt++;
 8004f9e:	6893      	ldr	r3, [r2, #8]
 8004fa0:	3301      	adds	r3, #1
 8004fa2:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 8004fa4:	e890 000c 	ldmia.w	r0, {r2, r3}
 8004fa8:	601a      	str	r2, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 8004faa:	6802      	ldr	r2, [r0, #0]
 8004fac:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8004fae:	f04f 34ff 	mov.w	r4, #4294967295
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004fb2:	2200      	movs	r2, #0
 8004fb4:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8004fb6:	4b0e      	ldr	r3, [pc, #56]	; (8004ff0 <wakeup.lto_priv.183+0x70>)
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
 8004fb8:	6244      	str	r4, [r0, #36]	; 0x24
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8004fba:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 8004fbe:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8004fc0:	689a      	ldr	r2, [r3, #8]
 8004fc2:	428a      	cmp	r2, r1
 8004fc4:	d2fb      	bcs.n	8004fbe <wakeup.lto_priv.183+0x3e>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8004fc6:	685a      	ldr	r2, [r3, #4]
 8004fc8:	6042      	str	r2, [r0, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8004fca:	6003      	str	r3, [r0, #0]
 8004fcc:	2100      	movs	r1, #0
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8004fce:	6010      	str	r0, [r2, #0]
  cp->queue.prev             = tp;
 8004fd0:	6058      	str	r0, [r3, #4]
 8004fd2:	f381 8811 	msr	BASEPRI, r1
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8004fd6:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004fda:	4770      	bx	lr
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->u.wttrp = NULL;
 8004fdc:	6a43      	ldr	r3, [r0, #36]	; 0x24
 8004fde:	2200      	movs	r2, #0
 8004fe0:	601a      	str	r2, [r3, #0]
 8004fe2:	e7e4      	b.n	8004fae <wakeup.lto_priv.183+0x2e>
 8004fe4:	2300      	movs	r3, #0
 8004fe6:	f383 8811 	msr	BASEPRI, r3
    break;
  }
  tp->u.rdymsg = MSG_TIMEOUT;
  (void) chSchReadyI(tp);
  chSysUnlockFromISR();
}
 8004fea:	f85d 4b04 	ldr.w	r4, [sp], #4
 8004fee:	4770      	bx	lr
 8004ff0:	200013b0 	.word	0x200013b0
 8004ff4:	f3af 8000 	nop.w
 8004ff8:	f3af 8000 	nop.w
 8004ffc:	f3af 8000 	nop.w

08005000 <_idle_thread.lto_priv.83>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 8005000:	e7fe      	b.n	8005000 <_idle_thread.lto_priv.83>
 8005002:	bf00      	nop
 8005004:	f3af 8000 	nop.w
 8005008:	f3af 8000 	nop.w
 800500c:	f3af 8000 	nop.w

08005010 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8005010:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
 8005012:	6804      	ldr	r4, [r0, #0]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005014:	42a0      	cmp	r0, r4
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8005016:	4606      	mov	r6, r0
 8005018:	460d      	mov	r5, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 800501a:	d00d      	beq.n	8005038 <chEvtBroadcastFlagsI+0x28>
  /*lint -restore*/
    elp->flags |= flags;
 800501c:	68e3      	ldr	r3, [r4, #12]
 800501e:	432b      	orrs	r3, r5
 8005020:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8005022:	b115      	cbz	r5, 800502a <chEvtBroadcastFlagsI+0x1a>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
 8005024:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8005026:	4213      	tst	r3, r2
 8005028:	d003      	beq.n	8005032 <chEvtBroadcastFlagsI+0x22>
        ((elp->flags & elp->wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->listener, elp->events);
 800502a:	6860      	ldr	r0, [r4, #4]
 800502c:	68a1      	ldr	r1, [r4, #8]
 800502e:	f7ff f977 	bl	8004320 <chEvtSignalI>
    }
    elp = elp->next;
 8005032:	6824      	ldr	r4, [r4, #0]
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8005034:	42a6      	cmp	r6, r4
 8005036:	d1f1      	bne.n	800501c <chEvtBroadcastFlagsI+0xc>
 8005038:	bd70      	pop	{r4, r5, r6, pc}
 800503a:	bf00      	nop
 800503c:	f3af 8000 	nop.w

08005040 <chEvtAddEvents>:
 8005040:	2320      	movs	r3, #32
 8005042:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
eventmask_t chEvtAddEvents(eventmask_t events) {

  chSysLock();
  currp->epending |= events;
 8005046:	4b04      	ldr	r3, [pc, #16]	; (8005058 <chEvtAddEvents+0x18>)
 8005048:	699a      	ldr	r2, [r3, #24]
 800504a:	6b53      	ldr	r3, [r2, #52]	; 0x34
 800504c:	4318      	orrs	r0, r3
 800504e:	6350      	str	r0, [r2, #52]	; 0x34
 8005050:	2300      	movs	r3, #0
 8005052:	f383 8811 	msr	BASEPRI, r3
  events = currp->epending;
  chSysUnlock();

  return events;
}
 8005056:	4770      	bx	lr
 8005058:	200013b0 	.word	0x200013b0
 800505c:	f3af 8000 	nop.w

08005060 <chEvtUnregister>:
 8005060:	2320      	movs	r3, #32
 8005062:	f383 8811 	msr	BASEPRI, r3
  event_listener_t *p;

  chDbgCheck((esp != NULL) && (elp != NULL));

  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
 8005066:	4602      	mov	r2, r0
 8005068:	e002      	b.n	8005070 <chEvtUnregister+0x10>
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
  /*lint -restore*/
    if (p->next == elp) {
 800506a:	428b      	cmp	r3, r1
 800506c:	d007      	beq.n	800507e <chEvtUnregister+0x1e>
 800506e:	461a      	mov	r2, r3
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  p = (event_listener_t *)esp;
  /*lint -restore*/
  chSysLock();
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (p->next != (event_listener_t *)esp) {
 8005070:	6813      	ldr	r3, [r2, #0]
 8005072:	4283      	cmp	r3, r0
 8005074:	d1f9      	bne.n	800506a <chEvtUnregister+0xa>
 8005076:	2300      	movs	r3, #0
 8005078:	f383 8811 	msr	BASEPRI, r3
 800507c:	4770      	bx	lr
  /*lint -restore*/
    if (p->next == elp) {
      p->next = elp->next;
 800507e:	680b      	ldr	r3, [r1, #0]
 8005080:	6013      	str	r3, [r2, #0]
 8005082:	2300      	movs	r3, #0
 8005084:	f383 8811 	msr	BASEPRI, r3
 8005088:	4770      	bx	lr
 800508a:	bf00      	nop
 800508c:	f3af 8000 	nop.w

08005090 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005090:	4b0e      	ldr	r3, [pc, #56]	; (80050cc <chTMStopMeasurementX+0x3c>)
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8005092:	490f      	ldr	r1, [pc, #60]	; (80050d0 <chTMStopMeasurementX+0x40>)
 8005094:	685a      	ldr	r2, [r3, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8005096:	6883      	ldr	r3, [r0, #8]
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8005098:	b4f0      	push	{r4, r5, r6, r7}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 800509a:	6f4f      	ldr	r7, [r1, #116]	; 0x74
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
 800509c:	6841      	ldr	r1, [r0, #4]

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 800509e:	68c6      	ldr	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80050a0:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80050a4:	1ad3      	subs	r3, r2, r3
 80050a6:	1bdb      	subs	r3, r3, r7
  tmp->cumulative += (rttime_t)tmp->last;
 80050a8:	18e4      	adds	r4, r4, r3
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
 80050aa:	6802      	ldr	r2, [r0, #0]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 80050ac:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 80050ae:	f145 0500 	adc.w	r5, r5, #0
  if (tmp->last > tmp->worst) {
 80050b2:	428b      	cmp	r3, r1

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80050b4:	f106 0601 	add.w	r6, r6, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
 80050b8:	bf88      	it	hi
 80050ba:	6043      	strhi	r3, [r0, #4]
  }
  if (tmp->last < tmp->best) {
 80050bc:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 80050be:	60c6      	str	r6, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 80050c0:	e9c0 4504 	strd	r4, r5, [r0, #16]
  if (tmp->last > tmp->worst) {
    tmp->worst = tmp->last;
  }
  if (tmp->last < tmp->best) {
    tmp->best = tmp->last;
 80050c4:	bf38      	it	cc
 80050c6:	6003      	strcc	r3, [r0, #0]
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
}
 80050c8:	bcf0      	pop	{r4, r5, r6, r7}
 80050ca:	4770      	bx	lr
 80050cc:	e0001000 	.word	0xe0001000
 80050d0:	200013b0 	.word	0x200013b0
 80050d4:	f3af 8000 	nop.w
 80050d8:	f3af 8000 	nop.w
 80050dc:	f3af 8000 	nop.w

080050e0 <chThdYield>:
 * @details Yields the CPU control to the next thread in the ready list with
 *          equal priority, if any.
 *
 * @api
 */
void chThdYield(void) {
 80050e0:	b570      	push	{r4, r5, r6, lr}
 80050e2:	2320      	movs	r3, #32
 80050e4:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80050e8:	4a12      	ldr	r2, [pc, #72]	; (8005134 <chThdYield+0x54>)
 80050ea:	6810      	ldr	r0, [r2, #0]
 80050ec:	6994      	ldr	r4, [r2, #24]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80050ee:	6883      	ldr	r3, [r0, #8]
 */
static inline bool chSchCanYieldS(void) {

  chDbgCheckClassS();

  return firstprio(&ch.rlist.queue) >= currp->prio;
 80050f0:	68a1      	ldr	r1, [r4, #8]
 */
static inline void chSchDoYieldS(void) {

  chDbgCheckClassS();

  if (chSchCanYieldS()) {
 80050f2:	428b      	cmp	r3, r1
 80050f4:	d203      	bcs.n	80050fe <chThdYield+0x1e>
 80050f6:	2300      	movs	r3, #0
 80050f8:	f383 8811 	msr	BASEPRI, r3
 80050fc:	bd70      	pop	{r4, r5, r6, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80050fe:	6803      	ldr	r3, [r0, #0]
 8005100:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005102:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005104:	2500      	movs	r5, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8005106:	605a      	str	r2, [r3, #4]
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005108:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleBehind(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 800510c:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800510e:	f884 5020 	strb.w	r5, [r4, #32]
 8005112:	e000      	b.n	8005116 <chThdYield+0x36>
 8005114:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
 8005116:	689a      	ldr	r2, [r3, #8]
 8005118:	4291      	cmp	r1, r2
 800511a:	d9fb      	bls.n	8005114 <chThdYield+0x34>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800511c:	685a      	ldr	r2, [r3, #4]
 800511e:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8005120:	6023      	str	r3, [r4, #0]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005122:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005124:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8005126:	605c      	str	r4, [r3, #4]

  /* Placing in ready list behind peers.*/
  otp = chSchReadyI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005128:	f7fb f8d4 	bl	80002d4 <_port_switch>
 800512c:	2300      	movs	r3, #0
 800512e:	f383 8811 	msr	BASEPRI, r3
 8005132:	bd70      	pop	{r4, r5, r6, pc}
 8005134:	200013b0 	.word	0x200013b0
 8005138:	f3af 8000 	nop.w
 800513c:	f3af 8000 	nop.w

08005140 <chThdRelease>:
 8005140:	2220      	movs	r2, #32
 8005142:	f382 8811 	msr	BASEPRI, r2
 */
void chThdRelease(thread_t *tp) {

  chSysLock();
  chDbgAssert(tp->refs > (trefs_t)0, "not referenced");
  tp->refs--;
 8005146:	f890 3022 	ldrb.w	r3, [r0, #34]	; 0x22
 800514a:	3b01      	subs	r3, #1
 800514c:	f880 3022 	strb.w	r3, [r0, #34]	; 0x22

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
 8005150:	6a03      	ldr	r3, [r0, #32]
 8005152:	f003 13ff 	and.w	r3, r3, #16711935	; 0xff00ff
 8005156:	2b0f      	cmp	r3, #15
 8005158:	d003      	beq.n	8005162 <chThdRelease+0x22>
 800515a:	2300      	movs	r3, #0
 800515c:	f383 8811 	msr	BASEPRI, r3
 8005160:	4770      	bx	lr
    REG_REMOVE(tp);
 8005162:	6943      	ldr	r3, [r0, #20]
 8005164:	6901      	ldr	r1, [r0, #16]
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8005166:	b410      	push	{r4}

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator.*/
  if ((tp->refs == (trefs_t)0) && (tp->state == CH_STATE_FINAL)) {
    REG_REMOVE(tp);
 8005168:	6119      	str	r1, [r3, #16]
 800516a:	6904      	ldr	r4, [r0, #16]
 800516c:	2100      	movs	r1, #0
 800516e:	6163      	str	r3, [r4, #20]
 8005170:	f381 8811 	msr	BASEPRI, r1
    chSysUnlock();

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
 8005174:	f890 3021 	ldrb.w	r3, [r0, #33]	; 0x21
 8005178:	f003 0303 	and.w	r3, r3, #3
 800517c:	2b01      	cmp	r3, #1
 800517e:	d00d      	beq.n	800519c <chThdRelease+0x5c>
 8005180:	2b02      	cmp	r3, #2
 8005182:	d108      	bne.n	8005196 <chThdRelease+0x56>
      chHeapFree(chThdGetWorkingAreaX(tp));
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
      chPoolFree(tp->mpool, chThdGetWorkingAreaX(tp));
 8005184:	6c03      	ldr	r3, [r0, #64]	; 0x40
 8005186:	69c0      	ldr	r0, [r0, #28]
 8005188:	f382 8811 	msr	BASEPRI, r2
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->next = mp->next;
 800518c:	681a      	ldr	r2, [r3, #0]
 800518e:	6002      	str	r2, [r0, #0]
  mp->next = php;
 8005190:	6018      	str	r0, [r3, #0]
 8005192:	f381 8811 	msr	BASEPRI, r1
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 8005196:	f85d 4b04 	ldr.w	r4, [sp], #4
 800519a:	4770      	bx	lr

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 800519c:	69c0      	ldr	r0, [r0, #28]
    }
#endif /* CH_CFG_USE_DYNAMIC == TRUE */
    return;
  }
  chSysUnlock();
}
 800519e:	f85d 4b04 	ldr.w	r4, [sp], #4

#if CH_CFG_USE_DYNAMIC == TRUE
    switch (tp->flags & CH_FLAG_MODE_MASK) {
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
      chHeapFree(chThdGetWorkingAreaX(tp));
 80051a2:	f7ff b825 	b.w	80041f0 <chHeapFree>
 80051a6:	bf00      	nop
 80051a8:	f3af 8000 	nop.w
 80051ac:	f3af 8000 	nop.w

080051b0 <chThdCreateSuspendedI>:
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 80051b0:	6883      	ldr	r3, [r0, #8]
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80051b2:	6841      	ldr	r1, [r0, #4]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 80051b4:	f8d0 c00c 	ldr.w	ip, [r0, #12]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80051b8:	4a1e      	ldr	r2, [pc, #120]	; (8005234 <chThdCreateSuspendedI+0x84>)
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @iclass
 */
thread_t *chThdCreateSuspendedI(const thread_descriptor_t *tdp) {
 80051ba:	e92d 04f0 	stmdb	sp!, {r4, r5, r6, r7, sl}
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80051be:	6904      	ldr	r4, [r0, #16]
 80051c0:	f843 4c6c 	str.w	r4, [r3, #-108]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80051c4:	2702      	movs	r7, #2
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80051c6:	6944      	ldr	r4, [r0, #20]
 80051c8:	f843 4c68 	str.w	r4, [r3, #-104]

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 80051cc:	6804      	ldr	r4, [r0, #0]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 80051ce:	f803 7c28 	strb.w	r7, [r3, #-40]
  tp->flags     = CH_FLAG_MODE_STATIC;
 80051d2:	2000      	movs	r0, #0
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 80051d4:	2701      	movs	r7, #1
 80051d6:	f803 7c26 	strb.w	r7, [r3, #-38]
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 80051da:	f803 0c27 	strb.w	r0, [r3, #-39]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 80051de:	6955      	ldr	r5, [r2, #20]

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
 80051e0:	f843 4c30 	str.w	r4, [r3, #-48]
  tp = (thread_t *)((uint8_t *)tdp->wend -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
 80051e4:	f843 1c2c 	str.w	r1, [r3, #-44]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 80051e8:	f1a3 071c 	sub.w	r7, r3, #28
  chDbgCheck((tdp->prio <= HIGHPRIO) && (tdp->funcp != NULL));

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)tdp->wend -
 80051ec:	f1a3 0148 	sub.w	r1, r3, #72	; 0x48
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80051f0:	4e11      	ldr	r6, [pc, #68]	; (8005238 <chThdCreateSuspendedI+0x88>)
 80051f2:	f843 6c4c 	str.w	r6, [r3, #-76]
 80051f6:	f1a3 0a6c 	sub.w	sl, r3, #108	; 0x6c
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 80051fa:	f1a3 0420 	sub.w	r4, r3, #32
  /* Stack boundary.*/
  tp->wabase = tdp->wbase;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);
 80051fe:	f843 ac3c 	str.w	sl, [r3, #-60]
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005202:	f843 0c10 	str.w	r0, [r3, #-16]
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8005206:	f843 0c14 	str.w	r0, [r3, #-20]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800520a:	f843 5c34 	str.w	r5, [r3, #-52]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 800520e:	f843 cc40 	str.w	ip, [r3, #-64]
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005212:	f843 cc0c 	str.w	ip, [r3, #-12]
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005216:	f843 2c38 	str.w	r2, [r3, #-56]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800521a:	4608      	mov	r0, r1
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 800521c:	6129      	str	r1, [r5, #16]
 800521e:	6151      	str	r1, [r2, #20]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005220:	f843 4c20 	str.w	r4, [r3, #-32]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005224:	f843 7c1c 	str.w	r7, [r3, #-28]
  tqp->prev = (thread_t *)tqp;
 8005228:	f843 7c18 	str.w	r7, [r3, #-24]
  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, tdp->wbase, tp, tdp->funcp, tdp->arg);

  /* The driver object is initialized but not started.*/
  return _thread_init(tp, tdp->name, tdp->prio);
}
 800522c:	e8bd 04f0 	ldmia.w	sp!, {r4, r5, r6, r7, sl}
 8005230:	4770      	bx	lr
 8005232:	bf00      	nop
 8005234:	200013b0 	.word	0x200013b0
 8005238:	080002e5 	.word	0x080002e5
 800523c:	f3af 8000 	nop.w

08005240 <chSchDoReschedule>:
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;
 8005240:	4a0e      	ldr	r2, [pc, #56]	; (800527c <chSchDoReschedule+0x3c>)
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8005242:	6810      	ldr	r0, [r2, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 8005244:	b470      	push	{r4, r5, r6}

  tqp->next             = tp->queue.next;
 8005246:	6803      	ldr	r3, [r0, #0]
  thread_t *otp = currp;
 8005248:	6994      	ldr	r4, [r2, #24]
 800524a:	6013      	str	r3, [r2, #0]

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800524c:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800524e:	2500      	movs	r5, #0
 8005250:	68a1      	ldr	r1, [r4, #8]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005252:	605a      	str	r2, [r3, #4]
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005254:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoReschedule(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 8005258:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800525a:	f884 5020 	strb.w	r5, [r4, #32]
 800525e:	e000      	b.n	8005262 <chSchDoReschedule+0x22>
 8005260:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 8005262:	689a      	ldr	r2, [r3, #8]
 8005264:	428a      	cmp	r2, r1
 8005266:	d8fb      	bhi.n	8005260 <chSchDoReschedule+0x20>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005268:	685a      	ldr	r2, [r3, #4]
 800526a:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800526c:	6023      	str	r3, [r4, #0]
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 800526e:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005270:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8005272:	605c      	str	r4, [r3, #4]
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
}
 8005274:	bc70      	pop	{r4, r5, r6}
     ahead of its peers.*/
  otp = chSchReadyAheadI(otp);
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 8005276:	f7fb b82d 	b.w	80002d4 <_port_switch>
 800527a:	bf00      	nop
 800527c:	200013b0 	.word	0x200013b0

08005280 <chSchRescheduleS>:
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.queue) > currp->prio;
 8005280:	4a10      	ldr	r2, [pc, #64]	; (80052c4 <chSchRescheduleS+0x44>)
 * @details If a thread with a higher priority than the current thread is in
 *          the ready list then make the higher priority thread running.
 *
 * @sclass
 */
void chSchRescheduleS(void) {
 8005282:	b470      	push	{r4, r5, r6}
 8005284:	6810      	ldr	r0, [r2, #0]
 8005286:	6994      	ldr	r4, [r2, #24]

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8005288:	6883      	ldr	r3, [r0, #8]
 800528a:	68a1      	ldr	r1, [r4, #8]
 800528c:	428b      	cmp	r3, r1
 800528e:	d801      	bhi.n	8005294 <chSchRescheduleS+0x14>
    chSchDoRescheduleAhead();
  }
}
 8005290:	bc70      	pop	{r4, r5, r6}
 8005292:	4770      	bx	lr
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005294:	6803      	ldr	r3, [r0, #0]
 8005296:	6013      	str	r3, [r2, #0]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 8005298:	2601      	movs	r6, #1
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800529a:	2500      	movs	r5, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 800529c:	605a      	str	r2, [r3, #4]
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 800529e:	f880 6020 	strb.w	r6, [r0, #32]
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp = currp;

  /* Picks the first thread from the ready queue and makes it current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80052a2:	6190      	str	r0, [r2, #24]
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 80052a4:	f884 5020 	strb.w	r5, [r4, #32]
 80052a8:	e000      	b.n	80052ac <chSchRescheduleS+0x2c>
 80052aa:	681b      	ldr	r3, [r3, #0]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
 80052ac:	689a      	ldr	r2, [r3, #8]
 80052ae:	4291      	cmp	r1, r2
 80052b0:	d3fb      	bcc.n	80052aa <chSchRescheduleS+0x2a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80052b2:	685a      	ldr	r2, [r3, #4]
 80052b4:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 80052b6:	6023      	str	r3, [r4, #0]

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80052b8:	4621      	mov	r1, r4
    cp = cp->queue.next;
  } while (cp->prio > tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80052ba:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 80052bc:	605c      	str	r4, [r3, #4]
  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
    chSchDoRescheduleAhead();
  }
}
 80052be:	bc70      	pop	{r4, r5, r6}

  /* Placing in ready list ahead of peers.*/
  otp = chSchReadyAheadI(otp);

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80052c0:	f7fb b808 	b.w	80002d4 <_port_switch>
 80052c4:	200013b0 	.word	0x200013b0
 80052c8:	f3af 8000 	nop.w
 80052cc:	f3af 8000 	nop.w

080052d0 <chThdSetPriority>:
 * @param[in] newprio   the new priority level of the running thread
 * @return              The old priority level.
 *
 * @api
 */
tprio_t chThdSetPriority(tprio_t newprio) {
 80052d0:	b510      	push	{r4, lr}
 80052d2:	2320      	movs	r3, #32
 80052d4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheck(newprio <= HIGHPRIO);

  chSysLock();
#if CH_CFG_USE_MUTEXES == TRUE
  oldprio = currp->realprio;
 80052d8:	4b08      	ldr	r3, [pc, #32]	; (80052fc <chThdSetPriority+0x2c>)
 80052da:	699b      	ldr	r3, [r3, #24]
 80052dc:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
  if ((currp->prio == currp->realprio) || (newprio > currp->prio)) {
 80052de:	6899      	ldr	r1, [r3, #8]
 80052e0:	428c      	cmp	r4, r1
 80052e2:	d001      	beq.n	80052e8 <chThdSetPriority+0x18>
 80052e4:	4281      	cmp	r1, r0
 80052e6:	d200      	bcs.n	80052ea <chThdSetPriority+0x1a>
    currp->prio = newprio;
 80052e8:	6098      	str	r0, [r3, #8]
  }
  currp->realprio = newprio;
 80052ea:	63d8      	str	r0, [r3, #60]	; 0x3c
#else
  oldprio = currp->prio;
  currp->prio = newprio;
#endif
  chSchRescheduleS();
 80052ec:	f7ff ffc8 	bl	8005280 <chSchRescheduleS>
 80052f0:	2300      	movs	r3, #0
 80052f2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return oldprio;
}
 80052f6:	4620      	mov	r0, r4
 80052f8:	bd10      	pop	{r4, pc}
 80052fa:	bf00      	nop
 80052fc:	200013b0 	.word	0x200013b0

08005300 <chSchWakeupS>:
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
  thread_t *otp = currp;
 8005300:	4b16      	ldr	r3, [pc, #88]	; (800535c <chSchWakeupS+0x5c>)
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005302:	b470      	push	{r4, r5, r6}
  thread_t *otp = currp;
 8005304:	699e      	ldr	r6, [r3, #24]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8005306:	6884      	ldr	r4, [r0, #8]
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8005308:	4605      	mov	r5, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800530a:	68b0      	ldr	r0, [r6, #8]
              (ch.rlist.current->prio >= ch.rlist.queue.next->prio),
              "priority order violation");

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->u.rdymsg = msg;
 800530c:	6269      	str	r1, [r5, #36]	; 0x24

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 800530e:	4284      	cmp	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005310:	f04f 0200 	mov.w	r2, #0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->prio <= otp->prio) {
 8005314:	d80c      	bhi.n	8005330 <chSchWakeupS+0x30>
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005316:	f885 2020 	strb.w	r2, [r5, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800531a:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 800531c:	689a      	ldr	r2, [r3, #8]
 800531e:	4294      	cmp	r4, r2
 8005320:	d9fb      	bls.n	800531a <chSchWakeupS+0x1a>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005322:	685a      	ldr	r2, [r3, #4]
 8005324:	606a      	str	r2, [r5, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8005326:	602b      	str	r3, [r5, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005328:	6015      	str	r5, [r2, #0]
  cp->queue.prev             = tp;
 800532a:	605d      	str	r5, [r3, #4]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 800532c:	bc70      	pop	{r4, r5, r6}
 800532e:	4770      	bx	lr
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005330:	f886 2020 	strb.w	r2, [r6, #32]
  cp = (thread_t *)&ch.rlist.queue;
 8005334:	461a      	mov	r2, r3
  do {
    cp = cp->queue.next;
 8005336:	6812      	ldr	r2, [r2, #0]
  } while (cp->prio >= tp->prio);
 8005338:	6891      	ldr	r1, [r2, #8]
 800533a:	4288      	cmp	r0, r1
 800533c:	d9fb      	bls.n	8005336 <chSchWakeupS+0x36>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 800533e:	6850      	ldr	r0, [r2, #4]
 8005340:	6070      	str	r0, [r6, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 8005342:	2401      	movs	r4, #1
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 8005344:	6032      	str	r2, [r6, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 8005346:	6006      	str	r6, [r0, #0]
  cp->queue.prev             = tp;
 8005348:	6056      	str	r6, [r2, #4]
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;
 800534a:	f885 4020 	strb.w	r4, [r5, #32]

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 800534e:	4631      	mov	r1, r6
 8005350:	4628      	mov	r0, r5
    if (otp->prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }

    /* The extracted thread is marked as current.*/
    currp = ntp;
 8005352:	619d      	str	r5, [r3, #24]
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
  }
}
 8005354:	bc70      	pop	{r4, r5, r6}
    /* The extracted thread is marked as current.*/
    currp = ntp;
    ntp->state = CH_STATE_CURRENT;

    /* Swap operation as tail call.*/
    chSysSwitch(ntp, otp);
 8005356:	f7fa bfbd 	b.w	80002d4 <_port_switch>
 800535a:	bf00      	nop
 800535c:	200013b0 	.word	0x200013b0

08005360 <chSemSignal>:
 *
 * @param[in] sp        pointer to a @p semaphore_t structure
 *
 * @api
 */
void chSemSignal(semaphore_t *sp) {
 8005360:	b508      	push	{r3, lr}
 8005362:	2320      	movs	r3, #32
 8005364:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sp->cnt <= (cnt_t)0) {
 8005368:	6883      	ldr	r3, [r0, #8]
 800536a:	3301      	adds	r3, #1
 800536c:	2b00      	cmp	r3, #0
 800536e:	6083      	str	r3, [r0, #8]
 8005370:	dd03      	ble.n	800537a <chSemSignal+0x1a>
 8005372:	2300      	movs	r3, #0
 8005374:	f383 8811 	msr	BASEPRI, r3
 8005378:	bd08      	pop	{r3, pc}
 800537a:	4603      	mov	r3, r0
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800537c:	6800      	ldr	r0, [r0, #0]

  tqp->next             = tp->queue.next;
 800537e:	6802      	ldr	r2, [r0, #0]
 8005380:	601a      	str	r2, [r3, #0]
    chSchWakeupS(queue_fifo_remove(&sp->queue), MSG_OK);
 8005382:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8005384:	6053      	str	r3, [r2, #4]
 8005386:	f7ff ffbb 	bl	8005300 <chSchWakeupS>
 800538a:	2300      	movs	r3, #0
 800538c:	f383 8811 	msr	BASEPRI, r3
 8005390:	bd08      	pop	{r3, pc}
 8005392:	bf00      	nop
 8005394:	f3af 8000 	nop.w
 8005398:	f3af 8000 	nop.w
 800539c:	f3af 8000 	nop.w

080053a0 <chSchGoSleepS>:
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp = currp;
 80053a0:	4b08      	ldr	r3, [pc, #32]	; (80053c4 <chSchGoSleepS+0x24>)
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 80053a2:	b430      	push	{r4, r5}
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 80053a4:	681a      	ldr	r2, [r3, #0]
  thread_t *otp = currp;
 80053a6:	6999      	ldr	r1, [r3, #24]

  tqp->next             = tp->queue.next;
 80053a8:	6814      	ldr	r4, [r2, #0]

  chDbgCheckClassS();

  /* New state.*/
  otp->state = newstate;
 80053aa:	f881 0020 	strb.w	r0, [r1, #32]
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
  currp->state = CH_STATE_CURRENT;
 80053ae:	2501      	movs	r5, #1
  tqp->next->queue.prev = (thread_t *)tqp;
 80053b0:	6063      	str	r3, [r4, #4]
 80053b2:	f882 5020 	strb.w	r5, [r2, #32]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80053b6:	601c      	str	r4, [r3, #0]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80053b8:	4610      	mov	r0, r2
}
 80053ba:	bc30      	pop	{r4, r5}
     time quantum when it will wakeup.*/
  otp->preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif

  /* Next thread in ready list becomes current.*/
  currp = queue_fifo_remove(&ch.rlist.queue);
 80053bc:	619a      	str	r2, [r3, #24]
  if (currp->prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }

  /* Swap operation as tail call.*/
  chSysSwitch(currp, otp);
 80053be:	f7fa bf89 	b.w	80002d4 <_port_switch>
 80053c2:	bf00      	nop
 80053c4:	200013b0 	.word	0x200013b0
 80053c8:	f3af 8000 	nop.w
 80053cc:	f3af 8000 	nop.w

080053d0 <chSemWait>:
 80053d0:	2320      	movs	r3, #32
 80053d2:	f383 8811 	msr	BASEPRI, r3
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 80053d6:	6883      	ldr	r3, [r0, #8]
 80053d8:	3b01      	subs	r3, #1
 80053da:	2b00      	cmp	r3, #0
 80053dc:	6083      	str	r3, [r0, #8]
 80053de:	db04      	blt.n	80053ea <chSemWait+0x1a>
    chSchGoSleepS(CH_STATE_WTSEM);

    return currp->u.rdymsg;
  }

  return MSG_OK;
 80053e0:	2000      	movs	r0, #0
 80053e2:	2300      	movs	r3, #0
 80053e4:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 80053e8:	4770      	bx	lr
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemWait(semaphore_t *sp) {
 80053ea:	b510      	push	{r4, lr}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    currp->u.wtsemp = sp;
 80053ec:	4c08      	ldr	r4, [pc, #32]	; (8005410 <chSemWait+0x40>)
 80053ee:	69a2      	ldr	r2, [r4, #24]
 80053f0:	6250      	str	r0, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 80053f2:	6841      	ldr	r1, [r0, #4]
 80053f4:	6051      	str	r1, [r2, #4]
 80053f6:	4603      	mov	r3, r0
  cp->queue.prev             = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
 80053f8:	6010      	str	r0, [r2, #0]
  tp->queue.prev             = tqp->prev;
  tp->queue.prev->queue.next = tp;
 80053fa:	600a      	str	r2, [r1, #0]
    sem_insert(currp, &sp->queue);
    chSchGoSleepS(CH_STATE_WTSEM);
 80053fc:	2005      	movs	r0, #5
  tqp->prev                  = tp;
 80053fe:	605a      	str	r2, [r3, #4]
 8005400:	f7ff ffce 	bl	80053a0 <chSchGoSleepS>

    return currp->u.rdymsg;
 8005404:	69a3      	ldr	r3, [r4, #24]
 8005406:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005408:	2300      	movs	r3, #0
 800540a:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  msg = chSemWaitS(sp);
  chSysUnlock();

  return msg;
}
 800540e:	bd10      	pop	{r4, pc}
 8005410:	200013b0 	.word	0x200013b0
 8005414:	f3af 8000 	nop.w
 8005418:	f3af 8000 	nop.w
 800541c:	f3af 8000 	nop.w

08005420 <chThdWait>:
 * @param[in] tp        pointer to the thread
 * @return              The exit code from the terminated thread.
 *
 * @api
 */
msg_t chThdWait(thread_t *tp) {
 8005420:	b538      	push	{r3, r4, r5, lr}
 8005422:	4604      	mov	r4, r0
 8005424:	2320      	movs	r3, #32
 8005426:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(tp != currp, "waiting self");
#if CH_CFG_USE_REGISTRY == TRUE
  chDbgAssert(tp->refs > (trefs_t)0, "no references");
#endif

  if (tp->state != CH_STATE_FINAL) {
 800542a:	f890 3020 	ldrb.w	r3, [r0, #32]
 800542e:	2b0f      	cmp	r3, #15
 8005430:	d007      	beq.n	8005442 <chThdWait+0x22>
    list_insert(currp, &tp->waiting);
 8005432:	4b08      	ldr	r3, [pc, #32]	; (8005454 <chThdWait+0x34>)
/* If the performance code path has been chosen then all the following
   functions are inlined into the various kernel modules.*/
#if CH_CFG_OPTIMIZE_SPEED == TRUE
static inline void list_insert(thread_t *tp, threads_list_t *tlp) {

  tp->queue.next = tlp->next;
 8005434:	6a82      	ldr	r2, [r0, #40]	; 0x28
 8005436:	699b      	ldr	r3, [r3, #24]
    chSchGoSleepS(CH_STATE_WTEXIT);
 8005438:	2009      	movs	r0, #9
 800543a:	601a      	str	r2, [r3, #0]
  tlp->next = tp;
 800543c:	62a3      	str	r3, [r4, #40]	; 0x28
 800543e:	f7ff ffaf 	bl	80053a0 <chSchGoSleepS>
  }
  msg = tp->u.exitcode;
 8005442:	6a65      	ldr	r5, [r4, #36]	; 0x24
 8005444:	2300      	movs	r3, #0
 8005446:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

#if CH_CFG_USE_REGISTRY == TRUE
  /* Releasing a reference to the thread.*/
  chThdRelease(tp);
 800544a:	4620      	mov	r0, r4
 800544c:	f7ff fe78 	bl	8005140 <chThdRelease>
#endif

  return msg;
}
 8005450:	4628      	mov	r0, r5
 8005452:	bd38      	pop	{r3, r4, r5, pc}
 8005454:	200013b0 	.word	0x200013b0
 8005458:	f3af 8000 	nop.w
 800545c:	f3af 8000 	nop.w

08005460 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 8005460:	2200      	movs	r2, #0
 8005462:	6881      	ldr	r1, [r0, #8]
  cp = (thread_t *)&ch.rlist.queue;
 8005464:	4b08      	ldr	r3, [pc, #32]	; (8005488 <chSchReadyI+0x28>)
 * @param[in] tp        the thread to be made ready
 * @return              The thread pointer.
 *
 * @iclass
 */
thread_t *chSchReadyI(thread_t *tp) {
 8005466:	b410      	push	{r4}
 8005468:	4604      	mov	r4, r0
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->state != CH_STATE_READY) &&
              (tp->state != CH_STATE_FINAL),
              "invalid state");

  tp->state = CH_STATE_READY;
 800546a:	f880 2020 	strb.w	r2, [r0, #32]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
 800546e:	681b      	ldr	r3, [r3, #0]
  } while (cp->prio >= tp->prio);
 8005470:	689a      	ldr	r2, [r3, #8]
 8005472:	428a      	cmp	r2, r1
 8005474:	d2fb      	bcs.n	800546e <chSchReadyI+0xe>
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005476:	685a      	ldr	r2, [r3, #4]
 8005478:	6062      	str	r2, [r4, #4]
  cp = (thread_t *)&ch.rlist.queue;
  do {
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
 800547a:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
  cp->queue.prev             = tp;

  return tp;
}
 800547c:	4620      	mov	r0, r4
    cp = cp->queue.next;
  } while (cp->prio >= tp->prio);
  /* Insertion on prev.*/
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800547e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8005480:	605c      	str	r4, [r3, #4]

  return tp;
}
 8005482:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005486:	4770      	bx	lr
 8005488:	200013b0 	.word	0x200013b0
 800548c:	f3af 8000 	nop.w

08005490 <chMtxUnlockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8005490:	4b12      	ldr	r3, [pc, #72]	; (80054dc <chMtxUnlockS+0x4c>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxUnlockS(mutex_t *mp) {
 8005492:	b430      	push	{r4, r5}
 8005494:	4604      	mov	r4, r0
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005496:	6805      	ldr	r5, [r0, #0]
  thread_t *ctp = currp;
 8005498:	6998      	ldr	r0, [r3, #24]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 800549a:	68e3      	ldr	r3, [r4, #12]
 800549c:	6383      	str	r3, [r0, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 800549e:	42ac      	cmp	r4, r5
 80054a0:	d017      	beq.n	80054d2 <chMtxUnlockS+0x42>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80054a2:	6bc1      	ldr	r1, [r0, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80054a4:	b14b      	cbz	r3, 80054ba <chMtxUnlockS+0x2a>
 80054a6:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80054a8:	4293      	cmp	r3, r2
 80054aa:	d003      	beq.n	80054b4 <chMtxUnlockS+0x24>
            (lmp->queue.next->prio > newprio)) {
 80054ac:	6892      	ldr	r2, [r2, #8]
 80054ae:	4291      	cmp	r1, r2
 80054b0:	bf38      	it	cc
 80054b2:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 80054b4:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80054b6:	2b00      	cmp	r3, #0
 80054b8:	d1f5      	bne.n	80054a6 <chMtxUnlockS+0x16>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 80054ba:	682b      	ldr	r3, [r5, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 80054bc:	6baa      	ldr	r2, [r5, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 80054be:	6081      	str	r1, [r0, #8]
 80054c0:	6023      	str	r3, [r4, #0]
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 80054c2:	4628      	mov	r0, r5
  tqp->next->queue.prev = (thread_t *)tqp;
 80054c4:	605c      	str	r4, [r3, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 80054c6:	60a5      	str	r5, [r4, #8]
      mp->next = tp->mtxlist;
 80054c8:	60e2      	str	r2, [r4, #12]
      tp->mtxlist = mp;
 80054ca:	63ac      	str	r4, [r5, #56]	; 0x38
      mp->owner = NULL;
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80054cc:	bc30      	pop	{r4, r5}
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
      tp->mtxlist = mp;
      (void) chSchReadyI(tp);
 80054ce:	f7ff bfc7 	b.w	8005460 <chSchReadyI>
    }
    else {
      mp->owner = NULL;
 80054d2:	2300      	movs	r3, #0
 80054d4:	60a3      	str	r3, [r4, #8]
    }
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
  }
#endif
}
 80054d6:	bc30      	pop	{r4, r5}
 80054d8:	4770      	bx	lr
 80054da:	bf00      	nop
 80054dc:	200013b0 	.word	0x200013b0

080054e0 <chMtxUnlock>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
  thread_t *ctp = currp;
 80054e0:	4b17      	ldr	r3, [pc, #92]	; (8005540 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 80054e2:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 80054e4:	699d      	ldr	r5, [r3, #24]
 80054e6:	2320      	movs	r3, #32
 80054e8:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 80054ec:	6804      	ldr	r4, [r0, #0]
    chDbgAssert(ctp->mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->mtxlist = mp->next;
 80054ee:	68c3      	ldr	r3, [r0, #12]
 80054f0:	63ab      	str	r3, [r5, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 80054f2:	42a0      	cmp	r0, r4
 80054f4:	d01d      	beq.n	8005532 <chMtxUnlock+0x52>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
 80054f6:	6be9      	ldr	r1, [r5, #60]	; 0x3c
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 80054f8:	b14b      	cbz	r3, 800550e <chMtxUnlock+0x2e>
 80054fa:	681a      	ldr	r2, [r3, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 80054fc:	4293      	cmp	r3, r2
 80054fe:	d003      	beq.n	8005508 <chMtxUnlock+0x28>
            (lmp->queue.next->prio > newprio)) {
 8005500:	6892      	ldr	r2, [r2, #8]
 8005502:	4291      	cmp	r1, r2
 8005504:	bf38      	it	cc
 8005506:	4611      	movcc	r1, r2
          newprio = lmp->queue.next->prio;
        }
        lmp = lmp->next;
 8005508:	68db      	ldr	r3, [r3, #12]

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->realprio;
      lmp = ctp->mtxlist;
      while (lmp != NULL) {
 800550a:	2b00      	cmp	r3, #0
 800550c:	d1f5      	bne.n	80054fa <chMtxUnlock+0x1a>
 800550e:	4603      	mov	r3, r0
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005510:	6822      	ldr	r2, [r4, #0]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
      mp->next = tp->mtxlist;
 8005512:	6ba6      	ldr	r6, [r4, #56]	; 0x38
        lmp = lmp->next;
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->prio = newprio;
 8005514:	60a9      	str	r1, [r5, #8]

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8005516:	4620      	mov	r0, r4
 8005518:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 800551a:	6053      	str	r3, [r2, #4]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->queue);
      mp->owner = tp;
 800551c:	609c      	str	r4, [r3, #8]
      mp->next = tp->mtxlist;
 800551e:	60de      	str	r6, [r3, #12]
      tp->mtxlist = mp;
 8005520:	63a3      	str	r3, [r4, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8005522:	f7ff ff9d 	bl	8005460 <chSchReadyI>
      chSchRescheduleS();
 8005526:	f7ff feab 	bl	8005280 <chSchRescheduleS>
 800552a:	2300      	movs	r3, #0
 800552c:	f383 8811 	msr	BASEPRI, r3
 8005530:	bd70      	pop	{r4, r5, r6, pc}
    }
    else {
      mp->owner = NULL;
 8005532:	2300      	movs	r3, #0
 8005534:	6083      	str	r3, [r0, #8]
 8005536:	2300      	movs	r3, #0
 8005538:	f383 8811 	msr	BASEPRI, r3
 800553c:	bd70      	pop	{r4, r5, r6, pc}
 800553e:	bf00      	nop
 8005540:	200013b0 	.word	0x200013b0
 8005544:	f3af 8000 	nop.w
 8005548:	f3af 8000 	nop.w
 800554c:	f3af 8000 	nop.w

08005550 <chMtxLockS>:
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8005550:	4b30      	ldr	r3, [pc, #192]	; (8005614 <chMtxLockS+0xc4>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8005552:	6882      	ldr	r2, [r0, #8]
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
 8005554:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8005556:	699c      	ldr	r4, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->owner != NULL) {
 8005558:	2a00      	cmp	r2, #0
 800555a:	d056      	beq.n	800560a <chMtxLockS+0xba>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 800555c:	68a1      	ldr	r1, [r4, #8]
 800555e:	6893      	ldr	r3, [r2, #8]
 8005560:	4299      	cmp	r1, r3
 8005562:	4605      	mov	r5, r0
 8005564:	d907      	bls.n	8005576 <chMtxLockS+0x26>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 8005566:	f892 3020 	ldrb.w	r3, [r2, #32]

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
        /* Make priority of thread tp match the running thread's priority.*/
        tp->prio = ctp->prio;
 800556a:	6091      	str	r1, [r2, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
 800556c:	2b06      	cmp	r3, #6
 800556e:	d033      	beq.n	80055d8 <chMtxLockS+0x88>
 8005570:	2b07      	cmp	r3, #7
 8005572:	d01d      	beq.n	80055b0 <chMtxLockS+0x60>
 8005574:	b19b      	cbz	r3, 800559e <chMtxLockS+0x4e>
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 8005576:	462b      	mov	r3, r5
 8005578:	e003      	b.n	8005582 <chMtxLockS+0x32>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 800557a:	6899      	ldr	r1, [r3, #8]
 800557c:	68a2      	ldr	r2, [r4, #8]
 800557e:	4291      	cmp	r1, r2
 8005580:	d302      	bcc.n	8005588 <chMtxLockS+0x38>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 8005582:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 8005584:	429d      	cmp	r5, r3
 8005586:	d1f8      	bne.n	800557a <chMtxLockS+0x2a>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 8005588:	685a      	ldr	r2, [r3, #4]
 800558a:	6062      	str	r2, [r4, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 800558c:	6023      	str	r3, [r4, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 800558e:	6014      	str	r4, [r2, #0]
  cp->queue.prev             = tp;
 8005590:	605c      	str	r4, [r3, #4]
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
 8005592:	6265      	str	r5, [r4, #36]	; 0x24
      chSchGoSleepS(CH_STATE_WTMTX);
 8005594:	2006      	movs	r0, #6
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
  }
}
 8005596:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->queue);
      ctp->u.wtmtxp = mp;
      chSchGoSleepS(CH_STATE_WTMTX);
 800559a:	f7ff bf01 	b.w	80053a0 <chSchGoSleepS>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 800559e:	e892 000a 	ldmia.w	r2, {r1, r3}
 80055a2:	6019      	str	r1, [r3, #0]
  tp->queue.next->queue.prev = tp->queue.prev;
 80055a4:	6811      	ldr	r1, [r2, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 80055a6:	4610      	mov	r0, r2
 80055a8:	604b      	str	r3, [r1, #4]
 80055aa:	f7ff ff59 	bl	8005460 <chSchReadyI>
 80055ae:	e7e2      	b.n	8005576 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80055b0:	e892 0009 	ldmia.w	r2, {r0, r3}
 80055b4:	6018      	str	r0, [r3, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80055b6:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 80055b8:	6810      	ldr	r0, [r2, #0]
 80055ba:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80055bc:	4633      	mov	r3, r6
 80055be:	e002      	b.n	80055c6 <chMtxLockS+0x76>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055c0:	6898      	ldr	r0, [r3, #8]
 80055c2:	4288      	cmp	r0, r1
 80055c4:	d302      	bcc.n	80055cc <chMtxLockS+0x7c>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80055c6:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055c8:	429e      	cmp	r6, r3
 80055ca:	d1f9      	bne.n	80055c0 <chMtxLockS+0x70>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80055cc:	6859      	ldr	r1, [r3, #4]
 80055ce:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80055d0:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80055d2:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80055d4:	605a      	str	r2, [r3, #4]
 80055d6:	e7ce      	b.n	8005576 <chMtxLockS+0x26>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->queue.prev->queue.next = tp->queue.next;
 80055d8:	e892 0009 	ldmia.w	r2, {r0, r3}
 80055dc:	6018      	str	r0, [r3, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->u.wtmtxp->queue);
 80055de:	6a56      	ldr	r6, [r2, #36]	; 0x24
  tp->queue.next->queue.prev = tp->queue.prev;
 80055e0:	6810      	ldr	r0, [r2, #0]
 80055e2:	6043      	str	r3, [r0, #4]
  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
 80055e4:	4633      	mov	r3, r6
 80055e6:	e002      	b.n	80055ee <chMtxLockS+0x9e>
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055e8:	6898      	ldr	r0, [r3, #8]
 80055ea:	4288      	cmp	r0, r1
 80055ec:	d302      	bcc.n	80055f4 <chMtxLockS+0xa4>

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
 80055ee:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
 80055f0:	429e      	cmp	r6, r3
 80055f2:	d1f9      	bne.n	80055e8 <chMtxLockS+0x98>
  tp->queue.next             = cp;
  tp->queue.prev             = cp->queue.prev;
 80055f4:	6859      	ldr	r1, [r3, #4]
 80055f6:	6051      	str	r1, [r2, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->queue.next;
  } while ((cp != (thread_t *)tqp) && (cp->prio >= tp->prio));
  tp->queue.next             = cp;
 80055f8:	6013      	str	r3, [r2, #0]
  tp->queue.prev             = cp->queue.prev;
  tp->queue.prev->queue.next = tp;
 80055fa:	600a      	str	r2, [r1, #0]
  cp->queue.prev             = tp;
 80055fc:	605a      	str	r2, [r3, #4]
          tp = tp->u.wtmtxp->owner;
 80055fe:	68b2      	ldr	r2, [r6, #8]
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->prio < ctp->prio) {
 8005600:	68a1      	ldr	r1, [r4, #8]
 8005602:	6893      	ldr	r3, [r2, #8]
 8005604:	428b      	cmp	r3, r1
 8005606:	d3ae      	bcc.n	8005566 <chMtxLockS+0x16>
 8005608:	e7b5      	b.n	8005576 <chMtxLockS+0x26>

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
    mp->next = ctp->mtxlist;
 800560a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 800560c:	60c3      	str	r3, [r0, #12]
    chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

    mp->cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->owner = ctp;
 800560e:	6084      	str	r4, [r0, #8]
    mp->next = ctp->mtxlist;
    ctp->mtxlist = mp;
 8005610:	63a0      	str	r0, [r4, #56]	; 0x38
 8005612:	bd70      	pop	{r4, r5, r6, pc}
 8005614:	200013b0 	.word	0x200013b0
 8005618:	f3af 8000 	nop.w
 800561c:	f3af 8000 	nop.w

08005620 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8005620:	b508      	push	{r3, lr}
 8005622:	2320      	movs	r3, #32
 8005624:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMtxLockS(mp);
 8005628:	f7ff ff92 	bl	8005550 <chMtxLockS>
 800562c:	2300      	movs	r3, #0
 800562e:	f383 8811 	msr	BASEPRI, r3
 8005632:	bd08      	pop	{r3, pc}
 8005634:	f3af 8000 	nop.w
 8005638:	f3af 8000 	nop.w
 800563c:	f3af 8000 	nop.w

08005640 <chSemSignalI>:
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (++sp->cnt <= (cnt_t)0) {
 8005640:	6883      	ldr	r3, [r0, #8]
 8005642:	3301      	adds	r3, #1
 8005644:	2b00      	cmp	r3, #0
 8005646:	6083      	str	r3, [r0, #8]
 8005648:	dd00      	ble.n	800564c <chSemSignalI+0xc>
 800564a:	4770      	bx	lr
  tp->queue.prev->queue.next = tp;
  tqp->prev                  = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 800564c:	6803      	ldr	r3, [r0, #0]

  tqp->next             = tp->queue.next;
 800564e:	681a      	ldr	r2, [r3, #0]
 8005650:	6002      	str	r2, [r0, #0]
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8005652:	2100      	movs	r1, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8005654:	6050      	str	r0, [r2, #4]
    (void) chSchReadyI(tp);
 8005656:	4618      	mov	r0, r3

  if (++sp->cnt <= (cnt_t)0) {
    /* Note, it is done this way in order to allow a tail call on
             chSchReadyI().*/
    thread_t *tp = queue_fifo_remove(&sp->queue);
    tp->u.rdymsg = MSG_OK;
 8005658:	6259      	str	r1, [r3, #36]	; 0x24
    (void) chSchReadyI(tp);
 800565a:	f7ff bf01 	b.w	8005460 <chSchReadyI>
 800565e:	bf00      	nop

08005660 <chSemResetI>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @iclass
 */
void chSemResetI(semaphore_t *sp, cnt_t n) {
 8005660:	b570      	push	{r4, r5, r6, lr}
  chDbgCheck((sp != NULL) && (n >= (cnt_t)0));
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
 8005662:	6885      	ldr	r5, [r0, #8]
  sp->cnt = n;
 8005664:	6081      	str	r1, [r0, #8]
  while (++cnt <= (cnt_t)0) {
 8005666:	3501      	adds	r5, #1
 8005668:	2d00      	cmp	r5, #0
 800566a:	dc0c      	bgt.n	8005686 <chSemResetI+0x26>
 800566c:	4604      	mov	r4, r0
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 800566e:	f06f 0601 	mvn.w	r6, #1

  return tp;
}

static inline thread_t *queue_lifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->prev;
 8005672:	6860      	ldr	r0, [r4, #4]

  tqp->prev             = tp->queue.prev;
 8005674:	6843      	ldr	r3, [r0, #4]
 8005676:	6063      	str	r3, [r4, #4]
  tqp->prev->queue.next = (thread_t *)tqp;
 8005678:	601c      	str	r4, [r3, #0]
 800567a:	f7ff fef1 	bl	8005460 <chSchReadyI>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 800567e:	3501      	adds	r5, #1
 8005680:	2d01      	cmp	r5, #1
    chSchReadyI(queue_lifo_remove(&sp->queue))->u.rdymsg = MSG_RESET;
 8005682:	6246      	str	r6, [r0, #36]	; 0x24
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  cnt = sp->cnt;
  sp->cnt = n;
  while (++cnt <= (cnt_t)0) {
 8005684:	d1f5      	bne.n	8005672 <chSemResetI+0x12>
 8005686:	bd70      	pop	{r4, r5, r6, pc}
 8005688:	f3af 8000 	nop.w
 800568c:	f3af 8000 	nop.w

08005690 <chSemReset>:
 * @param[in] n         the new value of the semaphore counter. The value must
 *                      be non-negative.
 *
 * @api
 */
void chSemReset(semaphore_t *sp, cnt_t n) {
 8005690:	b508      	push	{r3, lr}
 8005692:	2320      	movs	r3, #32
 8005694:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chSemResetI(sp, n);
 8005698:	f7ff ffe2 	bl	8005660 <chSemResetI>
  chSchRescheduleS();
 800569c:	f7ff fdf0 	bl	8005280 <chSchRescheduleS>
 80056a0:	2300      	movs	r3, #0
 80056a2:	f383 8811 	msr	BASEPRI, r3
 80056a6:	bd08      	pop	{r3, pc}
 80056a8:	f3af 8000 	nop.w
 80056ac:	f3af 8000 	nop.w

080056b0 <chThdExit>:
 *
 * @param[in] msg       thread exit code
 *
 * @api
 */
void chThdExit(msg_t msg) {
 80056b0:	b538      	push	{r3, r4, r5, lr}
 80056b2:	2220      	movs	r2, #32
 80056b4:	4603      	mov	r3, r0
 80056b6:	f382 8811 	msr	BASEPRI, r2
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 80056ba:	4a10      	ldr	r2, [pc, #64]	; (80056fc <chThdExit+0x4c>)
 80056bc:	6994      	ldr	r4, [r2, #24]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80056be:	6aa0      	ldr	r0, [r4, #40]	; 0x28

  /* Storing exit message.*/
  tp->u.exitcode = msg;
 80056c0:	6263      	str	r3, [r4, #36]	; 0x24
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80056c2:	f104 0528 	add.w	r5, r4, #40	; 0x28
 80056c6:	42a8      	cmp	r0, r5
 80056c8:	d006      	beq.n	80056d8 <chThdExit+0x28>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->next;
  tlp->next = tp->queue.next;
 80056ca:	6803      	ldr	r3, [r0, #0]
 80056cc:	62a3      	str	r3, [r4, #40]	; 0x28
    (void) chSchReadyI(list_remove(&tp->waiting));
 80056ce:	f7ff fec7 	bl	8005460 <chSchReadyI>
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->next != (thread_t *)tlp);
 80056d2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
  /* Exit handler hook.*/
  CH_CFG_THREAD_EXIT_HOOK(tp);

#if CH_CFG_USE_WAITEXIT == TRUE
  /* Waking up any waiting thread.*/
  while (list_notempty(&tp->waiting)) {
 80056d4:	42a8      	cmp	r0, r5
 80056d6:	d1f8      	bne.n	80056ca <chThdExit+0x1a>

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80056d8:	f894 3022 	ldrb.w	r3, [r4, #34]	; 0x22
 80056dc:	b943      	cbnz	r3, 80056f0 <chThdExit+0x40>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
 80056de:	f894 3021 	ldrb.w	r3, [r4, #33]	; 0x21

#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads with no references are immediately removed from the
     registry because there is no memory to recover.*/
#if CH_CFG_USE_DYNAMIC == TRUE
  if ((tp->refs == (trefs_t)0) &&
 80056e2:	079b      	lsls	r3, r3, #30
 80056e4:	d104      	bne.n	80056f0 <chThdExit+0x40>
      ((tp->flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC)) {
    REG_REMOVE(tp);
 80056e6:	6963      	ldr	r3, [r4, #20]
 80056e8:	6922      	ldr	r2, [r4, #16]
 80056ea:	611a      	str	r2, [r3, #16]
 80056ec:	6922      	ldr	r2, [r4, #16]
 80056ee:	6153      	str	r3, [r2, #20]
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80056f0:	200f      	movs	r0, #15
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
  /* The thread never returns here.*/
}
 80056f2:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  }
#endif
#endif

  /* Going into final state.*/
  chSchGoSleepS(CH_STATE_FINAL);
 80056f6:	f7ff be53 	b.w	80053a0 <chSchGoSleepS>
 80056fa:	bf00      	nop
 80056fc:	200013b0 	.word	0x200013b0

08005700 <chVTDoResetI>:
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8005700:	4b1a      	ldr	r3, [pc, #104]	; (800576c <chVTDoResetI+0x6c>)
 8005702:	69da      	ldr	r2, [r3, #28]
 8005704:	4282      	cmp	r2, r0
 *
 * @param[in] vtp       the @p virtual_timer_t structure pointer
 *
 * @iclass
 */
void chVTDoResetI(virtual_timer_t *vtp) {
 8005706:	b410      	push	{r4}
#else /* CH_CFG_ST_TIMEDELTA > 0 */
  systime_t nowdelta, delta;

  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
 8005708:	d010      	beq.n	800572c <chVTDoResetI+0x2c>
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
 800570a:	6841      	ldr	r1, [r0, #4]
 800570c:	6802      	ldr	r2, [r0, #0]
 800570e:	600a      	str	r2, [r1, #0]
    vtp->next->prev = vtp->prev;
 8005710:	6802      	ldr	r2, [r0, #0]
    vtp->func = NULL;

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8005712:	331c      	adds	r3, #28
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
    vtp->func = NULL;
 8005714:	2400      	movs	r4, #0

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 8005716:	429a      	cmp	r2, r3
  /* If the timer is not the first of the list then it is simply unlinked
     else the operation is more complex.*/
  if (ch.vtlist.next != vtp) {
    /* Removing the element from the delta list.*/
    vtp->prev->next = vtp->next;
    vtp->next->prev = vtp->prev;
 8005718:	6051      	str	r1, [r2, #4]
    vtp->func = NULL;
 800571a:	60c4      	str	r4, [r0, #12]

    /* Adding delta to the next element, if it is not the last one.*/
    if (&ch.vtlist != (virtual_timers_list_t *)vtp->next)
 800571c:	d003      	beq.n	8005726 <chVTDoResetI+0x26>
      vtp->next->delta += vtp->delta;
 800571e:	6883      	ldr	r3, [r0, #8]
 8005720:	6891      	ldr	r1, [r2, #8]
 8005722:	440b      	add	r3, r1
 8005724:	6093      	str	r3, [r2, #8]
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
#endif /* CH_CFG_ST_TIMEDELTA > 0 */
}
 8005726:	f85d 4b04 	ldr.w	r4, [sp], #4
 800572a:	4770      	bx	lr

    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
 800572c:	4618      	mov	r0, r3
 800572e:	6811      	ldr	r1, [r2, #0]
 8005730:	f840 1f1c 	str.w	r1, [r0, #28]!
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
  vtp->func = NULL;
 8005734:	2400      	movs	r4, #0

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8005736:	4281      	cmp	r1, r0
    return;
  }

  /* Removing the first timer from the list.*/
  ch.vtlist.next = vtp->next;
  ch.vtlist.next->prev = (virtual_timer_t *)&ch.vtlist;
 8005738:	6048      	str	r0, [r1, #4]
  vtp->func = NULL;
 800573a:	60d4      	str	r4, [r2, #12]

  /* If the list become empty then the alarm timer is stopped and done.*/
  if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800573c:	d011      	beq.n	8005762 <chVTDoResetI+0x62>

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 800573e:	6894      	ldr	r4, [r2, #8]
 8005740:	688a      	ldr	r2, [r1, #8]
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 8005742:	6a98      	ldr	r0, [r3, #40]	; 0x28

    return;
  }

  /* The delta of the removed timer is added to the new first timer.*/
  ch.vtlist.next->delta += vtp->delta;
 8005744:	18a3      	adds	r3, r4, r2
 8005746:	f04f 4480 	mov.w	r4, #1073741824	; 0x40000000
 800574a:	608b      	str	r3, [r1, #8]
 800574c:	6a61      	ldr	r1, [r4, #36]	; 0x24
/*  if (ch.vtlist.next->delta == 0) {
    return;
  }*/

  /* Distance in ticks between the last alarm event and current time.*/
  nowdelta = chVTGetSystemTimeX() - ch.vtlist.lasttime;
 800574e:	1a0a      	subs	r2, r1, r0

  /* If the current time surpassed the time of the next element in list
     then the event interrupt is already pending, just return.*/
  if (nowdelta >= ch.vtlist.next->delta) {
 8005750:	4293      	cmp	r3, r2
 8005752:	d9e8      	bls.n	8005726 <chVTDoResetI+0x26>
    return;
  }

  /* Distance from the next scheduled event and now.*/
  delta = ch.vtlist.next->delta - nowdelta;
 8005754:	1a9b      	subs	r3, r3, r2

  /* Making sure to not schedule an event closer than CH_CFG_ST_TIMEDELTA
     ticks from now.*/
  if (delta < (systime_t)CH_CFG_ST_TIMEDELTA) {
 8005756:	2b01      	cmp	r3, #1
    delta = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005758:	bf98      	it	ls
 800575a:	2302      	movls	r3, #2
  }

  port_timer_set_alarm(ch.vtlist.lasttime + nowdelta + delta);
 800575c:	440b      	add	r3, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 800575e:	6363      	str	r3, [r4, #52]	; 0x34
 8005760:	e7e1      	b.n	8005726 <chVTDoResetI+0x26>
 *
 * @notapi
 */
static inline void st_lld_stop_alarm(void) {

  STM32_ST_TIM->DIER = 0;
 8005762:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8005766:	60dc      	str	r4, [r3, #12]
 8005768:	e7dd      	b.n	8005726 <chVTDoResetI+0x26>
 800576a:	bf00      	nop
 800576c:	200013b0 	.word	0x200013b0

08005770 <chVTDoSetI>:
 *                      function
 *
 * @iclass
 */
void chVTDoSetI(virtual_timer_t *vtp, systime_t delay,
                vtfunc_t vtfunc, void *par) {
 8005770:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8005772:	4d1c      	ldr	r5, [pc, #112]	; (80057e4 <chVTDoSetI+0x74>)
 8005774:	462e      	mov	r6, r5
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8005776:	f04f 4780 	mov.w	r7, #1073741824	; 0x40000000
 800577a:	f856 4f1c 	ldr.w	r4, [r6, #28]!
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
 800577e:	6103      	str	r3, [r0, #16]
    systime_t now = chVTGetSystemTimeX();

    /* If the requested delay is lower than the minimum safe delta then it
       is raised to the minimum safe value.*/
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
 8005780:	2901      	cmp	r1, #1
 8005782:	bf98      	it	ls
 8005784:	2102      	movls	r1, #2
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 8005786:	42b4      	cmp	r4, r6

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->par = par;
  vtp->func = vtfunc;
 8005788:	60c2      	str	r2, [r0, #12]
 800578a:	6a7b      	ldr	r3, [r7, #36]	; 0x24
    if (delay < (systime_t)CH_CFG_ST_TIMEDELTA) {
      delay = (systime_t)CH_CFG_ST_TIMEDELTA;
    }

    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {
 800578c:	d01b      	beq.n	80057c6 <chVTDoSetI+0x56>
    /* Pointer to the first element in the delta list, which is non-empty.*/
    p = ch.vtlist.next;

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;
 800578e:	6aaa      	ldr	r2, [r5, #40]	; 0x28
 8005790:	1a9b      	subs	r3, r3, r2

    if (delta < now - ch.vtlist.lasttime) {
 8005792:	18c9      	adds	r1, r1, r3
      /* Scenario where a very large delay excedeed the numeric range, it
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
 8005794:	68a3      	ldr	r3, [r4, #8]

    /* Delay as delta from 'lasttime'. Note, it can overflow and the value
       becomes lower than 'now'.*/
    delta = now - ch.vtlist.lasttime + delay;

    if (delta < now - ch.vtlist.lasttime) {
 8005796:	d311      	bcc.n	80057bc <chVTDoSetI+0x4c>

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
    p = p->next;
 8005798:	6824      	ldr	r4, [r4, #0]
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
    delta -= p->delta;
 800579a:	1ac9      	subs	r1, r1, r3
  p = ch.vtlist.next;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  while (p->delta < delta) {
 800579c:	68a3      	ldr	r3, [r4, #8]
 800579e:	428b      	cmp	r3, r1
 80057a0:	d3fa      	bcc.n	8005798 <chVTDoSetI+0x28>
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
  vtp->prev = vtp->next->prev;
 80057a2:	6863      	ldr	r3, [r4, #4]
 80057a4:	6043      	str	r3, [r0, #4]
    delta -= p->delta;
    p = p->next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->next = p;
 80057a6:	6004      	str	r4, [r0, #0]
  vtp->prev = vtp->next->prev;
  vtp->prev->next = vtp;
 80057a8:	6018      	str	r0, [r3, #0]
  p->prev = vtp;
 80057aa:	6060      	str	r0, [r4, #4]
  vtp->delta = delta
 80057ac:	6081      	str	r1, [r0, #8]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 80057ae:	68a3      	ldr	r3, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 80057b0:	f04f 32ff 	mov.w	r2, #4294967295
  p->prev = vtp;
  vtp->delta = delta

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->delta -= delta;
 80057b4:	1a59      	subs	r1, r3, r1
 80057b6:	60a1      	str	r1, [r4, #8]
  ch.vtlist.delta = (systime_t)-1;
 80057b8:	626a      	str	r2, [r5, #36]	; 0x24
 80057ba:	bdf0      	pop	{r4, r5, r6, r7, pc}
         requires a special handling. We need to skip the first element and
         adjust the delta to wrap back in the previous numeric range.*/
      delta -= p->delta;
      p = p->next;
    }
    else if (delta < p->delta) {
 80057bc:	4299      	cmp	r1, r3
 80057be:	d2ee      	bcs.n	800579e <chVTDoSetI+0x2e>
     /* A small delay that will become the first element in the delta list
        and next deadline.*/
      port_timer_set_alarm(ch.vtlist.lasttime + delta);
 80057c0:	440a      	add	r2, r1
 *
 * @notapi
 */
static inline void st_lld_set_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80057c2:	637a      	str	r2, [r7, #52]	; 0x34
 80057c4:	e7eb      	b.n	800579e <chVTDoSetI+0x2e>
      vtp->next = (virtual_timer_t *)&ch.vtlist;
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
      vtp->delta = delay;

      /* Being the first element in the list the alarm timer is started.*/
      port_timer_start_alarm(ch.vtlist.lasttime + delay);
 80057c6:	eb01 0e03 	add.w	lr, r1, r3
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
  STM32_ST_TIM->SR     = 0;
 80057ca:	2600      	movs	r6, #0
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80057cc:	2202      	movs	r2, #2
    /* Special case where the timers list is empty.*/
    if (&ch.vtlist == (virtual_timers_list_t *)ch.vtlist.next) {

      /* The delta list is empty, the current time becomes the new
         delta list base time, the timer is inserted.*/
      ch.vtlist.lasttime = now;
 80057ce:	62ab      	str	r3, [r5, #40]	; 0x28
      ch.vtlist.next = vtp;
 80057d0:	61e8      	str	r0, [r5, #28]
      ch.vtlist.prev = vtp;
 80057d2:	6228      	str	r0, [r5, #32]
      vtp->next = (virtual_timer_t *)&ch.vtlist;
 80057d4:	6004      	str	r4, [r0, #0]
      vtp->prev = (virtual_timer_t *)&ch.vtlist;
 80057d6:	6044      	str	r4, [r0, #4]
      vtp->delta = delay;
 80057d8:	6081      	str	r1, [r0, #8]
 *
 * @notapi
 */
static inline void st_lld_start_alarm(systime_t time) {

  STM32_ST_TIM->CCR[0] = (uint32_t)time;
 80057da:	f8c7 e034 	str.w	lr, [r7, #52]	; 0x34
  STM32_ST_TIM->SR     = 0;
 80057de:	613e      	str	r6, [r7, #16]
  STM32_ST_TIM->DIER   = STM32_TIM_DIER_CC1IE;
 80057e0:	60fa      	str	r2, [r7, #12]
 80057e2:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80057e4:	200013b0 	.word	0x200013b0
 80057e8:	f3af 8000 	nop.w
 80057ec:	f3af 8000 	nop.w

080057f0 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80057f0:	b530      	push	{r4, r5, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80057f2:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 80057f4:	b087      	sub	sp, #28

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 80057f6:	d012      	beq.n	800581e <chSchGoSleepTimeoutS+0x2e>
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
 80057f8:	4c0c      	ldr	r4, [pc, #48]	; (800582c <chSchGoSleepTimeoutS+0x3c>)
 80057fa:	4a0d      	ldr	r2, [pc, #52]	; (8005830 <chSchGoSleepTimeoutS+0x40>)
 80057fc:	69a3      	ldr	r3, [r4, #24]
 80057fe:	4605      	mov	r5, r0
 8005800:	a801      	add	r0, sp, #4
 8005802:	f7ff ffb5 	bl	8005770 <chVTDoSetI>
    chSchGoSleepS(newstate);
 8005806:	4628      	mov	r0, r5
 8005808:	f7ff fdca 	bl	80053a0 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 800580c:	9b04      	ldr	r3, [sp, #16]
 800580e:	b113      	cbz	r3, 8005816 <chSchGoSleepTimeoutS+0x26>
      chVTDoResetI(&vt);
 8005810:	a801      	add	r0, sp, #4
 8005812:	f7ff ff75 	bl	8005700 <chVTDoResetI>
  }
  else {
    chSchGoSleepS(newstate);
  }

  return currp->u.rdymsg;
 8005816:	69a3      	ldr	r3, [r4, #24]
}
 8005818:	6a58      	ldr	r0, [r3, #36]	; 0x24
 800581a:	b007      	add	sp, #28
 800581c:	bd30      	pop	{r4, r5, pc}
 800581e:	4c03      	ldr	r4, [pc, #12]	; (800582c <chSchGoSleepTimeoutS+0x3c>)
    if (chVTIsArmedI(&vt)) {
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8005820:	f7ff fdbe 	bl	80053a0 <chSchGoSleepS>
  }

  return currp->u.rdymsg;
 8005824:	69a3      	ldr	r3, [r4, #24]
}
 8005826:	6a58      	ldr	r0, [r3, #36]	; 0x24
 8005828:	b007      	add	sp, #28
 800582a:	bd30      	pop	{r4, r5, pc}
 800582c:	200013b0 	.word	0x200013b0
 8005830:	08004f81 	.word	0x08004f81
 8005834:	f3af 8000 	nop.w
 8005838:	f3af 8000 	nop.w
 800583c:	f3af 8000 	nop.w

08005840 <chSemWaitTimeoutS>:
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8005840:	4603      	mov	r3, r0
  chDbgCheck(sp != NULL);
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
 8005842:	6880      	ldr	r0, [r0, #8]
 8005844:	1e42      	subs	r2, r0, #1
 8005846:	2a00      	cmp	r2, #0
 8005848:	609a      	str	r2, [r3, #8]
 800584a:	db01      	blt.n	8005850 <chSemWaitTimeoutS+0x10>
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
 800584c:	2000      	movs	r0, #0
 800584e:	4770      	bx	lr
 * @retval MSG_TIMEOUT  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t time) {
 8005850:	b410      	push	{r4}
  chDbgAssert(((sp->cnt >= (cnt_t)0) && queue_isempty(&sp->queue)) ||
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
 8005852:	b161      	cbz	r1, 800586e <chSemWaitTimeoutS+0x2e>
      sp->cnt++;

      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
 8005854:	4a09      	ldr	r2, [pc, #36]	; (800587c <chSemWaitTimeoutS+0x3c>)
 8005856:	6992      	ldr	r2, [r2, #24]
 8005858:	6253      	str	r3, [r2, #36]	; 0x24
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 800585a:	685c      	ldr	r4, [r3, #4]
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800585c:	2005      	movs	r0, #5
 800585e:	e882 0018 	stmia.w	r2, {r3, r4}
  tp->queue.prev->queue.next = tp;
 8005862:	6022      	str	r2, [r4, #0]
  tqp->prev                  = tp;
 8005864:	605a      	str	r2, [r3, #4]
  }

  return MSG_OK;
}
 8005866:	f85d 4b04 	ldr.w	r4, [sp], #4
      return MSG_TIMEOUT;
    }
    currp->u.wtsemp = sp;
    sem_insert(currp, &sp->queue);

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
 800586a:	f7ff bfc1 	b.w	80057f0 <chSchGoSleepTimeoutS>
              ((sp->cnt < (cnt_t)0) && queue_notempty(&sp->queue)),
              "inconsistent semaphore");

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;
 800586e:	6098      	str	r0, [r3, #8]

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8005870:	f85d 4b04 	ldr.w	r4, [sp], #4

  if (--sp->cnt < (cnt_t)0) {
    if (TIME_IMMEDIATE == time) {
      sp->cnt++;

      return MSG_TIMEOUT;
 8005874:	f04f 30ff 	mov.w	r0, #4294967295

    return chSchGoSleepTimeoutS(CH_STATE_WTSEM, time);
  }

  return MSG_OK;
}
 8005878:	4770      	bx	lr
 800587a:	bf00      	nop
 800587c:	200013b0 	.word	0x200013b0

08005880 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8005880:	b169      	cbz	r1, 800589e <chThdEnqueueTimeoutS+0x1e>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8005882:	4b08      	ldr	r3, [pc, #32]	; (80058a4 <chThdEnqueueTimeoutS+0x24>)
 *                      invoked with @p TIME_IMMEDIATE as timeout
 *                      specification.
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {
 8005884:	b410      	push	{r4}
 8005886:	4602      	mov	r2, r0
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8005888:	6844      	ldr	r4, [r0, #4]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 800588a:	699b      	ldr	r3, [r3, #24]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800588c:	2004      	movs	r0, #4
 800588e:	e883 0014 	stmia.w	r3, {r2, r4}
  tp->queue.prev->queue.next = tp;
 8005892:	6023      	str	r3, [r4, #0]
  tqp->prev                  = tp;
 8005894:	6053      	str	r3, [r2, #4]
}
 8005896:	f85d 4b04 	ldr.w	r4, [sp], #4
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 800589a:	f7ff bfa9 	b.w	80057f0 <chSchGoSleepTimeoutS>
}
 800589e:	f04f 30ff 	mov.w	r0, #4294967295
 80058a2:	4770      	bx	lr
 80058a4:	200013b0 	.word	0x200013b0
 80058a8:	f3af 8000 	nop.w
 80058ac:	f3af 8000 	nop.w

080058b0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 80058b0:	b508      	push	{r3, lr}
 80058b2:	4601      	mov	r1, r0
 80058b4:	2320      	movs	r3, #32
 80058b6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 80058ba:	2008      	movs	r0, #8
 80058bc:	f7ff ff98 	bl	80057f0 <chSchGoSleepTimeoutS>
 80058c0:	2300      	movs	r3, #0
 80058c2:	f383 8811 	msr	BASEPRI, r3
 80058c6:	bd08      	pop	{r3, pc}
 80058c8:	f3af 8000 	nop.w
 80058cc:	f3af 8000 	nop.w

080058d0 <chSysRestoreStatusX.part.2.lto_priv.192>:
 *
 * @param[in] sts       the system status to be restored.
 *
 * @xclass
 */
void chSysRestoreStatusX(syssts_t sts) {
 80058d0:	b510      	push	{r4, lr}
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80058d2:	f3ef 8405 	mrs	r4, IPSR
 * @retval false        not running in ISR mode.
 * @retval true         running in ISR mode.
 */
static inline bool port_is_isr_context(void) {

  return (bool)((__get_IPSR() & 0x1FFU) != 0U);
 80058d6:	f3c4 0408 	ubfx	r4, r4, #0, #9

  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80058da:	b11c      	cbz	r4, 80058e4 <chSysRestoreStatusX.part.2.lto_priv.192+0x14>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80058dc:	2300      	movs	r3, #0
 80058de:	f383 8811 	msr	BASEPRI, r3
 80058e2:	bd10      	pop	{r4, pc}
      chSysUnlockFromISR();
    }
    else {
      chSchRescheduleS();
 80058e4:	f7ff fccc 	bl	8005280 <chSchRescheduleS>
 80058e8:	f384 8811 	msr	BASEPRI, r4
 80058ec:	bd10      	pop	{r4, pc}
 80058ee:	bf00      	nop

080058f0 <chSysGetStatusAndLockX.part.1.lto_priv.193>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 80058f0:	f3ef 8305 	mrs	r3, IPSR
 80058f4:	f3c3 0308 	ubfx	r3, r3, #0, #9
 */
syssts_t chSysGetStatusAndLockX(void) {

  syssts_t sts = port_get_irq_status();
  if (port_irq_enabled(sts)) {
    if (port_is_isr_context()) {
 80058f8:	b91b      	cbnz	r3, 8005902 <chSysGetStatusAndLockX.part.1.lto_priv.193+0x12>
  \details Assigns the given value to the Base Priority register.
  \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80058fa:	2320      	movs	r3, #32
 80058fc:	f383 8811 	msr	BASEPRI, r3
    else {
      chSysLock();
    }
  }
  return sts;
}
 8005900:	4770      	bx	lr
 8005902:	2320      	movs	r3, #32
 8005904:	f383 8811 	msr	BASEPRI, r3
 8005908:	4770      	bx	lr
 800590a:	bf00      	nop
 800590c:	f3af 8000 	nop.w

08005910 <chSysIntegrityCheckI>:
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8005910:	07c2      	lsls	r2, r0, #31
 * @retval false        The test succeeded.
 * @retval true         Test failed.
 *
 * @iclass
 */
bool chSysIntegrityCheckI(unsigned testmask) {
 8005912:	b410      	push	{r4}
  cnt_t n;

  chDbgCheckClassI();

  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
 8005914:	d512      	bpl.n	800593c <chSysIntegrityCheckI+0x2c>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
 8005916:	4a2d      	ldr	r2, [pc, #180]	; (80059cc <chSysIntegrityCheckI+0xbc>)
 8005918:	6811      	ldr	r1, [r2, #0]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800591a:	4291      	cmp	r1, r2
 800591c:	d044      	beq.n	80059a8 <chSysIntegrityCheckI+0x98>
 800591e:	2300      	movs	r3, #0
      n++;
      tp = tp->queue.next;
 8005920:	6809      	ldr	r1, [r1, #0]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8005922:	4291      	cmp	r1, r2
      n++;
 8005924:	f103 0301 	add.w	r3, r3, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.queue.next;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8005928:	d1fa      	bne.n	8005920 <chSysIntegrityCheckI+0x10>
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 800592a:	684c      	ldr	r4, [r1, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 800592c:	428c      	cmp	r4, r1
 800592e:	d037      	beq.n	80059a0 <chSysIntegrityCheckI+0x90>
      n--;
      tp = tp->queue.prev;
 8005930:	6864      	ldr	r4, [r4, #4]
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8005932:	4294      	cmp	r4, r2
      n--;
 8005934:	f103 33ff 	add.w	r3, r3, #4294967295
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 8005938:	d1fa      	bne.n	8005930 <chSysIntegrityCheckI+0x20>
      n--;
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 800593a:	bb8b      	cbnz	r3, 80059a0 <chSysIntegrityCheckI+0x90>
      return true;
    }
  }

  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
 800593c:	0783      	lsls	r3, r0, #30
 800593e:	d514      	bpl.n	800596a <chSysIntegrityCheckI+0x5a>
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
 8005940:	4a22      	ldr	r2, [pc, #136]	; (80059cc <chSysIntegrityCheckI+0xbc>)
 8005942:	4614      	mov	r4, r2
 8005944:	f854 1f1c 	ldr.w	r1, [r4, #28]!
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8005948:	42a1      	cmp	r1, r4
 800594a:	d033      	beq.n	80059b4 <chSysIntegrityCheckI+0xa4>
 800594c:	2300      	movs	r3, #0
      n++;
      vtp = vtp->next;
 800594e:	6809      	ldr	r1, [r1, #0]
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8005950:	42a1      	cmp	r1, r4
      n++;
 8005952:	f103 0301 	add.w	r3, r3, #1
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
    vtp = ch.vtlist.next;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8005956:	d1fa      	bne.n	800594e <chSysIntegrityCheckI+0x3e>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 8005958:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 800595a:	428a      	cmp	r2, r1
 800595c:	d020      	beq.n	80059a0 <chSysIntegrityCheckI+0x90>
      n--;
      vtp = vtp->prev;
 800595e:	6852      	ldr	r2, [r2, #4]
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8005960:	42a2      	cmp	r2, r4
      n--;
 8005962:	f103 33ff 	add.w	r3, r3, #4294967295
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 8005966:	d1fa      	bne.n	800595e <chSysIntegrityCheckI+0x4e>
      n--;
      vtp = vtp->prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8005968:	b9d3      	cbnz	r3, 80059a0 <chSysIntegrityCheckI+0x90>
      return true;
    }
  }

#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
 800596a:	f010 0004 	ands.w	r0, r0, #4
 800596e:	d014      	beq.n	800599a <chSysIntegrityCheckI+0x8a>
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
 8005970:	4a16      	ldr	r2, [pc, #88]	; (80059cc <chSysIntegrityCheckI+0xbc>)
 8005972:	6913      	ldr	r3, [r2, #16]
    while (tp != (thread_t *)&ch.rlist) {
 8005974:	4293      	cmp	r3, r2
 8005976:	d023      	beq.n	80059c0 <chSysIntegrityCheckI+0xb0>
 8005978:	2000      	movs	r0, #0
      n++;
      tp = tp->newer;
 800597a:	691b      	ldr	r3, [r3, #16]
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 800597c:	4293      	cmp	r3, r2
      n++;
 800597e:	f100 0001 	add.w	r0, r0, #1
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
    tp = ch.rlist.newer;
    while (tp != (thread_t *)&ch.rlist) {
 8005982:	d1fa      	bne.n	800597a <chSysIntegrityCheckI+0x6a>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 8005984:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 8005986:	4299      	cmp	r1, r3
 8005988:	d00a      	beq.n	80059a0 <chSysIntegrityCheckI+0x90>
      n--;
      tp = tp->older;
 800598a:	6949      	ldr	r1, [r1, #20]
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 800598c:	4291      	cmp	r1, r2
      n--;
 800598e:	f100 30ff 	add.w	r0, r0, #4294967295
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 8005992:	d1fa      	bne.n	800598a <chSysIntegrityCheckI+0x7a>
      n--;
      tp = tp->older;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
 8005994:	3000      	adds	r0, #0
 8005996:	bf18      	it	ne
 8005998:	2001      	movne	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 800599a:	f85d 4b04 	ldr.w	r4, [sp], #4
 800599e:	4770      	bx	lr
      tp = tp->queue.prev;
    }

    /* The number of elements must match.*/
    if (n != (cnt_t)0) {
      return true;
 80059a0:	2001      	movs	r0, #1
    PORT_INTEGRITY_CHECK();
  }
#endif

  return false;
}
 80059a2:	f85d 4b04 	ldr.w	r4, [sp], #4
 80059a6:	4770      	bx	lr
      n++;
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
 80059a8:	6854      	ldr	r4, [r2, #4]
    while (tp != (thread_t *)&ch.rlist.queue) {
 80059aa:	4294      	cmp	r4, r2
  /* Ready List integrity check.*/
  if ((testmask & CH_INTEGRITY_RLIST) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80059ac:	bf18      	it	ne
 80059ae:	2300      	movne	r3, #0
      tp = tp->queue.next;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.queue.prev;
    while (tp != (thread_t *)&ch.rlist.queue) {
 80059b0:	d1be      	bne.n	8005930 <chSysIntegrityCheckI+0x20>
 80059b2:	e7c3      	b.n	800593c <chSysIntegrityCheckI+0x2c>
      n++;
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
 80059b4:	6a12      	ldr	r2, [r2, #32]
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80059b6:	42a2      	cmp	r2, r4
  /* Timers list integrity check.*/
  if ((testmask & CH_INTEGRITY_VTLIST) != 0U) {
    virtual_timer_t * vtp;

    /* Scanning the timers list forward.*/
    n = (cnt_t)0;
 80059b8:	bf18      	it	ne
 80059ba:	2300      	movne	r3, #0
      vtp = vtp->next;
    }

    /* Scanning the timers list backward.*/
    vtp = ch.vtlist.prev;
    while (vtp != (virtual_timer_t *)&ch.vtlist) {
 80059bc:	d1cf      	bne.n	800595e <chSysIntegrityCheckI+0x4e>
 80059be:	e7d4      	b.n	800596a <chSysIntegrityCheckI+0x5a>
      n++;
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
 80059c0:	6959      	ldr	r1, [r3, #20]
    while (tp != (thread_t *)&ch.rlist) {
 80059c2:	4299      	cmp	r1, r3
#if CH_CFG_USE_REGISTRY == TRUE
  if ((testmask & CH_INTEGRITY_REGISTRY) != 0U) {
    thread_t *tp;

    /* Scanning the ready list forward.*/
    n = (cnt_t)0;
 80059c4:	f04f 0000 	mov.w	r0, #0
      tp = tp->newer;
    }

    /* Scanning the ready list backward.*/
    tp = ch.rlist.older;
    while (tp != (thread_t *)&ch.rlist) {
 80059c8:	d1df      	bne.n	800598a <chSysIntegrityCheckI+0x7a>
 80059ca:	e7e6      	b.n	800599a <chSysIntegrityCheckI+0x8a>
 80059cc:	200013b0 	.word	0x200013b0

080059d0 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 80059d0:	e7fe      	b.n	80059d0 <BusFault_Handler>
 80059d2:	bf00      	nop
 80059d4:	f3af 8000 	nop.w
 80059d8:	f3af 8000 	nop.w
 80059dc:	f3af 8000 	nop.w

080059e0 <__init_ram_areas>:
}

/**
 * @brief   Performs the initialization of the various RAM areas.
 */
void __init_ram_areas(void) {
 80059e0:	b4f0      	push	{r4, r5, r6, r7}
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;
 80059e2:	4e11      	ldr	r6, [pc, #68]	; (8005a28 <__init_ram_areas+0x48>)
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
      *p = 0;
 80059e4:	2500      	movs	r5, #0
 80059e6:	f106 0780 	add.w	r7, r6, #128	; 0x80
void __init_ram_areas(void) {
#if CRT1_AREAS_NUMBER > 0
  const ram_init_area_t *rap = ram_areas;

  do {
    uint32_t *tp = rap->init_text_area;
 80059ea:	e896 001a 	ldmia.w	r6, {r1, r3, r4}
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80059ee:	42a3      	cmp	r3, r4
 80059f0:	d20d      	bcs.n	8005a0e <__init_ram_areas+0x2e>
 80059f2:	3904      	subs	r1, #4
 80059f4:	461a      	mov	r2, r3
      *p = *tp;
 80059f6:	f851 0f04 	ldr.w	r0, [r1, #4]!
 80059fa:	f842 0b04 	str.w	r0, [r2], #4
  do {
    uint32_t *tp = rap->init_text_area;
    uint32_t *p = rap->init_area;

    /* Copying initialization data.*/
    while (p < rap->clear_area) {
 80059fe:	42a2      	cmp	r2, r4
 8005a00:	d3f9      	bcc.n	80059f6 <__init_ram_areas+0x16>
 8005a02:	43da      	mvns	r2, r3
 8005a04:	4414      	add	r4, r2
 8005a06:	f024 0403 	bic.w	r4, r4, #3
 8005a0a:	3404      	adds	r4, #4
 8005a0c:	4423      	add	r3, r4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8005a0e:	68f2      	ldr	r2, [r6, #12]
 8005a10:	4293      	cmp	r3, r2
 8005a12:	d203      	bcs.n	8005a1c <__init_ram_areas+0x3c>
      *p = 0;
 8005a14:	f843 5b04 	str.w	r5, [r3], #4
      p++;
      tp++;
    }

    /* Zeroing clear area.*/
    while (p < rap->no_init_area) {
 8005a18:	4293      	cmp	r3, r2
 8005a1a:	d3fb      	bcc.n	8005a14 <__init_ram_areas+0x34>
      *p = 0;
      p++;
    }
    rap++;
 8005a1c:	3610      	adds	r6, #16
  }
  while (rap < &ram_areas[CRT1_AREAS_NUMBER]);
 8005a1e:	42be      	cmp	r6, r7
 8005a20:	d3e3      	bcc.n	80059ea <__init_ram_areas+0xa>
#endif
}
 8005a22:	bcf0      	pop	{r4, r5, r6, r7}
 8005a24:	4770      	bx	lr
 8005a26:	bf00      	nop
 8005a28:	080073e0 	.word	0x080073e0
 8005a2c:	f3af 8000 	nop.w

08005a30 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8005a30:	e7fe      	b.n	8005a30 <__default_exit>
 8005a32:	bf00      	nop
 8005a34:	f3af 8000 	nop.w
 8005a38:	f3af 8000 	nop.w
 8005a3c:	f3af 8000 	nop.w

08005a40 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8005a40:	4770      	bx	lr
 8005a42:	bf00      	nop
 8005a44:	f3af 8000 	nop.w
 8005a48:	f3af 8000 	nop.w
 8005a4c:	f3af 8000 	nop.w

08005a50 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8005a50:	4770      	bx	lr
 8005a52:	bf00      	nop
 8005a54:	f3af 8000 	nop.w
 8005a58:	f3af 8000 	nop.w
 8005a5c:	f3af 8000 	nop.w

08005a60 <chTMStartMeasurementX.constprop.70>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8005a60:	4b01      	ldr	r3, [pc, #4]	; (8005a68 <chTMStartMeasurementX.constprop.70+0x8>)
 8005a62:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8005a64:	6083      	str	r3, [r0, #8]
 8005a66:	4770      	bx	lr
 8005a68:	e0001000 	.word	0xe0001000
 8005a6c:	f3af 8000 	nop.w

08005a70 <chThdCreateStatic.constprop.69>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8005a70:	e92d 4ff8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005a74:	469a      	mov	sl, r3
 8005a76:	4604      	mov	r4, r0
 8005a78:	2320      	movs	r3, #32
 8005a7a:	f383 8811 	msr	BASEPRI, r3
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005a7e:	4f21      	ldr	r7, [pc, #132]	; (8005b04 <chThdCreateStatic.constprop.69+0x94>)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005a80:	f8c4 20dc 	str.w	r2, [r4, #220]	; 0xdc
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005a84:	f8d7 b014 	ldr.w	fp, [r7, #20]
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005a88:	4b1f      	ldr	r3, [pc, #124]	; (8005b08 <chThdCreateStatic.constprop.69+0x98>)
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8005a8a:	4820      	ldr	r0, [pc, #128]	; (8005b0c <chThdCreateStatic.constprop.69+0x9c>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
 8005a8c:	f8c4 1108 	str.w	r1, [r4, #264]	; 0x108
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005a90:	2500      	movs	r5, #0
  chSysLock();

  /* The thread structure is laid out in the upper part of the thread
     workspace. The thread position structure is aligned to the required
     stack alignment because it represents the stack top.*/
  tp = (thread_t *)((uint8_t *)wsp + size -
 8005a92:	f504 7680 	add.w	r6, r4, #256	; 0x100
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->msgqueue);
 8005a96:	f504 7296 	add.w	r2, r4, #300	; 0x12c
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005a9a:	f04f 0c01 	mov.w	ip, #1
  REG_INSERT(tp);
#else
  (void)name;
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->waiting);
 8005a9e:	f504 7e94 	add.w	lr, r4, #296	; 0x128
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005aa2:	f104 09dc 	add.w	r9, r4, #220	; 0xdc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005aa6:	f04f 0802 	mov.w	r8, #2
  tp->flags     = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
 8005aaa:	f8c4 113c 	str.w	r1, [r4, #316]	; 0x13c
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
 8005aae:	f8c4 0118 	str.w	r0, [r4, #280]	; 0x118
  tp = (thread_t *)((uint8_t *)wsp + size -
                    MEM_ALIGN_NEXT(sizeof (thread_t), PORT_STACK_ALIGN));

#if (CH_DBG_ENABLE_STACK_CHECK == TRUE) || (CH_CFG_USE_DYNAMIC == TRUE)
  /* Stack boundary.*/
  tp->wabase = (stkalign_t *)wsp;
 8005ab2:	f8c4 411c 	str.w	r4, [r4, #284]	; 0x11c
#endif

  /* Setting up the port-dependent part of the working area.*/
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);
 8005ab6:	f8c4 a0e0 	str.w	sl, [r4, #224]	; 0xe0
 8005aba:	f8c4 910c 	str.w	r9, [r4, #268]	; 0x10c
 8005abe:	f8c4 30fc 	str.w	r3, [r4, #252]	; 0xfc
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
 8005ac2:	f884 8120 	strb.w	r8, [r4, #288]	; 0x120
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
 8005ac6:	f884 c122 	strb.w	ip, [r4, #290]	; 0x122
 */
thread_t *_thread_init(thread_t *tp, const char *name, tprio_t prio) {

  tp->prio      = prio;
  tp->state     = CH_STATE_WTSTART;
  tp->flags     = CH_FLAG_MODE_STATIC;
 8005aca:	f884 5121 	strb.w	r5, [r4, #289]	; 0x121
#if CH_CFG_TIME_QUANTUM > 0
  tp->preempt   = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->realprio  = prio;
  tp->mtxlist   = NULL;
 8005ace:	f8c4 5138 	str.w	r5, [r4, #312]	; 0x138
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->epending  = (eventmask_t)0;
 8005ad2:	f8c4 5134 	str.w	r5, [r4, #308]	; 0x134
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005ad6:	f8c4 7110 	str.w	r7, [r4, #272]	; 0x110
 8005ada:	f8c4 b114 	str.w	fp, [r4, #276]	; 0x114
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005ade:	4630      	mov	r0, r6
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005ae0:	f8cb 6010 	str.w	r6, [fp, #16]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005ae4:	4629      	mov	r1, r5
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->next = (thread_t *)tlp;
 8005ae6:	f8c4 e128 	str.w	lr, [r4, #296]	; 0x128
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->next = (thread_t *)tqp;
 8005aea:	f8c4 212c 	str.w	r2, [r4, #300]	; 0x12c
  tqp->prev = (thread_t *)tqp;
 8005aee:	f8c4 2130 	str.w	r2, [r4, #304]	; 0x130
  tp->time      = (systime_t)0;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->refs      = (trefs_t)1;
  tp->name      = name;
  REG_INSERT(tp);
 8005af2:	617e      	str	r6, [r7, #20]
  PORT_SETUP_CONTEXT(tp, wsp, tp, pf, arg);

  tp = _thread_init(tp, "noname", prio);

  /* Starting the thread immediately.*/
  chSchWakeupS(tp, MSG_OK);
 8005af4:	f7ff fc04 	bl	8005300 <chSchWakeupS>
 8005af8:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 8005afc:	4630      	mov	r0, r6
 8005afe:	e8bd 8ff8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005b02:	bf00      	nop
 8005b04:	200013b0 	.word	0x200013b0
 8005b08:	080002e5 	.word	0x080002e5
 8005b0c:	08007460 	.word	0x08007460

08005b10 <chSemSignalWait.constprop.63>:
 *                      semaphore has been signaled.
 * @retval MSG_RESET    if the semaphore has been reset using @p chSemReset().
 *
 * @api
 */
msg_t chSemSignalWait(semaphore_t *sps, semaphore_t *spw) {
 8005b10:	b510      	push	{r4, lr}
 8005b12:	2320      	movs	r3, #32
 8005b14:	f383 8811 	msr	BASEPRI, r3
  chDbgAssert(((spw->cnt >= (cnt_t)0) && queue_isempty(&spw->queue)) ||
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
 8005b18:	4c15      	ldr	r4, [pc, #84]	; (8005b70 <chSemSignalWait.constprop.63+0x60>)
 8005b1a:	68a3      	ldr	r3, [r4, #8]
 8005b1c:	3301      	adds	r3, #1
 8005b1e:	2b00      	cmp	r3, #0
 8005b20:	60a3      	str	r3, [r4, #8]
 8005b22:	dd1b      	ble.n	8005b5c <chSemSignalWait.constprop.63+0x4c>
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
 8005b24:	3b01      	subs	r3, #1
 8005b26:	2b00      	cmp	r3, #0
 8005b28:	60a3      	str	r3, [r4, #8]
 8005b2a:	4a11      	ldr	r2, [pc, #68]	; (8005b70 <chSemSignalWait.constprop.63+0x60>)
 8005b2c:	db06      	blt.n	8005b3c <chSemSignalWait.constprop.63+0x2c>
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
    msg = ctp->u.rdymsg;
  }
  else {
    chSchRescheduleS();
 8005b2e:	f7ff fba7 	bl	8005280 <chSchRescheduleS>
    msg = MSG_OK;
 8005b32:	2000      	movs	r0, #0
 8005b34:	2300      	movs	r3, #0
 8005b36:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return msg;
}
 8005b3a:	bd10      	pop	{r4, pc}
  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
 8005b3c:	490d      	ldr	r1, [pc, #52]	; (8005b74 <chSemSignalWait.constprop.63+0x64>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->queue.next             = (thread_t *)tqp;
  tp->queue.prev             = tqp->prev;
 8005b3e:	6853      	ldr	r3, [r2, #4]
 8005b40:	698c      	ldr	r4, [r1, #24]
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
    chSchGoSleepS(CH_STATE_WTSEM);
 8005b42:	2005      	movs	r0, #5
 8005b44:	e884 000c 	stmia.w	r4, {r2, r3}
  tp->queue.prev->queue.next = tp;
 8005b48:	601c      	str	r4, [r3, #0]
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
  }
  if (--spw->cnt < (cnt_t)0) {
    thread_t *ctp = currp;
    sem_insert(ctp, &spw->queue);
    ctp->u.wtsemp = spw;
 8005b4a:	6262      	str	r2, [r4, #36]	; 0x24
  tqp->prev                  = tp;
 8005b4c:	6054      	str	r4, [r2, #4]
    chSchGoSleepS(CH_STATE_WTSEM);
 8005b4e:	f7ff fc27 	bl	80053a0 <chSchGoSleepS>
    msg = ctp->u.rdymsg;
 8005b52:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005b54:	2300      	movs	r3, #0
 8005b56:	f383 8811 	msr	BASEPRI, r3
    msg = MSG_OK;
  }
  chSysUnlock();

  return msg;
}
 8005b5a:	bd10      	pop	{r4, pc}
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;
 8005b5c:	6820      	ldr	r0, [r4, #0]

  tqp->next             = tp->queue.next;
 8005b5e:	6803      	ldr	r3, [r0, #0]
 8005b60:	6023      	str	r3, [r4, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005b62:	605c      	str	r4, [r3, #4]
              ((spw->cnt < (cnt_t)0) && queue_notempty(&spw->queue)),
              "inconsistent semaphore");

  chSysLock();
  if (++sps->cnt <= (cnt_t)0) {
    chSchReadyI(queue_fifo_remove(&sps->queue))->u.rdymsg = MSG_OK;
 8005b64:	f7ff fc7c 	bl	8005460 <chSchReadyI>
 8005b68:	2200      	movs	r2, #0
 8005b6a:	68a3      	ldr	r3, [r4, #8]
 8005b6c:	6242      	str	r2, [r0, #36]	; 0x24
 8005b6e:	e7d9      	b.n	8005b24 <chSemSignalWait.constprop.63+0x14>
 8005b70:	20001460 	.word	0x20001460
 8005b74:	200013b0 	.word	0x200013b0
 8005b78:	f3af 8000 	nop.w
 8005b7c:	f3af 8000 	nop.w

08005b80 <chMtxTryLock.constprop.61>:
 8005b80:	2320      	movs	r3, #32
 8005b82:	f383 8811 	msr	BASEPRI, r3
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8005b86:	4b09      	ldr	r3, [pc, #36]	; (8005bac <chMtxTryLock.constprop.61+0x2c>)
 8005b88:	689a      	ldr	r2, [r3, #8]
    if (mp->owner == currp) {
      mp->cnt++;
      return true;
    }
#endif
    return false;
 8005b8a:	2000      	movs	r0, #0
bool chMtxTryLockS(mutex_t *mp) {

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  if (mp->owner != NULL) {
 8005b8c:	b11a      	cbz	r2, 8005b96 <chMtxTryLock.constprop.61+0x16>
 8005b8e:	2300      	movs	r3, #0
 8005b90:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8005b94:	4770      	bx	lr

  chDbgAssert(mp->cnt == (cnt_t)0, "counter is not zero");

  mp->cnt++;
#endif
  mp->owner = currp;
 8005b96:	4a06      	ldr	r2, [pc, #24]	; (8005bb0 <chMtxTryLock.constprop.61+0x30>)
 8005b98:	6992      	ldr	r2, [r2, #24]
 8005b9a:	609a      	str	r2, [r3, #8]
  mp->next = currp->mtxlist;
 8005b9c:	6b91      	ldr	r1, [r2, #56]	; 0x38
 8005b9e:	60d9      	str	r1, [r3, #12]
  currp->mtxlist = mp;
 8005ba0:	6393      	str	r3, [r2, #56]	; 0x38
 8005ba2:	2001      	movs	r0, #1
 8005ba4:	2300      	movs	r3, #0
 8005ba6:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  b = chMtxTryLockS(mp);
  chSysUnlock();

  return b;
}
 8005baa:	4770      	bx	lr
 8005bac:	200008a0 	.word	0x200008a0
 8005bb0:	200013b0 	.word	0x200013b0
 8005bb4:	f3af 8000 	nop.w
 8005bb8:	f3af 8000 	nop.w
 8005bbc:	f3af 8000 	nop.w

08005bc0 <chCondSignal.constprop.59>:
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @api
 */
void chCondSignal(condition_variable_t *cp) {
 8005bc0:	b508      	push	{r3, lr}
 8005bc2:	2320      	movs	r3, #32
 8005bc4:	f383 8811 	msr	BASEPRI, r3
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005bc8:	4b06      	ldr	r3, [pc, #24]	; (8005be4 <chCondSignal.constprop.59+0x24>)
 8005bca:	6818      	ldr	r0, [r3, #0]

  chDbgCheck(cp != NULL);

  chSysLock();
  if (queue_notempty(&cp->queue)) {
 8005bcc:	4298      	cmp	r0, r3
 8005bce:	d005      	beq.n	8005bdc <chCondSignal.constprop.59+0x1c>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005bd0:	6802      	ldr	r2, [r0, #0]
 8005bd2:	601a      	str	r2, [r3, #0]
  tqp->next->queue.prev = (thread_t *)tqp;
 8005bd4:	6053      	str	r3, [r2, #4]
    chSchWakeupS(queue_fifo_remove(&cp->queue), MSG_OK);
 8005bd6:	2100      	movs	r1, #0
 8005bd8:	f7ff fb92 	bl	8005300 <chSchWakeupS>
 8005bdc:	2300      	movs	r3, #0
 8005bde:	f383 8811 	msr	BASEPRI, r3
 8005be2:	bd08      	pop	{r3, pc}
 8005be4:	20000858 	.word	0x20000858
 8005be8:	f3af 8000 	nop.w
 8005bec:	f3af 8000 	nop.w

08005bf0 <chCondSignalI.constprop.58>:
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->next != (const thread_t *)tqp);
 8005bf0:	4b07      	ldr	r3, [pc, #28]	; (8005c10 <chCondSignalI.constprop.58+0x20>)
 8005bf2:	681a      	ldr	r2, [r3, #0]
void chCondSignalI(condition_variable_t *cp) {

  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
 8005bf4:	429a      	cmp	r2, r3
 8005bf6:	d00a      	beq.n	8005c0e <chCondSignalI.constprop.58+0x1e>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005bf8:	6811      	ldr	r1, [r2, #0]
 *
 * @param[in] cp        pointer to the @p condition_variable_t structure
 *
 * @iclass
 */
void chCondSignalI(condition_variable_t *cp) {
 8005bfa:	b410      	push	{r4}
  chDbgCheckClassI();
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
 8005bfc:	2400      	movs	r4, #0
  tqp->next->queue.prev = (thread_t *)tqp;
 8005bfe:	604b      	str	r3, [r1, #4]
 8005c00:	6254      	str	r4, [r2, #36]	; 0x24
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->next;

  tqp->next             = tp->queue.next;
 8005c02:	6019      	str	r1, [r3, #0]
    (void) chSchReadyI(tp);
 8005c04:	4610      	mov	r0, r2
  }
}
 8005c06:	f85d 4b04 	ldr.w	r4, [sp], #4
  chDbgCheck(cp != NULL);

  if (queue_notempty(&cp->queue)) {
    thread_t *tp = queue_fifo_remove(&cp->queue);
    tp->u.rdymsg = MSG_OK;
    (void) chSchReadyI(tp);
 8005c0a:	f7ff bc29 	b.w	8005460 <chSchReadyI>
 8005c0e:	4770      	bx	lr
 8005c10:	20000858 	.word	0x20000858
 8005c14:	f3af 8000 	nop.w
 8005c18:	f3af 8000 	nop.w
 8005c1c:	f3af 8000 	nop.w

08005c20 <chEvtGetAndClearEvents.constprop.50>:
 8005c20:	2320      	movs	r3, #32
 8005c22:	f383 8811 	msr	BASEPRI, r3
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8005c26:	4b04      	ldr	r3, [pc, #16]	; (8005c38 <chEvtGetAndClearEvents.constprop.50+0x18>)
 8005c28:	699a      	ldr	r2, [r3, #24]
  currp->epending &= ~events;
 8005c2a:	2300      	movs	r3, #0
 */
eventmask_t chEvtGetAndClearEvents(eventmask_t events) {
  eventmask_t m;

  chSysLock();
  m = currp->epending & events;
 8005c2c:	6b50      	ldr	r0, [r2, #52]	; 0x34
  currp->epending &= ~events;
 8005c2e:	6353      	str	r3, [r2, #52]	; 0x34
 8005c30:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8005c34:	4770      	bx	lr
 8005c36:	bf00      	nop
 8005c38:	200013b0 	.word	0x200013b0
 8005c3c:	f3af 8000 	nop.w

08005c40 <chEvtWaitOne.constprop.46>:
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
  thread_t *ctp = currp;
 8005c40:	4a0b      	ldr	r2, [pc, #44]	; (8005c70 <chEvtWaitOne.constprop.46+0x30>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the lowest event id served and cleared.
 *
 * @api
 */
eventmask_t chEvtWaitOne(eventmask_t events) {
 8005c42:	b510      	push	{r4, lr}
 8005c44:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8005c46:	6994      	ldr	r4, [r2, #24]
 8005c48:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8005c4c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8005c4e:	b933      	cbnz	r3, 8005c5e <chEvtWaitOne.constprop.46+0x1e>
    ctp->u.ewmask = events;
 8005c50:	f04f 33ff 	mov.w	r3, #4294967295
 8005c54:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005c56:	200a      	movs	r0, #10
 8005c58:	f7ff fba2 	bl	80053a0 <chSchGoSleepS>
    m = ctp->epending & events;
 8005c5c:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  m ^= m & (m - (eventmask_t)1);
 8005c5e:	4258      	negs	r0, r3
 8005c60:	4018      	ands	r0, r3
  ctp->epending &= ~m;
 8005c62:	ea23 0300 	bic.w	r3, r3, r0
 8005c66:	6363      	str	r3, [r4, #52]	; 0x34
 8005c68:	2300      	movs	r3, #0
 8005c6a:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8005c6e:	bd10      	pop	{r4, pc}
 8005c70:	200013b0 	.word	0x200013b0
 8005c74:	f3af 8000 	nop.w
 8005c78:	f3af 8000 	nop.w
 8005c7c:	f3af 8000 	nop.w

08005c80 <chEvtWaitAny.constprop.45>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
  thread_t *ctp = currp;
 8005c80:	4a09      	ldr	r2, [pc, #36]	; (8005ca8 <chEvtWaitAny.constprop.45+0x28>)
 *                      for, @p ALL_EVENTS enables all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAny(eventmask_t events) {
 8005c82:	b510      	push	{r4, lr}
 8005c84:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8005c86:	6994      	ldr	r4, [r2, #24]
 8005c88:	f383 8811 	msr	BASEPRI, r3
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
 8005c8c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  if (m == (eventmask_t)0) {
 8005c8e:	b930      	cbnz	r0, 8005c9e <chEvtWaitAny.constprop.45+0x1e>
    ctp->u.ewmask = events;
 8005c90:	f04f 33ff 	mov.w	r3, #4294967295
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005c94:	200a      	movs	r0, #10
  eventmask_t m;

  chSysLock();
  m = ctp->epending & events;
  if (m == (eventmask_t)0) {
    ctp->u.ewmask = events;
 8005c96:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTOREVT);
 8005c98:	f7ff fb82 	bl	80053a0 <chSchGoSleepS>
    m = ctp->epending & events;
 8005c9c:	6b60      	ldr	r0, [r4, #52]	; 0x34
  }
  ctp->epending &= ~m;
 8005c9e:	2300      	movs	r3, #0
 8005ca0:	6363      	str	r3, [r4, #52]	; 0x34
 8005ca2:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return m;
}
 8005ca6:	bd10      	pop	{r4, pc}
 8005ca8:	200013b0 	.word	0x200013b0
 8005cac:	f3af 8000 	nop.w

08005cb0 <chEvtWaitAll.constprop.44>:
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
  thread_t *ctp = currp;
 8005cb0:	4a0c      	ldr	r2, [pc, #48]	; (8005ce4 <chEvtWaitAll.constprop.44+0x34>)
 *                      for, @p ALL_EVENTS requires all the events
 * @return              The mask of the served and cleared events.
 *
 * @api
 */
eventmask_t chEvtWaitAll(eventmask_t events) {
 8005cb2:	b510      	push	{r4, lr}
 8005cb4:	2320      	movs	r3, #32
  thread_t *ctp = currp;
 8005cb6:	6994      	ldr	r4, [r2, #24]
 8005cb8:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  if ((ctp->epending & events) != events) {
 8005cbc:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005cbe:	f003 0205 	and.w	r2, r3, #5
 8005cc2:	2a05      	cmp	r2, #5
 8005cc4:	d005      	beq.n	8005cd2 <chEvtWaitAll.constprop.44+0x22>
    ctp->u.ewmask = events;
 8005cc6:	2305      	movs	r3, #5
 8005cc8:	6263      	str	r3, [r4, #36]	; 0x24
    chSchGoSleepS(CH_STATE_WTANDEVT);
 8005cca:	200b      	movs	r0, #11
 8005ccc:	f7ff fb68 	bl	80053a0 <chSchGoSleepS>
 8005cd0:	6b63      	ldr	r3, [r4, #52]	; 0x34
  }
  ctp->epending &= ~events;
 8005cd2:	f023 0305 	bic.w	r3, r3, #5
 8005cd6:	6363      	str	r3, [r4, #52]	; 0x34
 8005cd8:	2300      	movs	r3, #0
 8005cda:	f383 8811 	msr	BASEPRI, r3
  chSysUnlock();

  return events;
}
 8005cde:	2005      	movs	r0, #5
 8005ce0:	bd10      	pop	{r4, pc}
 8005ce2:	bf00      	nop
 8005ce4:	200013b0 	.word	0x200013b0
 8005ce8:	f3af 8000 	nop.w
 8005cec:	f3af 8000 	nop.w

08005cf0 <chHeapAllocAligned.constprop.40>:
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8005cf0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

  chDbgCheck((size > 0U) && MEM_IS_VALID_ALIGNMENT(align));

  /* If an heap is not specified then the default system header is used.*/
  if (heapp == NULL) {
    heapp = &default_heap;
 8005cf4:	4d3a      	ldr	r5, [pc, #232]	; (8005de0 <chHeapAllocAligned.constprop.40+0xf0>)
 8005cf6:	2800      	cmp	r0, #0
 8005cf8:	bf18      	it	ne
 8005cfa:	4605      	movne	r5, r0

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005cfc:	f105 0710 	add.w	r7, r5, #16
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8005d00:	1dce      	adds	r6, r1, #7

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005d02:	4638      	mov	r0, r7
 * @return              A pointer to the aligned allocated block.
 * @retval NULL         if the block cannot be allocated.
 *
 * @api
 */
void *chHeapAllocAligned(memory_heap_t *heapp, size_t size, unsigned align) {
 8005d04:	460c      	mov	r4, r1
  if (align < CH_HEAP_ALIGNMENT) {
    align = CH_HEAP_ALIGNMENT;
  }

  /* Size is converted in number of elementary allocation units.*/
  pages = MEM_ALIGN_NEXT(size, CH_HEAP_ALIGNMENT) / CH_HEAP_ALIGNMENT;
 8005d06:	08f6      	lsrs	r6, r6, #3

  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);
 8005d08:	f7ff fc8a 	bl	8005620 <chMtxLock>

  /* Start of the free blocks list.*/
  qp = &heapp->header;
 8005d0c:	f105 0e08 	add.w	lr, r5, #8
  while (H_NEXT(qp) != NULL) {
 8005d10:	f8de 3000 	ldr.w	r3, [lr]

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d14:	f103 020f 	add.w	r2, r3, #15
 8005d18:	f022 0207 	bic.w	r2, r2, #7
 8005d1c:	3a08      	subs	r2, #8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d1e:	1a98      	subs	r0, r3, r2

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d20:	f103 0808 	add.w	r8, r3, #8
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8005d24:	b183      	cbz	r3, 8005d48 <chHeapAllocAligned.constprop.40+0x58>
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d26:	f8d3 c004 	ldr.w	ip, [r3, #4]
 8005d2a:	f10c 0101 	add.w	r1, ip, #1
 8005d2e:	00c9      	lsls	r1, r1, #3
 8005d30:	f1a1 0908 	sub.w	r9, r1, #8
 8005d34:	4419      	add	r1, r3
 8005d36:	4448      	add	r0, r9
 8005d38:	428a      	cmp	r2, r1
 8005d3a:	ea4f 00e0 	mov.w	r0, r0, asr #3
 8005d3e:	d201      	bcs.n	8005d44 <chHeapAllocAligned.constprop.40+0x54>
 8005d40:	4286      	cmp	r6, r0
 8005d42:	d912      	bls.n	8005d6a <chHeapAllocAligned.constprop.40+0x7a>
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8005d44:	469e      	mov	lr, r3
 8005d46:	e7e3      	b.n	8005d10 <chHeapAllocAligned.constprop.40+0x20>
    /* Next in the free blocks list.*/
    qp = hp;
  }

  /* Releasing heap mutex/semaphore.*/
  H_UNLOCK(heapp);
 8005d48:	4638      	mov	r0, r7
 8005d4a:	f7ff fbc9 	bl	80054e0 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->provider != NULL) {
 8005d4e:	682b      	ldr	r3, [r5, #0]
 8005d50:	2b00      	cmp	r3, #0
 8005d52:	d042      	beq.n	8005dda <chHeapAllocAligned.constprop.40+0xea>
    hp = heapp->provider((pages + 1U) * CH_HEAP_ALIGNMENT, align);
 8005d54:	1c70      	adds	r0, r6, #1
 8005d56:	00c0      	lsls	r0, r0, #3
 8005d58:	2108      	movs	r1, #8
 8005d5a:	4798      	blx	r3
    if (hp != NULL) {
 8005d5c:	2800      	cmp	r0, #0
 8005d5e:	d03c      	beq.n	8005dda <chHeapAllocAligned.constprop.40+0xea>
      H_HEAP(hp) = heapp;
 8005d60:	6005      	str	r5, [r0, #0]
      H_SIZE(hp) = size;
 8005d62:	6044      	str	r4, [r0, #4]

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8005d64:	3008      	adds	r0, #8
      /*lint -restore*/
    }
  }

  return NULL;
}
 8005d66:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8005d6a:	4293      	cmp	r3, r2
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
 8005d6c:	4611      	mov	r1, r2

    /* Next free block.*/
    hp = H_NEXT(qp);

    /* Pointer aligned to the requested alignment.*/
    ahp = (heap_header_t *)MEM_ALIGN_NEXT(H_BLOCK(hp), align) - 1U;
 8005d6e:	46c2      	mov	sl, r8

    if ((ahp < H_LIMIT(hp)) && (pages <= NPAGES(H_LIMIT(hp), ahp + 1U))) {
      /* The block is large enough to contain a correctly aligned area
         of sufficient size.*/

      if (ahp > hp) {
 8005d70:	d217      	bcs.n	8005da2 <chHeapAllocAligned.constprop.40+0xb2>
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005d72:	ebc8 0e02 	rsb	lr, r8, r2
 8005d76:	ea4f 0eee 	mov.w	lr, lr, asr #3
        if (bpages > pages) {
 8005d7a:	4286      	cmp	r6, r0
      if (ahp > hp) {
        /* The block is not properly aligned, must split it.*/
        size_t bpages;

        bpages = NPAGES(H_LIMIT(hp), H_BLOCK(ahp));
        H_PAGES(hp) = NPAGES(ahp, H_BLOCK(hp));
 8005d7c:	f8c3 e004 	str.w	lr, [r3, #4]
        if (bpages > pages) {
 8005d80:	d20c      	bcs.n	8005d9c <chHeapAllocAligned.constprop.40+0xac>
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
 8005d82:	f106 0e01 	add.w	lr, r6, #1
 8005d86:	ea6f 0c06 	mvn.w	ip, r6
 8005d8a:	eb02 06ce 	add.w	r6, r2, lr, lsl #3
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005d8e:	4460      	add	r0, ip

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8005d90:	f8d3 c000 	ldr.w	ip, [r3]
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          /* Creating the excess block.*/
          fp = H_BLOCK(ahp) + pages;
          H_PAGES(fp) = (bpages - pages) - 1U;
 8005d94:	6070      	str	r0, [r6, #4]

          /* Linking the excess block.*/
          H_NEXT(fp) = H_NEXT(hp);
 8005d96:	f842 c03e 	str.w	ip, [r2, lr, lsl #3]
          H_NEXT(hp) = fp;
 8005d9a:	601e      	str	r6, [r3, #0]
 8005d9c:	f102 0a08 	add.w	sl, r2, #8
 8005da0:	e00e      	b.n	8005dc0 <chHeapAllocAligned.constprop.40+0xd0>
        hp = ahp;
      }
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
 8005da2:	4566      	cmp	r6, ip
 8005da4:	d014      	beq.n	8005dd0 <chHeapAllocAligned.constprop.40+0xe0>
        }
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
 8005da6:	3601      	adds	r6, #1
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005da8:	eb03 00c6 	add.w	r0, r3, r6, lsl #3
 8005dac:	eba9 02c6 	sub.w	r2, r9, r6, lsl #3
        else {
          /* The block is bigger than required, must split the excess.*/
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
 8005db0:	6819      	ldr	r1, [r3, #0]
 8005db2:	f843 1036 	str.w	r1, [r3, r6, lsl #3]
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
 8005db6:	10d2      	asrs	r2, r2, #3
 8005db8:	6042      	str	r2, [r0, #4]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8005dba:	4619      	mov	r1, r3
          heap_header_t *fp;

          fp = H_BLOCK(hp) + pages;
          H_NEXT(fp) = H_NEXT(hp);
          H_PAGES(fp) = NPAGES(H_LIMIT(hp), H_BLOCK(fp));
          H_NEXT(qp) = fp;
 8005dbc:	f8ce 0000 	str.w	r0, [lr]
      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
      H_HEAP(hp) = heapp;

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 8005dc0:	4638      	mov	r0, r7
          H_NEXT(qp) = fp;
        }
      }

      /* Setting in the block owner heap and size.*/
      H_SIZE(hp) = size;
 8005dc2:	604c      	str	r4, [r1, #4]
      H_HEAP(hp) = heapp;
 8005dc4:	600d      	str	r5, [r1, #0]

      /* Releasing heap mutex/semaphore.*/
      H_UNLOCK(heapp);
 8005dc6:	f7ff fb8b 	bl	80054e0 <chMtxUnlock>

      /*lint -save -e9087 [11.3] Safe cast.*/
      return (void *)H_BLOCK(hp);
 8005dca:	4650      	mov	r0, sl
 8005dcc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
      else {
        /* The block is already properly aligned.*/

        if (H_PAGES(hp) == pages) {
          /* Exact size, getting the whole block.*/
          H_NEXT(qp) = H_NEXT(hp);
 8005dd0:	681a      	ldr	r2, [r3, #0]
 8005dd2:	f8ce 2000 	str.w	r2, [lr]
  /* Taking heap mutex/semaphore.*/
  H_LOCK(heapp);

  /* Start of the free blocks list.*/
  qp = &heapp->header;
  while (H_NEXT(qp) != NULL) {
 8005dd6:	4619      	mov	r1, r3
 8005dd8:	e7f2      	b.n	8005dc0 <chHeapAllocAligned.constprop.40+0xd0>
      return (void *)H_BLOCK(hp);
      /*lint -restore*/
    }
  }

  return NULL;
 8005dda:	2000      	movs	r0, #0
 8005ddc:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8005de0:	20001480 	.word	0x20001480
 8005de4:	f3af 8000 	nop.w
 8005de8:	f3af 8000 	nop.w
 8005dec:	f3af 8000 	nop.w

08005df0 <chThdCreateFromHeap.constprop.39>:
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8005df0:	b5f0      	push	{r4, r5, r6, r7, lr}
 8005df2:	4604      	mov	r4, r0
 8005df4:	b087      	sub	sp, #28
 8005df6:	460f      	mov	r7, r1
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8005df8:	4810      	ldr	r0, [pc, #64]	; (8005e3c <chThdCreateFromHeap.constprop.39+0x4c>)
 8005dfa:	4621      	mov	r1, r4
 *                      the thread into the working space area.
 * @retval NULL         if the memory cannot be allocated.
 *
 * @api
 */
thread_t *chThdCreateFromHeap(memory_heap_t *heapp, size_t size,
 8005dfc:	4616      	mov	r6, r2
 8005dfe:	461d      	mov	r5, r3
                              const char *name, tprio_t prio,
                              tfunc_t pf, void *arg) {
  thread_t *tp;
  void *wsp;

  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
 8005e00:	f7ff ff76 	bl	8005cf0 <chHeapAllocAligned.constprop.40>
  if (wsp == NULL) {
 8005e04:	b1c0      	cbz	r0, 8005e38 <chThdCreateFromHeap.constprop.39+0x48>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + size),
 8005e06:	4404      	add	r4, r0
  wsp = chHeapAllocAligned(heapp, size, PORT_WORKING_AREA_ALIGN);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8005e08:	4b0d      	ldr	r3, [pc, #52]	; (8005e40 <chThdCreateFromHeap.constprop.39+0x50>)
 8005e0a:	9304      	str	r3, [sp, #16]
 8005e0c:	9402      	str	r4, [sp, #8]
 8005e0e:	9700      	str	r7, [sp, #0]
 8005e10:	9001      	str	r0, [sp, #4]
 8005e12:	9603      	str	r6, [sp, #12]
 8005e14:	9505      	str	r5, [sp, #20]
 8005e16:	2320      	movs	r3, #32
 8005e18:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005e1c:	4668      	mov	r0, sp
 8005e1e:	f7ff f9c7 	bl	80051b0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_HEAP;
 8005e22:	2301      	movs	r3, #1
 8005e24:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  chSchWakeupS(tp, MSG_OK);
 8005e28:	2100      	movs	r1, #0
                  (uint8_t *)wsp + size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005e2a:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_HEAP;
  chSchWakeupS(tp, MSG_OK);
 8005e2c:	f7ff fa68 	bl	8005300 <chSchWakeupS>
 8005e30:	2300      	movs	r3, #0
 8005e32:	f383 8811 	msr	BASEPRI, r3
 8005e36:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 8005e38:	b007      	add	sp, #28
 8005e3a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005e3c:	20001430 	.word	0x20001430
 8005e40:	08004951 	.word	0x08004951
 8005e44:	f3af 8000 	nop.w
 8005e48:	f3af 8000 	nop.w
 8005e4c:	f3af 8000 	nop.w

08005e50 <chThdCreateFromMemoryPool.constprop.38>:
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8005e50:	b5f0      	push	{r4, r5, r6, r7, lr}
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8005e52:	4d13      	ldr	r5, [pc, #76]	; (8005ea0 <chThdCreateFromMemoryPool.constprop.38+0x50>)
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8005e54:	b087      	sub	sp, #28
 8005e56:	4607      	mov	r7, r0
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8005e58:	4628      	mov	r0, r5
 *                      the thread into the working space area.
 * @retval  NULL        if the memory pool is empty.
 *
 * @api
 */
thread_t *chThdCreateFromMemoryPool(memory_pool_t *mp, const char *name,
 8005e5a:	460e      	mov	r6, r1
 8005e5c:	4614      	mov	r4, r2
  thread_t *tp;
  void *wsp;

  chDbgCheck(mp != NULL);

  wsp = chPoolAlloc(mp);
 8005e5e:	f7fe f977 	bl	8004150 <chPoolAlloc>
  if (wsp == NULL) {
 8005e62:	b1d0      	cbz	r0, 8005e9a <chThdCreateFromMemoryPool.constprop.38+0x4a>
  }

  thread_descriptor_t td = {
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8005e64:	686b      	ldr	r3, [r5, #4]
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8005e66:	4a0f      	ldr	r2, [pc, #60]	; (8005ea4 <chThdCreateFromMemoryPool.constprop.38+0x54>)
 8005e68:	9700      	str	r7, [sp, #0]
    name,
    wsp,
    (stkalign_t *)((uint8_t *)wsp + mp->object_size),
 8005e6a:	4403      	add	r3, r0
  wsp = chPoolAlloc(mp);
  if (wsp == NULL) {
    return NULL;
  }

  thread_descriptor_t td = {
 8005e6c:	9302      	str	r3, [sp, #8]
 8005e6e:	9001      	str	r0, [sp, #4]
 8005e70:	9603      	str	r6, [sp, #12]
 8005e72:	9405      	str	r4, [sp, #20]
 8005e74:	9204      	str	r2, [sp, #16]
 8005e76:	2320      	movs	r3, #32
 8005e78:	f383 8811 	msr	BASEPRI, r3
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005e7c:	4668      	mov	r0, sp
 8005e7e:	f7ff f997 	bl	80051b0 <chThdCreateSuspendedI>
  tp->flags = CH_FLAG_MODE_MPOOL;
 8005e82:	2302      	movs	r3, #2
 8005e84:	f880 3021 	strb.w	r3, [r0, #33]	; 0x21
  tp->mpool = mp;
 8005e88:	6405      	str	r5, [r0, #64]	; 0x40
  chSchWakeupS(tp, MSG_OK);
 8005e8a:	2100      	movs	r1, #0
                  (uint8_t *)wsp + mp->object_size,
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateSuspendedI(&td);
 8005e8c:	4604      	mov	r4, r0
  tp->flags = CH_FLAG_MODE_MPOOL;
  tp->mpool = mp;
  chSchWakeupS(tp, MSG_OK);
 8005e8e:	f7ff fa37 	bl	8005300 <chSchWakeupS>
 8005e92:	2300      	movs	r3, #0
 8005e94:	f383 8811 	msr	BASEPRI, r3
 8005e98:	4620      	mov	r0, r4
  chSysUnlock();

  return tp;
}
 8005e9a:	b007      	add	sp, #28
 8005e9c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8005e9e:	bf00      	nop
 8005ea0:	20001470 	.word	0x20001470
 8005ea4:	08004951 	.word	0x08004951
 8005ea8:	f3af 8000 	nop.w
 8005eac:	f3af 8000 	nop.w

08005eb0 <chMBResetI.constprop.30>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBResetI(mailbox_t *mbp) {
 8005eb0:	b510      	push	{r4, lr}

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8005eb2:	4c09      	ldr	r4, [pc, #36]	; (8005ed8 <chMBResetI.constprop.30+0x28>)
 8005eb4:	6823      	ldr	r3, [r4, #0]
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8005eb6:	6861      	ldr	r1, [r4, #4]
void chMBResetI(mailbox_t *mbp) {

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
 8005eb8:	60a3      	str	r3, [r4, #8]
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8005eba:	1ac9      	subs	r1, r1, r3
 8005ebc:	f104 001c 	add.w	r0, r4, #28
 8005ec0:	1089      	asrs	r1, r1, #2

  chDbgCheckClassI();
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
 8005ec2:	60e3      	str	r3, [r4, #12]
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
 8005ec4:	f7ff fbcc 	bl	8005660 <chSemResetI>
  chSemResetI(&mbp->fullsem, (cnt_t)0);
 8005ec8:	f104 0010 	add.w	r0, r4, #16
 8005ecc:	2100      	movs	r1, #0
}
 8005ece:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  chDbgCheck(mbp != NULL);

  mbp->wrptr = mbp->buffer;
  mbp->rdptr = mbp->buffer;
  chSemResetI(&mbp->emptysem, (cnt_t)(mbp->top - mbp->buffer));
  chSemResetI(&mbp->fullsem, (cnt_t)0);
 8005ed2:	f7ff bbc5 	b.w	8005660 <chSemResetI>
 8005ed6:	bf00      	nop
 8005ed8:	20000860 	.word	0x20000860
 8005edc:	f3af 8000 	nop.w

08005ee0 <chMBReset.constprop.29>:
 *
 * @param[in] mbp       the pointer to an initialized @p mailbox_t object
 *
 * @api
 */
void chMBReset(mailbox_t *mbp) {
 8005ee0:	b508      	push	{r3, lr}
 8005ee2:	2320      	movs	r3, #32
 8005ee4:	f383 8811 	msr	BASEPRI, r3

  chSysLock();
  chMBResetI(mbp);
 8005ee8:	f7ff ffe2 	bl	8005eb0 <chMBResetI.constprop.30>
  chSchRescheduleS();
 8005eec:	f7ff f9c8 	bl	8005280 <chSchRescheduleS>
 8005ef0:	2300      	movs	r3, #0
 8005ef2:	f383 8811 	msr	BASEPRI, r3
 8005ef6:	bd08      	pop	{r3, pc}
 8005ef8:	f3af 8000 	nop.w
 8005efc:	f3af 8000 	nop.w

08005f00 <chMBPost.constprop.28>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPost(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8005f00:	b570      	push	{r4, r5, r6, lr}
 8005f02:	2320      	movs	r3, #32
 8005f04:	4606      	mov	r6, r0
 8005f06:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 8005f0a:	4c0d      	ldr	r4, [pc, #52]	; (8005f40 <chMBPost.constprop.28+0x40>)
 8005f0c:	f104 001c 	add.w	r0, r4, #28
 8005f10:	f7ff fc96 	bl	8005840 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8005f14:	4605      	mov	r5, r0
 8005f16:	b968      	cbnz	r0, 8005f34 <chMBPost.constprop.28+0x34>
    *mbp->wrptr++ = msg;
 8005f18:	68a2      	ldr	r2, [r4, #8]
    if (mbp->wrptr >= mbp->top) {
 8005f1a:	6861      	ldr	r1, [r4, #4]
      mbp->wrptr = mbp->buffer;
    }
    chSemSignalI(&mbp->fullsem);
 8005f1c:	4809      	ldr	r0, [pc, #36]	; (8005f44 <chMBPost.constprop.28+0x44>)
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->wrptr++ = msg;
 8005f1e:	1d13      	adds	r3, r2, #4
    if (mbp->wrptr >= mbp->top) {
 8005f20:	428b      	cmp	r3, r1
  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    *mbp->wrptr++ = msg;
 8005f22:	60a3      	str	r3, [r4, #8]
 8005f24:	6016      	str	r6, [r2, #0]
    if (mbp->wrptr >= mbp->top) {
      mbp->wrptr = mbp->buffer;
 8005f26:	bf24      	itt	cs
 8005f28:	6823      	ldrcs	r3, [r4, #0]
 8005f2a:	60a3      	strcs	r3, [r4, #8]
    }
    chSemSignalI(&mbp->fullsem);
 8005f2c:	f7ff fb88 	bl	8005640 <chSemSignalI>
    chSchRescheduleS();
 8005f30:	f7ff f9a6 	bl	8005280 <chSchRescheduleS>
 8005f34:	2300      	movs	r3, #0
 8005f36:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005f3a:	4628      	mov	r0, r5
 8005f3c:	bd70      	pop	{r4, r5, r6, pc}
 8005f3e:	bf00      	nop
 8005f40:	20000860 	.word	0x20000860
 8005f44:	20000870 	.word	0x20000870
 8005f48:	f3af 8000 	nop.w
 8005f4c:	f3af 8000 	nop.w

08005f50 <chMBPostAhead.constprop.26>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBPostAhead(mailbox_t *mbp, msg_t msg, systime_t timeout) {
 8005f50:	b570      	push	{r4, r5, r6, lr}
 8005f52:	2320      	movs	r3, #32
 8005f54:	4606      	mov	r6, r0
 8005f56:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
 8005f5a:	4c0e      	ldr	r4, [pc, #56]	; (8005f94 <chMBPostAhead.constprop.26+0x44>)
 8005f5c:	f104 001c 	add.w	r0, r4, #28
 8005f60:	f7ff fc6e 	bl	8005840 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8005f64:	4605      	mov	r5, r0
 8005f66:	b958      	cbnz	r0, 8005f80 <chMBPostAhead.constprop.26+0x30>
    if (--mbp->rdptr < mbp->buffer) {
 8005f68:	68e3      	ldr	r3, [r4, #12]
 8005f6a:	6822      	ldr	r2, [r4, #0]
 8005f6c:	3b04      	subs	r3, #4
 8005f6e:	4293      	cmp	r3, r2
 8005f70:	60e3      	str	r3, [r4, #12]
 8005f72:	d30a      	bcc.n	8005f8a <chMBPostAhead.constprop.26+0x3a>
      mbp->rdptr = mbp->top - 1;
    }
    *mbp->rdptr = msg;
 8005f74:	601e      	str	r6, [r3, #0]
    chSemSignalI(&mbp->fullsem);
 8005f76:	4808      	ldr	r0, [pc, #32]	; (8005f98 <chMBPostAhead.constprop.26+0x48>)
 8005f78:	f7ff fb62 	bl	8005640 <chSemSignalI>
    chSchRescheduleS();
 8005f7c:	f7ff f980 	bl	8005280 <chSchRescheduleS>
 8005f80:	2300      	movs	r3, #0
 8005f82:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBPostAheadS(mbp, msg, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005f86:	4628      	mov	r0, r5
 8005f88:	bd70      	pop	{r4, r5, r6, pc}
  chDbgCheck(mbp != NULL);

  rdymsg = chSemWaitTimeoutS(&mbp->emptysem, timeout);
  if (rdymsg == MSG_OK) {
    if (--mbp->rdptr < mbp->buffer) {
      mbp->rdptr = mbp->top - 1;
 8005f8a:	6863      	ldr	r3, [r4, #4]
 8005f8c:	3b04      	subs	r3, #4
 8005f8e:	60e3      	str	r3, [r4, #12]
 8005f90:	e7f0      	b.n	8005f74 <chMBPostAhead.constprop.26+0x24>
 8005f92:	bf00      	nop
 8005f94:	20000860 	.word	0x20000860
 8005f98:	20000870 	.word	0x20000870
 8005f9c:	f3af 8000 	nop.w

08005fa0 <chMBFetch.constprop.24>:
 * @retval MSG_RESET    if the mailbox has been reset while waiting.
 * @retval MSG_TIMEOUT  if the operation has timed out.
 *
 * @api
 */
msg_t chMBFetch(mailbox_t *mbp, msg_t *msgp, systime_t timeout) {
 8005fa0:	b570      	push	{r4, r5, r6, lr}
 8005fa2:	2320      	movs	r3, #32
 8005fa4:	4606      	mov	r6, r0
 8005fa6:	f383 8811 	msr	BASEPRI, r3
  msg_t rdymsg;

  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
 8005faa:	4c0d      	ldr	r4, [pc, #52]	; (8005fe0 <chMBFetch.constprop.24+0x40>)
 8005fac:	f104 0010 	add.w	r0, r4, #16
 8005fb0:	f7ff fc46 	bl	8005840 <chSemWaitTimeoutS>
  if (rdymsg == MSG_OK) {
 8005fb4:	4605      	mov	r5, r0
 8005fb6:	b970      	cbnz	r0, 8005fd6 <chMBFetch.constprop.24+0x36>
    *msgp = *mbp->rdptr++;
 8005fb8:	68e3      	ldr	r3, [r4, #12]
    if (mbp->rdptr >= mbp->top) {
 8005fba:	6862      	ldr	r2, [r4, #4]
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 8005fbc:	6819      	ldr	r1, [r3, #0]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
    }
    chSemSignalI(&mbp->emptysem);
 8005fbe:	4809      	ldr	r0, [pc, #36]	; (8005fe4 <chMBFetch.constprop.24+0x44>)
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 8005fc0:	3304      	adds	r3, #4
    if (mbp->rdptr >= mbp->top) {
 8005fc2:	4293      	cmp	r3, r2
  chDbgCheckClassS();
  chDbgCheck((mbp != NULL) && (msgp != NULL));

  rdymsg = chSemWaitTimeoutS(&mbp->fullsem, timeout);
  if (rdymsg == MSG_OK) {
    *msgp = *mbp->rdptr++;
 8005fc4:	60e3      	str	r3, [r4, #12]
 8005fc6:	6031      	str	r1, [r6, #0]
    if (mbp->rdptr >= mbp->top) {
      mbp->rdptr = mbp->buffer;
 8005fc8:	bf24      	itt	cs
 8005fca:	6823      	ldrcs	r3, [r4, #0]
 8005fcc:	60e3      	strcs	r3, [r4, #12]
    }
    chSemSignalI(&mbp->emptysem);
 8005fce:	f7ff fb37 	bl	8005640 <chSemSignalI>
    chSchRescheduleS();
 8005fd2:	f7ff f955 	bl	8005280 <chSchRescheduleS>
 8005fd6:	2300      	movs	r3, #0
 8005fd8:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  rdymsg = chMBFetchS(mbp, msgp, timeout);
  chSysUnlock();

  return rdymsg;
}
 8005fdc:	4628      	mov	r0, r5
 8005fde:	bd70      	pop	{r4, r5, r6, pc}
 8005fe0:	20000860 	.word	0x20000860
 8005fe4:	2000087c 	.word	0x2000087c
 8005fe8:	f3af 8000 	nop.w
 8005fec:	f3af 8000 	nop.w

08005ff0 <chGuardedPoolAllocTimeout.constprop.18>:
 * @return              The pointer to the allocated object.
 * @retval NULL         if the operation timed out.
 *
 * @api
 */
void *chGuardedPoolAllocTimeout(guarded_memory_pool_t *gmp,
 8005ff0:	b510      	push	{r4, lr}
 8005ff2:	4601      	mov	r1, r0
 8005ff4:	2320      	movs	r3, #32
 8005ff6:	f383 8811 	msr	BASEPRI, r3
 */
void *chGuardedPoolAllocTimeoutS(guarded_memory_pool_t *gmp,
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
 8005ffa:	4c0d      	ldr	r4, [pc, #52]	; (8006030 <chGuardedPoolAllocTimeout.constprop.18+0x40>)
 8005ffc:	4620      	mov	r0, r4
 8005ffe:	f7ff fc1f 	bl	8005840 <chSemWaitTimeoutS>
  if (msg != MSG_OK) {
 8006002:	b968      	cbnz	r0, 8006020 <chGuardedPoolAllocTimeout.constprop.18+0x30>
  void *objp;

  chDbgCheckClassI();
  chDbgCheck(mp != NULL);

  objp = mp->next;
 8006004:	68e0      	ldr	r0, [r4, #12]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
 8006006:	b128      	cbz	r0, 8006014 <chGuardedPoolAllocTimeout.constprop.18+0x24>
    mp->next = mp->next->next;
 8006008:	6803      	ldr	r3, [r0, #0]
 800600a:	60e3      	str	r3, [r4, #12]
 800600c:	2300      	movs	r3, #0
 800600e:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8006012:	bd10      	pop	{r4, pc}
  objp = mp->next;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (objp != NULL) {
    mp->next = mp->next->next;
  }
  else if (mp->provider != NULL) {
 8006014:	6963      	ldr	r3, [r4, #20]
 8006016:	b143      	cbz	r3, 800602a <chGuardedPoolAllocTimeout.constprop.18+0x3a>
    objp = mp->provider(mp->object_size, PORT_NATURAL_ALIGN); /* TODO: Alignment is not properly handled */
 8006018:	6920      	ldr	r0, [r4, #16]
 800601a:	2104      	movs	r1, #4
 800601c:	4798      	blx	r3
 800601e:	e7f5      	b.n	800600c <chGuardedPoolAllocTimeout.constprop.18+0x1c>
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
    return NULL;
 8006020:	2000      	movs	r0, #0
 8006022:	2300      	movs	r3, #0
 8006024:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  p = chGuardedPoolAllocTimeoutS(gmp, timeout);
  chSysUnlock();

  return p;
}
 8006028:	bd10      	pop	{r4, pc}
                                 systime_t timeout) {
  msg_t msg;

  msg = chSemWaitTimeoutS(&gmp->sem, timeout);
  if (msg != MSG_OK) {
    return NULL;
 800602a:	4618      	mov	r0, r3
 800602c:	e7ee      	b.n	800600c <chGuardedPoolAllocTimeout.constprop.18+0x1c>
 800602e:	bf00      	nop
 8006030:	20000888 	.word	0x20000888
 8006034:	f3af 8000 	nop.w
 8006038:	f3af 8000 	nop.w
 800603c:	f3af 8000 	nop.w

08006040 <_pal_lld_setgroupmode.constprop.5>:
 * @param[in] mask      the group mask
 * @param[in] mode      the mode
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
 8006040:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8006044:	2200      	movs	r2, #0
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8006046:	2502      	movs	r5, #2
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8006048:	f04f 0c07 	mov.w	ip, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 800604c:	f04f 0e0f 	mov.w	lr, #15
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8006050:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8006054:	2701      	movs	r7, #1
      m2 = 3 << (bit * 2);
 8006056:	2603      	movs	r6, #3
 8006058:	e009      	b.n	800606e <_pal_lld_setgroupmode.constprop.5+0x2e>
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 800605a:	6a19      	ldr	r1, [r3, #32]
 800605c:	ea21 0109 	bic.w	r1, r1, r9
 8006060:	ea41 0108 	orr.w	r1, r1, r8
 8006064:	6219      	str	r1, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
      }
    }
    mask >>= 1;
    if (!mask)
 8006066:	0840      	lsrs	r0, r0, #1
 8006068:	d02d      	beq.n	80060c6 <_pal_lld_setgroupmode.constprop.5+0x86>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 800606a:	00ad      	lsls	r5, r5, #2
    bit++;
 800606c:	3201      	adds	r2, #1
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUPDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
 800606e:	07c1      	lsls	r1, r0, #31
 8006070:	d5f9      	bpl.n	8006066 <_pal_lld_setgroupmode.constprop.5+0x26>

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8006072:	6859      	ldr	r1, [r3, #4]
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
 8006074:	fa07 f402 	lsl.w	r4, r7, r2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8006078:	ea21 0104 	bic.w	r1, r1, r4
 800607c:	6059      	str	r1, [r3, #4]
 800607e:	0054      	lsls	r4, r2, #1
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8006080:	6899      	ldr	r1, [r3, #8]
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
 8006082:	fa06 f404 	lsl.w	r4, r6, r4
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8006086:	43e4      	mvns	r4, r4
 8006088:	4021      	ands	r1, r4
 800608a:	6099      	str	r1, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800608c:	f8d3 800c 	ldr.w	r8, [r3, #12]
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8006090:	f002 0107 	and.w	r1, r2, #7
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8006094:	ea04 0808 	and.w	r8, r4, r8
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8006098:	0089      	lsls	r1, r1, #2
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 800609a:	2d02      	cmp	r5, #2
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 800609c:	f8c3 800c 	str.w	r8, [r3, #12]
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m1 = 1 << bit;
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
 80060a0:	fa0e f901 	lsl.w	r9, lr, r1
  uint32_t bit     = 0;
  while (true) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 80060a4:	fa0c f801 	lsl.w	r8, ip, r1
      m2 = 3 << (bit * 2);
      m4 = 15 << ((bit & 7) * 4);
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
 80060a8:	d00f      	beq.n	80060ca <_pal_lld_setgroupmode.constprop.5+0x8a>
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80060aa:	6819      	ldr	r1, [r3, #0]
 80060ac:	400c      	ands	r4, r1
 80060ae:	432c      	orrs	r4, r5
        if (bit < 8)
 80060b0:	2a07      	cmp	r2, #7
        port->MODER   = (port->MODER & ~m2) | moder;
      }
      else {
        /* If going into a non-alternate mode then the mode is switched
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
 80060b2:	601c      	str	r4, [r3, #0]
        if (bit < 8)
 80060b4:	d9d1      	bls.n	800605a <_pal_lld_setgroupmode.constprop.5+0x1a>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80060b6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80060b8:	ea21 0109 	bic.w	r1, r1, r9
 80060bc:	ea41 0108 	orr.w	r1, r1, r8
      }
    }
    mask >>= 1;
    if (!mask)
 80060c0:	0840      	lsrs	r0, r0, #1
           before setting the alternate mode in order to avoid glitches.*/
        port->MODER   = (port->MODER & ~m2) | moder;
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80060c2:	6259      	str	r1, [r3, #36]	; 0x24
      }
    }
    mask >>= 1;
    if (!mask)
 80060c4:	d1d1      	bne.n	800606a <_pal_lld_setgroupmode.constprop.5+0x2a>
 80060c6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
      if (moder == PAL_STM32_MODE_ALTERNATE) {
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
 80060ca:	2a07      	cmp	r2, #7
 80060cc:	d80b      	bhi.n	80060e6 <_pal_lld_setgroupmode.constprop.5+0xa6>
          port->AFRL = (port->AFRL & ~m4) | altrmask;
 80060ce:	6a19      	ldr	r1, [r3, #32]
 80060d0:	ea21 0109 	bic.w	r1, r1, r9
 80060d4:	ea41 0108 	orr.w	r1, r1, r8
 80060d8:	6219      	str	r1, [r3, #32]
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
        port->MODER   = (port->MODER & ~m2) | moder;
 80060da:	6819      	ldr	r1, [r3, #0]
 80060dc:	400c      	ands	r4, r1
 80060de:	f044 0402 	orr.w	r4, r4, #2
 80060e2:	601c      	str	r4, [r3, #0]
 80060e4:	e7bf      	b.n	8006066 <_pal_lld_setgroupmode.constprop.5+0x26>
        /* If going in alternate mode then the alternate number is set
           before switching mode in order to avoid glitches.*/
        if (bit < 8)
          port->AFRL = (port->AFRL & ~m4) | altrmask;
        else
          port->AFRH = (port->AFRH & ~m4) | altrmask;
 80060e6:	6a59      	ldr	r1, [r3, #36]	; 0x24
 80060e8:	ea21 0109 	bic.w	r1, r1, r9
 80060ec:	ea41 0108 	orr.w	r1, r1, r8
 80060f0:	6259      	str	r1, [r3, #36]	; 0x24
 80060f2:	e7f2      	b.n	80060da <_pal_lld_setgroupmode.constprop.5+0x9a>
 80060f4:	f3af 8000 	nop.w
 80060f8:	f3af 8000 	nop.w
 80060fc:	f3af 8000 	nop.w

08006100 <_test_assert_time_window.constprop.2>:
 *
 * @notapi
 */
static inline systime_t st_lld_get_counter(void) {

  return (systime_t)STM32_ST_TIM->CNT;
 8006100:	f04f 4380 	mov.w	r3, #1073741824	; 0x40000000
 8006104:	1a09      	subs	r1, r1, r0
 8006106:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 8006108:	1a1b      	subs	r3, r3, r0
  return true;
}

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
 800610a:	428b      	cmp	r3, r1
 800610c:	d308      	bcc.n	8006120 <_test_assert_time_window.constprop.2+0x20>

bool _test_fail(const char *msg) {

  test_local_fail      = true;
  test_global_fail     = true;
  test_failure_message = msg;
 800610e:	4905      	ldr	r1, [pc, #20]	; (8006124 <_test_assert_time_window.constprop.2+0x24>)
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8006110:	4a05      	ldr	r2, [pc, #20]	; (8006128 <_test_assert_time_window.constprop.2+0x28>)
  test_global_fail     = true;
 8006112:	4b06      	ldr	r3, [pc, #24]	; (800612c <_test_assert_time_window.constprop.2+0x2c>)
  test_failure_message = msg;
 8006114:	4806      	ldr	r0, [pc, #24]	; (8006130 <_test_assert_time_window.constprop.2+0x30>)
 8006116:	6008      	str	r0, [r1, #0]
/* Module exported functions.                                                */
/*===========================================================================*/

bool _test_fail(const char *msg) {

  test_local_fail      = true;
 8006118:	2001      	movs	r0, #1
 800611a:	7010      	strb	r0, [r2, #0]
  test_global_fail     = true;
 800611c:	7018      	strb	r0, [r3, #0]
 800611e:	4770      	bx	lr

bool _test_assert(bool condition, const char *msg) {

  if (!condition)
    return _test_fail(msg);
  return false;
 8006120:	2000      	movs	r0, #0
                              systime_t end,
                              const char *msg) {

  return _test_assert(osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end),
                      msg);
}
 8006122:	4770      	bx	lr
 8006124:	20001428 	.word	0x20001428
 8006128:	2000146d 	.word	0x2000146d
 800612c:	2000146c 	.word	0x2000146c
 8006130:	08007468 	.word	0x08007468
 8006134:	f3af 8000 	nop.w
 8006138:	f3af 8000 	nop.w
 800613c:	f3af 8000 	nop.w
